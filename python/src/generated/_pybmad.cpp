#include <pybind11/complex.h>
#include <pybind11/native_enum.h>
#include <pybind11/numpy.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <string>

#include "json.hpp"
#include "pybmad/common_structs.hpp"
#include "pybmad/generated/init.hpp"

using namespace Bmad;
using namespace Pybmad;

using json = nlohmann::json;

namespace py = pybind11;
using namespace pybind11::literals;

template <typename T>
std::string instance_to_json(const T& self) {
  json j;
  to_json(j, self);
  return to_string(j);
}

template <typename T>
std::optional<std::reference_wrapper<T>> make_opt_ref(
    std::optional<T>& opt_val) {
  if (opt_val.has_value()) {
    return std::ref(opt_val.value());
  }
  return std::nullopt;
}

struct PyEleFullName {
  std::string str;
};
PyEleFullName python_ele_full_name(
    EleProxy& ele,
    std::optional<std::string> template_,
    std::string str) {
  Bmad::ele_full_name(ele, template_, str);
  auto py_result{PyEleFullName{str}};
  return py_result;
}
struct PyRfIsOn {
  bool is_on;
};
PyRfIsOn python_rf_is_on(
    BranchProxy& branch,
    std::optional<int> ix_ele1,
    std::optional<int> ix_ele2,
    bool is_on) {
  Bmad::rf_is_on(branch, ix_ele1, ix_ele2, is_on);
  auto py_result{PyRfIsOn{is_on}};
  return py_result;
}
struct PyDpcGivenDe {
  double pc_old;
  double mass;
  double dE;
  double dpc;
};
PyDpcGivenDe python_dpc_given_de(
    double pc_old,
    double mass,
    double dE,
    double dpc) {
  Bmad::dpc_given_de(pc_old, mass, dE, dpc);
  auto py_result{PyDpcGivenDe{pc_old, mass, dE, dpc}};
  return py_result;
}
struct PyLordEdgeAligned {
  bool is_aligned;
};
PyLordEdgeAligned python_lord_edge_aligned(
    EleProxy& slave,
    int slave_edge,
    EleProxy& lord,
    bool is_aligned) {
  Bmad::lord_edge_aligned(slave, slave_edge, lord, is_aligned);
  auto py_result{PyLordEdgeAligned{is_aligned}};
  return py_result;
}
struct PyEleLocName {
  std::string str;
};
PyEleLocName python_ele_loc_name(
    EleProxy& ele,
    std::optional<bool> show_branch0,
    std::optional<std::string> parens,
    std::string str) {
  Bmad::ele_loc_name(ele, show_branch0, parens, str);
  auto py_result{PyEleLocName{str}};
  return py_result;
}
struct PyRelativeModeFlip {
  bool func_retval__;
};
PyRelativeModeFlip python_relative_mode_flip(
    EleProxy& ele1,
    EleProxy& ele2,
    bool func_retval__) {
  Bmad::relative_mode_flip(ele1, ele2, func_retval__);
  auto py_result{PyRelativeModeFlip{func_retval__}};
  return py_result;
}
struct PyParticleIsMovingForward {
  bool is_moving_forward;
};
PyParticleIsMovingForward python_particle_is_moving_forward(
    CoordProxy& orbit,
    std::optional<int> dir,
    bool is_moving_forward) {
  Bmad::particle_is_moving_forward(orbit, dir, is_moving_forward);
  auto py_result{PyParticleIsMovingForward{is_moving_forward}};
  return py_result;
}
struct PyValidFieldCalc {
  bool is_valid;
};
PyValidFieldCalc python_valid_field_calc(
    EleProxy& ele,
    int field_calc,
    bool is_valid) {
  Bmad::valid_field_calc(ele, field_calc, is_valid);
  auto py_result{PyValidFieldCalc{is_valid}};
  return py_result;
}
struct PyGammaRef {
  double gamma;
};
PyGammaRef python_gamma_ref(EleProxy& ele, double gamma) {
  Bmad::gamma_ref(ele, gamma);
  auto py_result{PyGammaRef{gamma}};
  return py_result;
}
struct PyRelTrackingChargeToMass {
  double rel_charge;
};
PyRelTrackingChargeToMass python_rel_tracking_charge_to_mass(
    CoordProxy& orbit,
    int ref_species,
    double rel_charge) {
  Bmad::rel_tracking_charge_to_mass(orbit, ref_species, rel_charge);
  auto py_result{PyRelTrackingChargeToMass{rel_charge}};
  return py_result;
}
struct PyChromCalc : public Bmad::ChromCalc {
  double delta_e;
  PyChromCalc(Bmad::ChromCalc _base, double delta_e)
      : Bmad::ChromCalc(std::move(_base)), delta_e(delta_e) {}
};
PyChromCalc python_chrom_calc(
    LatProxy& lat,
    double delta_e,
    std::optional<double> pz = std::nullopt,
    std::optional<int> ix_branch = std::nullopt,
    optional_ref<CoordProxy> orb0 = std::nullopt) {
  auto _result = Bmad::chrom_calc(lat, delta_e, pz, ix_branch, orb0);
  auto py_result{PyChromCalc{_result, delta_e}};
  return py_result;
}
struct PyValidTrackingMethod {
  bool is_valid;
};
PyValidTrackingMethod python_valid_tracking_method(
    EleProxy& ele,
    int species,
    int tracking_method,
    bool is_valid) {
  Bmad::valid_tracking_method(ele, species, tracking_method, is_valid);
  auto py_result{PyValidTrackingMethod{is_valid}};
  return py_result;
}
struct PyAtThisEleEnd {
  bool is_at_this_end;
};
PyAtThisEleEnd python_at_this_ele_end(
    int now_at,
    int where_at,
    bool is_at_this_end) {
  Bmad::at_this_ele_end(now_at, where_at, is_at_this_end);
  auto py_result{PyAtThisEleEnd{is_at_this_end}};
  return py_result;
}
struct PySetTune {
  bool ok;
};
PySetTune python_set_tune(
    double phi_a_set,
    double phi_b_set,
    RealAlloc1D& dk1,
    ElePointerProxyAlloc1D& eles,
    BranchProxy& branch,
    CoordProxyAlloc1D& orb,
    std::optional<bool> print_err,
    bool ok) {
  Bmad::set_tune(phi_a_set, phi_b_set, dk1, eles, branch, orb, print_err, ok);
  auto py_result{PySetTune{ok}};
  return py_result;
}
struct PyOffsetParticle : public Bmad::OffsetParticle {
  std::optional<double> time;
  PyOffsetParticle(Bmad::OffsetParticle _base, std::optional<double> time)
      : Bmad::OffsetParticle(std::move(_base)), time(time) {}
};
PyOffsetParticle python_offset_particle(
    EleProxy& ele,
    bool set,
    CoordProxy& orbit,
    std::optional<bool> set_tilt = std::nullopt,
    std::optional<bool> set_hvkicks = std::nullopt,
    std::optional<int> drift_to_edge = std::nullopt,
    std::optional<double> s_pos = std::nullopt,
    std::optional<bool> set_spin = std::nullopt,
    std::optional<FixedArray2D<Real, 6, 6>> mat6 = std::nullopt,
    std::optional<bool> make_matrix = std::nullopt,
    std::optional<double> time = std::nullopt) {
  auto _result = Bmad::offset_particle(
      ele,
      set,
      orbit,
      set_tilt,
      set_hvkicks,
      drift_to_edge,
      s_pos,
      set_spin,
      mat6,
      make_matrix,
      make_opt_ref(time));
  auto py_result{PyOffsetParticle{_result, time}};
  return py_result;
}
struct PyKeyNameToKeyIndex {
  int key_index;
};
PyKeyNameToKeyIndex python_key_name_to_key_index(
    std::string key_str,
    std::optional<bool> abbrev_allowed,
    int key_index) {
  Bmad::key_name_to_key_index(key_str, abbrev_allowed, key_index);
  auto py_result{PyKeyNameToKeyIndex{key_index}};
  return py_result;
}
struct PyClassicalRadius {
  double radius;
};
PyClassicalRadius python_classical_radius(int species, double radius) {
  Bmad::classical_radius(species, radius);
  auto py_result{PyClassicalRadius{radius}};
  return py_result;
}
struct PyDefaultTrackingSpecies {
  int species;
};
PyDefaultTrackingSpecies python_default_tracking_species(
    LatParamProxy& param,
    int species) {
  Bmad::default_tracking_species(param, species);
  auto py_result{PyDefaultTrackingSpecies{species}};
  return py_result;
}
struct PyKnotsToString {
  std::string str;
};
PyKnotsToString python_knots_to_string(
    RealAlloc1D& x_knot,
    RealAlloc1D& y_knot,
    std::string str) {
  Bmad::knots_to_string(x_knot, y_knot, str);
  auto py_result{PyKnotsToString{str}};
  return py_result;
}
struct PyEleHasNonzeroOffset {
  bool has_offset;
};
PyEleHasNonzeroOffset python_ele_has_nonzero_offset(
    EleProxy& ele,
    bool has_offset) {
  Bmad::ele_has_nonzero_offset(ele, has_offset);
  auto py_result{PyEleHasNonzeroOffset{has_offset}};
  return py_result;
}
struct PyFringeHere {
  bool is_here;
};
PyFringeHere python_fringe_here(
    EleProxy& ele,
    CoordProxy& orbit,
    int particle_at,
    bool is_here) {
  Bmad::fringe_here(ele, orbit, particle_at, is_here);
  auto py_result{PyFringeHere{is_here}};
  return py_result;
}

struct PyChromTune {
  bool err_flag;
  double delta_e;
};
PyChromTune python_chrom_tune(
    LatProxy& lat,
    double delta_e,
    double target_x,
    double target_y,
    double err_tol) {
  auto _result = Bmad::chrom_tune(lat, delta_e, target_x, target_y, err_tol);
  auto py_result{PyChromTune{_result, delta_e}};
  return py_result;
}
struct PyEleUniqueName {
  std::string unique_name;
};
PyEleUniqueName python_ele_unique_name(
    EleProxy& ele,
    LatEleOrderProxy& order,
    std::string unique_name) {
  Bmad::ele_unique_name(ele, order, unique_name);
  auto py_result{PyEleUniqueName{unique_name}};
  return py_result;
}
struct PyEleValueHasChanged {
  bool has_changed;
};
PyEleValueHasChanged python_ele_value_has_changed(
    EleProxy& ele,
    IntAlloc1D& list,
    RealAlloc1D& abs_tol,
    bool set_old,
    bool has_changed) {
  Bmad::ele_value_has_changed(ele, list, abs_tol, set_old, has_changed);
  auto py_result{PyEleValueHasChanged{has_changed}};
  return py_result;
}
struct PySignificantDifference {
  bool is_different;
};
PySignificantDifference python_significant_difference(
    double value1,
    double value2,
    std::optional<double> abs_tol,
    std::optional<double> rel_tol,
    bool is_different) {
  Bmad::significant_difference(value1, value2, abs_tol, rel_tol, is_different);
  auto py_result{PySignificantDifference{is_different}};
  return py_result;
}

struct PyValueOfAttribute {
  bool err_flag;
  double value;
};
PyValueOfAttribute python_value_of_attribute(
    EleProxy& ele,
    std::string attrib_name,
    std::optional<bool> err_print_flag,
    std::optional<double> err_value,
    double value) {
  auto _result = Bmad::value_of_attribute(
      ele, attrib_name, err_print_flag, err_value, value);
  auto py_result{PyValueOfAttribute{_result, value}};
  return py_result;
}
struct PyEquivalentTaylorAttributes {
  bool equiv;
};
PyEquivalentTaylorAttributes python_equivalent_taylor_attributes(
    EleProxy& ele_taylor,
    EleProxy& ele2,
    bool equiv) {
  Bmad::equivalent_taylor_attributes(ele_taylor, ele2, equiv);
  auto py_result{PyEquivalentTaylorAttributes{equiv}};
  return py_result;
}
struct PyNumLords {
  int num;
};
PyNumLords python_num_lords(EleProxy& slave, int lord_type, int num) {
  Bmad::num_lords(slave, lord_type, num);
  auto py_result{PyNumLords{num}};
  return py_result;
}
struct PyTaperMagStrengths {
  std::optional<bool> err_flag;
};
PyTaperMagStrengths python_taper_mag_strengths(
    LatProxy& lat,
    optional_ref<LatProxy> ref_lat = std::nullopt,
    std::optional<std::string> except = std::nullopt,
    std::optional<bool> err_flag = std::nullopt) {
  Bmad::taper_mag_strengths(lat, ref_lat, except, make_opt_ref(err_flag));
  auto py_result{PyTaperMagStrengths{err_flag}};
  return py_result;
}
struct PyParticleIsMovingBackwards {
  bool is_moving_backwards;
};
PyParticleIsMovingBackwards python_particle_is_moving_backwards(
    CoordProxy& orbit,
    bool is_moving_backwards) {
  Bmad::particle_is_moving_backwards(orbit, is_moving_backwards);
  auto py_result{PyParticleIsMovingBackwards{is_moving_backwards}};
  return py_result;
}
struct PyValidFringeType {
  bool is_valid;
};
PyValidFringeType python_valid_fringe_type(
    EleProxy& ele,
    int fringe_type,
    bool is_valid) {
  Bmad::valid_fringe_type(ele, fringe_type, is_valid);
  auto py_result{PyValidFringeType{is_valid}};
  return py_result;
}

struct PyLatEleLocator {
  bool err;
  int n_loc;
};
PyLatEleLocator python_lat_ele_locator(
    std::string loc_str,
    LatProxy& lat,
    ElePointerProxyAlloc1D& eles,
    int n_loc,
    std::optional<bool> above_ubound_is_err = std::nullopt,
    std::optional<int> ix_dflt_branch = std::nullopt,
    std::optional<bool> order_by_index = std::nullopt,
    std::optional<bool> append_eles = std::nullopt) {
  auto _result = Bmad::lat_ele_locator(
      loc_str,
      lat,
      eles,
      n_loc,
      above_ubound_is_err,
      ix_dflt_branch,
      order_by_index,
      append_eles);
  auto py_result{PyLatEleLocator{_result, n_loc}};
  return py_result;
}
struct PyStreamEleEnd {
  int stream_end;
};
PyStreamEleEnd python_stream_ele_end(
    int physical_end,
    int ele_orientation,
    int stream_end) {
  Bmad::stream_ele_end(physical_end, ele_orientation, stream_end);
  auto py_result{PyStreamEleEnd{stream_end}};
  return py_result;
}
struct PyValidMat6CalcMethod {
  bool is_valid;
};
PyValidMat6CalcMethod python_valid_mat6_calc_method(
    EleProxy& ele,
    int species,
    int mat6_calc_method,
    bool is_valid) {
  Bmad::valid_mat6_calc_method(ele, species, mat6_calc_method, is_valid);
  auto py_result{PyValidMat6CalcMethod{is_valid}};
  return py_result;
}
struct PyEAccelField {
  double field;
};
PyEAccelField python_e_accel_field(
    EleProxy& ele,
    int voltage_or_gradient,
    std::optional<bool> bmad_standard_tracking,
    double field) {
  Bmad::e_accel_field(ele, voltage_or_gradient, bmad_standard_tracking, field);
  auto py_result{PyEAccelField{field}};
  return py_result;
}
struct PyRadiationIntegrals : public Bmad::RadiationIntegrals {
  std::optional<int> ix_cache;
  PyRadiationIntegrals(
      Bmad::RadiationIntegrals _base,
      std::optional<int> ix_cache)
      : Bmad::RadiationIntegrals(std::move(_base)), ix_cache(ix_cache) {}
};
PyRadiationIntegrals python_radiation_integrals(
    LatProxy& lat,
    CoordProxyAlloc1D& orbit,
    std::optional<int> ix_cache = std::nullopt,
    std::optional<int> ix_branch = std::nullopt) {
  auto _result =
      Bmad::radiation_integrals(lat, orbit, make_opt_ref(ix_cache), ix_branch);
  auto py_result{PyRadiationIntegrals{_result, ix_cache}};
  return py_result;
}

struct PyEleHasNonzeroKick {
  EleProxy ele;
  bool has_kick;
};
PyEleHasNonzeroKick python_ele_has_nonzero_kick(bool has_kick) {
  auto _result = Bmad::ele_has_nonzero_kick(has_kick);
  auto py_result{PyEleHasNonzeroKick{_result, has_kick}};
  return py_result;
}
struct PyParticleRfTime {
  long double time;
};
PyParticleRfTime python_particle_rf_time(
    CoordProxy& orbit,
    EleProxy& ele,
    std::optional<bool> reference_active_edge,
    std::optional<double> s_rel,
    std::optional<bool> time_coords,
    std::optional<double> rf_freq,
    std::optional<bool> abs_time,
    long double time) {
  Bmad::particle_rf_time(
      orbit,
      ele,
      reference_active_edge,
      s_rel,
      time_coords,
      rf_freq,
      abs_time,
      time);
  auto py_result{PyParticleRfTime{time}};
  return py_result;
}
struct PyBranchName {
  std::string name;
};
PyBranchName python_branch_name(BranchProxy& branch, std::string name) {
  Bmad::branch_name(branch, name);
  auto py_result{PyBranchName{name}};
  return py_result;
}
struct PySetFringeOnOff {
  double fringe_at;
};
PySetFringeOnOff python_set_fringe_on_off(
    double fringe_at,
    int ele_end,
    int on_or_off) {
  Bmad::set_fringe_on_off(fringe_at, ele_end, on_or_off);
  auto py_result{PySetFringeOnOff{fringe_at}};
  return py_result;
}
struct PyMomentumCompaction {
  double mom_comp;
};
PyMomentumCompaction python_momentum_compaction(
    BranchProxy& branch,
    double mom_comp) {
  Bmad::momentum_compaction(branch, mom_comp);
  auto py_result{PyMomentumCompaction{mom_comp}};
  return py_result;
}
struct PyCoordsRelativeToFloor {
  std::optional<double> theta;
  std::optional<double> phi;
  std::optional<double> psi;
};
PyCoordsRelativeToFloor python_coords_relative_to_floor(
    FloorPositionProxy& floor0,
    FixedArray1D<Real, 3> dr,
    std::optional<double> theta,
    std::optional<double> phi,
    std::optional<double> psi,
    FloorPositionProxy& floor1) {
  Bmad::coords_relative_to_floor(
      floor0,
      dr,
      make_opt_ref(theta),
      make_opt_ref(phi),
      make_opt_ref(psi),
      floor1);
  auto py_result{PyCoordsRelativeToFloor{theta, phi, psi}};
  return py_result;
}
struct PyPatchFlipsPropagationDirection {
  bool is_flip;
};
PyPatchFlipsPropagationDirection python_patch_flips_propagation_direction(
    double x_pitch,
    double y_pitch,
    bool is_flip) {
  Bmad::patch_flips_propagation_direction(x_pitch, y_pitch, is_flip);
  auto py_result{PyPatchFlipsPropagationDirection{is_flip}};
  return py_result;
}
struct PySBodyCalc {
  double s_body;
};
PySBodyCalc python_s_body_calc(
    CoordProxy& orbit,
    EleProxy& ele,
    double s_body) {
  Bmad::s_body_calc(orbit, ele, s_body);
  auto py_result{PySBodyCalc{s_body}};
  return py_result;
}
struct PyWriteBlenderLatLayout {
  std::string file_name;
};
PyWriteBlenderLatLayout python_write_blender_lat_layout(
    std::string file_name,
    LatProxy& lat) {
  Bmad::write_blender_lat_layout(file_name, lat);
  auto py_result{PyWriteBlenderLatLayout{file_name}};
  return py_result;
}
struct PySkipEleBlender {
  bool skip;
};
PySkipEleBlender python_skip_ele_blender(EleProxy& ele, bool skip) {
  Bmad::skip_ele_blender(ele, skip);
  auto py_result{PySkipEleBlender{skip}};
  return py_result;
}
struct PyWriteBlenderEle {
  int iu;
  std::optional<bool> old_format;
};
PyWriteBlenderEle python_write_blender_ele(
    int iu,
    EleProxy& ele,
    std::optional<bool> old_format = std::nullopt) {
  Bmad::write_blender_ele(iu, ele, make_opt_ref(old_format));
  auto py_result{PyWriteBlenderEle{iu, old_format}};
  return py_result;
}
struct PyWriteAstraBend {
  int iu;
  double strength;
  int id;
};
PyWriteAstraBend python_write_astra_bend(
    int iu,
    double strength,
    int id,
    FixedArray1D<Real, 2> d1,
    FixedArray1D<Real, 2> d2,
    FixedArray1D<Real, 2> d3,
    FixedArray1D<Real, 2> d4) {
  Bmad::write_astra_bend(iu, strength, id, d1, d2, d3, d4);
  auto py_result{PyWriteAstraBend{iu, strength, id}};
  return py_result;
}
struct PyRotate3 {
  double angle;
};
PyRotate3 python_rotate3(
    FixedArray1D<Real, 3> vec,
    double angle,
    FixedArray1D<Real, 3> rvec) {
  Bmad::rotate3(vec, angle, rvec);
  auto py_result{PyRotate3{angle}};
  return py_result;
}
struct PyAstraMaxFieldReference {
  double field_value;
};
PyAstraMaxFieldReference python_astra_max_field_reference(
    GridFieldPt1Proxy& pt0,
    EleProxy& ele,
    double field_value) {
  Bmad::astra_max_field_reference(pt0, ele, field_value);
  auto py_result{PyAstraMaxFieldReference{field_value}};
  return py_result;
}
struct PyGptFieldGridScaling {
  int dimensions;
  double field_scale;
  double ref_time;
};
PyGptFieldGridScaling python_gpt_field_grid_scaling(
    EleProxy& ele,
    int dimensions,
    double field_scale,
    double ref_time) {
  Bmad::gpt_field_grid_scaling(ele, dimensions, field_scale, ref_time);
  auto py_result{PyGptFieldGridScaling{dimensions, field_scale, ref_time}};
  return py_result;
}
struct PyGptMaxFieldReference {
  double field_value;
};
PyGptMaxFieldReference python_gpt_max_field_reference(
    GridFieldPt1Proxy& pt0,
    EleProxy& ele,
    double field_value) {
  Bmad::gpt_max_field_reference(pt0, ele, field_value);
  auto py_result{PyGptMaxFieldReference{field_value}};
  return py_result;
}
struct PyRotateFieldZx {
  double theta;
};
PyRotateFieldZx python_rotate_field_zx(EmFieldProxy& field, double theta) {
  Bmad::rotate_field_zx(field, theta);
  auto py_result{PyRotateFieldZx{theta}};
  return py_result;
}
struct PyConvertLocalCurvilinearToLocalCartesian {
  double x;
  double s;
  double g;
  double xout;
  double zout;
};
PyConvertLocalCurvilinearToLocalCartesian
python_convert_local_curvilinear_to_local_cartesian(
    double x,
    double s,
    double g,
    double xout,
    double zout) {
  Bmad::convert_local_curvilinear_to_local_cartesian(x, s, g, xout, zout);
  auto py_result{
      PyConvertLocalCurvilinearToLocalCartesian{x, s, g, xout, zout}};
  return py_result;
}
struct PyConvertLocalCartesianToLocalCurvilinear {
  double x;
  double z;
  double g;
  double xout;
  double sout;
};
PyConvertLocalCartesianToLocalCurvilinear
python_convert_local_cartesian_to_local_curvilinear(
    double x,
    double z,
    double g,
    double xout,
    double sout) {
  Bmad::convert_local_cartesian_to_local_curvilinear(x, z, g, xout, sout);
  auto py_result{
      PyConvertLocalCartesianToLocalCurvilinear{x, z, g, xout, sout}};
  return py_result;
}
struct PyEleNametableIndex {
  int ix_nt;
};
PyEleNametableIndex python_ele_nametable_index(EleProxy& ele, int ix_nt) {
  Bmad::ele_nametable_index(ele, ix_nt);
  auto py_result{PyEleNametableIndex{ix_nt}};
  return py_result;
}
struct PyAcKickerAmp {
  double ac_amp;
};
PyAcKickerAmp python_ac_kicker_amp(
    EleProxy& ele,
    CoordProxy& orbit,
    std::optional<double> true_time,
    double ac_amp) {
  Bmad::ac_kicker_amp(ele, orbit, true_time, ac_amp);
  auto py_result{PyAcKickerAmp{ac_amp}};
  return py_result;
}
struct PyLowEnergyZCorrection {
  double dz;
};
PyLowEnergyZCorrection python_low_energy_z_correction(
    CoordProxy& orbit,
    EleProxy& ele,
    double ds,
    std::optional<FixedArray2D<Real, 6, 6>> mat6,
    std::optional<bool> make_matrix,
    double dz) {
  Bmad::low_energy_z_correction(orbit, ele, ds, mat6, make_matrix, dz);
  auto py_result{PyLowEnergyZCorrection{dz}};
  return py_result;
}
struct PySolQuadMat6Calc {
  double ks_in;
  double k1_in;
};
PySolQuadMat6Calc python_sol_quad_mat6_calc(
    double ks_in,
    double k1_in,
    double tilt,
    double length,
    EleProxy& ele,
    CoordProxy& orbit,
    std::optional<FixedArray2D<Real, 6, 6>> mat6 = std::nullopt,
    std::optional<bool> make_matrix = std::nullopt) {
  Bmad::sol_quad_mat6_calc(
      ks_in, k1_in, tilt, length, ele, orbit, mat6, make_matrix);
  auto py_result{PySolQuadMat6Calc{ks_in, k1_in}};
  return py_result;
}
struct PyEleRfStepIndex {
  int ix_step;
};
PyEleRfStepIndex python_ele_rf_step_index(
    double E_ref,
    double s_rel,
    EleProxy& ele,
    int ix_step) {
  Bmad::ele_rf_step_index(E_ref, s_rel, ele, ix_step);
  auto py_result{PyEleRfStepIndex{ix_step}};
  return py_result;
}
struct PyAbsoluteTimeTracking {
  bool is_abs_time;
};
PyAbsoluteTimeTracking python_absolute_time_tracking(
    EleProxy& ele,
    bool is_abs_time) {
  Bmad::absolute_time_tracking(ele, is_abs_time);
  auto py_result{PyAbsoluteTimeTracking{is_abs_time}};
  return py_result;
}

struct PyKnotInterpolate {
  bool err_flag;
  double y_pt;
};
PyKnotInterpolate python_knot_interpolate(
    RealAlloc1D& x_knot,
    RealAlloc1D& y_knot,
    double x_pt,
    int interpolation,
    double y_pt) {
  auto _result =
      Bmad::knot_interpolate(x_knot, y_knot, x_pt, interpolation, y_pt);
  auto py_result{PyKnotInterpolate{_result, y_pt}};
  return py_result;
}
struct PyPatchLength {
  double length;
};
PyPatchLength python_patch_length(
    EleProxy& patch,
    std::optional<int> ref_coords,
    double length) {
  Bmad::patch_length(patch, ref_coords, length);
  auto py_result{PyPatchLength{length}};
  return py_result;
}
struct PyPhysicalEleEnd {
  int physical_end;
};
PyPhysicalEleEnd python_physical_ele_end(
    int track_end,
    CoordProxy& orbit,
    int ele_orientation,
    std::optional<bool> return_stream_end,
    int physical_end) {
  Bmad::physical_ele_end(
      track_end, orbit, ele_orientation, return_stream_end, physical_end);
  auto py_result{PyPhysicalEleEnd{physical_end}};
  return py_result;
}
struct PyNumFieldEles {
  int n_field_ele;
};
PyNumFieldEles python_num_field_eles(EleProxy& ele, int n_field_ele) {
  Bmad::num_field_eles(ele, n_field_ele);
  auto py_result{PyNumFieldEles{n_field_ele}};
  return py_result;
}
struct PyEnteringElement {
  bool is_entering;
};
PyEnteringElement python_entering_element(
    CoordProxy& orbit,
    int particle_at,
    bool is_entering) {
  Bmad::entering_element(orbit, particle_at, is_entering);
  auto py_result{PyEnteringElement{is_entering}};
  return py_result;
}

struct PyTrackAPickup {
  std::optional<FixedArray2D<Real, 6, 6>> mat6;
  std::optional<bool> err_flag;
};
PyTrackAPickup python_track_a_pickup(
    CoordProxy& orbit,
    EleProxy& ele,
    LatParamProxy& param,
    std::optional<bool> err_flag = std::nullopt,
    std::optional<bool> make_matrix = std::nullopt) {
  auto _result = Bmad::track_a_pickup(
      orbit, ele, param, make_opt_ref(err_flag), make_matrix);
  auto py_result{PyTrackAPickup{_result, err_flag}};
  return py_result;
}
struct PyTrackADrift {
  std::optional<double> time;
};
PyTrackADrift python_track_a_drift(
    CoordProxy& orb,
    double length,
    std::optional<FixedArray2D<Real, 6, 6>> mat6 = std::nullopt,
    std::optional<bool> make_matrix = std::nullopt,
    std::optional<int> ele_orientation = std::nullopt,
    std::optional<bool> include_ref_motion = std::nullopt,
    std::optional<double> time = std::nullopt) {
  Bmad::track_a_drift(
      orb,
      length,
      mat6,
      make_matrix,
      ele_orientation,
      include_ref_motion,
      make_opt_ref(time));
  auto py_result{PyTrackADrift{time}};
  return py_result;
}

struct PyMakeMat6Taylor {
  CoordProxy end_orb;
  std::optional<bool> err_flag;
};
PyMakeMat6Taylor python_make_mat6_taylor(
    EleProxy& ele,
    CoordProxy& start_orb,
    std::optional<bool> err_flag = std::nullopt) {
  auto _result = Bmad::make_mat6_taylor(ele, start_orb, make_opt_ref(err_flag));
  auto py_result{PyMakeMat6Taylor{_result, err_flag}};
  return py_result;
}
struct PyMasterParameterValue {
  double value;
};
PyMasterParameterValue python_master_parameter_value(
    int master_parameter,
    EleProxy& ele,
    double value) {
  Bmad::master_parameter_value(master_parameter, ele, value);
  auto py_result{PyMasterParameterValue{value}};
  return py_result;
}

struct PyDistanceToAperture {
  bool no_aperture_here;
  double dist;
};
PyDistanceToAperture python_distance_to_aperture(
    CoordProxy& orbit,
    int particle_at,
    EleProxy& ele,
    double dist) {
  auto _result = Bmad::distance_to_aperture(orbit, particle_at, ele, dist);
  auto py_result{PyDistanceToAperture{_result, dist}};
  return py_result;
}
struct PySetFlagsForChangedIntegerAttribute {
  int attrib;
};
PySetFlagsForChangedIntegerAttribute
python_set_flags_for_changed_integer_attribute(
    EleProxy& ele,
    int attrib,
    std::optional<bool> set_dependent = std::nullopt) {
  Bmad::set_flags_for_changed_attribute(ele, attrib, set_dependent);
  auto py_result{PySetFlagsForChangedIntegerAttribute{attrib}};
  return py_result;
}
struct PySetFlagsForChangedLogicalAttribute {
  bool attrib;
};
PySetFlagsForChangedLogicalAttribute
python_set_flags_for_changed_logical_attribute(
    EleProxy& ele,
    bool attrib,
    std::optional<bool> set_dependent = std::nullopt) {
  Bmad::set_flags_for_changed_attribute(ele, attrib, set_dependent);
  auto py_result{PySetFlagsForChangedLogicalAttribute{attrib}};
  return py_result;
}
struct PySetFlagsForChangedRealAttribute {
  std::optional<double> attrib;
};
PySetFlagsForChangedRealAttribute python_set_flags_for_changed_real_attribute(
    EleProxy& ele,
    std::optional<double> attrib = std::nullopt,
    std::optional<bool> set_dependent = std::nullopt) {
  Bmad::set_flags_for_changed_attribute(
      ele, make_opt_ref(attrib), set_dependent);
  auto py_result{PySetFlagsForChangedRealAttribute{attrib}};
  return py_result;
}

struct PyMat4Multipole {
  FixedArray2D<Real, 4, 4> kick_mat;
  int n;
};
PyMat4Multipole python_mat4_multipole(
    double knl,
    double tilt,
    int n,
    CoordProxy& orbit) {
  auto _result = Bmad::mat4_multipole(knl, tilt, n, orbit);
  auto py_result{PyMat4Multipole{_result, n}};
  return py_result;
}
struct PyBendLengthHasBeenSet {
  bool is_set;
};
PyBendLengthHasBeenSet python_bend_length_has_been_set(
    EleProxy& ele,
    bool is_set) {
  Bmad::bend_length_has_been_set(ele, is_set);
  auto py_result{PyBendLengthHasBeenSet{is_set}};
  return py_result;
}
struct PyRfRefTimeOffset {
  double time;
};
PyRfRefTimeOffset python_rf_ref_time_offset(
    EleProxy& ele,
    std::optional<double> ds,
    double time) {
  Bmad::rf_ref_time_offset(ele, ds, time);
  auto py_result{PyRfRefTimeOffset{time}};
  return py_result;
}
struct PyTrack1TimeRungeKutta : public Bmad::Track1TimeRungeKutta {
  std::optional<double> dt_step;
  PyTrack1TimeRungeKutta(
      Bmad::Track1TimeRungeKutta _base,
      std::optional<double> dt_step)
      : Bmad::Track1TimeRungeKutta(std::move(_base)), dt_step(dt_step) {}
};
PyTrack1TimeRungeKutta python_track1_time_runge_kutta(
    CoordProxy& orbit,
    EleProxy& ele,
    LatParamProxy& param,
    std::optional<double> t_end = std::nullopt,
    std::optional<double> dt_step = std::nullopt) {
  auto _result = Bmad::track1_time_runge_kutta(
      orbit, ele, param, t_end, make_opt_ref(dt_step));
  auto py_result{PyTrack1TimeRungeKutta{_result, dt_step}};
  return py_result;
}
struct PyStrongBeamStrength {
  double strength;
};
PyStrongBeamStrength python_strong_beam_strength(
    EleProxy& ele,
    double strength) {
  Bmad::strong_beam_strength(ele, strength);
  auto py_result{PyStrongBeamStrength{strength}};
  return py_result;
}

struct PyRamperValue {
  bool err_flag;
  double value;
};
PyRamperValue python_ramper_value(
    EleProxy& ramper,
    ControlRamp1Proxy& r1,
    double value) {
  auto _result = Bmad::ramper_value(ramper, r1, value);
  auto py_result{PyRamperValue{_result, value}};
  return py_result;
}

struct PyTrackAMatch {
  std::optional<FixedArray2D<Real, 6, 6>> mat6;
  std::optional<bool> err_flag;
};
PyTrackAMatch python_track_a_match(
    CoordProxy& orbit,
    EleProxy& ele,
    LatParamProxy& param,
    std::optional<bool> err_flag = std::nullopt,
    std::optional<bool> make_matrix = std::nullopt) {
  auto _result = Bmad::track_a_match(
      orbit, ele, param, make_opt_ref(err_flag), make_matrix);
  auto py_result{PyTrackAMatch{_result, err_flag}};
  return py_result;
}
struct PyDiffractionPlateOrMaskHitSpot {
  int ix_section;
};
PyDiffractionPlateOrMaskHitSpot python_diffraction_plate_or_mask_hit_spot(
    EleProxy& ele,
    CoordProxy& orbit,
    int ix_section) {
  Bmad::diffraction_plate_or_mask_hit_spot(ele, orbit, ix_section);
  auto py_result{PyDiffractionPlateOrMaskHitSpot{ix_section}};
  return py_result;
}
struct PyMexp {
  double this_exp;
};
PyMexp python_mexp(double x, int m, double this_exp) {
  Bmad::mexp(x, m, this_exp);
  auto py_result{PyMexp{this_exp}};
  return py_result;
}
struct PyEleHasConstantDsDtRef {
  bool is_const;
};
PyEleHasConstantDsDtRef python_ele_has_constant_ds_dt_ref(
    EleProxy& ele,
    bool is_const) {
  Bmad::ele_has_constant_ds_dt_ref(ele, is_const);
  auto py_result{PyEleHasConstantDsDtRef{is_const}};
  return py_result;
}

struct PyOrbitTooLarge {
  LatParamProxy param;
  bool is_too_large;
};
PyOrbitTooLarge python_orbit_too_large(
    CoordProxy& orbit,
    std::optional<bool> check_momentum,
    bool is_too_large) {
  auto _result = Bmad::orbit_too_large(orbit, check_momentum, is_too_large);
  auto py_result{PyOrbitTooLarge{_result, is_too_large}};
  return py_result;
}
struct PyOdeintBmadTime : public Bmad::OdeintBmadTime {
  double rf_time;
  PyOdeintBmadTime(Bmad::OdeintBmadTime _base, double rf_time)
      : Bmad::OdeintBmadTime(std::move(_base)), rf_time(rf_time) {}
};
PyOdeintBmadTime python_odeint_bmad_time(
    CoordProxy& orb,
    EleProxy& ele,
    LatParamProxy& param,
    int t_dir,
    double rf_time,
    optional_ref<TrackProxy> track = std::nullopt,
    std::optional<double> t_end = std::nullopt,
    optional_ref<EmFieldProxy> extra_field = std::nullopt) {
  auto _result = Bmad::odeint_bmad_time(
      orb, ele, param, t_dir, rf_time, track, t_end, extra_field);
  auto py_result{PyOdeintBmadTime{_result, rf_time}};
  return py_result;
}
struct PyRkAdaptiveTimeStep {
  int t_dir;
  double rf_time;
  double dt_try;
  double dt_did;
  double dt_next;
  bool err_flag;
};
PyRkAdaptiveTimeStep python_rk_adaptive_time_step(
    EleProxy& ele,
    LatParamProxy& param,
    CoordProxy& orb,
    int t_dir,
    double rf_time,
    double dt_try,
    double dt_did,
    double dt_next,
    bool err_flag,
    optional_ref<EmFieldProxy> extra_field = std::nullopt) {
  Bmad::rk_adaptive_time_step(
      ele,
      param,
      orb,
      t_dir,
      rf_time,
      dt_try,
      dt_did,
      dt_next,
      err_flag,
      extra_field);
  auto py_result{
      PyRkAdaptiveTimeStep{t_dir, rf_time, dt_try, dt_did, dt_next, err_flag}};
  return py_result;
}

struct PyRkTimeStep1 {
  FixedArray1D<Real, 10> r_err;
  bool err_flag;
  std::optional<bool> print_err;
};
PyRkTimeStep1 python_rk_time_step1(
    EleProxy& ele,
    LatParamProxy& param,
    double rf_time,
    CoordProxy& orb,
    double dt,
    CoordProxy& new_orb,
    std::optional<FixedArray1D<Real, 10>> dr_dt,
    bool err_flag,
    std::optional<bool> print_err = std::nullopt,
    optional_ref<EmFieldProxy> extra_field = std::nullopt) {
  auto _result = Bmad::rk_time_step1(
      ele,
      param,
      rf_time,
      orb,
      dt,
      new_orb,
      dr_dt,
      err_flag,
      make_opt_ref(print_err),
      extra_field);
  auto py_result{PyRkTimeStep1{_result, err_flag, print_err}};
  return py_result;
}
struct PyToFieldmapCoords {
  double x;
  double y;
  double z;
  double cos_ang;
  double sin_ang;
};
PyToFieldmapCoords python_to_fieldmap_coords(
    EleProxy& ele,
    CoordProxy& local_orb,
    double s_body,
    int ele_anchor_pt,
    FixedArray1D<Real, 3> r0,
    bool curved_ref_frame,
    double x,
    double y,
    double z,
    double cos_ang,
    double sin_ang,
    bool err_flag) {
  Bmad::to_fieldmap_coords(
      ele,
      local_orb,
      s_body,
      ele_anchor_pt,
      r0,
      curved_ref_frame,
      x,
      y,
      z,
      cos_ang,
      sin_ang,
      err_flag);
  auto py_result{PyToFieldmapCoords{x, y, z, cos_ang, sin_ang}};
  return py_result;
}

struct PyEmFieldDerivatives {
  EmFieldProxy dfield;
  double s_pos;
  bool local_ref_frame;
  std::optional<bool> grid_allow_s_out_of_bounds;
  std::optional<double> rf_time;
};
PyEmFieldDerivatives python_em_field_derivatives(
    EleProxy& ele,
    LatParamProxy& param,
    double s_pos,
    CoordProxy& orbit,
    bool local_ref_frame,
    std::optional<bool> grid_allow_s_out_of_bounds = std::nullopt,
    std::optional<double> rf_time = std::nullopt) {
  auto _result = Bmad::em_field_derivatives(
      ele,
      param,
      s_pos,
      orbit,
      local_ref_frame,
      make_opt_ref(grid_allow_s_out_of_bounds),
      make_opt_ref(rf_time));
  auto py_result{PyEmFieldDerivatives{
      _result, s_pos, local_ref_frame, grid_allow_s_out_of_bounds, rf_time}};
  return py_result;
}
struct PyGenGradField {
  double rho;
  double theta;
};
PyGenGradField python_gen_grad_field(
    RealAlloc1D& deriv,
    GenGrad1Proxy& gg,
    double rho,
    double theta,
    FixedArray1D<Real, 3> field) {
  Bmad::gen_grad_field(deriv, gg, rho, theta, field);
  auto py_result{PyGenGradField{rho, theta}};
  return py_result;
}
struct PyMakeupGroupLord {
  bool err_flag;
};
PyMakeupGroupLord python_makeup_group_lord(
    LatProxy& lat,
    EleProxy& lord,
    bool err_flag) {
  Bmad::makeup_group_lord(lat, lord, err_flag);
  auto py_result{PyMakeupGroupLord{err_flag}};
  return py_result;
}
struct PyMakeupMultipassSlave {
  bool err_flag;
};
PyMakeupMultipassSlave python_makeup_multipass_slave(
    LatProxy& lat,
    EleProxy& slave,
    bool err_flag) {
  Bmad::makeup_multipass_slave(lat, slave, err_flag);
  auto py_result{PyMakeupMultipassSlave{err_flag}};
  return py_result;
}
struct PyMakeupSuperSlave {
  bool err_flag;
};
PyMakeupSuperSlave python_makeup_super_slave(
    LatProxy& lat,
    EleProxy& slave,
    bool err_flag) {
  Bmad::makeup_super_slave(lat, slave, err_flag);
  auto py_result{PyMakeupSuperSlave{err_flag}};
  return py_result;
}
struct PyMakeupControlSlave {
  bool err_flag;
};
PyMakeupControlSlave python_makeup_control_slave(
    LatProxy& lat,
    EleProxy& slave,
    bool err_flag) {
  Bmad::makeup_control_slave(lat, slave, err_flag);
  auto py_result{PyMakeupControlSlave{err_flag}};
  return py_result;
}
struct PyEqSpline {
  bool is_eq;
};
PyEqSpline python_eq_spline(SplineProxy& f1, SplineProxy& f2, bool is_eq) {
  Bmad::eq_spline(f1, f2, is_eq);
  auto py_result{PyEqSpline{is_eq}};
  return py_result;
}
struct PyEqSpinPolar {
  bool is_eq;
};
PyEqSpinPolar python_eq_spin_polar(
    SpinPolarProxy& f1,
    SpinPolarProxy& f2,
    bool is_eq) {
  Bmad::eq_spin_polar(f1, f2, is_eq);
  auto py_result{PyEqSpinPolar{is_eq}};
  return py_result;
}
struct PyEqAcKickerTime {
  bool is_eq;
};
PyEqAcKickerTime python_eq_ac_kicker_time(
    AcKickerTimeProxy& f1,
    AcKickerTimeProxy& f2,
    bool is_eq) {
  Bmad::eq_ac_kicker_time(f1, f2, is_eq);
  auto py_result{PyEqAcKickerTime{is_eq}};
  return py_result;
}
struct PyEqAcKickerFreq {
  bool is_eq;
};
PyEqAcKickerFreq python_eq_ac_kicker_freq(
    AcKickerFreqProxy& f1,
    AcKickerFreqProxy& f2,
    bool is_eq) {
  Bmad::eq_ac_kicker_freq(f1, f2, is_eq);
  auto py_result{PyEqAcKickerFreq{is_eq}};
  return py_result;
}
struct PyEqAcKicker {
  bool is_eq;
};
PyEqAcKicker python_eq_ac_kicker(
    AcKickerProxy& f1,
    AcKickerProxy& f2,
    bool is_eq) {
  Bmad::eq_ac_kicker(f1, f2, is_eq);
  auto py_result{PyEqAcKicker{is_eq}};
  return py_result;
}
struct PyEqInterval1Coef {
  bool is_eq;
};
PyEqInterval1Coef python_eq_interval1_coef(
    Interval1CoefProxy& f1,
    Interval1CoefProxy& f2,
    bool is_eq) {
  Bmad::eq_interval1_coef(f1, f2, is_eq);
  auto py_result{PyEqInterval1Coef{is_eq}};
  return py_result;
}
struct PyEqPhotonReflectTable {
  bool is_eq;
};
PyEqPhotonReflectTable python_eq_photon_reflect_table(
    PhotonReflectTableProxy& f1,
    PhotonReflectTableProxy& f2,
    bool is_eq) {
  Bmad::eq_photon_reflect_table(f1, f2, is_eq);
  auto py_result{PyEqPhotonReflectTable{is_eq}};
  return py_result;
}
struct PyEqPhotonReflectSurface {
  bool is_eq;
};
PyEqPhotonReflectSurface python_eq_photon_reflect_surface(
    PhotonReflectSurfaceProxy& f1,
    PhotonReflectSurfaceProxy& f2,
    bool is_eq) {
  Bmad::eq_photon_reflect_surface(f1, f2, is_eq);
  auto py_result{PyEqPhotonReflectSurface{is_eq}};
  return py_result;
}
struct PyEqCoord {
  bool is_eq;
};
PyEqCoord python_eq_coord(CoordProxy& f1, CoordProxy& f2, bool is_eq) {
  Bmad::eq_coord(f1, f2, is_eq);
  auto py_result{PyEqCoord{is_eq}};
  return py_result;
}
struct PyEqCoordArray {
  bool is_eq;
};
PyEqCoordArray python_eq_coord_array(
    CoordArrayProxy& f1,
    CoordArrayProxy& f2,
    bool is_eq) {
  Bmad::eq_coord_array(f1, f2, is_eq);
  auto py_result{PyEqCoordArray{is_eq}};
  return py_result;
}
struct PyEqBpmPhaseCoupling {
  bool is_eq;
};
PyEqBpmPhaseCoupling python_eq_bpm_phase_coupling(
    BpmPhaseCouplingProxy& f1,
    BpmPhaseCouplingProxy& f2,
    bool is_eq) {
  Bmad::eq_bpm_phase_coupling(f1, f2, is_eq);
  auto py_result{PyEqBpmPhaseCoupling{is_eq}};
  return py_result;
}
struct PyEqExpressionAtom {
  bool is_eq;
};
PyEqExpressionAtom python_eq_expression_atom(
    ExpressionAtomProxy& f1,
    ExpressionAtomProxy& f2,
    bool is_eq) {
  Bmad::eq_expression_atom(f1, f2, is_eq);
  auto py_result{PyEqExpressionAtom{is_eq}};
  return py_result;
}
struct PyEqWakeSrZLong {
  bool is_eq;
};
PyEqWakeSrZLong python_eq_wake_sr_z_long(
    WakeSrZLongProxy& f1,
    WakeSrZLongProxy& f2,
    bool is_eq) {
  Bmad::eq_wake_sr_z_long(f1, f2, is_eq);
  auto py_result{PyEqWakeSrZLong{is_eq}};
  return py_result;
}
struct PyEqWakeSrMode {
  bool is_eq;
};
PyEqWakeSrMode python_eq_wake_sr_mode(
    WakeSrModeProxy& f1,
    WakeSrModeProxy& f2,
    bool is_eq) {
  Bmad::eq_wake_sr_mode(f1, f2, is_eq);
  auto py_result{PyEqWakeSrMode{is_eq}};
  return py_result;
}
struct PyEqWakeSr {
  bool is_eq;
};
PyEqWakeSr python_eq_wake_sr(WakeSrProxy& f1, WakeSrProxy& f2, bool is_eq) {
  Bmad::eq_wake_sr(f1, f2, is_eq);
  auto py_result{PyEqWakeSr{is_eq}};
  return py_result;
}
struct PyEqWakeLrMode {
  bool is_eq;
};
PyEqWakeLrMode python_eq_wake_lr_mode(
    WakeLrModeProxy& f1,
    WakeLrModeProxy& f2,
    bool is_eq) {
  Bmad::eq_wake_lr_mode(f1, f2, is_eq);
  auto py_result{PyEqWakeLrMode{is_eq}};
  return py_result;
}
struct PyEqWakeLr {
  bool is_eq;
};
PyEqWakeLr python_eq_wake_lr(WakeLrProxy& f1, WakeLrProxy& f2, bool is_eq) {
  Bmad::eq_wake_lr(f1, f2, is_eq);
  auto py_result{PyEqWakeLr{is_eq}};
  return py_result;
}
struct PyEqLatEleLoc {
  bool is_eq;
};
PyEqLatEleLoc python_eq_lat_ele_loc(
    LatEleLocProxy& f1,
    LatEleLocProxy& f2,
    bool is_eq) {
  Bmad::eq_lat_ele_loc(f1, f2, is_eq);
  auto py_result{PyEqLatEleLoc{is_eq}};
  return py_result;
}
struct PyEqWake {
  bool is_eq;
};
PyEqWake python_eq_wake(WakeProxy& f1, WakeProxy& f2, bool is_eq) {
  Bmad::eq_wake(f1, f2, is_eq);
  auto py_result{PyEqWake{is_eq}};
  return py_result;
}
struct PyEqTaylorTerm {
  bool is_eq;
};
PyEqTaylorTerm python_eq_taylor_term(
    TaylorTermProxy& f1,
    TaylorTermProxy& f2,
    bool is_eq) {
  Bmad::eq_taylor_term(f1, f2, is_eq);
  auto py_result{PyEqTaylorTerm{is_eq}};
  return py_result;
}
struct PyEqTaylor {
  bool is_eq;
};
PyEqTaylor python_eq_taylor(TaylorProxy& f1, TaylorProxy& f2, bool is_eq) {
  Bmad::eq_taylor(f1, f2, is_eq);
  auto py_result{PyEqTaylor{is_eq}};
  return py_result;
}
struct PyEqEmTaylorTerm {
  bool is_eq;
};
PyEqEmTaylorTerm python_eq_em_taylor_term(
    EmTaylorTermProxy& f1,
    EmTaylorTermProxy& f2,
    bool is_eq) {
  Bmad::eq_em_taylor_term(f1, f2, is_eq);
  auto py_result{PyEqEmTaylorTerm{is_eq}};
  return py_result;
}
struct PyEqEmTaylor {
  bool is_eq;
};
PyEqEmTaylor python_eq_em_taylor(
    EmTaylorProxy& f1,
    EmTaylorProxy& f2,
    bool is_eq) {
  Bmad::eq_em_taylor(f1, f2, is_eq);
  auto py_result{PyEqEmTaylor{is_eq}};
  return py_result;
}
struct PyEqCartesianMapTerm1 {
  bool is_eq;
};
PyEqCartesianMapTerm1 python_eq_cartesian_map_term1(
    CartesianMapTerm1Proxy& f1,
    CartesianMapTerm1Proxy& f2,
    bool is_eq) {
  Bmad::eq_cartesian_map_term1(f1, f2, is_eq);
  auto py_result{PyEqCartesianMapTerm1{is_eq}};
  return py_result;
}
struct PyEqCartesianMapTerm {
  bool is_eq;
};
PyEqCartesianMapTerm python_eq_cartesian_map_term(
    CartesianMapTermProxy& f1,
    CartesianMapTermProxy& f2,
    bool is_eq) {
  Bmad::eq_cartesian_map_term(f1, f2, is_eq);
  auto py_result{PyEqCartesianMapTerm{is_eq}};
  return py_result;
}
struct PyEqCartesianMap {
  bool is_eq;
};
PyEqCartesianMap python_eq_cartesian_map(
    CartesianMapProxy& f1,
    CartesianMapProxy& f2,
    bool is_eq) {
  Bmad::eq_cartesian_map(f1, f2, is_eq);
  auto py_result{PyEqCartesianMap{is_eq}};
  return py_result;
}
struct PyEqCylindricalMapTerm1 {
  bool is_eq;
};
PyEqCylindricalMapTerm1 python_eq_cylindrical_map_term1(
    CylindricalMapTerm1Proxy& f1,
    CylindricalMapTerm1Proxy& f2,
    bool is_eq) {
  Bmad::eq_cylindrical_map_term1(f1, f2, is_eq);
  auto py_result{PyEqCylindricalMapTerm1{is_eq}};
  return py_result;
}
struct PyEqCylindricalMapTerm {
  bool is_eq;
};
PyEqCylindricalMapTerm python_eq_cylindrical_map_term(
    CylindricalMapTermProxy& f1,
    CylindricalMapTermProxy& f2,
    bool is_eq) {
  Bmad::eq_cylindrical_map_term(f1, f2, is_eq);
  auto py_result{PyEqCylindricalMapTerm{is_eq}};
  return py_result;
}
struct PyEqCylindricalMap {
  bool is_eq;
};
PyEqCylindricalMap python_eq_cylindrical_map(
    CylindricalMapProxy& f1,
    CylindricalMapProxy& f2,
    bool is_eq) {
  Bmad::eq_cylindrical_map(f1, f2, is_eq);
  auto py_result{PyEqCylindricalMap{is_eq}};
  return py_result;
}
struct PyEqGridFieldPt1 {
  bool is_eq;
};
PyEqGridFieldPt1 python_eq_grid_field_pt1(
    GridFieldPt1Proxy& f1,
    GridFieldPt1Proxy& f2,
    bool is_eq) {
  Bmad::eq_grid_field_pt1(f1, f2, is_eq);
  auto py_result{PyEqGridFieldPt1{is_eq}};
  return py_result;
}
struct PyEqGridFieldPt {
  bool is_eq;
};
PyEqGridFieldPt python_eq_grid_field_pt(
    GridFieldPtProxy& f1,
    GridFieldPtProxy& f2,
    bool is_eq) {
  Bmad::eq_grid_field_pt(f1, f2, is_eq);
  auto py_result{PyEqGridFieldPt{is_eq}};
  return py_result;
}
struct PyEqGridField {
  bool is_eq;
};
PyEqGridField python_eq_grid_field(
    GridFieldProxy& f1,
    GridFieldProxy& f2,
    bool is_eq) {
  Bmad::eq_grid_field(f1, f2, is_eq);
  auto py_result{PyEqGridField{is_eq}};
  return py_result;
}
struct PyEqFloorPosition {
  bool is_eq;
};
PyEqFloorPosition python_eq_floor_position(
    FloorPositionProxy& f1,
    FloorPositionProxy& f2,
    bool is_eq) {
  Bmad::eq_floor_position(f1, f2, is_eq);
  auto py_result{PyEqFloorPosition{is_eq}};
  return py_result;
}
struct PyEqHighEnergySpaceCharge {
  bool is_eq;
};
PyEqHighEnergySpaceCharge python_eq_high_energy_space_charge(
    HighEnergySpaceChargeProxy& f1,
    HighEnergySpaceChargeProxy& f2,
    bool is_eq) {
  Bmad::eq_high_energy_space_charge(f1, f2, is_eq);
  auto py_result{PyEqHighEnergySpaceCharge{is_eq}};
  return py_result;
}
struct PyEqXyDisp {
  bool is_eq;
};
PyEqXyDisp python_eq_xy_disp(XyDispProxy& f1, XyDispProxy& f2, bool is_eq) {
  Bmad::eq_xy_disp(f1, f2, is_eq);
  auto py_result{PyEqXyDisp{is_eq}};
  return py_result;
}
struct PyEqTwiss {
  bool is_eq;
};
PyEqTwiss python_eq_twiss(TwissProxy& f1, TwissProxy& f2, bool is_eq) {
  Bmad::eq_twiss(f1, f2, is_eq);
  auto py_result{PyEqTwiss{is_eq}};
  return py_result;
}
struct PyEqMode3 {
  bool is_eq;
};
PyEqMode3 python_eq_mode3(Mode3Proxy& f1, Mode3Proxy& f2, bool is_eq) {
  Bmad::eq_mode3(f1, f2, is_eq);
  auto py_result{PyEqMode3{is_eq}};
  return py_result;
}
struct PyEqBookkeepingState {
  bool is_eq;
};
PyEqBookkeepingState python_eq_bookkeeping_state(
    BookkeepingStateProxy& f1,
    BookkeepingStateProxy& f2,
    bool is_eq) {
  Bmad::eq_bookkeeping_state(f1, f2, is_eq);
  auto py_result{PyEqBookkeepingState{is_eq}};
  return py_result;
}
struct PyEqRadMap {
  bool is_eq;
};
PyEqRadMap python_eq_rad_map(RadMapProxy& f1, RadMapProxy& f2, bool is_eq) {
  Bmad::eq_rad_map(f1, f2, is_eq);
  auto py_result{PyEqRadMap{is_eq}};
  return py_result;
}
struct PyEqRadMapEle {
  bool is_eq;
};
PyEqRadMapEle python_eq_rad_map_ele(
    RadMapEleProxy& f1,
    RadMapEleProxy& f2,
    bool is_eq) {
  Bmad::eq_rad_map_ele(f1, f2, is_eq);
  auto py_result{PyEqRadMapEle{is_eq}};
  return py_result;
}
struct PyEqGenGrad1 {
  bool is_eq;
};
PyEqGenGrad1 python_eq_gen_grad1(
    GenGrad1Proxy& f1,
    GenGrad1Proxy& f2,
    bool is_eq) {
  Bmad::eq_gen_grad1(f1, f2, is_eq);
  auto py_result{PyEqGenGrad1{is_eq}};
  return py_result;
}
struct PyEqGenGradMap {
  bool is_eq;
};
PyEqGenGradMap python_eq_gen_grad_map(
    GenGradMapProxy& f1,
    GenGradMapProxy& f2,
    bool is_eq) {
  Bmad::eq_gen_grad_map(f1, f2, is_eq);
  auto py_result{PyEqGenGradMap{is_eq}};
  return py_result;
}
struct PyEqSurfaceSegmentedPt {
  bool is_eq;
};
PyEqSurfaceSegmentedPt python_eq_surface_segmented_pt(
    SurfaceSegmentedPtProxy& f1,
    SurfaceSegmentedPtProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_segmented_pt(f1, f2, is_eq);
  auto py_result{PyEqSurfaceSegmentedPt{is_eq}};
  return py_result;
}
struct PyEqSurfaceSegmented {
  bool is_eq;
};
PyEqSurfaceSegmented python_eq_surface_segmented(
    SurfaceSegmentedProxy& f1,
    SurfaceSegmentedProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_segmented(f1, f2, is_eq);
  auto py_result{PyEqSurfaceSegmented{is_eq}};
  return py_result;
}
struct PyEqSurfaceHMisalignPt {
  bool is_eq;
};
PyEqSurfaceHMisalignPt python_eq_surface_h_misalign_pt(
    SurfaceHMisalignPtProxy& f1,
    SurfaceHMisalignPtProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_h_misalign_pt(f1, f2, is_eq);
  auto py_result{PyEqSurfaceHMisalignPt{is_eq}};
  return py_result;
}
struct PyEqSurfaceHMisalign {
  bool is_eq;
};
PyEqSurfaceHMisalign python_eq_surface_h_misalign(
    SurfaceHMisalignProxy& f1,
    SurfaceHMisalignProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_h_misalign(f1, f2, is_eq);
  auto py_result{PyEqSurfaceHMisalign{is_eq}};
  return py_result;
}
struct PyEqSurfaceDisplacementPt {
  bool is_eq;
};
PyEqSurfaceDisplacementPt python_eq_surface_displacement_pt(
    SurfaceDisplacementPtProxy& f1,
    SurfaceDisplacementPtProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_displacement_pt(f1, f2, is_eq);
  auto py_result{PyEqSurfaceDisplacementPt{is_eq}};
  return py_result;
}
struct PyEqSurfaceDisplacement {
  bool is_eq;
};
PyEqSurfaceDisplacement python_eq_surface_displacement(
    SurfaceDisplacementProxy& f1,
    SurfaceDisplacementProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_displacement(f1, f2, is_eq);
  auto py_result{PyEqSurfaceDisplacement{is_eq}};
  return py_result;
}
struct PyEqTargetPoint {
  bool is_eq;
};
PyEqTargetPoint python_eq_target_point(
    TargetPointProxy& f1,
    TargetPointProxy& f2,
    bool is_eq) {
  Bmad::eq_target_point(f1, f2, is_eq);
  auto py_result{PyEqTargetPoint{is_eq}};
  return py_result;
}
struct PyEqSurfaceCurvature {
  bool is_eq;
};
PyEqSurfaceCurvature python_eq_surface_curvature(
    SurfaceCurvatureProxy& f1,
    SurfaceCurvatureProxy& f2,
    bool is_eq) {
  Bmad::eq_surface_curvature(f1, f2, is_eq);
  auto py_result{PyEqSurfaceCurvature{is_eq}};
  return py_result;
}
struct PyEqPhotonTarget {
  bool is_eq;
};
PyEqPhotonTarget python_eq_photon_target(
    PhotonTargetProxy& f1,
    PhotonTargetProxy& f2,
    bool is_eq) {
  Bmad::eq_photon_target(f1, f2, is_eq);
  auto py_result{PyEqPhotonTarget{is_eq}};
  return py_result;
}
struct PyEqPhotonMaterial {
  bool is_eq;
};
PyEqPhotonMaterial python_eq_photon_material(
    PhotonMaterialProxy& f1,
    PhotonMaterialProxy& f2,
    bool is_eq) {
  Bmad::eq_photon_material(f1, f2, is_eq);
  auto py_result{PyEqPhotonMaterial{is_eq}};
  return py_result;
}
struct PyEqPixelPt {
  bool is_eq;
};
PyEqPixelPt python_eq_pixel_pt(PixelPtProxy& f1, PixelPtProxy& f2, bool is_eq) {
  Bmad::eq_pixel_pt(f1, f2, is_eq);
  auto py_result{PyEqPixelPt{is_eq}};
  return py_result;
}
struct PyEqPixelDetec {
  bool is_eq;
};
PyEqPixelDetec python_eq_pixel_detec(
    PixelDetecProxy& f1,
    PixelDetecProxy& f2,
    bool is_eq) {
  Bmad::eq_pixel_detec(f1, f2, is_eq);
  auto py_result{PyEqPixelDetec{is_eq}};
  return py_result;
}
struct PyEqPhotonElement {
  bool is_eq;
};
PyEqPhotonElement python_eq_photon_element(
    PhotonElementProxy& f1,
    PhotonElementProxy& f2,
    bool is_eq) {
  Bmad::eq_photon_element(f1, f2, is_eq);
  auto py_result{PyEqPhotonElement{is_eq}};
  return py_result;
}
struct PyEqWall3dVertex {
  bool is_eq;
};
PyEqWall3dVertex python_eq_wall3d_vertex(
    Wall3dVertexProxy& f1,
    Wall3dVertexProxy& f2,
    bool is_eq) {
  Bmad::eq_wall3d_vertex(f1, f2, is_eq);
  auto py_result{PyEqWall3dVertex{is_eq}};
  return py_result;
}
struct PyEqWall3dSection {
  bool is_eq;
};
PyEqWall3dSection python_eq_wall3d_section(
    Wall3dSectionProxy& f1,
    Wall3dSectionProxy& f2,
    bool is_eq) {
  Bmad::eq_wall3d_section(f1, f2, is_eq);
  auto py_result{PyEqWall3dSection{is_eq}};
  return py_result;
}
struct PyEqWall3d {
  bool is_eq;
};
PyEqWall3d python_eq_wall3d(Wall3dProxy& f1, Wall3dProxy& f2, bool is_eq) {
  Bmad::eq_wall3d(f1, f2, is_eq);
  auto py_result{PyEqWall3d{is_eq}};
  return py_result;
}
struct PyEqRamperLord {
  bool is_eq;
};
PyEqRamperLord python_eq_ramper_lord(
    RamperLordProxy& f1,
    RamperLordProxy& f2,
    bool is_eq) {
  Bmad::eq_ramper_lord(f1, f2, is_eq);
  auto py_result{PyEqRamperLord{is_eq}};
  return py_result;
}
struct PyEqControl {
  bool is_eq;
};
PyEqControl python_eq_control(ControlProxy& f1, ControlProxy& f2, bool is_eq) {
  Bmad::eq_control(f1, f2, is_eq);
  auto py_result{PyEqControl{is_eq}};
  return py_result;
}
struct PyEqControlVar1 {
  bool is_eq;
};
PyEqControlVar1 python_eq_control_var1(
    ControlVar1Proxy& f1,
    ControlVar1Proxy& f2,
    bool is_eq) {
  Bmad::eq_control_var1(f1, f2, is_eq);
  auto py_result{PyEqControlVar1{is_eq}};
  return py_result;
}
struct PyEqControlRamp1 {
  bool is_eq;
};
PyEqControlRamp1 python_eq_control_ramp1(
    ControlRamp1Proxy& f1,
    ControlRamp1Proxy& f2,
    bool is_eq) {
  Bmad::eq_control_ramp1(f1, f2, is_eq);
  auto py_result{PyEqControlRamp1{is_eq}};
  return py_result;
}
struct PyEqController {
  bool is_eq;
};
PyEqController python_eq_controller(
    ControllerProxy& f1,
    ControllerProxy& f2,
    bool is_eq) {
  Bmad::eq_controller(f1, f2, is_eq);
  auto py_result{PyEqController{is_eq}};
  return py_result;
}
struct PyEqEllipseBeamInit {
  bool is_eq;
};
PyEqEllipseBeamInit python_eq_ellipse_beam_init(
    EllipseBeamInitProxy& f1,
    EllipseBeamInitProxy& f2,
    bool is_eq) {
  Bmad::eq_ellipse_beam_init(f1, f2, is_eq);
  auto py_result{PyEqEllipseBeamInit{is_eq}};
  return py_result;
}
struct PyEqKvBeamInit {
  bool is_eq;
};
PyEqKvBeamInit python_eq_kv_beam_init(
    KvBeamInitProxy& f1,
    KvBeamInitProxy& f2,
    bool is_eq) {
  Bmad::eq_kv_beam_init(f1, f2, is_eq);
  auto py_result{PyEqKvBeamInit{is_eq}};
  return py_result;
}
struct PyEqGridBeamInit {
  bool is_eq;
};
PyEqGridBeamInit python_eq_grid_beam_init(
    GridBeamInitProxy& f1,
    GridBeamInitProxy& f2,
    bool is_eq) {
  Bmad::eq_grid_beam_init(f1, f2, is_eq);
  auto py_result{PyEqGridBeamInit{is_eq}};
  return py_result;
}
struct PyEqBeamInit {
  bool is_eq;
};
PyEqBeamInit python_eq_beam_init(
    BeamInitProxy& f1,
    BeamInitProxy& f2,
    bool is_eq) {
  Bmad::eq_beam_init(f1, f2, is_eq);
  auto py_result{PyEqBeamInit{is_eq}};
  return py_result;
}
struct PyEqLatParam {
  bool is_eq;
};
PyEqLatParam python_eq_lat_param(
    LatParamProxy& f1,
    LatParamProxy& f2,
    bool is_eq) {
  Bmad::eq_lat_param(f1, f2, is_eq);
  auto py_result{PyEqLatParam{is_eq}};
  return py_result;
}
struct PyEqModeInfo {
  bool is_eq;
};
PyEqModeInfo python_eq_mode_info(
    ModeInfoProxy& f1,
    ModeInfoProxy& f2,
    bool is_eq) {
  Bmad::eq_mode_info(f1, f2, is_eq);
  auto py_result{PyEqModeInfo{is_eq}};
  return py_result;
}
struct PyEqPreTracker {
  bool is_eq;
};
PyEqPreTracker python_eq_pre_tracker(
    PreTrackerProxy& f1,
    PreTrackerProxy& f2,
    bool is_eq) {
  Bmad::eq_pre_tracker(f1, f2, is_eq);
  auto py_result{PyEqPreTracker{is_eq}};
  return py_result;
}
struct PyEqAnormalMode {
  bool is_eq;
};
PyEqAnormalMode python_eq_anormal_mode(
    AnormalModeProxy& f1,
    AnormalModeProxy& f2,
    bool is_eq) {
  Bmad::eq_anormal_mode(f1, f2, is_eq);
  auto py_result{PyEqAnormalMode{is_eq}};
  return py_result;
}
struct PyEqLinacNormalMode {
  bool is_eq;
};
PyEqLinacNormalMode python_eq_linac_normal_mode(
    LinacNormalModeProxy& f1,
    LinacNormalModeProxy& f2,
    bool is_eq) {
  Bmad::eq_linac_normal_mode(f1, f2, is_eq);
  auto py_result{PyEqLinacNormalMode{is_eq}};
  return py_result;
}
struct PyEqNormalModes {
  bool is_eq;
};
PyEqNormalModes python_eq_normal_modes(
    NormalModesProxy& f1,
    NormalModesProxy& f2,
    bool is_eq) {
  Bmad::eq_normal_modes(f1, f2, is_eq);
  auto py_result{PyEqNormalModes{is_eq}};
  return py_result;
}
struct PyEqEmField {
  bool is_eq;
};
PyEqEmField python_eq_em_field(EmFieldProxy& f1, EmFieldProxy& f2, bool is_eq) {
  Bmad::eq_em_field(f1, f2, is_eq);
  auto py_result{PyEqEmField{is_eq}};
  return py_result;
}
struct PyEqStrongBeam {
  bool is_eq;
};
PyEqStrongBeam python_eq_strong_beam(
    StrongBeamProxy& f1,
    StrongBeamProxy& f2,
    bool is_eq) {
  Bmad::eq_strong_beam(f1, f2, is_eq);
  auto py_result{PyEqStrongBeam{is_eq}};
  return py_result;
}
struct PyEqTrackPoint {
  bool is_eq;
};
PyEqTrackPoint python_eq_track_point(
    TrackPointProxy& f1,
    TrackPointProxy& f2,
    bool is_eq) {
  Bmad::eq_track_point(f1, f2, is_eq);
  auto py_result{PyEqTrackPoint{is_eq}};
  return py_result;
}
struct PyEqTrack {
  bool is_eq;
};
PyEqTrack python_eq_track(TrackProxy& f1, TrackProxy& f2, bool is_eq) {
  Bmad::eq_track(f1, f2, is_eq);
  auto py_result{PyEqTrack{is_eq}};
  return py_result;
}
struct PyEqSpaceChargeCommon {
  bool is_eq;
};
PyEqSpaceChargeCommon python_eq_space_charge_common(
    SpaceChargeCommonProxy& f1,
    SpaceChargeCommonProxy& f2,
    bool is_eq) {
  Bmad::eq_space_charge_common(f1, f2, is_eq);
  auto py_result{PyEqSpaceChargeCommon{is_eq}};
  return py_result;
}
struct PyEqBmadCommon {
  bool is_eq;
};
PyEqBmadCommon python_eq_bmad_common(
    BmadCommonProxy& f1,
    BmadCommonProxy& f2,
    bool is_eq) {
  Bmad::eq_bmad_common(f1, f2, is_eq);
  auto py_result{PyEqBmadCommon{is_eq}};
  return py_result;
}
struct PyEqRadInt1 {
  bool is_eq;
};
PyEqRadInt1 python_eq_rad_int1(RadInt1Proxy& f1, RadInt1Proxy& f2, bool is_eq) {
  Bmad::eq_rad_int1(f1, f2, is_eq);
  auto py_result{PyEqRadInt1{is_eq}};
  return py_result;
}
struct PyEqRadIntBranch {
  bool is_eq;
};
PyEqRadIntBranch python_eq_rad_int_branch(
    RadIntBranchProxy& f1,
    RadIntBranchProxy& f2,
    bool is_eq) {
  Bmad::eq_rad_int_branch(f1, f2, is_eq);
  auto py_result{PyEqRadIntBranch{is_eq}};
  return py_result;
}
struct PyEqRadIntAllEle {
  bool is_eq;
};
PyEqRadIntAllEle python_eq_rad_int_all_ele(
    RadIntAllEleProxy& f1,
    RadIntAllEleProxy& f2,
    bool is_eq) {
  Bmad::eq_rad_int_all_ele(f1, f2, is_eq);
  auto py_result{PyEqRadIntAllEle{is_eq}};
  return py_result;
}
struct PyEqEle {
  bool is_eq;
};
PyEqEle python_eq_ele(EleProxy& f1, EleProxy& f2, bool is_eq) {
  Bmad::eq_ele(f1, f2, is_eq);
  auto py_result{PyEqEle{is_eq}};
  return py_result;
}
struct PyEqComplexTaylorTerm {
  bool is_eq;
};
PyEqComplexTaylorTerm python_eq_complex_taylor_term(
    ComplexTaylorTermProxy& f1,
    ComplexTaylorTermProxy& f2,
    bool is_eq) {
  Bmad::eq_complex_taylor_term(f1, f2, is_eq);
  auto py_result{PyEqComplexTaylorTerm{is_eq}};
  return py_result;
}
struct PyEqComplexTaylor {
  bool is_eq;
};
PyEqComplexTaylor python_eq_complex_taylor(
    ComplexTaylorProxy& f1,
    ComplexTaylorProxy& f2,
    bool is_eq) {
  Bmad::eq_complex_taylor(f1, f2, is_eq);
  auto py_result{PyEqComplexTaylor{is_eq}};
  return py_result;
}
struct PyEqBranch {
  bool is_eq;
};
PyEqBranch python_eq_branch(BranchProxy& f1, BranchProxy& f2, bool is_eq) {
  Bmad::eq_branch(f1, f2, is_eq);
  auto py_result{PyEqBranch{is_eq}};
  return py_result;
}
struct PyEqLat {
  bool is_eq;
};
PyEqLat python_eq_lat(LatProxy& f1, LatProxy& f2, bool is_eq) {
  Bmad::eq_lat(f1, f2, is_eq);
  auto py_result{PyEqLat{is_eq}};
  return py_result;
}
struct PyEqBunch {
  bool is_eq;
};
PyEqBunch python_eq_bunch(BunchProxy& f1, BunchProxy& f2, bool is_eq) {
  Bmad::eq_bunch(f1, f2, is_eq);
  auto py_result{PyEqBunch{is_eq}};
  return py_result;
}
struct PyEqBunchParams {
  bool is_eq;
};
PyEqBunchParams python_eq_bunch_params(
    BunchParamsProxy& f1,
    BunchParamsProxy& f2,
    bool is_eq) {
  Bmad::eq_bunch_params(f1, f2, is_eq);
  auto py_result{PyEqBunchParams{is_eq}};
  return py_result;
}
struct PyEqBeam {
  bool is_eq;
};
PyEqBeam python_eq_beam(BeamProxy& f1, BeamProxy& f2, bool is_eq) {
  Bmad::eq_beam(f1, f2, is_eq);
  auto py_result{PyEqBeam{is_eq}};
  return py_result;
}
struct PyEqAperturePoint {
  bool is_eq;
};
PyEqAperturePoint python_eq_aperture_point(
    AperturePointProxy& f1,
    AperturePointProxy& f2,
    bool is_eq) {
  Bmad::eq_aperture_point(f1, f2, is_eq);
  auto py_result{PyEqAperturePoint{is_eq}};
  return py_result;
}
struct PyEqApertureParam {
  bool is_eq;
};
PyEqApertureParam python_eq_aperture_param(
    ApertureParamProxy& f1,
    ApertureParamProxy& f2,
    bool is_eq) {
  Bmad::eq_aperture_param(f1, f2, is_eq);
  auto py_result{PyEqApertureParam{is_eq}};
  return py_result;
}
struct PyEqApertureScan {
  bool is_eq;
};
PyEqApertureScan python_eq_aperture_scan(
    ApertureScanProxy& f1,
    ApertureScanProxy& f2,
    bool is_eq) {
  Bmad::eq_aperture_scan(f1, f2, is_eq);
  auto py_result{PyEqApertureScan{is_eq}};
  return py_result;
}

struct PyRadGIntegrals {
  FixedArray1D<Real, 2> int_g;
  double int_g2;
  double int_g3;
};
PyRadGIntegrals python_rad_g_integrals(
    EleProxy& ele,
    int where,
    CoordProxy& orb_in,
    CoordProxy& orb_out,
    double int_g2,
    double int_g3,
    double g_tol,
    double g2_tol,
    double g3_tol) {
  auto _result = Bmad::rad_g_integrals(
      ele, where, orb_in, orb_out, int_g2, int_g3, g_tol, g2_tol, g3_tol);
  auto py_result{PyRadGIntegrals{_result, int_g2, int_g3}};
  return py_result;
}
struct PyCreateConcatenatedWall3d {
  bool err;
};
PyCreateConcatenatedWall3d python_create_concatenated_wall3d(
    LatProxy& lat,
    bool err) {
  Bmad::create_concatenated_wall3d(lat, err);
  auto py_result{PyCreateConcatenatedWall3d{err}};
  return py_result;
}
struct PyAngleBetweenPolars {
  double angle;
};
PyAngleBetweenPolars python_angle_between_polars(
    SpinPolarProxy& polar1,
    SpinPolarProxy& polar2,
    double angle) {
  Bmad::angle_between_polars(polar1, polar2, angle);
  auto py_result{PyAngleBetweenPolars{angle}};
  return py_result;
}
struct PyBmadParser2 {
  std::optional<bool> err_flag;
};
PyBmadParser2 python_bmad_parser2(
    std::string lat_file,
    LatProxy& lat,
    optional_ref<CoordProxyAlloc1D> orbit = std::nullopt,
    std::optional<bool> make_mats6 = std::nullopt,
    std::optional<bool> err_flag = std::nullopt,
    optional_ref<LatProxy> parse_lat = std::nullopt) {
  Bmad::bmad_parser2(
      lat_file, lat, orbit, make_mats6, make_opt_ref(err_flag), parse_lat);
  auto py_result{PyBmadParser2{err_flag}};
  return py_result;
}
struct PyCreateGirder {
  bool err_flag;
};
PyCreateGirder python_create_girder(
    LatProxy& lat,
    int ix_girder,
    ControlProxyAlloc1D& contrl,
    EleProxy& girder_info,
    bool err_flag) {
  Bmad::create_girder(lat, ix_girder, contrl, girder_info, err_flag);
  auto py_result{PyCreateGirder{err_flag}};
  return py_result;
}
struct PyGradientShiftSrWake {
  double grad_shift;
};
PyGradientShiftSrWake python_gradient_shift_sr_wake(
    EleProxy& ele,
    LatParamProxy& param,
    double grad_shift) {
  Bmad::gradient_shift_sr_wake(ele, param, grad_shift);
  auto py_result{PyGradientShiftSrWake{grad_shift}};
  return py_result;
}
struct PyHdf5WriteBeam {
  std::string file_name;
  bool append;
  bool error;
  std::optional<bool> alive_only;
};
PyHdf5WriteBeam python_hdf5_write_beam(
    std::string file_name,
    BunchProxyAlloc1D& bunches,
    bool append,
    bool error,
    optional_ref<LatProxy> lat = std::nullopt,
    std::optional<bool> alive_only = std::nullopt) {
  Bmad::hdf5_write_beam(
      file_name, bunches, append, error, lat, make_opt_ref(alive_only));
  auto py_result{PyHdf5WriteBeam{file_name, append, error, alive_only}};
  return py_result;
}
struct PyHdf5WriteGridField {
  std::string file_name;
  bool err_flag;
};
PyHdf5WriteGridField python_hdf5_write_grid_field(
    std::string file_name,
    EleProxy& ele,
    GridFieldProxyAlloc1D& g_field,
    bool err_flag) {
  Bmad::hdf5_write_grid_field(file_name, ele, g_field, err_flag);
  auto py_result{PyHdf5WriteGridField{file_name, err_flag}};
  return py_result;
}
struct PyReallocateBeam {
  std::optional<bool> extend;
};
PyReallocateBeam python_reallocate_beam(
    BeamProxy& beam,
    int n_bunch,
    std::optional<int> n_particle = std::nullopt,
    std::optional<bool> extend = std::nullopt) {
  Bmad::reallocate_beam(beam, n_bunch, n_particle, make_opt_ref(extend));
  auto py_result{PyReallocateBeam{extend}};
  return py_result;
}
struct PySpinOmega {
  int sign_z_vel;
  std::optional<bool> phase_space_coords;
};
PySpinOmega python_spin_omega(
    EmFieldProxy& field,
    CoordProxy& orbit,
    int sign_z_vel,
    std::optional<bool> phase_space_coords,
    FixedArray1D<Real, 3> omega) {
  Bmad::spin_omega(
      field, orbit, sign_z_vel, make_opt_ref(phase_space_coords), omega);
  auto py_result{PySpinOmega{sign_z_vel, phase_space_coords}};
  return py_result;
}
struct PyTrack1Spin : public Bmad::Track1Spin {
  std::optional<bool> make_quaternion;
  PyTrack1Spin(Bmad::Track1Spin _base, std::optional<bool> make_quaternion)
      : Bmad::Track1Spin(std::move(_base)), make_quaternion(make_quaternion) {}
};
PyTrack1Spin python_track1_spin(
    CoordProxy& start_orb,
    LatParamProxy& param,
    std::optional<bool> make_quaternion = std::nullopt) {
  auto _result =
      Bmad::track1_spin(start_orb, param, make_opt_ref(make_quaternion));
  auto py_result{PyTrack1Spin{_result, make_quaternion}};
  return py_result;
}
struct PyValidSpinTrackingMethod {
  bool is_valid;
};
PyValidSpinTrackingMethod python_valid_spin_tracking_method(
    EleProxy& ele,
    int spin_tracking_method,
    bool is_valid) {
  Bmad::valid_spin_tracking_method(ele, spin_tracking_method, is_valid);
  auto py_result{PyValidSpinTrackingMethod{is_valid}};
  return py_result;
}
struct PyWriteLatticeInSadFormat {
  std::string out_file_name;
  std::optional<bool> include_apertures;
  std::optional<int> ix_branch;
  std::optional<bool> err;
};
PyWriteLatticeInSadFormat python_write_lattice_in_sad_format(
    std::string out_file_name,
    LatProxy& lat,
    std::optional<bool> include_apertures = std::nullopt,
    std::optional<int> ix_branch = std::nullopt,
    std::optional<bool> err = std::nullopt) {
  Bmad::write_lattice_in_sad_format(
      out_file_name,
      lat,
      make_opt_ref(include_apertures),
      make_opt_ref(ix_branch),
      make_opt_ref(err));
  auto py_result{PyWriteLatticeInSadFormat{
      out_file_name, include_apertures, ix_branch, err}};
  return py_result;
}
struct PyPointerToEle1 {
  int ix_ele;
  std::optional<int> ix_branch;
};
PyPointerToEle1 python_pointer_to_ele1(
    LatProxy& lat,
    int ix_ele,
    std::optional<int> ix_branch,
    EleProxy& ele_ptr) {
  Bmad::pointer_to_ele1(lat, ix_ele, make_opt_ref(ix_branch), ele_ptr);
  auto py_result{PyPointerToEle1{ix_ele, ix_branch}};
  return py_result;
}
struct PyPointerToEle3 {
  std::string ele_name;
};
PyPointerToEle3 python_pointer_to_ele3(
    LatProxy& lat,
    std::string ele_name,
    EleProxy& ele_ptr) {
  Bmad::pointer_to_ele3(lat, ele_name, ele_ptr);
  auto py_result{PyPointerToEle3{ele_name}};
  return py_result;
}

struct PyCoordStateName {
  std::string state_str;
  std::optional<bool> one_word;
};
PyCoordStateName python_coord_state_name(
    int coord_state,
    std::optional<bool> one_word = std::nullopt) {
  auto _result = Bmad::coord_state_name(coord_state, make_opt_ref(one_word));
  auto py_result{PyCoordStateName{_result, one_word}};
  return py_result;
}
struct PyKickVectorCalc : public Bmad::KickVectorCalc {
  std::optional<bool> print_err;
  PyKickVectorCalc(Bmad::KickVectorCalc _base, std::optional<bool> print_err)
      : Bmad::KickVectorCalc(std::move(_base)), print_err(print_err) {}
};
PyKickVectorCalc python_kick_vector_calc(
    EleProxy& ele,
    LatParamProxy& param,
    double s_body,
    CoordProxy& orbit,
    std::optional<bool> print_err = std::nullopt) {
  auto _result = Bmad::kick_vector_calc(
      ele, param, s_body, orbit, make_opt_ref(print_err));
  auto py_result{PyKickVectorCalc{_result, print_err}};
  return py_result;
}
struct PyIntegrationTimerEle {
  double tol;
};
PyIntegrationTimerEle python_integration_timer_ele(
    EleProxy& ele,
    LatParamProxy& param,
    CoordProxy& start,
    CoordProxy& orb_max,
    double tol) {
  Bmad::integration_timer_ele(ele, param, start, orb_max, tol);
  auto py_result{PyIntegrationTimerEle{tol}};
  return py_result;
}
struct PyAdjustSuperSlaveNames {
  int ix1_lord;
  int ix2_lord;
  std::optional<bool> first_time;
};
PyAdjustSuperSlaveNames python_adjust_super_slave_names(
    LatProxy& lat,
    int ix1_lord,
    int ix2_lord,
    std::optional<bool> first_time = std::nullopt) {
  Bmad::adjust_super_slave_names(
      lat, ix1_lord, ix2_lord, make_opt_ref(first_time));
  auto py_result{PyAdjustSuperSlaveNames{ix1_lord, ix2_lord, first_time}};
  return py_result;
}
struct PyReleaseRadIntCache {
  int ix_cache;
};
PyReleaseRadIntCache python_release_rad_int_cache(int ix_cache) {
  Bmad::release_rad_int_cache(ix_cache);
  auto py_result{PyReleaseRadIntCache{ix_cache}};
  return py_result;
}
struct PyMytan {
  double y;
  double x;
  double arg;
};
PyMytan python_mytan(double y, double x, double arg) {
  Bmad::mytan(y, x, arg);
  auto py_result{PyMytan{y, x, arg}};
  return py_result;
}
struct PyTwiss3Propagate1 {
  bool err_flag;
};
PyTwiss3Propagate1 python_twiss3_propagate1(
    EleProxy& ele1,
    EleProxy& ele2,
    bool err_flag) {
  Bmad::twiss3_propagate1(ele1, ele2, err_flag);
  auto py_result{PyTwiss3Propagate1{err_flag}};
  return py_result;
}

struct PyTwiss3AtStart {
  FixedArray1D<Real, 3> tune3;
  bool err_flag;
};
PyTwiss3AtStart python_twiss3_at_start(
    LatProxy& lat,
    bool err_flag,
    std::optional<int> ix_branch = std::nullopt) {
  auto _result = Bmad::twiss3_at_start(lat, err_flag, ix_branch);
  auto py_result{PyTwiss3AtStart{_result, err_flag}};
  return py_result;
}
struct PyAttributeIndex1 {
  std::string name;
  std::optional<std::string> full_name;
  std::optional<bool> can_abbreviate;
  std::optional<bool> print_error;
  int attrib_index;
};
PyAttributeIndex1 python_attribute_index1(
    EleProxy& ele,
    std::string name,
    std::optional<std::string> full_name,
    std::optional<bool> can_abbreviate,
    std::optional<bool> print_error,
    int attrib_index) {
  Bmad::attribute_index1(
      ele,
      name,
      make_opt_ref(full_name),
      make_opt_ref(can_abbreviate),
      make_opt_ref(print_error),
      attrib_index);
  auto py_result{PyAttributeIndex1{
      name, full_name, can_abbreviate, print_error, attrib_index}};
  return py_result;
}
struct PyAttributeIndex2 {
  int key;
  std::string name;
  std::optional<std::string> full_name;
  std::optional<bool> can_abbreviate;
  std::optional<bool> print_error;
  int attrib_index;
};
PyAttributeIndex2 python_attribute_index2(
    int key,
    std::string name,
    std::optional<std::string> full_name,
    std::optional<bool> can_abbreviate,
    std::optional<bool> print_error,
    int attrib_index) {
  Bmad::attribute_index2(
      key,
      name,
      make_opt_ref(full_name),
      make_opt_ref(can_abbreviate),
      make_opt_ref(print_error),
      attrib_index);
  auto py_result{PyAttributeIndex2{
      key, name, full_name, can_abbreviate, print_error, attrib_index}};
  return py_result;
}
struct PyAttributeName1 {
  int key;
  int ix_att;
  std::optional<bool> show_private;
  std::string attrib_name;
};
PyAttributeName1 python_attribute_name1(
    int key,
    int ix_att,
    std::optional<bool> show_private,
    std::string attrib_name) {
  Bmad::attribute_name1(key, ix_att, make_opt_ref(show_private), attrib_name);
  auto py_result{PyAttributeName1{key, ix_att, show_private, attrib_name}};
  return py_result;
}
struct PyAttributeName2 {
  int ix_att;
  std::optional<bool> show_private;
  std::string attrib_name;
};
PyAttributeName2 python_attribute_name2(
    EleProxy& ele,
    int ix_att,
    std::optional<bool> show_private,
    std::string attrib_name) {
  Bmad::attribute_name2(ele, ix_att, make_opt_ref(show_private), attrib_name);
  auto py_result{PyAttributeName2{ix_att, show_private, attrib_name}};
  return py_result;
}
struct PyHasAttribute {
  std::string attrib;
  bool has_it;
};
PyHasAttribute python_has_attribute(
    EleProxy& ele,
    std::string attrib,
    bool has_it) {
  Bmad::has_attribute(ele, attrib, has_it);
  auto py_result{PyHasAttribute{attrib, has_it}};
  return py_result;
}
struct PyAttributeFree1 {
  int ix_ele;
  std::string attrib_name;
  std::optional<bool> err_print_flag;
  std::optional<bool> except_overlay;
  std::optional<bool> dependent_attribs_free;
  std::optional<int> why_not_free;
  bool free;
};
PyAttributeFree1 python_attribute_free1(
    int ix_ele,
    std::string attrib_name,
    LatProxy& lat,
    std::optional<bool> err_print_flag,
    std::optional<bool> except_overlay,
    std::optional<bool> dependent_attribs_free,
    std::optional<int> why_not_free,
    bool free) {
  Bmad::attribute_free1(
      ix_ele,
      attrib_name,
      lat,
      make_opt_ref(err_print_flag),
      make_opt_ref(except_overlay),
      make_opt_ref(dependent_attribs_free),
      make_opt_ref(why_not_free),
      free);
  auto py_result{PyAttributeFree1{
      ix_ele,
      attrib_name,
      err_print_flag,
      except_overlay,
      dependent_attribs_free,
      why_not_free,
      free}};
  return py_result;
}
struct PyAttributeFree2 {
  std::string attrib_name;
  std::optional<bool> err_print_flag;
  std::optional<bool> except_overlay;
  std::optional<bool> dependent_attribs_free;
  std::optional<int> why_not_free;
  bool free;
};
PyAttributeFree2 python_attribute_free2(
    EleProxy& ele,
    std::string attrib_name,
    std::optional<bool> err_print_flag,
    std::optional<bool> except_overlay,
    std::optional<bool> dependent_attribs_free,
    std::optional<int> why_not_free,
    bool free) {
  Bmad::attribute_free2(
      ele,
      attrib_name,
      make_opt_ref(err_print_flag),
      make_opt_ref(except_overlay),
      make_opt_ref(dependent_attribs_free),
      make_opt_ref(why_not_free),
      free);
  auto py_result{PyAttributeFree2{
      attrib_name,
      err_print_flag,
      except_overlay,
      dependent_attribs_free,
      why_not_free,
      free}};
  return py_result;
}
struct PyAttributeFree3 {
  int ix_ele;
  int ix_branch;
  std::string attrib_name;
  std::optional<bool> err_print_flag;
  std::optional<bool> except_overlay;
  std::optional<bool> dependent_attribs_free;
  std::optional<int> why_not_free;
  bool free;
};
PyAttributeFree3 python_attribute_free3(
    int ix_ele,
    int ix_branch,
    std::string attrib_name,
    LatProxy& lat,
    std::optional<bool> err_print_flag,
    std::optional<bool> except_overlay,
    std::optional<bool> dependent_attribs_free,
    std::optional<int> why_not_free,
    bool free) {
  Bmad::attribute_free3(
      ix_ele,
      ix_branch,
      attrib_name,
      lat,
      make_opt_ref(err_print_flag),
      make_opt_ref(except_overlay),
      make_opt_ref(dependent_attribs_free),
      make_opt_ref(why_not_free),
      free);
  auto py_result{PyAttributeFree3{
      ix_ele,
      ix_branch,
      attrib_name,
      err_print_flag,
      except_overlay,
      dependent_attribs_free,
      why_not_free,
      free}};
  return py_result;
}
struct PyInitBeamDistribution : public Bmad::InitBeamDistribution {
  std::optional<bool> conserve_momentum;
  PyInitBeamDistribution(
      Bmad::InitBeamDistribution _base,
      std::optional<bool> conserve_momentum)
      : Bmad::InitBeamDistribution(std::move(_base)),
        conserve_momentum(conserve_momentum) {}
};
PyInitBeamDistribution python_init_beam_distribution(
    EleProxy& ele,
    LatParamProxy& param,
    BeamInitProxy& beam_init,
    optional_ref<NormalModesProxy> modes = std::nullopt,
    std::optional<bool> print_p0c_shift_warning = std::nullopt,
    std::optional<bool> conserve_momentum = std::nullopt) {
  auto _result = Bmad::init_beam_distribution(
      ele,
      param,
      beam_init,
      modes,
      print_p0c_shift_warning,
      make_opt_ref(conserve_momentum));
  auto py_result{PyInitBeamDistribution{_result, conserve_momentum}};
  return py_result;
}
struct PyInitBunchDistribution : public Bmad::InitBunchDistribution {
  std::optional<bool> conserve_momentum;
  PyInitBunchDistribution(
      Bmad::InitBunchDistribution _base,
      std::optional<bool> conserve_momentum)
      : Bmad::InitBunchDistribution(std::move(_base)),
        conserve_momentum(conserve_momentum) {}
};
PyInitBunchDistribution python_init_bunch_distribution(
    EleProxy& ele,
    LatParamProxy& param,
    BeamInitProxy& beam_init,
    int ix_bunch,
    optional_ref<NormalModesProxy> modes = std::nullopt,
    std::optional<bool> print_p0c_shift_warning = std::nullopt,
    std::optional<bool> conserve_momentum = std::nullopt) {
  auto _result = Bmad::init_bunch_distribution(
      ele,
      param,
      beam_init,
      ix_bunch,
      modes,
      print_p0c_shift_warning,
      make_opt_ref(conserve_momentum));
  auto py_result{PyInitBunchDistribution{_result, conserve_momentum}};
  return py_result;
}

struct PyCalcBunchSigmaMatrixEtc {
  BunchParamsProxy bunch_params;
  std::optional<bool> is_time_coords;
};
PyCalcBunchSigmaMatrixEtc python_calc_bunch_sigma_matrix_etc(
    CoordProxyAlloc1D& particle,
    RealAlloc1D& charge,
    std::optional<bool> is_time_coords = std::nullopt,
    optional_ref<EleProxy> ele = std::nullopt) {
  auto _result = Bmad::calc_bunch_sigma_matrix_etc(
      particle, charge, make_opt_ref(is_time_coords), ele);
  auto py_result{PyCalcBunchSigmaMatrixEtc{_result, is_time_coords}};
  return py_result;
}
struct PyDiffusionMatrixB {
  double gamma;
  double g_tot;
  int species;
};
PyDiffusionMatrixB python_diffusion_matrix_b(
    double gamma,
    double g_tot,
    int species,
    FixedArray2D<Real, 6, 6> mat) {
  Bmad::diffusion_matrix_b(gamma, g_tot, species, mat);
  auto py_result{PyDiffusionMatrixB{gamma, g_tot, species}};
  return py_result;
}
struct PyDampingMatrixD {
  double gamma;
  double g_tot;
  double B0;
  double B1;
  double delta;
  int species;
};
PyDampingMatrixD python_damping_matrix_d(
    double gamma,
    double g_tot,
    double B0,
    double B1,
    double delta,
    int species,
    FixedArray2D<Real, 6, 6> mat) {
  Bmad::damping_matrix_d(gamma, g_tot, B0, B1, delta, species, mat);
  auto py_result{PyDampingMatrixD{gamma, g_tot, B0, B1, delta, species}};
  return py_result;
}
struct PyIbsMatrixC {
  bool tail_cut;
  double tau;
  double energy;
  double n_part;
  int species;
};
PyIbsMatrixC python_ibs_matrix_c(
    FixedArray2D<Real, 6, 6> sigma_mat,
    bool tail_cut,
    double tau,
    double energy,
    double n_part,
    int species,
    FixedArray2D<Real, 6, 6> ibs_mat) {
  Bmad::ibs_matrix_c(
      sigma_mat, tail_cut, tau, energy, n_part, species, ibs_mat);
  auto py_result{PyIbsMatrixC{tail_cut, tau, energy, n_part, species}};
  return py_result;
}
struct PyEtdiv {
  double A;
  double B;
  double C;
  double D;
  double E;
  double F;
};
PyEtdiv python_etdiv(
    double A,
    double B,
    double C,
    double D,
    double E,
    double F) {
  Bmad::etdiv(A, B, C, D, E, F);
  auto py_result{PyEtdiv{A, B, C, D, E, F}};
  return py_result;
}
struct PyTouschekRate1Zap {
  double rate;
  std::optional<int> ix;
  std::optional<double> s;
};
PyTouschekRate1Zap python_touschek_rate1_zap(
    NormalModesProxy& mode,
    double rate,
    LatProxy& lat,
    std::optional<int> ix = std::nullopt,
    std::optional<double> s = std::nullopt) {
  Bmad::touschek_rate1_zap(mode, rate, lat, make_opt_ref(ix), make_opt_ref(s));
  auto py_result{PyTouschekRate1Zap{rate, ix, s}};
  return py_result;
}
struct PyIntegrandBase {
  double func_retval__;
};
PyIntegrandBase python_integrand_base(
    double t,
    RealAlloc1D& args,
    double func_retval__) {
  Bmad::integrand_base(t, args, func_retval__);
  auto py_result{PyIntegrandBase{func_retval__}};
  return py_result;
}
struct PyReadBeamFile : public Bmad::ReadBeamFile {
  std::optional<bool> conserve_momentum;
  PyReadBeamFile(
      Bmad::ReadBeamFile _base,
      std::optional<bool> conserve_momentum)
      : Bmad::ReadBeamFile(std::move(_base)),
        conserve_momentum(conserve_momentum) {}
};
PyReadBeamFile python_read_beam_file(
    std::string file_name,
    BeamInitProxy& beam_init,
    optional_ref<EleProxy> ele = std::nullopt,
    std::optional<bool> print_mom_shift_warning = std::nullopt,
    std::optional<bool> conserve_momentum = std::nullopt) {
  auto _result = Bmad::read_beam_file(
      file_name,
      beam_init,
      ele,
      print_mom_shift_warning,
      make_opt_ref(conserve_momentum));
  auto py_result{PyReadBeamFile{_result, conserve_momentum}};
  return py_result;
}
struct PyWriteLineElement {
  std::string line;
  int iu;
};
PyWriteLineElement python_write_line_element(
    std::string line,
    int iu,
    EleProxy& ele,
    LatProxy& lat) {
  Bmad::write_line_element(line, iu, ele, lat);
  auto py_result{PyWriteLineElement{line, iu}};
  return py_result;
}
struct PyReStrRp {
  double rel;
  std::string str_out;
};
PyReStrRp python_re_str_rp(double rel, std::string str_out) {
  Bmad::re_str_rp(rel, str_out);
  auto py_result{PyReStrRp{rel, str_out}};
  return py_result;
}
struct PyReStrQp {
  long double rel;
  std::string str_out;
};
PyReStrQp python_re_str_qp(long double rel, std::string str_out) {
  Bmad::re_str_qp(rel, str_out);
  auto py_result{PyReStrQp{rel, str_out}};
  return py_result;
}
struct PyArrayReStr {
  std::optional<std::string> parens_in;
  std::string str_out;
};
PyArrayReStr python_array_re_str(
    RealAlloc1D& arr,
    std::optional<std::string> parens_in,
    std::string str_out) {
  Bmad::array_re_str(arr, make_opt_ref(parens_in), str_out);
  auto py_result{PyArrayReStr{parens_in, str_out}};
  return py_result;
}
struct PyCmplxReStr {
  std::complex<double> cmp;
  std::string str_out;
};
PyCmplxReStr python_cmplx_re_str(
    std::complex<double> cmp,
    std::string str_out) {
  Bmad::cmplx_re_str(cmp, str_out);
  auto py_result{PyCmplxReStr{cmp, str_out}};
  return py_result;
}
struct PyRchomp {
  double rel;
  int plc;
  std::string out;
};
PyRchomp python_rchomp(double rel, int plc, std::string out) {
  Bmad::rchomp(rel, plc, out);
  auto py_result{PyRchomp{rel, plc, out}};
  return py_result;
}
struct PyWriteLatLine {
  std::string line;
};
PyWriteLatLine python_write_lat_line(
    std::string line,
    int iu,
    bool end_is_neigh,
    std::optional<bool> do_split = std::nullopt,
    std::optional<bool> scibmad = std::nullopt) {
  Bmad::write_lat_line(line, iu, end_is_neigh, do_split, scibmad);
  auto py_result{PyWriteLatLine{line}};
  return py_result;
}
struct PyValueToLine {
  std::string line;
  double value;
  std::string str;
  std::string typ;
  std::optional<bool> ignore_if_zero;
  std::optional<bool> use_comma;
};
PyValueToLine python_value_to_line(
    std::string line,
    double value,
    std::string str,
    std::string typ,
    std::optional<bool> ignore_if_zero = std::nullopt,
    std::optional<bool> use_comma = std::nullopt) {
  Bmad::value_to_line(
      line,
      value,
      str,
      typ,
      make_opt_ref(ignore_if_zero),
      make_opt_ref(use_comma));
  auto py_result{
      PyValueToLine{line, value, str, typ, ignore_if_zero, use_comma}};
  return py_result;
}
struct PyGetCalledFile {
  std::string delim;
  std::string call_file;
  bool err;
};
PyGetCalledFile python_get_called_file(
    std::string delim,
    std::string call_file,
    bool err) {
  Bmad::get_called_file(delim, call_file, err);
  auto py_result{PyGetCalledFile{delim, call_file, err}};
  return py_result;
}
struct PyAddThisTaylorTerm {
  int i_out;
  double coef;
};
PyAddThisTaylorTerm python_add_this_taylor_term(
    EleProxy& ele,
    int i_out,
    double coef,
    FixedArray1D<Int, 6> expn) {
  Bmad::add_this_taylor_term(ele, i_out, coef, expn);
  auto py_result{PyAddThisTaylorTerm{i_out, coef}};
  return py_result;
}
struct PyParserCallCheck {
  std::string word;
  int ix_word;
  std::string delim;
  bool delim_found;
  bool call_found;
  std::optional<bool> err_flag;
};
PyParserCallCheck python_parser_call_check(
    std::string word,
    int ix_word,
    std::string delim,
    bool delim_found,
    bool call_found,
    std::optional<bool> err_flag = std::nullopt) {
  Bmad::parser_call_check(
      word, ix_word, delim, delim_found, call_found, make_opt_ref(err_flag));
  auto py_result{PyParserCallCheck{
      word, ix_word, delim, delim_found, call_found, err_flag}};
  return py_result;
}
struct PyParserFileStack {
  std::string how;
  std::optional<std::string> file_name_in;
  std::optional<bool> finished;
  std::optional<bool> err;
  std::optional<bool> open_file;
  std::optional<bool> abort_on_open_error;
};
PyParserFileStack python_parser_file_stack(
    std::string how,
    std::optional<std::string> file_name_in = std::nullopt,
    std::optional<bool> finished = std::nullopt,
    std::optional<bool> err = std::nullopt,
    std::optional<bool> open_file = std::nullopt,
    std::optional<bool> abort_on_open_error = std::nullopt) {
  Bmad::parser_file_stack(
      how,
      make_opt_ref(file_name_in),
      make_opt_ref(finished),
      make_opt_ref(err),
      make_opt_ref(open_file),
      make_opt_ref(abort_on_open_error));
  auto py_result{PyParserFileStack{
      how, file_name_in, finished, err, open_file, abort_on_open_error}};
  return py_result;
}
struct PyWordToValue {
  std::string word;
  double value;
  bool err_flag;
};
PyWordToValue python_word_to_value(
    std::string word,
    LatProxy& lat,
    double value,
    bool err_flag,
    optional_ref<EleProxy> ele = std::nullopt) {
  Bmad::word_to_value(word, lat, value, err_flag, ele);
  auto py_result{PyWordToValue{word, value, err_flag}};
  return py_result;
}
struct PyParserAddConstant {
  std::string word;
  bool redef_is_error;
};
PyParserAddConstant python_parser_add_constant(
    std::string word,
    LatProxy& lat,
    bool redef_is_error) {
  Bmad::parser_add_constant(word, lat, redef_is_error);
  auto py_result{PyParserAddConstant{word, redef_is_error}};
  return py_result;
}
struct PyParserReadSrWake {
  std::string delim;
  bool delim_found;
  bool err_flag;
};
PyParserReadSrWake python_parser_read_sr_wake(
    EleProxy& ele,
    std::string delim,
    bool delim_found,
    bool err_flag) {
  Bmad::parser_read_sr_wake(ele, delim, delim_found, err_flag);
  auto py_result{PyParserReadSrWake{delim, delim_found, err_flag}};
  return py_result;
}
struct PyParserReadLrWake {
  std::string delim;
  bool delim_found;
  bool err_flag;
};
PyParserReadLrWake python_parser_read_lr_wake(
    EleProxy& ele,
    std::string delim,
    bool delim_found,
    bool err_flag) {
  Bmad::parser_read_lr_wake(ele, delim, delim_found, err_flag);
  auto py_result{PyParserReadLrWake{delim, delim_found, err_flag}};
  return py_result;
}
struct PyCheckForSuperimposeProblem {
  bool err_flag;
  bool wrap;
};
PyCheckForSuperimposeProblem python_check_for_superimpose_problem(
    BranchProxy& branch,
    EleProxy& super_ele,
    bool err_flag,
    optional_ref<EleProxy> ref_ele,
    bool wrap) {
  Bmad::check_for_superimpose_problem(
      branch, super_ele, err_flag, ref_ele, wrap);
  auto py_result{PyCheckForSuperimposeProblem{err_flag, wrap}};
  return py_result;
}
struct PyParseCartesianMap {
  std::string delim;
  bool delim_found;
  bool err_flag;
};
PyParseCartesianMap python_parse_cartesian_map(
    CartesianMapProxy& ct_map,
    EleProxy& ele,
    LatProxy& lat,
    std::string delim,
    bool delim_found,
    bool err_flag) {
  Bmad::parse_cartesian_map(ct_map, ele, lat, delim, delim_found, err_flag);
  auto py_result{PyParseCartesianMap{delim, delim_found, err_flag}};
  return py_result;
}
struct PyParseCylindricalMap {
  std::string delim;
  bool delim_found;
  bool err_flag;
};
PyParseCylindricalMap python_parse_cylindrical_map(
    CylindricalMapProxy& cl_map,
    EleProxy& ele,
    LatProxy& lat,
    std::string delim,
    bool delim_found,
    bool err_flag) {
  Bmad::parse_cylindrical_map(cl_map, ele, lat, delim, delim_found, err_flag);
  auto py_result{PyParseCylindricalMap{delim, delim_found, err_flag}};
  return py_result;
}
struct PyParseGridField {
  std::string delim;
  bool delim_found;
  bool err_flag;
};
PyParseGridField python_parse_grid_field(
    GridFieldProxy& g_field,
    EleProxy& ele,
    LatProxy& lat,
    std::string delim,
    bool delim_found,
    bool err_flag) {
  Bmad::parse_grid_field(g_field, ele, lat, delim, delim_found, err_flag);
  auto py_result{PyParseGridField{delim, delim_found, err_flag}};
  return py_result;
}
struct PyParseGenGradMap {
  std::string delim;
  bool delim_found;
  bool err_flag;
};
PyParseGenGradMap python_parse_gen_grad_map(
    GenGradMapProxy& gg_map,
    EleProxy& ele,
    LatProxy& lat,
    std::string delim,
    bool delim_found,
    bool err_flag) {
  Bmad::parse_gen_grad_map(gg_map, ele, lat, delim, delim_found, err_flag);
  auto py_result{PyParseGenGradMap{delim, delim_found, err_flag}};
  return py_result;
}
struct PyParseIntegerList {
  std::string err_str;
  bool exact_size;
  std::string delim;
  bool delim_found;
  std::optional<std::string> open_delim;
  std::optional<std::string> separator;
  std::optional<std::string> close_delim;
  std::optional<int> default_value;
  bool is_ok;
};
PyParseIntegerList python_parse_integer_list(
    std::string err_str,
    LatProxy& lat,
    IntAlloc1D& int_array,
    bool exact_size,
    std::string delim,
    bool delim_found,
    std::optional<std::string> open_delim,
    std::optional<std::string> separator,
    std::optional<std::string> close_delim,
    std::optional<int> default_value,
    bool is_ok) {
  Bmad::parse_integer_list(
      err_str,
      lat,
      int_array,
      exact_size,
      delim,
      delim_found,
      make_opt_ref(open_delim),
      make_opt_ref(separator),
      make_opt_ref(close_delim),
      make_opt_ref(default_value),
      is_ok);
  auto py_result{PyParseIntegerList{
      err_str,
      exact_size,
      delim,
      delim_found,
      open_delim,
      separator,
      close_delim,
      default_value,
      is_ok}};
  return py_result;
}
struct PyParseIntegerList2 : public Bmad::ParseIntegerList2 {
  std::optional<int> num_expected;
  std::optional<std::string> open_delim;
  std::optional<std::string> separator;
  std::optional<std::string> close_delim;
  std::optional<int> default_value;
  PyParseIntegerList2(
      Bmad::ParseIntegerList2 _base,
      std::optional<int> num_expected,
      std::optional<std::string> open_delim,
      std::optional<std::string> separator,
      std::optional<std::string> close_delim,
      std::optional<int> default_value)
      : Bmad::ParseIntegerList2(std::move(_base)),
        num_expected(num_expected),
        open_delim(open_delim),
        separator(separator),
        close_delim(close_delim),
        default_value(default_value) {}
};
PyParseIntegerList2 python_parse_integer_list2(
    std::string err_str,
    LatProxy& lat,
    IntAlloc1D& int_array,
    std::optional<int> num_expected = std::nullopt,
    std::optional<std::string> open_delim = std::nullopt,
    std::optional<std::string> separator = std::nullopt,
    std::optional<std::string> close_delim = std::nullopt,
    std::optional<int> default_value = std::nullopt) {
  auto _result = Bmad::parse_integer_list2(
      err_str,
      lat,
      int_array,
      make_opt_ref(num_expected),
      make_opt_ref(open_delim),
      make_opt_ref(separator),
      make_opt_ref(close_delim),
      make_opt_ref(default_value));
  auto py_result{PyParseIntegerList2{
      _result,
      num_expected,
      open_delim,
      separator,
      close_delim,
      default_value}};
  return py_result;
}
struct PyParseRealList2 : public Bmad::ParseRealList2 {
  std::optional<int> num_expected;
  std::optional<std::string> open_brace;
  std::optional<std::string> separator;
  std::optional<std::string> close_brace;
  std::optional<double> default_value;
  std::optional<bool> single_value;
  PyParseRealList2(
      Bmad::ParseRealList2 _base,
      std::optional<int> num_expected,
      std::optional<std::string> open_brace,
      std::optional<std::string> separator,
      std::optional<std::string> close_brace,
      std::optional<double> default_value,
      std::optional<bool> single_value)
      : Bmad::ParseRealList2(std::move(_base)),
        num_expected(num_expected),
        open_brace(open_brace),
        separator(separator),
        close_brace(close_brace),
        default_value(default_value),
        single_value(single_value) {}
};
PyParseRealList2 python_parse_real_list2(
    LatProxy& lat,
    std::string err_str,
    RealAlloc1D& real_array,
    std::optional<int> num_expected = std::nullopt,
    std::optional<std::string> open_brace = std::nullopt,
    std::optional<std::string> separator = std::nullopt,
    std::optional<std::string> close_brace = std::nullopt,
    std::optional<double> default_value = std::nullopt,
    std::optional<bool> single_value = std::nullopt) {
  auto _result = Bmad::parse_real_list2(
      lat,
      err_str,
      real_array,
      make_opt_ref(num_expected),
      make_opt_ref(open_brace),
      make_opt_ref(separator),
      make_opt_ref(close_brace),
      make_opt_ref(default_value),
      make_opt_ref(single_value));
  auto py_result{PyParseRealList2{
      _result,
      num_expected,
      open_brace,
      separator,
      close_brace,
      default_value,
      single_value}};
  return py_result;
}
struct PyParserGetInteger {
  int int_val;
  std::string word;
  int ix_word;
  std::string delim;
  bool delim_found;
  bool err;
  std::optional<std::string> str1;
  std::optional<std::string> str2;
};
PyParserGetInteger python_parser_get_integer(
    int int_val,
    std::string word,
    int ix_word,
    std::string delim,
    bool delim_found,
    bool err,
    std::optional<std::string> str1 = std::nullopt,
    std::optional<std::string> str2 = std::nullopt) {
  Bmad::parser_get_integer(
      int_val,
      word,
      ix_word,
      delim,
      delim_found,
      err,
      make_opt_ref(str1),
      make_opt_ref(str2));
  auto py_result{PyParserGetInteger{
      int_val, word, ix_word, delim, delim_found, err, str1, str2}};
  return py_result;
}
struct PyParserGetLogical {
  std::string attrib_name;
  bool this_logic;
  std::string ele_name;
  std::string delim;
  bool delim_found;
  bool err;
};
PyParserGetLogical python_parser_get_logical(
    std::string attrib_name,
    bool this_logic,
    std::string ele_name,
    std::string delim,
    bool delim_found,
    bool err) {
  Bmad::parser_get_logical(
      attrib_name, this_logic, ele_name, delim, delim_found, err);
  auto py_result{PyParserGetLogical{
      attrib_name, this_logic, ele_name, delim, delim_found, err}};
  return py_result;
}
struct PyExpectOneOf {
  std::string delim;
  bool delim_found;
  bool is_ok;
};
PyExpectOneOf python_expect_one_of(
    std::string delim_list,
    bool check_input_delim,
    std::string ele_name,
    std::string delim,
    bool delim_found,
    bool is_ok) {
  Bmad::expect_one_of(
      delim_list, check_input_delim, ele_name, delim, delim_found, is_ok);
  auto py_result{PyExpectOneOf{delim, delim_found, is_ok}};
  return py_result;
}
struct PyEqualSignHere {
  std::string delim;
  bool is_here;
};
PyEqualSignHere python_equal_sign_here(
    EleProxy& ele,
    std::string delim,
    bool is_here) {
  Bmad::equal_sign_here(ele, delim, is_here);
  auto py_result{PyEqualSignHere{delim, is_here}};
  return py_result;
}
struct PyParserPrintLine {
  bool end_of_file;
};
PyParserPrintLine python_parser_print_line(LatProxy& lat, bool end_of_file) {
  Bmad::parser_print_line(lat, end_of_file);
  auto py_result{PyParserPrintLine{end_of_file}};
  return py_result;
}
struct PyInitSurfaceSegment {
  int ix;
  int iy;
};
PyInitSurfaceSegment python_init_surface_segment(
    PhotonElementProxy& phot,
    int ix,
    int iy) {
  Bmad::init_surface_segment(phot, ix, iy);
  auto py_result{PyInitSurfaceSegment{ix, iy}};
  return py_result;
}
struct PyParserFastIntegerRead {
  std::string delim_wanted;
  std::string err_str;
  bool is_ok;
};
PyParserFastIntegerRead python_parser_fast_integer_read(
    IntAlloc1D& int_vec,
    EleProxy& ele,
    std::string delim_wanted,
    std::string err_str,
    bool is_ok) {
  Bmad::parser_fast_integer_read(int_vec, ele, delim_wanted, err_str, is_ok);
  auto py_result{PyParserFastIntegerRead{delim_wanted, err_str, is_ok}};
  return py_result;
}
struct PyZAtSurface : public Bmad::ZAtSurface {
  double x;
  double y;
  PyZAtSurface(Bmad::ZAtSurface _base, double x, double y)
      : Bmad::ZAtSurface(std::move(_base)), x(x), y(y) {}
};
PyZAtSurface python_z_at_surface(
    EleProxy& ele,
    double x,
    double y,
    std::optional<bool> extend_grid = std::nullopt) {
  auto _result = Bmad::z_at_surface(ele, x, y, extend_grid);
  auto py_result{PyZAtSurface{_result, x, y}};
  return py_result;
}
struct PySurfaceGridDisplacement {
  double x;
  double y;
};
PySurfaceGridDisplacement python_surface_grid_displacement(
    EleProxy& ele,
    double x,
    double y,
    bool err_flag,
    double z,
    std::optional<FixedArray1D<Real, 2>> dz_dxy = std::nullopt,
    std::optional<bool> extend_grid = std::nullopt) {
  Bmad::surface_grid_displacement(ele, x, y, err_flag, z, dz_dxy, extend_grid);
  auto py_result{PySurfaceGridDisplacement{x, y}};
  return py_result;
}

struct PyPointerToSurfaceSegmentedPt {
  SurfaceSegmentedPtProxy pt;
  double x;
  double y;
  std::optional<int> ix;
  std::optional<int> iy;
  std::optional<double> xx;
  std::optional<double> yy;
};
PyPointerToSurfaceSegmentedPt python_pointer_to_surface_segmented_pt(
    EleProxy& ele,
    bool nearest,
    double x,
    double y,
    std::optional<int> ix = std::nullopt,
    std::optional<int> iy = std::nullopt,
    std::optional<bool> extend_grid = std::nullopt,
    std::optional<double> xx = std::nullopt,
    std::optional<double> yy = std::nullopt) {
  auto _result = Bmad::pointer_to_surface_segmented_pt(
      ele,
      nearest,
      x,
      y,
      make_opt_ref(ix),
      make_opt_ref(iy),
      extend_grid,
      make_opt_ref(xx),
      make_opt_ref(yy));
  auto py_result{PyPointerToSurfaceSegmentedPt{_result, x, y, ix, iy, xx, yy}};
  return py_result;
}

struct PyPointerToSurfaceDisplacementPt {
  SurfaceDisplacementPtProxy pt;
  double x;
  double y;
  std::optional<int> ix;
  std::optional<int> iy;
  std::optional<double> xx;
  std::optional<double> yy;
};
PyPointerToSurfaceDisplacementPt python_pointer_to_surface_displacement_pt(
    EleProxy& ele,
    bool nearest,
    double x,
    double y,
    std::optional<int> ix = std::nullopt,
    std::optional<int> iy = std::nullopt,
    std::optional<bool> extend_grid = std::nullopt,
    std::optional<double> xx = std::nullopt,
    std::optional<double> yy = std::nullopt) {
  auto _result = Bmad::pointer_to_surface_displacement_pt(
      ele,
      nearest,
      x,
      y,
      make_opt_ref(ix),
      make_opt_ref(iy),
      extend_grid,
      make_opt_ref(xx),
      make_opt_ref(yy));
  auto py_result{
      PyPointerToSurfaceDisplacementPt{_result, x, y, ix, iy, xx, yy}};
  return py_result;
}
struct PyTargetMinMaxCalc {
  double y_min;
  double y_max;
  double phi_min;
  double phi_max;
};
PyTargetMinMaxCalc python_target_min_max_calc(
    FixedArray1D<Real, 3> r_corner1,
    FixedArray1D<Real, 3> r_corner2,
    double y_min,
    double y_max,
    double phi_min,
    double phi_max,
    std::optional<bool> initial = std::nullopt) {
  Bmad::target_min_max_calc(
      r_corner1, r_corner2, y_min, y_max, phi_min, phi_max, initial);
  auto py_result{PyTargetMinMaxCalc{y_min, y_max, phi_min, phi_max}};
  return py_result;
}

struct PyPhotonTargetCornerCalc {
  TargetPointProxy corner;
  double x_lim;
  double y_lim;
  double z_lim;
};
PyPhotonTargetCornerCalc python_photon_target_corner_calc(
    EleProxy& aperture_ele,
    double x_lim,
    double y_lim,
    double z_lim,
    EleProxy& source_ele) {
  auto _result = Bmad::photon_target_corner_calc(
      aperture_ele, x_lim, y_lim, z_lim, source_ele);
  auto py_result{PyPhotonTargetCornerCalc{_result, x_lim, y_lim, z_lim}};
  return py_result;
}
struct PyPhotonAddToDetectorStatistics {
  std::optional<int> ix_pt;
  std::optional<int> iy_pt;
};
PyPhotonAddToDetectorStatistics python_photon_add_to_detector_statistics(
    CoordProxy& orbit0,
    CoordProxy& orbit,
    EleProxy& ele,
    std::optional<int> ix_pt = std::nullopt,
    std::optional<int> iy_pt = std::nullopt,
    optional_ref<PixelPtProxy> pixel_pt = std::nullopt) {
  Bmad::photon_add_to_detector_statistics(
      orbit0, orbit, ele, make_opt_ref(ix_pt), make_opt_ref(iy_pt), pixel_pt);
  auto py_result{PyPhotonAddToDetectorStatistics{ix_pt, iy_pt}};
  return py_result;
}
struct PyNormalFormComplexTaylors {
  bool rf_on;
  std::optional<int> order;
};
PyNormalFormComplexTaylors python_normal_form_complex_taylors(
    FixedArray1D<TaylorProxy, 6> one_turn_taylor,
    bool rf_on,
    std::optional<FixedArray1D<ComplexTaylorProxy, 6>> F = std::nullopt,
    std::optional<FixedArray1D<ComplexTaylorProxy, 6>> L = std::nullopt,
    std::optional<FixedArray1D<TaylorProxy, 6>> A = std::nullopt,
    std::optional<FixedArray1D<TaylorProxy, 6>> A_inverse = std::nullopt,
    std::optional<int> order = std::nullopt) {
  Bmad::normal_form_complex_taylors(
      one_turn_taylor, rf_on, F, L, A, A_inverse, make_opt_ref(order));
  auto py_result{PyNormalFormComplexTaylors{rf_on, order}};
  return py_result;
}
struct PySetPtcVerbose {
  bool on;
};
PySetPtcVerbose python_set_ptc_verbose(bool on) {
  Bmad::set_ptc_verbose(on);
  auto py_result{PySetPtcVerbose{on}};
  return py_result;
}
struct PySetPtcQuiet {
  int old_val;
};
PySetPtcQuiet python_set_ptc_quiet(int channel, bool set, int old_val) {
  Bmad::set_ptc_quiet(channel, set, old_val);
  auto py_result{PySetPtcQuiet{old_val}};
  return py_result;
}
struct PyCoulombfun {
  double u;
  double v;
  double w;
  double gam;
  double res;
};
PyCoulombfun python_coulombfun(
    double u,
    double v,
    double w,
    double gam,
    double res) {
  Bmad::coulombfun(u, v, w, gam, res);
  auto py_result{PyCoulombfun{u, v, w, gam, res}};
  return py_result;
}
struct PyIgfcoulombfun {
  double u;
  double v;
  double w;
  double gam;
  double dx;
  double dy;
  double dz;
  double res;
};
PyIgfcoulombfun python_igfcoulombfun(
    double u,
    double v,
    double w,
    double gam,
    double dx,
    double dy,
    double dz,
    double res) {
  Bmad::igfcoulombfun(u, v, w, gam, dx, dy, dz, res);
  auto py_result{PyIgfcoulombfun{u, v, w, gam, dx, dy, dz, res}};
  return py_result;
}
struct PyLafun {
  double x;
  double y;
  double z;
  double res;
};
PyLafun python_lafun(double x, double y, double z, double res) {
  Bmad::lafun(x, y, z, res);
  auto py_result{PyLafun{x, y, z, res}};
  return py_result;
}
struct PyIgfexfun {
  double u;
  double v;
  double w;
  double gam;
  double dx;
  double dy;
  double dz;
  double res;
};
PyIgfexfun python_igfexfun(
    double u,
    double v,
    double w,
    double gam,
    double dx,
    double dy,
    double dz,
    double res) {
  Bmad::igfexfun(u, v, w, gam, dx, dy, dz, res);
  auto py_result{PyIgfexfun{u, v, w, gam, dx, dy, dz, res}};
  return py_result;
}
struct PyIgfeyfun {
  double u;
  double v;
  double w;
  double gam;
  double dx;
  double dy;
  double dz;
  double res;
};
PyIgfeyfun python_igfeyfun(
    double u,
    double v,
    double w,
    double gam,
    double dx,
    double dy,
    double dz,
    double res) {
  Bmad::igfeyfun(u, v, w, gam, dx, dy, dz, res);
  auto py_result{PyIgfeyfun{u, v, w, gam, dx, dy, dz, res}};
  return py_result;
}
struct PyIgfezfun {
  double u;
  double v;
  double w;
  double gam;
  double dx;
  double dy;
  double dz;
  double res;
};
PyIgfezfun python_igfezfun(
    double u,
    double v,
    double w,
    double gam,
    double dx,
    double dy,
    double dz,
    double res) {
  Bmad::igfezfun(u, v, w, gam, dx, dy, dz, res);
  auto py_result{PyIgfezfun{u, v, w, gam, dx, dy, dz, res}};
  return py_result;
}
struct PyXlafun {
  double x;
  double y;
  double z;
  double res;
};
PyXlafun python_xlafun(double x, double y, double z, double res) {
  Bmad::xlafun(x, y, z, res);
  auto py_result{PyXlafun{x, y, z, res}};
  return py_result;
}
struct PyYlafun {
  double x;
  double y;
  double z;
  double res;
};
PyYlafun python_ylafun(double x, double y, double z, double res) {
  Bmad::ylafun(x, y, z, res);
  auto py_result{PyYlafun{x, y, z, res}};
  return py_result;
}
struct PyZlafun {
  double x;
  double y;
  double z;
  double res;
};
PyZlafun python_zlafun(double x, double y, double z, double res) {
  Bmad::zlafun(x, y, z, res);
  auto py_result{PyZlafun{x, y, z, res}};
  return py_result;
}
struct PyOscGetgrnpipe {
  double gam;
  double a;
  double b;
};
PyOscGetgrnpipe python_osc_getgrnpipe(
    double gam,
    double a,
    double b,
    FixedArray1D<Real, 3> delta,
    FixedArray1D<Real, 3> umin,
    FixedArray1D<Int, 3> npad) {
  Bmad::osc_getgrnpipe(gam, a, b, delta, umin, npad);
  auto py_result{PyOscGetgrnpipe{gam, a, b}};
  return py_result;
}
struct PyRfun {
  double u;
  double v;
  double w;
  double gam;
  double a;
  double b;
  double hz;
  int i;
  int j;
  double res;
};
PyRfun python_rfun(
    double u,
    double v,
    double w,
    double gam,
    double a,
    double b,
    double hz,
    int i,
    int j,
    double res) {
  Bmad::rfun(u, v, w, gam, a, b, hz, i, j, res);
  auto py_result{PyRfun{u, v, w, gam, a, b, hz, i, j, res}};
  return py_result;
}
struct PyOscWriteRectpipeGrn {
  double apipe;
  double bpipe;
  double gamma;
};
PyOscWriteRectpipeGrn python_osc_write_rectpipe_grn(
    double apipe,
    double bpipe,
    FixedArray1D<Real, 3> delta,
    FixedArray1D<Real, 3> umin,
    FixedArray1D<Real, 3> umax,
    FixedArray1D<Int, 3> nlo,
    FixedArray1D<Int, 3> nhi,
    double gamma) {
  Bmad::osc_write_rectpipe_grn(
      apipe, bpipe, delta, umin, umax, nlo, nhi, gamma);
  auto py_result{PyOscWriteRectpipeGrn{apipe, bpipe, gamma}};
  return py_result;
}

struct PyScStep {
  int n_emit;
  bool include_image;
};
PyScStep python_sc_step(
    BunchProxy& bunch,
    EleProxy& ele,
    bool include_image,
    double t_end,
    EmFieldProxyAlloc1D& sc_field) {
  auto _result = Bmad::sc_step(bunch, ele, include_image, t_end, sc_field);
  auto py_result{PyScStep{_result, include_image}};
  return py_result;
}

struct PyScAdaptiveStep {
  double dt_next;
  bool include_image;
  double dt_step;
};
PyScAdaptiveStep python_sc_adaptive_step(
    BunchProxy& bunch,
    EleProxy& ele,
    bool include_image,
    double t_now,
    double dt_step,
    EmFieldProxyAlloc1D& sc_field) {
  auto _result = Bmad::sc_adaptive_step(
      bunch, ele, include_image, t_now, dt_step, sc_field);
  auto py_result{PyScAdaptiveStep{_result, include_image, dt_step}};
  return py_result;
}
struct PySetParameterReal {
  double param_val;
  double set_val;
  double save_val;
};
PySetParameterReal python_set_parameter_real(
    double param_val,
    double set_val,
    double save_val) {
  SimUtils::set_parameter(param_val, set_val, save_val);
  auto py_result{PySetParameterReal{param_val, set_val, save_val}};
  return py_result;
}
struct PySetParameterInt {
  int param_val;
  int set_val;
  int save_val;
};
PySetParameterInt python_set_parameter_int(
    int param_val,
    int set_val,
    int save_val) {
  SimUtils::set_parameter(param_val, set_val, save_val);
  auto py_result{PySetParameterInt{param_val, set_val, save_val}};
  return py_result;
}
struct PySetParameterLogic {
  bool param_val;
  bool set_val;
  bool save_val;
};
PySetParameterLogic python_set_parameter_logic(
    bool param_val,
    bool set_val,
    bool save_val) {
  SimUtils::set_parameter(param_val, set_val, save_val);
  auto py_result{PySetParameterLogic{param_val, set_val, save_val}};
  return py_result;
}
struct PyCosc {
  double y;
};
PyCosc python_cosc(double x, std::optional<int> nd, double y) {
  SimUtils::cosc(x, nd, y);
  auto py_result{PyCosc{y}};
  return py_result;
}
struct PyAsinc {
  double y;
};
PyAsinc python_asinc(double x, std::optional<int> nd, double y) {
  SimUtils::asinc(x, nd, y);
  auto py_result{PyAsinc{y}};
  return py_result;
}
struct PyAssertEqual {
  std::string err_str;
  int ival;
};
PyAssertEqual python_assert_equal(
    IntAlloc1D& int_arr,
    std::string err_str,
    int ival) {
  SimUtils::assert_equal(int_arr, err_str, ival);
  auto py_result{PyAssertEqual{err_str, ival}};
  return py_result;
}
struct PyCalcFileNumber {
  std::string file_name;
  int num_in;
  int num_out;
  bool err_flag;
};
PyCalcFileNumber python_calc_file_number(
    std::string file_name,
    int num_in,
    int num_out,
    bool err_flag) {
  SimUtils::calc_file_number(file_name, num_in, num_out, err_flag);
  auto py_result{PyCalcFileNumber{file_name, num_in, num_out, err_flag}};
  return py_result;
}
struct PyChangeFileNumber {
  std::string file_name;
  int change;
};
PyChangeFileNumber python_change_file_number(
    std::string file_name,
    int change) {
  SimUtils::change_file_number(file_name, change);
  auto py_result{PyChangeFileNumber{file_name, change}};
  return py_result;
}
struct PyCosOne {
  double cos1;
};
PyCosOne python_cos_one(double angle, double cos1) {
  SimUtils::cos_one(angle, cos1);
  auto py_result{PyCosOne{cos1}};
  return py_result;
}
struct PyComplexErrorFunction {
  double wr;
  double wi;
  double zr;
  double zi;
};
PyComplexErrorFunction python_complex_error_function(
    double wr,
    double wi,
    double zr,
    double zi) {
  SimUtils::complex_error_function(wr, wi, zr, zi);
  auto py_result{PyComplexErrorFunction{wr, wi, zr, zi}};
  return py_result;
}
struct PyDateAndTimeStamp {
  std::string string;
  std::optional<bool> numeric_month;
  std::optional<bool> include_zone;
};
PyDateAndTimeStamp python_date_and_time_stamp(
    std::string string,
    std::optional<bool> numeric_month = std::nullopt,
    std::optional<bool> include_zone = std::nullopt) {
  SimUtils::date_and_time_stamp(
      string, make_opt_ref(numeric_month), make_opt_ref(include_zone));
  auto py_result{PyDateAndTimeStamp{string, numeric_month, include_zone}};
  return py_result;
}
struct PyDetab {
  std::string str;
};
PyDetab python_detab(std::string str) {
  SimUtils::detab(str);
  auto py_result{PyDetab{str}};
  return py_result;
}
struct PyDisplaySizeAndResolution {
  int ix_screen;
  double x_size;
  double y_size;
  double x_res;
  double y_res;
};
PyDisplaySizeAndResolution python_display_size_and_resolution(
    int ix_screen,
    double x_size,
    double y_size,
    double x_res,
    double y_res) {
  SimUtils::display_size_and_resolution(
      ix_screen, x_size, y_size, x_res, y_res);
  auto py_result{
      PyDisplaySizeAndResolution{ix_screen, x_size, y_size, x_res, y_res}};
  return py_result;
}
struct PyDjBessel {
  int m;
  double arg;
  double dj_bes;
};
PyDjBessel python_dj_bessel(int m, double arg, double dj_bes) {
  SimUtils::dj_bessel(m, arg, dj_bes);
  auto py_result{PyDjBessel{m, arg, dj_bes}};
  return py_result;
}
struct PyDjbHash {
  std::string str;
  std::optional<int> old_hash;
  int hash;
};
PyDjbHash python_djb_hash(
    std::string str,
    std::optional<int> old_hash,
    int hash) {
  SimUtils::djb_hash(str, make_opt_ref(old_hash), hash);
  auto py_result{PyDjbHash{str, old_hash, hash}};
  return py_result;
}
struct PyDjbStrHash {
  std::string in_str;
  std::string hash_str;
};
PyDjbStrHash python_djb_str_hash(std::string in_str, std::string hash_str) {
  SimUtils::djb_str_hash(in_str, hash_str);
  auto py_result{PyDjbStrHash{in_str, hash_str}};
  return py_result;
}
struct PyDowncaseString {
  std::string string;
};
PyDowncaseString python_downcase_string(std::string string) {
  SimUtils::downcase_string(string);
  auto py_result{PyDowncaseString{string}};
  return py_result;
}
struct PyErrExit {
  std::optional<std::string> err_str;
};
PyErrExit python_err_exit(std::optional<std::string> err_str = std::nullopt) {
  SimUtils::err_exit(make_opt_ref(err_str));
  auto py_result{PyErrExit{err_str}};
  return py_result;
}
struct PyFactorial {
  int n;
  double fact;
};
PyFactorial python_factorial(int n, double fact) {
  SimUtils::factorial(n, fact);
  auto py_result{PyFactorial{n, fact}};
  return py_result;
}
struct PyFileDirectorizer {
  std::string in_file;
  std::string out_file;
  std::string directory;
  bool add_switch;
};
PyFileDirectorizer python_file_directorizer(
    std::string in_file,
    std::string out_file,
    std::string directory,
    bool add_switch) {
  SimUtils::file_directorizer(in_file, out_file, directory, add_switch);
  auto py_result{PyFileDirectorizer{in_file, out_file, directory, add_switch}};
  return py_result;
}
struct PyFileGet {
  std::string string;
  std::string dflt_file_name;
  std::string file_name;
};
PyFileGet python_file_get(
    std::string string,
    std::string dflt_file_name,
    std::string file_name) {
  SimUtils::file_get(string, dflt_file_name, file_name);
  auto py_result{PyFileGet{string, dflt_file_name, file_name}};
  return py_result;
}
struct PyFileGetOpen {
  std::string string;
  std::string dflt_file_name;
  std::string file_name;
  int file_unit;
  bool readonly;
};
PyFileGetOpen python_file_get_open(
    std::string string,
    std::string dflt_file_name,
    std::string file_name,
    int file_unit,
    bool readonly) {
  SimUtils::file_get_open(
      string, dflt_file_name, file_name, file_unit, readonly);
  auto py_result{
      PyFileGetOpen{string, dflt_file_name, file_name, file_unit, readonly}};
  return py_result;
}
struct PyFileSuffixer {
  std::string in_file_name;
  std::string out_file_name;
  std::string suffix;
  bool add_switch;
};
PyFileSuffixer python_file_suffixer(
    std::string in_file_name,
    std::string out_file_name,
    std::string suffix,
    bool add_switch) {
  SimUtils::file_suffixer(in_file_name, out_file_name, suffix, add_switch);
  auto py_result{
      PyFileSuffixer{in_file_name, out_file_name, suffix, add_switch}};
  return py_result;
}
struct PyGenCompleteElliptic {
  double kc;
  double p;
  double c;
  double s;
  std::optional<double> err_tol;
  double value;
};
PyGenCompleteElliptic python_gen_complete_elliptic(
    double kc,
    double p,
    double c,
    double s,
    std::optional<double> err_tol,
    double value) {
  SimUtils::gen_complete_elliptic(kc, p, c, s, make_opt_ref(err_tol), value);
  auto py_result{PyGenCompleteElliptic{kc, p, c, s, err_tol, value}};
  return py_result;
}
struct PyGetFileNumber {
  std::string file_name;
  std::string cnum_in;
  int num_out;
  bool err_flag;
};
PyGetFileNumber python_get_file_number(
    std::string file_name,
    std::string cnum_in,
    int num_out,
    bool err_flag) {
  SimUtils::get_file_number(file_name, cnum_in, num_out, err_flag);
  auto py_result{PyGetFileNumber{file_name, cnum_in, num_out, err_flag}};
  return py_result;
}
struct PyGetFileTimeStamp {
  std::string file;
  std::string time_stamp;
};
PyGetFileTimeStamp python_get_file_time_stamp(
    std::string file,
    std::string time_stamp) {
  SimUtils::get_file_time_stamp(file, time_stamp);
  auto py_result{PyGetFileTimeStamp{file, time_stamp}};
  return py_result;
}
struct PyIBessel {
  int m;
  double arg;
  double i_bes;
};
PyIBessel python_i_bessel(int m, double arg, double i_bes) {
  SimUtils::i_bessel(m, arg, i_bes);
  auto py_result{PyIBessel{m, arg, i_bes}};
  return py_result;
}
struct PyIBesselExtended {
  int m;
  double arg;
  std::complex<double> i_bes;
};
PyIBesselExtended python_i_bessel_extended(
    int m,
    double arg,
    std::complex<double> i_bes) {
  SimUtils::i_bessel_extended(m, arg, i_bes);
  auto py_result{PyIBesselExtended{m, arg, i_bes}};
  return py_result;
}
struct PyIncrementFileNumber {
  std::string file_name;
  int digits;
  int number;
  std::string cnumber;
};
PyIncrementFileNumber python_increment_file_number(
    std::string file_name,
    int digits,
    int number,
    std::string cnumber) {
  SimUtils::increment_file_number(file_name, digits, number, cnumber);
  auto py_result{PyIncrementFileNumber{file_name, digits, number, cnumber}};
  return py_result;
}
struct PyIndexNocase {
  std::string string1;
  std::string string2;
  int indx;
};
PyIndexNocase python_index_nocase(
    std::string string1,
    std::string string2,
    int indx) {
  SimUtils::index_nocase(string1, string2, indx);
  auto py_result{PyIndexNocase{string1, string2, indx}};
  return py_result;
}
struct PyIntStr {
  int int_;
  std::optional<int> width;
  std::string str;
};
PyIntStr python_int_str(int int_, std::optional<int> width, std::string str) {
  SimUtils::int_str(int_, make_opt_ref(width), str);
  auto py_result{PyIntStr{int_, width, str}};
  return py_result;
}
struct PyIsAlphabetic {
  std::string string;
  std::optional<std::string> valid_chars;
  bool is_alpha;
};
PyIsAlphabetic python_is_alphabetic(
    std::string string,
    std::optional<std::string> valid_chars,
    bool is_alpha) {
  SimUtils::is_alphabetic(string, make_opt_ref(valid_chars), is_alpha);
  auto py_result{PyIsAlphabetic{string, valid_chars, is_alpha}};
  return py_result;
}
struct PyIsDecreasingSequence {
  bool is_decreasing;
};
PyIsDecreasingSequence python_is_decreasing_sequence(
    RealAlloc1D& array,
    std::optional<bool> strict,
    bool is_decreasing) {
  SimUtils::is_decreasing_sequence(array, strict, is_decreasing);
  auto py_result{PyIsDecreasingSequence{is_decreasing}};
  return py_result;
}
struct PyIsIncreasingSequence {
  bool is_increasing;
};
PyIsIncreasingSequence python_is_increasing_sequence(
    RealAlloc1D& array,
    std::optional<bool> strict,
    bool is_increasing) {
  SimUtils::is_increasing_sequence(array, strict, is_increasing);
  auto py_result{PyIsIncreasingSequence{is_increasing}};
  return py_result;
}
struct PyIsInteger {
  std::string string;
  std::optional<int> int_;
  std::optional<std::string> delims;
  std::optional<int> ix_word;
  bool valid;
};
PyIsInteger python_is_integer(
    std::string string,
    std::optional<int> int_,
    std::optional<std::string> delims,
    std::optional<int> ix_word,
    bool valid) {
  SimUtils::is_integer(
      string,
      make_opt_ref(int_),
      make_opt_ref(delims),
      make_opt_ref(ix_word),
      valid);
  auto py_result{PyIsInteger{string, int_, delims, ix_word, valid}};
  return py_result;
}
struct PyIsLogical {
  std::string string;
  std::optional<bool> ignore;
  bool valid;
};
PyIsLogical python_is_logical(
    std::string string,
    std::optional<bool> ignore,
    bool valid) {
  SimUtils::is_logical(string, make_opt_ref(ignore), valid);
  auto py_result{PyIsLogical{string, ignore, valid}};
  return py_result;
}
struct PyIsReal {
  std::string string;
  std::optional<bool> ignore;
  std::optional<double> real_num;
  bool valid;
};
PyIsReal python_is_real(
    std::string string,
    std::optional<bool> ignore,
    std::optional<double> real_num,
    bool valid) {
  SimUtils::is_real(
      string, make_opt_ref(ignore), make_opt_ref(real_num), valid);
  auto py_result{PyIsReal{string, ignore, real_num, valid}};
  return py_result;
}
struct PyJBessel {
  int m;
  double arg;
  double j_bes;
};
PyJBessel python_j_bessel(int m, double arg, double j_bes) {
  SimUtils::j_bessel(m, arg, j_bes);
  auto py_result{PyJBessel{m, arg, j_bes}};
  return py_result;
}
struct PyLinearFit {
  int n_data;
  double a;
  double b;
  double sig_a;
  double sig_b;
};
PyLinearFit python_linear_fit(
    RealAlloc1D& x,
    RealAlloc1D& y,
    int n_data,
    double a,
    double b,
    double sig_a,
    double sig_b) {
  SimUtils::linear_fit(x, y, n_data, a, b, sig_a, sig_b);
  auto py_result{PyLinearFit{n_data, a, b, sig_a, sig_b}};
  return py_result;
}
struct PyLogicStr {
  bool logic;
  std::string str;
};
PyLogicStr python_logic_str(bool logic, std::string str) {
  SimUtils::logic_str(logic, str);
  auto py_result{PyLogicStr{logic, str}};
  return py_result;
}
struct PyMatchReg {
  std::string str;
  std::string pat;
  bool is_match;
};
PyMatchReg python_match_reg(std::string str, std::string pat, bool is_match) {
  SimUtils::match_reg(str, pat, is_match);
  auto py_result{PyMatchReg{str, pat, is_match}};
  return py_result;
}
struct PyMilliSleep {
  int milli_sec;
};
PyMilliSleep python_milli_sleep(int milli_sec) {
  SimUtils::milli_sleep(milli_sec);
  auto py_result{PyMilliSleep{milli_sec}};
  return py_result;
}
struct PyMakeLegalComment {
  std::string comment_in;
  std::string comment_out;
};
PyMakeLegalComment python_make_legal_comment(
    std::string comment_in,
    std::string comment_out) {
  SimUtils::make_legal_comment(comment_in, comment_out);
  auto py_result{PyMakeLegalComment{comment_in, comment_out}};
  return py_result;
}
struct PyMatchWild {
  std::string string;
  std::string template_;
  bool is_match;
};
PyMatchWild python_match_wild(
    std::string string,
    std::string template_,
    bool is_match) {
  SimUtils::match_wild(string, template_, is_match);
  auto py_result{PyMatchWild{string, template_, is_match}};
  return py_result;
}
struct PyNChooseK {
  int n;
  int k;
  double nck;
};
PyNChooseK python_n_choose_k(int n, int k, double nck) {
  SimUtils::n_choose_k(n, k, nck);
  auto py_result{PyNChooseK{n, k, nck}};
  return py_result;
}
struct PyNametableAdd {
  std::string name;
  int ix_name;
};
PyNametableAdd python_nametable_add(
    NametableProxy& nametable,
    std::string name,
    int ix_name) {
  SimUtils::nametable_add(nametable, name, ix_name);
  auto py_result{PyNametableAdd{name, ix_name}};
  return py_result;
}
struct PyNametableBracketIndexx {
  std::string name;
  std::optional<int> n_match;
  int ix_max;
};
PyNametableBracketIndexx python_nametable_bracket_indexx(
    NametableProxy& nametable,
    std::string name,
    std::optional<int> n_match,
    int ix_max) {
  SimUtils::nametable_bracket_indexx(
      nametable, name, make_opt_ref(n_match), ix_max);
  auto py_result{PyNametableBracketIndexx{name, n_match, ix_max}};
  return py_result;
}
struct PyNametableChange1 {
  std::string name;
  int ix_name;
};
PyNametableChange1 python_nametable_change1(
    NametableProxy& nametable,
    std::string name,
    int ix_name) {
  SimUtils::nametable_change1(nametable, name, ix_name);
  auto py_result{PyNametableChange1{name, ix_name}};
  return py_result;
}
struct PyNametableInit {
  std::optional<int> n_min;
  std::optional<int> n_max;
};
PyNametableInit python_nametable_init(
    NametableProxy& nametable,
    std::optional<int> n_min = std::nullopt,
    std::optional<int> n_max = std::nullopt) {
  SimUtils::nametable_init(nametable, make_opt_ref(n_min), make_opt_ref(n_max));
  auto py_result{PyNametableInit{n_min, n_max}};
  return py_result;
}
struct PyNametableRemove {
  int ix_name;
};
PyNametableRemove python_nametable_remove(
    NametableProxy& nametable,
    int ix_name) {
  SimUtils::nametable_remove(nametable, ix_name);
  auto py_result{PyNametableRemove{ix_name}};
  return py_result;
}
struct PyOrdinalStr {
  int n;
  std::string str;
};
PyOrdinalStr python_ordinal_str(int n, std::string str) {
  SimUtils::ordinal_str(n, str);
  auto py_result{PyOrdinalStr{n, str}};
  return py_result;
}
struct PyParseFortranFormat {
  std::string format_str;
  int n_repeat;
  int power;
  std::string descrip;
  int width;
  int digits;
};
PyParseFortranFormat python_parse_fortran_format(
    std::string format_str,
    int n_repeat,
    int power,
    std::string descrip,
    int width,
    int digits) {
  SimUtils::parse_fortran_format(
      format_str, n_repeat, power, descrip, width, digits);
  auto py_result{PyParseFortranFormat{
      format_str, n_repeat, power, descrip, width, digits}};
  return py_result;
}
struct PyPolyEval {
  double y;
};
PyPolyEval python_poly_eval(
    RealAlloc1D& poly,
    double x,
    std::optional<bool> diff_coef,
    double y) {
  SimUtils::poly_eval(poly, x, diff_coef, y);
  auto py_result{PyPolyEval{y}};
  return py_result;
}
struct PyProbabilityFunct {
  double prob;
};
PyProbabilityFunct python_probability_funct(double x, double prob) {
  SimUtils::probability_funct(x, prob);
  auto py_result{PyProbabilityFunct{prob}};
  return py_result;
}
struct PyQueryString {
  std::string query_str;
  bool upcase;
  std::string return_str;
  int ix;
  int ios;
};
PyQueryString python_query_string(
    std::string query_str,
    bool upcase,
    std::string return_str,
    int ix,
    int ios) {
  SimUtils::query_string(query_str, upcase, return_str, ix, ios);
  auto py_result{PyQueryString{query_str, upcase, return_str, ix, ios}};
  return py_result;
}
struct PyQuote {
  std::string str;
  std::string q_str;
};
PyQuote python_quote(std::string str, std::string q_str) {
  SimUtils::quote(str, q_str);
  auto py_result{PyQuote{str, q_str}};
  return py_result;
}
struct PyRealToString {
  double real_num;
  int width;
  std::optional<int> n_signif;
  std::optional<int> n_decimal;
  std::string str;
};
PyRealToString python_real_to_string(
    double real_num,
    int width,
    std::optional<int> n_signif,
    std::optional<int> n_decimal,
    std::string str) {
  SimUtils::real_to_string(
      real_num, width, make_opt_ref(n_signif), make_opt_ref(n_decimal), str);
  auto py_result{PyRealToString{real_num, width, n_signif, n_decimal, str}};
  return py_result;
}
struct PyRealNumFortranFormat {
  double number;
  int width;
  std::optional<int> n_blanks;
  std::string fmt_str;
};
PyRealNumFortranFormat python_real_num_fortran_format(
    double number,
    int width,
    std::optional<int> n_blanks,
    std::string fmt_str) {
  SimUtils::real_num_fortran_format(
      number, width, make_opt_ref(n_blanks), fmt_str);
  auto py_result{PyRealNumFortranFormat{number, width, n_blanks, fmt_str}};
  return py_result;
}
struct PyStrCount {
  std::string str;
  std::string match;
  int num;
};
PyStrCount python_str_count(std::string str, std::string match, int num) {
  SimUtils::str_count(str, match, num);
  auto py_result{PyStrCount{str, match, num}};
  return py_result;
}
struct PyRealPath {
  std::string path_in;
  std::string path_out;
  bool is_ok;
};
PyRealPath python_real_path(
    std::string path_in,
    std::string path_out,
    bool is_ok) {
  SimUtils::real_path(path_in, path_out, is_ok);
  auto py_result{PyRealPath{path_in, path_out, is_ok}};
  return py_result;
}
struct PyRealStr {
  double r_num;
  std::optional<int> n_signif;
  std::optional<int> n_decimal;
  std::string str;
};
PyRealStr python_real_str(
    double r_num,
    std::optional<int> n_signif,
    std::optional<int> n_decimal,
    std::string str) {
  SimUtils::real_str(
      r_num, make_opt_ref(n_signif), make_opt_ref(n_decimal), str);
  auto py_result{PyRealStr{r_num, n_signif, n_decimal, str}};
  return py_result;
}

struct PyRmsValue {
  double ave_val;
  double rms_val;
};
PyRmsValue python_rms_value(
    RealAlloc1D& val_arr,
    optional_ref<BoolAlloc1D> good_val,
    double rms_val) {
  auto _result = SimUtils::rms_value(val_arr, good_val, rms_val);
  auto py_result{PyRmsValue{_result, rms_val}};
  return py_result;
}
struct PyRunTimer {
  std::string command;
  std::optional<double> time;
  std::optional<double> time0;
};
PyRunTimer python_run_timer(
    std::string command,
    std::optional<double> time = std::nullopt,
    std::optional<double> time0 = std::nullopt) {
  SimUtils::run_timer(command, make_opt_ref(time), make_opt_ref(time0));
  auto py_result{PyRunTimer{command, time, time0}};
  return py_result;
}
struct PySinc {
  double y;
};
PySinc python_sinc(double x, std::optional<int> nd, double y) {
  SimUtils::sinc(x, nd, y);
  auto py_result{PySinc{y}};
  return py_result;
}
struct PySincc {
  double y;
};
PySincc python_sincc(double x, std::optional<int> nd, double y) {
  SimUtils::sincc(x, nd, y);
  auto py_result{PySincc{y}};
  return py_result;
}
struct PySinhxX {
  double y;
};
PySinhxX python_sinhx_x(double x, std::optional<int> nd, double y) {
  SimUtils::sinhx_x(x, nd, y);
  auto py_result{PySinhxX{y}};
  return py_result;
}
struct PySkipHeader {
  int ix_unit;
  bool error_flag;
};
PySkipHeader python_skip_header(int ix_unit, bool error_flag) {
  SimUtils::skip_header(ix_unit, error_flag);
  auto py_result{PySkipHeader{ix_unit, error_flag}};
  return py_result;
}
struct PySqrtOne {
  double ds1;
};
PySqrtOne python_sqrt_one(double x, std::optional<int> nd, double ds1) {
  SimUtils::sqrt_one(x, nd, ds1);
  auto py_result{PySqrtOne{ds1}};
  return py_result;
}
struct PySqrtAlpha {
  double y;
};
PySqrtAlpha python_sqrt_alpha(double alpha, double x, double y) {
  SimUtils::sqrt_alpha(alpha, x, y);
  auto py_result{PySqrtAlpha{y}};
  return py_result;
}
struct PyStrFirstInSet {
  std::string line;
  std::string set;
  std::optional<bool> ignore_clauses;
  int ix_match;
};
PyStrFirstInSet python_str_first_in_set(
    std::string line,
    std::string set,
    std::optional<bool> ignore_clauses,
    int ix_match) {
  SimUtils::str_first_in_set(line, set, make_opt_ref(ignore_clauses), ix_match);
  auto py_result{PyStrFirstInSet{line, set, ignore_clauses, ix_match}};
  return py_result;
}
struct PyStrFirstNotInSet {
  std::string line;
  std::string set;
  int ix_match;
};
PyStrFirstNotInSet python_str_first_not_in_set(
    std::string line,
    std::string set,
    int ix_match) {
  SimUtils::str_first_not_in_set(line, set, ix_match);
  auto py_result{PyStrFirstNotInSet{line, set, ix_match}};
  return py_result;
}
struct PyStrLastInSet {
  std::string line;
  std::string set;
  int ix_match;
};
PyStrLastInSet python_str_last_in_set(
    std::string line,
    std::string set,
    int ix_match) {
  SimUtils::str_last_in_set(line, set, ix_match);
  auto py_result{PyStrLastInSet{line, set, ix_match}};
  return py_result;
}
struct PyStrLastNotInSet {
  std::string line;
  std::string set;
  int ix_match;
};
PyStrLastNotInSet python_str_last_not_in_set(
    std::string line,
    std::string set,
    int ix_match) {
  SimUtils::str_last_not_in_set(line, set, ix_match);
  auto py_result{PyStrLastNotInSet{line, set, ix_match}};
  return py_result;
}
struct PyStringToInt {
  std::string line;
  int default_;
  bool err_flag;
  std::optional<bool> err_print_flag;
  int value;
};
PyStringToInt python_string_to_int(
    std::string line,
    int default_,
    bool err_flag,
    std::optional<bool> err_print_flag,
    int value) {
  SimUtils::string_to_int(
      line, default_, err_flag, make_opt_ref(err_print_flag), value);
  auto py_result{
      PyStringToInt{line, default_, err_flag, err_print_flag, value}};
  return py_result;
}
struct PyStringToReal {
  std::string line;
  double default_;
  bool err_flag;
  std::optional<bool> err_print_flag;
  double value;
};
PyStringToReal python_string_to_real(
    std::string line,
    double default_,
    bool err_flag,
    std::optional<bool> err_print_flag,
    double value) {
  SimUtils::string_to_real(
      line, default_, err_flag, make_opt_ref(err_print_flag), value);
  auto py_result{
      PyStringToReal{line, default_, err_flag, err_print_flag, value}};
  return py_result;
}
struct PyStringTrim2 {
  std::string in_str;
  std::string delimitors;
  std::string out_str;
  int ix_word;
  std::string delim;
  int ix_next;
};
PyStringTrim2 python_string_trim2(
    std::string in_str,
    std::string delimitors,
    std::string out_str,
    int ix_word,
    std::string delim,
    int ix_next) {
  SimUtils::string_trim2(in_str, delimitors, out_str, ix_word, delim, ix_next);
  auto py_result{
      PyStringTrim2{in_str, delimitors, out_str, ix_word, delim, ix_next}};
  return py_result;
}
struct PyToStr {
  double num;
  std::optional<int> max_signif;
  std::string string;
};
PyToStr python_to_str(
    double num,
    std::optional<int> max_signif,
    std::string string) {
  SimUtils::to_str(num, make_opt_ref(max_signif), string);
  auto py_result{PyToStr{num, max_signif, string}};
  return py_result;
}
struct PyTypeThisFile {
  std::string filename;
};
PyTypeThisFile python_type_this_file(std::string filename) {
  SimUtils::type_this_file(filename);
  auto py_result{PyTypeThisFile{filename}};
  return py_result;
}
struct PyUpcaseString {
  std::string string;
};
PyUpcaseString python_upcase_string(std::string string) {
  SimUtils::upcase_string(string);
  auto py_result{PyUpcaseString{string}};
  return py_result;
}
struct PyWordLen {
  std::string wording;
  int wlen;
};
PyWordLen python_word_len(std::string wording, int wlen) {
  SimUtils::word_len(wording, wlen);
  auto py_result{PyWordLen{wording, wlen}};
  return py_result;
}
struct PyWordRead {
  std::string in_str;
  std::string delim_list;
  std::string word;
  int ix_word;
  std::string delim;
  bool delim_found;
  std::string out_str;
  std::optional<bool> ignore_interior;
};
PyWordRead python_word_read(
    std::string in_str,
    std::string delim_list,
    std::string word,
    int ix_word,
    std::string delim,
    bool delim_found,
    std::string out_str,
    std::optional<bool> ignore_interior = std::nullopt) {
  SimUtils::word_read(
      in_str,
      delim_list,
      word,
      ix_word,
      delim,
      delim_found,
      out_str,
      make_opt_ref(ignore_interior));
  auto py_result{PyWordRead{
      in_str,
      delim_list,
      word,
      ix_word,
      delim,
      delim_found,
      out_str,
      ignore_interior}};
  return py_result;
}
struct PyStrSubstitute {
  std::string string;
  std::optional<std::string> str_match;
  std::optional<std::string> str_replace;
  std::optional<bool> do_trim;
  std::optional<bool> ignore_escaped;
};
PyStrSubstitute python_str_substitute(
    std::string string,
    std::optional<std::string> str_match = std::nullopt,
    std::optional<std::string> str_replace = std::nullopt,
    std::optional<bool> do_trim = std::nullopt,
    std::optional<bool> ignore_escaped = std::nullopt) {
  SimUtils::str_substitute(
      string,
      make_opt_ref(str_match),
      make_opt_ref(str_replace),
      make_opt_ref(do_trim),
      make_opt_ref(ignore_escaped));
  auto py_result{
      PyStrSubstitute{string, str_match, str_replace, do_trim, ignore_escaped}};
  return py_result;
}
struct PyStrMatchWild {
  std::string str;
  std::string pat;
  bool a_match;
};
PyStrMatchWild python_str_match_wild(
    std::string str,
    std::string pat,
    bool a_match) {
  SimUtils::str_match_wild(str, pat, a_match);
  auto py_result{PyStrMatchWild{str, pat, a_match}};
  return py_result;
}
struct PySystemCommand {
  std::string line;
  std::optional<bool> err_flag;
};
PySystemCommand python_system_command(
    std::string line,
    std::optional<bool> err_flag = std::nullopt) {
  SimUtils::system_command(line, make_opt_ref(err_flag));
  auto py_result{PySystemCommand{line, err_flag}};
  return py_result;
}
struct PyStringTrim {
  std::string in_string;
  std::string out_string;
  int word_len;
};
PyStringTrim python_string_trim(
    std::string in_string,
    std::string out_string,
    int word_len) {
  SimUtils::string_trim(in_string, out_string, word_len);
  auto py_result{PyStringTrim{in_string, out_string, word_len}};
  return py_result;
}
struct PyFindLocationReal {
  int ix_match;
};
PyFindLocationReal python_find_location_real(
    RealAlloc1D& arr,
    double value,
    int ix_match) {
  SimUtils::find_location(arr, value, ix_match);
  auto py_result{PyFindLocationReal{ix_match}};
  return py_result;
}
struct PyFindLocationInt {
  int value;
  int ix_match;
};
PyFindLocationInt python_find_location_int(
    IntAlloc1D& arr,
    int value,
    int ix_match) {
  SimUtils::find_location(arr, value, ix_match);
  auto py_result{PyFindLocationInt{value, ix_match}};
  return py_result;
}
struct PyFindLocationLogic {
  bool value;
  int ix_match;
};
PyFindLocationLogic python_find_location_logic(
    BoolAlloc1D& arr,
    bool value,
    int ix_match) {
  SimUtils::find_location(arr, value, ix_match);
  auto py_result{PyFindLocationLogic{value, ix_match}};
  return py_result;
}

struct PyCoarseFrequencyEstimate {
  double frequency;
  std::optional<bool> error;
};
PyCoarseFrequencyEstimate python_coarse_frequency_estimate(
    RealAlloc1D& data,
    std::optional<bool> error = std::nullopt) {
  auto _result = SimUtils::coarse_frequency_estimate(data, make_opt_ref(error));
  auto py_result{PyCoarseFrequencyEstimate{_result, error}};
  return py_result;
}
struct PyNaff {
  std::optional<int> opt_dump_spectra;
  std::optional<bool> opt_zero_first;
};
PyNaff python_naff(
    ComplexAlloc1D& cdata,
    RealAlloc1D& freqs,
    ComplexAlloc1D& amps,
    std::optional<int> opt_dump_spectra = std::nullopt,
    std::optional<bool> opt_zero_first = std::nullopt) {
  SimUtils::naff(
      cdata,
      freqs,
      amps,
      make_opt_ref(opt_dump_spectra),
      make_opt_ref(opt_zero_first));
  auto py_result{PyNaff{opt_dump_spectra, opt_zero_first}};
  return py_result;
}
struct PyProjdd {
  std::complex<double> func_retval__;
};
PyProjdd python_projdd(
    ComplexAlloc1D& a,
    ComplexAlloc1D& b,
    std::complex<double> func_retval__) {
  SimUtils::projdd(a, b, func_retval__);
  auto py_result{PyProjdd{func_retval__}};
  return py_result;
}
struct PyMaximizeProjection {
  double seed;
  double func_retval__;
};
PyMaximizeProjection python_maximize_projection(
    double seed,
    ComplexAlloc1D& cdata,
    double func_retval__) {
  SimUtils::maximize_projection(seed, cdata, func_retval__);
  auto py_result{PyMaximizeProjection{seed, func_retval__}};
  return py_result;
}
struct PyInterpolatedFftGsl {
  bool calc_ok;
  std::optional<int> opt_dump_spectrum;
  std::optional<int> opt_dump_index;
  double this_fft;
};
PyInterpolatedFftGsl python_interpolated_fft_gsl(
    ComplexAlloc1D& cdata,
    bool calc_ok,
    std::optional<int> opt_dump_spectrum,
    std::optional<int> opt_dump_index,
    double this_fft) {
  SimUtils::interpolated_fft_gsl(
      cdata,
      calc_ok,
      make_opt_ref(opt_dump_spectrum),
      make_opt_ref(opt_dump_index),
      this_fft);
  auto py_result{PyInterpolatedFftGsl{
      calc_ok, opt_dump_spectrum, opt_dump_index, this_fft}};
  return py_result;
}
struct PyInterpolatedFft {
  bool calc_ok;
  std::optional<int> opt_dump_spectrum;
  std::optional<int> opt_dump_index;
  double this_fft;
};
PyInterpolatedFft python_interpolated_fft(
    ComplexAlloc1D& cdata,
    bool calc_ok,
    std::optional<int> opt_dump_spectrum,
    std::optional<int> opt_dump_index,
    double this_fft) {
  SimUtils::interpolated_fft(
      cdata,
      calc_ok,
      make_opt_ref(opt_dump_spectrum),
      make_opt_ref(opt_dump_index),
      this_fft);
  auto py_result{
      PyInterpolatedFft{calc_ok, opt_dump_spectrum, opt_dump_index, this_fft}};
  return py_result;
}
struct PyFixedwindowls {
  double z;
};
PyFixedwindowls python_fixedwindowls(double ynew, int id, double z) {
  SimUtils::fixedwindowls(ynew, id, z);
  auto py_result{PyFixedwindowls{z}};
  return py_result;
}

struct PyBinXCenter {
  double x_center;
  int ix_bin;
};
PyBinXCenter python_bin_x_center(
    int ix_bin,
    double bin1_x_min,
    double bin_delta) {
  auto _result = SimUtils::bin_x_center(ix_bin, bin1_x_min, bin_delta);
  auto py_result{PyBinXCenter{_result, ix_bin}};
  return py_result;
}
struct PyNBinsAutomatic {
  int n_data;
  int n;
};
PyNBinsAutomatic python_n_bins_automatic(int n_data, int n) {
  SimUtils::n_bins_automatic(n_data, n);
  auto py_result{PyNBinsAutomatic{n_data, n}};
  return py_result;
}
struct PyApfft {
  std::string window;
  double phase;
  std::optional<int> diag;
};
PyApfft python_apfft(
    RealAlloc1D& rdata_in,
    FixedArray1D<Real, 2> bounds,
    std::string window,
    double phase,
    std::optional<int> diag = std::nullopt) {
  SimUtils::apfft(rdata_in, bounds, window, phase, make_opt_ref(diag));
  auto py_result{PyApfft{window, phase, diag}};
  return py_result;
}
struct PyApfftExt {
  std::string window;
  double phase;
  double amp;
  double freq;
  std::optional<int> diag;
};
PyApfftExt python_apfft_ext(
    RealAlloc1D& rdata,
    FixedArray1D<Real, 2> bounds,
    std::string window,
    double phase,
    double amp,
    double freq,
    std::optional<int> diag = std::nullopt) {
  SimUtils::apfft_ext(
      rdata, bounds, window, phase, amp, freq, make_opt_ref(diag));
  auto py_result{PyApfftExt{window, phase, amp, freq, diag}};
  return py_result;
}
struct PyHanhan {
  int N;
};
PyHanhan python_hanhan(int N, RealAlloc1D& hh) {
  SimUtils::hanhan(N, hh);
  auto py_result{PyHanhan{N}};
  return py_result;
}
struct PyBitSet {
  int word;
};
PyBitSet python_bit_set(int word, int pos, bool set_to_1) {
  SimUtils::bit_set(word, pos, set_to_1);
  auto py_result{PyBitSet{word}};
  return py_result;
}
struct PyTaoBranchIndex {
  int ix_this;
};
PyTaoBranchIndex python_tao_branch_index(int ix_branch, int ix_this) {
  Tao::tao_branch_index(ix_branch, ix_this);
  auto py_result{PyTaoBranchIndex{ix_this}};
  return py_result;
}
struct PyTaoUniverseIndex {
  int i_this_uni;
};
PyTaoUniverseIndex python_tao_universe_index(
    int i_uni,
    std::optional<bool> neg2_to_default,
    int i_this_uni) {
  Tao::tao_universe_index(i_uni, neg2_to_default, i_this_uni);
  auto py_result{PyTaoUniverseIndex{i_this_uni}};
  return py_result;
}
struct PyTaoDataSanityCheck {
  bool is_valid;
};
PyTaoDataSanityCheck python_tao_data_sanity_check(
    TaoDataProxy& datum,
    bool print_err,
    std::string default_data_type,
    optional_ref<TaoUniverseProxy> uni,
    bool is_valid) {
  Tao::tao_data_sanity_check(
      datum, print_err, default_data_type, uni, is_valid);
  auto py_result{PyTaoDataSanityCheck{is_valid}};
  return py_result;
}

struct PyTaoCommand {
  bool err_is_fatal;
  bool err;
};
PyTaoCommand python_tao_command(std::string command_line, bool err) {
  auto _result = Tao::tao_command(command_line, err);
  auto py_result{PyTaoCommand{_result, err}};
  return py_result;
}
struct PyTaoGraphName {
  std::string graph_name;
};
PyTaoGraphName python_tao_graph_name(
    TaoGraphProxy& graph,
    std::optional<bool> use_region,
    std::string graph_name) {
  Tao::tao_graph_name(graph, use_region, graph_name);
  auto py_result{PyTaoGraphName{graph_name}};
  return py_result;
}
struct PyTaoLatSigmaCalcNeeded {
  std::string data_type;
  std::string data_source;
  bool do_lat_sigma;
};
PyTaoLatSigmaCalcNeeded python_tao_lat_sigma_calc_needed(
    std::string data_type,
    std::string data_source,
    bool do_lat_sigma) {
  Tao::tao_lat_sigma_calc_needed(data_type, data_source, do_lat_sigma);
  auto py_result{PyTaoLatSigmaCalcNeeded{data_type, data_source, do_lat_sigma}};
  return py_result;
}
struct PyTaoTooManyParticlesLost {
  bool no_beam;
};
PyTaoTooManyParticlesLost python_tao_too_many_particles_lost(
    BeamProxy& beam,
    bool no_beam) {
  Tao::tao_too_many_particles_lost(beam, no_beam);
  auto py_result{PyTaoTooManyParticlesLost{no_beam}};
  return py_result;
}
struct PyTaoInjectParticle {
  int ix_branch;
};
PyTaoInjectParticle python_tao_inject_particle(
    TaoUniverseProxy& u,
    TaoLatticeProxy& model,
    int ix_branch) {
  Tao::tao_inject_particle(u, model, ix_branch);
  auto py_result{PyTaoInjectParticle{ix_branch}};
  return py_result;
}
struct PyTaoVar1Name {
  std::string var1_name;
};
PyTaoVar1Name python_tao_var1_name(TaoVarProxy& var, std::string var1_name) {
  Tao::tao_var1_name(var, var1_name);
  auto py_result{PyTaoVar1Name{var1_name}};
  return py_result;
}
struct PyTaoCurveIxUni {
  int ix_uni;
};
PyTaoCurveIxUni python_tao_curve_ix_uni(TaoCurveProxy& curve, int ix_uni) {
  Tao::tao_curve_ix_uni(curve, ix_uni);
  auto py_result{PyTaoCurveIxUni{ix_uni}};
  return py_result;
}

struct PyTaoOpenFile {
  int iunit;
  std::string file;
};
PyTaoOpenFile python_tao_open_file(
    std::string file,
    std::string file_name,
    int error_severity,
    std::optional<bool> binary = std::nullopt) {
  auto _result = Tao::tao_open_file(file, file_name, error_severity, binary);
  auto py_result{PyTaoOpenFile{_result, file}};
  return py_result;
}
struct PyTaoJsonCmd {
  std::string input_str;
};
PyTaoJsonCmd python_tao_json_cmd(std::string input_str) {
  Tao::tao_json_cmd(input_str);
  auto py_result{PyTaoJsonCmd{input_str}};
  return py_result;
}
struct PyTaoDatumName {
  std::string datum_name;
};
PyTaoDatumName python_tao_datum_name(
    TaoDataProxy& datum,
    std::optional<bool> show_universe,
    std::string datum_name) {
  Tao::tao_datum_name(datum, show_universe, datum_name);
  auto py_result{PyTaoDatumName{datum_name}};
  return py_result;
}
struct PyTaoRadIntCalcNeeded {
  std::string data_type;
  std::string data_source;
  bool do_rad_int;
};
PyTaoRadIntCalcNeeded python_tao_rad_int_calc_needed(
    std::string data_type,
    std::string data_source,
    bool do_rad_int) {
  Tao::tao_rad_int_calc_needed(data_type, data_source, do_rad_int);
  auto py_result{PyTaoRadIntCalcNeeded{data_type, data_source, do_rad_int}};
  return py_result;
}
struct PyTaoCmdHistoryRecord {
  std::string cmd;
};
PyTaoCmdHistoryRecord python_tao_cmd_history_record(std::string cmd) {
  Tao::tao_cmd_history_record(cmd);
  auto py_result{PyTaoCmdHistoryRecord{cmd}};
  return py_result;
}
struct PyTaoReExecute {
  std::string string;
  bool err;
};
PyTaoReExecute python_tao_re_execute(std::string string, bool err) {
  Tao::tao_re_execute(string, err);
  auto py_result{PyTaoReExecute{string, err}};
  return py_result;
}

struct PyTaoNextWord {
  std::string word;
  std::string line;
};
PyTaoNextWord python_tao_next_word(std::string line) {
  auto _result = Tao::tao_next_word(line);
  auto py_result{PyTaoNextWord{_result, line}};
  return py_result;
}
struct PyTaoSpinMatricesCalcNeeded {
  std::string data_type;
  std::string data_source;
  bool do_calc;
};
PyTaoSpinMatricesCalcNeeded python_tao_spin_matrices_calc_needed(
    std::string data_type,
    std::string data_source,
    bool do_calc) {
  Tao::tao_spin_matrices_calc_needed(data_type, data_source, do_calc);
  auto py_result{PyTaoSpinMatricesCalcNeeded{data_type, data_source, do_calc}};
  return py_result;
}
struct PyTaoInitLattice {
  std::string lat_file;
  bool err_flag;
};
PyTaoInitLattice python_tao_init_lattice(std::string lat_file, bool err_flag) {
  Tao::tao_init_lattice(lat_file, err_flag);
  auto py_result{PyTaoInitLattice{lat_file, err_flag}};
  return py_result;
}
struct PyTaoDrawEleForFloorPlan {
  double offset1;
  double offset2;
};
PyTaoDrawEleForFloorPlan python_tao_draw_ele_for_floor_plan(
    TaoPlotProxy& plot,
    TaoGraphProxy& graph,
    TaoLatticeProxy& tao_lat,
    EleProxy& ele,
    TaoEleShapeProxy& ele_shape,
    std::string label_name,
    double offset1,
    double offset2) {
  Tao::tao_draw_ele_for_floor_plan(
      plot, graph, tao_lat, ele, ele_shape, label_name, offset1, offset2);
  auto py_result{PyTaoDrawEleForFloorPlan{offset1, offset2}};
  return py_result;
}
struct PyTaoDrawCurveData {
  bool have_data;
};
PyTaoDrawCurveData python_tao_draw_curve_data(
    TaoPlotProxy& plot,
    TaoGraphProxy& graph,
    TaoCurveProxy& curve,
    bool have_data) {
  Tao::tao_draw_curve_data(plot, graph, curve, have_data);
  auto py_result{PyTaoDrawCurveData{have_data}};
  return py_result;
}
struct PyTaoDrawHistogramData {
  bool have_data;
};
PyTaoDrawHistogramData python_tao_draw_histogram_data(
    TaoPlotProxy& plot,
    TaoGraphProxy& graph,
    TaoCurveProxy& curve,
    bool have_data) {
  Tao::tao_draw_histogram_data(plot, graph, curve, have_data);
  auto py_result{PyTaoDrawHistogramData{have_data}};
  return py_result;
}

struct PyTaoOpenScratchFile {
  bool err;
  int iu;
};
PyTaoOpenScratchFile python_tao_open_scratch_file(int iu) {
  auto _result = Tao::tao_open_scratch_file(iu);
  auto py_result{PyTaoOpenScratchFile{_result, iu}};
  return py_result;
}
struct PyTaoCurveName {
  std::string curve_name;
};
PyTaoCurveName python_tao_curve_name(
    TaoCurveProxy& curve,
    std::optional<bool> use_region,
    std::string curve_name) {
  Tao::tao_curve_name(curve, use_region, curve_name);
  auto py_result{PyTaoCurveName{curve_name}};
  return py_result;
}
struct PyTaoLocateElements : public Tao::TaoLocateElements {
  std::optional<bool> above_ubound_is_err;
  PyTaoLocateElements(
      Tao::TaoLocateElements _base,
      std::optional<bool> above_ubound_is_err)
      : Tao::TaoLocateElements(std::move(_base)),
        above_ubound_is_err(above_ubound_is_err) {}
};
PyTaoLocateElements python_tao_locate_elements(
    std::string ele_list,
    int ix_universe,
    std::optional<int> lat_type = std::nullopt,
    std::optional<bool> ignore_blank = std::nullopt,
    std::optional<int> err_stat_level = std::nullopt,
    std::optional<bool> above_ubound_is_err = std::nullopt,
    std::optional<int> ix_branch = std::nullopt,
    std::optional<bool> multiple_eles_is_err = std::nullopt) {
  auto _result = Tao::tao_locate_elements(
      ele_list,
      ix_universe,
      lat_type,
      ignore_blank,
      err_stat_level,
      make_opt_ref(above_ubound_is_err),
      ix_branch,
      multiple_eles_is_err);
  auto py_result{PyTaoLocateElements{_result, above_ubound_is_err}};
  return py_result;
}
struct PyTaoLatEmitCalc {
  double emit;
};
PyTaoLatEmitCalc python_tao_lat_emit_calc(
    int plane,
    int emit_type,
    EleProxy& ele,
    NormalModesProxy& modes,
    double emit) {
  Tao::tao_lat_emit_calc(plane, emit_type, ele, modes, emit);
  auto py_result{PyTaoLatEmitCalc{emit}};
  return py_result;
}

struct PyTaoIsValidName {
  std::string why_invalid;
  bool is_valid;
};
PyTaoIsValidName python_tao_is_valid_name(std::string name, bool is_valid) {
  auto _result = Tao::tao_is_valid_name(name, is_valid);
  auto py_result{PyTaoIsValidName{_result, is_valid}};
  return py_result;
}
struct PyTaoSrdtCalcNeeded {
  std::string data_type;
  std::string data_source;
  int do_srdt;
};
PyTaoSrdtCalcNeeded python_tao_srdt_calc_needed(
    std::string data_type,
    std::string data_source,
    int do_srdt) {
  Tao::tao_srdt_calc_needed(data_type, data_source, do_srdt);
  auto py_result{PyTaoSrdtCalcNeeded{data_type, data_source, do_srdt}};
  return py_result;
}
struct PyTaoOptimizationStatus {
  std::string why_str;
};
PyTaoOptimizationStatus python_tao_optimization_status(
    TaoDataProxy& datum,
    std::string why_str) {
  Tao::tao_optimization_status(datum, why_str);
  auto py_result{PyTaoOptimizationStatus{why_str}};
  return py_result;
}
struct PyTaoEvaluateLatOrBeamData : public Tao::TaoEvaluateLatOrBeamData {
  std::string default_source;
  PyTaoEvaluateLatOrBeamData(
      Tao::TaoEvaluateLatOrBeamData _base,
      std::string default_source)
      : Tao::TaoEvaluateLatOrBeamData(std::move(_base)),
        default_source(default_source) {}
};
PyTaoEvaluateLatOrBeamData python_tao_evaluate_lat_or_beam_data(
    std::string data_name,
    bool print_err,
    std::string default_source,
    optional_ref<EleProxy> dflt_ele_ref = std::nullopt,
    optional_ref<EleProxy> dflt_ele_start = std::nullopt,
    optional_ref<EleProxy> dflt_ele = std::nullopt,
    std::optional<std::string> dflt_component = std::nullopt,
    std::optional<int> dflt_uni = std::nullopt,
    std::optional<int> dflt_eval_point = std::nullopt,
    std::optional<double> dflt_s_offset = std::nullopt) {
  auto _result = Tao::tao_evaluate_lat_or_beam_data(
      data_name,
      print_err,
      default_source,
      dflt_ele_ref,
      dflt_ele_start,
      dflt_ele,
      dflt_component,
      dflt_uni,
      dflt_eval_point,
      dflt_s_offset);
  auto py_result{PyTaoEvaluateLatOrBeamData{_result, default_source}};
  return py_result;
}
struct PyTaoToPhaseAndCouplingReading
    : public Tao::TaoToPhaseAndCouplingReading {
  std::string why_invalid;
  PyTaoToPhaseAndCouplingReading(
      Tao::TaoToPhaseAndCouplingReading _base,
      std::string why_invalid)
      : Tao::TaoToPhaseAndCouplingReading(std::move(_base)),
        why_invalid(why_invalid) {}
};
PyTaoToPhaseAndCouplingReading python_tao_to_phase_and_coupling_reading(
    EleProxy& ele,
    std::string why_invalid,
    TaoDataProxy& datum) {
  auto _result =
      Tao::tao_to_phase_and_coupling_reading(ele, why_invalid, datum);
  auto py_result{PyTaoToPhaseAndCouplingReading{_result, why_invalid}};
  return py_result;
}
struct PyTaoLoadThisDatum {
  double datum_value;
  bool valid_value;
  std::optional<std::string> why_invalid;
};
PyTaoLoadThisDatum python_tao_load_this_datum(
    RealAlloc1D& vec,
    EleProxy& ele_ref,
    EleProxy& ele_start,
    EleProxy& ele,
    double datum_value,
    bool valid_value,
    TaoDataProxy& datum,
    BranchProxy& branch,
    std::optional<std::string> why_invalid = std::nullopt,
    optional_ref<BoolAlloc1D> good = std::nullopt) {
  Tao::tao_load_this_datum(
      vec,
      ele_ref,
      ele_start,
      ele,
      datum_value,
      valid_value,
      datum,
      branch,
      make_opt_ref(why_invalid),
      good);
  auto py_result{PyTaoLoadThisDatum{datum_value, valid_value, why_invalid}};
  return py_result;
}
struct PyIntegrateMin {
  int ix_start;
  int ix_ele;
  double datum_value;
  int ix_m;
};
PyIntegrateMin python_integrate_min(
    int ix_start,
    int ix_ele,
    double datum_value,
    int ix_m,
    BranchProxy& branch,
    RealAlloc1D& vec,
    TaoDataProxy& datum) {
  Tao::integrate_min(ix_start, ix_ele, datum_value, ix_m, branch, vec, datum);
  auto py_result{PyIntegrateMin{ix_start, ix_ele, datum_value, ix_m}};
  return py_result;
}
struct PyIntegrateMax {
  int ix_start;
  int ix_ele;
  double datum_value;
  int ix_m;
};
PyIntegrateMax python_integrate_max(
    int ix_start,
    int ix_ele,
    double datum_value,
    int ix_m,
    BranchProxy& branch,
    RealAlloc1D& vec,
    TaoDataProxy& datum) {
  Tao::integrate_max(ix_start, ix_ele, datum_value, ix_m, branch, vec, datum);
  auto py_result{PyIntegrateMax{ix_start, ix_ele, datum_value, ix_m}};
  return py_result;
}
struct PyTaoPointerToDatumEle : public Tao::TaoPointerToDatumEle {
  std::string ele_name;
  PyTaoPointerToDatumEle(Tao::TaoPointerToDatumEle _base, std::string ele_name)
      : Tao::TaoPointerToDatumEle(std::move(_base)), ele_name(ele_name) {}
};
PyTaoPointerToDatumEle python_tao_pointer_to_datum_ele(
    LatProxy& lat,
    std::string ele_name,
    int ix_ele,
    TaoDataProxy& datum,
    std::optional<bool> print_err = std::nullopt) {
  auto _result =
      Tao::tao_pointer_to_datum_ele(lat, ele_name, ix_ele, datum, print_err);
  auto py_result{PyTaoPointerToDatumEle{_result, ele_name}};
  return py_result;
}
struct PyTaoToInt {
  std::string str;
  int i_int;
  bool err;
};
PyTaoToInt python_tao_to_int(std::string str, int i_int, bool err) {
  Tao::tao_to_int(str, i_int, err);
  auto py_result{PyTaoToInt{str, i_int, err}};
  return py_result;
}

struct PyTaoMerit {
  bool calc_ok;
  double this_merit;
};
PyTaoMerit python_tao_merit(double this_merit) {
  auto _result = Tao::tao_merit(this_merit);
  auto py_result{PyTaoMerit{_result, this_merit}};
  return py_result;
}
struct PyTaoD2D1Name {
  std::string d2_d1_name;
};
PyTaoD2D1Name python_tao_d2_d1_name(
    TaoD1DataProxy& d1,
    std::optional<bool> show_universe,
    std::string d2_d1_name) {
  Tao::tao_d2_d1_name(d1, show_universe, d2_d1_name);
  auto py_result{PyTaoD2D1Name{d2_d1_name}};
  return py_result;
}
struct PyTaoParamValueAtS : public Tao::TaoParamValueAtS {
  std::string dat_name;
  double value;
  PyTaoParamValueAtS(
      Tao::TaoParamValueAtS _base,
      std::string dat_name,
      double value)
      : Tao::TaoParamValueAtS(std::move(_base)),
        dat_name(dat_name),
        value(value) {}
};
PyTaoParamValueAtS python_tao_param_value_at_s(
    std::string dat_name,
    EleProxy& ele_to_s,
    EleProxy& ele_here,
    CoordProxy& orbit,
    double value) {
  auto _result =
      Tao::tao_param_value_at_s(dat_name, ele_to_s, ele_here, orbit, value);
  auto py_result{PyTaoParamValueAtS{_result, dat_name, value}};
  return py_result;
}
struct PyTaoEvaluateTune {
  double q_val;
};
PyTaoEvaluateTune python_tao_evaluate_tune(
    std::string q_str,
    double q0,
    bool delta_input,
    double q_val) {
  Tao::tao_evaluate_tune(q_str, q0, delta_input, q_val);
  auto py_result{PyTaoEvaluateTune{q_val}};
  return py_result;
}
struct PyReAllocateCDouble {
  std::optional<double> init_val;
};
PyReAllocateCDouble python_re_allocate_c_double(
    RealAlloc1D& re,
    int n,
    std::optional<bool> exact = std::nullopt,
    std::optional<double> init_val = std::nullopt) {
  Tao::re_allocate_c_double(re, n, exact, make_opt_ref(init_val));
  auto py_result{PyReAllocateCDouble{init_val}};
  return py_result;
}

struct PyTaoSubinUniNumber {
  std::string name_out;
  bool ok;
};
PyTaoSubinUniNumber python_tao_subin_uni_number(
    std::string name_in,
    int ix_uni,
    bool ok) {
  auto _result = Tao::tao_subin_uni_number(name_in, ix_uni, ok);
  auto py_result{PyTaoSubinUniNumber{_result, ok}};
  return py_result;
}

struct PyTaoParseCommandArgs {
  bool error;
  std::optional<std::string> cmd_line;
};
PyTaoParseCommandArgs python_tao_parse_command_args(
    std::optional<std::string> cmd_line = std::nullopt) {
  auto _result = Tao::tao_parse_command_args(make_opt_ref(cmd_line));
  auto py_result{PyTaoParseCommandArgs{_result, cmd_line}};
  return py_result;
}
struct PyTaoChromCalcNeeded {
  std::string data_type;
  std::string data_source;
  bool do_chrom;
};
PyTaoChromCalcNeeded python_tao_chrom_calc_needed(
    std::string data_type,
    std::string data_source,
    bool do_chrom) {
  Tao::tao_chrom_calc_needed(data_type, data_source, do_chrom);
  auto py_result{PyTaoChromCalcNeeded{data_type, data_source, do_chrom}};
  return py_result;
}
struct PyTaoVarAttribName {
  std::string var_attrib_name;
};
PyTaoVarAttribName python_tao_var_attrib_name(
    TaoVarProxy& var,
    std::string var_attrib_name) {
  Tao::tao_var_attrib_name(var, var_attrib_name);
  auto py_result{PyTaoVarAttribName{var_attrib_name}};
  return py_result;
}
struct PyTaoAllocateDataArray {
  int n_data;
  std::optional<bool> exact;
};
PyTaoAllocateDataArray python_tao_allocate_data_array(
    TaoUniverseProxy& u,
    int n_data,
    std::optional<bool> exact = std::nullopt) {
  Tao::tao_allocate_data_array(u, n_data, make_opt_ref(exact));
  auto py_result{PyTaoAllocateDataArray{n_data, exact}};
  return py_result;
}
struct PyTaoD2DataStuffit {
  std::string d2_name;
  int n_d1_data;
};
PyTaoD2DataStuffit python_tao_d2_data_stuffit(
    TaoUniverseProxy& u,
    std::string d2_name,
    int n_d1_data) {
  Tao::tao_d2_data_stuffit(u, d2_name, n_d1_data);
  auto py_result{PyTaoD2DataStuffit{d2_name, n_d1_data}};
  return py_result;
}
struct PyTaoInitDataInUniverse {
  int n_d2_add;
  std::optional<bool> keep_existing_data;
};
PyTaoInitDataInUniverse python_tao_init_data_in_universe(
    TaoUniverseProxy& u,
    int n_d2_add,
    std::optional<bool> keep_existing_data = std::nullopt) {
  Tao::tao_init_data_in_universe(u, n_d2_add, make_opt_ref(keep_existing_data));
  auto py_result{PyTaoInitDataInUniverse{n_d2_add, keep_existing_data}};
  return py_result;
}
struct PyTaoCalcDataAtSPts {
  double comp_sign;
};
PyTaoCalcDataAtSPts python_tao_calc_data_at_s_pts(
    TaoLatticeProxy& tao_lat,
    TaoCurveProxy& curve,
    double comp_sign,
    BoolAlloc1D& good) {
  Tao::tao_calc_data_at_s_pts(tao_lat, curve, comp_sign, good);
  auto py_result{PyTaoCalcDataAtSPts{comp_sign}};
  return py_result;
}
struct PyTaoConstraintTypeName {
  std::string datum_name;
};
PyTaoConstraintTypeName python_tao_constraint_type_name(
    TaoDataProxy& datum,
    std::string datum_name) {
  Tao::tao_constraint_type_name(datum, datum_name);
  auto py_result{PyTaoConstraintTypeName{datum_name}};
  return py_result;
}
struct PyTaoReadCmd {
  std::string which;
  std::string file;
};
PyTaoReadCmd python_tao_read_cmd(
    std::string which,
    std::string unis,
    std::string file,
    bool silent) {
  Tao::tao_read_cmd(which, unis, file, silent);
  auto py_result{PyTaoReadCmd{which, file}};
  return py_result;
}
struct PyTaoAllocateV1Var {
  int n_v1;
  bool save_old;
};
PyTaoAllocateV1Var python_tao_allocate_v1_var(int n_v1, bool save_old) {
  Tao::tao_allocate_v1_var(n_v1, save_old);
  auto py_result{PyTaoAllocateV1Var{n_v1, save_old}};
  return py_result;
}
struct PyTaoAllocateVarArray {
  bool default_good_user;
};
PyTaoAllocateVarArray python_tao_allocate_var_array(
    int n_var,
    bool default_good_user) {
  Tao::tao_allocate_var_array(n_var, default_good_user);
  auto py_result{PyTaoAllocateVarArray{default_good_user}};
  return py_result;
}
struct PyTaoInitPlotting {
  std::string plot_file;
};
PyTaoInitPlotting python_tao_init_plotting(std::string plot_file) {
  Tao::tao_init_plotting(plot_file);
  auto py_result{PyTaoInitPlotting{plot_file}};
  return py_result;
}
struct PyTaoXScaleGraph {
  double x_min;
  double x_max;
  std::optional<bool> include_wall;
  std::optional<bool> have_scaled;
};
PyTaoXScaleGraph python_tao_x_scale_graph(
    TaoGraphProxy& graph,
    double x_min,
    double x_max,
    std::optional<bool> include_wall = std::nullopt,
    std::optional<bool> have_scaled = std::nullopt) {
  Tao::tao_x_scale_graph(
      graph,
      x_min,
      x_max,
      make_opt_ref(include_wall),
      make_opt_ref(have_scaled));
  auto py_result{PyTaoXScaleGraph{x_min, x_max, include_wall, have_scaled}};
  return py_result;
}
struct PyTaoWaveCmd {
  bool err_flag;
};
PyTaoWaveCmd python_tao_wave_cmd(
    std::string curve_name,
    std::string plot_place,
    bool err_flag) {
  Tao::tao_wave_cmd(curve_name, plot_place, err_flag);
  auto py_result{PyTaoWaveCmd{err_flag}};
  return py_result;
}
struct PyTaoDatumHasAssociatedEle {
  int has_associated_ele;
};
PyTaoDatumHasAssociatedEle python_tao_datum_has_associated_ele(
    std::string data_type,
    std::optional<int> branch_geometry,
    int has_associated_ele) {
  Tao::tao_datum_has_associated_ele(
      data_type, branch_geometry, has_associated_ele);
  auto py_result{PyTaoDatumHasAssociatedEle{has_associated_ele}};
  return py_result;
}
struct PyTaoCurveEleRef {
  bool point_to_ele_ref;
};
PyTaoCurveEleRef python_tao_curve_ele_ref(
    TaoCurveProxy& curve,
    bool point_to_ele_ref,
    EleProxy& ele_track) {
  Tao::tao_curve_ele_ref(curve, point_to_ele_ref, ele_track);
  auto py_result{PyTaoCurveEleRef{point_to_ele_ref}};
  return py_result;
}
struct PyTaoOneTurnMapCalcNeeded {
  std::string data_type;
  std::string data_source;
  bool do_one_turn_map;
};
PyTaoOneTurnMapCalcNeeded python_tao_one_turn_map_calc_needed(
    std::string data_type,
    std::string data_source,
    bool do_one_turn_map) {
  Tao::tao_one_turn_map_calc_needed(data_type, data_source, do_one_turn_map);
  auto py_result{
      PyTaoOneTurnMapCalcNeeded{data_type, data_source, do_one_turn_map}};
  return py_result;
}
struct PyTaoEleShapeInfo : public Tao::TaoEleShapeInfo {
  double y1;
  double y2;
  std::optional<int> ix_shape_min;
  PyTaoEleShapeInfo(
      Tao::TaoEleShapeInfo _base,
      double y1,
      double y2,
      std::optional<int> ix_shape_min)
      : Tao::TaoEleShapeInfo(std::move(_base)),
        y1(y1),
        y2(y2),
        ix_shape_min(ix_shape_min) {}
};
PyTaoEleShapeInfo python_tao_ele_shape_info(
    int ix_uni,
    EleProxy& ele,
    TaoEleShapeProxyAlloc1D& ele_shapes,
    double y1,
    double y2,
    std::optional<int> ix_shape_min = std::nullopt) {
  auto _result = Tao::tao_ele_shape_info(
      ix_uni, ele, ele_shapes, y1, y2, make_opt_ref(ix_shape_min));
  auto py_result{PyTaoEleShapeInfo{_result, y1, y2, ix_shape_min}};
  return py_result;
}
struct PyTaoDataCheck {
  bool err;
};
PyTaoDataCheck python_tao_data_check(bool err) {
  Tao::tao_data_check(err);
  auto py_result{PyTaoDataCheck{err}};
  return py_result;
}
struct PyTaoBeamEmitCalc {
  double emit;
};
PyTaoBeamEmitCalc python_tao_beam_emit_calc(
    int plane,
    int emit_type,
    EleProxy& ele,
    BunchParamsProxy& bunch_params,
    double emit) {
  Tao::tao_beam_emit_calc(plane, emit_type, ele, bunch_params, emit);
  auto py_result{PyTaoBeamEmitCalc{emit}};
  return py_result;
}
struct PyTaoClipCmd {
  double value1;
  double value2;
};
PyTaoClipCmd python_tao_clip_cmd(
    bool gang,
    std::string where,
    double value1,
    double value2) {
  Tao::tao_clip_cmd(gang, where, value1, value2);
  auto py_result{PyTaoClipCmd{value1, value2}};
  return py_result;
}
struct PyTaoKeyInfoToStr {
  int ix_key;
  int ix_min_key;
  int ix_max_key;
  std::string key_str;
  std::string header_str;
};
PyTaoKeyInfoToStr python_tao_key_info_to_str(
    int ix_key,
    int ix_min_key,
    int ix_max_key,
    std::string key_str,
    std::string header_str) {
  Tao::tao_key_info_to_str(ix_key, ix_min_key, ix_max_key, key_str, header_str);
  auto py_result{
      PyTaoKeyInfoToStr{ix_key, ix_min_key, ix_max_key, key_str, header_str}};
  return py_result;
}
struct PyTaoPointerToEleShape : public Tao::TaoPointerToEleShape {
  std::optional<int> ix_shape_min;
  PyTaoPointerToEleShape(
      Tao::TaoPointerToEleShape _base,
      std::optional<int> ix_shape_min)
      : Tao::TaoPointerToEleShape(std::move(_base)),
        ix_shape_min(ix_shape_min) {}
};
PyTaoPointerToEleShape python_tao_pointer_to_ele_shape(
    int ix_uni,
    EleProxy& ele,
    TaoEleShapeProxyAlloc1D& ele_shape,
    std::optional<int> ix_shape_min,
    TaoEleShapeProxy& e_shape) {
  auto _result = Tao::tao_pointer_to_ele_shape(
      ix_uni, ele, ele_shape, make_opt_ref(ix_shape_min), e_shape);
  auto py_result{PyTaoPointerToEleShape{_result, ix_shape_min}};
  return py_result;
}
struct PyTaoRemoveBlankCharacters {
  std::string str;
};
PyTaoRemoveBlankCharacters python_tao_remove_blank_characters(std::string str) {
  Tao::tao_remove_blank_characters(str);
  auto py_result{PyTaoRemoveBlankCharacters{str}};
  return py_result;
}
struct PyTaoReadPhaseSpaceIndex {
  int ix_ps;
};
PyTaoReadPhaseSpaceIndex python_tao_read_phase_space_index(
    std::string name,
    int ixc,
    std::optional<bool> print_err,
    int ix_ps) {
  Tao::tao_read_phase_space_index(name, ixc, print_err, ix_ps);
  auto py_result{PyTaoReadPhaseSpaceIndex{ix_ps}};
  return py_result;
}
struct PyTaoInitBeamInUniverse {
  std::string track_start;
  std::string track_end;
  double comb_ds_save;
};
PyTaoInitBeamInUniverse python_tao_init_beam_in_universe(
    TaoUniverseProxy& u,
    BeamInitProxy& beam_init,
    std::string track_start,
    std::string track_end,
    double comb_ds_save) {
  Tao::tao_init_beam_in_universe(
      u, beam_init, track_start, track_end, comb_ds_save);
  auto py_result{PyTaoInitBeamInUniverse{track_start, track_end, comb_ds_save}};
  return py_result;
}

struct PyTaoChangeEle {
  bool err_flag;
  bool update;
};
PyTaoChangeEle python_tao_change_ele(
    std::string ele_name,
    std::string attrib_name,
    std::string num_str,
    bool update) {
  auto _result = Tao::tao_change_ele(ele_name, attrib_name, num_str, update);
  auto py_result{PyTaoChangeEle{_result, update}};
  return py_result;
}
struct PyTaoToChangeNumber {
  std::string num_str;
  int n_size;
  std::string abs_or_rel;
  bool err;
};
PyTaoToChangeNumber python_tao_to_change_number(
    std::string num_str,
    int n_size,
    RealAlloc1D& change_number,
    std::string abs_or_rel,
    bool err) {
  Tao::tao_to_change_number(num_str, n_size, change_number, abs_or_rel, err);
  auto py_result{PyTaoToChangeNumber{num_str, n_size, abs_or_rel, err}};
  return py_result;
}
struct PyTaoSetCalculateCmd {
  std::optional<std::string> switch_;
};
PyTaoSetCalculateCmd python_tao_set_calculate_cmd(
    std::optional<std::string> switch_ = std::nullopt) {
  Tao::tao_set_calculate_cmd(make_opt_ref(switch_));
  auto py_result{PyTaoSetCalculateCmd{switch_}};
  return py_result;
}
struct PyTaoSetDataCmd {
  std::optional<bool> silent;
};
PyTaoSetDataCmd python_tao_set_data_cmd(
    std::string who_str,
    std::string value_str,
    std::optional<bool> silent = std::nullopt) {
  Tao::tao_set_data_cmd(who_str, value_str, make_opt_ref(silent));
  auto py_result{PyTaoSetDataCmd{silent}};
  return py_result;
}
struct PyTaoSetElementsCmd {
  bool update;
};
PyTaoSetElementsCmd python_tao_set_elements_cmd(
    std::string ele_list,
    std::string attribute,
    std::string value,
    bool update) {
  Tao::tao_set_elements_cmd(ele_list, attribute, value, update);
  auto py_result{PyTaoSetElementsCmd{update}};
  return py_result;
}
struct PyTestIntegerScalar : public CppBmadTest::TestIntegerScalar {
  int val_inout;
  std::optional<int> val_inout_opt;
  PyTestIntegerScalar(
      CppBmadTest::TestIntegerScalar _base,
      int val_inout,
      std::optional<int> val_inout_opt)
      : CppBmadTest::TestIntegerScalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestIntegerScalar python_test_integer_scalar(
    int val_in,
    int val_inout,
    std::optional<int> val_in_opt = std::nullopt,
    std::optional<int> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_integer_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestIntegerScalar{_result, val_inout, val_inout_opt}};
  return py_result;
}
struct PyTestInteger8Scalar : public CppBmadTest::TestInteger8Scalar {
  int64_t val_inout;
  std::optional<int64_t> val_inout_opt;
  PyTestInteger8Scalar(
      CppBmadTest::TestInteger8Scalar _base,
      int64_t val_inout,
      std::optional<int64_t> val_inout_opt)
      : CppBmadTest::TestInteger8Scalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestInteger8Scalar python_test_integer8_scalar(
    int64_t val_in,
    int64_t val_inout,
    std::optional<int64_t> val_in_opt = std::nullopt,
    std::optional<int64_t> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_integer8_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestInteger8Scalar{_result, val_inout, val_inout_opt}};
  return py_result;
}
struct PyTestRealScalar : public CppBmadTest::TestRealScalar {
  double val_inout;
  std::optional<double> val_inout_opt;
  PyTestRealScalar(
      CppBmadTest::TestRealScalar _base,
      double val_inout,
      std::optional<double> val_inout_opt)
      : CppBmadTest::TestRealScalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestRealScalar python_test_real_scalar(
    double val_in,
    double val_inout,
    std::optional<double> val_in_opt = std::nullopt,
    std::optional<double> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_real_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestRealScalar{_result, val_inout, val_inout_opt}};
  return py_result;
}
struct PyTestReal16Scalar : public CppBmadTest::TestReal16Scalar {
  long double val_inout;
  std::optional<long double> val_inout_opt;
  PyTestReal16Scalar(
      CppBmadTest::TestReal16Scalar _base,
      long double val_inout,
      std::optional<long double> val_inout_opt)
      : CppBmadTest::TestReal16Scalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestReal16Scalar python_test_real16_scalar(
    long double val_in,
    long double val_inout,
    std::optional<long double> val_in_opt = std::nullopt,
    std::optional<long double> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_real16_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestReal16Scalar{_result, val_inout, val_inout_opt}};
  return py_result;
}
struct PyTestComplexScalar : public CppBmadTest::TestComplexScalar {
  std::complex<double> val_inout;
  std::optional<std::complex<double>> val_inout_opt;
  PyTestComplexScalar(
      CppBmadTest::TestComplexScalar _base,
      std::complex<double> val_inout,
      std::optional<std::complex<double>> val_inout_opt)
      : CppBmadTest::TestComplexScalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestComplexScalar python_test_complex_scalar(
    std::complex<double> val_in,
    std::complex<double> val_inout,
    std::optional<std::complex<double>> val_in_opt = std::nullopt,
    std::optional<std::complex<double>> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_complex_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestComplexScalar{_result, val_inout, val_inout_opt}};
  return py_result;
}
struct PyTestLogicalScalar : public CppBmadTest::TestLogicalScalar {
  bool val_inout;
  std::optional<bool> val_inout_opt;
  PyTestLogicalScalar(
      CppBmadTest::TestLogicalScalar _base,
      bool val_inout,
      std::optional<bool> val_inout_opt)
      : CppBmadTest::TestLogicalScalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestLogicalScalar python_test_logical_scalar(
    bool val_in,
    bool val_inout,
    std::optional<bool> val_in_opt = std::nullopt,
    std::optional<bool> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_logical_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestLogicalScalar{_result, val_inout, val_inout_opt}};
  return py_result;
}
struct PyTestCharacterScalar : public CppBmadTest::TestCharacterScalar {
  std::string val_inout;
  std::optional<std::string> val_inout_opt;
  PyTestCharacterScalar(
      CppBmadTest::TestCharacterScalar _base,
      std::string val_inout,
      std::optional<std::string> val_inout_opt)
      : CppBmadTest::TestCharacterScalar(std::move(_base)),
        val_inout(val_inout),
        val_inout_opt(val_inout_opt) {}
};
PyTestCharacterScalar python_test_character_scalar(
    std::string val_in,
    std::string val_inout,
    std::optional<std::string> val_in_opt = std::nullopt,
    std::optional<std::string> val_inout_opt = std::nullopt) {
  auto _result = CppBmadTest::test_character_scalar(
      val_in, val_inout, val_in_opt, make_opt_ref(val_inout_opt));
  auto py_result{PyTestCharacterScalar{_result, val_inout, val_inout_opt}};
  return py_result;
}

PYBIND11_MODULE(_pybmad, m) {
  // Generated definitions:

  m.doc() = "pybmad";

  // Per-structure bindings
  init_spline_struct(m);
  init_spin_polar_struct(m);
  init_ac_kicker_time_struct(m);
  init_ac_kicker_freq_struct(m);
  init_ac_kicker_struct(m);
  init_interval1_coef_struct(m);
  init_photon_reflect_table_struct(m);
  init_photon_reflect_surface_struct(m);
  init_coord_struct(m);
  init_coord_array_struct(m);
  init_bpm_phase_coupling_struct(m);
  init_expression_atom_struct(m);
  init_wake_sr_z_long_struct(m);
  init_wake_sr_mode_struct(m);
  init_wake_sr_struct(m);
  init_wake_lr_mode_struct(m);
  init_wake_lr_struct(m);
  init_lat_ele_loc_struct(m);
  init_wake_struct(m);
  init_taylor_term_struct(m);
  init_taylor_struct(m);
  init_em_taylor_term_struct(m);
  init_em_taylor_struct(m);
  init_cartesian_map_term1_struct(m);
  init_cartesian_map_term_struct(m);
  init_cartesian_map_struct(m);
  init_cylindrical_map_term1_struct(m);
  init_cylindrical_map_term_struct(m);
  init_cylindrical_map_struct(m);
  init_bicubic_cmplx_coef_struct(m);
  init_tricubic_cmplx_coef_struct(m);
  init_grid_field_pt1_struct(m);
  init_grid_field_pt_struct(m);
  init_grid_field_struct(m);
  init_floor_position_struct(m);
  init_high_energy_space_charge_struct(m);
  init_xy_disp_struct(m);
  init_twiss_struct(m);
  init_mode3_struct(m);
  init_bookkeeping_state_struct(m);
  init_rad_map_struct(m);
  init_rad_map_ele_struct(m);
  init_gen_grad1_struct(m);
  init_gen_grad_map_struct(m);
  init_surface_segmented_pt_struct(m);
  init_surface_segmented_struct(m);
  init_surface_h_misalign_pt_struct(m);
  init_surface_h_misalign_struct(m);
  init_surface_displacement_pt_struct(m);
  init_surface_displacement_struct(m);
  init_target_point_struct(m);
  init_surface_curvature_struct(m);
  init_photon_target_struct(m);
  init_photon_material_struct(m);
  init_pixel_pt_struct(m);
  init_pixel_detec_struct(m);
  init_photon_element_struct(m);
  init_wall3d_vertex_struct(m);
  init_wall3d_section_struct(m);
  init_wall3d_struct(m);
  init_ramper_lord_struct(m);
  init_control_struct(m);
  init_control_var1_struct(m);
  init_control_ramp1_struct(m);
  init_controller_struct(m);
  init_ellipse_beam_init_struct(m);
  init_kv_beam_init_struct(m);
  init_grid_beam_init_struct(m);
  init_beam_init_struct(m);
  init_lat_param_struct(m);
  init_mode_info_struct(m);
  init_pre_tracker_struct(m);
  init_anormal_mode_struct(m);
  init_linac_normal_mode_struct(m);
  init_normal_modes_struct(m);
  init_em_field_struct(m);
  init_strong_beam_struct(m);
  init_track_point_struct(m);
  init_track_struct(m);
  init_space_charge_common_struct(m);
  init_bmad_common_struct(m);
  init_rad_int1_struct(m);
  init_rad_int_branch_struct(m);
  init_rad_int_all_ele_struct(m);
  init_rf_stair_step_struct(m);
  init_rf_ele_struct(m);
  init_ele_struct(m);
  init_complex_taylor_term_struct(m);
  init_complex_taylor_struct(m);
  init_branch_struct(m);
  init_lat_struct(m);
  init_bunch_struct(m);
  init_bunch_params_struct(m);
  init_beam_struct(m);
  init_aperture_point_struct(m);
  init_aperture_param_struct(m);
  init_aperture_scan_struct(m);
  init_ele_pointer_struct(m);
  init_expression_tree_struct(m);
  init_nametable_struct(m);
  init_tao_spin_dn_dpz_struct(m);
  init_resonance_h_struct(m);
  init_spin_orbit_map1_struct(m);
  init_spin_axis_struct(m);
  init_ptc_normal_form_struct(m);
  init_bmad_normal_form_struct(m);
  init_bunch_track_struct(m);
  init_summation_rdt_struct(m);
  init_tao_ele_shape_struct(m);
  init_tao_curve_struct(m);
  init_lat_ele_order1_struct(m);
  init_lat_ele_order_array_struct(m);
  init_tao_lat_sigma_struct(m);
  init_tao_spin_ele_struct(m);
  init_tao_plot_cache_struct(m);
  init_tao_spin_polarization_struct(m);
  init_tao_lattice_branch_struct(m);
  init_tao_model_element_struct(m);
  init_tao_beam_branch_struct(m);
  init_tao_d1_data_struct(m);
  init_tao_d2_data_struct(m);
  init_tao_data_var_component_struct(m);
  init_tao_graph_struct(m);
  init_tao_plot_struct(m);
  init_tao_plot_region_struct(m);
  init_tao_universe_pointer_struct(m);
  init_tao_super_universe_struct(m);
  init_tao_var_struct(m);
  init_tao_lattice_struct(m);
  init_tao_beam_uni_struct(m);
  init_tao_dynamic_aperture_struct(m);
  init_tao_model_branch_struct(m);
  init_tao_spin_map_struct(m);
  init_tao_data_struct(m);
  init_tao_ping_scale_struct(m);
  init_tao_universe_calc_struct(m);
  init_lat_ele_order_struct(m);
  init_tao_universe_struct(m);
  init_all_encompassing_struct(m);
  init_test_sub_struct(m);
  init_test_sub_sub_struct(m);

  // Hand-written bindings
  bind_standard_arrays(m);
  init_common_structs(m);

  // Enums
  py::native_enum<EleAttribute>(m, "EleAttribute", "enum.IntEnum")
      .value(
          "L",
          EleAttribute::L,
          "Assumed unique. Do not assign 1 to another attribute.")
      .value("TILT", EleAttribute::TILT, "Important: tilt$ = roll$")
      .value("ROLL", EleAttribute::ROLL)
      .value("N_PART", EleAttribute::N_PART)
      .value("INHERIT_FROM_FORK", EleAttribute::INHERIT_FROM_FORK)
      .value("REF_TILT", EleAttribute::REF_TILT)
      .value("DIRECTION", EleAttribute::DIRECTION)
      .value("REPETITION_FREQUENCY", EleAttribute::REPETITION_FREQUENCY)
      .value("DETA_DS_MASTER", EleAttribute::DETA_DS_MASTER)
      .value("KICK", EleAttribute::KICK)
      .value("X_GAIN_ERR", EleAttribute::X_GAIN_ERR)
      .value("TAYLOR_ORDER", EleAttribute::TAYLOR_ORDER)
      .value("R_SOLENOID", EleAttribute::R_SOLENOID)
      .value("FINAL_CHARGE", EleAttribute::FINAL_CHARGE)
      .value("K1", EleAttribute::K1)
      .value("KX", EleAttribute::KX)
      .value("HARMON", EleAttribute::HARMON)
      .value("H_DISPLACE", EleAttribute::H_DISPLACE)
      .value("Y_GAIN_ERR", EleAttribute::Y_GAIN_ERR)
      .value("S_TWISS_REF", EleAttribute::S_TWISS_REF)
      .value("CRITICAL_ANGLE_FACTOR", EleAttribute::CRITICAL_ANGLE_FACTOR)
      .value("TILT_CORR", EleAttribute::TILT_CORR)
      .value("REF_COORDS", EleAttribute::REF_COORDS)
      .value("DT_MAX", EleAttribute::DT_MAX)
      .value("IX_FIXER", EleAttribute::IX_FIXER)
      .value("GRAZE_ANGLE", EleAttribute::GRAZE_ANGLE)
      .value("K2", EleAttribute::K2)
      .value("B_MAX", EleAttribute::B_MAX)
      .value("V_DISPLACE", EleAttribute::V_DISPLACE)
      .value("GRADIENT_TOT", EleAttribute::GRADIENT_TOT)
      .value("HARMON_MASTER", EleAttribute::HARMON_MASTER)
      .value("FLEXIBLE", EleAttribute::FLEXIBLE)
      .value("CRUNCH", EleAttribute::CRUNCH)
      .value("REF_ORBIT_FOLLOWS", EleAttribute::REF_ORBIT_FOLLOWS)
      .value("PC_OUT_MIN", EleAttribute::PC_OUT_MIN)
      .value("GRADIENT", EleAttribute::GRADIENT)
      .value("K3", EleAttribute::K3)
      .value("NOISE", EleAttribute::NOISE)
      .value("NEW_BRANCH", EleAttribute::NEW_BRANCH)
      .value("IX_BRANCH", EleAttribute::IX_BRANCH)
      .value("G_MAX", EleAttribute::G_MAX)
      .value("G", EleAttribute::G)
      .value("SYMMETRY", EleAttribute::SYMMETRY)
      .value("FIELD_SCALE_FACTOR", EleAttribute::FIELD_SCALE_FACTOR)
      .value("PC_OUT_MAX", EleAttribute::PC_OUT_MAX)
      .value("DG", EleAttribute::DG)
      .value("BBI_CONST", EleAttribute::BBI_CONST)
      .value("OSC_AMPLITUDE", EleAttribute::OSC_AMPLITUDE)
      .value("IX_TO_BRANCH", EleAttribute::IX_TO_BRANCH)
      .value("ANGLE_OUT_MAX", EleAttribute::ANGLE_OUT_MAX)
      .value("GRADIENT_ERR", EleAttribute::GRADIENT_ERR)
      .value("CRITICAL_ANGLE", EleAttribute::CRITICAL_ANGLE)
      .value("BRAGG_ANGLE_IN", EleAttribute::BRAGG_ANGLE_IN)
      .value("SPIN_DN_DPZ_X", EleAttribute::SPIN_DN_DPZ_X)
      .value("DELTA_E_REF", EleAttribute::DELTA_E_REF)
      .value("INTERPOLATION", EleAttribute::INTERPOLATION)
      .value("BRAGG_ANGLE_OUT", EleAttribute::BRAGG_ANGLE_OUT)
      .value("K1X", EleAttribute::K1X)
      .value("SPIN_DN_DPZ_Y", EleAttribute::SPIN_DN_DPZ_Y)
      .value("CHARGE", EleAttribute::CHARGE)
      .value("X_GAIN_CALIB", EleAttribute::X_GAIN_CALIB)
      .value("IX_TO_ELEMENT", EleAttribute::IX_TO_ELEMENT)
      .value("VOLTAGE", EleAttribute::VOLTAGE)
      .value("G_TOT", EleAttribute::G_TOT)
      .value("RHO", EleAttribute::RHO)
      .value("VOLTAGE_ERR", EleAttribute::VOLTAGE_ERR)
      .value("BRAGG_ANGLE", EleAttribute::BRAGG_ANGLE)
      .value("K1Y", EleAttribute::K1Y)
      .value("N_PARTICLE", EleAttribute::N_PARTICLE)
      .value("SPIN_DN_DPZ_Z", EleAttribute::SPIN_DN_DPZ_Z)
      .value("FRINGE_TYPE", EleAttribute::FRINGE_TYPE)
      .value("DBRAGG_ANGLE_DE", EleAttribute::DBRAGG_ANGLE_DE)
      .value("FRINGE_AT", EleAttribute::FRINGE_AT)
      .value("GANG", EleAttribute::GANG)
      .value("DARWIN_WIDTH_SIGMA", EleAttribute::DARWIN_WIDTH_SIGMA)
      .value("DARWIN_WIDTH_PI", EleAttribute::DARWIN_WIDTH_PI)
      .value("SPIN_FRINGE_ON", EleAttribute::SPIN_FRINGE_ON)
      .value(
          "PENDELLOSUNG_PERIOD_SIGMA", EleAttribute::PENDELLOSUNG_PERIOD_SIGMA)
      .value("SIG_X", EleAttribute::SIG_X)
      .value("EXACT_MULTIPOLES", EleAttribute::EXACT_MULTIPOLES)
      .value("PENDELLOSUNG_PERIOD_PI", EleAttribute::PENDELLOSUNG_PERIOD_PI)
      .value("SIG_Y", EleAttribute::SIG_Y)
      .value("GRAZE_ANGLE_IN", EleAttribute::GRAZE_ANGLE_IN)
      .value("R0_ELEC", EleAttribute::R0_ELEC)
      .value("RF_FREQUENCY", EleAttribute::RF_FREQUENCY)
      .value("SIG_Z", EleAttribute::SIG_Z)
      .value("GRAZE_ANGLE_OUT", EleAttribute::GRAZE_ANGLE_OUT)
      .value("R0_MAG", EleAttribute::R0_MAG)
      .value("RF_WAVELENGTH", EleAttribute::RF_WAVELENGTH)
      .value("SIG_VX", EleAttribute::SIG_VX)
      .value("SIG_VY", EleAttribute::SIG_VY)
      .value("CONSTANT_REF_ENERGY", EleAttribute::CONSTANT_REF_ENERGY)
      .value("KS", EleAttribute::KS)
      .value("SIG_E", EleAttribute::SIG_E)
      .value("SIG_PZ", EleAttribute::SIG_PZ)
      .value("AUTOSCALE_AMPLITUDE", EleAttribute::AUTOSCALE_AMPLITUDE)
      .value("D1_THICKNESS", EleAttribute::D1_THICKNESS)
      .value("DEFAULT_TRACKING_SPECIES", EleAttribute::DEFAULT_TRACKING_SPECIES)
      .value("AUTOSCALE_PHASE", EleAttribute::AUTOSCALE_PHASE)
      .value("N_SLICE", EleAttribute::N_SLICE)
      .value("Y_GAIN_CALIB", EleAttribute::Y_GAIN_CALIB)
      .value("SIG_E2", EleAttribute::SIG_E2)
      .value("FB1", EleAttribute::FB1)
      .value("POLARITY", EleAttribute::POLARITY)
      .value("CRUNCH_CALIB", EleAttribute::CRUNCH_CALIB)
      .value("ALPHA_ANGLE", EleAttribute::ALPHA_ANGLE)
      .value("D2_THICKNESS", EleAttribute::D2_THICKNESS)
      .value("BETA_A_STRONG", EleAttribute::BETA_A_STRONG)
      .value("BETA_A_OUT", EleAttribute::BETA_A_OUT)
      .value("E_LOSS", EleAttribute::E_LOSS)
      .value("GAP", EleAttribute::GAP)
      .value("SPIN_X", EleAttribute::SPIN_X)
      .value("E_CENTER", EleAttribute::E_CENTER)
      .value("SCATTER_TEST", EleAttribute::SCATTER_TEST)
      .value("FB2", EleAttribute::FB2)
      .value("X_OFFSET_CALIB", EleAttribute::X_OFFSET_CALIB)
      .value("V1_UNITCELL", EleAttribute::V1_UNITCELL)
      .value("PSI_ANGLE", EleAttribute::PSI_ANGLE)
      .value("CAVITY_TYPE", EleAttribute::CAVITY_TYPE)
      .value("BETA_B_STRONG", EleAttribute::BETA_B_STRONG)
      .value("BETA_B_OUT", EleAttribute::BETA_B_OUT)
      .value("SPIN_Y", EleAttribute::SPIN_Y)
      .value("E2_CENTER", EleAttribute::E2_CENTER)
      .value("N_PERIOD", EleAttribute::N_PERIOD)
      .value("EMIT_FRACTION", EleAttribute::EMIT_FRACTION)
      .value("X1_EDGE", EleAttribute::X1_EDGE)
      .value("Y_OFFSET_CALIB", EleAttribute::Y_OFFSET_CALIB)
      .value("V_UNITCELL", EleAttribute::V_UNITCELL)
      .value("V2_UNITCELL", EleAttribute::V2_UNITCELL)
      .value("SPIN_Z", EleAttribute::SPIN_Z)
      .value("L_PERIOD", EleAttribute::L_PERIOD)
      .value("FQ1", EleAttribute::FQ1)
      .value("ALPHA_A_STRONG", EleAttribute::ALPHA_A_STRONG)
      .value("ALPHA_A_OUT", EleAttribute::ALPHA_A_OUT)
      .value("E2_PROBABILITY", EleAttribute::E2_PROBABILITY)
      .value("PHI0_MAX", EleAttribute::PHI0_MAX)
      .value("X2_EDGE", EleAttribute::X2_EDGE)
      .value("FQ2", EleAttribute::FQ2)
      .value("PHI0", EleAttribute::PHI0)
      .value("TILT_CALIB", EleAttribute::TILT_CALIB)
      .value("E_CENTER_RELATIVE_TO_REF", EleAttribute::E_CENTER_RELATIVE_TO_REF)
      .value("Y1_EDGE", EleAttribute::Y1_EDGE)
      .value("ALPHA_B_STRONG", EleAttribute::ALPHA_B_STRONG)
      .value("ALPHA_B_OUT", EleAttribute::ALPHA_B_OUT)
      .value("IS_MOSAIC", EleAttribute::IS_MOSAIC)
      .value("PX_APERTURE_WIDTH2", EleAttribute::PX_APERTURE_WIDTH2)
      .value("PHI0_ERR", EleAttribute::PHI0_ERR)
      .value("CURRENT", EleAttribute::CURRENT)
      .value("MOSAIC_THICKNESS", EleAttribute::MOSAIC_THICKNESS)
      .value("PX_APERTURE_CENTER", EleAttribute::PX_APERTURE_CENTER)
      .value("ETA_X_OUT", EleAttribute::ETA_X_OUT)
      .value("QUAD_TILT", EleAttribute::QUAD_TILT)
      .value("DE_ETA_MEAS", EleAttribute::DE_ETA_MEAS)
      .value("SPATIAL_DISTRIBUTION", EleAttribute::SPATIAL_DISTRIBUTION)
      .value("Y2_EDGE", EleAttribute::Y2_EDGE)
      .value("SPECIES_STRONG", EleAttribute::SPECIES_STRONG)
      .value("ETA_Y_OUT", EleAttribute::ETA_Y_OUT)
      .value("MODE", EleAttribute::MODE)
      .value("VELOCITY_DISTRIBUTION", EleAttribute::VELOCITY_DISTRIBUTION)
      .value("PY_APERTURE_WIDTH2", EleAttribute::PY_APERTURE_WIDTH2)
      .value("PHI0_MULTIPASS", EleAttribute::PHI0_MULTIPASS)
      .value("N_SAMPLE", EleAttribute::N_SAMPLE)
      .value("ORIGIN_ELE_REF_PT", EleAttribute::ORIGIN_ELE_REF_PT)
      .value(
          "MOSAIC_ANGLE_RMS_IN_PLANE", EleAttribute::MOSAIC_ANGLE_RMS_IN_PLANE)
      .value("EPS_STEP_SCALE", EleAttribute::EPS_STEP_SCALE)
      .value("E_TOT_STRONG", EleAttribute::E_TOT_STRONG)
      .value("DTHICKNESS_DX", EleAttribute::DTHICKNESS_DX)
      .value("BEND_TILT", EleAttribute::BEND_TILT)
      .value("ETAP_X_OUT", EleAttribute::ETAP_X_OUT)
      .value("PHI0_AUTOSCALE", EleAttribute::PHI0_AUTOSCALE)
      .value("DX_ORIGIN", EleAttribute::DX_ORIGIN)
      .value("ENERGY_DISTRIBUTION", EleAttribute::ENERGY_DISTRIBUTION)
      .value("X_QUAD", EleAttribute::X_QUAD)
      .value("DS_PHOTON_SLICE", EleAttribute::DS_PHOTON_SLICE)
      .value(
          "MOSAIC_ANGLE_RMS_OUT_PLANE",
          EleAttribute::MOSAIC_ANGLE_RMS_OUT_PLANE)
      .value("PY_APERTURE_CENTER", EleAttribute::PY_APERTURE_CENTER)
      .value("X_DISPERSION_ERR", EleAttribute::X_DISPERSION_ERR)
      .value("L_RECTANGLE", EleAttribute::L_RECTANGLE)
      .value("PC_STRONG", EleAttribute::PC_STRONG)
      .value("ETAP_Y_OUT", EleAttribute::ETAP_Y_OUT)
      .value("DY_ORIGIN", EleAttribute::DY_ORIGIN)
      .value("Y_QUAD", EleAttribute::Y_QUAD)
      .value("E_FIELD_X", EleAttribute::E_FIELD_X)
      .value("Y_DISPERSION_ERR", EleAttribute::Y_DISPERSION_ERR)
      .value("Z_APERTURE_WIDTH2", EleAttribute::Z_APERTURE_WIDTH2)
      .value("USER_SETS_LENGTH", EleAttribute::USER_SETS_LENGTH)
      .value("B_FIELD_TOT", EleAttribute::B_FIELD_TOT)
      .value("UPSTREAM_COORD_DIR", EleAttribute::UPSTREAM_COORD_DIR)
      .value("DZ_ORIGIN", EleAttribute::DZ_ORIGIN)
      .value("MOSAIC_DIFFRACTION_NUM", EleAttribute::MOSAIC_DIFFRACTION_NUM)
      .value("CMAT_11", EleAttribute::CMAT_11)
      .value("FIELD_AUTOSCALE", EleAttribute::FIELD_AUTOSCALE)
      .value("L_SAGITTA", EleAttribute::L_SAGITTA)
      .value("E_FIELD_Y", EleAttribute::E_FIELD_Y)
      .value("X_DISPERSION_CALIB", EleAttribute::X_DISPERSION_CALIB)
      .value("Z_APERTURE_CENTER", EleAttribute::Z_APERTURE_CENTER)
      .value("F_FACTOR", EleAttribute::F_FACTOR)
      .value("CMAT_12", EleAttribute::CMAT_12)
      .value("DTHETA_ORIGIN", EleAttribute::DTHETA_ORIGIN)
      .value("B_PARAM", EleAttribute::B_PARAM)
      .value("L_CHORD", EleAttribute::L_CHORD)
      .value("DOWNSTREAM_COORD_DIR", EleAttribute::DOWNSTREAM_COORD_DIR)
      .value("PZ_APERTURE_WIDTH2", EleAttribute::PZ_APERTURE_WIDTH2)
      .value("Y_DISPERSION_CALIB", EleAttribute::Y_DISPERSION_CALIB)
      .value("SCALE_FIELD_TO_ONE", EleAttribute::SCALE_FIELD_TO_ONE)
      .value("VOLTAGE_TOT", EleAttribute::VOLTAGE_TOT)
      .value("SCATTER_METHOD", EleAttribute::SCATTER_METHOD)
      .value("CMAT_21", EleAttribute::CMAT_21)
      .value("L_ACTIVE", EleAttribute::L_ACTIVE)
      .value("DPHI_ORIGIN", EleAttribute::DPHI_ORIGIN)
      .value("SPLIT_ID", EleAttribute::SPLIT_ID)
      .value("REF_CAP_GAMMA", EleAttribute::REF_CAP_GAMMA)
      .value("L_SOFT_EDGE", EleAttribute::L_SOFT_EDGE)
      .value("TRANSVERSE_SIGMA_CUT", EleAttribute::TRANSVERSE_SIGMA_CUT)
      .value("PZ_APERTURE_CENTER", EleAttribute::PZ_APERTURE_CENTER)
      .value("MEAN_EXCITATION_ENERGY", EleAttribute::MEAN_EXCITATION_ENERGY)
      .value("FIDUCIAL_PT", EleAttribute::FIDUCIAL_PT)
      .value("CMAT_22", EleAttribute::CMAT_22)
      .value("DPSI_ORIGIN", EleAttribute::DPSI_ORIGIN)
      .value("T_OFFSET", EleAttribute::T_OFFSET)
      .value("DS_SLICE", EleAttribute::DS_SLICE)
      .value("USE_REFLECTIVITY_TABLE", EleAttribute::USE_REFLECTIVITY_TABLE)
      .value("INIT_NEEDED", EleAttribute::INIT_NEEDED)
      .value("LONGITUDINAL_MODE", EleAttribute::LONGITUDINAL_MODE)
      .value("ANGLE", EleAttribute::ANGLE)
      .value("N_CELL", EleAttribute::N_CELL)
      .value("MODE_FLIP", EleAttribute::MODE_FLIP)
      .value("CROSSING_TIME", EleAttribute::CROSSING_TIME)
      .value("X_KICK", EleAttribute::X_KICK)
      .value(
          "X_PITCH",
          EleAttribute::X_PITCH,
          "Note: [x_kick$, px_kick$, ..., pz_kick$] must be in order.")
      .value("PX_KICK", EleAttribute::PX_KICK)
      .value("Y_PITCH", EleAttribute::Y_PITCH)
      .value("Y_KICK", EleAttribute::Y_KICK)
      .value("X_OFFSET", EleAttribute::X_OFFSET)
      .value("PY_KICK", EleAttribute::PY_KICK)
      .value("Y_OFFSET", EleAttribute::Y_OFFSET)
      .value("Z_KICK", EleAttribute::Z_KICK)
      .value("Z_OFFSET", EleAttribute::Z_OFFSET)
      .value("PZ_KICK", EleAttribute::PZ_KICK)
      .value("HKICK", EleAttribute::HKICK)
      .value("D_SPACING", EleAttribute::D_SPACING)
      .value("X_OFFSET_MULT", EleAttribute::X_OFFSET_MULT)
      .value("EMITTANCE_A", EleAttribute::EMITTANCE_A)
      .value("CRAB_X1", EleAttribute::CRAB_X1)
      .value("VKICK", EleAttribute::VKICK)
      .value("Y_OFFSET_MULT", EleAttribute::Y_OFFSET_MULT)
      .value("P0C_REF_INIT", EleAttribute::P0C_REF_INIT)
      .value("EMITTANCE_B", EleAttribute::EMITTANCE_B)
      .value("CRAB_X2", EleAttribute::CRAB_X2)
      .value("BL_HKICK", EleAttribute::BL_HKICK)
      .value("E_TOT_REF_INIT", EleAttribute::E_TOT_REF_INIT)
      .value("EMITTANCE_Z", EleAttribute::EMITTANCE_Z)
      .value("CRAB_X3", EleAttribute::CRAB_X3)
      .value("BL_VKICK", EleAttribute::BL_VKICK)
      .value("CRAB_TILT", EleAttribute::CRAB_TILT)
      .value("BL_KICK", EleAttribute::BL_KICK)
      .value("B_FIELD", EleAttribute::B_FIELD)
      .value("E_FIELD", EleAttribute::E_FIELD)
      .value(
          "HIGH_ENERGY_SPACE_CHARGE_ON",
          EleAttribute::HIGH_ENERGY_SPACE_CHARGE_ON)
      .value("CRAB_X4", EleAttribute::CRAB_X4)
      .value("N_RF_STEPS", EleAttribute::N_RF_STEPS)
      .value("PHOTON_TYPE", EleAttribute::PHOTON_TYPE)
      .value("COUPLER_PHASE", EleAttribute::COUPLER_PHASE)
      .value("DB_FIELD", EleAttribute::DB_FIELD)
      .value("CRAB_X5", EleAttribute::CRAB_X5)
      .value("LATTICE_TYPE", EleAttribute::LATTICE_TYPE)
      .value("B1_GRADIENT", EleAttribute::B1_GRADIENT)
      .value("E1_GRADIENT", EleAttribute::E1_GRADIENT)
      .value("COUPLER_ANGLE", EleAttribute::COUPLER_ANGLE)
      .value("LIVE_BRANCH", EleAttribute::LIVE_BRANCH)
      .value("B2_GRADIENT", EleAttribute::B2_GRADIENT)
      .value("E2_GRADIENT", EleAttribute::E2_GRADIENT)
      .value("COUPLER_STRENGTH", EleAttribute::COUPLER_STRENGTH)
      .value("GEOMETRY", EleAttribute::GEOMETRY)
      .value("COUPLER_AT", EleAttribute::COUPLER_AT)
      .value("E_TOT_OFFSET", EleAttribute::E_TOT_OFFSET)
      .value("PTC_CANONICAL_COORDS", EleAttribute::PTC_CANONICAL_COORDS)
      .value("B3_GRADIENT", EleAttribute::B3_GRADIENT)
      .value("E3_GRADIENT", EleAttribute::E3_GRADIENT)
      .value("PTC_FRINGE_GEOMETRY", EleAttribute::PTC_FRINGE_GEOMETRY)
      .value("E_TOT_SET", EleAttribute::E_TOT_SET)
      .value("BS_FIELD", EleAttribute::BS_FIELD)
      .value("P0C_SET", EleAttribute::P0C_SET)
      .value("PTC_FIELD_GEOMETRY", EleAttribute::PTC_FIELD_GEOMETRY)
      .value("DELTA_REF_TIME_USER_SET", EleAttribute::DELTA_REF_TIME_USER_SET)
      .value("DELTA_REF_TIME", EleAttribute::DELTA_REF_TIME)
      .value("P0C_START", EleAttribute::P0C_START)
      .value("E_TOT_START", EleAttribute::E_TOT_START)
      .value("P0C", EleAttribute::P0C)
      .value("E_TOT", EleAttribute::E_TOT)
      .value("X_PITCH_TOT", EleAttribute::X_PITCH_TOT)
      .value("NO_END_MARKER", EleAttribute::NO_END_MARKER)
      .value("Y_PITCH_TOT", EleAttribute::Y_PITCH_TOT)
      .value("X_OFFSET_TOT", EleAttribute::X_OFFSET_TOT)
      .value("Y_OFFSET_TOT", EleAttribute::Y_OFFSET_TOT)
      .value("Z_OFFSET_TOT", EleAttribute::Z_OFFSET_TOT)
      .value(
          "TILT_TOT",
          EleAttribute::TILT_TOT,
          "Important: tilt_tot$ = roll_tot$")
      .value("ROLL_TOT", EleAttribute::ROLL_TOT)
      .value("REF_TILT_TOT", EleAttribute::REF_TILT_TOT)
      .value("MULTIPASS_REF_ENERGY", EleAttribute::MULTIPASS_REF_ENERGY)
      .value("DISPATCH", EleAttribute::DISPATCH)
      .value("REF_TIME_START", EleAttribute::REF_TIME_START)
      .value(
          "THICKNESS",
          EleAttribute::THICKNESS,
          "For Etiennes' PTC: 2, 4, 6, or 8.")
      .value("INTEGRATOR_ORDER", EleAttribute::INTEGRATOR_ORDER)
      .value(
          "NUM_STEPS",
          EleAttribute::NUM_STEPS,
          "Assumed unique by set_flags_for_changed_real_attribute")
      .value(
          "DS_STEP",
          EleAttribute::DS_STEP,
          "Assumed unique by set_flags_for_changed_real_attribute")
      .value("CSR_DS_STEP", EleAttribute::CSR_DS_STEP)
      .value("LORD_PAD1", EleAttribute::LORD_PAD1)
      .value("LORD_PAD2", EleAttribute::LORD_PAD2)
      .value("REF_WAVELENGTH", EleAttribute::REF_WAVELENGTH)
      .value("X1_LIMIT", EleAttribute::X1_LIMIT)
      .value("X2_LIMIT", EleAttribute::X2_LIMIT)
      .value("Y1_LIMIT", EleAttribute::Y1_LIMIT)
      .value("Y2_LIMIT", EleAttribute::Y2_LIMIT)
      .value("CHECK_SUM", EleAttribute::CHECK_SUM)
      .export_values()
      .finalize();
  py::native_enum<EleKey>(m, "EleKey", "enum.IntEnum")
      .value("DRIFT", EleKey::DRIFT)
      .value("SBEND", EleKey::SBEND)
      .value("QUADRUPOLE", EleKey::QUADRUPOLE)
      .value("GROUP", EleKey::GROUP)
      .value("SEXTUPOLE", EleKey::SEXTUPOLE)
      .value("OVERLAY", EleKey::OVERLAY)
      .value("CUSTOM", EleKey::CUSTOM)
      .value("TAYLOR", EleKey::TAYLOR)
      .value("RFCAVITY", EleKey::RFCAVITY)
      .value("ELSEPARATOR", EleKey::ELSEPARATOR)
      .value("BEAMBEAM", EleKey::BEAMBEAM)
      .value("WIGGLER", EleKey::WIGGLER)
      .value("SOL_QUAD", EleKey::SOL_QUAD)
      .value("MARKER", EleKey::MARKER)
      .value("KICKER", EleKey::KICKER)
      .value("HYBRID", EleKey::HYBRID)
      .value("OCTUPOLE", EleKey::OCTUPOLE)
      .value("RBEND", EleKey::RBEND)
      .value("MULTIPOLE", EleKey::MULTIPOLE)
      .value("DEF_BMAD_COM", EleKey::DEF_BMAD_COM)
      .value("DEF_MAD_BEAM", EleKey::DEF_MAD_BEAM)
      .value("AB_MULTIPOLE", EleKey::AB_MULTIPOLE)
      .value("SOLENOID", EleKey::SOLENOID)
      .value("PATCH", EleKey::PATCH)
      .value("LCAVITY", EleKey::LCAVITY)
      .value("DEF_PARAMETER", EleKey::DEF_PARAMETER)
      .value("NULL_ELE", EleKey::NULL_ELE)
      .value("BEGINNING_ELE", EleKey::BEGINNING_ELE)
      .value("DEF_LINE", EleKey::DEF_LINE)
      .value("MATCH", EleKey::MATCH)
      .value("MONITOR", EleKey::MONITOR)
      .value("INSTRUMENT", EleKey::INSTRUMENT)
      .value("HKICKER", EleKey::HKICKER)
      .value("VKICKER", EleKey::VKICKER)
      .value("RCOLLIMATOR", EleKey::RCOLLIMATOR)
      .value("ECOLLIMATOR", EleKey::ECOLLIMATOR)
      .value("GIRDER", EleKey::GIRDER)
      .value("CONVERTER", EleKey::CONVERTER)
      .value("DEF_PARTICLE_START", EleKey::DEF_PARTICLE_START)
      .value("PHOTON_FORK", EleKey::PHOTON_FORK)
      .value("FORK", EleKey::FORK)
      .value("MIRROR", EleKey::MIRROR)
      .value("CRYSTAL", EleKey::CRYSTAL)
      .value("PIPE", EleKey::PIPE)
      .value("CAPILLARY", EleKey::CAPILLARY)
      .value("MULTILAYER_MIRROR", EleKey::MULTILAYER_MIRROR)
      .value("E_GUN", EleKey::E_GUN)
      .value("EM_FIELD", EleKey::EM_FIELD)
      .value("FLOOR_SHIFT", EleKey::FLOOR_SHIFT)
      .value("FIDUCIAL", EleKey::FIDUCIAL)
      .value("UNDULATOR", EleKey::UNDULATOR)
      .value("DIFFRACTION_PLATE", EleKey::DIFFRACTION_PLATE)
      .value("PHOTON_INIT", EleKey::PHOTON_INIT)
      .value("SAMPLE", EleKey::SAMPLE)
      .value("DETECTOR", EleKey::DETECTOR)
      .value("SAD_MULT", EleKey::SAD_MULT)
      .value("MASK", EleKey::MASK)
      .value("AC_KICKER", EleKey::AC_KICKER)
      .value("LENS", EleKey::LENS)
      .value("DEF_SPACE_CHARGE_COM", EleKey::DEF_SPACE_CHARGE_COM)
      .value("CRAB_CAVITY", EleKey::CRAB_CAVITY)
      .value("RAMPER", EleKey::RAMPER)
      .value("DEF_PTC_COM", EleKey::DEF_PTC_COM)
      .value("RF_BEND", EleKey::RF_BEND)
      .value("GKICKER", EleKey::GKICKER)
      .value("FOIL", EleKey::FOIL)
      .value("THICK_MULTIPOLE", EleKey::THICK_MULTIPOLE)
      .value("PICKUP", EleKey::PICKUP)
      .value("FEEDBACK", EleKey::FEEDBACK)
      .value("FIXER", EleKey::FIXER)
      .value("N_KEY", EleKey::N_KEY)
      .export_values()
      .finalize();

  // Enums from bmad_struct.f90
  m.attr("BMAD_INC_VERSION") = py::int_(Bmad::BMAD_INC_VERSION);
  m.attr("NONE") = py::int_(Bmad::NONE);
  // maximum multipole order
  m.attr("N_POLE_MAXX") = py::int_(Bmad::N_POLE_MAXX);
  // For indexing into ele%control%var(:) array
  m.attr("OLD_CONTROL_VAR_OFFSET") = py::int_(Bmad::OLD_CONTROL_VAR_OFFSET);
  // Important: var_offset$ > old_control_var_offset$
  m.attr("VAR_OFFSET") = py::int_(Bmad::VAR_OFFSET);
  // Maximum number of variables per controller.
  m.attr("N_VAR_MAX") = py::int_(Bmad::N_VAR_MAX);
  // Taylor term index offset.
  m.attr("TAYLOR_OFFSET") = py::int_(Bmad::TAYLOR_OFFSET);
  m.attr("BMAD_STANDARD") = py::int_(Bmad::BMAD_STANDARD);
  m.attr("SYMP_LIE_PTC") = py::int_(Bmad::SYMP_LIE_PTC);
  m.attr("RUNGE_KUTTA") = py::int_(Bmad::RUNGE_KUTTA);
  m.attr("LINEAR") = py::int_(Bmad::LINEAR);
  m.attr("TRACKING") = py::int_(Bmad::TRACKING);
  m.attr("TIME_RUNGE_KUTTA") = py::int_(Bmad::TIME_RUNGE_KUTTA);
  m.attr("FIXED_STEP_RUNGE_KUTTA") = py::int_(Bmad::FIXED_STEP_RUNGE_KUTTA);
  m.attr("SYMP_LIE_BMAD") = py::int_(Bmad::SYMP_LIE_BMAD);
  m.attr("MAGNUS") = py::int_(Bmad::MAGNUS);
  m.attr("AUTO") = py::int_(Bmad::AUTO);
  m.attr("SPRINT") = py::int_(Bmad::SPRINT);
  m.attr("FIXED_STEP_TIME_RUNGE_KUTTA") =
      py::int_(Bmad::FIXED_STEP_TIME_RUNGE_KUTTA);
  m.attr("MAD") = py::int_(Bmad::MAD);
  m.attr("TRANSVERSE_KICK") = py::int_(Bmad::TRANSVERSE_KICK);
  m.attr("SPIN_INTEGRATION") = py::int_(Bmad::SPIN_INTEGRATION);
  m.attr("DRIFT_KICK") = py::int_(Bmad::DRIFT_KICK);
  m.attr("MATRIX_KICK") = py::int_(Bmad::MATRIX_KICK);
  m.attr("RIPKEN_KICK") = py::int_(Bmad::RIPKEN_KICK);
  m.attr("SECTOR") = py::int_(Bmad::SECTOR);
  m.attr("STRAIGHT") = py::int_(Bmad::STRAIGHT);
  m.attr("FIELDMAP") = py::int_(Bmad::FIELDMAP);
  m.attr("PLANAR_MODEL") = py::int_(Bmad::PLANAR_MODEL);
  m.attr("REFER_TO_LORDS") = py::int_(Bmad::REFER_TO_LORDS);
  m.attr("NO_FIELD") = py::int_(Bmad::NO_FIELD);
  m.attr("HELICAL_MODEL") = py::int_(Bmad::HELICAL_MODEL);
  m.attr("SOFT_EDGE") = py::int_(Bmad::SOFT_EDGE);
  m.attr("UNIFORM") = py::int_(Bmad::UNIFORM);
  m.attr("GAUSSIAN") = py::int_(Bmad::GAUSSIAN);
  m.attr("SPHERICAL") = py::int_(Bmad::SPHERICAL);
  m.attr("CURVE") = py::int_(Bmad::CURVE);
  // Index to set slice_slave%ix_ele to.
  m.attr("IX_SLICE_SLAVE") = py::int_(Bmad::IX_SLICE_SLAVE);
  m.attr("MINOR_SLAVE") = py::int_(Bmad::MINOR_SLAVE);
  m.attr("SUPER_SLAVE") = py::int_(Bmad::SUPER_SLAVE);
  m.attr("FREE") = py::int_(Bmad::FREE);
  m.attr("GROUP_LORD") = py::int_(Bmad::GROUP_LORD);
  m.attr("SUPER_LORD") = py::int_(Bmad::SUPER_LORD);
  m.attr("OVERLAY_LORD") = py::int_(Bmad::OVERLAY_LORD);
  m.attr("GIRDER_LORD") = py::int_(Bmad::GIRDER_LORD);
  m.attr("MULTIPASS_LORD") = py::int_(Bmad::MULTIPASS_LORD);
  m.attr("MULTIPASS_SLAVE") = py::int_(Bmad::MULTIPASS_SLAVE);
  m.attr("NOT_A_LORD") = py::int_(Bmad::NOT_A_LORD);
  m.attr("SLICE_SLAVE") = py::int_(Bmad::SLICE_SLAVE);
  m.attr("CONTROL_LORD") = py::int_(Bmad::CONTROL_LORD);
  m.attr("RAMPER_LORD") = py::int_(Bmad::RAMPER_LORD);
  // governor$ = Union of overlay and group lords.
  m.attr("GOVERNOR") = py::int_(Bmad::GOVERNOR);
  m.attr("FIELD_LORD") = py::int_(Bmad::FIELD_LORD);
  // Used with pointer_to_lord(...)
  m.attr("MULTIPOLE_SOURCE") = py::int_(Bmad::MULTIPOLE_SOURCE);
  m.attr("AUTO_APERTURE") = py::int_(Bmad::AUTO_APERTURE);
  m.attr("RECTANGULAR") = py::int_(Bmad::RECTANGULAR);
  m.attr("ELLIPTICAL") = py::int_(Bmad::ELLIPTICAL);
  m.attr("WALL3D") = py::int_(Bmad::WALL3D);
  m.attr("CUSTOM_APERTURE") = py::int_(Bmad::CUSTOM_APERTURE);
  m.attr("LORD_DEFINED") = py::int_(Bmad::LORD_DEFINED);
  m.attr("SOFT_EDGE_ONLY") = py::int_(Bmad::SOFT_EDGE_ONLY);
  m.attr("HARD_EDGE_ONLY") = py::int_(Bmad::HARD_EDGE_ONLY);
  m.attr("FULL") = py::int_(Bmad::FULL);
  m.attr("SAD_FULL") = py::int_(Bmad::SAD_FULL);
  m.attr("LINEAR_EDGE") = py::int_(Bmad::LINEAR_EDGE);
  m.attr("BASIC_BEND") = py::int_(Bmad::BASIC_BEND);
  m.attr("STANDING_WAVE") = py::int_(Bmad::STANDING_WAVE);
  m.attr("TRAVELING_WAVE") = py::int_(Bmad::TRAVELING_WAVE);
  m.attr("PTC_STANDARD") = py::int_(Bmad::PTC_STANDARD);
  m.attr("X_INVARIANT") = py::int_(Bmad::X_INVARIANT);
  m.attr("MULTIPOLE_SYMMETRY") = py::int_(Bmad::MULTIPOLE_SYMMETRY);
  m.attr("CONTROL_VAR") = py::int_(Bmad::CONTROL_VAR);
  m.attr("OLD_CONTROL_VAR") = py::int_(Bmad::OLD_CONTROL_VAR);
  m.attr("ALL_CONTROL_VAR") = py::int_(Bmad::ALL_CONTROL_VAR);
  m.attr("ELEC_MULTIPOLE") = py::int_(Bmad::ELEC_MULTIPOLE);
  m.attr("OK") = py::int_(Bmad::OK);
  m.attr("IN_STOP_BAND") = py::int_(Bmad::IN_STOP_BAND);
  m.attr("NON_SYMPLECTIC") = py::int_(Bmad::NON_SYMPLECTIC);
  m.attr("UNSTABLE") = py::int_(Bmad::UNSTABLE);
  m.attr("UNSTABLE_A") = py::int_(Bmad::UNSTABLE_A);
  m.attr("UNSTABLE_B") = py::int_(Bmad::UNSTABLE_B);
  m.attr("XFER_MAT_CALC_FAILURE") = py::int_(Bmad::XFER_MAT_CALC_FAILURE);
  m.attr("TWISS_PROPAGATE_FAILURE") = py::int_(Bmad::TWISS_PROPAGATE_FAILURE);
  m.attr("NO_CLOSED_ORBIT") = py::int_(Bmad::NO_CLOSED_ORBIT);
  m.attr("NO_COMPLETE_ORBIT") = py::int_(Bmad::NO_COMPLETE_ORBIT);
  m.attr("INCLUDE_KICKS") = py::int_(Bmad::INCLUDE_KICKS);
  m.attr("SHORT") = py::int_(Bmad::SHORT);
  m.attr("USER_SET") = py::int_(Bmad::USER_SET);
  m.attr("FIRST_PASS") = py::int_(Bmad::FIRST_PASS);
  m.attr("HIGHLAND") = py::int_(Bmad::HIGHLAND);
  m.attr("LYNCH_DAHL") = py::int_(Bmad::LYNCH_DAHL);
  m.attr("INCOHERENT") = py::int_(Bmad::INCOHERENT);
  m.attr("COHERENT") = py::int_(Bmad::COHERENT);
  m.attr("ASCII") = py::int_(Bmad::ASCII);
  m.attr("BINARY") = py::int_(Bmad::BINARY);
  m.attr("HDF5") = py::int_(Bmad::HDF5);
  m.attr("ONE_FILE") = py::int_(Bmad::ONE_FILE);
  // For testing purposes.
  m.attr("OLD_ASCII") = py::int_(Bmad::OLD_ASCII);
  m.attr("NUM_ELE_ATTRIB") = py::int_(Bmad::NUM_ELE_ATTRIB);
  m.attr("OFF") = py::int_(Bmad::OFF);
  m.attr("ON") = py::int_(Bmad::ON);
  m.attr("SAVE_STATE") = py::int_(Bmad::SAVE_STATE);
  m.attr("RESTORE_STATE") = py::int_(Bmad::RESTORE_STATE);
  m.attr("OFF_AND_SAVE") = py::int_(Bmad::OFF_AND_SAVE);
  m.attr("HORIZONTALLY_PURE") = py::int_(Bmad::HORIZONTALLY_PURE);
  m.attr("VERTICALLY_PURE") = py::int_(Bmad::VERTICALLY_PURE);
  m.attr("ONE_DIM") = py::int_(Bmad::ONE_DIM);
  m.attr("STEADY_STATE_3D") = py::int_(Bmad::STEADY_STATE_3D);
  m.attr("SLICE") = py::int_(Bmad::SLICE);
  m.attr("FFT_3D") = py::int_(Bmad::FFT_3D);
  m.attr("CATHODE_FFT_3D") = py::int_(Bmad::CATHODE_FFT_3D);
  m.attr("MAGNETIC") = py::int_(Bmad::MAGNETIC);
  m.attr("ELECTRIC") = py::int_(Bmad::ELECTRIC);
  m.attr("MIXED") = py::int_(Bmad::MIXED);
  m.attr("BRAGG_DIFFRACTED") = py::int_(Bmad::BRAGG_DIFFRACTED);
  m.attr("FORWARD_DIFFRACTED") = py::int_(Bmad::FORWARD_DIFFRACTED);
  m.attr("UNDIFFRACTED") = py::int_(Bmad::UNDIFFRACTED);
  m.attr("REFLECTION") = py::int_(Bmad::REFLECTION);
  m.attr("TRANSMISSION") = py::int_(Bmad::TRANSMISSION);
  m.attr("ANCHOR_BEGINNING") = py::int_(Bmad::ANCHOR_BEGINNING);
  m.attr("ANCHOR_CENTER") = py::int_(Bmad::ANCHOR_CENTER);
  m.attr("ANCHOR_END") = py::int_(Bmad::ANCHOR_END);
  m.attr("NONE_PT") = py::int_(Bmad::NONE_PT);
  m.attr("ENTRANCE_END") = py::int_(Bmad::ENTRANCE_END);
  m.attr("EXIT_END") = py::int_(Bmad::EXIT_END);
  m.attr("BOTH_ENDS") = py::int_(Bmad::BOTH_ENDS);
  m.attr("NO_END") = py::int_(Bmad::NO_END);
  m.attr("NO_APERTURE") = py::int_(Bmad::NO_APERTURE);
  m.attr("NOWHERE") = py::int_(Bmad::NOWHERE);
  m.attr("CONTINUOUS") = py::int_(Bmad::CONTINUOUS);
  m.attr("SURFACE") = py::int_(Bmad::SURFACE);
  m.attr("WALL_TRANSITION") = py::int_(Bmad::WALL_TRANSITION);
  m.attr("UPSTREAM_END") = py::int_(Bmad::UPSTREAM_END);
  m.attr("DOWNSTREAM_END") = py::int_(Bmad::DOWNSTREAM_END);
  m.attr("INSIDE") = py::int_(Bmad::INSIDE);
  m.attr("CENTER_PT") = py::int_(Bmad::CENTER_PT);
  m.attr("START_END") = py::int_(Bmad::START_END);
  // Must be different from upstream_end$, downstream_end$
  m.attr("FIRST_TRACK_EDGE") = py::int_(Bmad::FIRST_TRACK_EDGE);
  m.attr("SECOND_TRACK_EDGE") = py::int_(Bmad::SECOND_TRACK_EDGE);
  m.attr("IN_BETWEEN") = py::int_(Bmad::IN_BETWEEN);
  m.attr("NORMAL") = py::int_(Bmad::NORMAL);
  m.attr("CLEAR") = py::int_(Bmad::CLEAR);
  m.attr("OPAQUE") = py::int_(Bmad::OPAQUE);
  m.attr("WALL_START") = py::int_(Bmad::WALL_START);
  m.attr("WALL_END") = py::int_(Bmad::WALL_END);
  m.attr("ABSOLUTE") = py::int_(Bmad::ABSOLUTE);
  m.attr("RELATIVE") = py::int_(Bmad::RELATIVE);
  m.attr("SHIFTED_TO_RELATIVE") = py::int_(Bmad::SHIFTED_TO_RELATIVE);
  m.attr("CHAMBER_WALL") = py::int_(Bmad::CHAMBER_WALL);
  m.attr("MASK_PLATE") = py::int_(Bmad::MASK_PLATE);
  m.attr("X_PLANE") = py::int_(Bmad::X_PLANE);
  m.attr("Y_PLANE") = py::int_(Bmad::Y_PLANE);
  m.attr("Z_PLANE") = py::int_(Bmad::Z_PLANE);
  m.attr("N_PLANE") = py::int_(Bmad::N_PLANE);
  m.attr("S_PLANE") = py::int_(Bmad::S_PLANE);
  m.attr("MOVING_FORWARD") = py::int_(Bmad::MOVING_FORWARD);
  // EG: before cathode emission. Conforms to OpenPMD standard.
  m.attr("PRE_BORN") = py::int_(Bmad::PRE_BORN);
  // Conforms to OpenPMD standard.
  m.attr("ALIVE") = py::int_(Bmad::ALIVE);
  m.attr("LOST") = py::int_(Bmad::LOST);
  m.attr("LOST_NEG_X") = py::int_(Bmad::LOST_NEG_X);
  m.attr("LOST_POS_X") = py::int_(Bmad::LOST_POS_X);
  m.attr("LOST_NEG_Y") = py::int_(Bmad::LOST_NEG_Y);
  m.attr("LOST_POS_Y") = py::int_(Bmad::LOST_POS_Y);
  m.attr("LOST_Z") = py::int_(Bmad::LOST_Z);
  // Particle "turned around" when not tracking with time_runge_kutta.
  m.attr("LOST_PZ") = py::int_(Bmad::LOST_PZ);
  // old names.
  m.attr("LOST_NEG_X_APERTURE") = py::int_(Bmad::LOST_NEG_X_APERTURE);
  m.attr("LOST_POS_X_APERTURE") = py::int_(Bmad::LOST_POS_X_APERTURE);
  m.attr("LOST_NEG_Y_APERTURE") = py::int_(Bmad::LOST_NEG_Y_APERTURE);
  m.attr("LOST_POS_Y_APERTURE") = py::int_(Bmad::LOST_POS_Y_APERTURE);
  m.attr("LOST_Z_APERTURE") = py::int_(Bmad::LOST_Z_APERTURE);
  // Particle "turned around" when not tracking with time_runge_kutta.
  m.attr("LOST_PZ_APERTURE") = py::int_(Bmad::LOST_PZ_APERTURE);
  m.attr("NO_MISALIGNMENT") = py::float_(Bmad::NO_MISALIGNMENT);
  m.attr("X_POLARIZATION") = py::int_(Bmad::X_POLARIZATION);
  m.attr("Y_POLARIZATION") = py::int_(Bmad::Y_POLARIZATION);
  m.attr("XY") = py::int_(Bmad::XY);
  m.attr("LEADING") = py::int_(Bmad::LEADING);
  m.attr("TRAILING") = py::int_(Bmad::TRAILING);
  m.attr("X_LEADING") = py::int_(Bmad::X_LEADING);
  m.attr("Y_LEADING") = py::int_(Bmad::Y_LEADING);
  m.attr("X_TRAILING") = py::int_(Bmad::X_TRAILING);
  m.attr("Y_TRAILING") = py::int_(Bmad::Y_TRAILING);
  m.attr("FAMILY_Y") = py::int_(Bmad::FAMILY_Y);
  m.attr("FAMILY_X") = py::int_(Bmad::FAMILY_X);
  m.attr("FAMILY_QU") = py::int_(Bmad::FAMILY_QU);
  m.attr("FAMILY_SQ") = py::int_(Bmad::FAMILY_SQ);
  m.attr("HYPER_Y") = py::int_(Bmad::HYPER_Y);
  m.attr("HYPER_XY") = py::int_(Bmad::HYPER_XY);
  m.attr("HYPER_X") = py::int_(Bmad::HYPER_X);
  m.attr("SUPER_OK") = py::int_(Bmad::SUPER_OK);
  m.attr("STALE") = py::int_(Bmad::STALE);
  m.attr("ATTRIBUTE_GROUP") = py::int_(Bmad::ATTRIBUTE_GROUP);
  m.attr("CONTROL_GROUP") = py::int_(Bmad::CONTROL_GROUP);
  m.attr("FLOOR_POSITION_GROUP") = py::int_(Bmad::FLOOR_POSITION_GROUP);
  m.attr("S_POSITION_GROUP") = py::int_(Bmad::S_POSITION_GROUP);
  m.attr("REF_ENERGY_GROUP") = py::int_(Bmad::REF_ENERGY_GROUP);
  m.attr("MAT6_GROUP") = py::int_(Bmad::MAT6_GROUP);
  m.attr("RAD_INT_GROUP") = py::int_(Bmad::RAD_INT_GROUP);
  m.attr("ALL_GROUPS") = py::int_(Bmad::ALL_GROUPS);
  m.attr("S_AND_FLOOR_POSITION_GROUP") =
      py::int_(Bmad::S_AND_FLOOR_POSITION_GROUP);
  m.attr("POLARIZED") = py::int_(Bmad::POLARIZED);
  m.attr("UNPOLARIZED") = py::int_(Bmad::UNPOLARIZED);
  m.attr("CUBIC") = py::int_(Bmad::CUBIC);
  m.attr("OPAL") = py::int_(Bmad::OPAL);
  m.attr("IMPACTT") = py::int_(Bmad::IMPACTT);
  m.attr("DRIFT") = py::int_(Bmad::DRIFT);
  m.attr("SBEND") = py::int_(Bmad::SBEND);
  m.attr("QUADRUPOLE") = py::int_(Bmad::QUADRUPOLE);
  m.attr("GROUP") = py::int_(Bmad::GROUP);
  m.attr("SEXTUPOLE") = py::int_(Bmad::SEXTUPOLE);
  m.attr("OVERLAY") = py::int_(Bmad::OVERLAY);
  m.attr("CUSTOM") = py::int_(Bmad::CUSTOM);
  m.attr("TAYLOR") = py::int_(Bmad::TAYLOR);
  m.attr("RFCAVITY") = py::int_(Bmad::RFCAVITY);
  m.attr("ELSEPARATOR") = py::int_(Bmad::ELSEPARATOR);
  m.attr("BEAMBEAM") = py::int_(Bmad::BEAMBEAM);
  m.attr("WIGGLER") = py::int_(Bmad::WIGGLER);
  m.attr("SOL_QUAD") = py::int_(Bmad::SOL_QUAD);
  m.attr("MARKER") = py::int_(Bmad::MARKER);
  m.attr("KICKER") = py::int_(Bmad::KICKER);
  m.attr("HYBRID") = py::int_(Bmad::HYBRID);
  m.attr("OCTUPOLE") = py::int_(Bmad::OCTUPOLE);
  m.attr("RBEND") = py::int_(Bmad::RBEND);
  m.attr("MULTIPOLE") = py::int_(Bmad::MULTIPOLE);
  m.attr("DEF_BMAD_COM") = py::int_(Bmad::DEF_BMAD_COM);
  m.attr("DEF_MAD_BEAM") = py::int_(Bmad::DEF_MAD_BEAM);
  m.attr("AB_MULTIPOLE") = py::int_(Bmad::AB_MULTIPOLE);
  m.attr("SOLENOID") = py::int_(Bmad::SOLENOID);
  m.attr("PATCH") = py::int_(Bmad::PATCH);
  m.attr("LCAVITY") = py::int_(Bmad::LCAVITY);
  m.attr("DEF_PARAMETER") = py::int_(Bmad::DEF_PARAMETER);
  m.attr("NULL_ELE") = py::int_(Bmad::NULL_ELE);
  m.attr("BEGINNING_ELE") = py::int_(Bmad::BEGINNING_ELE);
  m.attr("DEF_LINE") = py::int_(Bmad::DEF_LINE);
  m.attr("MATCH") = py::int_(Bmad::MATCH);
  m.attr("MONITOR") = py::int_(Bmad::MONITOR);
  m.attr("INSTRUMENT") = py::int_(Bmad::INSTRUMENT);
  m.attr("HKICKER") = py::int_(Bmad::HKICKER);
  m.attr("VKICKER") = py::int_(Bmad::VKICKER);
  m.attr("RCOLLIMATOR") = py::int_(Bmad::RCOLLIMATOR);
  m.attr("ECOLLIMATOR") = py::int_(Bmad::ECOLLIMATOR);
  m.attr("GIRDER") = py::int_(Bmad::GIRDER);
  m.attr("CONVERTER") = py::int_(Bmad::CONVERTER);
  m.attr("DEF_PARTICLE_START") = py::int_(Bmad::DEF_PARTICLE_START);
  m.attr("PHOTON_FORK") = py::int_(Bmad::PHOTON_FORK);
  m.attr("FORK") = py::int_(Bmad::FORK);
  m.attr("MIRROR") = py::int_(Bmad::MIRROR);
  m.attr("CRYSTAL") = py::int_(Bmad::CRYSTAL);
  m.attr("PIPE") = py::int_(Bmad::PIPE);
  m.attr("CAPILLARY") = py::int_(Bmad::CAPILLARY);
  m.attr("MULTILAYER_MIRROR") = py::int_(Bmad::MULTILAYER_MIRROR);
  m.attr("E_GUN") = py::int_(Bmad::E_GUN);
  m.attr("EM_FIELD") = py::int_(Bmad::EM_FIELD);
  m.attr("FLOOR_SHIFT") = py::int_(Bmad::FLOOR_SHIFT);
  m.attr("FIDUCIAL") = py::int_(Bmad::FIDUCIAL);
  m.attr("UNDULATOR") = py::int_(Bmad::UNDULATOR);
  m.attr("DIFFRACTION_PLATE") = py::int_(Bmad::DIFFRACTION_PLATE);
  m.attr("PHOTON_INIT") = py::int_(Bmad::PHOTON_INIT);
  m.attr("SAMPLE") = py::int_(Bmad::SAMPLE);
  m.attr("DETECTOR") = py::int_(Bmad::DETECTOR);
  m.attr("SAD_MULT") = py::int_(Bmad::SAD_MULT);
  m.attr("MASK") = py::int_(Bmad::MASK);
  m.attr("AC_KICKER") = py::int_(Bmad::AC_KICKER);
  m.attr("LENS") = py::int_(Bmad::LENS);
  m.attr("DEF_SPACE_CHARGE_COM") = py::int_(Bmad::DEF_SPACE_CHARGE_COM);
  m.attr("CRAB_CAVITY") = py::int_(Bmad::CRAB_CAVITY);
  m.attr("RAMPER") = py::int_(Bmad::RAMPER);
  m.attr("DEF_PTC_COM") = py::int_(Bmad::DEF_PTC_COM);
  m.attr("RF_BEND") = py::int_(Bmad::RF_BEND);
  m.attr("GKICKER") = py::int_(Bmad::GKICKER);
  m.attr("FOIL") = py::int_(Bmad::FOIL);
  m.attr("THICK_MULTIPOLE") = py::int_(Bmad::THICK_MULTIPOLE);
  m.attr("PICKUP") = py::int_(Bmad::PICKUP);
  m.attr("FEEDBACK") = py::int_(Bmad::FEEDBACK);
  m.attr("FIXER") = py::int_(Bmad::FIXER);
  m.attr("N_KEY") = py::int_(Bmad::N_KEY);
  m.attr("STANDARD") = py::int_(Bmad::STANDARD);
  m.attr("MATCH_TWISS") = py::int_(Bmad::MATCH_TWISS);
  m.attr("IDENTITY") = py::int_(Bmad::IDENTITY);
  m.attr("PHASE_TROMBONE") = py::int_(Bmad::PHASE_TROMBONE);
  m.attr("MATCH_ORBIT") = py::int_(Bmad::MATCH_ORBIT);
  m.attr("ZERO") = py::int_(Bmad::ZERO);
  m.attr("VAL1") = py::int_(Bmad::VAL1);
  m.attr("VAL2") = py::int_(Bmad::VAL2);
  m.attr("VAL3") = py::int_(Bmad::VAL3);
  m.attr("VAL4") = py::int_(Bmad::VAL4);
  m.attr("VAL5") = py::int_(Bmad::VAL5);
  m.attr("VAL6") = py::int_(Bmad::VAL6);
  m.attr("VAL7") = py::int_(Bmad::VAL7);
  m.attr("VAL8") = py::int_(Bmad::VAL8);
  m.attr("VAL9") = py::int_(Bmad::VAL9);
  m.attr("VAL10") = py::int_(Bmad::VAL10);
  m.attr("VAL11") = py::int_(Bmad::VAL11);
  m.attr("VAL12") = py::int_(Bmad::VAL12);
  m.attr("BETA_A0") = py::int_(Bmad::BETA_A0);
  m.attr("ALPHA_A0") = py::int_(Bmad::ALPHA_A0);
  m.attr("BETA_B0") = py::int_(Bmad::BETA_B0);
  m.attr("ALPHA_B0") = py::int_(Bmad::ALPHA_B0);
  m.attr("BETA_A1") = py::int_(Bmad::BETA_A1);
  m.attr("ALPHA_A1") = py::int_(Bmad::ALPHA_A1);
  m.attr("BETA_B1") = py::int_(Bmad::BETA_B1);
  m.attr("ALPHA_B1") = py::int_(Bmad::ALPHA_B1);
  m.attr("DPHI_A") = py::int_(Bmad::DPHI_A);
  m.attr("DPHI_B") = py::int_(Bmad::DPHI_B);
  m.attr("ETA_X0") = py::int_(Bmad::ETA_X0);
  m.attr("ETAP_X0") = py::int_(Bmad::ETAP_X0);
  m.attr("ETA_Y0") = py::int_(Bmad::ETA_Y0);
  m.attr("ETAP_Y0") = py::int_(Bmad::ETAP_Y0);
  m.attr("ETA_X1") = py::int_(Bmad::ETA_X1);
  m.attr("ETAP_X1") = py::int_(Bmad::ETAP_X1);
  m.attr("ETA_Y1") = py::int_(Bmad::ETA_Y1);
  m.attr("ETAP_Y1") = py::int_(Bmad::ETAP_Y1);
  m.attr("C11_MAT0") = py::int_(Bmad::C11_MAT0);
  m.attr("C12_MAT0") = py::int_(Bmad::C12_MAT0);
  m.attr("C21_MAT0") = py::int_(Bmad::C21_MAT0);
  m.attr("C22_MAT0") = py::int_(Bmad::C22_MAT0);
  m.attr("MODE_FLIP0") = py::int_(Bmad::MODE_FLIP0);
  m.attr("C11_MAT1") = py::int_(Bmad::C11_MAT1);
  m.attr("C12_MAT1") = py::int_(Bmad::C12_MAT1);
  m.attr("C21_MAT1") = py::int_(Bmad::C21_MAT1);
  m.attr("C22_MAT1") = py::int_(Bmad::C22_MAT1);
  m.attr("MODE_FLIP1") = py::int_(Bmad::MODE_FLIP1);
  m.attr("X0") = py::int_(Bmad::X0);
  m.attr("PX0") = py::int_(Bmad::PX0);
  m.attr("Y0") = py::int_(Bmad::Y0);
  m.attr("PY0") = py::int_(Bmad::PY0);
  m.attr("Z0") = py::int_(Bmad::Z0);
  m.attr("PZ0") = py::int_(Bmad::PZ0);
  m.attr("X1") = py::int_(Bmad::X1);
  m.attr("PX1") = py::int_(Bmad::PX1);
  m.attr("Y1") = py::int_(Bmad::Y1);
  m.attr("PY1") = py::int_(Bmad::PY1);
  m.attr("Z1") = py::int_(Bmad::Z1);
  m.attr("PZ1") = py::int_(Bmad::PZ1);
  m.attr("MATRIX") = py::int_(Bmad::MATRIX);
  m.attr("KICK0") = py::int_(Bmad::KICK0);
  m.attr("RECALC") = py::int_(Bmad::RECALC);
  m.attr("DELTA_TIME") = py::int_(Bmad::DELTA_TIME);
  m.attr("X") = py::int_(Bmad::X);
  m.attr("PX") = py::int_(Bmad::PX);
  m.attr("Y") = py::int_(Bmad::Y);
  m.attr("PY") = py::int_(Bmad::PY);
  m.attr("Z") = py::int_(Bmad::Z);
  m.attr("PZ") = py::int_(Bmad::PZ);
  m.attr("T") = py::int_(Bmad::T);
  m.attr("FIELD_X") = py::int_(Bmad::FIELD_X);
  m.attr("FIELD_Y") = py::int_(Bmad::FIELD_Y);
  m.attr("PHASE_X") = py::int_(Bmad::PHASE_X);
  m.attr("PHASE_Y") = py::int_(Bmad::PHASE_Y);
  m.attr("E_PHOTON") = py::int_(Bmad::E_PHOTON);
  m.attr("E1") = py::int_(Bmad::E1);
  m.attr("E2") = py::int_(Bmad::E2);
  m.attr("FINT") = py::int_(Bmad::FINT);
  m.attr("FINTX") = py::int_(Bmad::FINTX);
  m.attr("HGAP") = py::int_(Bmad::HGAP);
  m.attr("HGAPX") = py::int_(Bmad::HGAPX);
  m.attr("H1") = py::int_(Bmad::H1);
  m.attr("H2") = py::int_(Bmad::H2);
  m.attr("SPIN_X_STORED") = py::int_(Bmad::SPIN_X_STORED);
  m.attr("SPIN_Y_STORED") = py::int_(Bmad::SPIN_Y_STORED);
  m.attr("SPIN_Z_STORED") = py::int_(Bmad::SPIN_Z_STORED);
  m.attr("X_STORED") = py::int_(Bmad::X_STORED);
  m.attr("PX_STORED") = py::int_(Bmad::PX_STORED);
  m.attr("Y_STORED") = py::int_(Bmad::Y_STORED);
  m.attr("PY_STORED") = py::int_(Bmad::PY_STORED);
  m.attr("Z_STORED") = py::int_(Bmad::Z_STORED);
  m.attr("PZ_STORED") = py::int_(Bmad::PZ_STORED);
  m.attr("BETA_A_STORED") = py::int_(Bmad::BETA_A_STORED);
  m.attr("ALPHA_A_STORED") = py::int_(Bmad::ALPHA_A_STORED);
  m.attr("BETA_B_STORED") = py::int_(Bmad::BETA_B_STORED);
  m.attr("ALPHA_B_STORED") = py::int_(Bmad::ALPHA_B_STORED);
  m.attr("PHI_A_STORED") = py::int_(Bmad::PHI_A_STORED);
  m.attr("PHI_B_STORED") = py::int_(Bmad::PHI_B_STORED);
  m.attr("MODE_FLIP_STORED") = py::int_(Bmad::MODE_FLIP_STORED);
  m.attr("ETA_X_STORED") = py::int_(Bmad::ETA_X_STORED);
  m.attr("ETAP_X_STORED") = py::int_(Bmad::ETAP_X_STORED);
  m.attr("ETA_Y_STORED") = py::int_(Bmad::ETA_Y_STORED);
  m.attr("ETAP_Y_STORED") = py::int_(Bmad::ETAP_Y_STORED);
  m.attr("CMAT_11_STORED") = py::int_(Bmad::CMAT_11_STORED);
  m.attr("CMAT_12_STORED") = py::int_(Bmad::CMAT_12_STORED);
  m.attr("CMAT_21_STORED") = py::int_(Bmad::CMAT_21_STORED);
  m.attr("CMAT_22_STORED") = py::int_(Bmad::CMAT_22_STORED);
  m.attr("DBETA_DPZ_A_STORED") = py::int_(Bmad::DBETA_DPZ_A_STORED);
  m.attr("DBETA_DPZ_B_STORED") = py::int_(Bmad::DBETA_DPZ_B_STORED);
  m.attr("DALPHA_DPZ_A_STORED") = py::int_(Bmad::DALPHA_DPZ_A_STORED);
  m.attr("DALPHA_DPZ_B_STORED") = py::int_(Bmad::DALPHA_DPZ_B_STORED);
  m.attr("DETA_DPZ_X_STORED") = py::int_(Bmad::DETA_DPZ_X_STORED);
  m.attr("DETA_DPZ_Y_STORED") = py::int_(Bmad::DETA_DPZ_Y_STORED);
  m.attr("DETAP_DPZ_X_STORED") = py::int_(Bmad::DETAP_DPZ_X_STORED);
  m.attr("DETAP_DPZ_Y_STORED") = py::int_(Bmad::DETAP_DPZ_Y_STORED);
  m.attr("DCMAT_DPZ_11_STORED") = py::int_(Bmad::DCMAT_DPZ_11_STORED);
  m.attr("DCMAT_DPZ_12_STORED") = py::int_(Bmad::DCMAT_DPZ_12_STORED);
  m.attr("DCMAT_DPZ_21_STORED") = py::int_(Bmad::DCMAT_DPZ_21_STORED);
  m.attr("DCMAT_DPZ_22_STORED") = py::int_(Bmad::DCMAT_DPZ_22_STORED);
  m.attr("RADIUS") = py::int_(Bmad::RADIUS);
  m.attr("FOCAL_STRENGTH") = py::int_(Bmad::FOCAL_STRENGTH);
  // Assumed unique. Do not assign 1 to another attribute.
  m.attr("L") = py::int_(Bmad::L);
  // Important: tilt$ = roll$
  m.attr("TILT") = py::int_(Bmad::TILT);
  m.attr("ROLL") = py::int_(Bmad::ROLL);
  m.attr("N_PART") = py::int_(Bmad::N_PART);
  m.attr("INHERIT_FROM_FORK") = py::int_(Bmad::INHERIT_FROM_FORK);
  m.attr("REF_TILT") = py::int_(Bmad::REF_TILT);
  m.attr("DIRECTION") = py::int_(Bmad::DIRECTION);
  m.attr("REPETITION_FREQUENCY") = py::int_(Bmad::REPETITION_FREQUENCY);
  m.attr("DETA_DS_MASTER") = py::int_(Bmad::DETA_DS_MASTER);
  m.attr("KICK") = py::int_(Bmad::KICK);
  m.attr("X_GAIN_ERR") = py::int_(Bmad::X_GAIN_ERR);
  m.attr("TAYLOR_ORDER") = py::int_(Bmad::TAYLOR_ORDER);
  m.attr("R_SOLENOID") = py::int_(Bmad::R_SOLENOID);
  m.attr("FINAL_CHARGE") = py::int_(Bmad::FINAL_CHARGE);
  m.attr("K1") = py::int_(Bmad::K1);
  m.attr("KX") = py::int_(Bmad::KX);
  m.attr("HARMON") = py::int_(Bmad::HARMON);
  m.attr("H_DISPLACE") = py::int_(Bmad::H_DISPLACE);
  m.attr("Y_GAIN_ERR") = py::int_(Bmad::Y_GAIN_ERR);
  m.attr("S_TWISS_REF") = py::int_(Bmad::S_TWISS_REF);
  m.attr("CRITICAL_ANGLE_FACTOR") = py::int_(Bmad::CRITICAL_ANGLE_FACTOR);
  m.attr("TILT_CORR") = py::int_(Bmad::TILT_CORR);
  m.attr("REF_COORDS") = py::int_(Bmad::REF_COORDS);
  m.attr("DT_MAX") = py::int_(Bmad::DT_MAX);
  m.attr("IX_FIXER") = py::int_(Bmad::IX_FIXER);
  m.attr("GRAZE_ANGLE") = py::int_(Bmad::GRAZE_ANGLE);
  m.attr("K2") = py::int_(Bmad::K2);
  m.attr("B_MAX") = py::int_(Bmad::B_MAX);
  m.attr("V_DISPLACE") = py::int_(Bmad::V_DISPLACE);
  m.attr("GRADIENT_TOT") = py::int_(Bmad::GRADIENT_TOT);
  m.attr("HARMON_MASTER") = py::int_(Bmad::HARMON_MASTER);
  m.attr("FLEXIBLE") = py::int_(Bmad::FLEXIBLE);
  m.attr("CRUNCH") = py::int_(Bmad::CRUNCH);
  m.attr("REF_ORBIT_FOLLOWS") = py::int_(Bmad::REF_ORBIT_FOLLOWS);
  m.attr("PC_OUT_MIN") = py::int_(Bmad::PC_OUT_MIN);
  m.attr("GRADIENT") = py::int_(Bmad::GRADIENT);
  m.attr("K3") = py::int_(Bmad::K3);
  m.attr("NOISE") = py::int_(Bmad::NOISE);
  m.attr("NEW_BRANCH") = py::int_(Bmad::NEW_BRANCH);
  m.attr("IX_BRANCH") = py::int_(Bmad::IX_BRANCH);
  m.attr("G_MAX") = py::int_(Bmad::G_MAX);
  m.attr("G") = py::int_(Bmad::G);
  m.attr("SYMMETRY") = py::int_(Bmad::SYMMETRY);
  m.attr("FIELD_SCALE_FACTOR") = py::int_(Bmad::FIELD_SCALE_FACTOR);
  m.attr("PC_OUT_MAX") = py::int_(Bmad::PC_OUT_MAX);
  m.attr("DG") = py::int_(Bmad::DG);
  m.attr("BBI_CONST") = py::int_(Bmad::BBI_CONST);
  m.attr("OSC_AMPLITUDE") = py::int_(Bmad::OSC_AMPLITUDE);
  m.attr("IX_TO_BRANCH") = py::int_(Bmad::IX_TO_BRANCH);
  m.attr("ANGLE_OUT_MAX") = py::int_(Bmad::ANGLE_OUT_MAX);
  m.attr("GRADIENT_ERR") = py::int_(Bmad::GRADIENT_ERR);
  m.attr("CRITICAL_ANGLE") = py::int_(Bmad::CRITICAL_ANGLE);
  m.attr("BRAGG_ANGLE_IN") = py::int_(Bmad::BRAGG_ANGLE_IN);
  m.attr("SPIN_DN_DPZ_X") = py::int_(Bmad::SPIN_DN_DPZ_X);
  m.attr("DELTA_E_REF") = py::int_(Bmad::DELTA_E_REF);
  m.attr("INTERPOLATION") = py::int_(Bmad::INTERPOLATION);
  m.attr("BRAGG_ANGLE_OUT") = py::int_(Bmad::BRAGG_ANGLE_OUT);
  m.attr("K1X") = py::int_(Bmad::K1X);
  m.attr("SPIN_DN_DPZ_Y") = py::int_(Bmad::SPIN_DN_DPZ_Y);
  m.attr("CHARGE") = py::int_(Bmad::CHARGE);
  m.attr("X_GAIN_CALIB") = py::int_(Bmad::X_GAIN_CALIB);
  m.attr("IX_TO_ELEMENT") = py::int_(Bmad::IX_TO_ELEMENT);
  m.attr("VOLTAGE") = py::int_(Bmad::VOLTAGE);
  m.attr("G_TOT") = py::int_(Bmad::G_TOT);
  m.attr("RHO") = py::int_(Bmad::RHO);
  m.attr("VOLTAGE_ERR") = py::int_(Bmad::VOLTAGE_ERR);
  m.attr("BRAGG_ANGLE") = py::int_(Bmad::BRAGG_ANGLE);
  m.attr("K1Y") = py::int_(Bmad::K1Y);
  m.attr("N_PARTICLE") = py::int_(Bmad::N_PARTICLE);
  m.attr("SPIN_DN_DPZ_Z") = py::int_(Bmad::SPIN_DN_DPZ_Z);
  m.attr("FRINGE_TYPE") = py::int_(Bmad::FRINGE_TYPE);
  m.attr("DBRAGG_ANGLE_DE") = py::int_(Bmad::DBRAGG_ANGLE_DE);
  m.attr("FRINGE_AT") = py::int_(Bmad::FRINGE_AT);
  m.attr("GANG") = py::int_(Bmad::GANG);
  m.attr("DARWIN_WIDTH_SIGMA") = py::int_(Bmad::DARWIN_WIDTH_SIGMA);
  m.attr("DARWIN_WIDTH_PI") = py::int_(Bmad::DARWIN_WIDTH_PI);
  m.attr("SPIN_FRINGE_ON") = py::int_(Bmad::SPIN_FRINGE_ON);
  m.attr("PENDELLOSUNG_PERIOD_SIGMA") =
      py::int_(Bmad::PENDELLOSUNG_PERIOD_SIGMA);
  m.attr("SIG_X") = py::int_(Bmad::SIG_X);
  m.attr("EXACT_MULTIPOLES") = py::int_(Bmad::EXACT_MULTIPOLES);
  m.attr("PENDELLOSUNG_PERIOD_PI") = py::int_(Bmad::PENDELLOSUNG_PERIOD_PI);
  m.attr("SIG_Y") = py::int_(Bmad::SIG_Y);
  m.attr("GRAZE_ANGLE_IN") = py::int_(Bmad::GRAZE_ANGLE_IN);
  m.attr("R0_ELEC") = py::int_(Bmad::R0_ELEC);
  m.attr("RF_FREQUENCY") = py::int_(Bmad::RF_FREQUENCY);
  m.attr("SIG_Z") = py::int_(Bmad::SIG_Z);
  m.attr("GRAZE_ANGLE_OUT") = py::int_(Bmad::GRAZE_ANGLE_OUT);
  m.attr("R0_MAG") = py::int_(Bmad::R0_MAG);
  m.attr("RF_WAVELENGTH") = py::int_(Bmad::RF_WAVELENGTH);
  m.attr("SIG_VX") = py::int_(Bmad::SIG_VX);
  m.attr("SIG_VY") = py::int_(Bmad::SIG_VY);
  m.attr("CONSTANT_REF_ENERGY") = py::int_(Bmad::CONSTANT_REF_ENERGY);
  m.attr("KS") = py::int_(Bmad::KS);
  m.attr("SIG_E") = py::int_(Bmad::SIG_E);
  m.attr("SIG_PZ") = py::int_(Bmad::SIG_PZ);
  m.attr("AUTOSCALE_AMPLITUDE") = py::int_(Bmad::AUTOSCALE_AMPLITUDE);
  m.attr("D1_THICKNESS") = py::int_(Bmad::D1_THICKNESS);
  m.attr("DEFAULT_TRACKING_SPECIES") = py::int_(Bmad::DEFAULT_TRACKING_SPECIES);
  m.attr("AUTOSCALE_PHASE") = py::int_(Bmad::AUTOSCALE_PHASE);
  m.attr("N_SLICE") = py::int_(Bmad::N_SLICE);
  m.attr("Y_GAIN_CALIB") = py::int_(Bmad::Y_GAIN_CALIB);
  m.attr("SIG_E2") = py::int_(Bmad::SIG_E2);
  m.attr("FB1") = py::int_(Bmad::FB1);
  m.attr("POLARITY") = py::int_(Bmad::POLARITY);
  m.attr("CRUNCH_CALIB") = py::int_(Bmad::CRUNCH_CALIB);
  m.attr("ALPHA_ANGLE") = py::int_(Bmad::ALPHA_ANGLE);
  m.attr("D2_THICKNESS") = py::int_(Bmad::D2_THICKNESS);
  m.attr("BETA_A_STRONG") = py::int_(Bmad::BETA_A_STRONG);
  m.attr("BETA_A_OUT") = py::int_(Bmad::BETA_A_OUT);
  m.attr("E_LOSS") = py::int_(Bmad::E_LOSS);
  m.attr("GAP") = py::int_(Bmad::GAP);
  m.attr("SPIN_X") = py::int_(Bmad::SPIN_X);
  m.attr("E_CENTER") = py::int_(Bmad::E_CENTER);
  m.attr("SCATTER_TEST") = py::int_(Bmad::SCATTER_TEST);
  m.attr("FB2") = py::int_(Bmad::FB2);
  m.attr("X_OFFSET_CALIB") = py::int_(Bmad::X_OFFSET_CALIB);
  m.attr("V1_UNITCELL") = py::int_(Bmad::V1_UNITCELL);
  m.attr("PSI_ANGLE") = py::int_(Bmad::PSI_ANGLE);
  m.attr("CAVITY_TYPE") = py::int_(Bmad::CAVITY_TYPE);
  m.attr("BETA_B_STRONG") = py::int_(Bmad::BETA_B_STRONG);
  m.attr("BETA_B_OUT") = py::int_(Bmad::BETA_B_OUT);
  m.attr("SPIN_Y") = py::int_(Bmad::SPIN_Y);
  m.attr("E2_CENTER") = py::int_(Bmad::E2_CENTER);
  m.attr("N_PERIOD") = py::int_(Bmad::N_PERIOD);
  m.attr("EMIT_FRACTION") = py::int_(Bmad::EMIT_FRACTION);
  m.attr("X1_EDGE") = py::int_(Bmad::X1_EDGE);
  m.attr("Y_OFFSET_CALIB") = py::int_(Bmad::Y_OFFSET_CALIB);
  m.attr("V_UNITCELL") = py::int_(Bmad::V_UNITCELL);
  m.attr("V2_UNITCELL") = py::int_(Bmad::V2_UNITCELL);
  m.attr("SPIN_Z") = py::int_(Bmad::SPIN_Z);
  m.attr("L_PERIOD") = py::int_(Bmad::L_PERIOD);
  m.attr("FQ1") = py::int_(Bmad::FQ1);
  m.attr("ALPHA_A_STRONG") = py::int_(Bmad::ALPHA_A_STRONG);
  m.attr("ALPHA_A_OUT") = py::int_(Bmad::ALPHA_A_OUT);
  m.attr("E2_PROBABILITY") = py::int_(Bmad::E2_PROBABILITY);
  m.attr("PHI0_MAX") = py::int_(Bmad::PHI0_MAX);
  m.attr("X2_EDGE") = py::int_(Bmad::X2_EDGE);
  m.attr("FQ2") = py::int_(Bmad::FQ2);
  m.attr("PHI0") = py::int_(Bmad::PHI0);
  m.attr("TILT_CALIB") = py::int_(Bmad::TILT_CALIB);
  m.attr("E_CENTER_RELATIVE_TO_REF") = py::int_(Bmad::E_CENTER_RELATIVE_TO_REF);
  m.attr("Y1_EDGE") = py::int_(Bmad::Y1_EDGE);
  m.attr("ALPHA_B_STRONG") = py::int_(Bmad::ALPHA_B_STRONG);
  m.attr("ALPHA_B_OUT") = py::int_(Bmad::ALPHA_B_OUT);
  m.attr("IS_MOSAIC") = py::int_(Bmad::IS_MOSAIC);
  m.attr("PX_APERTURE_WIDTH2") = py::int_(Bmad::PX_APERTURE_WIDTH2);
  m.attr("PHI0_ERR") = py::int_(Bmad::PHI0_ERR);
  m.attr("CURRENT") = py::int_(Bmad::CURRENT);
  m.attr("MOSAIC_THICKNESS") = py::int_(Bmad::MOSAIC_THICKNESS);
  m.attr("PX_APERTURE_CENTER") = py::int_(Bmad::PX_APERTURE_CENTER);
  m.attr("ETA_X_OUT") = py::int_(Bmad::ETA_X_OUT);
  m.attr("QUAD_TILT") = py::int_(Bmad::QUAD_TILT);
  m.attr("DE_ETA_MEAS") = py::int_(Bmad::DE_ETA_MEAS);
  m.attr("SPATIAL_DISTRIBUTION") = py::int_(Bmad::SPATIAL_DISTRIBUTION);
  m.attr("Y2_EDGE") = py::int_(Bmad::Y2_EDGE);
  m.attr("SPECIES_STRONG") = py::int_(Bmad::SPECIES_STRONG);
  m.attr("ETA_Y_OUT") = py::int_(Bmad::ETA_Y_OUT);
  m.attr("MODE") = py::int_(Bmad::MODE);
  m.attr("VELOCITY_DISTRIBUTION") = py::int_(Bmad::VELOCITY_DISTRIBUTION);
  m.attr("PY_APERTURE_WIDTH2") = py::int_(Bmad::PY_APERTURE_WIDTH2);
  m.attr("PHI0_MULTIPASS") = py::int_(Bmad::PHI0_MULTIPASS);
  m.attr("N_SAMPLE") = py::int_(Bmad::N_SAMPLE);
  m.attr("ORIGIN_ELE_REF_PT") = py::int_(Bmad::ORIGIN_ELE_REF_PT);
  m.attr("MOSAIC_ANGLE_RMS_IN_PLANE") =
      py::int_(Bmad::MOSAIC_ANGLE_RMS_IN_PLANE);
  m.attr("EPS_STEP_SCALE") = py::int_(Bmad::EPS_STEP_SCALE);
  m.attr("E_TOT_STRONG") = py::int_(Bmad::E_TOT_STRONG);
  m.attr("DTHICKNESS_DX") = py::int_(Bmad::DTHICKNESS_DX);
  m.attr("BEND_TILT") = py::int_(Bmad::BEND_TILT);
  m.attr("ETAP_X_OUT") = py::int_(Bmad::ETAP_X_OUT);
  m.attr("PHI0_AUTOSCALE") = py::int_(Bmad::PHI0_AUTOSCALE);
  m.attr("DX_ORIGIN") = py::int_(Bmad::DX_ORIGIN);
  m.attr("ENERGY_DISTRIBUTION") = py::int_(Bmad::ENERGY_DISTRIBUTION);
  m.attr("X_QUAD") = py::int_(Bmad::X_QUAD);
  m.attr("DS_PHOTON_SLICE") = py::int_(Bmad::DS_PHOTON_SLICE);
  m.attr("MOSAIC_ANGLE_RMS_OUT_PLANE") =
      py::int_(Bmad::MOSAIC_ANGLE_RMS_OUT_PLANE);
  m.attr("PY_APERTURE_CENTER") = py::int_(Bmad::PY_APERTURE_CENTER);
  m.attr("X_DISPERSION_ERR") = py::int_(Bmad::X_DISPERSION_ERR);
  m.attr("L_RECTANGLE") = py::int_(Bmad::L_RECTANGLE);
  m.attr("PC_STRONG") = py::int_(Bmad::PC_STRONG);
  m.attr("ETAP_Y_OUT") = py::int_(Bmad::ETAP_Y_OUT);
  m.attr("DY_ORIGIN") = py::int_(Bmad::DY_ORIGIN);
  m.attr("Y_QUAD") = py::int_(Bmad::Y_QUAD);
  m.attr("E_FIELD_X") = py::int_(Bmad::E_FIELD_X);
  m.attr("Y_DISPERSION_ERR") = py::int_(Bmad::Y_DISPERSION_ERR);
  m.attr("Z_APERTURE_WIDTH2") = py::int_(Bmad::Z_APERTURE_WIDTH2);
  m.attr("USER_SETS_LENGTH") = py::int_(Bmad::USER_SETS_LENGTH);
  m.attr("B_FIELD_TOT") = py::int_(Bmad::B_FIELD_TOT);
  m.attr("UPSTREAM_COORD_DIR") = py::int_(Bmad::UPSTREAM_COORD_DIR);
  m.attr("DZ_ORIGIN") = py::int_(Bmad::DZ_ORIGIN);
  m.attr("MOSAIC_DIFFRACTION_NUM") = py::int_(Bmad::MOSAIC_DIFFRACTION_NUM);
  m.attr("CMAT_11") = py::int_(Bmad::CMAT_11);
  m.attr("FIELD_AUTOSCALE") = py::int_(Bmad::FIELD_AUTOSCALE);
  m.attr("L_SAGITTA") = py::int_(Bmad::L_SAGITTA);
  m.attr("E_FIELD_Y") = py::int_(Bmad::E_FIELD_Y);
  m.attr("X_DISPERSION_CALIB") = py::int_(Bmad::X_DISPERSION_CALIB);
  m.attr("Z_APERTURE_CENTER") = py::int_(Bmad::Z_APERTURE_CENTER);
  m.attr("F_FACTOR") = py::int_(Bmad::F_FACTOR);
  m.attr("CMAT_12") = py::int_(Bmad::CMAT_12);
  m.attr("DTHETA_ORIGIN") = py::int_(Bmad::DTHETA_ORIGIN);
  m.attr("B_PARAM") = py::int_(Bmad::B_PARAM);
  m.attr("L_CHORD") = py::int_(Bmad::L_CHORD);
  m.attr("DOWNSTREAM_COORD_DIR") = py::int_(Bmad::DOWNSTREAM_COORD_DIR);
  m.attr("PZ_APERTURE_WIDTH2") = py::int_(Bmad::PZ_APERTURE_WIDTH2);
  m.attr("Y_DISPERSION_CALIB") = py::int_(Bmad::Y_DISPERSION_CALIB);
  m.attr("SCALE_FIELD_TO_ONE") = py::int_(Bmad::SCALE_FIELD_TO_ONE);
  m.attr("VOLTAGE_TOT") = py::int_(Bmad::VOLTAGE_TOT);
  m.attr("SCATTER_METHOD") = py::int_(Bmad::SCATTER_METHOD);
  m.attr("CMAT_21") = py::int_(Bmad::CMAT_21);
  m.attr("L_ACTIVE") = py::int_(Bmad::L_ACTIVE);
  m.attr("DPHI_ORIGIN") = py::int_(Bmad::DPHI_ORIGIN);
  m.attr("SPLIT_ID") = py::int_(Bmad::SPLIT_ID);
  m.attr("REF_CAP_GAMMA") = py::int_(Bmad::REF_CAP_GAMMA);
  m.attr("L_SOFT_EDGE") = py::int_(Bmad::L_SOFT_EDGE);
  m.attr("TRANSVERSE_SIGMA_CUT") = py::int_(Bmad::TRANSVERSE_SIGMA_CUT);
  m.attr("PZ_APERTURE_CENTER") = py::int_(Bmad::PZ_APERTURE_CENTER);
  m.attr("MEAN_EXCITATION_ENERGY") = py::int_(Bmad::MEAN_EXCITATION_ENERGY);
  m.attr("FIDUCIAL_PT") = py::int_(Bmad::FIDUCIAL_PT);
  m.attr("CMAT_22") = py::int_(Bmad::CMAT_22);
  m.attr("DPSI_ORIGIN") = py::int_(Bmad::DPSI_ORIGIN);
  m.attr("T_OFFSET") = py::int_(Bmad::T_OFFSET);
  m.attr("DS_SLICE") = py::int_(Bmad::DS_SLICE);
  m.attr("USE_REFLECTIVITY_TABLE") = py::int_(Bmad::USE_REFLECTIVITY_TABLE);
  m.attr("INIT_NEEDED") = py::int_(Bmad::INIT_NEEDED);
  m.attr("LONGITUDINAL_MODE") = py::int_(Bmad::LONGITUDINAL_MODE);
  m.attr("ANGLE") = py::int_(Bmad::ANGLE);
  m.attr("N_CELL") = py::int_(Bmad::N_CELL);
  m.attr("MODE_FLIP") = py::int_(Bmad::MODE_FLIP);
  m.attr("CROSSING_TIME") = py::int_(Bmad::CROSSING_TIME);
  m.attr("X_KICK") = py::int_(Bmad::X_KICK);
  // Note: [x_kick$, px_kick$, ..., pz_kick$] must be in order.
  m.attr("X_PITCH") = py::int_(Bmad::X_PITCH);
  m.attr("PX_KICK") = py::int_(Bmad::PX_KICK);
  m.attr("Y_PITCH") = py::int_(Bmad::Y_PITCH);
  m.attr("Y_KICK") = py::int_(Bmad::Y_KICK);
  m.attr("X_OFFSET") = py::int_(Bmad::X_OFFSET);
  m.attr("PY_KICK") = py::int_(Bmad::PY_KICK);
  m.attr("Y_OFFSET") = py::int_(Bmad::Y_OFFSET);
  m.attr("Z_KICK") = py::int_(Bmad::Z_KICK);
  m.attr("Z_OFFSET") = py::int_(Bmad::Z_OFFSET);
  m.attr("PZ_KICK") = py::int_(Bmad::PZ_KICK);
  m.attr("HKICK") = py::int_(Bmad::HKICK);
  m.attr("D_SPACING") = py::int_(Bmad::D_SPACING);
  m.attr("X_OFFSET_MULT") = py::int_(Bmad::X_OFFSET_MULT);
  m.attr("EMITTANCE_A") = py::int_(Bmad::EMITTANCE_A);
  m.attr("CRAB_X1") = py::int_(Bmad::CRAB_X1);
  m.attr("VKICK") = py::int_(Bmad::VKICK);
  m.attr("Y_OFFSET_MULT") = py::int_(Bmad::Y_OFFSET_MULT);
  m.attr("P0C_REF_INIT") = py::int_(Bmad::P0C_REF_INIT);
  m.attr("EMITTANCE_B") = py::int_(Bmad::EMITTANCE_B);
  m.attr("CRAB_X2") = py::int_(Bmad::CRAB_X2);
  m.attr("BL_HKICK") = py::int_(Bmad::BL_HKICK);
  m.attr("E_TOT_REF_INIT") = py::int_(Bmad::E_TOT_REF_INIT);
  m.attr("EMITTANCE_Z") = py::int_(Bmad::EMITTANCE_Z);
  m.attr("CRAB_X3") = py::int_(Bmad::CRAB_X3);
  m.attr("BL_VKICK") = py::int_(Bmad::BL_VKICK);
  m.attr("CRAB_TILT") = py::int_(Bmad::CRAB_TILT);
  m.attr("BL_KICK") = py::int_(Bmad::BL_KICK);
  m.attr("B_FIELD") = py::int_(Bmad::B_FIELD);
  m.attr("E_FIELD") = py::int_(Bmad::E_FIELD);
  m.attr("HIGH_ENERGY_SPACE_CHARGE_ON") =
      py::int_(Bmad::HIGH_ENERGY_SPACE_CHARGE_ON);
  m.attr("CRAB_X4") = py::int_(Bmad::CRAB_X4);
  m.attr("N_RF_STEPS") = py::int_(Bmad::N_RF_STEPS);
  m.attr("PHOTON_TYPE") = py::int_(Bmad::PHOTON_TYPE);
  m.attr("COUPLER_PHASE") = py::int_(Bmad::COUPLER_PHASE);
  m.attr("DB_FIELD") = py::int_(Bmad::DB_FIELD);
  m.attr("CRAB_X5") = py::int_(Bmad::CRAB_X5);
  m.attr("LATTICE_TYPE") = py::int_(Bmad::LATTICE_TYPE);
  m.attr("B1_GRADIENT") = py::int_(Bmad::B1_GRADIENT);
  m.attr("E1_GRADIENT") = py::int_(Bmad::E1_GRADIENT);
  m.attr("COUPLER_ANGLE") = py::int_(Bmad::COUPLER_ANGLE);
  m.attr("LIVE_BRANCH") = py::int_(Bmad::LIVE_BRANCH);
  m.attr("B2_GRADIENT") = py::int_(Bmad::B2_GRADIENT);
  m.attr("E2_GRADIENT") = py::int_(Bmad::E2_GRADIENT);
  m.attr("COUPLER_STRENGTH") = py::int_(Bmad::COUPLER_STRENGTH);
  m.attr("GEOMETRY") = py::int_(Bmad::GEOMETRY);
  m.attr("COUPLER_AT") = py::int_(Bmad::COUPLER_AT);
  m.attr("E_TOT_OFFSET") = py::int_(Bmad::E_TOT_OFFSET);
  m.attr("PTC_CANONICAL_COORDS") = py::int_(Bmad::PTC_CANONICAL_COORDS);
  m.attr("B3_GRADIENT") = py::int_(Bmad::B3_GRADIENT);
  m.attr("E3_GRADIENT") = py::int_(Bmad::E3_GRADIENT);
  m.attr("PTC_FRINGE_GEOMETRY") = py::int_(Bmad::PTC_FRINGE_GEOMETRY);
  m.attr("E_TOT_SET") = py::int_(Bmad::E_TOT_SET);
  m.attr("BS_FIELD") = py::int_(Bmad::BS_FIELD);
  m.attr("P0C_SET") = py::int_(Bmad::P0C_SET);
  m.attr("PTC_FIELD_GEOMETRY") = py::int_(Bmad::PTC_FIELD_GEOMETRY);
  m.attr("DELTA_REF_TIME_USER_SET") = py::int_(Bmad::DELTA_REF_TIME_USER_SET);
  m.attr("DELTA_REF_TIME") = py::int_(Bmad::DELTA_REF_TIME);
  m.attr("P0C_START") = py::int_(Bmad::P0C_START);
  m.attr("E_TOT_START") = py::int_(Bmad::E_TOT_START);
  m.attr("P0C") = py::int_(Bmad::P0C);
  m.attr("E_TOT") = py::int_(Bmad::E_TOT);
  m.attr("X_PITCH_TOT") = py::int_(Bmad::X_PITCH_TOT);
  m.attr("NO_END_MARKER") = py::int_(Bmad::NO_END_MARKER);
  m.attr("Y_PITCH_TOT") = py::int_(Bmad::Y_PITCH_TOT);
  m.attr("X_OFFSET_TOT") = py::int_(Bmad::X_OFFSET_TOT);
  m.attr("Y_OFFSET_TOT") = py::int_(Bmad::Y_OFFSET_TOT);
  m.attr("Z_OFFSET_TOT") = py::int_(Bmad::Z_OFFSET_TOT);
  // Important: tilt_tot$ = roll_tot$
  m.attr("TILT_TOT") = py::int_(Bmad::TILT_TOT);
  m.attr("ROLL_TOT") = py::int_(Bmad::ROLL_TOT);
  m.attr("REF_TILT_TOT") = py::int_(Bmad::REF_TILT_TOT);
  m.attr("MULTIPASS_REF_ENERGY") = py::int_(Bmad::MULTIPASS_REF_ENERGY);
  m.attr("DISPATCH") = py::int_(Bmad::DISPATCH);
  m.attr("REF_TIME_START") = py::int_(Bmad::REF_TIME_START);
  // For Etiennes' PTC: 2, 4, 6, or 8.
  m.attr("THICKNESS") = py::int_(Bmad::THICKNESS);
  m.attr("INTEGRATOR_ORDER") = py::int_(Bmad::INTEGRATOR_ORDER);
  // Assumed unique by set_flags_for_changed_real_attribute
  m.attr("NUM_STEPS") = py::int_(Bmad::NUM_STEPS);
  // Assumed unique by set_flags_for_changed_real_attribute
  m.attr("DS_STEP") = py::int_(Bmad::DS_STEP);
  m.attr("CSR_DS_STEP") = py::int_(Bmad::CSR_DS_STEP);
  m.attr("LORD_PAD1") = py::int_(Bmad::LORD_PAD1);
  m.attr("LORD_PAD2") = py::int_(Bmad::LORD_PAD2);
  m.attr("REF_WAVELENGTH") = py::int_(Bmad::REF_WAVELENGTH);
  m.attr("X1_LIMIT") = py::int_(Bmad::X1_LIMIT);
  m.attr("X2_LIMIT") = py::int_(Bmad::X2_LIMIT);
  m.attr("Y1_LIMIT") = py::int_(Bmad::Y1_LIMIT);
  m.attr("Y2_LIMIT") = py::int_(Bmad::Y2_LIMIT);
  m.attr("CHECK_SUM") = py::int_(Bmad::CHECK_SUM);
  m.attr("DISTRIBUTION") = py::int_(Bmad::DISTRIBUTION);
  m.attr("TT") = py::int_(Bmad::TT);
  m.attr("X_KNOT") = py::int_(Bmad::X_KNOT);
  m.attr("ALIAS") = py::int_(Bmad::ALIAS);
  m.attr("MAX_FRINGE_ORDER") = py::int_(Bmad::MAX_FRINGE_ORDER);
  m.attr("ETA_X") = py::int_(Bmad::ETA_X);
  m.attr("ELECTRIC_DIPOLE_MOMENT") = py::int_(Bmad::ELECTRIC_DIPOLE_MOMENT);
  m.attr("LR_SELF_WAKE_ON") = py::int_(Bmad::LR_SELF_WAKE_ON);
  m.attr("X_REF") = py::int_(Bmad::X_REF);
  m.attr("SPECIES_OUT") = py::int_(Bmad::SPECIES_OUT);
  m.attr("Y_KNOT") = py::int_(Bmad::Y_KNOT);
  m.attr("ETA_Y") = py::int_(Bmad::ETA_Y);
  m.attr("DENSITY") = py::int_(Bmad::DENSITY);
  m.attr("LR_WAKE_FILE") = py::int_(Bmad::LR_WAKE_FILE);
  m.attr("PX_REF") = py::int_(Bmad::PX_REF);
  m.attr("ETAP_X") = py::int_(Bmad::ETAP_X);
  m.attr("SLAVE") = py::int_(Bmad::SLAVE);
  m.attr("DENSITY_USED") = py::int_(Bmad::DENSITY_USED);
  m.attr("LR_FREQ_SPREAD") = py::int_(Bmad::LR_FREQ_SPREAD);
  m.attr("Y_REF") = py::int_(Bmad::Y_REF);
  m.attr("ETAP_Y") = py::int_(Bmad::ETAP_Y);
  m.attr("AREA_DENSITY") = py::int_(Bmad::AREA_DENSITY);
  m.attr("INPUT_ELE") = py::int_(Bmad::INPUT_ELE);
  m.attr("LATTICE") = py::int_(Bmad::LATTICE);
  m.attr("PHI_A") = py::int_(Bmad::PHI_A);
  m.attr("MULTIPOLES_ON") = py::int_(Bmad::MULTIPOLES_ON);
  m.attr("PY_REF") = py::int_(Bmad::PY_REF);
  m.attr("AREA_DENSITY_USED") = py::int_(Bmad::AREA_DENSITY_USED);
  m.attr("OUTPUT_ELE") = py::int_(Bmad::OUTPUT_ELE);
  m.attr("APERTURE_TYPE") = py::int_(Bmad::APERTURE_TYPE);
  m.attr("ETA_Z") = py::int_(Bmad::ETA_Z);
  m.attr("MACHINE") = py::int_(Bmad::MACHINE);
  m.attr("TAYLOR_MAP_INCLUDES_OFFSETS") =
      py::int_(Bmad::TAYLOR_MAP_INCLUDES_OFFSETS);
  m.attr("PIXEL") = py::int_(Bmad::PIXEL);
  m.attr("P88") = py::int_(Bmad::P88);
  m.attr("RADIATION_LENGTH") = py::int_(Bmad::RADIATION_LENGTH);
  m.attr("DETA_DPZ_X") = py::int_(Bmad::DETA_DPZ_X);
  m.attr("CSR_METHOD") = py::int_(Bmad::CSR_METHOD);
  m.attr("VAR") = py::int_(Bmad::VAR);
  m.attr("Z_REF") = py::int_(Bmad::Z_REF);
  m.attr("P89") = py::int_(Bmad::P89);
  m.attr("RADIATION_LENGTH_USED") = py::int_(Bmad::RADIATION_LENGTH_USED);
  m.attr("DETA_DPZ_Y") = py::int_(Bmad::DETA_DPZ_Y);
  m.attr("PZ_REF") = py::int_(Bmad::PZ_REF);
  m.attr("SPACE_CHARGE_METHOD") = py::int_(Bmad::SPACE_CHARGE_METHOD);
  m.attr("P90") = py::int_(Bmad::P90);
  m.attr("DETAP_DPZ_X") = py::int_(Bmad::DETAP_DPZ_X);
  m.attr("MAT6_CALC_METHOD") = py::int_(Bmad::MAT6_CALC_METHOD);
  m.attr("DETAP_DPZ_Y") = py::int_(Bmad::DETAP_DPZ_Y);
  m.attr("TRACKING_METHOD") = py::int_(Bmad::TRACKING_METHOD);
  m.attr("S_LONG") = py::int_(Bmad::S_LONG);
  m.attr("REF_TIME") = py::int_(Bmad::REF_TIME);
  m.attr("PTC_INTEGRATION_TYPE") = py::int_(Bmad::PTC_INTEGRATION_TYPE);
  m.attr("SPIN_TRACKING_METHOD") = py::int_(Bmad::SPIN_TRACKING_METHOD);
  m.attr("ETA_A") = py::int_(Bmad::ETA_A);
  m.attr("APERTURE") = py::int_(Bmad::APERTURE);
  m.attr("ETAP_A") = py::int_(Bmad::ETAP_A);
  m.attr("X_LIMIT") = py::int_(Bmad::X_LIMIT);
  m.attr("ABSOLUTE_TIME_TRACKING") = py::int_(Bmad::ABSOLUTE_TIME_TRACKING);
  m.attr("ETA_B") = py::int_(Bmad::ETA_B);
  m.attr("Y_LIMIT") = py::int_(Bmad::Y_LIMIT);
  m.attr("ETAP_B") = py::int_(Bmad::ETAP_B);
  m.attr("OFFSET_MOVES_APERTURE") = py::int_(Bmad::OFFSET_MOVES_APERTURE);
  m.attr("ALPHA_A") = py::int_(Bmad::ALPHA_A);
  m.attr("REFLECTIVITY_TABLE") = py::int_(Bmad::REFLECTIVITY_TABLE);
  m.attr("ENERGY_PROBABILITY_CURVE") = py::int_(Bmad::ENERGY_PROBABILITY_CURVE);
  m.attr("EXACT_MISALIGN") = py::int_(Bmad::EXACT_MISALIGN);
  m.attr("PHYSICAL_SOURCE") = py::int_(Bmad::PHYSICAL_SOURCE);
  m.attr("SR_WAKE_FILE") = py::int_(Bmad::SR_WAKE_FILE);
  m.attr("ALPHA_B") = py::int_(Bmad::ALPHA_B);
  m.attr("TERM") = py::int_(Bmad::TERM);
  m.attr("FREQUENCIES") = py::int_(Bmad::FREQUENCIES);
  m.attr("OLD_INTEGRATOR") = py::int_(Bmad::OLD_INTEGRATOR);
  m.attr("CURVATURE") = py::int_(Bmad::CURVATURE);
  m.attr("X_POSITION") = py::int_(Bmad::X_POSITION);
  m.attr("EXACT_MODEL") = py::int_(Bmad::EXACT_MODEL);
  m.attr("SYMPLECTIFY") = py::int_(Bmad::SYMPLECTIFY);
  m.attr("Y_POSITION") = py::int_(Bmad::Y_POSITION);
  m.attr("N_SLICE_SPLINE") = py::int_(Bmad::N_SLICE_SPLINE);
  m.attr("Z_POSITION") = py::int_(Bmad::Z_POSITION);
  m.attr("AMP_VS_TIME") = py::int_(Bmad::AMP_VS_TIME);
  m.attr("IS_ON") = py::int_(Bmad::IS_ON);
  m.attr("THETA_POSITION") = py::int_(Bmad::THETA_POSITION);
  m.attr("VERTICAL_KICK") = py::int_(Bmad::VERTICAL_KICK);
  m.attr("FIELD_CALC") = py::int_(Bmad::FIELD_CALC);
  m.attr("PHI_POSITION") = py::int_(Bmad::PHI_POSITION);
  m.attr("PSI_POSITION") = py::int_(Bmad::PSI_POSITION);
  m.attr("WALL") = py::int_(Bmad::WALL);
  m.attr("APERTURE_AT") = py::int_(Bmad::APERTURE_AT);
  m.attr("BETA_A") = py::int_(Bmad::BETA_A);
  m.attr("RAN_SEED") = py::int_(Bmad::RAN_SEED);
  m.attr("ORIGIN_ELE") = py::int_(Bmad::ORIGIN_ELE);
  m.attr("BETA_B") = py::int_(Bmad::BETA_B);
  m.attr("TO_LINE") = py::int_(Bmad::TO_LINE);
  m.attr("FIELD_OVERLAPS") = py::int_(Bmad::FIELD_OVERLAPS);
  m.attr("DBETA_DPZ_A") = py::int_(Bmad::DBETA_DPZ_A);
  m.attr("FIELD_MASTER") = py::int_(Bmad::FIELD_MASTER);
  m.attr("TO_ELEMENT") = py::int_(Bmad::TO_ELEMENT);
  m.attr("DBETA_DPZ_B") = py::int_(Bmad::DBETA_DPZ_B);
  m.attr("DESCRIP") = py::int_(Bmad::DESCRIP);
  m.attr("SCALE_MULTIPOLES") = py::int_(Bmad::SCALE_MULTIPOLES);
  m.attr("DALPHA_DPZ_A") = py::int_(Bmad::DALPHA_DPZ_A);
  m.attr("SR_WAKE") = py::int_(Bmad::SR_WAKE);
  m.attr("DALPHA_DPZ_B") = py::int_(Bmad::DALPHA_DPZ_B);
  m.attr("REF_ORBIT") = py::int_(Bmad::REF_ORBIT);
  m.attr("LR_WAKE") = py::int_(Bmad::LR_WAKE);
  m.attr("PHI_B") = py::int_(Bmad::PHI_B);
  m.attr("CRYSTAL_TYPE") = py::int_(Bmad::CRYSTAL_TYPE);
  m.attr("MATERIAL_TYPE") = py::int_(Bmad::MATERIAL_TYPE);
  m.attr("TYPE") = py::int_(Bmad::TYPE);
  m.attr("REF_ORIGIN") = py::int_(Bmad::REF_ORIGIN);
  m.attr("ELE_ORIGIN") = py::int_(Bmad::ELE_ORIGIN);
  m.attr("SUPERIMPOSE") = py::int_(Bmad::SUPERIMPOSE);
  m.attr("SUPER_OFFSET") = py::int_(Bmad::SUPER_OFFSET);
  m.attr("REFERENCE") = py::int_(Bmad::REFERENCE);
  m.attr("CARTESIAN_MAP") = py::int_(Bmad::CARTESIAN_MAP);
  m.attr("CYLINDRICAL_MAP") = py::int_(Bmad::CYLINDRICAL_MAP);
  m.attr("GRID_FIELD") = py::int_(Bmad::GRID_FIELD);
  m.attr("GEN_GRAD_MAP") = py::int_(Bmad::GEN_GRAD_MAP);
  m.attr("CREATE_JUMBO_SLAVE") = py::int_(Bmad::CREATE_JUMBO_SLAVE);
  m.attr("ACCORDION_EDGE") = py::int_(Bmad::ACCORDION_EDGE);
  m.attr("START_EDGE") = py::int_(Bmad::START_EDGE);
  m.attr("END_EDGE") = py::int_(Bmad::END_EDGE);
  m.attr("S_POSITION") = py::int_(Bmad::S_POSITION);
  m.attr("REF_SPECIES") = py::int_(Bmad::REF_SPECIES);
  m.attr("PARTICLE") = py::int_(Bmad::PARTICLE);
  m.attr("WRAP_SUPERIMPOSE") = py::int_(Bmad::WRAP_SUPERIMPOSE);
  m.attr("A0") = py::int_(Bmad::A0);
  m.attr("A21") = py::int_(Bmad::A21);
  m.attr("B0") = py::int_(Bmad::B0);
  m.attr("B21") = py::int_(Bmad::B21);
  m.attr("K0L") = py::int_(Bmad::K0L);
  m.attr("K21L") = py::int_(Bmad::K21L);
  m.attr("T0") = py::int_(Bmad::T0);
  m.attr("T21") = py::int_(Bmad::T21);
  m.attr("K0SL") = py::int_(Bmad::K0SL);
  m.attr("K21SL") = py::int_(Bmad::K21SL);
  m.attr("A0_ELEC") = py::int_(Bmad::A0_ELEC);
  m.attr("A21_ELEC") = py::int_(Bmad::A21_ELEC);
  m.attr("B0_ELEC") = py::int_(Bmad::B0_ELEC);
  m.attr("B21_ELEC") = py::int_(Bmad::B21_ELEC);
  m.attr("CUSTOM_ATTRIBUTE0") = py::int_(Bmad::CUSTOM_ATTRIBUTE0);
  m.attr("CUSTOM_ATTRIBUTE_NUM") = py::int_(Bmad::CUSTOM_ATTRIBUTE_NUM);
  m.attr("NUM_ELE_ATTRIB_EXTENDED") = py::int_(Bmad::NUM_ELE_ATTRIB_EXTENDED);
  // For backwards compatibility.
  m.attr("G_ERR") = py::int_(Bmad::G_ERR);
  // For backwards compatibility
  m.attr("B_FIELD_ERR") = py::int_(Bmad::B_FIELD_ERR);
  m.attr("OPEN") = py::int_(Bmad::OPEN);
  m.attr("CLOSED") = py::int_(Bmad::CLOSED);
  m.attr("BENDS") = py::int_(Bmad::BENDS);
  m.attr("WIGGLERS") = py::int_(Bmad::WIGGLERS);
  m.attr("ALL") = py::int_(Bmad::ALL);
  m.attr("UPSTREAM") = py::int_(Bmad::UPSTREAM);
  m.attr("DOWNSTREAM") = py::int_(Bmad::DOWNSTREAM);
  m.attr("RADIANS") = py::int_(Bmad::RADIANS);
  m.attr("DEGREES") = py::int_(Bmad::DEGREES);
  m.attr("CYCLES") = py::int_(Bmad::CYCLES);
  m.attr("RADIANS_OVER_2PI") = py::int_(Bmad::RADIANS_OVER_2PI);
  m.attr("ROTATIONALLY_SYMMETRIC_RZ") =
      py::int_(Bmad::ROTATIONALLY_SYMMETRIC_RZ);
  m.attr("XYZ") = py::int_(Bmad::XYZ);
  m.attr("INVALID_NAME") = py::int_(Bmad::INVALID_NAME);
  m.attr("IS_LOGICAL") = py::int_(Bmad::IS_LOGICAL);
  m.attr("IS_INTEGER") = py::int_(Bmad::IS_INTEGER);
  m.attr("IS_REAL") = py::int_(Bmad::IS_REAL);
  m.attr("IS_SWITCH") = py::int_(Bmad::IS_SWITCH);
  m.attr("IS_STRING") = py::int_(Bmad::IS_STRING);
  m.attr("IS_STRUCT") = py::int_(Bmad::IS_STRUCT);
  m.attr("UNKNOWN") = py::int_(Bmad::UNKNOWN);
  m.attr("PATCH_PROBLEM") = py::int_(Bmad::PATCH_PROBLEM);
  m.attr("OUTSIDE") = py::int_(Bmad::OUTSIDE);
  m.attr("CANNOT_FIND") = py::int_(Bmad::CANNOT_FIND);
  m.attr("SMALL_REL_CHANGE") = py::float_(Bmad::SMALL_REL_CHANGE);
  m.attr("END_STACK") = py::int_(Bmad::END_STACK);
  m.attr("PLUS") = py::int_(Bmad::PLUS);
  m.attr("MINUS") = py::int_(Bmad::MINUS);
  m.attr("TIMES") = py::int_(Bmad::TIMES);
  m.attr("DIVIDE") = py::int_(Bmad::DIVIDE);
  m.attr("L_PARENS") = py::int_(Bmad::L_PARENS);
  m.attr("R_PARENS") = py::int_(Bmad::R_PARENS);
  m.attr("POWER") = py::int_(Bmad::POWER);
  m.attr("UNARY_MINUS") = py::int_(Bmad::UNARY_MINUS);
  m.attr("UNARY_PLUS") = py::int_(Bmad::UNARY_PLUS);
  m.attr("NO_DELIM") = py::int_(Bmad::NO_DELIM);
  m.attr("SIN") = py::int_(Bmad::SIN);
  m.attr("COS") = py::int_(Bmad::COS);
  m.attr("TAN") = py::int_(Bmad::TAN);
  m.attr("ASIN") = py::int_(Bmad::ASIN);
  m.attr("ACOS") = py::int_(Bmad::ACOS);
  m.attr("ATAN") = py::int_(Bmad::ATAN);
  m.attr("ABS") = py::int_(Bmad::ABS);
  m.attr("SQRT") = py::int_(Bmad::SQRT);
  m.attr("LOG") = py::int_(Bmad::LOG);
  m.attr("EXP") = py::int_(Bmad::EXP);
  m.attr("RAN") = py::int_(Bmad::RAN);
  m.attr("RAN_GAUSS") = py::int_(Bmad::RAN_GAUSS);
  m.attr("ATAN2") = py::int_(Bmad::ATAN2);
  m.attr("FACTORIAL") = py::int_(Bmad::FACTORIAL);
  m.attr("INT") = py::int_(Bmad::INT);
  m.attr("NINT") = py::int_(Bmad::NINT);
  m.attr("FLOOR") = py::int_(Bmad::FLOOR);
  m.attr("CEILING") = py::int_(Bmad::CEILING);
  m.attr("NUMERIC") = py::int_(Bmad::NUMERIC);
  m.attr("VARIABLE") = py::int_(Bmad::VARIABLE);
  m.attr("MASS_OF") = py::int_(Bmad::MASS_OF);
  m.attr("CHARGE_OF") = py::int_(Bmad::CHARGE_OF);
  m.attr("ANOMALOUS_MOMENT_OF") = py::int_(Bmad::ANOMALOUS_MOMENT_OF);
  m.attr("SPECIES") = py::int_(Bmad::SPECIES);
  m.attr("SPECIES_CONST") = py::int_(Bmad::SPECIES_CONST);
  m.attr("SINC") = py::int_(Bmad::SINC);
  m.attr("CONSTANT") = py::int_(Bmad::CONSTANT);
  m.attr("COMMA") = py::int_(Bmad::COMMA);
  m.attr("RMS") = py::int_(Bmad::RMS);
  m.attr("AVERAGE") = py::int_(Bmad::AVERAGE);
  m.attr("SUM") = py::int_(Bmad::SUM);
  m.attr("ARG_COUNT") = py::int_(Bmad::ARG_COUNT);
  m.attr("ANTIPARTICLE") = py::int_(Bmad::ANTIPARTICLE);
  m.attr("COT") = py::int_(Bmad::COT);
  m.attr("SEC") = py::int_(Bmad::SEC);
  m.attr("CSC") = py::int_(Bmad::CSC);
  m.attr("SIGN") = py::int_(Bmad::SIGN);
  m.attr("L_FUNC_PARENS") = py::int_(Bmad::L_FUNC_PARENS);
  m.attr("SINH") = py::int_(Bmad::SINH);
  m.attr("COSH") = py::int_(Bmad::COSH);
  m.attr("TANH") = py::int_(Bmad::TANH);
  m.attr("COTH") = py::int_(Bmad::COTH);
  m.attr("ASINH") = py::int_(Bmad::ASINH);
  m.attr("ACOSH") = py::int_(Bmad::ACOSH);
  m.attr("ATANH") = py::int_(Bmad::ATANH);
  m.attr("ACOTH") = py::int_(Bmad::ACOTH);
  m.attr("MIN") = py::int_(Bmad::MIN);
  m.attr("MAX") = py::int_(Bmad::MAX);
  m.attr("MODULO") = py::int_(Bmad::MODULO);
  m.attr("ROOT") = py::int_(Bmad::ROOT);
  m.attr("PARENS") = py::int_(Bmad::PARENS);
  m.attr("SQUARE_BRACKETS") = py::int_(Bmad::SQUARE_BRACKETS);
  m.attr("CURLY_BRACKETS") = py::int_(Bmad::CURLY_BRACKETS);
  m.attr("FUNC_PARENS") = py::int_(Bmad::FUNC_PARENS);
  m.attr("ARROW") = py::int_(Bmad::ARROW);
  m.attr("EQUAL") = py::int_(Bmad::EQUAL);
  m.attr("COLON") = py::int_(Bmad::COLON);
  m.attr("DOUBLE_COLON") = py::int_(Bmad::DOUBLE_COLON);
  m.attr("COMPOUND") = py::int_(Bmad::COMPOUND);
  m.attr("FUNCTION") = py::int_(Bmad::FUNCTION);
  m.attr("VERTICAL_BAR") = py::int_(Bmad::VERTICAL_BAR);
  m.attr("BLANK") = py::int_(Bmad::BLANK);
  m.attr("AMPERSAND") = py::int_(Bmad::AMPERSAND);

  // Enums from output_mod.f90
  // No message printed. Used to override a status level variable.
  m.attr("S_NOOUTPUT") = py::int_(Bmad::S_NOOUTPUT);
  // Information message. The routine name is not printed.
  m.attr("S_BLANK") = py::int_(Bmad::S_BLANK);
  // Informational message.
  m.attr("S_INFO") = py::int_(Bmad::S_INFO);
  // Info message (w/timestamp).
  m.attr("S_DINFO") = py::int_(Bmad::S_DINFO);
  // Successful completion.
  m.attr("S_SUCCESS") = py::int_(Bmad::S_SUCCESS);
  // Warning of a possible problem.
  m.attr("S_WARN") = py::int_(Bmad::S_WARN);
  // Warning of a possible problem (w/timestamp).
  m.attr("S_DWARN") = py::int_(Bmad::S_DWARN);
  // An error as occurred [EG: bad user input] (w/ timestamp).
  m.attr("S_ERROR") = py::int_(Bmad::S_ERROR);
  // A fatal error has occurred so that computations
  m.attr("S_FATAL") = py::int_(Bmad::S_FATAL);
  // A severe error has occurred and
  m.attr("S_ABORT") = py::int_(Bmad::S_ABORT);
  // An important message.
  m.attr("S_IMPORTANT") = py::int_(Bmad::S_IMPORTANT);

  // Enums from physical_constants.f90
  m.attr("PI") = py::float_(Bmad::PI);
  m.attr("TWOPI") = py::float_(Bmad::TWOPI);
  m.attr("FOURPI") = py::float_(Bmad::FOURPI);
  m.attr("SQRT_2") = py::float_(Bmad::SQRT_2);
  m.attr("SQRT_3") = py::float_(Bmad::SQRT_3);
  // Mass [eV]
  m.attr("M_ELECTRON") = py::float_(Bmad::M_ELECTRON);
  // Mass [eV]
  m.attr("M_PROTON") = py::float_(Bmad::M_PROTON);
  // Mass [eV]
  m.attr("M_NEUTRON") = py::float_(Bmad::M_NEUTRON);
  // Mass [eV]
  m.attr("M_MUON") = py::float_(Bmad::M_MUON);
  // Mass He3 nucleus
  m.attr("M_HELION") = py::float_(Bmad::M_HELION);
  // [GeV] FOR MAD COMPATIBILITY USE ONLY. USE M_ELECTRON INSTEAD.
  m.attr("E_MASS") = py::float_(Bmad::E_MASS);
  // [GeV] FOR MAD COMPATIBILITY USE ONLY. USE M_PROTON INSTEAD.
  m.attr("P_MASS") = py::float_(Bmad::P_MASS);
  // Mass [eV]
  m.attr("M_PION_0") = py::float_(Bmad::M_PION_0);
  // Mass [eV]
  m.attr("M_PION_CHARGED") = py::float_(Bmad::M_PION_CHARGED);
  // Mass [eV]
  m.attr("M_DEUTERON") = py::float_(Bmad::M_DEUTERON);
  // unified atomic mass unit u (or dalton) in [eV]
  m.attr("ATOMIC_MASS_UNIT") = py::float_(Bmad::ATOMIC_MASS_UNIT);
  // speed of light
  m.attr("C_LIGHT") = py::float_(Bmad::C_LIGHT);
  // classical electron radius
  m.attr("R_E") = py::float_(Bmad::R_E);
  // proton radius
  m.attr("R_P") = py::float_(Bmad::R_P);
  // electron charge [Coul]
  m.attr("E_CHARGE") = py::float_(Bmad::E_CHARGE);
  // Planck's constant [eV*sec]
  m.attr("H_PLANCK") = py::float_(Bmad::H_PLANCK);
  // h_planck/twopi [eV*sec]
  m.attr("H_BAR_PLANCK") = py::float_(Bmad::H_BAR_PLANCK);
  // Vacuum permeability 2018 CODATA.
  m.attr("MU_0_VAC") = py::float_(Bmad::MU_0_VAC);
  // e^2 / (4 pi eps_0) [m*eV]
  m.attr("CLASSICAL_RADIUS_FACTOR") = py::float_(Bmad::CLASSICAL_RADIUS_FACTOR);
  // Number / mole  (exact)
  m.attr("N_AVOGADRO") = py::float_(Bmad::N_AVOGADRO);
  m.attr("FINE_STRUCTURE_CONSTANT") = py::float_(Bmad::FINE_STRUCTURE_CONSTANT);
  m.attr("ANOMALOUS_MAG_MOMENT_ELECTRON") =
      py::float_(Bmad::ANOMALOUS_MAG_MOMENT_ELECTRON);
  m.attr("ANOMALOUS_MAG_MOMENT_PROTON") =
      py::float_(Bmad::ANOMALOUS_MAG_MOMENT_PROTON);
  // ~fine_structure_constant / twopi
  m.attr("ANOMALOUS_MAG_MOMENT_MUON") =
      py::float_(Bmad::ANOMALOUS_MAG_MOMENT_MUON);
  m.attr("ANOMALOUS_MAG_MOMENT_DEUTERON") =
      py::float_(Bmad::ANOMALOUS_MAG_MOMENT_DEUTERON);
  m.attr("ANOMALOUS_MAG_MOMENT_NEUTRON") =
      py::float_(Bmad::ANOMALOUS_MAG_MOMENT_NEUTRON);
  m.attr("ANOMALOUS_MAG_MOMENT_HE3") =
      py::float_(Bmad::ANOMALOUS_MAG_MOMENT_HE3);

  // Enums from particle_species_mod.f90
  m.attr("PION_0") = py::int_(Bmad::PION_0);
  m.attr("HELION") = py::int_(Bmad::HELION);
  m.attr("REF_PARTICLE") = py::int_(Bmad::REF_PARTICLE);
  m.attr("NEUTRON") = py::int_(Bmad::NEUTRON);
  m.attr("DEUTERON") = py::int_(Bmad::DEUTERON);
  m.attr("PION_PLUS") = py::int_(Bmad::PION_PLUS);
  m.attr("ANTIMUON") = py::int_(Bmad::ANTIMUON);
  m.attr("PROTON") = py::int_(Bmad::PROTON);
  m.attr("POSITRON") = py::int_(Bmad::POSITRON);
  m.attr("PHOTON") = py::int_(Bmad::PHOTON);
  m.attr("ELECTRON") = py::int_(Bmad::ELECTRON);
  m.attr("ANTIPROTON") = py::int_(Bmad::ANTIPROTON);
  m.attr("MUON") = py::int_(Bmad::MUON);
  m.attr("PION_MINUS") = py::int_(Bmad::PION_MINUS);
  m.attr("ANTI_DEUTERON") = py::int_(Bmad::ANTI_DEUTERON);
  m.attr("ANTI_NEUTRON") = py::int_(Bmad::ANTI_NEUTRON);
  m.attr("ANTI_REF_PARTICLE") = py::int_(Bmad::ANTI_REF_PARTICLE);
  m.attr("ANTI_HELION") = py::int_(Bmad::ANTI_HELION);
  m.attr("LB_SUBATOMIC") = py::int_(Bmad::LB_SUBATOMIC);
  m.attr("UB_SUBATOMIC") = py::int_(Bmad::UB_SUBATOMIC);
  m.attr("ANTI_ATOM") = py::int_(Bmad::ANTI_ATOM);

  // Enums from sim_utils_struct.f90
  m.attr("INT_GARBAGE") = py::int_(Bmad::INT_GARBAGE);
  m.attr("REAL_GARBAGE") = py::float_(Bmad::REAL_GARBAGE);
  m.attr("INVALID") = py::int_(Bmad::INVALID);
  m.attr("NOT_SET") = py::int_(Bmad::NOT_SET);
  m.attr("X_AXIS") = py::int_(Bmad::X_AXIS);
  m.attr("Y_AXIS") = py::int_(Bmad::Y_AXIS);
  m.attr("Z_AXIS") = py::int_(Bmad::Z_AXIS);
  m.attr("XY_AXIS") = py::int_(Bmad::XY_AXIS);
  m.attr("TRUE_") = py::float_(Bmad::TRUE_);
  m.attr("FALSE_") = py::float_(Bmad::FALSE_);
  m.attr("TRUE_INT") = py::int_(Bmad::TRUE_INT);
  m.attr("FALSE_INT") = py::int_(Bmad::FALSE_INT);
  m.attr("YES") = py::int_(Bmad::YES);
  m.attr("NO") = py::int_(Bmad::NO);
  m.attr("MAYBE") = py::int_(Bmad::MAYBE);
  m.attr("PROVISIONAL") = py::int_(Bmad::PROVISIONAL);

  // Enums from quick_plot_struct.f90
  m.attr("WHITE") = py::int_(Bmad::WHITE);
  m.attr("BLACK") = py::int_(Bmad::BLACK);
  m.attr("RED") = py::int_(Bmad::RED);
  m.attr("GREEN") = py::int_(Bmad::GREEN);
  m.attr("BLUE") = py::int_(Bmad::BLUE);
  m.attr("CYAN") = py::int_(Bmad::CYAN);
  m.attr("MAGENTA") = py::int_(Bmad::MAGENTA);
  m.attr("YELLOW") = py::int_(Bmad::YELLOW);
  m.attr("ORANGE") = py::int_(Bmad::ORANGE);
  m.attr("YELLOW_GREEN") = py::int_(Bmad::YELLOW_GREEN);
  m.attr("LIGHT_GREEN") = py::int_(Bmad::LIGHT_GREEN);
  m.attr("NAVY_BLUE") = py::int_(Bmad::NAVY_BLUE);
  m.attr("PURPLE") = py::int_(Bmad::PURPLE);
  m.attr("REDDISH_PURPLE") = py::int_(Bmad::REDDISH_PURPLE);
  m.attr("DARK_GREY") = py::int_(Bmad::DARK_GREY);
  m.attr("LIGHT_GREY") = py::int_(Bmad::LIGHT_GREY);
  m.attr("TRANSPARENT") = py::int_(Bmad::TRANSPARENT);
  m.attr("SOLID") = py::int_(Bmad::SOLID);
  m.attr("DASHED") = py::int_(Bmad::DASHED);
  m.attr("DASH_DOT") = py::int_(Bmad::DASH_DOT);
  m.attr("DOTTED") = py::int_(Bmad::DOTTED);
  m.attr("DASH_DOT3") = py::int_(Bmad::DASH_DOT3);
  m.attr("SOLID_FILL") = py::int_(Bmad::SOLID_FILL);
  m.attr("NO_FILL") = py::int_(Bmad::NO_FILL);
  m.attr("HATCHED") = py::int_(Bmad::HATCHED);
  m.attr("CROSS_HATCHED") = py::int_(Bmad::CROSS_HATCHED);
  m.attr("SQUARE_SYM") = py::int_(Bmad::SQUARE_SYM);
  m.attr("DOT_SYM") = py::int_(Bmad::DOT_SYM);
  m.attr("PLUS_SYM") = py::int_(Bmad::PLUS_SYM);
  m.attr("TIMES_SYM") = py::int_(Bmad::TIMES_SYM);
  m.attr("CIRCLE_SYM") = py::int_(Bmad::CIRCLE_SYM);
  m.attr("X_SYMBOL_SYM") = py::int_(Bmad::X_SYMBOL_SYM);
  m.attr("TRIANGLE_SYM") = py::int_(Bmad::TRIANGLE_SYM);
  m.attr("CIRCLE_PLUS_SYM") = py::int_(Bmad::CIRCLE_PLUS_SYM);
  m.attr("CIRCLE_DOT_SYM") = py::int_(Bmad::CIRCLE_DOT_SYM);
  m.attr("SQUARE_CONCAVE_SYM") = py::int_(Bmad::SQUARE_CONCAVE_SYM);
  m.attr("DIAMOND_SYM") = py::int_(Bmad::DIAMOND_SYM);
  m.attr("STAR5_SYM") = py::int_(Bmad::STAR5_SYM);
  m.attr("TRIANGLE_FILLED_SYM") = py::int_(Bmad::TRIANGLE_FILLED_SYM);
  m.attr("RED_CROSS_SYM") = py::int_(Bmad::RED_CROSS_SYM);
  m.attr("STAR_OF_DAVID_SYM") = py::int_(Bmad::STAR_OF_DAVID_SYM);
  m.attr("SQUARE_FILLED_SYM") = py::int_(Bmad::SQUARE_FILLED_SYM);
  m.attr("CIRCLE_FILLED_SYM") = py::int_(Bmad::CIRCLE_FILLED_SYM);
  m.attr("STAR5_FILLED_SYM") = py::int_(Bmad::STAR5_FILLED_SYM);
  m.attr("DFLT_DRAW") = py::int_(Bmad::DFLT_DRAW);
  m.attr("DFLT_SET") = py::int_(Bmad::DFLT_SET);
  m.attr("PRINT_PAGE_LONG_LEN") = py::float_(Bmad::PRINT_PAGE_LONG_LEN);
  m.attr("PRINT_PAGE_SHORT_LEN") = py::float_(Bmad::PRINT_PAGE_SHORT_LEN);
  m.attr("FILLED_ARROW_HEAD") = py::int_(Bmad::FILLED_ARROW_HEAD);
  m.attr("OUTLINE_ARROW_HEAD") = py::int_(Bmad::OUTLINE_ARROW_HEAD);

  // Routines
  m.def(
      "twiss_at_element",
      &Bmad::twiss_at_element,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to be averaged
start : EleStruct
    Twiss and s at start of element.
end : EleStruct
    Twiss and s at end of element.
average : EleStruct
    Average Twiss and s of element. .value(l$) -- "Effective" length which for groups and overlays are
    weighted by the control coefficient.
)""");
  py::class_<Bmad::TwissAtElement, std::unique_ptr<Bmad::TwissAtElement>>(
      m, "TwissAtElement", "Fortran routine twiss_at_element return value")
      .def_readonly("start", &Bmad::TwissAtElement::start)
      .def_readonly("end", &Bmad::TwissAtElement::end)
      .def_readonly("average", &Bmad::TwissAtElement::average)
      .def("__len__", [](const Bmad::TwissAtElement&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::TwissAtElement& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.start);
            if (i == 1)
              return py::cast(s.end);
            if (i == 2)
              return py::cast(s.average);
            return py::none();
          });
  m.def(
      "multipole_ele_to_kt",
      &Bmad::multipole_ele_to_kt,
      py::arg("ele"),
      py::arg("use_ele_tilt"),
      py::arg("pole_type") = py::none(),
      py::arg("include_kicks") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
use_ele_tilt : bool
    If True then include ele.value(tilt_tot$) in calculations. use_ele_tilt is ignored in the case of
    multipole$ elements.
ix_pole_max : int
    Index of largest nonzero pole.
knl : float
    Vector of strengths, MAD units.
tilt : float
    Vector of tilts.
pole_type : int, optional
    Type of multipole. magnetic$ (default) or electric$.
include_kicks : int, optional
    Possibilities are: no$                      -- Default. Do not include any kick components in a and b
    multipoles. include_kicks$           -- Include hkick/vkick/dg in the n = 0 components. Also included are
    quad k1, sextupole k2 and octupole k3 components.
)""");
  py::class_<Bmad::MultipoleEleToKt, std::unique_ptr<Bmad::MultipoleEleToKt>>(
      m, "MultipoleEleToKt", "Fortran routine multipole_ele_to_kt return value")
      .def_readonly("ix_pole_max", &Bmad::MultipoleEleToKt::ix_pole_max)
      .def_readonly("knl", &Bmad::MultipoleEleToKt::knl)
      .def_readonly("tilt", &Bmad::MultipoleEleToKt::tilt)
      .def("__len__", [](const Bmad::MultipoleEleToKt&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::MultipoleEleToKt& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_pole_max);
            if (i == 1)
              return py::cast(s.knl);
            if (i == 2)
              return py::cast(s.tilt);
            return py::none();
          });
  m.def(
      "attribute_bookkeeper",
      &Bmad::attribute_bookkeeper,
      py::arg("ele"),
      py::arg("force_bookkeeping") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with attributes
    This parameter is an input/output and is modified in-place. As an output: Element with self-consistant
    attributes.
force_bookkeeping : bool, optional
    If present and True then force -- Logical, optional: If present and True then force attribute bookkeeping
    to be done independent of the state of ele.bookkeeping_stat.attributes. This will also cause
    attribute_bookkeeper to assume intelligent bookkeeping.
)""");
  m.def(
      "closed_orbit_from_tracking",
      &Bmad::closed_orbit_from_tracking,
      py::arg("lat"),
      py::arg("i_dim"),
      py::arg("eps_rel") = py::none(),
      py::arg("eps_abs") = py::none(),
      py::arg("init_guess") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to track through.
closed_orb : CoordStruct
    closed orbit. This routine will allocate this array for you.
i_dim : int
    = 2,4  Transverse closed orbit at constant energy. = 6    Full closed orbit using the entire transfer 6x6
    matrix.
eps_rel : float, optional
    Relative allowed error. Default is bmad_com.rel_tol_tracking
eps_abs : float, optional
    Absolute allowed error. Default is bmad_com.abs_tol_tracking
init_guess : CoordStruct, optional
    Starting guess for the closed orbit at the start of the lattice. Set init_guess.vec(6) to the appropriate
    value of pz when calculating off-energy orbits. If not present then the origin will be used.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::ClosedOrbitFromTracking,
      std::unique_ptr<Bmad::ClosedOrbitFromTracking>>(
      m,
      "ClosedOrbitFromTracking",
      "Fortran routine closed_orbit_from_tracking return value")
      .def_readonly("closed_orb", &Bmad::ClosedOrbitFromTracking::closed_orb)
      .def_readonly("err_flag", &Bmad::ClosedOrbitFromTracking::err_flag)
      .def("__len__", [](const Bmad::ClosedOrbitFromTracking&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ClosedOrbitFromTracking& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.closed_orb);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "ele_full_name",
      &python_ele_full_name,
      py::arg("ele"),
      py::arg("template_") = py::none(),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element in a lattice
template : unknown, optional
    Encoding template. Default is "@N (&#)".
str : 
)""");
  py::class_<PyEleFullName, std::unique_ptr<PyEleFullName>>(
      m, "EleFullName", "Fortran routine ele_full_name return value")
      .def_readonly("str", &PyEleFullName::str)
      .def("__len__", [](const PyEleFullName&) { return 1; })
      .def("__getitem__", [](const PyEleFullName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "find_element_ends",
      &Bmad::find_element_ends,
      py::arg("ele"),
      py::arg("ix_multipass") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to find the ends for.
ele1 : EleStruct
    Pointer to element just before ele.
ele2 : EleStruct
    Pointer to ele itself or the last sub-element within ele. Note: ele1 and ele2 will be nullified if ele is
    in the lord part of the lattice and does not have any slaves. Note: For an element in the tracking part of
    the lattice: ele1.ix_ele = ele.ix_ele - 1 ele2        => ele Exception: For Beginning element (index 0),
    ele1 => ele
ix_multipass : int, optional
    Which multipass pass to follow. Default is 1. This is ignored if there is no multipass elements.
)""");
  py::class_<Bmad::FindElementEnds, std::unique_ptr<Bmad::FindElementEnds>>(
      m, "FindElementEnds", "Fortran routine find_element_ends return value")
      .def_readonly("ele1", &Bmad::FindElementEnds::ele1)
      .def_readonly("ele2", &Bmad::FindElementEnds::ele2)
      .def("__len__", [](const Bmad::FindElementEnds&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::FindElementEnds& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ele1);
            if (i == 1)
              return py::cast(s.ele2);
            return py::none();
          });
  m.def(
      "pointer_to_super_lord",
      &Bmad::pointer_to_super_lord,
      py::arg("slave"),
      py::arg("lord_type") = py::none(),
      py::arg("lord_ptr"),
      R"""(No docstring available

Parameters
----------
slave : EleStruct
    Slave element.
control : ControlStruct
    Pointer to control info for this lord/slave relationship. Nullified if there is an error.
ix_slave_back : int
    Index back to the slave. That is, pointer_to_slave(lord_ptr, ix_slave_back) will point back to slave. Set
    to -1 if there is an error or the slave is a slice_slave.
ix_control : int
    Index in lat.control(:) array the control argument is at. For ramper lord elements, ix_control is index
    for the lord.control.ramper(:) array.
ix_ic : int
    Index of the lat.ic(:) element associated with the control argument.
lord_type : int, optional
    If present, only return a super_lord of this type.
lord_ptr : 
)""");
  py::class_<
      Bmad::PointerToSuperLord,
      std::unique_ptr<Bmad::PointerToSuperLord>>(
      m,
      "PointerToSuperLord",
      "Fortran routine pointer_to_super_lord return value")
      .def_readonly("control", &Bmad::PointerToSuperLord::control)
      .def_readonly("ix_slave_back", &Bmad::PointerToSuperLord::ix_slave_back)
      .def_readonly("ix_control", &Bmad::PointerToSuperLord::ix_control)
      .def_readonly("ix_ic", &Bmad::PointerToSuperLord::ix_ic)
      .def("__len__", [](const Bmad::PointerToSuperLord&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::PointerToSuperLord& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.control);
            if (i == 1)
              return py::cast(s.ix_slave_back);
            if (i == 2)
              return py::cast(s.ix_control);
            if (i == 3)
              return py::cast(s.ix_ic);
            return py::none();
          });
  m.def(
      "kill_taylor",
      &Bmad::kill_taylor,
      py::arg("bmad_taylor"),
      R"""(No docstring available

Parameters
----------
bmad_taylor : TaylorStruct
    Taylor to be deallocated.
    This parameter is an input/output and is modified in-place. As an output: deallocated Taylor structure.
)""");
  m.def(
      "track_all",
      &Bmad::track_all,
      py::arg("lat"),
      py::arg("orbit"),
      py::arg("ix_branch") = py::none(),
      py::arg("init_lost") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to track through.
orbit : CoordStruct
    orbit(0) is the starting coordinates for tracking. If not allocated, the zero orbit will be used.
    This parameter is an input/output and is modified in-place. As an output: Orbit array.
ix_branch : int, optional
    Index of branch to track. Default is 0 (main branch).
track_state : int
    Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
err_flag : bool
    Set true if particle lost or error. False otherwise
orbit0 : CoordStruct
    Orbit array for branch 0. Used to fill in the orbit at lord elemenets. Only needed when orbit(:) is not
    the orbit for branch 0.
init_lost : bool
    Default if False. If True, initialize orbit(N) terms that are not tracked through due to particle loss.
)""");
  py::class_<Bmad::TrackAll, std::unique_ptr<Bmad::TrackAll>>(
      m, "TrackAll", "Fortran routine track_all return value")
      .def_readonly("track_state", &Bmad::TrackAll::track_state)
      .def_readonly("err_flag", &Bmad::TrackAll::err_flag)
      .def_readonly("orbit0", &Bmad::TrackAll::orbit0)
      .def("__len__", [](const Bmad::TrackAll&) { return 3; })
      .def("__getitem__", [](const Bmad::TrackAll& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.track_state);
        if (i == 1)
          return py::cast(s.err_flag);
        if (i == 2)
          return py::cast(s.orbit0);
        return py::none();
      });
  m.def(
      "ion_kick",
      &Bmad::ion_kick,
      py::arg("orbit"),
      py::arg("r_beam"),
      py::arg("n_beam_part"),
      py::arg("a_twiss"),
      py::arg("b_twiss"),
      py::arg("sig_ee"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Ion position.
r_beam : float
    Beam (x, y) position.
n_beam_part : float
    Number of beam particles.
a_twiss : TwissStruct
    Horizontal like beam twiss parameters.
b_twiss : TwissStruct
    vertical like beam twiss parameters.
sig_ee : float
    Sigma_E/E beam energy spread.
kick : float
    (x, y, s) kick in m/sec.
)""");
  m.def(
      "find_matching_fieldmap",
      &Bmad::find_matching_fieldmap,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("fm_type"),
      py::arg("ignore_slaves") = py::none(),
      R"""(No docstring available

Parameters
----------
file_name : unknown
    File name associated with field to match to.
ele : EleStruct
    Element holding the field to be matched.
fm_type : int
    Type of fieldmap: cartesian_map$, cylindircal_map$, or gen_grad_map$, grid_field$
match_ele : EleStruct
    Pointer to element with matched field. Nullified if no match found.
ix_field : int
    index of field. For example: matching field => match_ele.cartesian_map(ix_field) Set to -1 if no match
    found.
ignore_slaves : bool, optional
    If True, ignore any multipass slaves. Default is False.
)""");
  py::class_<
      Bmad::FindMatchingFieldmap,
      std::unique_ptr<Bmad::FindMatchingFieldmap>>(
      m,
      "FindMatchingFieldmap",
      "Fortran routine find_matching_fieldmap return value")
      .def_readonly("match_ele", &Bmad::FindMatchingFieldmap::match_ele)
      .def_readonly("ix_field", &Bmad::FindMatchingFieldmap::ix_field)
      .def("__len__", [](const Bmad::FindMatchingFieldmap&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::FindMatchingFieldmap& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.match_ele);
            if (i == 1)
              return py::cast(s.ix_field);
            return py::none();
          });
  m.def(
      "rf_is_on",
      &python_rf_is_on,
      py::arg("branch"),
      py::arg("ix_ele1") = py::none(),
      py::arg("ix_ele2") = py::none(),
      py::arg("is_on"),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch to check.
ix_ele1 : int, optional
    Start of range of elements to check. Default is 0.
ix_ele2 : int, optional
    End of range of elements to check. Default is branch.n_ele_track.
is_on : 
)""");
  py::class_<PyRfIsOn, std::unique_ptr<PyRfIsOn>>(
      m, "RfIsOn", "Fortran routine rf_is_on return value")
      .def_readonly("is_on", &PyRfIsOn::is_on)
      .def("__len__", [](const PyRfIsOn&) { return 1; })
      .def("__getitem__", [](const PyRfIsOn& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_on);
        return py::none();
      });
  m.def(
      "set_ele_status_stale",
      &Bmad::set_ele_status_stale,
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element. .bookkeeping_state   -- Status block to set.
status_group : int
    Which flag groups to set. Possibilities are: attribute_group$, control_group$, floor_position_group$,
    s_position_group$, s_and_floor_position_group$, ref_energy_group$, or mat6_group$, all_groups$
set_slaves : bool
    If present and False then do not set the status for any slaves. Default is True.
)""");
  py::class_<Bmad::SetEleStatusStale, std::unique_ptr<Bmad::SetEleStatusStale>>(
      m,
      "SetEleStatusStale",
      "Fortran routine set_ele_status_stale return value")
      .def_readonly("ele", &Bmad::SetEleStatusStale::ele)
      .def_readonly("status_group", &Bmad::SetEleStatusStale::status_group)
      .def_readonly("set_slaves", &Bmad::SetEleStatusStale::set_slaves)
      .def("__len__", [](const Bmad::SetEleStatusStale&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::SetEleStatusStale& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ele);
            if (i == 1)
              return py::cast(s.status_group);
            if (i == 2)
              return py::cast(s.set_slaves);
            return py::none();
          });
  m.def(
      "create_lat_ele_nametable",
      &Bmad::create_lat_ele_nametable,
      py::arg("lat"),
      py::arg("nametable"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice. Ouput:
nametable : NametableStruct
    Nametable of the elment names
)""");
  m.def(
      "dpc_given_de",
      &python_dpc_given_de,
      py::arg("pc_old"),
      py::arg("mass"),
      py::arg("dE"),
      py::arg("dpc"),
      R"""(No docstring available

Parameters
----------
pc_old : 
mass : 
dE : 
dpc : 
)""");
  py::class_<PyDpcGivenDe, std::unique_ptr<PyDpcGivenDe>>(
      m, "DpcGivenDe", "Fortran routine dpc_given_de return value")
      .def_readonly("pc_old", &PyDpcGivenDe::pc_old)
      .def_readonly("mass", &PyDpcGivenDe::mass)
      .def_readonly("dE", &PyDpcGivenDe::dE)
      .def_readonly("dpc", &PyDpcGivenDe::dpc)
      .def("__len__", [](const PyDpcGivenDe&) { return 4; })
      .def("__getitem__", [](const PyDpcGivenDe& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.pc_old);
        if (i == 1)
          return py::cast(s.mass);
        if (i == 2)
          return py::cast(s.dE);
        if (i == 3)
          return py::cast(s.dpc);
        return py::none();
      });
  m.def(
      "apply_rampers_to_slave",
      &Bmad::apply_rampers_to_slave,
      py::arg("slave"),
      R"""(No docstring available

Parameters
----------
slave : EleStruct
    Element to apply ramper elements to.
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "element_slice_iterator",
      &Bmad::element_slice_iterator,
      py::arg("ele"),
      py::arg("param"),
      py::arg("i_slice"),
      py::arg("n_slice_tot"),
      py::arg("sliced_ele"),
      py::arg("s_start") = py::none(),
      py::arg("s_end") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to slice and dice.
param : LatParamStruct
    Lattice parameters
i_slice : int
    Slice index
n_slice_tot : int
    Total number of slices.
sliced_ele : 
s_start : float, optional
    Starting edge of slice relative to beginning of element.
s_end : float, optional
    Ending edge of slice relative to beginning of element.
)""");
  m.def(
      "create_element_slice",
      &Bmad::create_element_slice,
      py::arg("ele_in"),
      py::arg("l_slice"),
      py::arg("offset"),
      py::arg("param"),
      py::arg("include_upstream_end"),
      py::arg("include_downstream_end"),
      py::arg("old_slice") = py::none(),
      py::arg("orb_in") = py::none(),
      R"""(No docstring available

Parameters
----------
sliced_ele : EleStruct
    Sliced_ele element with appropriate values set.
ele_in : EleStruct
    Original element to slice
l_slice : float
    Length of the slice
offset : float
    Offset of entrance end of sliced_ele from entrance end of ele_in.
param : LatParamStruct
    lattice paramters.
include_upstream_end : bool
    Sliced_ele contains the ele's entrance end?
include_downstream_end : bool
    Sliced_ele contains the ele's exit end?
err_flag : bool
    Set True if there is an error. False otherwise.
old_slice : EleStruct, optional
    Previous slice or, if offset = 0, the previous element. If present this saves computation time of the
    reference energy and time at the start of the present slice. Also makes the ref energy continuous (there
    can be some small differences when using, say, runge_kutta tracking due to tracking tolerances).
orb_in : CoordStruct, optional
    Incoming orbit if calling routine is doing tracking through the slice. This is used when old_slice is not
    present and there may be an adjustment needed to the orbit ref energy (EG space charge tracking does not
    keep track of ref energy through an lcavity).
)""");
  py::class_<
      Bmad::CreateElementSlice,
      std::unique_ptr<Bmad::CreateElementSlice>>(
      m,
      "CreateElementSlice",
      "Fortran routine create_element_slice return value")
      .def_readonly("sliced_ele", &Bmad::CreateElementSlice::sliced_ele)
      .def_readonly("err_flag", &Bmad::CreateElementSlice::err_flag)
      .def("__len__", [](const Bmad::CreateElementSlice&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::CreateElementSlice& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.sliced_ele);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "lord_edge_aligned",
      &python_lord_edge_aligned,
      py::arg("slave"),
      py::arg("slave_edge"),
      py::arg("lord"),
      py::arg("is_aligned"),
      R"""(No docstring available

Parameters
----------
slave : EleStruct
    Slave element.
slave_edge : int
    End under consideration: entrance_end$, exit_end$, in_between$, etc.
lord : EleStruct
    Lord element.
is_aligned : 
)""");
  py::class_<PyLordEdgeAligned, std::unique_ptr<PyLordEdgeAligned>>(
      m, "LordEdgeAligned", "Fortran routine lord_edge_aligned return value")
      .def_readonly("is_aligned", &PyLordEdgeAligned::is_aligned)
      .def("__len__", [](const PyLordEdgeAligned&) { return 1; })
      .def(
          "__getitem__",
          [](const PyLordEdgeAligned& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_aligned);
            return py::none();
          });
  m.def(
      "ele_loc_name",
      &python_ele_loc_name,
      py::arg("ele"),
      py::arg("show_branch0") = py::none(),
      py::arg("parens") = py::none(),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element in a lattice
show_branch0 : bool, optional
    Explicitly show branch for main lattice elements? Default is False.
parens : unknown, optional
    If present, enclose location string using the two characters supplied. Typically parens will be set to
    "()" or "[]".
str : 
)""");
  py::class_<PyEleLocName, std::unique_ptr<PyEleLocName>>(
      m, "EleLocName", "Fortran routine ele_loc_name return value")
      .def_readonly("str", &PyEleLocName::str)
      .def("__len__", [](const PyEleLocName&) { return 1; })
      .def("__getitem__", [](const PyEleLocName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "convert_particle_coordinates_t_to_s",
      &Bmad::convert_particle_coordinates_t_to_s,
      py::arg("particle"),
      py::arg("ele"),
      py::arg("use_downstream_p0c") = py::none(),
      R"""(No docstring available

Parameters
----------
particle : CoordStruct
    Particle with .vec(:) in t-coords.
ele : EleStruct
    Element particle is going through.
s_body : float
    s-position in element body coords.
use_downstream_p0c : bool, optional
    If True (the default), use ele.value(p0c$) as the reference momentum. If False, use ele.value(p0c_start$)
    as the reference.
)""");
  m.def(
      "one_turn_mat_at_ele",
      &Bmad::one_turn_mat_at_ele,
      py::arg("ele"),
      py::arg("phi_a"),
      py::arg("phi_b"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Reference element. .a       -- "a" mode Twiss parameter structure. .b       -- "b" mode Twiss parameter
    structure. .c_mat   -- 2x2 C matrix. .gamma_c -- gamma associated with C matrix.
phi_a : float
    "a" mode tune in radians.
phi_b : float
    "b" mode tune in radians.
mat4 : float
    1-Turn coupled matrix.
)""");
  m.def(
      "set_ele_real_attribute",
      &Bmad::set_ele_real_attribute,
      py::arg("ele"),
      py::arg("attrib_name"),
      py::arg("value"),
      py::arg("err_print_flag") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with attribute to set.
    This parameter is an input/output and is modified in-place. As an output: Element with attribute set.
attrib_name : unknown
    Attribute name.
value : float
    value to set to.
err_flag : bool
    Set True if there is an error, False otherwise.
err_print_flag : bool, optional
    If present and False then suppress printing of an error message if attribute is, for example, not free.
)""");
  m.def(
      "ele_order_calc",
      &Bmad::ele_order_calc,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to analyze.
order : LatEleOrderStruct
    Structure holding the element order information.
)""");
  m.def(
      "pointer_to_wake_ele",
      &Bmad::pointer_to_wake_ele,
      py::arg("ele"),
      py::arg("wake_ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
delta_s : float
    distance of wake locaiton from beginning of ele.
wake_ele : 
)""");
  m.def(
      "set_ele_attribute",
      &Bmad::set_ele_attribute,
      py::arg("ele"),
      py::arg("set_string"),
      py::arg("err_print_flag") = py::none(),
      py::arg("set_lords") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with attribute to set.
    This parameter is an input/output and is modified in-place. As an output: Element with attribute set.
set_string : unknown
    Attribute and value for set.
err_flag : bool
    Set True if there is an error, False otherwise.
err_print_flag : bool, optional
    If present and False then suppress printing of an error message if attribute is, for example, not free.
set_lords : bool, optional
    Default False. If True, set the super_lord(s) if the element is a super_slave.
err_id : int
    Set to an integer which identifies the error type. 0 = no error. The higher the error the further along
    the error was encountered.
)""");
  py::class_<Bmad::SetEleAttribute, std::unique_ptr<Bmad::SetEleAttribute>>(
      m, "SetEleAttribute", "Fortran routine set_ele_attribute return value")
      .def_readonly("err_flag", &Bmad::SetEleAttribute::err_flag)
      .def_readonly("err_id", &Bmad::SetEleAttribute::err_id)
      .def("__len__", [](const Bmad::SetEleAttribute&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::SetEleAttribute& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.err_id);
            return py::none();
          });
  m.def(
      "twiss_from_tracking",
      &Bmad::twiss_from_tracking,
      py::arg("lat"),
      py::arg("ref_orb0"),
      py::arg("d_orb") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to track through.
    This parameter is an input/output and is modified in-place. As an output: Structure holding the Twiss
    parameters.
ref_orb0 : CoordStruct
    Reference orbit at lat.ele(0).
symp_err : float
    A measure of how symplectic the constructed matrices were before symplecitification. mat_symp_check for
    more details.
err_flag : bool
    Set True if there is an error. False otherwise.
d_orb : float, optional
    Vector of offsets to use. If not present or zero bmad_com.d_orb(:) will be used.
)""");
  py::class_<Bmad::TwissFromTracking, std::unique_ptr<Bmad::TwissFromTracking>>(
      m,
      "TwissFromTracking",
      "Fortran routine twiss_from_tracking return value")
      .def_readonly("symp_err", &Bmad::TwissFromTracking::symp_err)
      .def_readonly("err_flag", &Bmad::TwissFromTracking::err_flag)
      .def("__len__", [](const Bmad::TwissFromTracking&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TwissFromTracking& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.symp_err);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "relative_mode_flip",
      &python_relative_mode_flip,
      py::arg("ele1"),
      py::arg("ele2"),
      py::arg("func_retval__"),
      R"""(No docstring available

Parameters
----------
ele1 : 
ele2 : 
relative_mode_flip : 
)""");
  py::class_<PyRelativeModeFlip, std::unique_ptr<PyRelativeModeFlip>>(
      m, "RelativeModeFlip", "Fortran routine relative_mode_flip return value")
      .def_readonly("func_retval__", &PyRelativeModeFlip::func_retval__)
      .def("__len__", [](const PyRelativeModeFlip&) { return 1; })
      .def(
          "__getitem__",
          [](const PyRelativeModeFlip& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.func_retval__);
            return py::none();
          });
  m.def(
      "check_if_s_in_bounds",
      &Bmad::check_if_s_in_bounds,
      py::arg("branch"),
      py::arg("s"),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Branch
s : float
    longitudinal position in the given branch.
err_flag : bool
    Set True if s position is out-of-bounds. False otherwise.
translated_s : float
    position translated to the range [0, branch_length]
print_err : bool, optional
    Print error message if there is an error? Default is True.
)""");
  py::class_<Bmad::CheckIfSInBounds, std::unique_ptr<Bmad::CheckIfSInBounds>>(
      m,
      "CheckIfSInBounds",
      "Fortran routine check_if_s_in_bounds return value")
      .def_readonly("err_flag", &Bmad::CheckIfSInBounds::err_flag)
      .def_readonly("translated_s", &Bmad::CheckIfSInBounds::translated_s)
      .def("__len__", [](const Bmad::CheckIfSInBounds&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::CheckIfSInBounds& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.translated_s);
            return py::none();
          });
  m.def(
      "particle_is_moving_forward",
      &python_particle_is_moving_forward,
      py::arg("orbit"),
      py::arg("dir") = py::none(),
      py::arg("is_moving_forward"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle coordinates
dir : int, optional
    +1 if tracking forward(default) or -1 to return True if tracking backwards.
is_moving_forward : 
)""");
  py::class_<
      PyParticleIsMovingForward,
      std::unique_ptr<PyParticleIsMovingForward>>(
      m,
      "ParticleIsMovingForward",
      "Fortran routine particle_is_moving_forward return value")
      .def_readonly(
          "is_moving_forward", &PyParticleIsMovingForward::is_moving_forward)
      .def("__len__", [](const PyParticleIsMovingForward&) { return 1; })
      .def(
          "__getitem__",
          [](const PyParticleIsMovingForward& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_moving_forward);
            return py::none();
          });
  m.def(
      "twiss_and_track_intra_ele",
      &Bmad::twiss_and_track_intra_ele,
      py::arg("ele"),
      py::arg("param"),
      py::arg("l_start"),
      py::arg("l_end"),
      py::arg("track_upstream_end"),
      py::arg("track_downstream_end"),
      py::arg("orbit_start") = py::none(),
      py::arg("ele_start") = py::none(),
      py::arg("ele_end") = py::none(),
      py::arg("compute_floor_coords") = py::none(),
      py::arg("compute_twiss") = py::none(),
      py::arg("reuse_ele_end") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to track through.
param : LatParamStruct
l_start : float
    Start position measured from the beginning of the element.
l_end : float
    Stop position measured from the beginning of the element.
track_upstream_end : bool
    If True then entrance effects are included in the tracking. But only if l_start = 0 and
    orbit_start.location /= inside$.
track_downstream_end : bool
    If True then exit effects are included in the tracking but only if l_end = ele.value(l$) (within
    bmad_com.significant_length tol)
orbit_start : CoordStruct, optional
    Starting phase space coordinates at l_start.
orbit_end : CoordStruct
    End phase space coordinates. If present then the orbit_start argument must also be present.
ele_start : EleStruct, optional
    Holds the starting Twiss parameters at l_start.
ele_end : EleStruct, optional
    If reuse_ele_end is set True then reuse ele_end from trancking instead of recomputing ele_end from
    scratch. This can save time.
    This parameter is an input/output and is modified in-place. As an output: Holds the ending Twiss
    parameters at l_end (except for photons).
err : bool
    Set True if there is a problem like the particle gets lost in tracking
compute_floor_coords : bool, optional
    If present and True then the global "floor" coordinates (without misalignments) will be calculated and put
    in ele_end.floor.
compute_twiss : bool, optional
    Default True. If False, to save a little time, do not compute Twiss parameters. Also if ele_start is not
    present, no Twiss parameters are computed.
reuse_ele_end : bool, optional
    If present and True, and if ele_end has the correct lonigitudianal length and key type, reuse ele_end from
    trancking instead of recomputing ele_end from scratch. This can save time.
)""");
  py::class_<
      Bmad::TwissAndTrackIntraEle,
      std::unique_ptr<Bmad::TwissAndTrackIntraEle>>(
      m,
      "TwissAndTrackIntraEle",
      "Fortran routine twiss_and_track_intra_ele return value")
      .def_readonly("orbit_end", &Bmad::TwissAndTrackIntraEle::orbit_end)
      .def_readonly("err", &Bmad::TwissAndTrackIntraEle::err)
      .def("__len__", [](const Bmad::TwissAndTrackIntraEle&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TwissAndTrackIntraEle& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.orbit_end);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "convert_total_energy_to",
      &Bmad::convert_total_energy_to,
      py::arg("E_tot"),
      py::arg("particle"),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
E_tot : float
    Total energy of the particle.
particle : int
    Type of particle. positron$, etc.
gamma : float
    Gamma factor. Set to -1 for photons.
kinetic : float
    Kinetic energy
beta : float
    velocity / c_light
pc : float
    Particle momentum
brho : float
    Nominal B_field*rho_bend
beta1 : float
    1 - beta. Equal to 1/(2*gamma^2) in ultra-rel limit.
err_flag : bool
    Set true if there is an error. False otherwise.
print_err : bool, optional
    Print error message if E_tot < particle mass? Default is True.
)""");
  py::class_<
      Bmad::ConvertTotalEnergyTo,
      std::unique_ptr<Bmad::ConvertTotalEnergyTo>>(
      m,
      "ConvertTotalEnergyTo",
      "Fortran routine convert_total_energy_to return value")
      .def_readonly("gamma", &Bmad::ConvertTotalEnergyTo::gamma)
      .def_readonly("kinetic", &Bmad::ConvertTotalEnergyTo::kinetic)
      .def_readonly("beta", &Bmad::ConvertTotalEnergyTo::beta)
      .def_readonly("pc", &Bmad::ConvertTotalEnergyTo::pc)
      .def_readonly("brho", &Bmad::ConvertTotalEnergyTo::brho)
      .def_readonly("beta1", &Bmad::ConvertTotalEnergyTo::beta1)
      .def_readonly("err_flag", &Bmad::ConvertTotalEnergyTo::err_flag)
      .def("__len__", [](const Bmad::ConvertTotalEnergyTo&) { return 7; })
      .def(
          "__getitem__",
          [](const Bmad::ConvertTotalEnergyTo& s, size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.gamma);
            if (i == 1)
              return py::cast(s.kinetic);
            if (i == 2)
              return py::cast(s.beta);
            if (i == 3)
              return py::cast(s.pc);
            if (i == 4)
              return py::cast(s.brho);
            if (i == 5)
              return py::cast(s.beta1);
            if (i == 6)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "clear_taylor_maps_from_elements",
      &Bmad::clear_taylor_maps_from_elements,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice
    This parameter is an input/output and is modified in-place. As an output: Lattice with all maps cleared
)""");
  m.def(
      "track1",
      &Bmad::track1,
      py::arg("start_orb"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("track") = py::none(),
      py::arg("ignore_radiation") = py::none(),
      py::arg("make_map1") = py::none(),
      py::arg("init_to_edge") = py::none(),
      R"""(No docstring available

Parameters
----------
start_orb : CoordStruct
    Starting position.
ele : EleStruct
    Element to track through.
    This parameter is an input/output and is modified in-place. As an output: Modified if make_map1 is True.
param : LatParamStruct
    Reference particle info.
end_orb : CoordStruct
    End position.
track : TrackStruct, optional
    Structure holding existing track.
    This parameter is an input/output and is modified in-place. As an output: Structure holding the track
    information if the
err_flag : bool
    Set true if there is an error. False otherwise. Note: The particle getting lost (EG hitting an aperture)
    is *not* an error. An error is something like start_orb not being properly initialized.
ignore_radiation : bool, optional
    If present and True then do not include radiation -- Logical, optional: If present and True then do not
    include radiation effects along with space charge effects.
make_map1 : bool, optional
    Make ele.mat6 and ele.spin_q components? Default is false.
init_to_edge : bool, optional
    Default is True. If True then force the tracked particle to begin at the element's edge. See above. Do not
    use this argument unless you know what you are doing.
)""");
  py::class_<Bmad::Track1, std::unique_ptr<Bmad::Track1>>(
      m, "Track1", "Fortran routine track1 return value")
      .def_readonly("end_orb", &Bmad::Track1::end_orb)
      .def_readonly("err_flag", &Bmad::Track1::err_flag)
      .def("__len__", [](const Bmad::Track1&) { return 2; })
      .def("__getitem__", [](const Bmad::Track1& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.end_orb);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "multipole_ab_to_kt",
      &Bmad::multipole_ab_to_kt,
      py::arg("an"),
      py::arg("bn"),
      R"""(No docstring available

Parameters
----------
an : float
    Skew multipole component.
bn : float
    Normal multipole component.
knl : float
    Multitude magnatude.
tn : float
    Multipole angle.
)""");
  py::class_<Bmad::MultipoleAbToKt, std::unique_ptr<Bmad::MultipoleAbToKt>>(
      m, "MultipoleAbToKt", "Fortran routine multipole_ab_to_kt return value")
      .def_readonly("knl", &Bmad::MultipoleAbToKt::knl)
      .def_readonly("tn", &Bmad::MultipoleAbToKt::tn)
      .def("__len__", [](const Bmad::MultipoleAbToKt&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::MultipoleAbToKt& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.knl);
            if (i == 1)
              return py::cast(s.tn);
            return py::none();
          });
  m.def(
      "multipole_ele_to_ab",
      &Bmad::multipole_ele_to_ab,
      py::arg("ele"),
      py::arg("use_ele_tilt"),
      py::arg("pole_type") = py::none(),
      py::arg("include_kicks") = py::none(),
      py::arg("original") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element. .value()      -- ab_multipole values.
use_ele_tilt : bool
    If True then include ele.value(tilt_tot$) in calculations. use_ele_tilt is ignored in the case of
    multipole$ elements.
ix_pole_max : int
    Index of largest nonzero a(:) or b(:) pole. Set to -1 if all multipoles are zero. ix_pole_max is set
    independent of a nonzero b1 (if present).
a : float
    Array of multipole values.
b : float
    Array of multipole values.
pole_type : int, optional
    Type of multipole. magnetic$ (default) or electric$.
include_kicks : int, optional
    Ignored for for pole_type == electric$ for non-elseparator elements. Possibilities are: no$
    -- Default. Do not include any kick components in a and b multipoles. include_kicks$           -- Include
    hkick/vkick/dg in the n = 0 components. Also included are quad k1, sextupole k2 and octupole k3
    components.
b1 : float
    If present, b1 is set to the value of the b(1) component of the b(:) array and b(1) is set to zero. Also
    ix_pole_max is ajusted as needed. This is used by routines that want to handle b(1) in a special way in
    tracking.
original : bool, optional
    Default is false. If True, no scaling is applied.
)""");
  py::class_<Bmad::MultipoleEleToAb, std::unique_ptr<Bmad::MultipoleEleToAb>>(
      m, "MultipoleEleToAb", "Fortran routine multipole_ele_to_ab return value")
      .def_readonly("ix_pole_max", &Bmad::MultipoleEleToAb::ix_pole_max)
      .def_readonly("a", &Bmad::MultipoleEleToAb::a)
      .def_readonly("b", &Bmad::MultipoleEleToAb::b)
      .def_readonly("b1", &Bmad::MultipoleEleToAb::b1)
      .def("__len__", [](const Bmad::MultipoleEleToAb&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::MultipoleEleToAb& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_pole_max);
            if (i == 1)
              return py::cast(s.a);
            if (i == 2)
              return py::cast(s.b);
            if (i == 3)
              return py::cast(s.b1);
            return py::none();
          });
  m.def(
      "start_branch_at",
      &Bmad::start_branch_at,
      py::arg("lat"),
      py::arg("ele_start"),
      py::arg("move_end_marker"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to modify.
    This parameter is an input/output and is modified in-place. As an output: Modified lattice.
ele_start : unknown
    Start element. Ele_start will identify the lattice branch to modify.
move_end_marker : bool
    If True then the end marker (if it is present) will be shifted like any other element. False means that
    the end marker will stay at the end.
error : bool
    Set True if there is an error Set False if not.
)""");
  m.def(
      "valid_field_calc",
      &python_valid_field_calc,
      py::arg("ele"),
      py::arg("field_calc"),
      py::arg("is_valid"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
field_calc : int
    bmad_standard$, etc.
is_valid : 
)""");
  py::class_<PyValidFieldCalc, std::unique_ptr<PyValidFieldCalc>>(
      m, "ValidFieldCalc", "Fortran routine valid_field_calc return value")
      .def_readonly("is_valid", &PyValidFieldCalc::is_valid)
      .def("__len__", [](const PyValidFieldCalc&) { return 1; })
      .def(
          "__getitem__", [](const PyValidFieldCalc& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "order_super_lord_slaves",
      &Bmad::order_super_lord_slaves,
      py::arg("lat"),
      py::arg("ix_lord"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat with fixed controls.
ix_lord : int
    Index of lord element. Output
)""");
  m.def(
      "spline_fit_orbit",
      &Bmad::spline_fit_orbit,
      py::arg("start_orb"),
      py::arg("end_orb"),
      py::arg("spline_x"),
      py::arg("spline_y"),
      R"""(No docstring available

Parameters
----------
start_orb : CoordStruct
    Starting coords.
end_orb : CoordStruct
    Ending coords.
spline_x : float
    Spline coefs for the horizontal trajectory.
spline_y : float
    Spline coefs for vertical trajectory.
)""");
  m.def(
      "pointer_to_multipass_lord",
      &Bmad::pointer_to_multipass_lord,
      py::arg("ele"),
      py::arg("multi_lord"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
ix_pass : int
    Multipass turn number. Set to 0 if element is a multipass_lord. Set to -1 if element is not a
    multipass_slave.
super_lord : EleStruct
    super_lord of the element. Set to NULL if ele is not a super_slave or super_lord. Note: if ele is a
    multipass_lord there are multiple possible super_lord slaves.
multi_lord : 
)""");
  py::class_<
      Bmad::PointerToMultipassLord,
      std::unique_ptr<Bmad::PointerToMultipassLord>>(
      m,
      "PointerToMultipassLord",
      "Fortran routine pointer_to_multipass_lord return value")
      .def_readonly("ix_pass", &Bmad::PointerToMultipassLord::ix_pass)
      .def_readonly("super_lord", &Bmad::PointerToMultipassLord::super_lord)
      .def("__len__", [](const Bmad::PointerToMultipassLord&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::PointerToMultipassLord& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_pass);
            if (i == 1)
              return py::cast(s.super_lord);
            return py::none();
          });
  m.def(
      "gamma_ref",
      &python_gamma_ref,
      py::arg("ele"),
      py::arg("gamma"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to evaluate at.
gamma : 
)""");
  py::class_<PyGammaRef, std::unique_ptr<PyGammaRef>>(
      m, "GammaRef", "Fortran routine gamma_ref return value")
      .def_readonly("gamma", &PyGammaRef::gamma)
      .def("__len__", [](const PyGammaRef&) { return 1; })
      .def("__getitem__", [](const PyGammaRef& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.gamma);
        return py::none();
      });
  m.def(
      "multipole_init",
      &Bmad::multipole_init,
      py::arg("who"),
      py::arg("zero") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element holding the multipoles. .a_pole(0:n_pole_maxx) -- Multipole An array .b_pole(0:n_pole_maxx) --
    Multipole Bn array
who : int
    electric$, magnetic$, or all$
zero : bool, optional
    If present and True then zero the arrays even if they already exist when this routine is called. Default
    is False which means that if the arrays already exist then this routine will do nothing.
)""");
  m.def(
      "rel_tracking_charge_to_mass",
      &python_rel_tracking_charge_to_mass,
      py::arg("orbit"),
      py::arg("ref_species"),
      py::arg("rel_charge"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle position structure.
ref_species : int
    Reference species
rel_charge : 
)""");
  py::class_<
      PyRelTrackingChargeToMass,
      std::unique_ptr<PyRelTrackingChargeToMass>>(
      m,
      "RelTrackingChargeToMass",
      "Fortran routine rel_tracking_charge_to_mass return value")
      .def_readonly("rel_charge", &PyRelTrackingChargeToMass::rel_charge)
      .def("__len__", [](const PyRelTrackingChargeToMass&) { return 1; })
      .def(
          "__getitem__",
          [](const PyRelTrackingChargeToMass& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rel_charge);
            return py::none();
          });
  m.def(
      "chrom_calc",
      &python_chrom_calc,
      py::arg("lat"),
      py::arg("delta_e"),
      py::arg("pz") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("orb0") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat
delta_e : float
    +/- Delta energy used for the calculation. Notice that the energy difference between high and low is 2 *
    delta_e. If 0 then default of 1.0d-4 is used.
    This parameter is an input/output and is modified in-place. As an output: Set to 1.0d-4 if on input
    DELTA_E =< 0.
chrom_a : float
    a-mode chromaticity.
chrom_b : float
    b-mode chromaticity.
err_flag : bool
    Set true if there is an error. False otherwise.
pz : float, optional
    reference momentum about which to calculate. Default is 0.
low_E_lat : LatStruct
    Lattice with RF off and matrices computed at E_lat +pz - delta_e
high_E_lat : LatStruct
    Lattice with RF off and matrices computed at E_lat +pz + delta_e
low_E_orb : CoordStruct
    Orbit computed at E_lat + pz - delta_e.
high_E_orb : CoordStruct
    Orbit computed at E_lat + pz + delta_e.
ix_branch : int, optional
    Index of the lattice branch to use. Default is 0.
orb0 : CoordStruct, optional
    On-energy orbit at start (fixer point). Default is the branch.particle_start. Only needed if lattice
    branch has an open geometry.
)""");
  py::class_<PyChromCalc, std::unique_ptr<PyChromCalc>>(
      m, "ChromCalc", "Fortran routine chrom_calc return value")
      .def_readonly("chrom_a", &PyChromCalc::chrom_a)
      .def_readonly("chrom_b", &PyChromCalc::chrom_b)
      .def_readonly("err_flag", &PyChromCalc::err_flag)
      .def_readonly("low_E_lat", &PyChromCalc::low_E_lat)
      .def_readonly("high_E_lat", &PyChromCalc::high_E_lat)
      .def_readonly("low_E_orb", &PyChromCalc::low_E_orb)
      .def_readonly("high_E_orb", &PyChromCalc::high_E_orb)
      .def_readonly("delta_e", &PyChromCalc::delta_e)
      .def("__len__", [](const PyChromCalc&) { return 8; })
      .def("__getitem__", [](const PyChromCalc& s, size_t i) -> py::object {
        if (i >= 8)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.chrom_a);
        if (i == 1)
          return py::cast(s.chrom_b);
        if (i == 2)
          return py::cast(s.err_flag);
        if (i == 3)
          return py::cast(s.low_E_lat);
        if (i == 4)
          return py::cast(s.high_E_lat);
        if (i == 5)
          return py::cast(s.low_E_orb);
        if (i == 6)
          return py::cast(s.high_E_orb);
        if (i == 7)
          return py::cast(s.delta_e);
        return py::none();
      });
  m.def(
      "valid_tracking_method",
      &python_valid_tracking_method,
      py::arg("ele"),
      py::arg("species"),
      py::arg("tracking_method"),
      py::arg("is_valid"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
species : 
    Type of particle being tracked. electron$, etc. or not_set$
tracking_method : int
    bmad_standard$, etc.
is_valid : 
)""");
  py::class_<PyValidTrackingMethod, std::unique_ptr<PyValidTrackingMethod>>(
      m,
      "ValidTrackingMethod",
      "Fortran routine valid_tracking_method return value")
      .def_readonly("is_valid", &PyValidTrackingMethod::is_valid)
      .def("__len__", [](const PyValidTrackingMethod&) { return 1; })
      .def(
          "__getitem__",
          [](const PyValidTrackingMethod& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "em_field_calc",
      &Bmad::em_field_calc,
      py::arg("ele"),
      py::arg("param"),
      py::arg("s_pos"),
      py::arg("orbit"),
      py::arg("local_ref_frame"),
      py::arg("calc_dfield") = py::none(),
      py::arg("calc_potential") = py::none(),
      py::arg("use_overlap") = py::none(),
      py::arg("grid_allow_s_out_of_bounds") = py::none(),
      py::arg("rf_time") = py::none(),
      py::arg("used_eles") = py::none(),
      py::arg("print_err") = py::none(),
      py::arg("original_ele") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
param : LatParamStruct
    Lattice parameters.
s_pos : float
    Longitudinal position. If local_ref_frame = T: In Body coords relative to the entrance edge of the
    element. If local_ref_frame = F: In Lab coords relative to the upstream edge of the element.
orbit : CoordStruct
    Transverse coordinates. .vec(1), .vec(3)    -- Transverse coords. .t                  -- Used with
    absolute time tracking. .vec(5)             -- Used with relative time tracking (except with time Runge-
    Kutta).
local_ref_frame : 
    Logical, If True then take the input coordinates and output fields as being with respect to the frame of
    referene of the element (ignore misalignments).
field : EmFieldStruct
    E and B fields and derivatives.
calc_dfield : bool, optional
    If present and True then calculate the field derivatives.
err_flag : bool
    Set True if there is an error. False otherwise.
calc_potential : bool, optional
    Calc electric and magnetic potentials? Default is false. This is experimental and only implemented for
    wigglers at present.
use_overlap : bool, optional
    Add in overlap fields from other elements? Default is True.
grid_allow_s_out_of_bounds : bool, optional
    For grids, allow s-coordinate to be grossly out of bounds -- logical, optional: For grids, allow
    s-coordinate to be grossly out of bounds and return zero instead of an error? Default: False. Used
    internally for overlapping fields.
rf_time : float, optional
    Set the time relative to the RF clock. Normally this time is calculated using orbit.t or orbit.vec(5) but
    sometimes it is convenient to be able to override this. For example, time_runge_kutta uses this.
used_eles : ElePointerStruct, optional
    For internal use only when this routine is called recursively. Used to prevent double counting when there
    is field overlap.
print_err : bool, optional
    Print an error message? Default is True. For example, if the particle is out of bounds when the field is
    defined on a grid.
original_ele : EleStruct, optional
    Used with recursive calls that pass the lord as the ele argument. In this case original_ele is the
    original ele argument.
)""");
  py::class_<Bmad::EmFieldCalc, std::unique_ptr<Bmad::EmFieldCalc>>(
      m, "EmFieldCalc", "Fortran routine em_field_calc return value")
      .def_readonly("field", &Bmad::EmFieldCalc::field)
      .def_readonly("err_flag", &Bmad::EmFieldCalc::err_flag)
      .def("__len__", [](const Bmad::EmFieldCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::EmFieldCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.field);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "at_this_ele_end",
      &python_at_this_ele_end,
      py::arg("now_at"),
      py::arg("where_at"),
      py::arg("is_at_this_end"),
      R"""(No docstring available

Parameters
----------
now_at : int
    Which end is under consideration: entrance_end$, exit_end$, surface$, or in_between$.
where_at : int
    Which ends have the aperture or fringe field: entrance_end$, exit_end$, continuous$, both_ends$,
    no_aperture$, surface$, wall_transition$.
is_at_this_end : 
)""");
  py::class_<PyAtThisEleEnd, std::unique_ptr<PyAtThisEleEnd>>(
      m, "AtThisEleEnd", "Fortran routine at_this_ele_end return value")
      .def_readonly("is_at_this_end", &PyAtThisEleEnd::is_at_this_end)
      .def("__len__", [](const PyAtThisEleEnd&) { return 1; })
      .def("__getitem__", [](const PyAtThisEleEnd& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_at_this_end);
        return py::none();
      });
  m.def(
      "transfer_map_calc",
      &Bmad::transfer_map_calc,
      py::arg("lat"),
      py::arg("orb_map"),
      py::arg("ix1") = py::none(),
      py::arg("ix2") = py::none(),
      py::arg("ref_orb") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("one_turn") = py::none(),
      py::arg("unit_start") = py::none(),
      py::arg("concat_if_possible") = py::none(),
      py::arg("spin_map") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice used in the calculation.
orb_map : TaylorStruct
    Initial map (used when unit_start = False)
    This parameter is an input/output and is modified in-place. As an output: Transfer map.
err_flag : bool
    Set True if problem like number overflow, etc.
ix1 : int, optional
    Element start index for the calculation. Default is 0.
ix2 : int, optional
    Element end index for the calculation. Default is lat.n_ele_track.
ref_orb : CoordStruct, optional
    Reference orbit/particle at s1 around which the map is made. This arg is needed if: unit_start = True or
    particle is not the same as the reference particle of the lattice.
ix_branch : int, optional
    Lattice branch index. Default is 0.
one_turn : bool, optional
    If present and True, and if ix1 = ix2, and the lattice is circular, then construct the one-turn map from
    ix1 back to ix1. Default = False.
unit_start : bool, optional
    If present and False then orb_map will be used as the starting map instead of the unit map. Default = True
concat_if_possible : bool, optional
    If present and True then use map concatenation rather than tracking -- logical, optional: If present and
    True then use map concatenation rather than tracking if a map is present for a given lattice element. See
    above. Default is False.
spin_map : TaylorStruct, optional
    Input quaternion spin map. Output only computed if bmad_com.spin_tracking_on = T
    This parameter is an input/output and is modified in-place. As an output: Quaternion spin map.
)""");
  m.def(
      "pointer_to_next_ele",
      &Bmad::pointer_to_next_ele,
      py::arg("this_ele"),
      py::arg("offset") = py::none(),
      py::arg("skip_beginning") = py::none(),
      py::arg("follow_fork") = py::none(),
      py::arg("next_ele"),
      R"""(No docstring available

Parameters
----------
this_ele : EleStruct
    Starting element.
offset : int, optional
    +1 -> return next element, +2 -> element after that, etc. Can be negative. Default = +1.
skip_beginning : bool, optional
    If True then skip beginning element #0 when wrapping around. Default is False.
follow_fork : bool, optional
    If True then fork at any fork element. Default is False.
next_ele : 
)""");
  m.def(
      "set_tune",
      &python_set_tune,
      py::arg("phi_a_set"),
      py::arg("phi_b_set"),
      py::arg("dk1"),
      py::arg("eles"),
      py::arg("branch"),
      py::arg("orb"),
      py::arg("print_err") = py::none(),
      py::arg("ok"),
      R"""(No docstring available

Parameters
----------
phi_a_set : float
    Horizontal set tune (radians)
phi_b_set : float
    Vertical set tune (radians)
dk1 : float
    Relative amount to vary a quad in tuning. The variation will be proportional to dk1. Those quads with a
    positive dk1(i) will be varied as one group and the quads with negative dk1(i) will be varied as another
    group. The routine choose_quads_for_set_tune can be used to calculate values for dk1.
eles : ElePointerStruct
    eles(i).ele points to quadrupole corresponding to dk1(i).
branch : BranchStruct
    Lattice branch to tune.
    This parameter is an input/output and is modified in-place. As an output: Q_tuned lattice branch
orb : CoordStruct
    If RF is off: Energy dE/E at which the tune is computed.
    This parameter is an input/output and is modified in-place. As an output: New closed orbit.
print_err : bool, optional
    Print error message if there is a problem? Default is True.
ok : 
)""");
  py::class_<PySetTune, std::unique_ptr<PySetTune>>(
      m, "SetTune", "Fortran routine set_tune return value")
      .def_readonly("ok", &PySetTune::ok)
      .def("__len__", [](const PySetTune&) { return 1; })
      .def("__getitem__", [](const PySetTune& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ok);
        return py::none();
      });
  m.def(
      "make_mat6",
      &Bmad::make_mat6,
      py::arg("ele"),
      py::arg("param"),
      py::arg("start_orb") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element holding the transfer matrix.
param : LatParamStruct
    Lattice global parameters.
start_orb : CoordStruct, optional
    Reference coordinates at the beginning of element. If not present, default is to use the zero orbit.
end_orb : CoordStruct
    Reference coordinates at the end of element.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<Bmad::MakeMat6, std::unique_ptr<Bmad::MakeMat6>>(
      m, "MakeMat6", "Fortran routine make_mat6 return value")
      .def_readonly("end_orb", &Bmad::MakeMat6::end_orb)
      .def_readonly("err_flag", &Bmad::MakeMat6::err_flag)
      .def("__len__", [](const Bmad::MakeMat6&) { return 2; })
      .def("__getitem__", [](const Bmad::MakeMat6& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.end_orb);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "new_control",
      &Bmad::new_control,
      py::arg("lat"),
      py::arg("ix_ele"),
      py::arg("ele_name") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat used
ix_ele : int
    Index of the new control element
ele_name : unknown, optional
    Name of the new element. Output
)""");
  m.def(
      "set_ele_name",
      &Bmad::set_ele_name,
      py::arg("ele"),
      py::arg("name"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element whose name is to be set.
    This parameter is an input/output and is modified in-place. As an output: Element with name set.
name : unknown
    Name to set.
)""");
  m.def(
      "make_v_mats",
      &Bmad::make_v_mats,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
v_mat : float
    Normal mode to X-Y coords transformation
v_inv_mat : float
    X-Y coords to Normal mode transformation
)""");
  py::class_<Bmad::MakeVMats, std::unique_ptr<Bmad::MakeVMats>>(
      m, "MakeVMats", "Fortran routine make_v_mats return value")
      .def_readonly("v_mat", &Bmad::MakeVMats::v_mat)
      .def_readonly("v_inv_mat", &Bmad::MakeVMats::v_inv_mat)
      .def("__len__", [](const Bmad::MakeVMats&) { return 2; })
      .def("__getitem__", [](const Bmad::MakeVMats& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.v_mat);
        if (i == 1)
          return py::cast(s.v_inv_mat);
        return py::none();
      });
  m.def(
      "twiss_propagate_all",
      &Bmad::twiss_propagate_all,
      py::arg("lat"),
      py::arg("ix_branch") = py::none(),
      py::arg("ie_start") = py::none(),
      py::arg("ie_end") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    lattice. .branch(ix_branch).ele(0) -- Branch beginning element with the starting parameters.
    This parameter is an input/output and is modified in-place. As an output: Lattice with parameters computed
    for the branch.
ix_branch : int, optional
    Branch index. Default is 0 (main lattice).
err_flag : bool
    Set True if there is an error. False otherwise.
ie_start : int, optional
    Starting element index. Default is 0. Note: The first element at which the Twiss parameters are calculated
    is ie_start+1.
ie_end : int, optional
    Ending element index, Default is branch.n_ele_track.
)""");
  m.def(
      "offset_particle",
      &python_offset_particle,
      py::arg("ele"),
      py::arg("set"),
      py::arg("orbit"),
      py::arg("set_tilt") = py::none(),
      py::arg("set_hvkicks") = py::none(),
      py::arg("drift_to_edge") = py::none(),
      py::arg("s_pos") = py::none(),
      py::arg("set_spin") = py::none(),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      py::arg("time") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
set : bool
    T (= set$)   -> Translate from lab coords to the local element coords. F (= unset$) -> Translate back from
    element to lab coords.
orbit : CoordStruct
    Coordinates of the particle.
    This parameter is an input/output and is modified in-place. As an output: Coordinates of particle.
set_tilt : bool, optional
    Default is True. T -> Rotate using ele.value(tilt$) and ele.value(roll$) for sbends. F -> Do not rotate
set_hvkicks : bool, optional
    Default is True. T -> Apply 1/2 any hkick or vkick.
drift_to_edge : int, optional
    no$             -> Do not propagate (drift) particle. no$ is default if s_pos is present. upstream_end$
    -> Propagate to upsteam edge. This is default if set = set$ and s_pos is not present. downstream_end$ ->
    Propagate to downsteam edge. This is default if set = unset$ and s_pos is not present. Note: "edge" is
    body edge if set = set$ and is laboratory (nominal non-misaligned) edge if set = unset$
s_pos : float, optional
    Longitudinal particle position: If set = set$: Relative to upstream end (in lab coords). If set = unset$:
    Relative to entrance end (in body coords).
s_out : float
    Longitudinal particle position. If set = set$: Relative to entrance end (in body coords). If set = unset$:
    Relative to upstream end (in lab coords).
set_spin : bool, optional
    Default if False. Rotate spin coordinates? Also bmad_com.spin_tracking_on must be T to rotate.
mat6 : float, optional
    Transfer matrix before off setting.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    after offsets applied.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
spin_qrot : float
    Spin rotation quaternion
time : float, optional
    Particle time before drifting. Typically this is an RF clock time which may not be equal to orb.t
    This parameter is an input/output and is modified in-place. As an output: Updated time.
)""");
  py::class_<PyOffsetParticle, std::unique_ptr<PyOffsetParticle>>(
      m, "OffsetParticle", "Fortran routine offset_particle return value")
      .def_readonly("s_out", &PyOffsetParticle::s_out)
      .def_readonly("spin_qrot", &PyOffsetParticle::spin_qrot)
      .def_readonly("time", &PyOffsetParticle::time)
      .def("__len__", [](const PyOffsetParticle&) { return 3; })
      .def(
          "__getitem__", [](const PyOffsetParticle& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.s_out);
            if (i == 1)
              return py::cast(s.spin_qrot);
            if (i == 2)
              return py::cast(s.time);
            return py::none();
          });
  m.def(
      "s_calc",
      &Bmad::s_calc,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
)""");
  m.def(
      "cbar_to_c",
      &Bmad::cbar_to_c,
      py::arg("cbar_mat"),
      py::arg("a"),
      py::arg("b"),
      R"""(No docstring available

Parameters
----------
cbar_mat : float
    Cbar matrix.
a : TwissStruct
    a-mode Twiss parameters
b : TwissStruct
    b-mode Twiss parameters
c_mat : float
    C matrix.
)""");
  m.def(
      "choose_quads_for_set_tune",
      &Bmad::choose_quads_for_set_tune,
      py::arg("branch"),
      py::arg("mask") = py::none(),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch.
dk1 : float
    Weights for the quadrupoles. All values will be +1 or -1.
eles : ElePointerStruct
    eles(i).ele points to element with dk1(i) weight.
mask : unknown, optional
    If present, assign weight of zero for all quads that do not match. That is, no variation for matching
    quads.
err_flag : bool
    Set True if there is not one quad with positive dk1 and one quad with negative dk1.
)""");
  py::class_<
      Bmad::ChooseQuadsForSetTune,
      std::unique_ptr<Bmad::ChooseQuadsForSetTune>>(
      m,
      "ChooseQuadsForSetTune",
      "Fortran routine choose_quads_for_set_tune return value")
      .def_readonly("dk1", &Bmad::ChooseQuadsForSetTune::dk1)
      .def_readonly("eles", &Bmad::ChooseQuadsForSetTune::eles)
      .def_readonly("err_flag", &Bmad::ChooseQuadsForSetTune::err_flag)
      .def("__len__", [](const Bmad::ChooseQuadsForSetTune&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ChooseQuadsForSetTune& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dk1);
            if (i == 1)
              return py::cast(s.eles);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "convert_particle_coordinates_s_to_t",
      &Bmad::convert_particle_coordinates_s_to_t,
      py::arg("particle"),
      py::arg("s_body"),
      py::arg("orientation"),
      R"""(No docstring available

Parameters
----------
particle : CoordStruct
    Particle with .vec(:) in s-coords.
s_body : float
    s-position in element body coords.
orientation : int
    ele.orientation for vec(6).
)""");
  m.def(
      "multipass_chain",
      &Bmad::multipass_chain,
      py::arg("ele"),
      py::arg("ix_pass"),
      py::arg("n_links"),
      py::arg("chain_ele") = py::none(),
      py::arg("use_super_lord") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : ElePointerStruct
    Element in a multipass chain.
ix_pass : int
    Multipass pass number of the input element. Set to -1 if input element is not in a multipass section.
n_links : int
    Number of times the physical element is passed through.
chain_ele : ElePointerStruct, optional
    pointers to the elements of the chain. Note: chain_ele(ix_pass).ele => ele
use_super_lord : bool, optional
    If present and True and if ele is a super_slave, construct the chain_ele(:) array using the corresponding
    super_lords. Output
)""");
  m.def(
      "key_name_to_key_index",
      &python_key_name_to_key_index,
      py::arg("key_str"),
      py::arg("abbrev_allowed") = py::none(),
      py::arg("key_index"),
      R"""(No docstring available

Parameters
----------
key_str : unknown
    Name of the key. Result is case insensitive.
abbrev_allowed : bool, optional
    Abbreviations (eg: "quad") allowed? Default is False. At least 3 characters are needed (except for
    rfcavity elements) if True.
key_index : 
)""");
  py::class_<PyKeyNameToKeyIndex, std::unique_ptr<PyKeyNameToKeyIndex>>(
      m,
      "KeyNameToKeyIndex",
      "Fortran routine key_name_to_key_index return value")
      .def_readonly("key_index", &PyKeyNameToKeyIndex::key_index)
      .def("__len__", [](const PyKeyNameToKeyIndex&) { return 1; })
      .def(
          "__getitem__",
          [](const PyKeyNameToKeyIndex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.key_index);
            return py::none();
          });
  m.def(
      "zero_ele_kicks",
      &Bmad::zero_ele_kicks,
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with no kicks.
)""");
  m.def(
      "classical_radius",
      &python_classical_radius,
      py::arg("species"),
      py::arg("radius"),
      R"""(No docstring available

Parameters
----------
species : int
    Species of particle.
radius : 
)""");
  py::class_<PyClassicalRadius, std::unique_ptr<PyClassicalRadius>>(
      m, "ClassicalRadius", "Fortran routine classical_radius return value")
      .def_readonly("radius", &PyClassicalRadius::radius)
      .def("__len__", [](const PyClassicalRadius&) { return 1; })
      .def(
          "__getitem__",
          [](const PyClassicalRadius& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.radius);
            return py::none();
          });
  m.def(
      "canonical_to_angle_coords",
      &Bmad::canonical_to_angle_coords,
      py::arg("orbit"),
      py::arg("coord_type") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Orbit in canonical coordinates.
    This parameter is an input/output and is modified in-place. As an output: Orbit in angular coordinates.
coord_type : unknown, optional
    Angular coordinates type '' (default): (x, x' = dx/ds, y, y' = dy/ds, z, pz) 'ZGOUBI':     (x, x' = dx/ds,
    y, y' = dy/ds, dt = -z / (beta * c), pz)
)""");
  m.def(
      "calc_z_tune",
      &Bmad::calc_z_tune,
      py::arg("branch"),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch
)""");
  m.def(
      "save_a_step",
      &Bmad::save_a_step,
      py::arg("track"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("local_ref_frame"),
      py::arg("orb"),
      py::arg("s_rel"),
      py::arg("save_field") = py::none(),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      py::arg("rf_time") = py::none(),
      py::arg("strong_beam") = py::none(),
      R"""(No docstring available

Parameters
----------
track : TrackStruct
    Track with current position appended on.
ele : EleStruct
    Element being tracked through.
param : LatParamStruct
    Lattice parameters.
local_ref_frame : bool
    If True then input orb is with respect to body coordinates.
orb : CoordStruct
    trajectory at s with respect to element coordinates.
s_rel : float
    Longitudinal position wrt the element. If local_ref_frame = F: Lab coords. If local_ref_frame = T: body
    coords.
save_field : bool, optional
    Save electric and magnetic field values? Default is False.
mat6 : float, optional
    Matrix to store.
make_matrix : bool, optional
    Is mat6 a valid matrix? Default is False.
rf_time : float, optional
    RF clock time used for calculating the field.. If not present then the time will be calculated using the
    standard algorithm. This is only needed if save_field = True.
strong_beam : StrongBeambeamStruct, optional
    Strong beam info if tracking through a beambeam element. Ouput:
)""");
  m.def(
      "g_bending_strength_from_em_field",
      &Bmad::g_bending_strength_from_em_field,
      py::arg("ele"),
      py::arg("param"),
      py::arg("s_rel"),
      py::arg("orbit"),
      py::arg("local_ref_frame"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element being tracked thorugh.
param : LatParamStruct
    Lattice parameters.
s_rel : float
    Distance from the start of the element to the particle.
orbit : CoordStruct
    Particle position in lab (not element) frame.
local_ref_frame : 
    Logical, If True then take the input coordinates and output g as being with respect to the frame of
    referene of the element (ignore misalignments).
g : float
    g = (g_x, g_y, g_s) bending strength vector (|g| = 1/bend_radius).
dg : float
    dg(:)/dr gradient. Takes into account dg_x/dx in a bend due to curvilinear coords.
)""");
  py::class_<
      Bmad::GBendingStrengthFromEmField,
      std::unique_ptr<Bmad::GBendingStrengthFromEmField>>(
      m,
      "GBendingStrengthFromEmField",
      "Fortran routine g_bending_strength_from_em_field return value")
      .def_readonly("g", &Bmad::GBendingStrengthFromEmField::g)
      .def_readonly("dg", &Bmad::GBendingStrengthFromEmField::dg)
      .def(
          "__len__", [](const Bmad::GBendingStrengthFromEmField&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::GBendingStrengthFromEmField& s,
             size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.g);
            if (i == 1)
              return py::cast(s.dg);
            return py::none();
          });
  m.def(
      "multi_turn_tracking_analysis",
      &Bmad::multi_turn_tracking_analysis,
      py::arg("track"),
      py::arg("i_dim"),
      R"""(No docstring available

Parameters
----------
track : CooordStruct
    multi-turn tracking data to analyze. track(i) is the particle position at a given point in the lat on the
    i^th turn.
i_dim : int
    number of dimensions used in the tracking: 2, or 4.
track0 : CoordStruct
    Closed orbit.
ele : EleStruct
    structure holding the 1-turn matrix and Twiss parameters. .mat6        -- Symplectified 1-turn matrix. If
    you want the true non-symplectified 1-turn matrix use the routine multi_turn_tracking_to_mat. .a.beta, etc
    -- a-mode beta,  etc. .a.phi       -- a-mode fractional tune in radians. .a.sigma     -- a-mode amplitude
    = sqrt(ele.a.beta * ele.a.sigma) .c_mat       -- c coupling matrix (only with i_dim = 4)
stable : bool
    Is motion stable?
growth_rate : float
    Unstable growth rate (= 0 if stable).
chi : float
    How symplectic the computed 1-turn matrix is. See mat_symp_check for more details.
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::MultiTurnTrackingAnalysis,
      std::unique_ptr<Bmad::MultiTurnTrackingAnalysis>>(
      m,
      "MultiTurnTrackingAnalysis",
      "Fortran routine multi_turn_tracking_analysis return value")
      .def_readonly("track0", &Bmad::MultiTurnTrackingAnalysis::track0)
      .def_readonly("ele", &Bmad::MultiTurnTrackingAnalysis::ele)
      .def_readonly("stable", &Bmad::MultiTurnTrackingAnalysis::stable)
      .def_readonly(
          "growth_rate", &Bmad::MultiTurnTrackingAnalysis::growth_rate)
      .def_readonly("chi", &Bmad::MultiTurnTrackingAnalysis::chi)
      .def_readonly("err_flag", &Bmad::MultiTurnTrackingAnalysis::err_flag)
      .def("__len__", [](const Bmad::MultiTurnTrackingAnalysis&) { return 6; })
      .def(
          "__getitem__",
          [](const Bmad::MultiTurnTrackingAnalysis& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.track0);
            if (i == 1)
              return py::cast(s.ele);
            if (i == 2)
              return py::cast(s.stable);
            if (i == 3)
              return py::cast(s.growth_rate);
            if (i == 4)
              return py::cast(s.chi);
            if (i == 5)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "orbit_amplitude_calc",
      &Bmad::orbit_amplitude_calc,
      py::arg("ele"),
      py::arg("orb"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element holding the Twiss parameters, dispersion and coupling info.
orb : CoordStruct
    Orbit coordinates at the exit end of ele.
amp_a : float
    a-mode amplitude
amp_b : float
    b-mode amplitude
amp_na : float
    a-mode, energy normalized, amplitude.
amp_nb : float
    b-mode, energy normalized, amplitude.
)""");
  py::class_<
      Bmad::OrbitAmplitudeCalc,
      std::unique_ptr<Bmad::OrbitAmplitudeCalc>>(
      m,
      "OrbitAmplitudeCalc",
      "Fortran routine orbit_amplitude_calc return value")
      .def_readonly("amp_a", &Bmad::OrbitAmplitudeCalc::amp_a)
      .def_readonly("amp_b", &Bmad::OrbitAmplitudeCalc::amp_b)
      .def_readonly("amp_na", &Bmad::OrbitAmplitudeCalc::amp_na)
      .def_readonly("amp_nb", &Bmad::OrbitAmplitudeCalc::amp_nb)
      .def("__len__", [](const Bmad::OrbitAmplitudeCalc&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::OrbitAmplitudeCalc& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.amp_a);
            if (i == 1)
              return py::cast(s.amp_b);
            if (i == 2)
              return py::cast(s.amp_na);
            if (i == 3)
              return py::cast(s.amp_nb);
            return py::none();
          });
  m.def(
      "split_lat",
      &Bmad::split_lat,
      py::arg("lat"),
      py::arg("s_split"),
      py::arg("ix_branch"),
      py::arg("add_suffix") = py::none(),
      py::arg("check_sanity") = py::none(),
      py::arg("save_null_drift") = py::none(),
      py::arg("choose_max") = py::none(),
      py::arg("ix_insert") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Original lat structure.
    This parameter is an input/output and is modified in-place. As an output: Modified lat structure.
s_split : float
    Position at which lat.branch(ix_branch) is to be split.
ix_branch : int
    Index of lat.branch(:) to use.
ix_split : int
    Index of element just before the s = s_split point.
split_done : bool
    True if lat was split.
add_suffix : bool, optional
    If True (default) add '#1' and '#2" suffixes to the split elements.
check_sanity : bool, optional
    If True (default) then call lat_sanity_check after the split to make sure everything is ok.
save_null_drift : bool, optional
    Save a copy of a drift to be split as a null_ele? This is useful when superpositions are done. See
    add_superimpose for more info. Default is False.
err_flag : bool
    Set true if there is an error, false otherwise.
choose_max : bool, optional
    If no splitting of an element is needed, that is, s_split is at an element boundary, there can be multiple
    possible values for ix_split if there exist zero length elements at the split point. If choose_max = True,
    ix_split will be chosen to be the maximum possible index and if choose_max = False ix_split will be chosen
    to be the minimal possible index. If s_split is not at an element boundary, the setting of choose_max is
    immaterial. If ix_insert is present, the default value of choose_max is set to give the closest element to
    ix_insert. If ix_insert is not present, the default value of choose_max is False.
ix_insert : int, optional
    Element index near the point to be split. ix_insert is useful in the case where there is a patch with a
    negative length which can create an ambiguity as to where to do the split In this case ix_insert will
    remove the ambiguity. Also useful to ensure where to split if there are elements with zero length nearby.
    Ignored if negative.
)""");
  py::class_<Bmad::SplitLat, std::unique_ptr<Bmad::SplitLat>>(
      m, "SplitLat", "Fortran routine split_lat return value")
      .def_readonly("ix_split", &Bmad::SplitLat::ix_split)
      .def_readonly("split_done", &Bmad::SplitLat::split_done)
      .def_readonly("err_flag", &Bmad::SplitLat::err_flag)
      .def("__len__", [](const Bmad::SplitLat&) { return 3; })
      .def("__getitem__", [](const Bmad::SplitLat& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ix_split);
        if (i == 1)
          return py::cast(s.split_done);
        if (i == 2)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "default_tracking_species",
      &python_default_tracking_species,
      py::arg("param"),
      py::arg("species"),
      R"""(No docstring available

Parameters
----------
param : LatParamStruct
    Parameters for a lattice branch.
species : 
)""");
  py::class_<
      PyDefaultTrackingSpecies,
      std::unique_ptr<PyDefaultTrackingSpecies>>(
      m,
      "DefaultTrackingSpecies",
      "Fortran routine default_tracking_species return value")
      .def_readonly("species", &PyDefaultTrackingSpecies::species)
      .def("__len__", [](const PyDefaultTrackingSpecies&) { return 1; })
      .def(
          "__getitem__",
          [](const PyDefaultTrackingSpecies& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.species);
            return py::none();
          });
  m.def(
      "transfer_matrix_calc",
      &Bmad::transfer_matrix_calc,
      py::arg("lat"),
      py::arg("xfer_mat"),
      py::arg("xfer_vec") = py::none(),
      py::arg("ix1") = py::none(),
      py::arg("ix2") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("one_turn") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice used in the calculation. .ele(:).mat6  -- Transfer matrices used in the calculation.
xfer_mat : 
xfer_vec : 
ix1 : int, optional
    Element start index for the calculation. Default is 0.
ix2 : int, optional
    Element end index for the calculation. Defaults: If ix1 is not present: ix2 = lat.n_ele_track If ix1 is
    present and lattice is closed: Calculate the one-turn matrix from ix1 back to ix1.
ix_branch : int, optional
    Branch index. Default is 0.
one_turn : bool, optional
    If present and True, and ix1 = ix2, and the lattice is closed: Construct the one-turn matrix from ix1 back
    to ix1. If False, (the default), and ix1 = ix2, mat6 is the unit matrix.
)""");
  m.def(
      "tilt_coords",
      &Bmad::tilt_coords,
      py::arg("tilt_val"),
      py::arg("coord"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
tilt_val : float
    Tilt value (could be the roll value for a bend)
coord : float
    Coordinates of particle before rotation.
    This parameter is an input/output and is modified in-place. As an output: Coordinates of particle after
    rotation.
mat6 : float, optional
    Transfer matrix before tilt.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    after tilt applied.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "make_g_mats",
      &Bmad::make_g_mats,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
g_mat : float
    Normal mode to betaless coords
g_inv_mat : float
    The inverse of G_MAT
)""");
  py::class_<Bmad::MakeGMats, std::unique_ptr<Bmad::MakeGMats>>(
      m, "MakeGMats", "Fortran routine make_g_mats return value")
      .def_readonly("g_mat", &Bmad::MakeGMats::g_mat)
      .def_readonly("g_inv_mat", &Bmad::MakeGMats::g_inv_mat)
      .def("__len__", [](const Bmad::MakeGMats&) { return 2; })
      .def("__getitem__", [](const Bmad::MakeGMats& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.g_mat);
        if (i == 1)
          return py::cast(s.g_inv_mat);
        return py::none();
      });
  m.def(
      "knots_to_string",
      &python_knots_to_string,
      py::arg("x_knot"),
      py::arg("y_knot"),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
x_knot : 
y_knot : 
str : 
)""");
  py::class_<PyKnotsToString, std::unique_ptr<PyKnotsToString>>(
      m, "KnotsToString", "Fortran routine knots_to_string return value")
      .def_readonly("str", &PyKnotsToString::str)
      .def("__len__", [](const PyKnotsToString&) { return 1; })
      .def("__getitem__", [](const PyKnotsToString& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "convert_coords",
      &Bmad::convert_coords,
      py::arg("in_type_str"),
      py::arg("coord_in"),
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
in_type_str : unknown
    type of the input coords.
coord_in : CoordStruct
    Input coordinates.
ele : EleStruct
    Provides the Twiss parameters.
out_type_str : unknown
    type of the output coords.
coord_out : CoordStruct
    Output coordinates.
err_flag : bool
    Set True if there is an error. False otherwise. in_type_str and out_type_str can be: 'LAB'
    {x, x', y, y', z, z'} 'MODE'               {a, a', b, b', z, z'} 'NORMALIZED'         {a_bar, a'_bar,
    b_bar, b'_bar, z_bar, z'_bar} 'ACTION-ANGLE'       {j_a, phi_a, j_b, phi_b, j_z,  phi_z} x_vec = V_mat *
    (a_vec + eta_vec * z') a_bar  =  sqrt(2*j_a) * cos(phi_a) a'_bar = -sqrt(2*j_a) * sin(phi_a) Note: 1) If
    ELE.Z.BETA = 0 then ELE.Z.BETA is set to 1. 2) phases are in radians
)""");
  py::class_<Bmad::ConvertCoords, std::unique_ptr<Bmad::ConvertCoords>>(
      m, "ConvertCoords", "Fortran routine convert_coords return value")
      .def_readonly("out_type_str", &Bmad::ConvertCoords::out_type_str)
      .def_readonly("coord_out", &Bmad::ConvertCoords::coord_out)
      .def_readonly("err_flag", &Bmad::ConvertCoords::err_flag)
      .def("__len__", [](const Bmad::ConvertCoords&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ConvertCoords& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.out_type_str);
            if (i == 1)
              return py::cast(s.coord_out);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "ele_has_nonzero_offset",
      &python_ele_has_nonzero_offset,
      py::arg("ele"),
      py::arg("has_offset"),
      R"""(No docstring available

Parameters
----------
ele : 
has_offset : 
)""");
  py::class_<PyEleHasNonzeroOffset, std::unique_ptr<PyEleHasNonzeroOffset>>(
      m,
      "EleHasNonzeroOffset",
      "Fortran routine ele_has_nonzero_offset return value")
      .def_readonly("has_offset", &PyEleHasNonzeroOffset::has_offset)
      .def("__len__", [](const PyEleHasNonzeroOffset&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEleHasNonzeroOffset& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.has_offset);
            return py::none();
          });
  m.def(
      "insert_element",
      &Bmad::insert_element,
      py::arg("lat"),
      py::arg("insert_ele"),
      py::arg("ix_ele"),
      py::arg("ix_branch") = py::none(),
      py::arg("orbit") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    lattice that will be modified
    This parameter is an input/output and is modified in-place. As an output: lattice with new element
    inserted
insert_ele : EleStruct
    element to insert into the lat
ix_ele : int
    branch.ele(:) index where the new element is inserted.
ix_branch : int, optional
    : branch index for the insertion. Default = 0.
orbit : CoordStruct, optional
    orbit array to enlarge.
    This parameter is an input/output and is modified in-place. As an output: Enlarged orbit array.
)""");
  m.def(
      "set_on_off",
      &Bmad::set_on_off,
      py::arg("key"),
      py::arg("lat"),
      py::arg("switch_"),
      py::arg("orb") = py::none(),
      py::arg("use_ref_orb") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("saved_values") = py::none(),
      py::arg("attribute") = py::none(),
      py::arg("set_val") = py::none(),
      R"""(No docstring available

Parameters
----------
key : int
    Class name of elements to be turned on or off. [quadrupole$, etc.]
lat : LatStruct
    lattice structure holding the elements.
    This parameter is an input/output and is modified in-place. As an output: Modified lattice.
switch : int
    on$            => Turn elements on. If saved_values argument is present, use this. If not present (only
    for logical attributes), set to True. off$           => Turn elements off (but will not store the present
    state). off_and_save$  => Save on/off state and then turn elements off. save_state$    => Save present
    on/off state. No turning on or off is done. restore_state$ => Restore saved on/off state from saved_values
    argument.
orb : CoordStruct, optional
    Needed for lat_make_mat6
use_ref_orb : bool, optional
    If present and true then use ele.map_ref_orb for the reference orbit for calculating .mat6. Default is
    false.
ix_branch : int, optional
    If present then only set for this lattice branch.
saved_values : float, optional
    Element-by element saved values of the component. Must be present if needed (EG if switch =
    restore_state$, etc.).
    This parameter is an input/output and is modified in-place. As an output: Saved values of the component.
attribute : unknown, optional
    Attribute to turn on/off. Eg: 'K2', 'MULTIPOLE_ON', etc. Default is 'IS_ON'. Must be upper case.
set_val : int, optional
    Value to set to. Overrides normal set value.
)""");
  m.def(
      "fringe_here",
      &python_fringe_here,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("particle_at"),
      py::arg("is_here"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
orbit : CoordStruct
    Particle position.
particle_at : int
    Either first_track_edge$ or second_track_edge$.
is_here : 
)""");
  py::class_<PyFringeHere, std::unique_ptr<PyFringeHere>>(
      m, "FringeHere", "Fortran routine fringe_here return value")
      .def_readonly("is_here", &PyFringeHere::is_here)
      .def("__len__", [](const PyFringeHere&) { return 1; })
      .def("__getitem__", [](const PyFringeHere& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_here);
        return py::none();
      });
  m.def(
      "chrom_tune",
      &python_chrom_tune,
      py::arg("lat"),
      py::arg("delta_e"),
      py::arg("target_x"),
      py::arg("target_y"),
      py::arg("err_tol"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to use,
    This parameter is an input/output and is modified in-place. As an output: Lat with sextupole set
delta_e : float
    Delta energy used for the calculation. If 0 then default of 1.0d-4 is used.
    This parameter is an input/output and is modified in-place. As an output: Set to 1.0d-4 if on input
    DELTA_E =< 0.
target_x : float
    Target X Chromaticity
target_y : float
    Target Y Chromaticity
err_tol : float
    Max allowable Error: Error = | X_Target - X_Actual | + | Y_Target -Y_Actual | A good number is: err_tol =
    0.05_rp
err_flag : bool
    .false. if match successful, .true. if failed Fails if takes longer than 100 iterations. If it fails the
    sextupoles are set to the last value calculated. Note: This subroutine assumes the Twiss parameters have
    been computed.
)""");
  py::class_<PyChromTune, std::unique_ptr<PyChromTune>>(
      m, "ChromTune", "Fortran routine chrom_tune return value")
      .def_readonly("err_flag", &PyChromTune::err_flag)
      .def_readonly("delta_e", &PyChromTune::delta_e)
      .def("__len__", [](const PyChromTune&) { return 2; })
      .def("__getitem__", [](const PyChromTune& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        if (i == 1)
          return py::cast(s.delta_e);
        return py::none();
      });
  m.def(
      "multipole_kt_to_ab",
      &Bmad::multipole_kt_to_ab,
      py::arg("knl"),
      py::arg("knsl"),
      py::arg("tn"),
      R"""(No docstring available

Parameters
----------
knl : float
    Normal multitude component.
knsl : float
    Skew multitude component.
tn : float
    Multipole angle.
an : float
    Skew multipole component.
bn : float
    Normal multipole component.
)""");
  py::class_<Bmad::MultipoleKtToAb, std::unique_ptr<Bmad::MultipoleKtToAb>>(
      m, "MultipoleKtToAb", "Fortran routine multipole_kt_to_ab return value")
      .def_readonly("an", &Bmad::MultipoleKtToAb::an)
      .def_readonly("bn", &Bmad::MultipoleKtToAb::bn)
      .def("__len__", [](const Bmad::MultipoleKtToAb&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::MultipoleKtToAb& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.an);
            if (i == 1)
              return py::cast(s.bn);
            return py::none();
          });
  m.def(
      "make_hybrid_lat",
      &Bmad::make_hybrid_lat,
      py::arg("lat_in"),
      py::arg("use_taylor") = py::none(),
      py::arg("orb0_arr") = py::none(),
      R"""(No docstring available

Parameters
----------
lat_in : LatStruct
    Input lattice. .branch(:).ele(:).select  -- Roughly: Set True to keep and False to hybridize. See above.
lat_out : LatStruct
    Lattice with hybrid elements. Note: Lat_out must not be the same actual argument as lat_in.
use_taylor : bool, optional
    If present and True then the hybrid elements will have a taylor series instead of a simple linear matrix.
    If an element to be concatenated has a taylor series then this taylor series will be concatenated with the
    other elements in the hybrid element.
orb0_arr : CoordArrayStruct, optional
    Central orbit for taylor stuff. Each orb0_arr(i).orbit(:) holds the orbit for the i^th lattice branch
)""");
  m.def(
      "twiss_at_start",
      &Bmad::twiss_at_start,
      py::arg("lat"),
      py::arg("ix_branch") = py::none(),
      py::arg("type_out") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat
    This parameter is an input/output and is modified in-place. As an output: Lattice with twiss parameters
    computed.
status : int
    Calculation status: ok$, in_stop_band$, unstable$, or non_symplectic$
ix_branch : int, optional
    Branch to use. Default is 0 (main branch).
type_out : bool, optional
    If True (the default), print an error message If the 1-turn matrix is unstable.
)""");
  m.def(
      "twiss_and_track_from_s_to_s",
      &Bmad::twiss_and_track_from_s_to_s,
      py::arg("branch"),
      py::arg("orbit_start"),
      py::arg("s_end"),
      py::arg("ele_start") = py::none(),
      py::arg("compute_floor_coords") = py::none(),
      py::arg("compute_twiss") = py::none(),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch to track through.
orbit_start : CoordStruct
    Starting phase space coordinates at s_start. .s                     -- Starting position. .ix_ele
    -- Starting element. .location              -- Location relative element.
s_end : float
    Ending position.
orbit_end : CoordStruct
    End phase space coordinates.
ele_start : EleStruct, optional
    Holds the starting parameters at s_start.
ele_end : EleStruct
    Holds the ending Twiss parameters and the transfer matrix. If present then the ele_start argument must
    also be present.
err : bool
    Set True if there is a problem like the particle gets lost in tracking
compute_floor_coords : bool, optional
    If present and True then the global "floor" coordinates will be calculated and put in ele_end.floor.
compute_twiss : bool, optional
    Default True. If False, to save a little time, do not compute Twiss parameters.
)""");
  py::class_<
      Bmad::TwissAndTrackFromSToS,
      std::unique_ptr<Bmad::TwissAndTrackFromSToS>>(
      m,
      "TwissAndTrackFromSToS",
      "Fortran routine twiss_and_track_from_s_to_s return value")
      .def_readonly("orbit_end", &Bmad::TwissAndTrackFromSToS::orbit_end)
      .def_readonly("ele_end", &Bmad::TwissAndTrackFromSToS::ele_end)
      .def_readonly("err", &Bmad::TwissAndTrackFromSToS::err)
      .def("__len__", [](const Bmad::TwissAndTrackFromSToS&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::TwissAndTrackFromSToS& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.orbit_end);
            if (i == 1)
              return py::cast(s.ele_end);
            if (i == 2)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "set_twiss",
      &Bmad::set_twiss,
      py::arg("branch"),
      py::arg("twiss_ele"),
      py::arg("ix_ele"),
      py::arg("match_deta_ds"),
      py::arg("err_flag"),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Branch to modify.
twiss_ele : EleStruct
    Element with desired Twiss parameters.
ix_ele : int
    Match branch.ele(ix_ele) Twiss to twiss_ele.
match_deta_ds : bool
    If True, match deta_ds. If False, match etap.
err_flag : bool
    Set True if there is an error. False otherwise.
print_err : bool, optional
    Print an error message if there is an error? Default is True.
)""");
  m.def(
      "do_mode_flip",
      &Bmad::do_mode_flip,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Starting Element
    This parameter is an input/output and is modified in-place. As an output: Flipped element
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "ele_unique_name",
      &python_ele_unique_name,
      py::arg("ele"),
      py::arg("order"),
      py::arg("unique_name"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to construct a unique name for.
order : LatEleOrderStruct
    Information on element ordering. Before calling this routine, use the routine ele_order_calc to compute
    this argument.
unique_name : 
)""");
  py::class_<PyEleUniqueName, std::unique_ptr<PyEleUniqueName>>(
      m, "EleUniqueName", "Fortran routine ele_unique_name return value")
      .def_readonly("unique_name", &PyEleUniqueName::unique_name)
      .def("__len__", [](const PyEleUniqueName&) { return 1; })
      .def("__getitem__", [](const PyEleUniqueName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.unique_name);
        return py::none();
      });
  m.def(
      "track_from_s_to_s",
      &Bmad::track_from_s_to_s,
      py::arg("lat"),
      py::arg("s_start"),
      py::arg("s_end"),
      py::arg("orbit_start"),
      py::arg("ix_branch") = py::none(),
      py::arg("ix_ele_end") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to track through
s_start : float
    Starting s-position.
s_end : float
    Ending s-position. If <= s_start then will wrap
orbit_start : CoordStruct
    Starting coordinates.
orbit_end : CoordStruct
    Ending coordinates.
all_orb : CoordStruct
    If present then the orbit at the exit ends of the elements tracked through will be recorded in this
    structure.
ix_branch : int, optional
    Lattice branch index. Default is 0 (main branch).
track_state : int
    Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
ix_ele_end : int, optional
    If present, ignore s_end and track to in between ix_ele_end and ix_ele_end+1
)""");
  py::class_<Bmad::TrackFromSToS, std::unique_ptr<Bmad::TrackFromSToS>>(
      m, "TrackFromSToS", "Fortran routine track_from_s_to_s return value")
      .def_readonly("orbit_end", &Bmad::TrackFromSToS::orbit_end)
      .def_readonly("all_orb", &Bmad::TrackFromSToS::all_orb)
      .def_readonly("track_state", &Bmad::TrackFromSToS::track_state)
      .def("__len__", [](const Bmad::TrackFromSToS&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::TrackFromSToS& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.orbit_end);
            if (i == 1)
              return py::cast(s.all_orb);
            if (i == 2)
              return py::cast(s.track_state);
            return py::none();
          });
  m.def(
      "pointer_to_girder",
      &Bmad::pointer_to_girder,
      py::arg("ele"),
      py::arg("girder"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to check.
ix_slave_back : int
    Index back to ele. That is, pointer_to_slave(girder, ix_slave_back) will point back to ele. Set to -1 if
    no girder present
girder : 
)""");
  m.def(
      "lat_compute_ref_energy_and_time",
      &Bmad::lat_compute_ref_energy_and_time,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Input lattice. .ele(0).value(E_tot$) -- Energy at the start of the lattice.
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "ele_compute_ref_energy_and_time",
      &Bmad::ele_compute_ref_energy_and_time,
      py::arg("ele0"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
ele0 : EleStruct
    Previous element in lattice with starting energy and time values.
ele : EleStruct
    Lattice element .time_ref_orb_in  -- Starting orbit for ref time calc.
    This parameter is an input/output and is modified in-place. As an output: Lattice element with reference
    energy and time.
param : LatParamStruct
    Lattice parameters.
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "get_slave_list",
      &Bmad::get_slave_list,
      py::arg("lord"),
      R"""(No docstring available

Parameters
----------
lord : EleStruct
    The lord element.
slaves : ElePointerStruct
    : Array of slaves.
n_slave : int
    Number of slaves.
)""");
  py::class_<Bmad::GetSlaveList, std::unique_ptr<Bmad::GetSlaveList>>(
      m, "GetSlaveList", "Fortran routine get_slave_list return value")
      .def_readonly("slaves", &Bmad::GetSlaveList::slaves)
      .def_readonly("n_slave", &Bmad::GetSlaveList::n_slave)
      .def("__len__", [](const Bmad::GetSlaveList&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::GetSlaveList& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.slaves);
            if (i == 1)
              return py::cast(s.n_slave);
            return py::none();
          });
  m.def(
      "ele_value_has_changed",
      &python_ele_value_has_changed,
      py::arg("ele"),
      py::arg("list"),
      py::arg("abs_tol"),
      py::arg("set_old"),
      py::arg("has_changed"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element under consideration.
    This parameter is an input/output and is modified in-place. As an output: ele.old_value may be set
    depending upon setting of set_old
list : int
    List of indexes of ele.value(:) array to check.
abs_tol : float
    List of values such that if the change in parameter value is less than this it is not considered to have
    changed significantly.
set_old : bool
    If True then set ele.old_value(j) = ele.value(j) for j in list
has_changed : 
)""");
  py::class_<PyEleValueHasChanged, std::unique_ptr<PyEleValueHasChanged>>(
      m,
      "EleValueHasChanged",
      "Fortran routine ele_value_has_changed return value")
      .def_readonly("has_changed", &PyEleValueHasChanged::has_changed)
      .def("__len__", [](const PyEleValueHasChanged&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEleValueHasChanged& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.has_changed);
            return py::none();
          });
  m.def(
      "set_orbit_to_zero",
      &Bmad::set_orbit_to_zero,
      py::arg("n1"),
      py::arg("n2"),
      py::arg("ix_noset") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Array with particle positions in the range orbit(n1:n2) set to zero except for orbit(ix_noset).
n1 : int
    Lower bound of orbit(:) array subset.
n2 : int
    Upper bound of orbit(:) array subset.
ix_noset : int, optional
    If present then orbit(ix_noset) will not be zeroed.
)""");
  m.def(
      "significant_difference",
      &python_significant_difference,
      py::arg("value1"),
      py::arg("value2"),
      py::arg("abs_tol") = py::none(),
      py::arg("rel_tol") = py::none(),
      py::arg("is_different"),
      R"""(No docstring available

Parameters
----------
value1 : float
    First value.
value2 : float
    Second value.
abs_tol : float, optional
    Absolute tolerance. Default is 0.
rel_tol : float, optional
    Relative tolerance. Default is 0.
is_different : 
)""");
  py::class_<PySignificantDifference, std::unique_ptr<PySignificantDifference>>(
      m,
      "SignificantDifference",
      "Fortran routine significant_difference return value")
      .def_readonly("is_different", &PySignificantDifference::is_different)
      .def("__len__", [](const PySignificantDifference&) { return 1; })
      .def(
          "__getitem__",
          [](const PySignificantDifference& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_different);
            return py::none();
          });
  m.def(
      "value_of_attribute",
      &python_value_of_attribute,
      py::arg("ele"),
      py::arg("attrib_name"),
      py::arg("err_print_flag") = py::none(),
      py::arg("err_value") = py::none(),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    After this routine finishes Ptr_attrib will point to a variable within this element.
attrib_name : unknown
    Name of attribute. Must be uppercase. For example: "HKICK".
err_flag : bool
    Set True if attribtute not found. False otherwise.
err_print_flag : bool, optional
    If present and True then print an error message if there is an  error.
err_value : float, optional
    Value to set value argument if there is an error. Default is 0.
value : 
)""");
  py::class_<PyValueOfAttribute, std::unique_ptr<PyValueOfAttribute>>(
      m, "ValueOfAttribute", "Fortran routine value_of_attribute return value")
      .def_readonly("err_flag", &PyValueOfAttribute::err_flag)
      .def_readonly("value", &PyValueOfAttribute::value)
      .def("__len__", [](const PyValueOfAttribute&) { return 2; })
      .def(
          "__getitem__",
          [](const PyValueOfAttribute& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "elec_multipole_field",
      &Bmad::elec_multipole_field,
      py::arg("a"),
      py::arg("b"),
      py::arg("n"),
      py::arg("coord"),
      R"""(No docstring available

Parameters
----------
a : float
    Multipole skew component.
b : float
    Multipole normal component.
n : float
    Multipole order.
coord : CoordStruct
Ex : float
    X field component
Ey : float
    Y field component.
dE : float
    Field derivatives: dfield(x,y)/d(x,y).
compute_dE : bool
    If False, do not compute the field derivatives even if dE is present. Default is True.
)""");
  py::class_<
      Bmad::ElecMultipoleField,
      std::unique_ptr<Bmad::ElecMultipoleField>>(
      m,
      "ElecMultipoleField",
      "Fortran routine elec_multipole_field return value")
      .def_readonly("Ex", &Bmad::ElecMultipoleField::Ex)
      .def_readonly("Ey", &Bmad::ElecMultipoleField::Ey)
      .def_readonly("dE", &Bmad::ElecMultipoleField::dE)
      .def_readonly("compute_dE", &Bmad::ElecMultipoleField::compute_dE)
      .def("__len__", [](const Bmad::ElecMultipoleField&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::ElecMultipoleField& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.Ex);
            if (i == 1)
              return py::cast(s.Ey);
            if (i == 2)
              return py::cast(s.dE);
            if (i == 3)
              return py::cast(s.compute_dE);
            return py::none();
          });
  m.def(
      "equivalent_taylor_attributes",
      &python_equivalent_taylor_attributes,
      py::arg("ele_taylor"),
      py::arg("ele2"),
      py::arg("equiv"),
      R"""(No docstring available

Parameters
----------
ele_taylor : EleStruct
    Element with a Taylor map
ele2 : EleStruct
    Element that might receive the Taylor map from ele_taylor.
equiv : 
)""");
  py::class_<
      PyEquivalentTaylorAttributes,
      std::unique_ptr<PyEquivalentTaylorAttributes>>(
      m,
      "EquivalentTaylorAttributes",
      "Fortran routine equivalent_taylor_attributes return value")
      .def_readonly("equiv", &PyEquivalentTaylorAttributes::equiv)
      .def("__len__", [](const PyEquivalentTaylorAttributes&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEquivalentTaylorAttributes& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.equiv);
            return py::none();
          });
  m.def(
      "num_lords",
      &python_num_lords,
      py::arg("slave"),
      py::arg("lord_type"),
      py::arg("num"),
      R"""(No docstring available

Parameters
----------
slave : EleStruct
    Slave element.
lord_type : int
    Type of lord. super_lord$, multipass_lord$, girder_lord$, group_lord$, overlay_lord$, and governor$ (=
    group + overlay + control + girder)
num : 
)""");
  py::class_<PyNumLords, std::unique_ptr<PyNumLords>>(
      m, "NumLords", "Fortran routine num_lords return value")
      .def_readonly("num", &PyNumLords::num)
      .def("__len__", [](const PyNumLords&) { return 1; })
      .def("__getitem__", [](const PyNumLords& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.num);
        return py::none();
      });
  m.def(
      "taper_mag_strengths",
      &python_taper_mag_strengths,
      py::arg("lat"),
      py::arg("ref_lat") = py::none(),
      py::arg("except") = py::none(),
      py::arg("err_flag") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to vary.
    This parameter is an input/output and is modified in-place. As an output: Lattice with magnet strengths
    varied.
ref_lat : LatStruct, optional
    Reference lattice. If not present, lat will be used as the ref.
except : unknown, optional
    List of elements not to vary.
err_flag : 
)""");
  py::class_<PyTaperMagStrengths, std::unique_ptr<PyTaperMagStrengths>>(
      m,
      "TaperMagStrengths",
      "Fortran routine taper_mag_strengths return value")
      .def_readonly("err_flag", &PyTaperMagStrengths::err_flag)
      .def("__len__", [](const PyTaperMagStrengths&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaperMagStrengths& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "twiss_propagate1",
      &Bmad::twiss_propagate1,
      py::arg("ele1"),
      py::arg("ele2"),
      py::arg("forward") = py::none(),
      R"""(No docstring available

Parameters
----------
ele1 : EleStruct
    Element holding the starting Twiss parameters for forwards propagation.
    This parameter is an input/output and is modified in-place. As an output: Element for the ending Twiss
    parameters for backwards propagation.
ele2 : EleStruct
    Element holding the transfer matrix and, if backwards propagation, the starting Twiss. .key
    -- Needed since, for example, Match element are handled differently from other elements. .map_ref_orb_in
    -- Important for the dispersion calc. .map_ref_orb_out    -- Important for the dispersion calc.
    This parameter is an input/output and is modified in-place. As an output: Element for the ending Twiss
    parameters for forward propagation.
err_flag : bool
    Set True if there is an error. False otherwise.
forward : bool, optional
    Default is True. If false, propagate the Twiss backwards.
)""");
  m.def(
      "twiss1_propagate",
      &Bmad::twiss1_propagate,
      py::arg("twiss1"),
      py::arg("mat2"),
      py::arg("ele_key"),
      py::arg("length"),
      R"""(No docstring available

Parameters
----------
twiss1 : TwissStruct
    Input Twiss parameters.
mat2 : float
    The transfer matrix.
ele_key : int
    quadrupole$, etc.
length : float
    Determines whether the phase is increasing or decreasing.
twiss2 : TwissStruct
    Output Twiss parameters.
err : bool
    Set True if there is an error, false otherwise.
)""");
  py::class_<Bmad::Twiss1Propagate, std::unique_ptr<Bmad::Twiss1Propagate>>(
      m, "Twiss1Propagate", "Fortran routine twiss1_propagate return value")
      .def_readonly("twiss2", &Bmad::Twiss1Propagate::twiss2)
      .def_readonly("err", &Bmad::Twiss1Propagate::err)
      .def("__len__", [](const Bmad::Twiss1Propagate&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::Twiss1Propagate& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.twiss2);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "lat_sanity_check",
      &Bmad::lat_sanity_check,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to check
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "lat_make_mat6",
      &Bmad::lat_make_mat6,
      py::arg("lat"),
      py::arg("ix_ele") = py::none(),
      py::arg("ref_orb") = py::none(),
      py::arg("ix_branch") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat containing the elements.
ix_ele : int, optional
    Index of the element. If not present or negative, the matrices for all elements will be calculated.
ref_orb : CoordStruct, optional
    Coordinates of the reference orbit around which the matrix is calculated. If not present then the
    referemce is taken to be the origin.
ix_branch : int, optional
    Branch index. Default is 0 (main lattice). -1 => All branches/all elements (ref_orb & ix_ele will be
    ignored).
err_flag : bool
    True if there is an error. False otherwise.
)""");
  m.def(
      "map_to_angle_coords",
      &Bmad::map_to_angle_coords,
      py::arg("t_canon"),
      R"""(No docstring available

Parameters
----------
t_canon : TaylorStruct
    Taylor map in canonical coords.
t_angle : TaylorStruct
    Taylor map in angle coords.
)""");
  m.def(
      "set_z_tune",
      &Bmad::set_z_tune,
      py::arg("branch"),
      py::arg("z_tune"),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
z_tune : float
    Longitudinal tune in radians (must be negative above transition).
ok : bool
    If present, returns true or false if set was successful. If not present, set_z_tune will bomb if tune
    could not be set. Notes: 1) The calculation assumes that Q_z < 1. 2) By convention a positive tune
    signifies a clockwise rotation in phase space so that the transverse tunes are positive. This means the
    longitudinal tune is negative above transition.
print_err : bool, optional
    Default is True. If False, suppress error messages
)""");
  m.def(
      "track_many",
      &Bmad::track_many,
      py::arg("lat"),
      py::arg("orbit"),
      py::arg("ix_start"),
      py::arg("ix_end"),
      py::arg("direction"),
      py::arg("ix_branch") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to track through.
orbit : CoordStruct
    Coordinates at start of tracking.
    This parameter is an input/output and is modified in-place. As an output: Orbit.
ix_start : int
    Start index (See Note).
ix_end : int
    End index (See Note).
direction : int
    Direction to track. = +1 -> Track forward (+s) = -1 -> Track backward (-s)
ix_branch : int, optional
    Branch to track. Default is 0 (main lattice).
track_state : int
    Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
)""");
  m.def(
      "particle_is_moving_backwards",
      &python_particle_is_moving_backwards,
      py::arg("orbit"),
      py::arg("is_moving_backwards"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle coordinates
is_moving_backwards : 
)""");
  py::class_<
      PyParticleIsMovingBackwards,
      std::unique_ptr<PyParticleIsMovingBackwards>>(
      m,
      "ParticleIsMovingBackwards",
      "Fortran routine particle_is_moving_backwards return value")
      .def_readonly(
          "is_moving_backwards",
          &PyParticleIsMovingBackwards::is_moving_backwards)
      .def("__len__", [](const PyParticleIsMovingBackwards&) { return 1; })
      .def(
          "__getitem__",
          [](const PyParticleIsMovingBackwards& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_moving_backwards);
            return py::none();
          });
  m.def(
      "valid_fringe_type",
      &python_valid_fringe_type,
      py::arg("ele"),
      py::arg("fringe_type"),
      py::arg("is_valid"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
fringe_type : int
    bmad_standard$, etc.
is_valid : 
)""");
  py::class_<PyValidFringeType, std::unique_ptr<PyValidFringeType>>(
      m, "ValidFringeType", "Fortran routine valid_fringe_type return value")
      .def_readonly("is_valid", &PyValidFringeType::is_valid)
      .def("__len__", [](const PyValidFringeType&) { return 1; })
      .def(
          "__getitem__",
          [](const PyValidFringeType& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "lat_ele_locator",
      &python_lat_ele_locator,
      py::arg("loc_str"),
      py::arg("lat"),
      py::arg("eles"),
      py::arg("n_loc"),
      py::arg("above_ubound_is_err") = py::none(),
      py::arg("ix_dflt_branch") = py::none(),
      py::arg("order_by_index") = py::none(),
      py::arg("append_eles") = py::none(),
      R"""(No docstring available

Parameters
----------
loc_str : unknown
    Element names or indexes. May be lower case.
lat : LatStruct
    Lattice to search through.
eles : ElePointerStruct
    If append_eles is True, save existing elements.
    This parameter is an input/output and is modified in-place. As an output: Array of matching elements.
n_loc : int
    Number of existing elements. Used if append_eles is True.
    This parameter is an input/output and is modified in-place. As an output: Number of locations found.
err : bool
    Set True if there is a decode error. Note: Not finding any matching element is not an error.
above_ubound_is_err : bool, optional
    Default is True. If the upper bound "e2" on an "e1:e2" range construct -- logical, optional: Default is
    True. If the upper bound "e2" on an "e1:e2" range construct is an integer and above the maximum element
    index then treat this as an error? If False, treat e2 as the maximum element index.
ix_dflt_branch : int, optional
    If present and not -1 then restrict search to specified branch. If not present or -1: Search all branches.
    Exception: For elements specified using an integer index (EG: "43"), if ix_dflt_branch is not present or
    -1 use branch 0.
order_by_index : bool, optional
    False is default. If True, order a component of loc_str like "quad::*" by element index instead of
    longitudinal s-position. Index ordering and s-position ordering are different when there are super lords
    and super slaves.
append_eles : bool, optional
    Default is False. If True, found elements are appended to eles(:) array.
)""");
  py::class_<PyLatEleLocator, std::unique_ptr<PyLatEleLocator>>(
      m, "LatEleLocator", "Fortran routine lat_ele_locator return value")
      .def_readonly("err", &PyLatEleLocator::err)
      .def_readonly("n_loc", &PyLatEleLocator::n_loc)
      .def("__len__", [](const PyLatEleLocator&) { return 2; })
      .def("__getitem__", [](const PyLatEleLocator& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err);
        if (i == 1)
          return py::cast(s.n_loc);
        return py::none();
      });
  m.def(
      "stream_ele_end",
      &python_stream_ele_end,
      py::arg("physical_end"),
      py::arg("ele_orientation"),
      py::arg("stream_end"),
      R"""(No docstring available

Parameters
----------
physical_end : int
    entrance_end$, exit_end$, surface$, etc.
ele_orientation : int
    Either 1 = Normal or -1 = element reversed.
stream_end : 
)""");
  py::class_<PyStreamEleEnd, std::unique_ptr<PyStreamEleEnd>>(
      m, "StreamEleEnd", "Fortran routine stream_ele_end return value")
      .def_readonly("stream_end", &PyStreamEleEnd::stream_end)
      .def("__len__", [](const PyStreamEleEnd&) { return 1; })
      .def("__getitem__", [](const PyStreamEleEnd& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.stream_end);
        return py::none();
      });
  m.def(
      "init_taylor_series",
      &Bmad::init_taylor_series,
      py::arg("bmad_taylor"),
      py::arg("n_term"),
      py::arg("save_old") = py::none(),
      R"""(No docstring available

Parameters
----------
bmad_taylor : TaylorStruct
    Old structure.
    This parameter is an input/output and is modified in-place. As an output: Initalized structure.
n_term : int
    Number of terms to allocate. n_term < 0 => bmad_taylor.term pointer will be disassociated.
save_old : bool, optional
    If True then save any old terms and ref orbit when bmad_taylor is resized. If False zero the ref orbit.
    Default is False.
)""");
  m.def(
      "valid_mat6_calc_method",
      &python_valid_mat6_calc_method,
      py::arg("ele"),
      py::arg("species"),
      py::arg("mat6_calc_method"),
      py::arg("is_valid"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
species : 
    Type of particle being tracked. electron$, etc. or not_set$
mat6_calc_method : int
    bmad_standard$, etc.
is_valid : 
)""");
  py::class_<PyValidMat6CalcMethod, std::unique_ptr<PyValidMat6CalcMethod>>(
      m,
      "ValidMat6CalcMethod",
      "Fortran routine valid_mat6_calc_method return value")
      .def_readonly("is_valid", &PyValidMat6CalcMethod::is_valid)
      .def("__len__", [](const PyValidMat6CalcMethod&) { return 1; })
      .def(
          "__getitem__",
          [](const PyValidMat6CalcMethod& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "e_accel_field",
      &python_e_accel_field,
      py::arg("ele"),
      py::arg("voltage_or_gradient"),
      py::arg("bmad_standard_tracking") = py::none(),
      py::arg("field"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lcavity or rfcavity element.
voltage_or_gradient : int
    voltage$ or gradient$
bmad_standard_tracking : bool, optional
    Using bmad_standard tracking? Default is False.
field : 
)""");
  py::class_<PyEAccelField, std::unique_ptr<PyEAccelField>>(
      m, "EAccelField", "Fortran routine e_accel_field return value")
      .def_readonly("field", &PyEAccelField::field)
      .def("__len__", [](const PyEAccelField&) { return 1; })
      .def("__getitem__", [](const PyEAccelField& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.field);
        return py::none();
      });
  m.def(
      "apply_all_rampers",
      &Bmad::apply_all_rampers,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice.
    This parameter is an input/output and is modified in-place. As an output: Lattice with rampers applied.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "convert_pc_to",
      &Bmad::convert_pc_to,
      py::arg("pc"),
      py::arg("particle"),
      R"""(No docstring available

Parameters
----------
pc : float
    Particle momentum
particle : int
    Type of particle. positron$, etc.
E_tot : float
    Total energy of the particle.
gamma : float
    Gamma factor.
kinetic : float
    Kinetic energy
beta : float
    velocity / c_light
brho : float
    Nominal B_field*rho_bend
beta1 : float
    1 - beta. Equal to 1/(2*gamma^2) in ultra-rel limit.
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  py::class_<Bmad::ConvertPcTo, std::unique_ptr<Bmad::ConvertPcTo>>(
      m, "ConvertPcTo", "Fortran routine convert_pc_to return value")
      .def_readonly("E_tot", &Bmad::ConvertPcTo::E_tot)
      .def_readonly("gamma", &Bmad::ConvertPcTo::gamma)
      .def_readonly("kinetic", &Bmad::ConvertPcTo::kinetic)
      .def_readonly("beta", &Bmad::ConvertPcTo::beta)
      .def_readonly("brho", &Bmad::ConvertPcTo::brho)
      .def_readonly("beta1", &Bmad::ConvertPcTo::beta1)
      .def_readonly("err_flag", &Bmad::ConvertPcTo::err_flag)
      .def("__len__", [](const Bmad::ConvertPcTo&) { return 7; })
      .def(
          "__getitem__",
          [](const Bmad::ConvertPcTo& s, size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.E_tot);
            if (i == 1)
              return py::cast(s.gamma);
            if (i == 2)
              return py::cast(s.kinetic);
            if (i == 3)
              return py::cast(s.beta);
            if (i == 4)
              return py::cast(s.brho);
            if (i == 5)
              return py::cast(s.beta1);
            if (i == 6)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "radiation_integrals",
      &python_radiation_integrals,
      py::arg("lat"),
      py::arg("orbit"),
      py::arg("ix_cache") = py::none(),
      py::arg("ix_branch") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to use. The calculation assumes that the Twiss parameters have been calculated.
orbit : CoordStruct
    Closed orbit for the branch.
mode : NormalModesStruct
    Parameters for the ("horizontal like") a-mode, ("vertical like") b-mode, and the z-mode .synch_int(0:3) --
    Synchrotron integrals. See Bmad manual .sigE_E         -- Sigma_E/E energy spread .sig_z          -- Bunch
    Length .e_loss         -- Energy loss in eV per turn .a, .b, .z      -- Anormal_mode_struct: Substructure
    .emittance      -- Emittance. B-mode emit includes photon opening angle (I6) contribution. .synch_int(4:6)
    -- Synchrotron integrals .j_damp         -- Damping partition factor .alpha_damp     -- Exponential
    damping coefficient per turn .lin            -- Linac version of the integrals. .i2_E4           --
    Integral: g^2 * gamma^4 .i3_E7           -- Integral: g^3 * gamma^7 .i5a_E6          -- Integral: (g^3 *
    H_a) * gamma^6 .i5b_E6          -- Integral: (g^3 * H_b) * gamma^6 .sig_E1          -- Energy spread after
    1 pass (eV) .a_emittance_end -- a-mode emittance at end of linac .b_emittance_end -- b-mode emittance at
    end of linac
ix_cache : int, optional
    Cache pointer. = -2 --> No temporary wiggler cache. This is slow so only use as a check. = -1 --> Use
    temporary cache for wiggler elements only (default). =  0 --> Create a new cache for all elements. >  0
    --> Use the corresponding cache.
    This parameter is an input/output and is modified in-place. As an output: Cache pointer. If ix_cache = 0
    at input then
ix_branch : int, optional
    Lattice branch index. Default is 0.
rad_int_by_ele : RadIntAllEleStruct
    Radiation integrals element by element. .branch(ix_branch).ele(0:) -- Array of rad_int1_struct structures,
    one for each element in the branch. Notes: 1) .synch_int(1) = momentum_compaction * lat_length 2) The
    lin_norm_emit values are running sums from the beginning of the lattice and include the beginning
    emittance stored in lat.a.emit and lat.b.emit.
)""");
  py::class_<PyRadiationIntegrals, std::unique_ptr<PyRadiationIntegrals>>(
      m,
      "RadiationIntegrals",
      "Fortran routine radiation_integrals return value")
      .def_readonly("mode", &PyRadiationIntegrals::mode)
      .def_readonly("rad_int_by_ele", &PyRadiationIntegrals::rad_int_by_ele)
      .def_readonly("ix_cache", &PyRadiationIntegrals::ix_cache)
      .def("__len__", [](const PyRadiationIntegrals&) { return 3; })
      .def(
          "__getitem__",
          [](const PyRadiationIntegrals& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.mode);
            if (i == 1)
              return py::cast(s.rad_int_by_ele);
            if (i == 2)
              return py::cast(s.ix_cache);
            return py::none();
          });
  m.def(
      "lattice_bookkeeper",
      &Bmad::lattice_bookkeeper,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice needing bookkeeping.
    This parameter is an input/output and is modified in-place. As an output: Lattice with bookkeeping done.
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "combine_consecutive_elements",
      &Bmad::combine_consecutive_elements,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice.
    This parameter is an input/output and is modified in-place. As an output: Lattice with elements combined.
error : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "transfer_mat_from_twiss",
      &Bmad::transfer_mat_from_twiss,
      py::arg("ele1"),
      py::arg("ele2"),
      py::arg("orb1"),
      py::arg("orb2"),
      R"""(No docstring available

Parameters
----------
ele1 : EleStruct
    Element with twiss parameters for the starting point. .a, .b       -- a-mode and b-mode Twiss paramters
    .beta         -- Beta parameter. .alpha        -- Alpha parameter. .phi          -- Phase at initial
    point. .x, .y       -- dispersion values .eta          -- Dispersion at initial point. .etap         --
    Dispersion derivative at initial point. .c_mat(2,2)  -- Coupling matrix
ele2 : EleStruct
    Element with twiss parameters for the ending point.
orb1 : float
    Reference orbit at ele1 (affects m(i,6) dispersion terms).
orb2 : float
    Reference orbit at ele2 (affects m(i,6) dispersion terms).
m : float
    Transfer matrix between the two points.
)""");
  m.def(
      "remove_eles_from_lat",
      &Bmad::remove_eles_from_lat,
      py::arg("lat"),
      py::arg("check_sanity") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to compress.
    This parameter is an input/output and is modified in-place. As an output: Compressed lattice.
check_sanity : bool, optional
    If True (default) then call lat_sanity_check
)""");
  m.def(
      "ele_has_nonzero_kick",
      &python_ele_has_nonzero_kick,
      py::arg("has_kick"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with no kicks.
has_kick : 
)""");
  py::class_<PyEleHasNonzeroKick, std::unique_ptr<PyEleHasNonzeroKick>>(
      m,
      "EleHasNonzeroKick",
      "Fortran routine ele_has_nonzero_kick return value")
      .def_readonly("ele", &PyEleHasNonzeroKick::ele)
      .def_readonly("has_kick", &PyEleHasNonzeroKick::has_kick)
      .def("__len__", [](const PyEleHasNonzeroKick&) { return 2; })
      .def(
          "__getitem__",
          [](const PyEleHasNonzeroKick& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ele);
            if (i == 1)
              return py::cast(s.has_kick);
            return py::none();
          });
  m.def(
      "slice_lattice",
      &Bmad::slice_lattice,
      py::arg("lat"),
      py::arg("ele_list"),
      py::arg("do_bookkeeping") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to slice.
    This parameter is an input/output and is modified in-place. As an output: Lattice with unwanted elements
    sliced out.
ele_list : unknown
    List of elements to retain. See the documentation for the lat_ele_locator routine for the syntax of the
    list.
error : bool
    Set True if there is an error Set False if not.
do_bookkeeping : bool, optional
    Default is True. If false, the calling routine is responsible for: * Modifying lat.particle_start if
    needed. * Calculating Twiss functions.
)""");
  m.def(
      "particle_rf_time",
      &python_particle_rf_time,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("reference_active_edge") = py::none(),
      py::arg("s_rel") = py::none(),
      py::arg("time_coords") = py::none(),
      py::arg("rf_freq") = py::none(),
      py::arg("abs_time") = py::none(),
      py::arg("time"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle coordinates
ele : EleStruct
    Element being tracked through.
reference_active_edge : bool
    If True, and ele is a rfcavity or lcavity, use the active edge (edge of the -- logical: If True, and ele
    is a rfcavity or lcavity, use the active edge (edge of the region with non-zero field) as the reference
    point.
s_rel : float, optional
    Longitudinal position relative to the upstream edge of the element. Needed for relative time tracking when
    the particle is inside the element. Default is 0.
time_coords : bool, optional
    Default False. If True then orbit is using time based phase space coordinates.
rf_freq : float, optional
    If present, the returned time shifted by an integer multiple of 1/rf_freq to be in the range
    [-1/2*rf_freq, 1/2*rf_freq]. This is useful to avoid round-off errors.
abs_time : float, optional
    If False (default) use setting of bmad_com.absolute_time_tracking. If True, use absolute time instead of
    relative time. Ouput:
time : 
)""");
  py::class_<PyParticleRfTime, std::unique_ptr<PyParticleRfTime>>(
      m, "ParticleRfTime", "Fortran routine particle_rf_time return value")
      .def_readonly("time", &PyParticleRfTime::time)
      .def("__len__", [](const PyParticleRfTime&) { return 1; })
      .def(
          "__getitem__", [](const PyParticleRfTime& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.time);
            return py::none();
          });
  m.def(
      "branch_name",
      &python_branch_name,
      py::arg("branch"),
      py::arg("name"),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch
name : 
)""");
  py::class_<PyBranchName, std::unique_ptr<PyBranchName>>(
      m, "BranchName", "Fortran routine branch_name return value")
      .def_readonly("name", &PyBranchName::name)
      .def("__len__", [](const PyBranchName&) { return 1; })
      .def("__getitem__", [](const PyBranchName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.name);
        return py::none();
      });
  m.def(
      "c_to_cbar",
      &Bmad::c_to_cbar,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with C matrix and Twiss parameters. .c_mat(2,2) -- C matrix. .a          -- a-mode Twiss
    parameters .b          -- b-mode Twiss parameters
cbar_mat : float
    Cbar matrix.
)""");
  m.def(
      "set_fringe_on_off",
      &python_set_fringe_on_off,
      py::arg("fringe_at"),
      py::arg("ele_end"),
      py::arg("on_or_off"),
      R"""(No docstring available

Parameters
----------
fringe_at : float
    Present fringe_at setting. entrance_end$, exit_end$, both_ends$, or no_end$
    This parameter is an input/output and is modified in-place. As an output: Modified fringe setting.
ele_end : int
    Element edge: entrance_end$ or exit_end$
on_or_off : int
    Turn on$ or off$
)""");
  py::class_<PySetFringeOnOff, std::unique_ptr<PySetFringeOnOff>>(
      m, "SetFringeOnOff", "Fortran routine set_fringe_on_off return value")
      .def_readonly("fringe_at", &PySetFringeOnOff::fringe_at)
      .def("__len__", [](const PySetFringeOnOff&) { return 1; })
      .def(
          "__getitem__", [](const PySetFringeOnOff& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.fringe_at);
            return py::none();
          });
  m.def(
      "reverse_lat",
      &Bmad::reverse_lat,
      py::arg("lat_in"),
      py::arg("track_antiparticle") = py::none(),
      R"""(No docstring available

Parameters
----------
lat_in : LatStruct
    Input lattice to reverse.
lat_rev : LatStruct
    Reversed lattice.
track_antiparticle : bool, optional
    Set the particle species of the reversed lat to the anti-particle of lat_in? Default is True.
)""");
  m.def(
      "momentum_compaction",
      &python_momentum_compaction,
      py::arg("branch"),
      py::arg("mom_comp"),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch to calculate on.
mom_comp : 
)""");
  py::class_<PyMomentumCompaction, std::unique_ptr<PyMomentumCompaction>>(
      m,
      "MomentumCompaction",
      "Fortran routine momentum_compaction return value")
      .def_readonly("mom_comp", &PyMomentumCompaction::mom_comp)
      .def("__len__", [](const PyMomentumCompaction&) { return 1; })
      .def(
          "__getitem__",
          [](const PyMomentumCompaction& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.mom_comp);
            return py::none();
          });
  m.def(
      "bend_exact_multipole_field",
      &Bmad::bend_exact_multipole_field,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      py::arg("local_ref_frame"),
      py::arg("calc_dfield") = py::none(),
      py::arg("calc_potential") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : unknown
    Bend element.
param : LatParamStruct
    Lattice branch parameters.
orbit : CoordStruct
    particle position.
local_ref_frame : bool
    Is the particle position in the local element ref frame (as opposed to the lab frame)?
field : EmFieldStruct
    Field
calc_dfield : bool, optional
    If present and True then calculate the field derivatives.
calc_potential : bool, optional
    Calc electric and magnetic potentials? Default is false.
)""");
  m.def(
      "convert_bend_exact_multipole",
      &Bmad::convert_bend_exact_multipole,
      py::arg("g"),
      py::arg("out_type"),
      py::arg("an"),
      py::arg("bn"),
      R"""(No docstring available

Parameters
----------
g : float
    1/rho bending strength.
out_type : int
    Output type: horizontally_pure$ or vertically_pure$.
an : float
    Skew multipoles.
    This parameter is an input/output and is modified in-place. As an output: Converted skew multipoles.
bn : float
    Non-skew multipoles.
    This parameter is an input/output and is modified in-place. As an output: Converted Non-skew multipoles.
)""");
  m.def(
      "pointer_to_lord",
      &Bmad::pointer_to_lord,
      py::arg("slave"),
      py::arg("ix_lord"),
      py::arg("lord_type") = py::none(),
      py::arg("lord_ptr"),
      R"""(No docstring available

Parameters
----------
slave : EleStruct
    Slave element.
ix_lord : int
    Index of the lord.
control : ControlStruct
    Pointer to control info for this lord/slave relationship. Nullified if there is an error.
ix_slave_back : int
    Index back to the slave. That is, pointer_to_slave(lord_ptr, ix_slave_back) will point back to slave. Set
    to -1 if there is an error or the slave is a slice_slave.
lord_type : int, optional
    See above.
ix_control : int
    Index in lat.control(:) array the control argument is at. For ramper lord elements, ix_control is index
    for the lord.control.ramper(:) array.
ix_ic : int
    Index of the lat.ic(:) element associated with the control argument.
lord_ptr : 
)""");
  py::class_<Bmad::PointerToLord, std::unique_ptr<Bmad::PointerToLord>>(
      m, "PointerToLord", "Fortran routine pointer_to_lord return value")
      .def_readonly("control", &Bmad::PointerToLord::control)
      .def_readonly("ix_slave_back", &Bmad::PointerToLord::ix_slave_back)
      .def_readonly("ix_control", &Bmad::PointerToLord::ix_control)
      .def_readonly("ix_ic", &Bmad::PointerToLord::ix_ic)
      .def("__len__", [](const Bmad::PointerToLord&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::PointerToLord& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.control);
            if (i == 1)
              return py::cast(s.ix_slave_back);
            if (i == 2)
              return py::cast(s.ix_control);
            if (i == 3)
              return py::cast(s.ix_ic);
            return py::none();
          });
  m.def(
      "clear_lat_1turn_mats",
      &Bmad::clear_lat_1turn_mats,
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat with 1-turn matrices cleared.
)""");
  m.def(
      "closed_orbit_calc",
      &Bmad::closed_orbit_calc,
      py::arg("lat"),
      py::arg("closed_orb"),
      py::arg("i_dim") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to track through.
closed_orb : CoordStruct
    closed_orb(nt) is the initial guess where nt = 0 for direction = 1 and nt = lat.n_ele_track for direction
    = -1. Additionally, if i_dim = 4, then closed_orb(nt).vec(6) is used as the energy around which the closed
    orbit is calculated.
    This parameter is an input/output and is modified in-place. As an output: Closed orbit. closed_orb(i)
i_dim : int, optional
    Phase space dimensions to use: = 4  Transverse closed orbit at constant energy (RF off). (dE/E =
    closed_orb(0).vec(6)) = 5 Transverse closed orbit at constant energy (RF off) with the energy adjusted so
    that vec(5) is the same at the beginning and at the end. = 6 True closed orbit. Default: 4 if RF is off, 6
    if RF is on.
direction : int, optional
    Direction of tracking. +1 --> forwad (default), -1 --> backward. The closed orbit will be dependent on
    direction only in the case that radiation damping is turned on.
ix_branch : int, optional
    Lattice branch to find the closed orbit of. Default is 0 (main branch).
err_flag : bool
    Set true if there is an error. False otherwise.
print_err : bool, optional
    Print error message if calc does not converge? Default is True. Note: Condition messages like no RF
    voltage with i_dim = 6 will always be printed.
)""");
  m.def(
      "angle_to_canonical_coords",
      &Bmad::angle_to_canonical_coords,
      py::arg("orbit"),
      py::arg("coord_type") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Orbit in angular coordinates.
    This parameter is an input/output and is modified in-place. As an output: Orbit in canonical coordinates.
coord_type : unknown, optional
    Angular coordinates type '' (default): (x, x' = dx/ds, y, y' = dy/ds, z, pz) 'ZGOUBI':     (x, x' = dx/ds,
    y, y' = dy/ds, dt = -z / (beta * c), pz)
)""");
  m.def(
      "set_status_flags",
      &Bmad::set_status_flags,
      py::arg("stat"),
      R"""(No docstring available

Parameters
----------
bookkeeping_state : BookkeepingStateStruct
stat : int
    bookkeeping status. ok$, stale$, etc.
)""");
  m.def(
      "create_unique_ele_names",
      &Bmad::create_unique_ele_names,
      py::arg("lat"),
      py::arg("key"),
      py::arg("suffix"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice holding the elements.
    This parameter is an input/output and is modified in-place. As an output: Lattice with names made unique.
key : int
    Class key of elements to consider.
suffix : unknown
    Suffix string. Must have a single "?" character.
)""");
  m.def(
      "zero_ele_offsets",
      &Bmad::zero_ele_offsets,
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with no (mis)orientation.
)""");
  m.def(
      "coords_body_to_local",
      &Bmad::coords_body_to_local,
      py::arg("body_position"),
      py::arg("ele"),
      py::arg("w_mat") = py::none(),
      py::arg("calculate_angles") = py::none(),
      py::arg("local_position"),
      R"""(No docstring available

Parameters
----------
body_position : FloorPositionStruct
    Element body frame coordinates. .r(3)               [x, y, s] position with s = Position from entrance end
    of element.
ele : EleStruct
    element that local_position coordinates are relative to.
w_mat : float, optional
    W matrix at to transform vectors. v_local  = w_mat . v_body v_body   = transpose(w_mat) . v_local
calculate_angles : bool, optional
    calculate angles for local_position Default: True. False returns local_position angles (.theta, .phi,
    .psi) = 0. Output
local_position : 
)""");
  m.def(
      "ele_misalignment_l_s_calc",
      &Bmad::ele_misalignment_l_s_calc,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : float
    Element
L_mis : float
    Misalignment vector relative to center of element
S_mis : float
    Misalignment matrix relative to center of element
)""");
  py::class_<
      Bmad::EleMisalignmentLSCalc,
      std::unique_ptr<Bmad::EleMisalignmentLSCalc>>(
      m,
      "EleMisalignmentLSCalc",
      "Fortran routine ele_misalignment_l_s_calc return value")
      .def_readonly("L_mis", &Bmad::EleMisalignmentLSCalc::L_mis)
      .def_readonly("S_mis", &Bmad::EleMisalignmentLSCalc::S_mis)
      .def("__len__", [](const Bmad::EleMisalignmentLSCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::EleMisalignmentLSCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.L_mis);
            if (i == 1)
              return py::cast(s.S_mis);
            return py::none();
          });
  m.def(
      "coords_relative_to_floor",
      &python_coords_relative_to_floor,
      py::arg("floor0"),
      py::arg("dr"),
      py::arg("theta") = py::none(),
      py::arg("phi") = py::none(),
      py::arg("psi") = py::none(),
      py::arg("floor1"),
      R"""(No docstring available

Parameters
----------
floor0 : FloorPositionStruct
    Initial reference frame.
dr : float
    (x, y, z) positional shift of the reference frame. theta, phi, psi -- real(rp), optional: Angular shift of
    the reference frame. See the Bmad manual on the Global Coordinate system for more details. All angles must
    either be absent or present.
theta : 
phi : 
psi : 
floor1 : 
)""");
  py::class_<PyCoordsRelativeToFloor, std::unique_ptr<PyCoordsRelativeToFloor>>(
      m,
      "CoordsRelativeToFloor",
      "Fortran routine coords_relative_to_floor return value")
      .def_readonly("theta", &PyCoordsRelativeToFloor::theta)
      .def_readonly("phi", &PyCoordsRelativeToFloor::phi)
      .def_readonly("psi", &PyCoordsRelativeToFloor::psi)
      .def("__len__", [](const PyCoordsRelativeToFloor&) { return 3; })
      .def(
          "__getitem__",
          [](const PyCoordsRelativeToFloor& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.theta);
            if (i == 1)
              return py::cast(s.phi);
            if (i == 2)
              return py::cast(s.psi);
            return py::none();
          });
  m.def(
      "update_floor_angles",
      &Bmad::update_floor_angles,
      py::arg("floor"),
      py::arg("floor0") = py::none(),
      R"""(No docstring available

Parameters
----------
floor : FloorPositionStruct
    Position with input w matrix. .w      -- w matrix.
    This parameter is an input/output and is modified in-place. As an output: Position with output angles.
floor0 : FloorPositionStruct, optional
    Reference position. There are two solutions related by: [theta, phi, psi] & [pi+theta, pi-phi, pi+psi] If
    floor0 is present, choose the solution "nearest" the angles in floor0.
)""");
  m.def(
      "coords_body_to_rel_exit",
      &Bmad::coords_body_to_rel_exit,
      py::arg("body_position"),
      py::arg("ele"),
      py::arg("w_mat") = py::none(),
      py::arg("calculate_angles") = py::none(),
      py::arg("rel_exit"),
      R"""(No docstring available

Parameters
----------
body_position : FloorPositionStruct
    Element body frame coordinates. .r                  [x, y, s] position with s = Position from entrance end
    of element .
ele : EleStruct
    element that rel_exit coordinates are relative to.
w_mat : float, optional
    W matrix at to transform vectors. v_rel_exit = w_mat . v_body v_body     = transpose(w_mat) . v_rel_exit
calculate_angles : bool, optional
    calculate angles for rel_exit Default: True. False returns rel_exit angles (.theta, .phi, .psi) = 0.
    Output
rel_exit : 
)""");
  m.def(
      "ele_geometry",
      &Bmad::ele_geometry,
      py::arg("floor_start"),
      py::arg("ele"),
      py::arg("len_scale") = py::none(),
      py::arg("ignore_patch_err") = py::none(),
      R"""(No docstring available

Parameters
----------
floor_start : 
    Starting floor coordinates at upstream end. Not used for fiducial and girder elements.
ele : EleStruct
    Element to propagate the geometry through.
floor_end : FloorPositionStruct
    Output floor position. If not present then ele.floor will be used and ele.bookkeeping_state.floor_position
    will be set to ok$. .r(3)              -- X, Y, Z Floor position at end of element .w(3,3)            -- W
    matrix corresponding to orientation angles .theta, phi, .psi  -- Orientation angles
len_scale : float, optional
    factor to scale the length of the element. 1.0_rp => Output is geometry at end of element (default).
    0.5_rp => Output is geometry at center of element. -1.0_rp => Used to propagate geometry in reverse.
ignore_patch_err : bool, optional
    If present and True, ignore flexible patch errors. This is used by ele_compute_ref_energy_and_time to
    suppress unnecessary messages.
)""");
  m.def(
      "w_mat_for_tilt",
      &Bmad::w_mat_for_tilt,
      py::arg("tilt"),
      py::arg("return_inverse") = py::none(),
      py::arg("w_mat"),
      R"""(No docstring available

Parameters
----------
tilt : float
    pitch angle
return_inverse : bool, optional
    If True, return the inverse matrix. Default is False.
w_mat : 
)""");
  m.def(
      "patch_flips_propagation_direction",
      &python_patch_flips_propagation_direction,
      py::arg("x_pitch"),
      py::arg("y_pitch"),
      py::arg("is_flip"),
      R"""(No docstring available

Parameters
----------
x_pitch : float
    Rotaion around y-axis
y_pitch : float
    Rotation around x-axis.
is_flip : 
)""");
  py::class_<
      PyPatchFlipsPropagationDirection,
      std::unique_ptr<PyPatchFlipsPropagationDirection>>(
      m,
      "PatchFlipsPropagationDirection",
      "Fortran routine patch_flips_propagation_direction return value")
      .def_readonly("is_flip", &PyPatchFlipsPropagationDirection::is_flip)
      .def("__len__", [](const PyPatchFlipsPropagationDirection&) { return 1; })
      .def(
          "__getitem__",
          [](const PyPatchFlipsPropagationDirection& s,
             size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_flip);
            return py::none();
          });
  m.def(
      "coords_floor_to_curvilinear",
      &Bmad::coords_floor_to_curvilinear,
      py::arg("floor_coords"),
      py::arg("ele0"),
      py::arg("local_coords"),
      R"""(No docstring available

Parameters
----------
floor_coords : FloorPositionStruct
    .r = [X, Y, Z] position in global coordinates
ele0 : EleStruct
    Element to start the search at.
ele1 : EleStruct
    Element that local_coords is with respect to.
status : bool
    ok$             -> Local_coords found. patch_problem$  -> No solution due to a patch element. outside$
    -> Outside of lattice ends (for open lattices).
w_mat : float
    W matrix at s, to transform vectors from floor to local. w_mat will only be well defined if status = ok$
local_coords : 
)""");
  py::class_<
      Bmad::CoordsFloorToCurvilinear,
      std::unique_ptr<Bmad::CoordsFloorToCurvilinear>>(
      m,
      "CoordsFloorToCurvilinear",
      "Fortran routine coords_floor_to_curvilinear return value")
      .def_readonly("ele1", &Bmad::CoordsFloorToCurvilinear::ele1)
      .def_readonly("status", &Bmad::CoordsFloorToCurvilinear::status)
      .def_readonly("w_mat", &Bmad::CoordsFloorToCurvilinear::w_mat)
      .def("__len__", [](const Bmad::CoordsFloorToCurvilinear&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::CoordsFloorToCurvilinear& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ele1);
            if (i == 1)
              return py::cast(s.status);
            if (i == 2)
              return py::cast(s.w_mat);
            return py::none();
          });
  m.def(
      "floor_w_mat_to_angles",
      &Bmad::floor_w_mat_to_angles,
      py::arg("w_mat"),
      py::arg("floor0") = py::none(),
      R"""(No docstring available

Parameters
----------
w_mat : float
    Orientation matrix.
theta : float
    Azimuth angle.
phi : float
    Pitch angle.
psi : float
    Roll angle.
floor0 : FloorPositionStruct, optional
    There are two solutions related by: [theta, phi, psi] & [pi+theta, pi-phi, pi+psi] If floor0 is present,
    choose the solution "nearest" the angles in floor0.
)""");
  py::class_<Bmad::FloorWMatToAngles, std::unique_ptr<Bmad::FloorWMatToAngles>>(
      m,
      "FloorWMatToAngles",
      "Fortran routine floor_w_mat_to_angles return value")
      .def_readonly("theta", &Bmad::FloorWMatToAngles::theta)
      .def_readonly("phi", &Bmad::FloorWMatToAngles::phi)
      .def_readonly("psi", &Bmad::FloorWMatToAngles::psi)
      .def("__len__", [](const Bmad::FloorWMatToAngles&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::FloorWMatToAngles& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.theta);
            if (i == 1)
              return py::cast(s.phi);
            if (i == 2)
              return py::cast(s.psi);
            return py::none();
          });
  m.def(
      "coords_floor_to_relative",
      &Bmad::coords_floor_to_relative,
      py::arg("floor0"),
      py::arg("global_position"),
      py::arg("calculate_angles") = py::none(),
      py::arg("is_delta_position") = py::none(),
      py::arg("local_position"),
      R"""(No docstring available

Parameters
----------
floor0 : FloorPositionStruct
    reference position
global_position : FloorPositionStruct
    global position
calculate_angles : bool, optional
    calculate angles for local_position Default: True. False returns local_position angles (.theta, .phi,
    .psi) = 0.
is_delta_position : bool, optional
    If True then treat global_position.r as a difference position in global space and only rotate the position
    but not shift it. Default: False.
local_position : 
)""");
  m.def(
      "coords_local_curvilinear_to_body",
      &Bmad::coords_local_curvilinear_to_body,
      py::arg("local_position"),
      py::arg("ele"),
      py::arg("w_mat") = py::none(),
      py::arg("calculate_angles") = py::none(),
      py::arg("body_position"),
      R"""(No docstring available

Parameters
----------
local_position : FloorPositionStruct
    local coordinates. .r(3)               [x, y, s] position with s = Position from entrance end of element.
ele : EleStruct
    element that coordinates are relative to.
w_mat : float, optional
    W matrix at to transform vectors. v_local  = w_mat . v_body v_body   = transpose(w_mat) . v_local
calculate_angles : bool, optional
    calculate angles for body_position Default: True. False returns body_position angles (.theta, .phi, .psi)
    = 0. Output
body_position : 
)""");
  m.def(
      "w_mat_for_bend_angle",
      &Bmad::w_mat_for_bend_angle,
      py::arg("angle"),
      py::arg("ref_tilt"),
      py::arg("r_vec") = py::none(),
      py::arg("w_mat"),
      R"""(No docstring available

Parameters
----------
angle : float
    Bending angle.
ref_tilt : float
    Reference tilt.
r_vec : float, optional
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: position with ref_tilt
    transformation
w_mat : 
)""");
  m.def(
      "ele_geometry_with_misalignments",
      &Bmad::ele_geometry_with_misalignments,
      py::arg("ele"),
      py::arg("len_scale") = py::none(),
      py::arg("floor"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element under consideration.
len_scale : float, optional
    factor to scale the length of the element. 1.0_rp => Output is geometry at end of element (default).
    0.5_rp => Output is geometry at center of element. -1.0_rp => Used to propagate geometry in reverse.
floor : 
)""");
  m.def(
      "w_mat_for_y_pitch",
      &Bmad::w_mat_for_y_pitch,
      py::arg("y_pitch"),
      py::arg("return_inverse") = py::none(),
      py::arg("w_mat"),
      R"""(No docstring available

Parameters
----------
y_pitch : float
    pitch angle
return_inverse : bool, optional
    If True, return the inverse matrix. Default is False.
w_mat : 
)""");
  m.def(
      "coords_floor_to_local_curvilinear",
      &Bmad::coords_floor_to_local_curvilinear,
      py::arg("global_position"),
      py::arg("ele"),
      py::arg("relative_to") = py::none(),
      py::arg("local_position"),
      R"""(No docstring available

Parameters
----------
global_position : FloorPositionStruct
    .r = [X, Y, Z] position in global coordinates
ele : EleStruct
    element to find local coordinates of.
status : bool
    longitudinal position: inside$: Inside the element. upstream_end$: At upstream end of element or beyound.
    downstream_end$: At downstream end of element or beyound.
w_mat : float
    W matrix at s, to transform vectors. v_global = w_mat.v_local v_local = transpose(w_mat).v_global
relative_to : int, optional
    not_set$ (default), upstream_end$, or downstream_end$. Force which end is used for z = 0. If
    upstream_end$, local_position.r(3) is relative to the upstream end which will not be the entrance end if
    ele.orientation = -1.
local_position : 
)""");
  py::class_<
      Bmad::CoordsFloorToLocalCurvilinear,
      std::unique_ptr<Bmad::CoordsFloorToLocalCurvilinear>>(
      m,
      "CoordsFloorToLocalCurvilinear",
      "Fortran routine coords_floor_to_local_curvilinear return value")
      .def_readonly("status", &Bmad::CoordsFloorToLocalCurvilinear::status)
      .def_readonly("w_mat", &Bmad::CoordsFloorToLocalCurvilinear::w_mat)
      .def(
          "__len__",
          [](const Bmad::CoordsFloorToLocalCurvilinear&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::CoordsFloorToLocalCurvilinear& s,
             size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.status);
            if (i == 1)
              return py::cast(s.w_mat);
            return py::none();
          });
  m.def(
      "orbit_to_floor_phase_space",
      &Bmad::orbit_to_floor_phase_space,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("floor_phase_space"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle orbit in local (not element) coordinates.
ele : EleStruct
    Lattice element particle is in.
floor_phase_space : 
)""");
  m.def(
      "bend_shift",
      &Bmad::bend_shift,
      py::arg("position1"),
      py::arg("g"),
      py::arg("delta_s"),
      py::arg("ref_tilt") = py::none(),
      py::arg("position2"),
      R"""(No docstring available

Parameters
----------
position1 : FloorPositionStruct
    Position of particle in inital coordinate frame.
g : float
    Curvature (1/rho)
delta_s : float
    S-position of final frame relative to the initial frame.
w_mat : float
    W matrix used in the transformation
ref_tilt : float, optional
    ref_tilt. Default: 0
position2 : 
)""");
  m.def(
      "orbit_to_local_curvilinear",
      &Bmad::orbit_to_local_curvilinear,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("z_direction") = py::none(),
      py::arg("relative_to") = py::none(),
      py::arg("local_position"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle orbit in laboratory (not body) coordinates.
ele : EleStruct
    Lattice element particle is in.
z_direction : int, optional
    Set to +1 or -1.  Z-direction of particle velocity relative to element z-axis. Default is ele.orientation
    * orbit.direction.
relative_to : int, optional
    not_set$ (default), upstream_end$, downstream_end$. If not_set$ then origin is at the entrance end.
local_position : 
)""");
  m.def(
      "coords_local_curvilinear_to_floor",
      &Bmad::coords_local_curvilinear_to_floor,
      py::arg("local_position"),
      py::arg("ele"),
      py::arg("in_body_frame") = py::none(),
      py::arg("calculate_angles") = py::none(),
      py::arg("relative_to") = py::none(),
      py::arg("global_position"),
      R"""(No docstring available

Parameters
----------
local_position : FloorPositionStruct
    Floor position in local curvilinear coordinates, with .r = [x, y, z_local] where z_local is wrt the
    entrance end of the element except if relative_to = downstream_end$. In this case, z_local is a distance
    -ele.value(l$) from the exit end (important for patch elements).
ele : EleStruct
    element that local_position coordinates are relative to.
in_body_frame : bool, optional
    True => local_position is in ele body frame and includes misalignments. Ignored if element is a patch.
    Default: False.
w_mat : float
    W matrix at z, to transform vectors. v_global     = w_mat . v_local/body v_local/body = transpose(w_mat) .
    v_global
calculate_angles : bool, optional
    calculate angles for global_position Default: True. False returns local_position angles (.theta, .phi,
    .psi) = 0.
relative_to : int, optional
    not_set$ (default), upstream_end$, or downstream_end$. Force which end is used for z = 0. If
    upstream_end$, local_position.r(3) is relative to the upstream end which will not be the entrance end if
    ele.orientation = -1.
global_position : 
)""");
  m.def(
      "lat_geometry",
      &Bmad::lat_geometry,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    The lattice. .ele(0).floor  -- Floor_position_struct: The starting point for the calculations.
)""");
  m.def(
      "s_body_calc",
      &python_s_body_calc,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("s_body"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle coordinates.
ele : EleStruct
    Lattice element
s_body : 
)""");
  py::class_<PySBodyCalc, std::unique_ptr<PySBodyCalc>>(
      m, "SBodyCalc", "Fortran routine s_body_calc return value")
      .def_readonly("s_body", &PySBodyCalc::s_body)
      .def("__len__", [](const PySBodyCalc&) { return 1; })
      .def("__getitem__", [](const PySBodyCalc& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.s_body);
        return py::none();
      });
  m.def(
      "floor_angles_to_w_mat",
      &Bmad::floor_angles_to_w_mat,
      py::arg("theta"),
      py::arg("phi"),
      py::arg("psi"),
      R"""(No docstring available

Parameters
----------
theta : float
    Azimuth angle.
phi : float
    Pitch angle.
psi : float
    Roll angle.
w_mat : float
    Orientation matrix.
w_mat_inv : float
    Inverse Orientation matrix.
)""");
  py::class_<Bmad::FloorAnglesToWMat, std::unique_ptr<Bmad::FloorAnglesToWMat>>(
      m,
      "FloorAnglesToWMat",
      "Fortran routine floor_angles_to_w_mat return value")
      .def_readonly("w_mat", &Bmad::FloorAnglesToWMat::w_mat)
      .def_readonly("w_mat_inv", &Bmad::FloorAnglesToWMat::w_mat_inv)
      .def("__len__", [](const Bmad::FloorAnglesToWMat&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::FloorAnglesToWMat& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.w_mat);
            if (i == 1)
              return py::cast(s.w_mat_inv);
            return py::none();
          });
  m.def(
      "coords_curvilinear_to_floor",
      &Bmad::coords_curvilinear_to_floor,
      py::arg("xys"),
      py::arg("branch"),
      py::arg("global"),
      R"""(No docstring available

Parameters
----------
xys : float
    (x, y, s) lab frame position vector.
branch : BranchStruct
    Lattice branch that defines the local reference coordinates.
err_flag : bool
    Set True if global floor position cannot be computed.
global : 
)""");
  m.def(
      "w_mat_for_x_pitch",
      &Bmad::w_mat_for_x_pitch,
      py::arg("x_pitch"),
      py::arg("return_inverse") = py::none(),
      py::arg("w_mat"),
      R"""(No docstring available

Parameters
----------
x_pitch : float
    pitch angle
return_inverse : bool, optional
    If True, return the inverse matrix. Default is False.
w_mat : 
)""");
  m.def(
      "write_blender_lat_layout",
      &python_write_blender_lat_layout,
      py::arg("file_name"),
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
file_name : 
lat : 
)""");
  py::class_<PyWriteBlenderLatLayout, std::unique_ptr<PyWriteBlenderLatLayout>>(
      m,
      "WriteBlenderLatLayout",
      "Fortran routine write_blender_lat_layout return value")
      .def_readonly("file_name", &PyWriteBlenderLatLayout::file_name)
      .def("__len__", [](const PyWriteBlenderLatLayout&) { return 1; })
      .def(
          "__getitem__",
          [](const PyWriteBlenderLatLayout& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.file_name);
            return py::none();
          });
  m.def(
      "skip_ele_blender",
      &python_skip_ele_blender,
      py::arg("ele"),
      py::arg("skip"),
      R"""(No docstring available

Parameters
----------
ele : 
skip : 
)""");
  py::class_<PySkipEleBlender, std::unique_ptr<PySkipEleBlender>>(
      m, "SkipEleBlender", "Fortran routine skip_ele_blender return value")
      .def_readonly("skip", &PySkipEleBlender::skip)
      .def("__len__", [](const PySkipEleBlender&) { return 1; })
      .def(
          "__getitem__", [](const PySkipEleBlender& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.skip);
            return py::none();
          });
  m.def(
      "write_blender_ele",
      &python_write_blender_ele,
      py::arg("iu"),
      py::arg("ele"),
      py::arg("old_format") = py::none(),
      R"""(No docstring available

Parameters
----------
iu : 
ele : 
old_format : 
)""");
  py::class_<PyWriteBlenderEle, std::unique_ptr<PyWriteBlenderEle>>(
      m, "WriteBlenderEle", "Fortran routine write_blender_ele return value")
      .def_readonly("iu", &PyWriteBlenderEle::iu)
      .def_readonly("old_format", &PyWriteBlenderEle::old_format)
      .def("__len__", [](const PyWriteBlenderEle&) { return 2; })
      .def(
          "__getitem__",
          [](const PyWriteBlenderEle& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.iu);
            if (i == 1)
              return py::cast(s.old_format);
            return py::none();
          });
  m.def(
      "write_astra_bend",
      &python_write_astra_bend,
      py::arg("iu"),
      py::arg("strength"),
      py::arg("id"),
      py::arg("d1"),
      py::arg("d2"),
      py::arg("d3"),
      py::arg("d4"),
      R"""(No docstring available

Parameters
----------
iu : 
strength : 
id : 
d1 : 
d2 : 
d3 : 
d4 : 
)""");
  py::class_<PyWriteAstraBend, std::unique_ptr<PyWriteAstraBend>>(
      m, "WriteAstraBend", "Fortran routine write_astra_bend return value")
      .def_readonly("iu", &PyWriteAstraBend::iu)
      .def_readonly("strength", &PyWriteAstraBend::strength)
      .def_readonly("id", &PyWriteAstraBend::id)
      .def("__len__", [](const PyWriteAstraBend&) { return 3; })
      .def(
          "__getitem__", [](const PyWriteAstraBend& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.iu);
            if (i == 1)
              return py::cast(s.strength);
            if (i == 2)
              return py::cast(s.id);
            return py::none();
          });
  m.def(
      "rotate3",
      &python_rotate3,
      py::arg("vec"),
      py::arg("angle"),
      py::arg("rvec"),
      R"""(No docstring available

Parameters
----------
vec : 
angle : 
rvec : 
)""");
  py::class_<PyRotate3, std::unique_ptr<PyRotate3>>(
      m, "Rotate3", "Fortran routine rotate3 return value")
      .def_readonly("angle", &PyRotate3::angle)
      .def("__len__", [](const PyRotate3&) { return 1; })
      .def("__getitem__", [](const PyRotate3& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.angle);
        return py::none();
      });
  m.def(
      "write_astra_field_grid_file",
      &Bmad::write_astra_field_grid_file,
      py::arg("astra_file_unit"),
      py::arg("ele"),
      py::arg("dz") = py::none(),
      R"""(Write 1-D field map files for Astra. The format is:

z field
...

Parameters
----------
astra_file_unit : int
    unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
ele : EleStruct
    element to make map
dz : float, optional
    z step size in m. Default: 0.001 m

Return value is a dictionary containing values below.


Returns
-------
maxfield : float
    absolute maximum found for element field scaling
err : bool
    Set True if, say a file could not be opened.
)""");
  py::class_<
      Bmad::WriteAstraFieldGridFile,
      std::unique_ptr<Bmad::WriteAstraFieldGridFile>>(
      m,
      "WriteAstraFieldGridFile",
      "Fortran routine write_astra_field_grid_file return value")
      .def_readonly("maxfield", &Bmad::WriteAstraFieldGridFile::maxfield)
      .def_readonly("err", &Bmad::WriteAstraFieldGridFile::err)
      .def("__len__", [](const Bmad::WriteAstraFieldGridFile&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::WriteAstraFieldGridFile& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.maxfield);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "write_astra_field_grid_file_3d",
      &Bmad::write_astra_field_grid_file_3d,
      py::arg("base_filename"),
      py::arg("ele"),
      py::arg("dz") = py::none(),
      R"""(Writes 3-D field map files for Astra. The format is:

Nx x[1] x[2] ....... x[Nx-1] x[Nx]
Ny y[1] y[2] ....... y[Ny-1] y[Ny]
Nz z[1] z[2] ....... z[Nz-1] z[Nz]
<field values>
where field values are produced from a loop as in:
do iz = 1, Nz
do iy = 1, Ny
write single line: field(:, iy, iz)

Parameters
----------
base_filename : unknown
    Base filename. Files will be written as: base_filename.ex, .ey, .ez, .bx, .by, .bz If set to '', no files
    will be written
ele : EleStruct
    element to make map
dz : float, optional
    z step size in m. Default: 0.001 m

Return value is a dictionary containing values below.


Returns
-------
maxfield : float
    absolute maximum on-axis field found for element field scaling
err : bool
    Set True if, say a file could not be opened.
)""");
  py::class_<
      Bmad::WriteAstraFieldGridFile3d,
      std::unique_ptr<Bmad::WriteAstraFieldGridFile3d>>(
      m,
      "WriteAstraFieldGridFile3d",
      "Fortran routine write_astra_field_grid_file_3d return value")
      .def_readonly("maxfield", &Bmad::WriteAstraFieldGridFile3d::maxfield)
      .def_readonly("err", &Bmad::WriteAstraFieldGridFile3d::err)
      .def("__len__", [](const Bmad::WriteAstraFieldGridFile3d&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::WriteAstraFieldGridFile3d& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.maxfield);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "astra_max_field_reference",
      &python_astra_max_field_reference,
      py::arg("pt0"),
      py::arg("ele"),
      py::arg("field_value"),
      R"""(No docstring available

Parameters
----------
pt0 : 
ele : 
field_value : 
)""");
  py::class_<
      PyAstraMaxFieldReference,
      std::unique_ptr<PyAstraMaxFieldReference>>(
      m,
      "AstraMaxFieldReference",
      "Fortran routine astra_max_field_reference return value")
      .def_readonly("field_value", &PyAstraMaxFieldReference::field_value)
      .def("__len__", [](const PyAstraMaxFieldReference&) { return 1; })
      .def(
          "__getitem__",
          [](const PyAstraMaxFieldReference& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.field_value);
            return py::none();
          });
  m.def(
      "photon_absorption_and_phase_shift",
      &Bmad::photon_absorption_and_phase_shift,
      py::arg("material"),
      py::arg("Energy"),
      R"""(Routine to calcualte the absorption and phase shift values for a photon with a given

energy going through a particular material.

Parameters
----------
material : unknown
    Material name.
Energy : float
    Photon energy (eV).

Return value is a dictionary containing values below.


Returns
-------
absorption : float
    E_field ~ Exp(-absorption * length)
phase_shift : float
    E_field Phase shift (radians) per unit length relative to vacuum.
err_flag : bool
    Set true if material not recognized.
)""");
  py::class_<
      Bmad::PhotonAbsorptionAndPhaseShift,
      std::unique_ptr<Bmad::PhotonAbsorptionAndPhaseShift>>(
      m,
      "PhotonAbsorptionAndPhaseShift",
      "Fortran routine photon_absorption_and_phase_shift return value")
      .def_readonly(
          "absorption", &Bmad::PhotonAbsorptionAndPhaseShift::absorption)
      .def_readonly(
          "phase_shift", &Bmad::PhotonAbsorptionAndPhaseShift::phase_shift)
      .def_readonly("err_flag", &Bmad::PhotonAbsorptionAndPhaseShift::err_flag)
      .def(
          "__len__",
          [](const Bmad::PhotonAbsorptionAndPhaseShift&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::PhotonAbsorptionAndPhaseShift& s,
             size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.absorption);
            if (i == 1)
              return py::cast(s.phase_shift);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "multilayer_type_to_multilayer_params",
      &Bmad::multilayer_type_to_multilayer_params,
      py::arg("ele"),
      R"""(Routine to set the multilayer parameters based upon the multilayer type.

Multilayer types are of the form:
"AAA:BBB"
Where "AAA" is the atomic formula for the top layer crystal and "BBB" is the second layer atomic formula.

Parameters
----------
ele : EleStruct
    Multilayer element. .component_name -- Character: Multilayer type name. Assumed upper case. A blank name
    is not an error and results in nothing set. .value(e_tot$)  -- Photon energy in eV.

Returns
-------
err_flag : bool
    Set True if multilayer type is unrecognized. False otherwise.
)""");
  m.def(
      "crystal_type_to_crystal_params",
      &Bmad::crystal_type_to_crystal_params,
      py::arg("ele"),
      R"""(Routine to set the crystal parameters based upon the crystal type.

Crystal types are of the form:
"ZZZ(ijk)"
Where "ZZZ" is the atomic formula of the crystal material and "ijk" is the reciprical lattice
vetor specifying the diffraction plans.

Parameters
----------
ele : EleStruct
    Crystal element. .component_name -- Character: Crystal type name. Assumed upper case. A blank name is not
    an error and results in nothing set. .value(e_tot$)  -- Photon energy in eV.
    This parameter is an input/output and is modified in-place. As an output: Crystal element with computed
    parameter..

Returns
-------
err_flag : bool
    Set True if crystal type is unrecognized. False otherwise.
)""");
  m.def(
      "xraylib_nist_compound",
      &Bmad::xraylib_nist_compound,
      py::arg("name"),
      R"""(Routine to return the xraylib index for a given NIST compound.

Taken from file xraylib/include/xraylib-nist_compounds.h

Parameters
----------
name : unknown
    Name of compound

Returns
-------
indx : int
    Compound index. -1 if not found.
)""");
  m.def(
      "write_opal_lattice_file",
      &Bmad::write_opal_lattice_file,
      py::arg("opal_file_unit"),
      py::arg("lat"),
      R"""(Subroutine to write an OPAL lattice file using the information in

a lat_struct. Optionally only part of the lattice can be generated.

Parameters
----------
opal_file_unit : int
    unit number to write to
lat : LatStruct
    Holds the lattice information.

Returns
-------
err : bool
    Set True if, say a file could not be opened.
)""");
  m.def(
      "write_opal_field_grid_file",
      &Bmad::write_opal_field_grid_file,
      py::arg("opal_file_unit"),
      py::arg("ele"),
      py::arg("param"),
      R"""(Subroutine to write an OPAL lattice file using the information in

a lat_struct. Optionally only part of the lattice can be generated.

Parameters
----------
opal_file_unit : int
    unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
ele : EleStruct
    element to make map
param : LatParamStruct
    Contains lattice information

Return value is a dictionary containing values below.


Returns
-------
maxfield : float
    absolute maximum found for element field scaling
err : bool
    Set True if, say a file could not be opened.
)""");
  py::class_<
      Bmad::WriteOpalFieldGridFile,
      std::unique_ptr<Bmad::WriteOpalFieldGridFile>>(
      m,
      "WriteOpalFieldGridFile",
      "Fortran routine write_opal_field_grid_file return value")
      .def_readonly("maxfield", &Bmad::WriteOpalFieldGridFile::maxfield)
      .def_readonly("err", &Bmad::WriteOpalFieldGridFile::err)
      .def("__len__", [](const Bmad::WriteOpalFieldGridFile&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::WriteOpalFieldGridFile& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.maxfield);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "gpt_to_particle_bunch",
      &Bmad::gpt_to_particle_bunch,
      py::arg("gpt_file"),
      py::arg("ele"),
      R"""(Routine to initialize a bunch of particles from a GPT screen file.

Parameters
----------
gpt_file : unknown
    Name of GPT data file.
ele : EleStruct
    Lattice element whose downstream end coincident with the GPT screen.

Return value is a dictionary containing values below.


Returns
-------
bunch : BunchStruct
    Particle bunch
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::GptToParticleBunch,
      std::unique_ptr<Bmad::GptToParticleBunch>>(
      m,
      "GptToParticleBunch",
      "Fortran routine gpt_to_particle_bunch return value")
      .def_readonly("bunch", &Bmad::GptToParticleBunch::bunch)
      .def_readonly("err_flag", &Bmad::GptToParticleBunch::err_flag)
      .def("__len__", [](const Bmad::GptToParticleBunch&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::GptToParticleBunch& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.bunch);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "gpt_field_grid_scaling",
      &python_gpt_field_grid_scaling,
      py::arg("ele"),
      py::arg("dimensions"),
      py::arg("field_scale"),
      py::arg("ref_time"),
      R"""(No docstring available

Parameters
----------
ele : 
dimensions : 
field_scale : 
ref_time : 
)""");
  py::class_<PyGptFieldGridScaling, std::unique_ptr<PyGptFieldGridScaling>>(
      m,
      "GptFieldGridScaling",
      "Fortran routine gpt_field_grid_scaling return value")
      .def_readonly("dimensions", &PyGptFieldGridScaling::dimensions)
      .def_readonly("field_scale", &PyGptFieldGridScaling::field_scale)
      .def_readonly("ref_time", &PyGptFieldGridScaling::ref_time)
      .def("__len__", [](const PyGptFieldGridScaling&) { return 3; })
      .def(
          "__getitem__",
          [](const PyGptFieldGridScaling& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dimensions);
            if (i == 1)
              return py::cast(s.field_scale);
            if (i == 2)
              return py::cast(s.ref_time);
            return py::none();
          });
  m.def(
      "write_gpt_field_grid_file_1d",
      &Bmad::write_gpt_field_grid_file_1d,
      py::arg("gpt_file_unit"),
      py::arg("ele"),
      py::arg("dz") = py::none(),
      R"""(Write 1-D field map files for gpt. The format is:

z field
...

Parameters
----------
gpt_file_unit : int
    unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
ele : EleStruct
    element to make map
dz : float, optional
    z step size in m. Default: 0.001 m

Return value is a dictionary containing values below.


Returns
-------
maxfield : float
    absolute maximum found for element field scaling
ref_time : float
    time that the field was evaluated at
err : bool
    Set True if, say a file could not be opened.
)""");
  py::class_<
      Bmad::WriteGptFieldGridFile1d,
      std::unique_ptr<Bmad::WriteGptFieldGridFile1d>>(
      m,
      "WriteGptFieldGridFile1d",
      "Fortran routine write_gpt_field_grid_file_1d return value")
      .def_readonly("maxfield", &Bmad::WriteGptFieldGridFile1d::maxfield)
      .def_readonly("ref_time", &Bmad::WriteGptFieldGridFile1d::ref_time)
      .def_readonly("err", &Bmad::WriteGptFieldGridFile1d::err)
      .def("__len__", [](const Bmad::WriteGptFieldGridFile1d&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::WriteGptFieldGridFile1d& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.maxfield);
            if (i == 1)
              return py::cast(s.ref_time);
            if (i == 2)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "write_gpt_field_grid_file_2d",
      &Bmad::write_gpt_field_grid_file_2d,
      py::arg("gpt_file_unit"),
      py::arg("ele"),
      py::arg("dr") = py::none(),
      py::arg("dz") = py::none(),
      py::arg("r_max") = py::none(),
      R"""(Subroutine to write an GPT lattice file using the information in

a lat_struct. Optionally only part of the lattice can be generated.

Parameters
----------
gpt_file_unit : int
    unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
ele : EleStruct
    element to make map
dr : float, optional
    r step size in m. Default: 0.001 m
dz : float, optional
    z step size in m. Default: 0.001 m
r_max : float, optional
    maximum radius in m. Default: 0.02 m

Return value is a dictionary containing values below.


Returns
-------
maxfield : float
    absolute maximum found for element field scaling
ref_time : float
    time that the field was evaluated at
err : bool
    Set True if, say a file could not be opened.
)""");
  py::class_<
      Bmad::WriteGptFieldGridFile2d,
      std::unique_ptr<Bmad::WriteGptFieldGridFile2d>>(
      m,
      "WriteGptFieldGridFile2d",
      "Fortran routine write_gpt_field_grid_file_2d return value")
      .def_readonly("maxfield", &Bmad::WriteGptFieldGridFile2d::maxfield)
      .def_readonly("ref_time", &Bmad::WriteGptFieldGridFile2d::ref_time)
      .def_readonly("err", &Bmad::WriteGptFieldGridFile2d::err)
      .def("__len__", [](const Bmad::WriteGptFieldGridFile2d&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::WriteGptFieldGridFile2d& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.maxfield);
            if (i == 1)
              return py::cast(s.ref_time);
            if (i == 2)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "write_gpt_field_grid_file_3d",
      &Bmad::write_gpt_field_grid_file_3d,
      py::arg("base_filename"),
      py::arg("ele"),
      py::arg("dz") = py::none(),
      R"""(Writes 3-D field map files for gpt. The format is:

E-fields:
'x', 'y', 'z', 'ExRe', 'EyRe', 'EzRe', 'ExIm ', 'EyIm ', 'EzIm '
H-fields
'x', 'y', 'z', 'HxRe', 'HyRe', 'HzRe', 'HxIm ', 'HyIm ', 'HzIm '
where the fields oscillate as exp(+i \omega t)

Parameters
----------
base_filename : unknown
    Base filename. Files will be written as: base_filename_E_ASCII.gpt, _H_ASCII.gpt If set to '', no files
    will be written
ele : EleStruct
    element to make map
dz : float, optional
    z step size in m. Default: 0.001 m

Return value is a dictionary containing values below.


Returns
-------
maxfield : float
    absolute maximum on-axis field found for element field scaling
ref_time : float
    time that the field was evaluated at
err : bool
    Set True if, say a file could not be opened.
)""");
  py::class_<
      Bmad::WriteGptFieldGridFile3d,
      std::unique_ptr<Bmad::WriteGptFieldGridFile3d>>(
      m,
      "WriteGptFieldGridFile3d",
      "Fortran routine write_gpt_field_grid_file_3d return value")
      .def_readonly("maxfield", &Bmad::WriteGptFieldGridFile3d::maxfield)
      .def_readonly("ref_time", &Bmad::WriteGptFieldGridFile3d::ref_time)
      .def_readonly("err", &Bmad::WriteGptFieldGridFile3d::err)
      .def("__len__", [](const Bmad::WriteGptFieldGridFile3d&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::WriteGptFieldGridFile3d& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.maxfield);
            if (i == 1)
              return py::cast(s.ref_time);
            if (i == 2)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "gpt_max_field_reference",
      &python_gpt_max_field_reference,
      py::arg("pt0"),
      py::arg("ele"),
      py::arg("field_value"),
      R"""(No docstring available

Parameters
----------
pt0 : 
ele : 
field_value : 
)""");
  py::class_<PyGptMaxFieldReference, std::unique_ptr<PyGptMaxFieldReference>>(
      m,
      "GptMaxFieldReference",
      "Fortran routine gpt_max_field_reference return value")
      .def_readonly("field_value", &PyGptMaxFieldReference::field_value)
      .def("__len__", [](const PyGptMaxFieldReference&) { return 1; })
      .def(
          "__getitem__",
          [](const PyGptMaxFieldReference& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.field_value);
            return py::none();
          });
  m.def(
      "rotate_field_zx",
      &python_rotate_field_zx,
      py::arg("field"),
      py::arg("theta"),
      R"""(No docstring available

Parameters
----------
field : 
theta : 
)""");
  py::class_<PyRotateFieldZx, std::unique_ptr<PyRotateFieldZx>>(
      m, "RotateFieldZx", "Fortran routine rotate_field_zx return value")
      .def_readonly("theta", &PyRotateFieldZx::theta)
      .def("__len__", [](const PyRotateFieldZx&) { return 1; })
      .def("__getitem__", [](const PyRotateFieldZx& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.theta);
        return py::none();
      });
  m.def(
      "convert_local_curvilinear_to_local_cartesian",
      &python_convert_local_curvilinear_to_local_cartesian,
      py::arg("x"),
      py::arg("s"),
      py::arg("g"),
      py::arg("xout"),
      py::arg("zout"),
      R"""(No docstring available

Parameters
----------
x : 
s : 
g : 
xout : 
zout : 
)""");
  py::class_<
      PyConvertLocalCurvilinearToLocalCartesian,
      std::unique_ptr<PyConvertLocalCurvilinearToLocalCartesian>>(
      m,
      "ConvertLocalCurvilinearToLocalCartesian",
      "Fortran routine convert_local_curvilinear_to_local_cartesian return value")
      .def_readonly("x", &PyConvertLocalCurvilinearToLocalCartesian::x)
      .def_readonly("s", &PyConvertLocalCurvilinearToLocalCartesian::s)
      .def_readonly("g", &PyConvertLocalCurvilinearToLocalCartesian::g)
      .def_readonly("xout", &PyConvertLocalCurvilinearToLocalCartesian::xout)
      .def_readonly("zout", &PyConvertLocalCurvilinearToLocalCartesian::zout)
      .def(
          "__len__",
          [](const PyConvertLocalCurvilinearToLocalCartesian&) { return 5; })
      .def(
          "__getitem__",
          [](const PyConvertLocalCurvilinearToLocalCartesian& s,
             size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.x);
            if (i == 1)
              return py::cast(s.s);
            if (i == 2)
              return py::cast(s.g);
            if (i == 3)
              return py::cast(s.xout);
            if (i == 4)
              return py::cast(s.zout);
            return py::none();
          });
  m.def(
      "convert_local_cartesian_to_local_curvilinear",
      &python_convert_local_cartesian_to_local_curvilinear,
      py::arg("x"),
      py::arg("z"),
      py::arg("g"),
      py::arg("xout"),
      py::arg("sout"),
      R"""(No docstring available

Parameters
----------
x : 
z : 
g : 
xout : 
sout : 
)""");
  py::class_<
      PyConvertLocalCartesianToLocalCurvilinear,
      std::unique_ptr<PyConvertLocalCartesianToLocalCurvilinear>>(
      m,
      "ConvertLocalCartesianToLocalCurvilinear",
      "Fortran routine convert_local_cartesian_to_local_curvilinear return value")
      .def_readonly("x", &PyConvertLocalCartesianToLocalCurvilinear::x)
      .def_readonly("z", &PyConvertLocalCartesianToLocalCurvilinear::z)
      .def_readonly("g", &PyConvertLocalCartesianToLocalCurvilinear::g)
      .def_readonly("xout", &PyConvertLocalCartesianToLocalCurvilinear::xout)
      .def_readonly("sout", &PyConvertLocalCartesianToLocalCurvilinear::sout)
      .def(
          "__len__",
          [](const PyConvertLocalCartesianToLocalCurvilinear&) { return 5; })
      .def(
          "__getitem__",
          [](const PyConvertLocalCartesianToLocalCurvilinear& s,
             size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.x);
            if (i == 1)
              return py::cast(s.z);
            if (i == 2)
              return py::cast(s.g);
            if (i == 3)
              return py::cast(s.xout);
            if (i == 4)
              return py::cast(s.sout);
            return py::none();
          });
  m.def(
      "multipole1_ab_to_kt",
      &Bmad::multipole1_ab_to_kt,
      py::arg("an"),
      py::arg("bn"),
      py::arg("n"),
      R"""(No docstring available

Parameters
----------
an : float
    Skew multipole component.
bn : float
    Normal multipole component.
n : int
    Order of multipole.
knl : float
    Multitude magnatude.
tn : float
    Multipole angle.
)""");
  py::class_<Bmad::Multipole1AbToKt, std::unique_ptr<Bmad::Multipole1AbToKt>>(
      m, "Multipole1AbToKt", "Fortran routine multipole1_ab_to_kt return value")
      .def_readonly("knl", &Bmad::Multipole1AbToKt::knl)
      .def_readonly("tn", &Bmad::Multipole1AbToKt::tn)
      .def("__len__", [](const Bmad::Multipole1AbToKt&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::Multipole1AbToKt& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.knl);
            if (i == 1)
              return py::cast(s.tn);
            return py::none();
          });
  m.def(
      "track_a_foil",
      &Bmad::track_a_foil,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    foil element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "ele_nametable_index",
      &python_ele_nametable_index,
      py::arg("ele"),
      py::arg("ix_nt"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element in a lattice.
ix_nt : 
)""");
  py::class_<PyEleNametableIndex, std::unique_ptr<PyEleNametableIndex>>(
      m,
      "EleNametableIndex",
      "Fortran routine ele_nametable_index return value")
      .def_readonly("ix_nt", &PyEleNametableIndex::ix_nt)
      .def("__len__", [](const PyEleNametableIndex&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEleNametableIndex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_nt);
            return py::none();
          });
  m.def(
      "check_aperture_limit",
      &Bmad::check_aperture_limit,
      py::arg("orb"),
      py::arg("ele"),
      py::arg("particle_at"),
      py::arg("param"),
      py::arg("old_orb") = py::none(),
      py::arg("check_momentum") = py::none(),
      R"""(No docstring available

Parameters
----------
orb : CoordStruct
    coordinates of a particle.
ele : EleStruct
    Element holding the aperture
particle_at : int
    first_track_edge$, second_track_edge$, surface$, in_between$
param : LatParamStruct
    Lattice global parameter structure.
old_orb : CoordStruct, optional
    Old coordinates at last check. Needed if ele.aperture_at = wall_transition$. If not present then wall
    transitions will be ignored.
check_momentum : bool, optional
    If present and false then checking of p_x and p_y will be disabled.
)""");
  m.def(
      "transfer_eles",
      &Bmad::transfer_eles,
      py::arg("ele1"),
      R"""(No docstring available

Parameters
----------
ele1 : EleStruct
ele2 : EleStruct
)""");
  m.def(
      "track_a_sol_quad",
      &Bmad::track_a_sol_quad,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Sol_quad or solenoid element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "track_a_gkicker",
      &Bmad::track_a_gkicker,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Gkicker
param : LatParamStruct
    Lattice parameters.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
    element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "track1_linear",
      &Bmad::track1_linear,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position
    This parameter is an input/output and is modified in-place. As an output: End position
ele : EleStruct
    Element
param : LatParamStruct
)""");
  m.def(
      "track_a_bend",
      &Bmad::track_a_bend,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Bend element.
param : LatParamStruct
    Lattice parameters.
mat6 : float, optional
    Transfer matrix up to the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix to the element
    end.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "sbend_body_with_k1_map",
      &Bmad::sbend_body_with_k1_map,
      py::arg("ele"),
      py::arg("dg"),
      py::arg("b1"),
      py::arg("param"),
      py::arg("n_step"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Sbend element.
dg : float
    Field error.
b1 : float
    b1 quadrupole strength * rel_charge_dir
param : LatParamStruct
    Branch parameters.
n_step : int
    Number of steps to divide the bend into. Only one step is taken by this routine.
orbit : CoordStruct
    Orbit at beginning of the bend.
    This parameter is an input/output and is modified in-place. As an output: Ending coordinates.
mat6 : float, optional
    Transfer matrix before element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix with body added
    in.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "ele_loc",
      &Bmad::ele_loc,
      py::arg("ele"),
      py::arg("loc"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to be identified
loc : 
)""");
  m.def(
      "strong_beam_sigma_calc",
      &Bmad::strong_beam_sigma_calc,
      py::arg("ele"),
      py::arg("s_pos"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Beambeam element.
s_pos : float
    Longitudinal position in lab coords of slice (used with hourglass effect correction).
sigma : float
    Strong beam x,y sigmas.
bbi_const : float
    BBI kick scale factor.
dsigma_ds : float
    sig_x and sig_y longitudinal derivatives.
)""");
  py::class_<
      Bmad::StrongBeamSigmaCalc,
      std::unique_ptr<Bmad::StrongBeamSigmaCalc>>(
      m,
      "StrongBeamSigmaCalc",
      "Fortran routine strong_beam_sigma_calc return value")
      .def_readonly("sigma", &Bmad::StrongBeamSigmaCalc::sigma)
      .def_readonly("bbi_const", &Bmad::StrongBeamSigmaCalc::bbi_const)
      .def_readonly("dsigma_ds", &Bmad::StrongBeamSigmaCalc::dsigma_ds)
      .def("__len__", [](const Bmad::StrongBeamSigmaCalc&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::StrongBeamSigmaCalc& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.sigma);
            if (i == 1)
              return py::cast(s.bbi_const);
            if (i == 2)
              return py::cast(s.dsigma_ds);
            return py::none();
          });
  m.def(
      "track_a_sad_mult",
      &Bmad::track_a_sad_mult,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Sad_mult element.
param : LatParamStruct
    Lattice parameters.
mat6 : float, optional
    Transfer matrix up to the sad_mult.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "ac_kicker_amp",
      &python_ac_kicker_amp,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("true_time") = py::none(),
      py::arg("ac_amp"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    ac_kicker element.
orbit : CoordStruct
    Contains the time to evaluate the amplitude at.
true_time : float, optional
    The actual time. Normally this time is calculated using orbit.t or orbit.vec(5) but sometimes it is
    convenient to be able to override this. For example, time_runge_kutta uses this.
ac_amp : 
)""");
  py::class_<PyAcKickerAmp, std::unique_ptr<PyAcKickerAmp>>(
      m, "AcKickerAmp", "Fortran routine ac_kicker_amp return value")
      .def_readonly("ac_amp", &PyAcKickerAmp::ac_amp)
      .def("__len__", [](const PyAcKickerAmp&) { return 1; })
      .def("__getitem__", [](const PyAcKickerAmp& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ac_amp);
        return py::none();
      });
  m.def(
      "low_energy_z_correction",
      &python_low_energy_z_correction,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("ds"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      py::arg("dz"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Position before correction
ele : unknown
    Element being tracked through.
ds : float
    Longitudinal distance traveled by reference particle.
mat6 : float, optional
    Transfer matrix before the multipole.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    including multipole.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
dz : 
)""");
  py::class_<PyLowEnergyZCorrection, std::unique_ptr<PyLowEnergyZCorrection>>(
      m,
      "LowEnergyZCorrection",
      "Fortran routine low_energy_z_correction return value")
      .def_readonly("dz", &PyLowEnergyZCorrection::dz)
      .def("__len__", [](const PyLowEnergyZCorrection&) { return 1; })
      .def(
          "__getitem__",
          [](const PyLowEnergyZCorrection& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dz);
            return py::none();
          });
  m.def(
      "sol_quad_mat6_calc",
      &python_sol_quad_mat6_calc,
      py::arg("ks_in"),
      py::arg("k1_in"),
      py::arg("tilt"),
      py::arg("length"),
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
ks_in : 
k1_in : 
tilt : float
    quadrupole tilt.
length : float
    Sol_quad length.
ele : EleStruct
    Sol_quad element.
orbit : CoordStruct
    Orbit at beginning of the sol_quad.
mat6 : float, optional
    Transfer matrix up to the sol_quad.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix includeing the
    sol_quad.
make_matrix : bool, optional
    Extend the matrix?
)""");
  py::class_<PySolQuadMat6Calc, std::unique_ptr<PySolQuadMat6Calc>>(
      m, "SolQuadMat6Calc", "Fortran routine sol_quad_mat6_calc return value")
      .def_readonly("ks_in", &PySolQuadMat6Calc::ks_in)
      .def_readonly("k1_in", &PySolQuadMat6Calc::k1_in)
      .def("__len__", [](const PySolQuadMat6Calc&) { return 2; })
      .def(
          "__getitem__",
          [](const PySolQuadMat6Calc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ks_in);
            if (i == 1)
              return py::cast(s.k1_in);
            return py::none();
          });
  m.def(
      "pointer_to_field_ele",
      &Bmad::pointer_to_field_ele,
      py::arg("ele"),
      py::arg("ix_field_ele"),
      py::arg("field_ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with sum number of associated field elements.
ix_field_ele : int
    Index of the field element to point to. This index runs from 1 to num_field_eles(ele).
dz_offset : float
    Longitudinal offset of ele upstream edge from the field ele pointed to.
field_ele : 
)""");
  m.def(
      "ele_rf_step_index",
      &python_ele_rf_step_index,
      py::arg("E_ref"),
      py::arg("s_rel"),
      py::arg("ele"),
      py::arg("ix_step"),
      R"""(No docstring available

Parameters
----------
E_ref : float
    Reference energy of step. If negative, ignore and use s_rel.
s_rel : float
    S-position relative to the beginning of the element
ele : float
    RF cavity.
ix_step : 
)""");
  py::class_<PyEleRfStepIndex, std::unique_ptr<PyEleRfStepIndex>>(
      m, "EleRfStepIndex", "Fortran routine ele_rf_step_index return value")
      .def_readonly("ix_step", &PyEleRfStepIndex::ix_step)
      .def("__len__", [](const PyEleRfStepIndex&) { return 1; })
      .def(
          "__getitem__", [](const PyEleRfStepIndex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_step);
            return py::none();
          });
  m.def(
      "absolute_time_tracking",
      &python_absolute_time_tracking,
      py::arg("ele"),
      py::arg("is_abs_time"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element being tracked through.
is_abs_time : 
)""");
  py::class_<PyAbsoluteTimeTracking, std::unique_ptr<PyAbsoluteTimeTracking>>(
      m,
      "AbsoluteTimeTracking",
      "Fortran routine absolute_time_tracking return value")
      .def_readonly("is_abs_time", &PyAbsoluteTimeTracking::is_abs_time)
      .def("__len__", [](const PyAbsoluteTimeTracking&) { return 1; })
      .def(
          "__getitem__",
          [](const PyAbsoluteTimeTracking& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_abs_time);
            return py::none();
          });
  m.def(
      "knot_interpolate",
      &python_knot_interpolate,
      py::arg("x_knot"),
      py::arg("y_knot"),
      py::arg("x_pt"),
      py::arg("interpolation"),
      py::arg("y_pt"),
      R"""(No docstring available

Parameters
----------
x_knot : float
    Knot x-values.
y_knot : float
    Knot y-values.
x_pt : float
    Point to evaluate at.
interpolation : int
    Interpolation type. cubic$ or linear$.
err_flag : bool
    Set True if there is an error. False otherwise.
y_pt : 
)""");
  py::class_<PyKnotInterpolate, std::unique_ptr<PyKnotInterpolate>>(
      m, "KnotInterpolate", "Fortran routine knot_interpolate return value")
      .def_readonly("err_flag", &PyKnotInterpolate::err_flag)
      .def_readonly("y_pt", &PyKnotInterpolate::y_pt)
      .def("__len__", [](const PyKnotInterpolate&) { return 2; })
      .def(
          "__getitem__",
          [](const PyKnotInterpolate& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.y_pt);
            return py::none();
          });
  m.def(
      "ramper_slave_setup",
      &Bmad::ramper_slave_setup,
      py::arg("lat"),
      py::arg("force_setup") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to be setup.
    This parameter is an input/output and is modified in-place. As an output: Lattice with ramper slaves
    setup.
force_setup : bool, optional
    Default False. If True, do the setup even if lat.ramper_slave_bookkeeping = ok$. But the setup will never
    be done if lat.ramper_slave_bookkeeping = super_ok$.
)""");
  m.def(
      "autoscale_phase_and_amp",
      &Bmad::autoscale_phase_and_amp,
      py::arg("ele"),
      py::arg("param"),
      py::arg("scale_phase") = py::none(),
      py::arg("scale_amp") = py::none(),
      py::arg("call_bookkeeper") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    RF element or e_gun.
    This parameter is an input/output and is modified in-place. As an output: element with phase and amplitude
    adjusted.
param : LatParamStruct
    lattice parameters
err_flag : 
    Logical, Set true if there is an error. False otherwise.
scale_phase : bool, optional
    Scale the phase? See above.
scale_amp : bool, optional
    Scale the amplitude? See above.
call_bookkeeper : bool, optional
    Call lattice_bookkeeper at end? Default is True.
)""");
  m.def(
      "patch_length",
      &python_patch_length,
      py::arg("patch"),
      py::arg("ref_coords") = py::none(),
      py::arg("length"),
      R"""(No docstring available

Parameters
----------
patch : EleStruct
    Patch element.
ref_coords : int, optional
    Reference coords to use. entrance_end$, exit_end$ Default is nint(patch.value(ref_coords$)).
length : 
)""");
  py::class_<PyPatchLength, std::unique_ptr<PyPatchLength>>(
      m, "PatchLength", "Fortran routine patch_length return value")
      .def_readonly("length", &PyPatchLength::length)
      .def("__len__", [](const PyPatchLength&) { return 1; })
      .def("__getitem__", [](const PyPatchLength& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.length);
        return py::none();
      });
  m.def(
      "physical_ele_end",
      &python_physical_ele_end,
      py::arg("track_end"),
      py::arg("orbit"),
      py::arg("ele_orientation"),
      py::arg("return_stream_end") = py::none(),
      py::arg("physical_end"),
      R"""(import

implicit none
type (twiss_struct) twiss
real(rp), optional :: tol
real(rp) x(:), xp(:)
real(rp) tune, emit
real(rp) x_0, xp_0, chi
end subroutine

Parameters
----------
track_end : int
    first_track_edge$, second_track_edge$, surface$, or in_between$
orbit : CoordStruct
    Particle position.
ele_orientation : int
    Either 1 = Normal or -1 = element reversed.
return_stream_end : bool, optional
    If True return the stream end instead of the physical end. Default is False.
)""");
  py::class_<PyPhysicalEleEnd, std::unique_ptr<PyPhysicalEleEnd>>(
      m, "PhysicalEleEnd", "Fortran routine physical_ele_end return value")
      .def_readonly("physical_end", &PyPhysicalEleEnd::physical_end)
      .def("__len__", [](const PyPhysicalEleEnd&) { return 1; })
      .def(
          "__getitem__", [](const PyPhysicalEleEnd& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.physical_end);
            return py::none();
          });
  m.def(
      "transfer_fieldmap",
      &Bmad::transfer_fieldmap,
      py::arg("ele_in"),
      py::arg("who"),
      R"""(No docstring available

Parameters
----------
ele_in : EleStruct
    Input element.
ele_out : EleStruct
    Output element.
who : int
    Possibilities are: all$, cartesian_map$, cylindrical_map$, or grid_field$
)""");
  m.def(
      "control_bookkeeper",
      &Bmad::control_bookkeeper,
      py::arg("lat"),
      py::arg("ele") = py::none(),
      py::arg("err_flag") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    lattice to be used
ele : EleStruct, optional
    Element whose attribute values have been changed. If not present bookkeeping will be done for all
    elements.
err_flag : bool, optional
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "orbit_reference_energy_correction",
      &Bmad::orbit_reference_energy_correction,
      py::arg("orbit"),
      py::arg("p0c_new"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Coordinates to correct.
p0c_new : float
    New reference momentum.
mat6 : float, optional
    Transfer matrix before correction.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    including correction.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "add_lattice_control_structs",
      &Bmad::add_lattice_control_structs,
      py::arg("ele"),
      py::arg("n_add_slave") = py::none(),
      py::arg("n_add_lord") = py::none(),
      py::arg("n_add_slave_field") = py::none(),
      py::arg("n_add_lord_field") = py::none(),
      py::arg("add_at_end") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lord or slave element that needs extra control elements.
n_add_slave : int, optional
    Number of field slaves to add to lord. Default is zero.
n_add_lord : int, optional
    Number of field lords to add to slave. Default is zero.
n_add_slave_field : int, optional
    Number of field slaves to add to lord. Default is zero.
n_add_lord_field : int, optional
    Number of field lords to add to slave. Default is zero.
add_at_end : bool, optional
    Used when n_add_slave or n_add_slave_field is non-zero. If True then new space is added at the end of the
    array. If False then new space is added at the front of the array. Default is True.
)""");
  m.def(
      "transfer_lat_parameters",
      &Bmad::transfer_lat_parameters,
      py::arg("lat_in"),
      R"""(No docstring available

Parameters
----------
lat_in : LatStruct
    Input lat.
lat_out : LatStruct
    Output lat with parameters set.
)""");
  m.def(
      "allocate_lat_ele_array",
      &Bmad::allocate_lat_ele_array,
      py::arg("lat"),
      py::arg("upper_bound") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("do_ramper_slave_setup") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice with element array. .branch(ix_branch).ele(:)  -- Element array to reallocate.
upper_bound : int, optional
    Optional desired upper bound. Default: 1.3*ubound(ele(:)) or 10 if ele is not allocated.
ix_branch : int, optional
    Branch index. Default is 0.
do_ramper_slave_setup : bool, optional
    Default False. If true, setup ramper slaves. Generally this needs to be done if reallocating with a fully
    formed lattice.
)""");
  m.def(
      "track_a_rfcavity",
      &Bmad::track_a_rfcavity,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    rfcavity element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "bbi_slice_calc",
      &Bmad::bbi_slice_calc,
      py::arg("ele"),
      py::arg("n_slice"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    beambeam element
n_slice : int
    Number of slices
z_slice : float
    Array of slice positions 1:n_slice. zero padded for indexes greater than n_slice
)""");
  m.def(
      "init_ele",
      &Bmad::init_ele,
      py::arg("key") = py::none(),
      py::arg("sub_key") = py::none(),
      py::arg("ix_ele") = py::none(),
      py::arg("branch") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Initialized element.
key : int, optional
    Key to initialize to. EG: quadrupole$, etc.
sub_key : int, optional
    Sub-key to initialize to.
ix_ele : int, optional
    ix_ele index to initalize to. Default = -1.
branch : BranchStruct, optional
    Branch to point ele.branch and ele.ix_branch to. Otherwise ele.branch is nullified and ele.ix_branch = 0.
)""");
  m.def(
      "num_field_eles",
      &python_num_field_eles,
      py::arg("ele"),
      py::arg("n_field_ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with sum number of associated field elements.
n_field_ele : 
)""");
  py::class_<PyNumFieldEles, std::unique_ptr<PyNumFieldEles>>(
      m, "NumFieldEles", "Fortran routine num_field_eles return value")
      .def_readonly("n_field_ele", &PyNumFieldEles::n_field_ele)
      .def("__len__", [](const PyNumFieldEles&) { return 1; })
      .def("__getitem__", [](const PyNumFieldEles& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n_field_ele);
        return py::none();
      });
  m.def(
      "transfer_twiss",
      &Bmad::transfer_twiss,
      py::arg("ele_in"),
      py::arg("reverse") = py::none(),
      R"""(No docstring available

Parameters
----------
ele_in : EleStruct
    Element with existing Twiss parameters.
ele_out : EleStruct
    Element receiving the Twiss parameters.
reverse : bool, optional
    Reverse alpha and coupling as if particle is going in the reversed direction? Default is False.
)""");
  m.def(
      "multipole_kick_mat",
      &Bmad::multipole_kick_mat,
      py::arg("knl"),
      py::arg("tilt"),
      py::arg("ref_species"),
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("factor"),
      R"""(No docstring available

Parameters
----------
knl : float
    Strength of multipoles
tilt : float
    Tilt of multipoles
ref_species : int
    Reference species.
ele : EleStruct
    Lattice element containing multipoles.
orbit : CoordStruct
    coordinates of particle around which the multipole kick matrix is computed.
factor : float
    Factor to scale knl by.
mat6 : float
    matrix with kick values at mat6(2:4:2, 1:3:2). The rest of the matrix is untouched.
)""");
  m.def(
      "make_mat6_bmad",
      &Bmad::make_mat6_bmad,
      py::arg("ele"),
      py::arg("param"),
      py::arg("start_orb"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to track through.
    This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
param : LatParamStruct
    Parameters are needed for some elements.
start_orb : CoordStruct
    Starting coords.
end_orb : CoordStruct
    Coordinates at the end of element.
err : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<Bmad::MakeMat6Bmad, std::unique_ptr<Bmad::MakeMat6Bmad>>(
      m, "MakeMat6Bmad", "Fortran routine make_mat6_bmad return value")
      .def_readonly("end_orb", &Bmad::MakeMat6Bmad::end_orb)
      .def_readonly("err", &Bmad::MakeMat6Bmad::err)
      .def("__len__", [](const Bmad::MakeMat6Bmad&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::MakeMat6Bmad& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_orb);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "transfer_ac_kick",
      &Bmad::transfer_ac_kick,
      py::arg("ac_in"),
      R"""(No docstring available

Parameters
----------
ac_in : AcKickerStruct
    Input
ac_out : AcKickerStruct
    Gets set equal to ac_in
)""");
  m.def(
      "pointer_to_branch",
      py::overload_cast<
          std::string,
          LatProxy&,
          std::optional<bool>,
          std::optional<int>>(&Bmad::pointer_to_branch),
      py::arg("branch_name"),
      py::arg("lat"),
      py::arg("parameter_is_branch0") = py::none(),
      py::arg("blank_branch") = py::none(),
      R"""(Routine to return a pointer to the lattice branch associated with a given name

or a given element.
pointer_to_branch_given_ele (ele) result (branch_ptr))
pointer_to_branch_given_name (branch_name, lat, parameter_is_branch0, blank_branch) result (branch_ptr)
The lattice branch *associated* with a given element is not necessarily the
branch where the element is *located*. For example, all lords live in branch #0.
But the branch associated with a super_lord element is the branch of its slaves.
To get the branch where the element is located, simply use ele%ix_branch.

Parameters
----------
ele : EleStruct
    Element contained in the branch.
branch_name : unknown
    May be a branch name or a branch index.
lat : LatStruct
    Lattice to search.
parameter_is_branch0 : bool, optional
    If True, 'PARAMETER' is taken to be an alternative name for branch(0). Default is False.
blank_branch : int, optional
    Branch index if branch_name = ''. Default is blank is an error.

Returns
-------
branch_ptr : BranchStruct
    Pointer to the branch. Nullified if there is no associated branch.

Notes
-----
Overloaded versions:
)""");
  m.def(
      "pointer_to_branch",
      py::overload_cast<EleProxy&>(&Bmad::pointer_to_branch),
      py::arg("ele"),
      R"""(Routine to return a pointer to the lattice branch associated with a given name

or a given element.
pointer_to_branch_given_ele (ele) result (branch_ptr))
pointer_to_branch_given_name (branch_name, lat, parameter_is_branch0, blank_branch) result (branch_ptr)
The lattice branch *associated* with a given element is not necessarily the
branch where the element is *located*. For example, all lords live in branch #0.
But the branch associated with a super_lord element is the branch of its slaves.
To get the branch where the element is located, simply use ele%ix_branch.

Parameters
----------
ele : EleStruct
    Element contained in the branch.
branch_name : unknown
    May be a branch name or a branch index.
lat : LatStruct
    Lattice to search.
parameter_is_branch0 : bool, optional
    If True, 'PARAMETER' is taken to be an alternative name for branch(0). Default is False.
blank_branch : int, optional
    Branch index if branch_name = ''. Default is blank is an error.

Returns
-------
branch_ptr : BranchStruct
    Pointer to the branch. Nullified if there is no associated branch.

Notes
-----
Overloaded versions:
)""");
  m.def(
      "allocate_branch_array",
      &Bmad::allocate_branch_array,
      py::arg("lat"),
      py::arg("upper_bound"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    .branch(:)  -- Branch array to be allocated.
upper_bound : int
    Desired upper bound.
)""");
  m.def(
      "entering_element",
      &python_entering_element,
      py::arg("orbit"),
      py::arg("particle_at"),
      py::arg("is_entering"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle orbit.
particle_at : int
    First_track_edge$ or second_track_edge$
is_entering : 
)""");
  py::class_<PyEnteringElement, std::unique_ptr<PyEnteringElement>>(
      m, "EnteringElement", "Fortran routine entering_element return value")
      .def_readonly("is_entering", &PyEnteringElement::is_entering)
      .def("__len__", [](const PyEnteringElement&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEnteringElement& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_entering);
            return py::none();
          });
  m.def(
      "track_a_pickup",
      &python_track_a_pickup,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("err_flag") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Pickup element.
param : LatParamStruct
    Lattice parameters.
err_flag : 
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  py::class_<PyTrackAPickup, std::unique_ptr<PyTrackAPickup>>(
      m, "TrackAPickup", "Fortran routine track_a_pickup return value")
      .def_readonly("mat6", &PyTrackAPickup::mat6)
      .def_readonly("err_flag", &PyTrackAPickup::err_flag)
      .def("__len__", [](const PyTrackAPickup&) { return 2; })
      .def("__getitem__", [](const PyTrackAPickup& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.mat6);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "track_a_drift",
      &python_track_a_drift,
      py::arg("orb"),
      py::arg("length"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      py::arg("ele_orientation") = py::none(),
      py::arg("include_ref_motion") = py::none(),
      py::arg("time") = py::none(),
      R"""(No docstring available

Parameters
----------
orb : CoordStruct
    Orbit at start of the drift.
    This parameter is an input/output and is modified in-place. As an output: Orbit at end of the drift.
length : float
    Length to drift through in body coordinates. --    If orb.direction = 1, positive length is in +z
    direction and vice versa.
mat6 : float, optional
    Transfer matrix up to the drift.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
    drift.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
ele_orientation : int, optional
    Element orientation. Default is orb.direction.
include_ref_motion : bool, optional
    Include effect of the motion of the reference particle? Default is True. False is basically only used by
    offset_particle. Additionally, if False, orb.s is not changed.
time : float, optional
    Particle time before drifting. Typically this is an RF clock time which may not be equal to orb.t
    This parameter is an input/output and is modified in-place. As an output: Updated time.
)""");
  py::class_<PyTrackADrift, std::unique_ptr<PyTrackADrift>>(
      m, "TrackADrift", "Fortran routine track_a_drift return value")
      .def_readonly("time", &PyTrackADrift::time)
      .def("__len__", [](const PyTrackADrift&) { return 1; })
      .def("__getitem__", [](const PyTrackADrift& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.time);
        return py::none();
      });
  m.def(
      "match_ele_to_mat6",
      &Bmad::match_ele_to_mat6,
      py::arg("ele"),
      py::arg("start_orb"),
      py::arg("include_delta_time") = py::none(),
      py::arg("set_trombone") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Match element.
start_orb : CoordStruct
    Starting orbit.
mat6 : float
    Transfer matrix (1st order part of xfer map).
vec0 : float
    0th order part of the transfer map.
err_flag : bool
    Set true if there is an error. False otherwise.
include_delta_time : bool, optional
    If False, ignore any finite ele.value(delta_time$). Default is True.
set_trombone : bool, optional
    Default is False. If True, set the beginning and ending Twiss values in the element to create a phase
    trombone.
)""");
  py::class_<Bmad::MatchEleToMat6, std::unique_ptr<Bmad::MatchEleToMat6>>(
      m, "MatchEleToMat6", "Fortran routine match_ele_to_mat6 return value")
      .def_readonly("mat6", &Bmad::MatchEleToMat6::mat6)
      .def_readonly("vec0", &Bmad::MatchEleToMat6::vec0)
      .def_readonly("err_flag", &Bmad::MatchEleToMat6::err_flag)
      .def("__len__", [](const Bmad::MatchEleToMat6&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::MatchEleToMat6& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.mat6);
            if (i == 1)
              return py::cast(s.vec0);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "track1_runge_kutta",
      &Bmad::track1_runge_kutta,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Ending coords.
ele : 
    Ele_struct
param : LatParamStruct
    Lattice parameters.
err_flag : bool
    Set True if there is an error. False otherwise.
track : TrackStruct
    Structure holding the track information.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
    through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  py::class_<Bmad::Track1RungeKutta, std::unique_ptr<Bmad::Track1RungeKutta>>(
      m, "Track1RungeKutta", "Fortran routine track1_runge_kutta return value")
      .def_readonly("err_flag", &Bmad::Track1RungeKutta::err_flag)
      .def_readonly("track", &Bmad::Track1RungeKutta::track)
      .def("__len__", [](const Bmad::Track1RungeKutta&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::Track1RungeKutta& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.track);
            return py::none();
          });
  m.def(
      "transfer_branch",
      &Bmad::transfer_branch,
      py::arg("branch1"),
      R"""(No docstring available

Parameters
----------
branch1 : BranchStruct
branch2 : BranchStruct
)""");
  m.def(
      "track_a_zero_length_element",
      &Bmad::track_a_zero_length_element,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Ending coords.
ele : EleStruct
    Element tracked through.
param : LatParamStruct
    Lattice parameters.
err_flag : bool
    Set True if there is an error. False otherwise.
track : TrackStruct
    Structure holding the track information.
)""");
  py::class_<
      Bmad::TrackAZeroLengthElement,
      std::unique_ptr<Bmad::TrackAZeroLengthElement>>(
      m,
      "TrackAZeroLengthElement",
      "Fortran routine track_a_zero_length_element return value")
      .def_readonly("err_flag", &Bmad::TrackAZeroLengthElement::err_flag)
      .def_readonly("track", &Bmad::TrackAZeroLengthElement::track)
      .def("__len__", [](const Bmad::TrackAZeroLengthElement&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TrackAZeroLengthElement& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.track);
            return py::none();
          });
  m.def(
      "transfer_ele",
      &Bmad::transfer_ele,
      py::arg("ele1"),
      py::arg("nullify_pointers") = py::none(),
      R"""(No docstring available

Parameters
----------
ele1 : EleStruct
ele2 : EleStruct
nullify_pointers : bool, optional
    If present and True then nullify the pointers in ele2 except for the ele2.lat and ele2.lord pointers. This
    gives a "bare bones" copy where one does not have to worry about deallocating allocated structure
    components later.
)""");
  m.def(
      "remove_lord_slave_link",
      &Bmad::remove_lord_slave_link,
      py::arg("lord"),
      py::arg("slave"),
      R"""(No docstring available

Parameters
----------
lord : EleStruct
    Lord element
    This parameter is an input/output and is modified in-place. As an output: Lord element with link info
    removed
slave : EleStruct
    Slave element
    This parameter is an input/output and is modified in-place. As an output: Slave element with link info
    removed
)""");
  m.def(
      "track_a_lcavity",
      &Bmad::track_a_lcavity,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Thick multipole element.
param : LatParamStruct
    Lattice parameters.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
    element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "rf_coupler_kick",
      &Bmad::rf_coupler_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("phase"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(import

implicit none
type (branch_struct), target :: branch
integer n_rf_included, n_rf_excluded
logical ok
end function

Parameters
----------
ele : EleStruct
    Element being tracked through
param : LatParamStruct
    branch parameters.
particle_at : int
    first_track_edge$, or second_track_edge$.
phase : float
    phase of cavity
orbit : CoordStruct
    Position before kick.
    This parameter is an input/output and is modified in-place. As an output: Position after kick.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
    element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.

Returns
-------
ok
)""");
  m.def(
      "lcavity_rf_step_setup",
      &Bmad::lcavity_rf_step_setup,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lcavity element.
    This parameter is an input/output and is modified in-place. As an output: Element with ele.rf properly
    setup.
)""");
  m.def(
      "init_multipole_cache",
      &Bmad::init_multipole_cache,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to init
    This parameter is an input/output and is modified in-place. As an output: Initalized element.
)""");
  m.def(
      "track_a_quadrupole",
      &Bmad::track_a_quadrupole,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Quadrupole element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "deallocate_lat_pointers",
      &Bmad::deallocate_lat_pointers,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat with pointers.
    This parameter is an input/output and is modified in-place. As an output: Lat with deallocated pointers.
)""");
  m.def(
      "apply_energy_kick",
      &Bmad::apply_energy_kick,
      py::arg("dE"),
      py::arg("orbit"),
      py::arg("ddE_dr"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
dE : float
    Energy change
orbit : CoordStruct
    Beginning coordinates
    This parameter is an input/output and is modified in-place. As an output: coordinates with added dE energy
    kick.
ddE_dr : 
    real(rp), Derivatives of dE [ddE_dx, ddE_dy].
mat6 : float, optional
    Transfer matrix before fringe.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    including energy kick.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "make_mat6_taylor",
      &python_make_mat6_taylor,
      py::arg("ele"),
      py::arg("start_orb"),
      py::arg("err_flag") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to track through.
    This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
start_orb : CoordStruct
    Starting coords.
end_orb : CoordStruct
    Coordinates at the end of element.
err_flag : 
)""");
  py::class_<PyMakeMat6Taylor, std::unique_ptr<PyMakeMat6Taylor>>(
      m, "MakeMat6Taylor", "Fortran routine make_mat6_taylor return value")
      .def_readonly("end_orb", &PyMakeMat6Taylor::end_orb)
      .def_readonly("err_flag", &PyMakeMat6Taylor::err_flag)
      .def("__len__", [](const PyMakeMat6Taylor&) { return 2; })
      .def(
          "__getitem__", [](const PyMakeMat6Taylor& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_orb);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "twiss_to_1_turn_mat",
      &Bmad::twiss_to_1_turn_mat,
      py::arg("twiss"),
      py::arg("phi"),
      R"""(No docstring available

Parameters
----------
twiss : TwissStruct
    Structure holding the Twiss parameters. .beta .alpha
phi : float
    Tune in radians.
mat2 : float
    1-turn matrix.
)""");
  m.def(
      "master_parameter_value",
      &python_master_parameter_value,
      py::arg("master_parameter"),
      py::arg("ele"),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
master_parameter : int
    Index of the master parameter.
ele : EleStruct
    Element containing the fieldmap.
value : 
)""");
  py::class_<PyMasterParameterValue, std::unique_ptr<PyMasterParameterValue>>(
      m,
      "MasterParameterValue",
      "Fortran routine master_parameter_value return value")
      .def_readonly("value", &PyMasterParameterValue::value)
      .def("__len__", [](const PyMasterParameterValue&) { return 1; })
      .def(
          "__getitem__",
          [](const PyMasterParameterValue& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "track1_taylor",
      &Bmad::track1_taylor,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("taylor") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Ending coords.
ele : EleStruct
    Element to track through.
taylor : TaylorStruct, optional
    Alternative map to use instead of ele.taylor.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "make_mat6_symp_lie_ptc",
      &Bmad::make_mat6_symp_lie_ptc,
      py::arg("ele"),
      py::arg("start_orb"),
      R"""(import

implicit none
type (ele_struct), target :: ele
type (coord_struct) :: start_orb, end_orb
type (lat_param_struct) param
end subroutine

Parameters
----------
ele : EleStruct
    Element with transfer matrix
    This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
start_orb : CoordStruct
    Coordinates at the beginning of element.

Returns
-------
end_orb : CoordStruct
    Coordinates at end of element.
)""");
  m.def(
      "ele_reference_energy_correction",
      &Bmad::ele_reference_energy_correction,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("particle_at"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(import

implicit none
type (ele_struct) ele
end subroutine

Parameters
----------
ele : EleStruct
    Element being tracked through.
orbit : CoordStruct
    Coordinates to correct.
particle_at : int
    first_track_edge$ (that is, entering the element), or second_track_edge$ (that is, leaving the element),
    or upstream_end$ (inherit ele.value(p0c_start$) ref), or downstream_end$ (inherit ele.value(p0c$)).
    inside$ (or anything else) -> Do nothing.
mat6 : float, optional
    Transfer matrix before correction.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    including correction.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "track_a_thick_multipole",
      &Bmad::track_a_thick_multipole,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Thick multipole element.
param : LatParamStruct
    Lattice parameters.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
    element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "track_a_converter",
      &Bmad::track_a_converter,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    converter element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "reallocate_control",
      &Bmad::reallocate_control,
      py::arg("lat"),
      py::arg("n"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice.
n : int
    Array size for lat.control(:) and lat.ic(:).
)""");
  m.def(
      "distance_to_aperture",
      &python_distance_to_aperture,
      py::arg("orbit"),
      py::arg("particle_at"),
      py::arg("ele"),
      py::arg("dist"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle position.
particle_at : int
    first_track_edge$, second_track_edge$, or in_between$
ele : EleStruct
    Element containing aperture.
no_aperture_here : bool
    True if aperture does not exist at the longitudinal location of the particle.
dist : 
)""");
  py::class_<PyDistanceToAperture, std::unique_ptr<PyDistanceToAperture>>(
      m,
      "DistanceToAperture",
      "Fortran routine distance_to_aperture return value")
      .def_readonly("no_aperture_here", &PyDistanceToAperture::no_aperture_here)
      .def_readonly("dist", &PyDistanceToAperture::dist)
      .def("__len__", [](const PyDistanceToAperture&) { return 2; })
      .def(
          "__getitem__",
          [](const PyDistanceToAperture& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.no_aperture_here);
            if (i == 1)
              return py::cast(s.dist);
            return py::none();
          });
  m.def(
      "tilt_mat6",
      &Bmad::tilt_mat6,
      py::arg("mat6"),
      py::arg("tilt"),
      R"""(No docstring available

Parameters
----------
mat6 : float
    Untilted matrix.
    This parameter is an input/output and is modified in-place. As an output: Tilted matrix.
tilt : float
    Tilt angle.
)""");
  m.def(
      "set_flags_for_changed_attribute",
      py::overload_cast<EleProxy&, int, std::optional<bool>>(
          &python_set_flags_for_changed_integer_attribute),
      py::arg("ele"),
      py::arg("attrib"),
      py::arg("set_dependent") = py::none(),
      R"""(Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.

Also will do some dependent variable bookkeeping when a particular attribute has
been altered.
This routine should be called after the attribute has been set.
set_flags_for_changed_lat_attribute (lat, set_dependent)
set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
The set_flags_for_changed_lat_attribute (lat) routine is used when one
does not know what has changed and wants a complete bookkeeping done.
And NOT:
call set_flags_for_changed_attribute (ele, off_value)  ! WRONG

Parameters
----------
lat : LatStruct
    Lattice being modified.
    This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
    changes.
ele : 
    ele_struct, Element being modified.
real_attrib : float, optional
    Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
    potentially changed.
int_attrib : int
    Attribute that has been changed. For example: ele.mat6_calc_method.
logic_attrib : unknown
    ele.is_on.
all_attrib : AllPointerStruct
    Pointer to attribute.
set_dependent : bool, optional
    If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
    when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
    doing.

Notes
-----
NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
Overloaded versions:
)""");
  py::class_<
      PySetFlagsForChangedIntegerAttribute,
      std::unique_ptr<PySetFlagsForChangedIntegerAttribute>>(
      m,
      "SetFlagsForChangedIntegerAttribute",
      "Fortran routine set_flags_for_changed_integer_attribute return value")
      .def_readonly("attrib", &PySetFlagsForChangedIntegerAttribute::attrib)
      .def(
          "__len__",
          [](const PySetFlagsForChangedIntegerAttribute&) { return 1; })
      .def(
          "__getitem__",
          [](const PySetFlagsForChangedIntegerAttribute& s,
             size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.attrib);
            return py::none();
          });
  m.def(
      "set_flags_for_changed_attribute",
      py::overload_cast<EleProxy&, bool, std::optional<bool>>(
          &python_set_flags_for_changed_logical_attribute),
      py::arg("ele"),
      py::arg("attrib"),
      py::arg("set_dependent") = py::none(),
      R"""(Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.

Also will do some dependent variable bookkeeping when a particular attribute has
been altered.
This routine should be called after the attribute has been set.
set_flags_for_changed_lat_attribute (lat, set_dependent)
set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
The set_flags_for_changed_lat_attribute (lat) routine is used when one
does not know what has changed and wants a complete bookkeeping done.
And NOT:
call set_flags_for_changed_attribute (ele, off_value)  ! WRONG

Parameters
----------
lat : LatStruct
    Lattice being modified.
    This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
    changes.
ele : 
    ele_struct, Element being modified.
real_attrib : float, optional
    Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
    potentially changed.
int_attrib : int
    Attribute that has been changed. For example: ele.mat6_calc_method.
logic_attrib : unknown
    ele.is_on.
all_attrib : AllPointerStruct
    Pointer to attribute.
set_dependent : bool, optional
    If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
    when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
    doing.

Notes
-----
NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
Overloaded versions:
)""");
  py::class_<
      PySetFlagsForChangedLogicalAttribute,
      std::unique_ptr<PySetFlagsForChangedLogicalAttribute>>(
      m,
      "SetFlagsForChangedLogicalAttribute",
      "Fortran routine set_flags_for_changed_logical_attribute return value")
      .def_readonly("attrib", &PySetFlagsForChangedLogicalAttribute::attrib)
      .def(
          "__len__",
          [](const PySetFlagsForChangedLogicalAttribute&) { return 1; })
      .def(
          "__getitem__",
          [](const PySetFlagsForChangedLogicalAttribute& s,
             size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.attrib);
            return py::none();
          });
  m.def(
      "set_flags_for_changed_attribute",
      py::overload_cast<LatProxy&, std::optional<bool>>(
          &Bmad::set_flags_for_changed_attribute),
      py::arg("lat"),
      py::arg("set_dependent") = py::none(),
      R"""(Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.

Also will do some dependent variable bookkeeping when a particular attribute has
been altered.
This routine should be called after the attribute has been set.
set_flags_for_changed_lat_attribute (lat, set_dependent)
set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
The set_flags_for_changed_lat_attribute (lat) routine is used when one
does not know what has changed and wants a complete bookkeeping done.
And NOT:
call set_flags_for_changed_attribute (ele, off_value)  ! WRONG

Parameters
----------
lat : LatStruct
    Lattice being modified.
    This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
    changes.
ele : 
    ele_struct, Element being modified.
real_attrib : float, optional
    Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
    potentially changed.
int_attrib : int
    Attribute that has been changed. For example: ele.mat6_calc_method.
logic_attrib : unknown
    ele.is_on.
all_attrib : AllPointerStruct
    Pointer to attribute.
set_dependent : bool, optional
    If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
    when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
    doing.

Notes
-----
NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
Overloaded versions:
)""");
  m.def(
      "set_flags_for_changed_attribute",
      py::overload_cast<EleProxy&, std::optional<double>, std::optional<bool>>(
          &python_set_flags_for_changed_real_attribute),
      py::arg("ele"),
      py::arg("attrib") = py::none(),
      py::arg("set_dependent") = py::none(),
      R"""(Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.

Also will do some dependent variable bookkeeping when a particular attribute has
been altered.
This routine should be called after the attribute has been set.
set_flags_for_changed_lat_attribute (lat, set_dependent)
set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
The set_flags_for_changed_lat_attribute (lat) routine is used when one
does not know what has changed and wants a complete bookkeeping done.
And NOT:
call set_flags_for_changed_attribute (ele, off_value)  ! WRONG

Parameters
----------
lat : LatStruct
    Lattice being modified.
    This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
    changes.
ele : 
    ele_struct, Element being modified.
real_attrib : float, optional
    Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
    potentially changed.
int_attrib : int
    Attribute that has been changed. For example: ele.mat6_calc_method.
logic_attrib : unknown
    ele.is_on.
all_attrib : AllPointerStruct
    Pointer to attribute.
set_dependent : bool, optional
    If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
    when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
    doing.

Notes
-----
NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
Overloaded versions:
)""");
  py::class_<
      PySetFlagsForChangedRealAttribute,
      std::unique_ptr<PySetFlagsForChangedRealAttribute>>(
      m,
      "SetFlagsForChangedRealAttribute",
      "Fortran routine set_flags_for_changed_real_attribute return value")
      .def_readonly("attrib", &PySetFlagsForChangedRealAttribute::attrib)
      .def(
          "__len__", [](const PySetFlagsForChangedRealAttribute&) { return 1; })
      .def(
          "__getitem__",
          [](const PySetFlagsForChangedRealAttribute& s,
             size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.attrib);
            return py::none();
          });
  m.def(
      "transfer_branch_parameters",
      &Bmad::transfer_branch_parameters,
      py::arg("branch_in"),
      R"""(No docstring available

Parameters
----------
branch_in : BranchStruct
    Input branch.
branch_out : BranchStruct
    Output branch with parameters set.
)""");
  m.def(
      "make_g2_mats",
      &Bmad::make_g2_mats,
      py::arg("twiss"),
      py::arg("g2_mat"),
      py::arg("g2_inv_mat"),
      R"""(No docstring available

Parameters
----------
twiss : TwissStruct
    Twiss parameters.
g2_mat : 
g2_inv_mat : 
)""");
  m.def(
      "mat4_multipole",
      &python_mat4_multipole,
      py::arg("knl"),
      py::arg("tilt"),
      py::arg("n"),
      py::arg("orbit"),
      R"""(No docstring available

Parameters
----------
knl : float
    Strength of multipole
tilt : float
    Tilt of multipole
n : 
orbit : CoordStruct
    coordinates of particle
kick_mat : float
    Kick matrix (Jacobian) at orbit.
)""");
  py::class_<PyMat4Multipole, std::unique_ptr<PyMat4Multipole>>(
      m, "Mat4Multipole", "Fortran routine mat4_multipole return value")
      .def_readonly("kick_mat", &PyMat4Multipole::kick_mat)
      .def_readonly("n", &PyMat4Multipole::n)
      .def("__len__", [](const PyMat4Multipole&) { return 2; })
      .def("__getitem__", [](const PyMat4Multipole& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.kick_mat);
        if (i == 1)
          return py::cast(s.n);
        return py::none();
      });
  m.def(
      "track_a_lcavity_old",
      &Bmad::track_a_lcavity_old,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Thick multipole element.
param : LatParamStruct
    Lattice parameters.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
    element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "bend_length_has_been_set",
      &python_bend_length_has_been_set,
      py::arg("ele"),
      py::arg("is_set"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to be checked. Ouput:
is_set : 
)""");
  py::class_<PyBendLengthHasBeenSet, std::unique_ptr<PyBendLengthHasBeenSet>>(
      m,
      "BendLengthHasBeenSet",
      "Fortran routine bend_length_has_been_set return value")
      .def_readonly("is_set", &PyBendLengthHasBeenSet::is_set)
      .def("__len__", [](const PyBendLengthHasBeenSet&) { return 1; })
      .def(
          "__getitem__",
          [](const PyBendLengthHasBeenSet& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_set);
            return py::none();
          });
  m.def(
      "init_lat",
      &Bmad::init_lat,
      py::arg("n") = py::none(),
      py::arg("init_beginning_ele") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Initialized lat.
n : int, optional
    Upper bound lat.ele(0:) array is initialized to. Default is 10.
init_beginning_ele : bool, optional
    Init lat.ele(0)? Default is False.
)""");
  m.def(
      "track1_bmad",
      &Bmad::track1_bmad,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Element
param : LatParamStruct
    .particle     -- Particle type
err_flag : bool
    Set true if there is an error. False otherwise.
track : TrackStruct
    Structure holding the track information if the lattice element does tracking step-by-step. See track1 for
    more details.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
    through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  py::class_<Bmad::Track1Bmad, std::unique_ptr<Bmad::Track1Bmad>>(
      m, "Track1Bmad", "Fortran routine track1_bmad return value")
      .def_readonly("err_flag", &Bmad::Track1Bmad::err_flag)
      .def_readonly("track", &Bmad::Track1Bmad::track)
      .def("__len__", [](const Bmad::Track1Bmad&) { return 2; })
      .def(
          "__getitem__", [](const Bmad::Track1Bmad& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.track);
            return py::none();
          });
  m.def(
      "deallocate_ele_pointers",
      &Bmad::deallocate_ele_pointers,
      py::arg("ele"),
      py::arg("nullify_only") = py::none(),
      py::arg("nullify_branch") = py::none(),
      py::arg("dealloc_poles") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with pointers.
    This parameter is an input/output and is modified in-place. As an output: Element with deallocated
    pointers.
nullify_only : bool, optional
    If present and True: Nullify & do not deallocate.
nullify_branch : bool, optional
    Nullify ele.branch? Default is True.
dealloc_poles : bool, optional
    Dealloc ele.a/b_pole, ele.a/b_pole_elec? Default is True.
)""");
  m.def(
      "init_bmad",
      &Bmad::init_bmad,
      R"""(No docstring available

)""");
  m.def(
      "gen_grad_at_s_to_em_taylor",
      &Bmad::gen_grad_at_s_to_em_taylor,
      py::arg("ele"),
      py::arg("gen_grad"),
      py::arg("s_pos"),
      R"""(No docstring available

Parameters
----------
ele : unknown
    Element containing the map.
gen_grad : GenGradMapStruct
    Gen_grad map.
s_pos : float
    Position to evaluate em_taylor at.
em_taylor : EmTaylorStruct
    Map for (Bx, By, Bz) or (Ex, Ey, Ez) fields.
)""");
  m.def(
      "rf_ref_time_offset",
      &python_rf_ref_time_offset,
      py::arg("ele"),
      py::arg("ds") = py::none(),
      py::arg("time"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    RF Element being tracked through.
ds : float, optional
    Distance of particle from start edge. Default is zero. Ouput:
time : 
)""");
  py::class_<PyRfRefTimeOffset, std::unique_ptr<PyRfRefTimeOffset>>(
      m, "RfRefTimeOffset", "Fortran routine rf_ref_time_offset return value")
      .def_readonly("time", &PyRfRefTimeOffset::time)
      .def("__len__", [](const PyRfRefTimeOffset&) { return 1; })
      .def(
          "__getitem__",
          [](const PyRfRefTimeOffset& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.time);
            return py::none();
          });
  m.def(
      "track_a_beambeam",
      &Bmad::track_a_beambeam,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Beambeam element.
param : LatParamStruct
    Lattice parameters.
track : TrackStruct
    Structure holding the track information if the lattice element does tracking step-by-step. See track1 for
    more details.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  py::class_<Bmad::TrackABeambeam, std::unique_ptr<Bmad::TrackABeambeam>>(
      m, "TrackABeambeam", "Fortran routine track_a_beambeam return value")
      .def_readonly("track", &Bmad::TrackABeambeam::track)
      .def_readonly("mat6", &Bmad::TrackABeambeam::mat6)
      .def("__len__", [](const Bmad::TrackABeambeam&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TrackABeambeam& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.track);
            if (i == 1)
              return py::cast(s.mat6);
            return py::none();
          });
  m.def(
      "tracking_rad_map_setup",
      &Bmad::tracking_rad_map_setup,
      py::arg("ele"),
      py::arg("tollerance"),
      py::arg("ref_edge"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to setup. Matrices will be with respect to the map reference orbit.
tollerance : float
    Tolerance used for the computation.
ref_edge : int
    Edge that the matrices are referenced to. upstream_end$ or downstream_end$.
rad_map : RadMapStruct
    Structure holding the matrices.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::TrackingRadMapSetup,
      std::unique_ptr<Bmad::TrackingRadMapSetup>>(
      m,
      "TrackingRadMapSetup",
      "Fortran routine tracking_rad_map_setup return value")
      .def_readonly("rad_map", &Bmad::TrackingRadMapSetup::rad_map)
      .def_readonly("err_flag", &Bmad::TrackingRadMapSetup::err_flag)
      .def("__len__", [](const Bmad::TrackingRadMapSetup&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TrackingRadMapSetup& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rad_map);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "track1_symp_lie_ptc",
      &Bmad::track1_symp_lie_ptc,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position
    This parameter is an input/output and is modified in-place. As an output: End position
ele : EleStruct
    Element
param : LatParamStruct
track : TrackStruct
    Structure holding the track information.
)""");
  m.def(
      "track1_time_runge_kutta",
      &python_track1_time_runge_kutta,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("t_end") = py::none(),
      py::arg("dt_step") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    starting position, z-based coords
    This parameter is an input/output and is modified in-place. As an output: end position, z-based coords
ele : EleStruct
    element
param : LatParamStruct
    lattice parameters
err_flag : bool
    Set True if there is an error. False otherwise
track : TrackStruct
    Contains array of the step-by-step particle trajectory along with the field at these positions. When
    tracking through multiple elements, the trajectory in an element is appended to the existing trajectory.
    To reset: Set track.n_pt = -1.
t_end : float, optional
    If present, maximum time to which the particle will be tracked. Used for tracking with given time steps.
    The time orb.t at which tracking stops may be less than this if the particle gets to the end of the
    element
dt_step : float, optional
    If positive, next RK time step to take. This overrides bmad_com.init_ds_adaptive_tracking. Used by
    track_bunch_time.
    This parameter is an input/output and is modified in-place. As an output: Next RK time step that this
    tracker would take based on the error tolerance.
)""");
  py::class_<PyTrack1TimeRungeKutta, std::unique_ptr<PyTrack1TimeRungeKutta>>(
      m,
      "Track1TimeRungeKutta",
      "Fortran routine track1_time_runge_kutta return value")
      .def_readonly("err_flag", &PyTrack1TimeRungeKutta::err_flag)
      .def_readonly("track", &PyTrack1TimeRungeKutta::track)
      .def_readonly("dt_step", &PyTrack1TimeRungeKutta::dt_step)
      .def("__len__", [](const PyTrack1TimeRungeKutta&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTrack1TimeRungeKutta& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.track);
            if (i == 2)
              return py::cast(s.dt_step);
            return py::none();
          });
  m.def(
      "make_mat6_tracking",
      &Bmad::make_mat6_tracking,
      py::arg("ele"),
      py::arg("param"),
      py::arg("start_orb"),
      py::arg("spin_only") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with transfer matrix
    This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
param : LatParamStruct
    Parameters are needed for some elements.
start_orb : CoordStruct
    Coordinates at the beginning of element.
end_orb : CoordStruct
    Coordinates at the end of element.
err_flag : bool
    Set True if there is an error. False otherwise.
spin_only : bool, optional
    Default False. If True, only calculate ele.spin_taylor.
)""");
  py::class_<Bmad::MakeMat6Tracking, std::unique_ptr<Bmad::MakeMat6Tracking>>(
      m, "MakeMat6Tracking", "Fortran routine make_mat6_tracking return value")
      .def_readonly("end_orb", &Bmad::MakeMat6Tracking::end_orb)
      .def_readonly("err_flag", &Bmad::MakeMat6Tracking::err_flag)
      .def("__len__", [](const Bmad::MakeMat6Tracking&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::MakeMat6Tracking& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_orb);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "transfer_mat2_from_twiss",
      &Bmad::transfer_mat2_from_twiss,
      py::arg("twiss1"),
      py::arg("twiss2"),
      R"""(No docstring available

Parameters
----------
twiss1 : TwissStruct
    Twiss parameters at the initial point. .beta   -- Beta parameter. .alpha  -- Alpha parameter. .phi    --
    Phase at initial point.
twiss2 : TwissStruct
    Twiss parameters at the end point. .beta   -- Beta parameter. .alpha  -- Alpha parameter. .phi    -- Phase
    at final point.
mat : float
    Transfer matrix between the two points.
)""");
  m.def(
      "set_lords_status_stale",
      &Bmad::set_lords_status_stale,
      py::arg("ele"),
      py::arg("stat_group"),
      py::arg("control_bookkeeping") = py::none(),
      py::arg("flag") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
stat_group : int
    which status group to set. floor_position_group$, etc. See set_ele_status_stale for more details.
control_bookkeeping : bool, optional
    Call control_bookkeeper for each lord if needed? -- logical, optional: Call control_bookkeeper for each
    lord if needed? Default if False.
flag : int, optional
    Do not use. For coordinating recursion. ele.lat    -- Lat_struct: Lattice with status flags of lords of
    ele set.
)""");
  m.def(
      "calc_super_slave_key",
      &Bmad::calc_super_slave_key,
      py::arg("lord1"),
      py::arg("lord2"),
      py::arg("create_jumbo_slave") = py::none(),
      R"""(No docstring available

Parameters
----------
lord1 : EleStruct
    First slave. .key .sub_key
lord2 : EleStruct
    Second slave. .key .sub_key
slave : EleStruct
    Super_slave element. .key        -- Set to -1 if there is an error. .sub_key
create_jumbo_slave : bool, optional
    If True then slave.key will be set to em_field. -- Logical, optional: If True then slave.key will be set
    to em_field. Default is False.
)""");
  m.def(
      "strong_beam_strength",
      &python_strong_beam_strength,
      py::arg("ele"),
      py::arg("strength"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Beambeam element.
strength : 
)""");
  py::class_<PyStrongBeamStrength, std::unique_ptr<PyStrongBeamStrength>>(
      m,
      "StrongBeamStrength",
      "Fortran routine strong_beam_strength return value")
      .def_readonly("strength", &PyStrongBeamStrength::strength)
      .def("__len__", [](const PyStrongBeamStrength&) { return 1; })
      .def(
          "__getitem__",
          [](const PyStrongBeamStrength& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.strength);
            return py::none();
          });
  m.def(
      "ramper_value",
      &python_ramper_value,
      py::arg("ramper"),
      py::arg("r1"),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
ramper : EleStruct
    Ramper lord.
r1 : ControlRamp1Struct
    Slave function.
err_flag : bool
    Set True if there is an error, False otherwise.
value : 
)""");
  py::class_<PyRamperValue, std::unique_ptr<PyRamperValue>>(
      m, "RamperValue", "Fortran routine ramper_value return value")
      .def_readonly("err_flag", &PyRamperValue::err_flag)
      .def_readonly("value", &PyRamperValue::value)
      .def("__len__", [](const PyRamperValue&) { return 2; })
      .def("__getitem__", [](const PyRamperValue& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        if (i == 1)
          return py::cast(s.value);
        return py::none();
      });
  m.def(
      "create_wiggler_cartesian_map",
      &Bmad::create_wiggler_cartesian_map,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Wiggler or undulator element.
cart_map : CartesianMapStruct
    Cartesian map.
)""");
  m.def(
      "gen_grad1_to_em_taylor",
      &Bmad::gen_grad1_to_em_taylor,
      py::arg("ele"),
      py::arg("gen_grad"),
      py::arg("iz"),
      R"""(No docstring available

Parameters
----------
ele : unknown
    Element containing the map.
gen_grad : GenGradMapStruct
    Gen_grad map.
iz : int
    z-plane index to evaluate.
em_taylor : EmTaylorStruct
    Map for (Bx, By, Bz) or (Ex, Ey, Ez) fields.
)""");
  m.def(
      "track_a_crab_cavity",
      &Bmad::track_a_crab_cavity,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    crab_cavity element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "average_twiss",
      &Bmad::average_twiss,
      py::arg("frac1"),
      py::arg("twiss1"),
      py::arg("twiss2"),
      py::arg("ave_twiss"),
      R"""(No docstring available

Parameters
----------
frac1 : float
    Fraction of twiss1 to use in the average.
twiss1 : TwissStruct
    Twiss parameters to average.
twiss2 : 
ave_twiss : 
)""");
  m.def(
      "mat6_add_offsets",
      &Bmad::mat6_add_offsets,
      py::arg("ele"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with given orientation. .vec0(6)         -- 0th order part of the transfer map. .mat6(6,6)
    -- 1st order part of the transfer map (Jacobian). .map_ref_orb_in  -- Reference orbit at entrance end.
    .map_ref_orb_out -- Reference orbit at exit end. .value(x_offset$), .value(x_pitch$), .value(tilt$), etc.
    -- Offsets, tilts, and pitches
param : LatParamStruct
)""");
  m.def(
      "reallocate_coord",
      py::overload_cast<CoordProxyAlloc1D&, int>(&Bmad::reallocate_coord),
      py::arg("coord"),
      py::arg("n_coord"),
      R"""(Routine to allocate or reallocate at allocatable coord_struct array.

reallocate_coord_n (coord, n_coord)
reallocate_coord_lat (coord, lat, ix_branch)
Subroutine to allocate an allocatable coord_struct array to at least:
coord(0:n_coord)                            if n_coord arg is used.
coord(0:lat%branch(ix_branch)%n_ele_max)    if lat arg is used.
The old coordinates are saved
If, at input, coord(:) is not allocated, coord(0)%vec is set to zero.
In any case, coord(n)%vec for n > 0 is set to zero.

Parameters
----------
coord : CoordStruct
    Allocatable array.
    This parameter is an input/output and is modified in-place. As an output: Allocated array.
n_coord : int
    Minimum array upper bound wanted.
lat : LatStruct
    Lattice
ix_branch : int, optional
    Branch to use. Default is 0 (main branch).

Notes
-----
Overloaded versions:
)""");
  m.def(
      "reallocate_coord",
      py::overload_cast<CoordProxyAlloc1D&, LatProxy&, std::optional<int>>(
          &Bmad::reallocate_coord),
      py::arg("coord"),
      py::arg("lat"),
      py::arg("ix_branch") = py::none(),
      R"""(Routine to allocate or reallocate at allocatable coord_struct array.

reallocate_coord_n (coord, n_coord)
reallocate_coord_lat (coord, lat, ix_branch)
Subroutine to allocate an allocatable coord_struct array to at least:
coord(0:n_coord)                            if n_coord arg is used.
coord(0:lat%branch(ix_branch)%n_ele_max)    if lat arg is used.
The old coordinates are saved
If, at input, coord(:) is not allocated, coord(0)%vec is set to zero.
In any case, coord(n)%vec for n > 0 is set to zero.

Parameters
----------
coord : CoordStruct
    Allocatable array.
    This parameter is an input/output and is modified in-place. As an output: Allocated array.
n_coord : int
    Minimum array upper bound wanted.
lat : LatStruct
    Lattice
ix_branch : int, optional
    Branch to use. Default is 0 (main branch).

Notes
-----
Overloaded versions:
)""");
  m.def(
      "reallocate_coord",
      py::overload_cast<CoordArrayProxyAlloc1D&, LatProxy&>(
          &Bmad::reallocate_coord),
      py::arg("coord_array"),
      py::arg("lat"),
      R"""(Routine to allocate or reallocate at allocatable coord_struct array.

reallocate_coord_n (coord, n_coord)
reallocate_coord_lat (coord, lat, ix_branch)
Subroutine to allocate an allocatable coord_struct array to at least:
coord(0:n_coord)                            if n_coord arg is used.
coord(0:lat%branch(ix_branch)%n_ele_max)    if lat arg is used.
The old coordinates are saved
If, at input, coord(:) is not allocated, coord(0)%vec is set to zero.
In any case, coord(n)%vec for n > 0 is set to zero.

Parameters
----------
coord : CoordStruct
    Allocatable array.
    This parameter is an input/output and is modified in-place. As an output: Allocated array.
n_coord : int
    Minimum array upper bound wanted.
lat : LatStruct
    Lattice
ix_branch : int, optional
    Branch to use. Default is 0 (main branch).

Notes
-----
Overloaded versions:
)""");
  m.def(
      "symp_lie_bmad",
      &Bmad::symp_lie_bmad,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      py::arg("offset_ele") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with transfer matrix
    This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
param : LatParamStruct
    Parameters are needed for some elements.
orbit : CoordStruct
    Coordinates at the beginning of element.
    This parameter is an input/output and is modified in-place. As an output: Coordinates at the end of
    element.
track : TrackStruct
    Structure holding the track information. When tracking through multiple elements, the trajectory in an
    element is appended to the existing trajectory. To reset: Set track.n_pt = -1.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
    through the element.
make_matrix : bool
    If True then make the 6x6 transfer matrix.
offset_ele : bool, optional
    Offset the element using ele.value(x_offset$), etc. Default is True.
)""");
  m.def(
      "normal_mode_dispersion",
      &Bmad::normal_mode_dispersion,
      py::arg("ele"),
      py::arg("reverse") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element whose dispersions are to be adjusted.
    This parameter is an input/output and is modified in-place. As an output: Element with adjusted
    dispersions.
reverse : bool, optional
    Default is False. If True, calculate the x,y dispersions from the normal mode ones.
)""");
  m.def(
      "track_a_match",
      &python_track_a_match,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("err_flag") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Match element.
param : LatParamStruct
    Lattice parameters.
err_flag : 
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  py::class_<PyTrackAMatch, std::unique_ptr<PyTrackAMatch>>(
      m, "TrackAMatch", "Fortran routine track_a_match return value")
      .def_readonly("mat6", &PyTrackAMatch::mat6)
      .def_readonly("err_flag", &PyTrackAMatch::err_flag)
      .def("__len__", [](const PyTrackAMatch&) { return 2; })
      .def("__getitem__", [](const PyTrackAMatch& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.mat6);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "track_a_wiggler",
      &Bmad::track_a_wiggler,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Wiggler element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "diffraction_plate_or_mask_hit_spot",
      &python_diffraction_plate_or_mask_hit_spot,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("ix_section"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    diffraction_plate or mask element.
orbit : CoordStruct
    particle position.
ix_section : 
)""");
  py::class_<
      PyDiffractionPlateOrMaskHitSpot,
      std::unique_ptr<PyDiffractionPlateOrMaskHitSpot>>(
      m,
      "DiffractionPlateOrMaskHitSpot",
      "Fortran routine diffraction_plate_or_mask_hit_spot return value")
      .def_readonly("ix_section", &PyDiffractionPlateOrMaskHitSpot::ix_section)
      .def("__len__", [](const PyDiffractionPlateOrMaskHitSpot&) { return 1; })
      .def(
          "__getitem__",
          [](const PyDiffractionPlateOrMaskHitSpot& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_section);
            return py::none();
          });
  m.def(
      "re_allocate_eles",
      &Bmad::re_allocate_eles,
      py::arg("eles"),
      py::arg("n"),
      py::arg("save_old") = py::none(),
      py::arg("exact") = py::none(),
      R"""(No docstring available

Parameters
----------
eles : ElePointerStruct
    Array of element pointers with possible old data.
    This parameter is an input/output and is modified in-place. As an output: Array of element pointers.
n : int
    Array size to set.
save_old : bool, optional
    If present and True then save the old data.
exact : bool, optional
    If present and True then eles will have size = n If False (default), reallcation will not be done if eles
    is already large enough
)""");
  m.def(
      "init_coord",
      py::overload_cast<
          CoordProxy&,
          FixedArray1D<Real, 6>,
          optional_ref<EleProxy>,
          std::optional<int>,
          std::optional<int>,
          std::optional<int>,
          std::optional<double>,
          std::optional<double>,
          std::optional<bool>,
          std::optional<FixedArray1D<Real, 3>>,
          std::optional<double>,
          std::optional<bool>>(&Bmad::init_coord),
      py::arg("orb"),
      py::arg("vec"),
      py::arg("ele") = py::none(),
      py::arg("element_end") = py::none(),
      py::arg("particle") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("E_photon") = py::none(),
      py::arg("t_offset") = py::none(),
      py::arg("shift_vec6") = py::none(),
      py::arg("spin") = py::none(),
      py::arg("s_pos") = py::none(),
      py::arg("random_on") = py::none(),
      R"""(Routine to initialize a coord_struct.

Subroutine init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
Subroutine init_coord2 (orb, orb_in, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
Subroutine init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)

Parameters
----------
orb_in : CoordStruct
    Input orbit.
vec : float
    Coordinate vector. If not present then taken to be zero.
ele : EleStruct, optional
    Particle is initialized to start at element_end of this ele.
element_end : int, optional
    upstream_end$, downstream_end$, inside$, or start_end$. Must be present if ele argument is present.
    start_end$ -> upstream_end$ if dir = 1 and start_end$ -> downstream_end$ if dir = -1. Default is
    upstream_end$. Note: If ele is the beginning element (index zero), the setting of element_end will not
    matter.
particle : int, optional
    Particle type (electron$, etc.). If particle = not_set$ and orb_in is present, use orb_in.species instead.
direction : int, optional
    +1 -> moving downstream +s direciton, -1 -> moving upstream. 0 -> Ignore. Default is to not change
    orb.direction except for photons which get set according to orb.vec(6).
E_photon : float, optional
    Photon energy if particle is a photon. Ignored otherwise.
t_offset : float, optional
    Offset of the reference time. This is non-zero when there are multiple bunches and the reference time for
    a particular particle is pegged to the time of the center of the bunch.
shift_vec6 : bool, optional
    If present and False, prevent the shift of orb.vec(6).
spin : float, optional
    Particle spin. Taken to be zero if not present.
s_pos : float, optional
    Particle s-position. Only relavent if element_end = inside$.
random_on : bool, optional
    Default is True. Used only for photons being initalized with a photon_init element. If True, vary the
    photon coords using a random number generator. If False, the photon coords will be centered within the
    distribution specified in the photon_init ele.

Returns
-------
orb : coord_struct
    Input orbit

Notes
-----
Overloaded versions:
)""");
  m.def(
      "init_coord",
      py::overload_cast<
          CoordProxy&,
          optional_ref<EleProxy>,
          std::optional<int>,
          std::optional<int>,
          std::optional<int>,
          std::optional<double>,
          std::optional<double>,
          std::optional<bool>,
          std::optional<FixedArray1D<Real, 3>>,
          std::optional<double>,
          std::optional<bool>>(&Bmad::init_coord),
      py::arg("orb_in"),
      py::arg("ele") = py::none(),
      py::arg("element_end") = py::none(),
      py::arg("particle") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("E_photon") = py::none(),
      py::arg("t_offset") = py::none(),
      py::arg("shift_vec6") = py::none(),
      py::arg("spin") = py::none(),
      py::arg("s_pos") = py::none(),
      py::arg("random_on") = py::none(),
      R"""(Routine to initialize a coord_struct.

Subroutine init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
Subroutine init_coord2 (orb, orb_in, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
Subroutine init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)

Parameters
----------
orb_in : coord_struct
    Input orbit
vec : float
    Coordinate vector. If not present then taken to be zero.
ele : EleStruct, optional
    Particle is initialized to start at element_end of this ele.
element_end : int, optional
    upstream_end$, downstream_end$, inside$, or start_end$. Must be present if ele argument is present.
    start_end$ -> upstream_end$ if dir = 1 and start_end$ -> downstream_end$ if dir = -1. Default is
    upstream_end$. Note: If ele is the beginning element (index zero), the setting of element_end will not
    matter.
particle : int, optional
    Particle type (electron$, etc.). If particle = not_set$ and orb_in is present, use orb_in.species instead.
direction : int, optional
    +1 -> moving downstream +s direciton, -1 -> moving upstream. 0 -> Ignore. Default is to not change
    orb.direction except for photons which get set according to orb.vec(6).
E_photon : float, optional
    Photon energy if particle is a photon. Ignored otherwise.
t_offset : float, optional
    Offset of the reference time. This is non-zero when there are multiple bunches and the reference time for
    a particular particle is pegged to the time of the center of the bunch.
shift_vec6 : bool, optional
    If present and False, prevent the shift of orb.vec(6).
spin : float, optional
    Particle spin. Taken to be zero if not present.
s_pos : float, optional
    Particle s-position. Only relavent if element_end = inside$.
random_on : bool, optional
    Default is True. Used only for photons being initalized with a photon_init element. If True, vary the
    photon coords using a random number generator. If False, the photon coords will be centered within the
    distribution specified in the photon_init ele.

Return value is a dictionary containing values below.


Returns
-------
orb : CoordStruct
    Initialized coordinate. Note: For photons, orb.vec(6) is computed as sqrt(1 - vec(2)^2 - vec(4)^2) if
    needed.
orb_out : coord_struct
    Initialized coordinate

Notes
-----
Overloaded versions:
)""");
  m.def(
      "init_coord",
      py::overload_cast<
          CoordProxy&,
          optional_ref<EleProxy>,
          std::optional<int>,
          std::optional<int>,
          std::optional<int>,
          std::optional<double>,
          std::optional<double>,
          std::optional<bool>,
          std::optional<FixedArray1D<Real, 3>>>(&Bmad::init_coord),
      py::arg("orb"),
      py::arg("ele") = py::none(),
      py::arg("element_end") = py::none(),
      py::arg("particle") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("E_photon") = py::none(),
      py::arg("t_offset") = py::none(),
      py::arg("shift_vec6") = py::none(),
      py::arg("spin") = py::none(),
      R"""(Routine to initialize a coord_struct.

Subroutine init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
Subroutine init_coord2 (orb, orb_in, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
Subroutine init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)

Parameters
----------
orb_in : CoordStruct
    Input orbit.
vec : float
    Coordinate vector. If not present then taken to be zero.
ele : EleStruct, optional
    Particle is initialized to start at element_end of this ele.
element_end : int, optional
    upstream_end$, downstream_end$, inside$, or start_end$. Must be present if ele argument is present.
    start_end$ -> upstream_end$ if dir = 1 and start_end$ -> downstream_end$ if dir = -1. Default is
    upstream_end$. Note: If ele is the beginning element (index zero), the setting of element_end will not
    matter.
particle : int, optional
    Particle type (electron$, etc.). If particle = not_set$ and orb_in is present, use orb_in.species instead.
direction : int, optional
    +1 -> moving downstream +s direciton, -1 -> moving upstream. 0 -> Ignore. Default is to not change
    orb.direction except for photons which get set according to orb.vec(6).
E_photon : float, optional
    Photon energy if particle is a photon. Ignored otherwise.
t_offset : float, optional
    Offset of the reference time. This is non-zero when there are multiple bunches and the reference time for
    a particular particle is pegged to the time of the center of the bunch.
shift_vec6 : bool, optional
    If present and False, prevent the shift of orb.vec(6).
spin : float, optional
    Particle spin. Taken to be zero if not present.
s_pos : float, optional
    Particle s-position. Only relavent if element_end = inside$.
random_on : bool, optional
    Default is True. Used only for photons being initalized with a photon_init element. If True, vary the
    photon coords using a random number generator. If False, the photon coords will be centered within the
    distribution specified in the photon_init ele.

Returns
-------
orb : coord_struct
    Input orbit

Notes
-----
Overloaded versions:
)""");
  m.def(
      "mexp",
      &python_mexp,
      py::arg("x"),
      py::arg("m"),
      py::arg("this_exp"),
      R"""(No docstring available

Parameters
----------
x : float
    Number.
m : int
    Exponent.
this_exp : 
)""");
  py::class_<PyMexp, std::unique_ptr<PyMexp>>(
      m, "Mexp", "Fortran routine mexp return value")
      .def_readonly("this_exp", &PyMexp::this_exp)
      .def("__len__", [](const PyMexp&) { return 1; })
      .def("__getitem__", [](const PyMexp& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.this_exp);
        return py::none();
      });
  m.def(
      "multipole1_kt_to_ab",
      &Bmad::multipole1_kt_to_ab,
      py::arg("knl"),
      py::arg("knsl"),
      py::arg("tn"),
      py::arg("n"),
      R"""(No docstring available

Parameters
----------
knl : float
    Normal multitude component.
knsl : float
    Skew multitude component.
tn : float
    Multipole angle.
n : int
    Multipole order.
an : float
    Skew multipole component.
bn : float
    Normal multipole component.
)""");
  py::class_<Bmad::Multipole1KtToAb, std::unique_ptr<Bmad::Multipole1KtToAb>>(
      m, "Multipole1KtToAb", "Fortran routine multipole1_kt_to_ab return value")
      .def_readonly("an", &Bmad::Multipole1KtToAb::an)
      .def_readonly("bn", &Bmad::Multipole1KtToAb::bn)
      .def("__len__", [](const Bmad::Multipole1KtToAb&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::Multipole1KtToAb& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.an);
            if (i == 1)
              return py::cast(s.bn);
            return py::none();
          });
  m.def(
      "ele_has_constant_ds_dt_ref",
      &python_ele_has_constant_ds_dt_ref,
      py::arg("ele"),
      py::arg("is_const"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element.
is_const : 
)""");
  py::class_<PyEleHasConstantDsDtRef, std::unique_ptr<PyEleHasConstantDsDtRef>>(
      m,
      "EleHasConstantDsDtRef",
      "Fortran routine ele_has_constant_ds_dt_ref return value")
      .def_readonly("is_const", &PyEleHasConstantDsDtRef::is_const)
      .def("__len__", [](const PyEleHasConstantDsDtRef&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEleHasConstantDsDtRef& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_const);
            return py::none();
          });
  m.def(
      "transfer_branches",
      &Bmad::transfer_branches,
      py::arg("branch1"),
      R"""(No docstring available

Parameters
----------
branch1 : BranchStruct
branch2 : BranchStruct
)""");
  m.def(
      "track_a_mask",
      &Bmad::track_a_mask,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Mask element.
param : LatParamStruct
    Lattice parameters.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "g_integrals_calc",
      &Bmad::g_integrals_calc,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice to integrate through.
)""");
  m.def(
      "transfer_ele_taylor",
      &Bmad::transfer_ele_taylor,
      py::arg("ele_in"),
      py::arg("taylor_order") = py::none(),
      R"""(No docstring available

Parameters
----------
ele_in : EleStruct
    Element with the Taylor map.
ele_out : EleStruct
    Element receiving the Taylor map truncated to order taylor_order.
taylor_order : int, optional
    Order to truncate the Taylor map at.
)""");
  m.def(
      "mat_symp_decouple",
      &Bmad::mat_symp_decouple,
      py::arg("t0"),
      py::arg("U"),
      py::arg("V"),
      py::arg("Ubar"),
      py::arg("Vbar"),
      py::arg("G"),
      py::arg("type_out"),
      R"""(No docstring available

Parameters
----------
t0 : float
    Input matrix
stat : int
    status of results: ok$, in_stop_band$, or unstable$
U : 
V : 
Ubar : 
Vbar : 
G : 
twiss1 : TwissStruct
    Twiss params for the "upper left" mode. .phi     -- Rotation angle in radians, 0 < .PHI < twopi
twiss2 : TwissStruct
    Twiss params for the "lower right" mode. u(4,4), v(4,4), ubar(4,4), vbar(4,4), g(4,4) -- Real(rp): See MGB
    CBN 85-2 and PPB/DLR PAC89 papers for more info.
gamma : float
    gamma_c factor.
type_out : bool
    If .true. then an error message is typed out for a non ok$ STAT
)""");
  py::class_<Bmad::MatSympDecouple, std::unique_ptr<Bmad::MatSympDecouple>>(
      m, "MatSympDecouple", "Fortran routine mat_symp_decouple return value")
      .def_readonly("stat", &Bmad::MatSympDecouple::stat)
      .def_readonly("twiss1", &Bmad::MatSympDecouple::twiss1)
      .def_readonly("twiss2", &Bmad::MatSympDecouple::twiss2)
      .def_readonly("gamma", &Bmad::MatSympDecouple::gamma)
      .def("__len__", [](const Bmad::MatSympDecouple&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::MatSympDecouple& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.stat);
            if (i == 1)
              return py::cast(s.twiss1);
            if (i == 2)
              return py::cast(s.twiss2);
            if (i == 3)
              return py::cast(s.gamma);
            return py::none();
          });
  m.def(
      "transfer_lat",
      &Bmad::transfer_lat,
      py::arg("lat1"),
      R"""(No docstring available

Parameters
----------
lat1 : LatStruct
lat2 : LatStruct
)""");
  m.def(
      "reallocate_expression_stack",
      &Bmad::reallocate_expression_stack,
      py::arg("stack"),
      py::arg("n"),
      py::arg("exact") = py::none(),
      R"""(No docstring available

Parameters
----------
stack : unknown
    Existing stack array.
    This parameter is an input/output and is modified in-place. As an output: Resized stack.
n : int
    Array size needed.
exact : bool, optional
    If present and False then the size of the output array is permitted to be larger than n. Default is True.
)""");
  m.def(
      "orbit_too_large",
      &python_orbit_too_large,
      py::arg("orbit"),
      py::arg("check_momentum") = py::none(),
      py::arg("is_too_large"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Particle orbit.
param : LatParamStruct
    .unstable_factor  -- Set if orbit is too large. Otherwise not set
check_momentum : bool, optional
    If True (default) check the momentum.
is_too_large : 
)""");
  py::class_<PyOrbitTooLarge, std::unique_ptr<PyOrbitTooLarge>>(
      m, "OrbitTooLarge", "Fortran routine orbit_too_large return value")
      .def_readonly("param", &PyOrbitTooLarge::param)
      .def_readonly("is_too_large", &PyOrbitTooLarge::is_too_large)
      .def("__len__", [](const PyOrbitTooLarge&) { return 2; })
      .def("__getitem__", [](const PyOrbitTooLarge& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.param);
        if (i == 1)
          return py::cast(s.is_too_large);
        return py::none();
      });
  m.def(
      "track_a_patch",
      &Bmad::track_a_patch,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("drift_to_exit") = py::none(),
      py::arg("track_spin") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    patch element.
orbit : CoordStruct
    Starting phase space coords
    This parameter is an input/output and is modified in-place. As an output: Coords after applying a patch
    transformation.
drift_to_exit : bool, optional
    If False then do not drift the particle from beginning to end face. Also do not correct for a reference
    energy shift. Default is True.
s_ent : float
    Longitudinal coordinate of the initial particle position in the frame of reference of the face where the
    particle exits. For a patch with positive z_offset and all other attributes zero, s_ent = -z_offset.
ds_ref : float
    Distance reference particle travels from entrance to exit.
track_spin : bool, optional
    If True rotate the spin vector appropriately. If ele.spin_tracking_method = symp_lie_ptc -> default =
    True. Else default = False.
mat6 : float
    Transfer matrix through the element.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  py::class_<Bmad::TrackAPatch, std::unique_ptr<Bmad::TrackAPatch>>(
      m, "TrackAPatch", "Fortran routine track_a_patch return value")
      .def_readonly("s_ent", &Bmad::TrackAPatch::s_ent)
      .def_readonly("ds_ref", &Bmad::TrackAPatch::ds_ref)
      .def_readonly("mat6", &Bmad::TrackAPatch::mat6)
      .def("__len__", [](const Bmad::TrackAPatch&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::TrackAPatch& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.s_ent);
            if (i == 1)
              return py::cast(s.ds_ref);
            if (i == 2)
              return py::cast(s.mat6);
            return py::none();
          });
  m.def(
      "mat6_add_pitch",
      &Bmad::mat6_add_pitch,
      py::arg("x_pitch_tot"),
      py::arg("y_pitch_tot"),
      py::arg("orientation"),
      py::arg("mat6"),
      R"""(No docstring available

Parameters
----------
x_pitch_tot : float
    Horizontal pitch
y_pitch_tot : float
    Vertical pitch
orientation : int
    Element longitudinal orientation. +1 or -1.
mat6 : float
    1st order part of the transfer map (Jacobian).
    This parameter is an input/output and is modified in-place. As an output: 1st order xfer map with pitches.
)""");
  m.def(
      "ele_is_monitor",
      &Bmad::ele_is_monitor,
      py::arg("ele"),
      py::arg("print_warning") = py::none(),
      R"""(Routine to check that an element is either a detector, instrument, monitor, or marker.

These are the elements where measurement errors can be defined.

Parameters
----------
ele : EleStruct
    Lattice element.
print_warning : bool, optional
    If True print a warning message if the element not a monitor like element. Default is True.

Returns
-------
is_monitor : bool
    Set True if the element is a monitor like element.
)""");
  m.def(
      "to_orbit_reading",
      &Bmad::to_orbit_reading,
      py::arg("orb"),
      py::arg("ele"),
      py::arg("axis"),
      py::arg("add_noise"),
      R"""(Calculate the measured reading on a bpm given the actual orbit and the

BPM's offsets, noise, etc.
This routine will only give a nonzero reading for Bmad markers,
monitors, and instruments.

Parameters
----------
orb : CoordStruct
    Orbit position at BPM.
ele : EleStruct
    Element where the orbit is measured. .value(noise$)         -- relative bpm resolution RMS
    .value(tilt_tot$)      -- angle error in radians rms. .value(x_gain_calib$)  -- Horizontal gain
    correction. .value(y_gain_err$)    -- Horizontal gain error. ... etc ...
axis : int
    x_plane$ or y_plane$
add_noise : bool
    If True add noise to the reading

Return value is a dictionary containing values below.


Returns
-------
reading : float
    BPM reading
err : bool
    Set True if there is no valid reading. For example, if ele.is_on = False.
)""");
  py::class_<Bmad::ToOrbitReading, std::unique_ptr<Bmad::ToOrbitReading>>(
      m, "ToOrbitReading", "Fortran routine to_orbit_reading return value")
      .def_readonly("reading", &Bmad::ToOrbitReading::reading)
      .def_readonly("err", &Bmad::ToOrbitReading::err)
      .def("__len__", [](const Bmad::ToOrbitReading&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ToOrbitReading& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.reading);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "to_eta_reading",
      &Bmad::to_eta_reading,
      py::arg("eta_actual"),
      py::arg("ele"),
      py::arg("axis"),
      py::arg("add_noise"),
      R"""(Compute the measured dispersion reading given the true dispersion and the

monitor offsets, noise, etc.
This routine will only give a nonzero reading for Bmad markers,
monitors, and instruments.

Parameters
----------
eta_actual : float
    Actual (eta_x, eta_y) dispersion.
ele : EleStruct
    Element where the orbit is measured. .value(dE_eta_meas$)   -- Percent energy change used in dispersion
    measurement. .value(noise$)         -- relative bpm resolution RMS .value(tilt_tot$)      -- angle error
    in radians rms. .value(x_gain_calib$)  -- Horizontal gain correction. .value(y_gain_err$)    -- Horizontal
    gain error. ... etc ...
axis : int
    x_plane$ or y_plane$
add_noise : bool
    If True add noise to the reading

Return value is a dictionary containing values below.


Returns
-------
reading : float
    BPM reading
err : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<Bmad::ToEtaReading, std::unique_ptr<Bmad::ToEtaReading>>(
      m, "ToEtaReading", "Fortran routine to_eta_reading return value")
      .def_readonly("reading", &Bmad::ToEtaReading::reading)
      .def_readonly("err", &Bmad::ToEtaReading::err)
      .def("__len__", [](const Bmad::ToEtaReading&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ToEtaReading& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.reading);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "to_phase_and_coupling_reading",
      &Bmad::to_phase_and_coupling_reading,
      py::arg("ele"),
      py::arg("add_noise"),
      R"""(Find the measured coupling values given the actual ones

This routine will only give a nonzero reading for Bmad markers,
monitors, and instruments.

Parameters
----------
actual_phase : float
    Actual phase reading.
ele : EleStruct
    Element where phase is measured. .value(phase_noise$) -- RMS Noise in radians.
add_noise : bool
    If True add noise to the reading

Return value is a dictionary containing values below.


Returns
-------
reading : BpmPhaseCouplingStruct
    K and Cbar coupling parameters
err : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::ToPhaseAndCouplingReading,
      std::unique_ptr<Bmad::ToPhaseAndCouplingReading>>(
      m,
      "ToPhaseAndCouplingReading",
      "Fortran routine to_phase_and_coupling_reading return value")
      .def_readonly("reading", &Bmad::ToPhaseAndCouplingReading::reading)
      .def_readonly("err", &Bmad::ToPhaseAndCouplingReading::err)
      .def("__len__", [](const Bmad::ToPhaseAndCouplingReading&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ToPhaseAndCouplingReading& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.reading);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "odeint_bmad_time",
      &python_odeint_bmad_time,
      py::arg("orb"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("t_dir"),
      py::arg("rf_time"),
      py::arg("track") = py::none(),
      py::arg("t_end") = py::none(),
      py::arg("extra_field") = py::none(),
      R"""(Subroutine to do Runge Kutta tracking in time. This routine is adapted from Numerical

Recipes.  See the NR book for more details.
Tracking is done until the particle is lost or exits the element.

Parameters
----------
orb : CoordStruct
    Starting coords: (x, px, y, py, s, ps) [t-based]
    This parameter is an input/output and is modified in-place. As an output: Ending coords
ele : EleStruct
    Element to track through. .tracking_method -- Determines which subroutine to use to calculate the field.
    Note: BMAD does no supply em_field_custom. == custom$ then use em_field_custom /= custom$ then use
    em_field_standard
param : LatParamStruct
    Beam parameters.
t_dir : float
    Direction of time travel = +/-1. Can be negative for patches. Will be -1 if element has a negative length.
rf_time : float
    Time relative to RF clock.
    This parameter is an input/output and is modified in-place. As an output: Updated time.
track : TrackStruct, optional
    Structure holding the track information. .save_track   -- Logical: Set True if track is to be saved.
t_end : float, optional
    If present, maximum time to which the particle will be tracked. Used for tracking with given time steps.
    The time orb.t at which tracking stops may be less than this if the particle gets to the end of the
    element
extra_field : EmFieldStruct, optional
    Static field to be added to the element field. Eg used with space charge.

Return value is a dictionary containing values below.


Returns
-------
err_flag : bool
    Set True if there is an error. False otherwise.
dt_step : float
    Next RK time step that this tracker would take based on the error tolerance. Used by track_bunch_time.
)""");
  py::class_<PyOdeintBmadTime, std::unique_ptr<PyOdeintBmadTime>>(
      m, "OdeintBmadTime", "Fortran routine odeint_bmad_time return value")
      .def_readonly("err_flag", &PyOdeintBmadTime::err_flag)
      .def_readonly("dt_step", &PyOdeintBmadTime::dt_step)
      .def_readonly("rf_time", &PyOdeintBmadTime::rf_time)
      .def("__len__", [](const PyOdeintBmadTime&) { return 3; })
      .def(
          "__getitem__", [](const PyOdeintBmadTime& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.dt_step);
            if (i == 2)
              return py::cast(s.rf_time);
            return py::none();
          });
  m.def(
      "rk_adaptive_time_step",
      &python_rk_adaptive_time_step,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orb"),
      py::arg("t_dir"),
      py::arg("rf_time"),
      py::arg("dt_try"),
      py::arg("dt_did"),
      py::arg("dt_next"),
      py::arg("err_flag"),
      py::arg("extra_field") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : 
param : 
orb : 
t_dir : 
rf_time : 
dt_try : 
dt_did : 
dt_next : 
err_flag : 
extra_field : 
)""");
  py::class_<PyRkAdaptiveTimeStep, std::unique_ptr<PyRkAdaptiveTimeStep>>(
      m,
      "RkAdaptiveTimeStep",
      "Fortran routine rk_adaptive_time_step return value")
      .def_readonly("t_dir", &PyRkAdaptiveTimeStep::t_dir)
      .def_readonly("rf_time", &PyRkAdaptiveTimeStep::rf_time)
      .def_readonly("dt_try", &PyRkAdaptiveTimeStep::dt_try)
      .def_readonly("dt_did", &PyRkAdaptiveTimeStep::dt_did)
      .def_readonly("dt_next", &PyRkAdaptiveTimeStep::dt_next)
      .def_readonly("err_flag", &PyRkAdaptiveTimeStep::err_flag)
      .def("__len__", [](const PyRkAdaptiveTimeStep&) { return 6; })
      .def(
          "__getitem__",
          [](const PyRkAdaptiveTimeStep& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.t_dir);
            if (i == 1)
              return py::cast(s.rf_time);
            if (i == 2)
              return py::cast(s.dt_try);
            if (i == 3)
              return py::cast(s.dt_did);
            if (i == 4)
              return py::cast(s.dt_next);
            if (i == 5)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "rk_time_step1",
      &python_rk_time_step1,
      py::arg("ele"),
      py::arg("param"),
      py::arg("rf_time"),
      py::arg("orb"),
      py::arg("dt"),
      py::arg("new_orb"),
      py::arg("dr_dt") = py::none(),
      py::arg("err_flag"),
      py::arg("print_err") = py::none(),
      py::arg("extra_field") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : 
param : 
rf_time : 
orb : 
dt : 
new_orb : 
r_err : 
dr_dt : 
err_flag : 
print_err : 
extra_field : 
)""");
  py::class_<PyRkTimeStep1, std::unique_ptr<PyRkTimeStep1>>(
      m, "RkTimeStep1", "Fortran routine rk_time_step1 return value")
      .def_readonly("r_err", &PyRkTimeStep1::r_err)
      .def_readonly("err_flag", &PyRkTimeStep1::err_flag)
      .def_readonly("print_err", &PyRkTimeStep1::print_err)
      .def("__len__", [](const PyRkTimeStep1&) { return 3; })
      .def("__getitem__", [](const PyRkTimeStep1& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.r_err);
        if (i == 1)
          return py::cast(s.err_flag);
        if (i == 2)
          return py::cast(s.print_err);
        return py::none();
      });
  m.def(
      "em_field_kick_vector_time",
      &Bmad::em_field_kick_vector_time,
      py::arg("ele"),
      py::arg("param"),
      py::arg("rf_time"),
      py::arg("orbit"),
      py::arg("err_flag"),
      py::arg("print_err") = py::none(),
      py::arg("extra_field") = py::none(),
      R"""(Subroutine to convert particle coordinates from t-based to s-based system.

Parameters
----------
ele : CoordStruct
    input particle
param : float
    Reference momentum. The sign indicates direction of p_s.
rf_time : float
    RF time.
orbit : CoordStruct
    in t-based system
err_flag : bool
    Set True if there is an error. False otherwise.
print_err : bool, optional
    Passed to em_field_calc
extra_field : EmFieldStruct, optional
    Static field to be added to the element field. Eg used with space charge.

Returns
-------
dvec_dt : float
    Derivatives.
)""");
  m.def(
      "particle_in_global_frame",
      &Bmad::particle_in_global_frame,
      py::arg("orb"),
      py::arg("branch"),
      py::arg("in_time_coordinates") = py::none(),
      py::arg("in_body_frame") = py::none(),
      py::arg("w_mat_out") = py::none(),
      py::arg("particle"),
      R"""(Returns the particle in global time coordinates given is coordinates orb in lattice lat.

Parameters
----------
orb : CoordStruct
    particle in s-coordinates
branch : BranchStruct
    branch that contains branch.ele(orb.ix_ele)
in_time_coordinates : bool
    Default is false. If true, orb will taken as in time coordinates.
in_body_frame : bool
    Default is true. If false, ele offsets will be ignored. Result:
particle : CoordStruct
    particle in global time coordinates

Returns
-------
particle
)""");
  m.def(
      "drift_orbit_time",
      &Bmad::drift_orbit_time,
      py::arg("orbit"),
      py::arg("beta0"),
      py::arg("delta_s") = py::none(),
      py::arg("delta_t") = py::none(),
      R"""(Simple routine to drift a particle orbit in time-based coordinates by a distance delta_s

or a time delta_t
If the particle has zero longitudinal velocity, then the particle is not drifted
and a warning is printed.

Parameters
----------
orbit : CoordStruct
    particle orbit in time-based coordinates.
beta0 : float
    reference velocity v/c.
delta_s : float, optional
    s-coordinate distance to drift particle.
delta_t : float, optional
    -coordinate distancet to drift particle.
)""");
  m.def(
      "write_time_particle_distribution",
      &Bmad::write_time_particle_distribution,
      py::arg("time_file_unit"),
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("style") = py::none(),
      py::arg("branch") = py::none(),
      py::arg("format") = py::none(),
      R"""(Subroutine to write a time-based bunch from a standard Bmad bunch

Parameters
----------
time_file_unit : int
    unit number to write to, if > 0
bunch : BunchStruct
    bunch to be written. Particles are drifted to bmad_bunch.t_center for output
ele : EleStruct
    Element being tracked through.
style : unknown, optional
    Style of output file: 'BMAD' (default), 'OPAL', 'ASTRA', 'GPT'
branch : BranchStruct, optional
    Required for 'ASTRA' style
format : unknown
    format for numerical output. default: 'es15.7'

Returns
-------
err : bool
    Set True if, say a file could not be opened.
)""");
  m.def(
      "track_until_dead",
      &Bmad::track_until_dead,
      py::arg("start_orb"),
      py::arg("lat"),
      R"""(Subroutine to track a particle arbitrarily through a lattice, forwards or backwards,

until it is lost or exits the lattice.
The starting element is located using start_orb%s.

Parameters
----------
start_orb : CoordStruct
    Starting coords.
lat : unknown
    lattice that contains and element at start_orb.s

Return value is a dictionary containing values below.


Returns
-------
end_orb : CoordStruct
    final coords
track : TrackStruct
    (optional)
)""");
  py::class_<Bmad::TrackUntilDead, std::unique_ptr<Bmad::TrackUntilDead>>(
      m, "TrackUntilDead", "Fortran routine track_until_dead return value")
      .def_readonly("end_orb", &Bmad::TrackUntilDead::end_orb)
      .def_readonly("track", &Bmad::TrackUntilDead::track)
      .def("__len__", [](const Bmad::TrackUntilDead&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TrackUntilDead& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_orb);
            if (i == 1)
              return py::cast(s.track);
            return py::none();
          });
  m.def(
      "pointer_to_element_at_s",
      &Bmad::pointer_to_element_at_s,
      py::arg("branch"),
      py::arg("s"),
      py::arg("choose_max"),
      py::arg("print_err") = py::none(),
      R"""(Function to return a pointer to the element at position s.

That is, return ele => branch%ele(ix_ele) such that:
If choose_max = True:
If s = branch%ele(ix_end_of_branch): ix_ele = ix_end_of_branch
Else: branch%ele(ix_ele)%s_strat <= s < branch%ele(ix_ele)%s
If choose_max = False:
If s = branch%ele(0): ix_ele = 0
Else: branch%ele(ix_ele)%s_start < s <= branch%ele(ix_ele)%s
That is, if s corresponds to an element boundary between elements with indexes ix1 and ix2 = ix1 + 1:
choose_max = True  => ix_ele = ix2
choose_max = False => ix_ele = ix1

Parameters
----------
branch : BranchStruct
    Branch to use
s : float
    Longitudinal position.
choose_max : bool
    See above.
print_err : bool, optional
    Print error message if there is an error? Default is True.

Return value is a dictionary containing values below.


Returns
-------
ele : EleStruct
    Pointer to element at s.
err_flag : bool
    Set True if s is out of bounds. False otherwise.
s_eff : float
    Effective s. Equal to s with a open lattice. See above.
position : CoordStruct
    Positional information. .s         -- Same as input s. .ix_ele    -- Same as output ix_ele .location  --
    Location relative to element. Upstream_end$, downstream_end$, or inside$

Notes
-----
Related routines:
element_at_s The setting of choose_max only makes a difference when s corresponds to an element boundary. For
a circular lattice s is evaluated at the effective s which s_eff = s - branch_length * floor(s/branch_length)
If there are multiple elements that are at the given s position due to the presence of an element with a
negative length which of the possible elements is actually chosen is ill-defined.
)""");
  py::class_<
      Bmad::PointerToElementAtS,
      std::unique_ptr<Bmad::PointerToElementAtS>>(
      m,
      "PointerToElementAtS",
      "Fortran routine pointer_to_element_at_s return value")
      .def_readonly("err_flag", &Bmad::PointerToElementAtS::err_flag)
      .def_readonly("s_eff", &Bmad::PointerToElementAtS::s_eff)
      .def_readonly("position", &Bmad::PointerToElementAtS::position)
      .def_readonly("ele", &Bmad::PointerToElementAtS::ele)
      .def("__len__", [](const Bmad::PointerToElementAtS&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::PointerToElementAtS& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.s_eff);
            if (i == 2)
              return py::cast(s.position);
            if (i == 3)
              return py::cast(s.ele);
            return py::none();
          });
  m.def(
      "g_bend_from_em_field",
      &Bmad::g_bend_from_em_field,
      py::arg("b"),
      py::arg("e"),
      py::arg("orbit"),
      R"""(Routine to calculate the bending strength (1/bending_radius) for a given particle for a given field.

This will include the dipole bending field of an sbend.

Parameters
----------
B : float
    Magnetic field.
E : float
    Electric field
orbit : CoordStruct
    particle orbit

Returns
-------
g_bend : float
    bending strength vector.
)""");
  m.def(
      "to_fieldmap_coords",
      &python_to_fieldmap_coords,
      py::arg("ele"),
      py::arg("local_orb"),
      py::arg("s_body"),
      py::arg("ele_anchor_pt"),
      py::arg("r0"),
      py::arg("curved_ref_frame"),
      py::arg("x"),
      py::arg("y"),
      py::arg("z"),
      py::arg("cos_ang"),
      py::arg("sin_ang"),
      py::arg("err_flag"),
      R"""(x, y, z, cos_ang, sin_ang, err_flag)

Routine to return the (x,y,s) position relative to a field map.

Parameters
----------
ele : EleStruct
    Element being tracked through.
local_orb : CoordStruct
    Particle orbit. Must be in local element coordinates.
s_body : float
    Longitudinal position relative to the entrance end of the element.
ele_anchor_pt : int
    anchor point of the field map (anchor_beginning$, anchor_center$, or anchor_end$).
r0 : float
    origin point of the fieldmap.
curved_ref_frame : bool
    If the element is a bend: Does the field map follow the bend reference coords? Outpt: x, y, z           --
    real(rp): Coords relative to the field map. cos_ang, sin_ang  -- real(rp): cos and sin of coordinate
    rotation angle.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<PyToFieldmapCoords, std::unique_ptr<PyToFieldmapCoords>>(
      m, "ToFieldmapCoords", "Fortran routine to_fieldmap_coords return value")
      .def_readonly("x", &PyToFieldmapCoords::x)
      .def_readonly("y", &PyToFieldmapCoords::y)
      .def_readonly("z", &PyToFieldmapCoords::z)
      .def_readonly("cos_ang", &PyToFieldmapCoords::cos_ang)
      .def_readonly("sin_ang", &PyToFieldmapCoords::sin_ang)
      .def("__len__", [](const PyToFieldmapCoords&) { return 5; })
      .def(
          "__getitem__",
          [](const PyToFieldmapCoords& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.x);
            if (i == 1)
              return py::cast(s.y);
            if (i == 2)
              return py::cast(s.z);
            if (i == 3)
              return py::cast(s.cos_ang);
            if (i == 4)
              return py::cast(s.sin_ang);
            return py::none();
          });
  m.def(
      "rotate_em_field",
      &Bmad::rotate_em_field,
      py::arg("field"),
      py::arg("w_mat"),
      py::arg("w_inv"),
      py::arg("calc_dfield") = py::none(),
      py::arg("calc_potential") = py::none(),
      R"""(Routine to transform the fields using the given rotation matrices.

Parameters
----------
field : EmFieldStruct
    E and B fields and derivatives.
w_mat : float
    rotation matrix.
w_inv : float
    rotation matrix inverse = transpose(w_mat)
calc_dfield : bool, optional
    If present and True then rotate the field derivatives.
calc_potential : bool, optional
    Rotate the magnetic vector potential? Default is false.
)""");
  m.def(
      "grid_field_interpolate",
      &Bmad::grid_field_interpolate,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("grid"),
      py::arg("err_flag"),
      py::arg("x1"),
      py::arg("x2") = py::none(),
      py::arg("x3") = py::none(),
      py::arg("allow_s_out_of_bounds") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(allow_s_out_of_bounds, print_err)

Subroutine to interpolate the E and B fields on a rectilinear grid.

Parameters
----------
ele : EleStruct
    Element containing the grid.
orbit : CoordStruct
    Used for constructing an error message if the particle is out of bounds.
grid : GridFieldStruct
    Grid to interpolate.
err_flag : bool
    Set to true if there is an error. False otherwise.
x1 : float
    dimension 1 interpolation point.
x2 : float, optional
    dimension 2 interpolation point.
x3 : float, optional
    dimension 3 interpolation point.
allow_s_out_of_bounds : bool, optional
    allow s-coordinate grossly out of bounds to return zero field without an error. This is used when the
    field of one element overlaps the field of another. Default is False.
print_err : bool, optional
    print an error message if the particle is out of bounds? Default is True.

Returns
-------
field : GridFieldPtStruct
    Interpolated field (complex)
)""");
  m.def(
      "em_field_derivatives",
      &python_em_field_derivatives,
      py::arg("ele"),
      py::arg("param"),
      py::arg("s_pos"),
      py::arg("orbit"),
      py::arg("local_ref_frame"),
      py::arg("grid_allow_s_out_of_bounds") = py::none(),
      py::arg("rf_time") = py::none(),
      R"""(Routine to calculate field derivatives.

In theory this should be handled by em_filed_calc. In practice, em_field_calc is currently incomplete.
Input
ele             -- Ele_struct: Element
param           -- lat_param_struct: Lattice parameters.
s_pos           -- Real(rp): Longitudinal position relative to the upstream edge of the element.
time            -- Real(rp): Particle time.
For absolute time tracking this is the absolute time.
For relative time tracking this is relative to the reference particle entering the element.
orbit           -- Coord_struct: Transverse coordinates.
%vec(1), %vec(3)  -- Transverse coords. These are the only components used in the calculation.
local_ref_frame     -- Logical, If True then take the input coordinates and output fields
as being with respect to the frame of referene of the element (ignore misalignments).
grid_allow_s_out_of_bounds
-- logical, optional: For grids, allow s-coordinate to be grossly out of bounds
and return zero instead of an error? Default: False. Used internally for overlapping fields.
rf_time          -- real(rp), optional: RF clock time. If not present then the time will be calculated using the standard algorithm.


Returns
-------
dfield : EmFieldStruct
    E and B field derivatives. dfield.E and dfield.B are not touched.
)""");
  py::class_<PyEmFieldDerivatives, std::unique_ptr<PyEmFieldDerivatives>>(
      m,
      "EmFieldDerivatives",
      "Fortran routine em_field_derivatives return value")
      .def_readonly("dfield", &PyEmFieldDerivatives::dfield)
      .def_readonly("s_pos", &PyEmFieldDerivatives::s_pos)
      .def_readonly("local_ref_frame", &PyEmFieldDerivatives::local_ref_frame)
      .def_readonly(
          "grid_allow_s_out_of_bounds",
          &PyEmFieldDerivatives::grid_allow_s_out_of_bounds)
      .def_readonly("rf_time", &PyEmFieldDerivatives::rf_time)
      .def("__len__", [](const PyEmFieldDerivatives&) { return 5; })
      .def(
          "__getitem__",
          [](const PyEmFieldDerivatives& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dfield);
            if (i == 1)
              return py::cast(s.s_pos);
            if (i == 2)
              return py::cast(s.local_ref_frame);
            if (i == 3)
              return py::cast(s.grid_allow_s_out_of_bounds);
            if (i == 4)
              return py::cast(s.rf_time);
            return py::none();
          });
  m.def(
      "gen_grad_field",
      &python_gen_grad_field,
      py::arg("deriv"),
      py::arg("gg"),
      py::arg("rho"),
      py::arg("theta"),
      py::arg("field"),
      R"""(No docstring available

Parameters
----------
deriv : 
gg : 
rho : 
theta : 
field : 
)""");
  py::class_<PyGenGradField, std::unique_ptr<PyGenGradField>>(
      m, "GenGradField", "Fortran routine gen_grad_field return value")
      .def_readonly("rho", &PyGenGradField::rho)
      .def_readonly("theta", &PyGenGradField::theta)
      .def("__len__", [](const PyGenGradField&) { return 2; })
      .def("__getitem__", [](const PyGenGradField& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.rho);
        if (i == 1)
          return py::cast(s.theta);
        return py::none();
      });
  m.def(
      "convert_field_ele_to_lab",
      &Bmad::convert_field_ele_to_lab,
      py::arg("ele"),
      py::arg("s_here"),
      py::arg("forward_transform"),
      py::arg("calc_dfield") = py::none(),
      py::arg("calc_potential") = py::none(),
      R"""(Convert fields: ele to lab coords

Parameters
----------
ele : EleStruct
    Lattice element.
s_here : 
    real(rp) S-position.
forward_transform : 
    Transform foward (to lab) or reverse.
calc_dfield : bool, optional
    If present and True then calculate the field derivatives.
calc_potential : bool, optional
    Calc electric and magnetic potentials? Default is false. This is experimental and only implemented for
    wigglers at present.

Returns
-------
field : EmFieldStruct
    EM field.
)""");
  m.def(
      "dynamic_aperture_scan",
      &Bmad::dynamic_aperture_scan,
      py::arg("aperture_param"),
      py::arg("pz_start"),
      py::arg("lat"),
      py::arg("print_timing") = py::none(),
      R"""(Routine to do a set of dynamic aperture scans.

Parameters
----------
aperture_param : ApertureParamStruct
    Scan parameters
lat : LatStruct
    Lattice.
pz_start : float
    Starting phase space pz values.
print_timing : bool, optional
    If True print info on calculation time. Default is True.

Returns
-------
aperture_scan : ApertureScanStruct
    Set of scans. One for each pz_start(:).
)""");
  m.def(
      "dynamic_aperture_point",
      &Bmad::dynamic_aperture_point,
      py::arg("branch"),
      py::arg("ele0"),
      py::arg("orb0"),
      py::arg("theta_xy"),
      py::arg("ap_param"),
      py::arg("check_xy_init") = py::none(),
      R"""(Subroutine to determine one dynamic aperture point by tracking.

This routine works by determining where on a radial line y = const * x the aperture is.
Here x and y are deviations from the reference orbit.

Parameters
----------
branch : BranchStruct
    Lattice branch to track through.
ele0 : EleStruct
    Lattice element at start of tracking
orb0 : CoordStruct
    reference orbit at the start of tracking.
theta_xy : float
    Angle of radial line (in radians) in x-y space. Angle is "normalized" by .x_init, .y_init.
ap_param : ApertureParamStruct
    Structure holding the input data:
check_xy_init : bool, optional
    If True, do not check that aperture_param.x_init and .y_init are non-zero. Default is True.

Returns
-------
ap_point : AperturePointStruct
)""");
  m.def(
      "makeup_group_lord",
      &python_makeup_group_lord,
      py::arg("lat"),
      py::arg("lord"),
      py::arg("err_flag"),
      R"""(Subroutine to calculate the attributes of group slave elements.

This routine is private to bookkeeper_mod.

)""");
  py::class_<PyMakeupGroupLord, std::unique_ptr<PyMakeupGroupLord>>(
      m, "MakeupGroupLord", "Fortran routine makeup_group_lord return value")
      .def_readonly("err_flag", &PyMakeupGroupLord::err_flag)
      .def("__len__", [](const PyMakeupGroupLord&) { return 1; })
      .def(
          "__getitem__",
          [](const PyMakeupGroupLord& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "makeup_multipass_slave",
      &python_makeup_multipass_slave,
      py::arg("lat"),
      py::arg("slave"),
      py::arg("err_flag"),
      R"""(Subroutine to calcualte the attributes of multipass slave elements.

This routine is not meant for guse.

)""");
  py::class_<PyMakeupMultipassSlave, std::unique_ptr<PyMakeupMultipassSlave>>(
      m,
      "MakeupMultipassSlave",
      "Fortran routine makeup_multipass_slave return value")
      .def_readonly("err_flag", &PyMakeupMultipassSlave::err_flag)
      .def("__len__", [](const PyMakeupMultipassSlave&) { return 1; })
      .def(
          "__getitem__",
          [](const PyMakeupMultipassSlave& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "makeup_super_slave",
      &python_makeup_super_slave,
      py::arg("lat"),
      py::arg("slave"),
      py::arg("err_flag"),
      R"""(Subroutine to calcualte the attributes of superposition slave elements.

This routine is not meant for general use.

)""");
  py::class_<PyMakeupSuperSlave, std::unique_ptr<PyMakeupSuperSlave>>(
      m, "MakeupSuperSlave", "Fortran routine makeup_super_slave return value")
      .def_readonly("err_flag", &PyMakeupSuperSlave::err_flag)
      .def("__len__", [](const PyMakeupSuperSlave&) { return 1; })
      .def(
          "__getitem__",
          [](const PyMakeupSuperSlave& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "makeup_super_slave1",
      &Bmad::makeup_super_slave1,
      py::arg("slave"),
      py::arg("lord"),
      py::arg("offset"),
      py::arg("param"),
      py::arg("include_upstream_end"),
      py::arg("include_downstream_end"),
      R"""(Routine to construct a super_slave from a super_lord when the slave has only one lord.

Parameters
----------
slave : EleStruct
    Slave element.
    This parameter is an input/output and is modified in-place. As an output: Slave element with appropriate
    values set.
lord : EleStruct
    Lord element.
offset : float
    offset of entrance end of slave from entrance end of the lord.
param : LatParamStruct
    lattice paramters.
include_upstream_end : bool
    Slave contains the lord's entrance end?
include_downstream_end : bool
    Slave contains the lord's exit end?

Returns
-------
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "compute_slave_coupler",
      &Bmad::compute_slave_coupler,
      py::arg("slave"),
      R"""(This routine is not meant for general use.

)""");
  m.def(
      "makeup_control_slave",
      &python_makeup_control_slave,
      py::arg("lat"),
      py::arg("slave"),
      py::arg("err_flag"),
      R"""(This routine is not meant for general use.

)""");
  py::class_<PyMakeupControlSlave, std::unique_ptr<PyMakeupControlSlave>>(
      m,
      "MakeupControlSlave",
      "Fortran routine makeup_control_slave return value")
      .def_readonly("err_flag", &PyMakeupControlSlave::err_flag)
      .def("__len__", [](const PyMakeupControlSlave&) { return 1; })
      .def(
          "__getitem__",
          [](const PyMakeupControlSlave& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "aperture_bookkeeper",
      &Bmad::aperture_bookkeeper,
      py::arg("ele"),
      R"""(Routine to calculate aperture limits when ele%attribute_type is set to auto_aperture$

Parameters
----------
ele : EleStruct
    Element with aperture.
    This parameter is an input/output and is modified in-place. As an output: Element with apertures set.
)""");
  m.def(
      "attributes_need_bookkeeping",
      &Bmad::attributes_need_bookkeeping,
      py::arg("ele"),
      R"""(Routine, when bmad_com%auto_bookkeeper = True, to decide if attribute

bookkeeping needs to be done for an element.

Parameters
----------
ele : EleStruct
    Element under consideration.

Return value is a dictionary containing values below.


Returns
-------
dval : float
    Array of differences between old and new ele.value(:) values.
ele%bookkeeping_state%attributes : !
    Set ok$ if not needed, stale$ otherwise -- Set ok$ if not needed, stale$ otherwise
)""");
  m.def(
      "transfer_map_from_s_to_s",
      &Bmad::transfer_map_from_s_to_s,
      py::arg("lat"),
      py::arg("t_map"),
      py::arg("s1") = py::none(),
      py::arg("s2") = py::none(),
      py::arg("ref_orb_in") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("one_turn") = py::none(),
      py::arg("unit_start") = py::none(),
      py::arg("concat_if_possible") = py::none(),
      py::arg("spin_map") = py::none(),
      R"""(one_turn, unit_start, err_flag, concat_if_possible, spin_map)

Subroutine to calculate the transfer map between longitudinal positions s1 to s2.
If s2 < s1 and lat%param%geometry is closed$ then the
calculation will 'wrap around' the lattice end.
For example, if s1 = 900 and s2 = 10 then the t_map is the map from
element 900 to the lattice end plus from 0 through 10.
If s2 < s1 and lat%param%geometry is open$ then the inverse of the forward map of s2 -> s1 is computed.
If s2 = s1 then you get the unit map except if one_turn = True and the lattice is circular.

Parameters
----------
lat : LatStruct
    Lattice used in the calculation.
t_map : TaylorStruct
    Initial map (used when unit_start = False)
    This parameter is an input/output and is modified in-place. As an output: Transfer map.
s1 : float, optional
    Element start position for the calculation. Default is 0.
s2 : float, optional
    Element end position for the calculation. Default is lat.param.total_length.
ref_orb_in : CoordStruct, optional
    Reference orbit/particle at s1 around which the map is made. This arg is needed if: unit_start = True or
    particle is not the same as the reference particle of the lattice.
ix_branch : int, optional
    Lattice branch index. Default is 0 (main branch).
one_turn : bool, optional
    If present and True, and s1 = s2, and the lattice is circular: Construct the one-turn map from s1 back to
    s1. Otherwise t_map is unchanged or the unit map if unit_start = T. Default = False.
unit_start : bool, optional
    If present and False then t_map will be used as the starting map instead of the unit map. Default = True
concat_if_possible : bool, optional
    If present and True then use map concatenation rather than tracking -- logical, optional: If present and
    True then use map concatenation rather than tracking if a map is present for a given lattice element. See
    above. Default is False.
spin_map : TaylorStruct, optional
    Initial spin map.
    This parameter is an input/output and is modified in-place. As an output: Final spin map. Only computed if
    bmad_com.spin_tracking_on = T.

Return value is a dictionary containing values below.


Returns
-------
ref_orb_out : CoordStruct
    Ending coordinates of the reference orbit. This is also the actual orbit of particle
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::TransferMapFromSToS,
      std::unique_ptr<Bmad::TransferMapFromSToS>>(
      m,
      "TransferMapFromSToS",
      "Fortran routine transfer_map_from_s_to_s return value")
      .def_readonly("ref_orb_out", &Bmad::TransferMapFromSToS::ref_orb_out)
      .def_readonly("err_flag", &Bmad::TransferMapFromSToS::err_flag)
      .def("__len__", [](const Bmad::TransferMapFromSToS&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TransferMapFromSToS& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ref_orb_out);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "concat_transfer_mat",
      &Bmad::concat_transfer_mat,
      py::arg("mat_1"),
      py::arg("vec_1"),
      py::arg("mat_0"),
      py::arg("vec_0"),
      py::arg("vec_out"),
      R"""(Routine to concatinate two linear maps:

mat_out = matmul(mat_1, mat_0)
vec_out = matmul(mat_1, vec_0) + vec_1

Parameters
----------
mat_1 : float
    Map from s1 to s2
mat_0 : float
    Map from s0 to s1

Returns
-------
mat_out : float
    Map from s0 to s2
)""");
  m.def(
      "eq_spline",
      &python_eq_spline,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSpline, std::unique_ptr<PyEqSpline>>(
      m, "EqSpline", "Fortran routine eq_spline return value")
      .def_readonly("is_eq", &PyEqSpline::is_eq)
      .def("__len__", [](const PyEqSpline&) { return 1; })
      .def("__getitem__", [](const PyEqSpline& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_spin_polar",
      &python_eq_spin_polar,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSpinPolar, std::unique_ptr<PyEqSpinPolar>>(
      m, "EqSpinPolar", "Fortran routine eq_spin_polar return value")
      .def_readonly("is_eq", &PyEqSpinPolar::is_eq)
      .def("__len__", [](const PyEqSpinPolar&) { return 1; })
      .def("__getitem__", [](const PyEqSpinPolar& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_ac_kicker_time",
      &python_eq_ac_kicker_time,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqAcKickerTime, std::unique_ptr<PyEqAcKickerTime>>(
      m, "EqAcKickerTime", "Fortran routine eq_ac_kicker_time return value")
      .def_readonly("is_eq", &PyEqAcKickerTime::is_eq)
      .def("__len__", [](const PyEqAcKickerTime&) { return 1; })
      .def(
          "__getitem__", [](const PyEqAcKickerTime& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_ac_kicker_freq",
      &python_eq_ac_kicker_freq,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqAcKickerFreq, std::unique_ptr<PyEqAcKickerFreq>>(
      m, "EqAcKickerFreq", "Fortran routine eq_ac_kicker_freq return value")
      .def_readonly("is_eq", &PyEqAcKickerFreq::is_eq)
      .def("__len__", [](const PyEqAcKickerFreq&) { return 1; })
      .def(
          "__getitem__", [](const PyEqAcKickerFreq& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_ac_kicker",
      &python_eq_ac_kicker,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqAcKicker, std::unique_ptr<PyEqAcKicker>>(
      m, "EqAcKicker", "Fortran routine eq_ac_kicker return value")
      .def_readonly("is_eq", &PyEqAcKicker::is_eq)
      .def("__len__", [](const PyEqAcKicker&) { return 1; })
      .def("__getitem__", [](const PyEqAcKicker& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_interval1_coef",
      &python_eq_interval1_coef,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqInterval1Coef, std::unique_ptr<PyEqInterval1Coef>>(
      m, "EqInterval1Coef", "Fortran routine eq_interval1_coef return value")
      .def_readonly("is_eq", &PyEqInterval1Coef::is_eq)
      .def("__len__", [](const PyEqInterval1Coef&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqInterval1Coef& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_photon_reflect_table",
      &python_eq_photon_reflect_table,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPhotonReflectTable, std::unique_ptr<PyEqPhotonReflectTable>>(
      m,
      "EqPhotonReflectTable",
      "Fortran routine eq_photon_reflect_table return value")
      .def_readonly("is_eq", &PyEqPhotonReflectTable::is_eq)
      .def("__len__", [](const PyEqPhotonReflectTable&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqPhotonReflectTable& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_photon_reflect_surface",
      &python_eq_photon_reflect_surface,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<
      PyEqPhotonReflectSurface,
      std::unique_ptr<PyEqPhotonReflectSurface>>(
      m,
      "EqPhotonReflectSurface",
      "Fortran routine eq_photon_reflect_surface return value")
      .def_readonly("is_eq", &PyEqPhotonReflectSurface::is_eq)
      .def("__len__", [](const PyEqPhotonReflectSurface&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqPhotonReflectSurface& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_coord",
      &python_eq_coord,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCoord, std::unique_ptr<PyEqCoord>>(
      m, "EqCoord", "Fortran routine eq_coord return value")
      .def_readonly("is_eq", &PyEqCoord::is_eq)
      .def("__len__", [](const PyEqCoord&) { return 1; })
      .def("__getitem__", [](const PyEqCoord& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_coord_array",
      &python_eq_coord_array,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCoordArray, std::unique_ptr<PyEqCoordArray>>(
      m, "EqCoordArray", "Fortran routine eq_coord_array return value")
      .def_readonly("is_eq", &PyEqCoordArray::is_eq)
      .def("__len__", [](const PyEqCoordArray&) { return 1; })
      .def("__getitem__", [](const PyEqCoordArray& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_bpm_phase_coupling",
      &python_eq_bpm_phase_coupling,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBpmPhaseCoupling, std::unique_ptr<PyEqBpmPhaseCoupling>>(
      m,
      "EqBpmPhaseCoupling",
      "Fortran routine eq_bpm_phase_coupling return value")
      .def_readonly("is_eq", &PyEqBpmPhaseCoupling::is_eq)
      .def("__len__", [](const PyEqBpmPhaseCoupling&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqBpmPhaseCoupling& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_expression_atom",
      &python_eq_expression_atom,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqExpressionAtom, std::unique_ptr<PyEqExpressionAtom>>(
      m, "EqExpressionAtom", "Fortran routine eq_expression_atom return value")
      .def_readonly("is_eq", &PyEqExpressionAtom::is_eq)
      .def("__len__", [](const PyEqExpressionAtom&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqExpressionAtom& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_wake_sr_z_long",
      &python_eq_wake_sr_z_long,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWakeSrZLong, std::unique_ptr<PyEqWakeSrZLong>>(
      m, "EqWakeSrZLong", "Fortran routine eq_wake_sr_z_long return value")
      .def_readonly("is_eq", &PyEqWakeSrZLong::is_eq)
      .def("__len__", [](const PyEqWakeSrZLong&) { return 1; })
      .def("__getitem__", [](const PyEqWakeSrZLong& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_wake_sr_mode",
      &python_eq_wake_sr_mode,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWakeSrMode, std::unique_ptr<PyEqWakeSrMode>>(
      m, "EqWakeSrMode", "Fortran routine eq_wake_sr_mode return value")
      .def_readonly("is_eq", &PyEqWakeSrMode::is_eq)
      .def("__len__", [](const PyEqWakeSrMode&) { return 1; })
      .def("__getitem__", [](const PyEqWakeSrMode& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_wake_sr",
      &python_eq_wake_sr,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWakeSr, std::unique_ptr<PyEqWakeSr>>(
      m, "EqWakeSr", "Fortran routine eq_wake_sr return value")
      .def_readonly("is_eq", &PyEqWakeSr::is_eq)
      .def("__len__", [](const PyEqWakeSr&) { return 1; })
      .def("__getitem__", [](const PyEqWakeSr& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_wake_lr_mode",
      &python_eq_wake_lr_mode,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWakeLrMode, std::unique_ptr<PyEqWakeLrMode>>(
      m, "EqWakeLrMode", "Fortran routine eq_wake_lr_mode return value")
      .def_readonly("is_eq", &PyEqWakeLrMode::is_eq)
      .def("__len__", [](const PyEqWakeLrMode&) { return 1; })
      .def("__getitem__", [](const PyEqWakeLrMode& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_wake_lr",
      &python_eq_wake_lr,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWakeLr, std::unique_ptr<PyEqWakeLr>>(
      m, "EqWakeLr", "Fortran routine eq_wake_lr return value")
      .def_readonly("is_eq", &PyEqWakeLr::is_eq)
      .def("__len__", [](const PyEqWakeLr&) { return 1; })
      .def("__getitem__", [](const PyEqWakeLr& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_lat_ele_loc",
      &python_eq_lat_ele_loc,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqLatEleLoc, std::unique_ptr<PyEqLatEleLoc>>(
      m, "EqLatEleLoc", "Fortran routine eq_lat_ele_loc return value")
      .def_readonly("is_eq", &PyEqLatEleLoc::is_eq)
      .def("__len__", [](const PyEqLatEleLoc&) { return 1; })
      .def("__getitem__", [](const PyEqLatEleLoc& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_wake",
      &python_eq_wake,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWake, std::unique_ptr<PyEqWake>>(
      m, "EqWake", "Fortran routine eq_wake return value")
      .def_readonly("is_eq", &PyEqWake::is_eq)
      .def("__len__", [](const PyEqWake&) { return 1; })
      .def("__getitem__", [](const PyEqWake& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_taylor_term",
      &python_eq_taylor_term,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqTaylorTerm, std::unique_ptr<PyEqTaylorTerm>>(
      m, "EqTaylorTerm", "Fortran routine eq_taylor_term return value")
      .def_readonly("is_eq", &PyEqTaylorTerm::is_eq)
      .def("__len__", [](const PyEqTaylorTerm&) { return 1; })
      .def("__getitem__", [](const PyEqTaylorTerm& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_taylor",
      &python_eq_taylor,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqTaylor, std::unique_ptr<PyEqTaylor>>(
      m, "EqTaylor", "Fortran routine eq_taylor return value")
      .def_readonly("is_eq", &PyEqTaylor::is_eq)
      .def("__len__", [](const PyEqTaylor&) { return 1; })
      .def("__getitem__", [](const PyEqTaylor& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_em_taylor_term",
      &python_eq_em_taylor_term,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqEmTaylorTerm, std::unique_ptr<PyEqEmTaylorTerm>>(
      m, "EqEmTaylorTerm", "Fortran routine eq_em_taylor_term return value")
      .def_readonly("is_eq", &PyEqEmTaylorTerm::is_eq)
      .def("__len__", [](const PyEqEmTaylorTerm&) { return 1; })
      .def(
          "__getitem__", [](const PyEqEmTaylorTerm& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_em_taylor",
      &python_eq_em_taylor,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqEmTaylor, std::unique_ptr<PyEqEmTaylor>>(
      m, "EqEmTaylor", "Fortran routine eq_em_taylor return value")
      .def_readonly("is_eq", &PyEqEmTaylor::is_eq)
      .def("__len__", [](const PyEqEmTaylor&) { return 1; })
      .def("__getitem__", [](const PyEqEmTaylor& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_cartesian_map_term1",
      &python_eq_cartesian_map_term1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCartesianMapTerm1, std::unique_ptr<PyEqCartesianMapTerm1>>(
      m,
      "EqCartesianMapTerm1",
      "Fortran routine eq_cartesian_map_term1 return value")
      .def_readonly("is_eq", &PyEqCartesianMapTerm1::is_eq)
      .def("__len__", [](const PyEqCartesianMapTerm1&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqCartesianMapTerm1& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_cartesian_map_term",
      &python_eq_cartesian_map_term,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCartesianMapTerm, std::unique_ptr<PyEqCartesianMapTerm>>(
      m,
      "EqCartesianMapTerm",
      "Fortran routine eq_cartesian_map_term return value")
      .def_readonly("is_eq", &PyEqCartesianMapTerm::is_eq)
      .def("__len__", [](const PyEqCartesianMapTerm&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqCartesianMapTerm& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_cartesian_map",
      &python_eq_cartesian_map,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCartesianMap, std::unique_ptr<PyEqCartesianMap>>(
      m, "EqCartesianMap", "Fortran routine eq_cartesian_map return value")
      .def_readonly("is_eq", &PyEqCartesianMap::is_eq)
      .def("__len__", [](const PyEqCartesianMap&) { return 1; })
      .def(
          "__getitem__", [](const PyEqCartesianMap& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_cylindrical_map_term1",
      &python_eq_cylindrical_map_term1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCylindricalMapTerm1, std::unique_ptr<PyEqCylindricalMapTerm1>>(
      m,
      "EqCylindricalMapTerm1",
      "Fortran routine eq_cylindrical_map_term1 return value")
      .def_readonly("is_eq", &PyEqCylindricalMapTerm1::is_eq)
      .def("__len__", [](const PyEqCylindricalMapTerm1&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqCylindricalMapTerm1& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_cylindrical_map_term",
      &python_eq_cylindrical_map_term,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCylindricalMapTerm, std::unique_ptr<PyEqCylindricalMapTerm>>(
      m,
      "EqCylindricalMapTerm",
      "Fortran routine eq_cylindrical_map_term return value")
      .def_readonly("is_eq", &PyEqCylindricalMapTerm::is_eq)
      .def("__len__", [](const PyEqCylindricalMapTerm&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqCylindricalMapTerm& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_cylindrical_map",
      &python_eq_cylindrical_map,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqCylindricalMap, std::unique_ptr<PyEqCylindricalMap>>(
      m, "EqCylindricalMap", "Fortran routine eq_cylindrical_map return value")
      .def_readonly("is_eq", &PyEqCylindricalMap::is_eq)
      .def("__len__", [](const PyEqCylindricalMap&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqCylindricalMap& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_grid_field_pt1",
      &python_eq_grid_field_pt1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqGridFieldPt1, std::unique_ptr<PyEqGridFieldPt1>>(
      m, "EqGridFieldPt1", "Fortran routine eq_grid_field_pt1 return value")
      .def_readonly("is_eq", &PyEqGridFieldPt1::is_eq)
      .def("__len__", [](const PyEqGridFieldPt1&) { return 1; })
      .def(
          "__getitem__", [](const PyEqGridFieldPt1& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_grid_field_pt",
      &python_eq_grid_field_pt,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqGridFieldPt, std::unique_ptr<PyEqGridFieldPt>>(
      m, "EqGridFieldPt", "Fortran routine eq_grid_field_pt return value")
      .def_readonly("is_eq", &PyEqGridFieldPt::is_eq)
      .def("__len__", [](const PyEqGridFieldPt&) { return 1; })
      .def("__getitem__", [](const PyEqGridFieldPt& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_grid_field",
      &python_eq_grid_field,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqGridField, std::unique_ptr<PyEqGridField>>(
      m, "EqGridField", "Fortran routine eq_grid_field return value")
      .def_readonly("is_eq", &PyEqGridField::is_eq)
      .def("__len__", [](const PyEqGridField&) { return 1; })
      .def("__getitem__", [](const PyEqGridField& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_floor_position",
      &python_eq_floor_position,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqFloorPosition, std::unique_ptr<PyEqFloorPosition>>(
      m, "EqFloorPosition", "Fortran routine eq_floor_position return value")
      .def_readonly("is_eq", &PyEqFloorPosition::is_eq)
      .def("__len__", [](const PyEqFloorPosition&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqFloorPosition& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_high_energy_space_charge",
      &python_eq_high_energy_space_charge,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<
      PyEqHighEnergySpaceCharge,
      std::unique_ptr<PyEqHighEnergySpaceCharge>>(
      m,
      "EqHighEnergySpaceCharge",
      "Fortran routine eq_high_energy_space_charge return value")
      .def_readonly("is_eq", &PyEqHighEnergySpaceCharge::is_eq)
      .def("__len__", [](const PyEqHighEnergySpaceCharge&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqHighEnergySpaceCharge& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_xy_disp",
      &python_eq_xy_disp,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqXyDisp, std::unique_ptr<PyEqXyDisp>>(
      m, "EqXyDisp", "Fortran routine eq_xy_disp return value")
      .def_readonly("is_eq", &PyEqXyDisp::is_eq)
      .def("__len__", [](const PyEqXyDisp&) { return 1; })
      .def("__getitem__", [](const PyEqXyDisp& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_twiss",
      &python_eq_twiss,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqTwiss, std::unique_ptr<PyEqTwiss>>(
      m, "EqTwiss", "Fortran routine eq_twiss return value")
      .def_readonly("is_eq", &PyEqTwiss::is_eq)
      .def("__len__", [](const PyEqTwiss&) { return 1; })
      .def("__getitem__", [](const PyEqTwiss& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_mode3",
      &python_eq_mode3,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqMode3, std::unique_ptr<PyEqMode3>>(
      m, "EqMode3", "Fortran routine eq_mode3 return value")
      .def_readonly("is_eq", &PyEqMode3::is_eq)
      .def("__len__", [](const PyEqMode3&) { return 1; })
      .def("__getitem__", [](const PyEqMode3& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_bookkeeping_state",
      &python_eq_bookkeeping_state,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBookkeepingState, std::unique_ptr<PyEqBookkeepingState>>(
      m,
      "EqBookkeepingState",
      "Fortran routine eq_bookkeeping_state return value")
      .def_readonly("is_eq", &PyEqBookkeepingState::is_eq)
      .def("__len__", [](const PyEqBookkeepingState&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqBookkeepingState& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_rad_map",
      &python_eq_rad_map,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqRadMap, std::unique_ptr<PyEqRadMap>>(
      m, "EqRadMap", "Fortran routine eq_rad_map return value")
      .def_readonly("is_eq", &PyEqRadMap::is_eq)
      .def("__len__", [](const PyEqRadMap&) { return 1; })
      .def("__getitem__", [](const PyEqRadMap& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_rad_map_ele",
      &python_eq_rad_map_ele,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqRadMapEle, std::unique_ptr<PyEqRadMapEle>>(
      m, "EqRadMapEle", "Fortran routine eq_rad_map_ele return value")
      .def_readonly("is_eq", &PyEqRadMapEle::is_eq)
      .def("__len__", [](const PyEqRadMapEle&) { return 1; })
      .def("__getitem__", [](const PyEqRadMapEle& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_gen_grad1",
      &python_eq_gen_grad1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqGenGrad1, std::unique_ptr<PyEqGenGrad1>>(
      m, "EqGenGrad1", "Fortran routine eq_gen_grad1 return value")
      .def_readonly("is_eq", &PyEqGenGrad1::is_eq)
      .def("__len__", [](const PyEqGenGrad1&) { return 1; })
      .def("__getitem__", [](const PyEqGenGrad1& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_gen_grad_map",
      &python_eq_gen_grad_map,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqGenGradMap, std::unique_ptr<PyEqGenGradMap>>(
      m, "EqGenGradMap", "Fortran routine eq_gen_grad_map return value")
      .def_readonly("is_eq", &PyEqGenGradMap::is_eq)
      .def("__len__", [](const PyEqGenGradMap&) { return 1; })
      .def("__getitem__", [](const PyEqGenGradMap& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_surface_segmented_pt",
      &python_eq_surface_segmented_pt,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSurfaceSegmentedPt, std::unique_ptr<PyEqSurfaceSegmentedPt>>(
      m,
      "EqSurfaceSegmentedPt",
      "Fortran routine eq_surface_segmented_pt return value")
      .def_readonly("is_eq", &PyEqSurfaceSegmentedPt::is_eq)
      .def("__len__", [](const PyEqSurfaceSegmentedPt&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceSegmentedPt& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_surface_segmented",
      &python_eq_surface_segmented,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSurfaceSegmented, std::unique_ptr<PyEqSurfaceSegmented>>(
      m,
      "EqSurfaceSegmented",
      "Fortran routine eq_surface_segmented return value")
      .def_readonly("is_eq", &PyEqSurfaceSegmented::is_eq)
      .def("__len__", [](const PyEqSurfaceSegmented&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceSegmented& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_surface_h_misalign_pt",
      &python_eq_surface_h_misalign_pt,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSurfaceHMisalignPt, std::unique_ptr<PyEqSurfaceHMisalignPt>>(
      m,
      "EqSurfaceHMisalignPt",
      "Fortran routine eq_surface_h_misalign_pt return value")
      .def_readonly("is_eq", &PyEqSurfaceHMisalignPt::is_eq)
      .def("__len__", [](const PyEqSurfaceHMisalignPt&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceHMisalignPt& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_surface_h_misalign",
      &python_eq_surface_h_misalign,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSurfaceHMisalign, std::unique_ptr<PyEqSurfaceHMisalign>>(
      m,
      "EqSurfaceHMisalign",
      "Fortran routine eq_surface_h_misalign return value")
      .def_readonly("is_eq", &PyEqSurfaceHMisalign::is_eq)
      .def("__len__", [](const PyEqSurfaceHMisalign&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceHMisalign& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_surface_displacement_pt",
      &python_eq_surface_displacement_pt,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<
      PyEqSurfaceDisplacementPt,
      std::unique_ptr<PyEqSurfaceDisplacementPt>>(
      m,
      "EqSurfaceDisplacementPt",
      "Fortran routine eq_surface_displacement_pt return value")
      .def_readonly("is_eq", &PyEqSurfaceDisplacementPt::is_eq)
      .def("__len__", [](const PyEqSurfaceDisplacementPt&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceDisplacementPt& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_surface_displacement",
      &python_eq_surface_displacement,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSurfaceDisplacement, std::unique_ptr<PyEqSurfaceDisplacement>>(
      m,
      "EqSurfaceDisplacement",
      "Fortran routine eq_surface_displacement return value")
      .def_readonly("is_eq", &PyEqSurfaceDisplacement::is_eq)
      .def("__len__", [](const PyEqSurfaceDisplacement&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceDisplacement& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_target_point",
      &python_eq_target_point,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqTargetPoint, std::unique_ptr<PyEqTargetPoint>>(
      m, "EqTargetPoint", "Fortran routine eq_target_point return value")
      .def_readonly("is_eq", &PyEqTargetPoint::is_eq)
      .def("__len__", [](const PyEqTargetPoint&) { return 1; })
      .def("__getitem__", [](const PyEqTargetPoint& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_surface_curvature",
      &python_eq_surface_curvature,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSurfaceCurvature, std::unique_ptr<PyEqSurfaceCurvature>>(
      m,
      "EqSurfaceCurvature",
      "Fortran routine eq_surface_curvature return value")
      .def_readonly("is_eq", &PyEqSurfaceCurvature::is_eq)
      .def("__len__", [](const PyEqSurfaceCurvature&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSurfaceCurvature& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_photon_target",
      &python_eq_photon_target,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPhotonTarget, std::unique_ptr<PyEqPhotonTarget>>(
      m, "EqPhotonTarget", "Fortran routine eq_photon_target return value")
      .def_readonly("is_eq", &PyEqPhotonTarget::is_eq)
      .def("__len__", [](const PyEqPhotonTarget&) { return 1; })
      .def(
          "__getitem__", [](const PyEqPhotonTarget& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_photon_material",
      &python_eq_photon_material,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPhotonMaterial, std::unique_ptr<PyEqPhotonMaterial>>(
      m, "EqPhotonMaterial", "Fortran routine eq_photon_material return value")
      .def_readonly("is_eq", &PyEqPhotonMaterial::is_eq)
      .def("__len__", [](const PyEqPhotonMaterial&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqPhotonMaterial& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_pixel_pt",
      &python_eq_pixel_pt,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPixelPt, std::unique_ptr<PyEqPixelPt>>(
      m, "EqPixelPt", "Fortran routine eq_pixel_pt return value")
      .def_readonly("is_eq", &PyEqPixelPt::is_eq)
      .def("__len__", [](const PyEqPixelPt&) { return 1; })
      .def("__getitem__", [](const PyEqPixelPt& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_pixel_detec",
      &python_eq_pixel_detec,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPixelDetec, std::unique_ptr<PyEqPixelDetec>>(
      m, "EqPixelDetec", "Fortran routine eq_pixel_detec return value")
      .def_readonly("is_eq", &PyEqPixelDetec::is_eq)
      .def("__len__", [](const PyEqPixelDetec&) { return 1; })
      .def("__getitem__", [](const PyEqPixelDetec& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_photon_element",
      &python_eq_photon_element,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPhotonElement, std::unique_ptr<PyEqPhotonElement>>(
      m, "EqPhotonElement", "Fortran routine eq_photon_element return value")
      .def_readonly("is_eq", &PyEqPhotonElement::is_eq)
      .def("__len__", [](const PyEqPhotonElement&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqPhotonElement& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_wall3d_vertex",
      &python_eq_wall3d_vertex,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWall3dVertex, std::unique_ptr<PyEqWall3dVertex>>(
      m, "EqWall3dVertex", "Fortran routine eq_wall3d_vertex return value")
      .def_readonly("is_eq", &PyEqWall3dVertex::is_eq)
      .def("__len__", [](const PyEqWall3dVertex&) { return 1; })
      .def(
          "__getitem__", [](const PyEqWall3dVertex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_wall3d_section",
      &python_eq_wall3d_section,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWall3dSection, std::unique_ptr<PyEqWall3dSection>>(
      m, "EqWall3dSection", "Fortran routine eq_wall3d_section return value")
      .def_readonly("is_eq", &PyEqWall3dSection::is_eq)
      .def("__len__", [](const PyEqWall3dSection&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqWall3dSection& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_wall3d",
      &python_eq_wall3d,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqWall3d, std::unique_ptr<PyEqWall3d>>(
      m, "EqWall3d", "Fortran routine eq_wall3d return value")
      .def_readonly("is_eq", &PyEqWall3d::is_eq)
      .def("__len__", [](const PyEqWall3d&) { return 1; })
      .def("__getitem__", [](const PyEqWall3d& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_ramper_lord",
      &python_eq_ramper_lord,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqRamperLord, std::unique_ptr<PyEqRamperLord>>(
      m, "EqRamperLord", "Fortran routine eq_ramper_lord return value")
      .def_readonly("is_eq", &PyEqRamperLord::is_eq)
      .def("__len__", [](const PyEqRamperLord&) { return 1; })
      .def("__getitem__", [](const PyEqRamperLord& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_control",
      &python_eq_control,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqControl, std::unique_ptr<PyEqControl>>(
      m, "EqControl", "Fortran routine eq_control return value")
      .def_readonly("is_eq", &PyEqControl::is_eq)
      .def("__len__", [](const PyEqControl&) { return 1; })
      .def("__getitem__", [](const PyEqControl& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_control_var1",
      &python_eq_control_var1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqControlVar1, std::unique_ptr<PyEqControlVar1>>(
      m, "EqControlVar1", "Fortran routine eq_control_var1 return value")
      .def_readonly("is_eq", &PyEqControlVar1::is_eq)
      .def("__len__", [](const PyEqControlVar1&) { return 1; })
      .def("__getitem__", [](const PyEqControlVar1& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_control_ramp1",
      &python_eq_control_ramp1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqControlRamp1, std::unique_ptr<PyEqControlRamp1>>(
      m, "EqControlRamp1", "Fortran routine eq_control_ramp1 return value")
      .def_readonly("is_eq", &PyEqControlRamp1::is_eq)
      .def("__len__", [](const PyEqControlRamp1&) { return 1; })
      .def(
          "__getitem__", [](const PyEqControlRamp1& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_controller",
      &python_eq_controller,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqController, std::unique_ptr<PyEqController>>(
      m, "EqController", "Fortran routine eq_controller return value")
      .def_readonly("is_eq", &PyEqController::is_eq)
      .def("__len__", [](const PyEqController&) { return 1; })
      .def("__getitem__", [](const PyEqController& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_ellipse_beam_init",
      &python_eq_ellipse_beam_init,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqEllipseBeamInit, std::unique_ptr<PyEqEllipseBeamInit>>(
      m,
      "EqEllipseBeamInit",
      "Fortran routine eq_ellipse_beam_init return value")
      .def_readonly("is_eq", &PyEqEllipseBeamInit::is_eq)
      .def("__len__", [](const PyEqEllipseBeamInit&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqEllipseBeamInit& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_kv_beam_init",
      &python_eq_kv_beam_init,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqKvBeamInit, std::unique_ptr<PyEqKvBeamInit>>(
      m, "EqKvBeamInit", "Fortran routine eq_kv_beam_init return value")
      .def_readonly("is_eq", &PyEqKvBeamInit::is_eq)
      .def("__len__", [](const PyEqKvBeamInit&) { return 1; })
      .def("__getitem__", [](const PyEqKvBeamInit& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_grid_beam_init",
      &python_eq_grid_beam_init,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqGridBeamInit, std::unique_ptr<PyEqGridBeamInit>>(
      m, "EqGridBeamInit", "Fortran routine eq_grid_beam_init return value")
      .def_readonly("is_eq", &PyEqGridBeamInit::is_eq)
      .def("__len__", [](const PyEqGridBeamInit&) { return 1; })
      .def(
          "__getitem__", [](const PyEqGridBeamInit& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_beam_init",
      &python_eq_beam_init,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBeamInit, std::unique_ptr<PyEqBeamInit>>(
      m, "EqBeamInit", "Fortran routine eq_beam_init return value")
      .def_readonly("is_eq", &PyEqBeamInit::is_eq)
      .def("__len__", [](const PyEqBeamInit&) { return 1; })
      .def("__getitem__", [](const PyEqBeamInit& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_lat_param",
      &python_eq_lat_param,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqLatParam, std::unique_ptr<PyEqLatParam>>(
      m, "EqLatParam", "Fortran routine eq_lat_param return value")
      .def_readonly("is_eq", &PyEqLatParam::is_eq)
      .def("__len__", [](const PyEqLatParam&) { return 1; })
      .def("__getitem__", [](const PyEqLatParam& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_mode_info",
      &python_eq_mode_info,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqModeInfo, std::unique_ptr<PyEqModeInfo>>(
      m, "EqModeInfo", "Fortran routine eq_mode_info return value")
      .def_readonly("is_eq", &PyEqModeInfo::is_eq)
      .def("__len__", [](const PyEqModeInfo&) { return 1; })
      .def("__getitem__", [](const PyEqModeInfo& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_pre_tracker",
      &python_eq_pre_tracker,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqPreTracker, std::unique_ptr<PyEqPreTracker>>(
      m, "EqPreTracker", "Fortran routine eq_pre_tracker return value")
      .def_readonly("is_eq", &PyEqPreTracker::is_eq)
      .def("__len__", [](const PyEqPreTracker&) { return 1; })
      .def("__getitem__", [](const PyEqPreTracker& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_anormal_mode",
      &python_eq_anormal_mode,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqAnormalMode, std::unique_ptr<PyEqAnormalMode>>(
      m, "EqAnormalMode", "Fortran routine eq_anormal_mode return value")
      .def_readonly("is_eq", &PyEqAnormalMode::is_eq)
      .def("__len__", [](const PyEqAnormalMode&) { return 1; })
      .def("__getitem__", [](const PyEqAnormalMode& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_linac_normal_mode",
      &python_eq_linac_normal_mode,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqLinacNormalMode, std::unique_ptr<PyEqLinacNormalMode>>(
      m,
      "EqLinacNormalMode",
      "Fortran routine eq_linac_normal_mode return value")
      .def_readonly("is_eq", &PyEqLinacNormalMode::is_eq)
      .def("__len__", [](const PyEqLinacNormalMode&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqLinacNormalMode& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_normal_modes",
      &python_eq_normal_modes,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqNormalModes, std::unique_ptr<PyEqNormalModes>>(
      m, "EqNormalModes", "Fortran routine eq_normal_modes return value")
      .def_readonly("is_eq", &PyEqNormalModes::is_eq)
      .def("__len__", [](const PyEqNormalModes&) { return 1; })
      .def("__getitem__", [](const PyEqNormalModes& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_em_field",
      &python_eq_em_field,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqEmField, std::unique_ptr<PyEqEmField>>(
      m, "EqEmField", "Fortran routine eq_em_field return value")
      .def_readonly("is_eq", &PyEqEmField::is_eq)
      .def("__len__", [](const PyEqEmField&) { return 1; })
      .def("__getitem__", [](const PyEqEmField& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_strong_beam",
      &python_eq_strong_beam,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqStrongBeam, std::unique_ptr<PyEqStrongBeam>>(
      m, "EqStrongBeam", "Fortran routine eq_strong_beam return value")
      .def_readonly("is_eq", &PyEqStrongBeam::is_eq)
      .def("__len__", [](const PyEqStrongBeam&) { return 1; })
      .def("__getitem__", [](const PyEqStrongBeam& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_track_point",
      &python_eq_track_point,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqTrackPoint, std::unique_ptr<PyEqTrackPoint>>(
      m, "EqTrackPoint", "Fortran routine eq_track_point return value")
      .def_readonly("is_eq", &PyEqTrackPoint::is_eq)
      .def("__len__", [](const PyEqTrackPoint&) { return 1; })
      .def("__getitem__", [](const PyEqTrackPoint& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_track",
      &python_eq_track,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqTrack, std::unique_ptr<PyEqTrack>>(
      m, "EqTrack", "Fortran routine eq_track return value")
      .def_readonly("is_eq", &PyEqTrack::is_eq)
      .def("__len__", [](const PyEqTrack&) { return 1; })
      .def("__getitem__", [](const PyEqTrack& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_space_charge_common",
      &python_eq_space_charge_common,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqSpaceChargeCommon, std::unique_ptr<PyEqSpaceChargeCommon>>(
      m,
      "EqSpaceChargeCommon",
      "Fortran routine eq_space_charge_common return value")
      .def_readonly("is_eq", &PyEqSpaceChargeCommon::is_eq)
      .def("__len__", [](const PyEqSpaceChargeCommon&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqSpaceChargeCommon& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_bmad_common",
      &python_eq_bmad_common,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBmadCommon, std::unique_ptr<PyEqBmadCommon>>(
      m, "EqBmadCommon", "Fortran routine eq_bmad_common return value")
      .def_readonly("is_eq", &PyEqBmadCommon::is_eq)
      .def("__len__", [](const PyEqBmadCommon&) { return 1; })
      .def("__getitem__", [](const PyEqBmadCommon& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_rad_int1",
      &python_eq_rad_int1,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqRadInt1, std::unique_ptr<PyEqRadInt1>>(
      m, "EqRadInt1", "Fortran routine eq_rad_int1 return value")
      .def_readonly("is_eq", &PyEqRadInt1::is_eq)
      .def("__len__", [](const PyEqRadInt1&) { return 1; })
      .def("__getitem__", [](const PyEqRadInt1& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_rad_int_branch",
      &python_eq_rad_int_branch,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqRadIntBranch, std::unique_ptr<PyEqRadIntBranch>>(
      m, "EqRadIntBranch", "Fortran routine eq_rad_int_branch return value")
      .def_readonly("is_eq", &PyEqRadIntBranch::is_eq)
      .def("__len__", [](const PyEqRadIntBranch&) { return 1; })
      .def(
          "__getitem__", [](const PyEqRadIntBranch& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_rad_int_all_ele",
      &python_eq_rad_int_all_ele,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqRadIntAllEle, std::unique_ptr<PyEqRadIntAllEle>>(
      m, "EqRadIntAllEle", "Fortran routine eq_rad_int_all_ele return value")
      .def_readonly("is_eq", &PyEqRadIntAllEle::is_eq)
      .def("__len__", [](const PyEqRadIntAllEle&) { return 1; })
      .def(
          "__getitem__", [](const PyEqRadIntAllEle& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_ele",
      &python_eq_ele,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqEle, std::unique_ptr<PyEqEle>>(
      m, "EqEle", "Fortran routine eq_ele return value")
      .def_readonly("is_eq", &PyEqEle::is_eq)
      .def("__len__", [](const PyEqEle&) { return 1; })
      .def("__getitem__", [](const PyEqEle& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_complex_taylor_term",
      &python_eq_complex_taylor_term,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqComplexTaylorTerm, std::unique_ptr<PyEqComplexTaylorTerm>>(
      m,
      "EqComplexTaylorTerm",
      "Fortran routine eq_complex_taylor_term return value")
      .def_readonly("is_eq", &PyEqComplexTaylorTerm::is_eq)
      .def("__len__", [](const PyEqComplexTaylorTerm&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqComplexTaylorTerm& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_complex_taylor",
      &python_eq_complex_taylor,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqComplexTaylor, std::unique_ptr<PyEqComplexTaylor>>(
      m, "EqComplexTaylor", "Fortran routine eq_complex_taylor return value")
      .def_readonly("is_eq", &PyEqComplexTaylor::is_eq)
      .def("__len__", [](const PyEqComplexTaylor&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqComplexTaylor& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_branch",
      &python_eq_branch,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBranch, std::unique_ptr<PyEqBranch>>(
      m, "EqBranch", "Fortran routine eq_branch return value")
      .def_readonly("is_eq", &PyEqBranch::is_eq)
      .def("__len__", [](const PyEqBranch&) { return 1; })
      .def("__getitem__", [](const PyEqBranch& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_lat",
      &python_eq_lat,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqLat, std::unique_ptr<PyEqLat>>(
      m, "EqLat", "Fortran routine eq_lat return value")
      .def_readonly("is_eq", &PyEqLat::is_eq)
      .def("__len__", [](const PyEqLat&) { return 1; })
      .def("__getitem__", [](const PyEqLat& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_bunch",
      &python_eq_bunch,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBunch, std::unique_ptr<PyEqBunch>>(
      m, "EqBunch", "Fortran routine eq_bunch return value")
      .def_readonly("is_eq", &PyEqBunch::is_eq)
      .def("__len__", [](const PyEqBunch&) { return 1; })
      .def("__getitem__", [](const PyEqBunch& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_bunch_params",
      &python_eq_bunch_params,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBunchParams, std::unique_ptr<PyEqBunchParams>>(
      m, "EqBunchParams", "Fortran routine eq_bunch_params return value")
      .def_readonly("is_eq", &PyEqBunchParams::is_eq)
      .def("__len__", [](const PyEqBunchParams&) { return 1; })
      .def("__getitem__", [](const PyEqBunchParams& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_beam",
      &python_eq_beam,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqBeam, std::unique_ptr<PyEqBeam>>(
      m, "EqBeam", "Fortran routine eq_beam return value")
      .def_readonly("is_eq", &PyEqBeam::is_eq)
      .def("__len__", [](const PyEqBeam&) { return 1; })
      .def("__getitem__", [](const PyEqBeam& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.is_eq);
        return py::none();
      });
  m.def(
      "eq_aperture_point",
      &python_eq_aperture_point,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqAperturePoint, std::unique_ptr<PyEqAperturePoint>>(
      m, "EqAperturePoint", "Fortran routine eq_aperture_point return value")
      .def_readonly("is_eq", &PyEqAperturePoint::is_eq)
      .def("__len__", [](const PyEqAperturePoint&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqAperturePoint& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_aperture_param",
      &python_eq_aperture_param,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqApertureParam, std::unique_ptr<PyEqApertureParam>>(
      m, "EqApertureParam", "Fortran routine eq_aperture_param return value")
      .def_readonly("is_eq", &PyEqApertureParam::is_eq)
      .def("__len__", [](const PyEqApertureParam&) { return 1; })
      .def(
          "__getitem__",
          [](const PyEqApertureParam& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "eq_aperture_scan",
      &python_eq_aperture_scan,
      py::arg("f1"),
      py::arg("f2"),
      py::arg("is_eq"),
      R"""(No docstring available

Parameters
----------
f1 : 
f2 : 
is_eq : 
)""");
  py::class_<PyEqApertureScan, std::unique_ptr<PyEqApertureScan>>(
      m, "EqApertureScan", "Fortran routine eq_aperture_scan return value")
      .def_readonly("is_eq", &PyEqApertureScan::is_eq)
      .def("__len__", [](const PyEqApertureScan&) { return 1; })
      .def(
          "__getitem__", [](const PyEqApertureScan& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_eq);
            return py::none();
          });
  m.def(
      "srdt_calc",
      &Bmad::srdt_calc,
      py::arg("lat"),
      py::arg("order"),
      py::arg("n_slices_gen_opt") = py::none(),
      py::arg("n_slices_sxt_opt") = py::none(),
      py::arg("per_ele_out") = py::none(),
      R"""(Calculate summation RDT terms up to order=1 or order=2 while slicing sextupoles

n_slices_sxt_opt times and all other elements n_slices_gen_opt times.
These formulas are documented in "The Sextupole Scheme for the Swiss Light Source (SLS): An Analytic Approach"
by Johan Bengtsson.  SLS Note 9/97.
The 2nd order formulas are documented in "Second-order driving terms due to sextupoles and
chromatic effects of quadrupoles" by Chun-xi Wang.  AOP-TN-2009-020.

Parameters
----------
lat : LatStruct
    lattice with Twiss parameters calculated.
order : int
    1 to calculate only first order terms.  2 to also calculate 2nd order terms.
n_slices_gen_opt : int, optional
    number of times to slice elements other than sextupoles.  Default is 10.
n_slices_sxt_opt : int, optional
    nubmer of times to slice sextupoles.  Default is 20.

Returns
-------
srdt_sums : SummationRdtStruct
    contains complex RDT strengths.
)""");
  m.def(
      "srdt_lsq_solution",
      &Bmad::srdt_lsq_solution,
      py::arg("lat"),
      py::arg("var_indexes"),
      py::arg("n_slices_gen_opt") = py::none(),
      py::arg("n_slices_sxt_opt") = py::none(),
      py::arg("chrom_set_x_opt") = py::none(),
      py::arg("chrom_set_y_opt") = py::none(),
      py::arg("weight_in") = py::none(),
      R"""(chrom_set_x_opt, chrom_set_y_opt, weight_in)

Given lat, finds K2 moments that set the chromaticity and zeros-out the real
and complex parts of the first order driving terms, that minimizes the sum of the squares
of the K2 moments.  i.e. the weakest sextupole scheme that sets chromaticity
and zeros out the first order terms.

Parameters
----------
lat : LatStruct
    lattice with Twiss parameters calculated.
var_indexes : int
    indexes in lat.ele that are K2 variables.  Must be sorted smallest index to largest index.
n_slices_gen_opt : int, optional
    number of times to slice elements other than sextupoles.  Default is 10.
n_slices_sxt_opt : int, optional
    nubmer of times to slice sextupoles.  Default is 20.
chrom_set_x_opt : float, optional
    what to set x chromaticity to.  Default zero.
chrom_set_y_opt : float, optional
    what to set y chromaticity to.  Default zero.
weight_in : float, optional
    moment weights. Terms are: [wgt_chrom_x, wgt_chrom_y, wgt_h20001, wgt_h00201, wgt_h10002, wgt_h21000,
    wgt_h30000, wgt_h10110, wgt_h10020, wgt_h10200, If present, any terms equal to zero are given default
    values which is 1.0e4 for wgt_chrom_x and wgt_chrom_y and is 1.0 for everything else.

Returns
-------
ls_soln : float
    contains K2 for the indexes in var_indexes
)""");
  m.def(
      "multipole_kicks",
      &Bmad::multipole_kicks,
      py::arg("knl"),
      py::arg("tilt"),
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("pole_type") = py::none(),
      py::arg("ref_orb_offset") = py::none(),
      R"""(Subroutine to put in the kick due to a multipole.

Also see the ab_multipole_kicks routine.

Parameters
----------
knl : float
    Multipole strengths.
tilt : float
    Multipole tilts.
ele : EleStruct
    Lattice element containing the multipoles.
orbit : CoordStruct
    Particle position.
    This parameter is an input/output and is modified in-place. As an output: Kicked particle.
pole_type : int, optional
    Type of multipole. magnetic$ (default) or electric$.
ref_orb_offset : bool, optional
    If present and n = 0 then the multipole simulates a zero length bend with bending angle knl.
)""");
  m.def(
      "ab_multipole_kicks",
      &Bmad::ab_multipole_kicks,
      py::arg("an"),
      py::arg("bn"),
      py::arg("ix_pole_max"),
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("pole_type") = py::none(),
      py::arg("scale") = py::none(),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Routine to put in the kick due to ab_multipole components.

Also see the multipole_kicks routine.
The kick will be corrected for the orientation of the element and the particle direction of travel.

Parameters
----------
an : float
    Skew multipole strengths.
bn : float
    Normal multipole tilts.
ix_pole_max : int
    Maximum pole index.
ele : EleStruct
    Lattice element containing the multipoles.
orbit : CoordStruct
    Particle position.
    This parameter is an input/output and is modified in-place. As an output: Kicked particle.
pole_type : int, optional
    Type of multipole. magnetic$ (default) or electric$.
scale : float, optional
    Factor to scale the kicks. Default is 1. For pole_type = electric$, set scale to the longitudinal length
    of the field region
mat6 : float, optional
    Transfer matrix before the multipole.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    including multipole.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
)""");
  m.def(
      "multipole_kick",
      &Bmad::multipole_kick,
      py::arg("knl"),
      py::arg("tilt"),
      py::arg("n"),
      py::arg("ref_species"),
      py::arg("ele_orientation"),
      py::arg("coord"),
      py::arg("pole_type") = py::none(),
      py::arg("ref_orb_offset") = py::none(),
      R"""(Subroutine to put in the kick due to a multipole.

Parameters
----------
knl : float
    Multipole integrated strength.
tilt : float
    Multipole tilt.
n : float
    Multipole order.
ref_species : int
    Reference species.
ele_orientation : int
    Element orientation +1 = normal, -1 = reversed.
coord : CoordStruct
    Particle position and direction of travel.
pole_type : int, optional
    Type of multipole. magnetic$ (default) or electric$.
ref_orb_offset : bool, optional
    If True and n = 0 then use the MAD convention and model the multipole as a zero length bend with bending
    angle knl. Default is False.
)""");
  m.def(
      "ab_multipole_kick",
      &Bmad::ab_multipole_kick,
      py::arg("a"),
      py::arg("b"),
      py::arg("n"),
      py::arg("ref_species"),
      py::arg("ele_orientation"),
      py::arg("coord"),
      py::arg("pole_type") = py::none(),
      py::arg("scale") = py::none(),
      R"""(Subroutine to put in the kick due to an ab_multipole.

Parameters
----------
a : float
    Multipole skew component.
b : float
    Multipole normal component.
n : float
    Multipole order.
ref_species : int
    Reference species.
ele_orientation : int
    Element orientation +1 = normal, -1 = reversed, 0 = Ignore orientation and tracking species (used with
    pole_type = magnetic$).
coord : CoordStruct
    Particle position and direction of travel.
pole_type : int, optional
    Type of multipole. magnetic$ (default) or electric$.
scale : float, optional
    Factor to scale the kicks. Default is 1. For pole_type = electric$, set scale to the longitudinal length
    of the field region.

Return value is a dictionary containing values below.


Returns
-------
kx : float
    X kick.
ky : float
    Y kick.
dk : float
    Kick derivative: dkick(x,y)/d(x,y).
)""");
  py::class_<Bmad::AbMultipoleKick, std::unique_ptr<Bmad::AbMultipoleKick>>(
      m, "AbMultipoleKick", "Fortran routine ab_multipole_kick return value")
      .def_readonly("kx", &Bmad::AbMultipoleKick::kx)
      .def_readonly("ky", &Bmad::AbMultipoleKick::ky)
      .def_readonly("dk", &Bmad::AbMultipoleKick::dk)
      .def("__len__", [](const Bmad::AbMultipoleKick&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::AbMultipoleKick& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.kx);
            if (i == 1)
              return py::cast(s.ky);
            if (i == 2)
              return py::cast(s.dk);
            return py::none();
          });
  m.def(
      "emit_6d",
      &Bmad::emit_6d,
      py::arg("ele_ref"),
      py::arg("include_opening_angle"),
      py::arg("closed_orbit") = py::none(),
      R"""(Routine to calculate the three normal mode emittances, damping partition numbers, radiation integrals, etc.

Since the emattances, etc. are only an invariant in the limit of zero damping, the calculated
values will vary depending upon the reference element.
If the lattice geometry is open, only the radiation integrals is computed.

Parameters
----------
ele_ref : EleStruct
    Origin of the 1-turn maps used to evaluate the emittances.
include_opening_angle : bool
    If True include the effect of the vertical opening angle of emitted radiation. Generally use True unless
    comparing against other codes.
closed_orbit : CoordStruct, optional
    Closed orbit. If not present this routine will calculate it.

Return value is a dictionary containing values below.


Returns
-------
mode : NormalModesStruct
    Emittance and other info.
sigma_mat : float
    Sigma matrix.
rad_int_by_ele : RadIntAllEleStruct
    Radiation integrals element-by-element.
)""");
  py::class_<Bmad::Emit6d, std::unique_ptr<Bmad::Emit6d>>(
      m, "Emit6d", "Fortran routine emit_6d return value")
      .def_readonly("mode", &Bmad::Emit6d::mode)
      .def_readonly("sigma_mat", &Bmad::Emit6d::sigma_mat)
      .def_readonly("rad_int_by_ele", &Bmad::Emit6d::rad_int_by_ele)
      .def("__len__", [](const Bmad::Emit6d&) { return 3; })
      .def("__getitem__", [](const Bmad::Emit6d& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.mode);
        if (i == 1)
          return py::cast(s.sigma_mat);
        if (i == 2)
          return py::cast(s.rad_int_by_ele);
        return py::none();
      });
  m.def(
      "rad_damp_and_stoc_mats",
      &Bmad::rad_damp_and_stoc_mats,
      py::arg("ele1"),
      py::arg("ele2"),
      py::arg("include_opening_angle"),
      py::arg("closed_orbit") = py::none(),
      R"""(Routine to calculate the damping and stochastic variance matrices from exit end of ele1

to the exit end of ele2. Use ele1 = ele2 to get 1-turn matrices.
If ele2 is before ele1 the integration range if from ele1 to the branch end plus
from the beginning to ele2.

Parameters
----------
ele1 : EleStruct
    Start element of integration range.
ele2 : EleStruct
    End element of integration range.
include_opening_angle : bool
    If True include the effect of the vertical opening angle of emitted radiation. Generally use True unless
    comparing against other codes.
closed_orbit : CoordStruct, optional
    Closed orbit. If not present this routine will calculate it.

Return value is a dictionary containing values below.


Returns
-------
rmap : RadMapStruct
    Damping and stochastic mats .stoc_mat               --  stochastic variance matrix.
mode : NormalModesStruct
    .dpz_damp                 -- Change in pz without RF. .pz_average               -- Average pz due to
    damping.
xfer_nodamp_mat : float
    Transfer matrix without damping.
rad_int_branch : RadIntBranchStruct
    Array of element-by-element radiation integrals.
err_flag : bool
    Set true if there is a problem.
)""");
  py::class_<
      Bmad::RadDampAndStocMats,
      std::unique_ptr<Bmad::RadDampAndStocMats>>(
      m,
      "RadDampAndStocMats",
      "Fortran routine rad_damp_and_stoc_mats return value")
      .def_readonly("rmap", &Bmad::RadDampAndStocMats::rmap)
      .def_readonly("mode", &Bmad::RadDampAndStocMats::mode)
      .def_readonly(
          "xfer_nodamp_mat", &Bmad::RadDampAndStocMats::xfer_nodamp_mat)
      .def_readonly("err_flag", &Bmad::RadDampAndStocMats::err_flag)
      .def_readonly("rad_int_branch", &Bmad::RadDampAndStocMats::rad_int_branch)
      .def("__len__", [](const Bmad::RadDampAndStocMats&) { return 5; })
      .def(
          "__getitem__",
          [](const Bmad::RadDampAndStocMats& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rmap);
            if (i == 1)
              return py::cast(s.mode);
            if (i == 2)
              return py::cast(s.xfer_nodamp_mat);
            if (i == 3)
              return py::cast(s.err_flag);
            if (i == 4)
              return py::cast(s.rad_int_branch);
            return py::none();
          });
  m.def(
      "rad1_damp_and_stoc_mats",
      &Bmad::rad1_damp_and_stoc_mats,
      py::arg("ele"),
      py::arg("include_opening_angle"),
      py::arg("orb_in"),
      py::arg("orb_out"),
      py::arg("g2_tol"),
      py::arg("g3_tol"),
      py::arg("ele0") = py::none(),
      R"""(Routine to calculate the damping and stochastic matrices for a given lattice element.

Parameters
----------
ele : EleStruct
    Element under consideration.
include_opening_angle : bool
    If True include the effect of the vertical opening angle of emitted radiation. Generally use True unless
    comparing against other codes.
orb_in : CoordStruct
    Entrance orbit about which to compute the matrices.
orb_out : CoordStruct
    Exit orbit.
g2_tol : float
    Tollerance on g^2 per unit length (damping tolerance).
g3_tol : float
    Tollerance on g^3 per unit length (stocastic tolerance).
ele0 : EleStruct, optional
    Element before `ele`. Needed if and only if rad_int1 is present

Return value is a dictionary containing values below.


Returns
-------
rad_map : RadMapStruct
    Damping and stochastic matrices. .stoc_mat             -- Variance matrix.
err_flag : bool
    Set true if there is an error. False otherwise.
rad_int1 : RadInt1Struct
    Radiation integrals
)""");
  py::class_<
      Bmad::Rad1DampAndStocMats,
      std::unique_ptr<Bmad::Rad1DampAndStocMats>>(
      m,
      "Rad1DampAndStocMats",
      "Fortran routine rad1_damp_and_stoc_mats return value")
      .def_readonly("rad_map", &Bmad::Rad1DampAndStocMats::rad_map)
      .def_readonly("err_flag", &Bmad::Rad1DampAndStocMats::err_flag)
      .def_readonly("rad_int1", &Bmad::Rad1DampAndStocMats::rad_int1)
      .def("__len__", [](const Bmad::Rad1DampAndStocMats&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::Rad1DampAndStocMats& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rad_map);
            if (i == 1)
              return py::cast(s.err_flag);
            if (i == 2)
              return py::cast(s.rad_int1);
            return py::none();
          });
  m.def(
      "rad_g_integrals",
      &python_rad_g_integrals,
      py::arg("ele"),
      py::arg("where"),
      py::arg("orb_in"),
      py::arg("orb_out"),
      py::arg("int_g2"),
      py::arg("int_g3"),
      py::arg("g_tol"),
      py::arg("g2_tol"),
      py::arg("g3_tol"),
      R"""(Routine to calculate bending strength integrals (g(s) = 1/trajectory_bending_radius(s)) in

laboratory coords.

Parameters
----------
ele : EleStruct
    Element under consideration.
where : int
    What part of ele to integrate over. upstream$ -> 1st half of element, downsteam$ -> 2nd half, all$ ->
    everything.
orb_in : CoordStruct
    Entrance orbit about which to compute the matrices.
orb_out : CoordStruct
    Exit orbit.
g_tol : float
    Tollerance on |g| per unit length.
g2_tol : float
    Tollerance on g^2 per unit length.
g3_tol : float
    Tollerance on g^3 per unit length.

Returns
-------
int_g : float
    Integrals of (gx,gy) vector. gint_g2, int_g3       -- real(rp): integrals of |g|^2 and |g|^3.
)""");
  py::class_<PyRadGIntegrals, std::unique_ptr<PyRadGIntegrals>>(
      m, "RadGIntegrals", "Fortran routine rad_g_integrals return value")
      .def_readonly("int_g", &PyRadGIntegrals::int_g)
      .def_readonly("int_g2", &PyRadGIntegrals::int_g2)
      .def_readonly("int_g3", &PyRadGIntegrals::int_g3)
      .def("__len__", [](const PyRadGIntegrals&) { return 3; })
      .def("__getitem__", [](const PyRadGIntegrals& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.int_g);
        if (i == 1)
          return py::cast(s.int_g2);
        if (i == 2)
          return py::cast(s.int_g3);
        return py::none();
      });
  m.def(
      "re_allocate_wall3d_vertex_array",
      &Bmad::re_allocate_wall3d_vertex_array,
      py::arg("v"),
      py::arg("n"),
      py::arg("exact") = py::none(),
      R"""(Routine to reallocate an array of vertex structures.

Overloaded by re_allocate.

Parameters
----------
v : Wall3DVertexStruct
    Array of vertices
    This parameter is an input/output and is modified in-place. As an output: Allocated array.
n : int
    Minimum size needed for array.
exact : bool, optional
    If present and False then the size of the output array is permitted to be larger than n. Default is True.
)""");
  m.def(
      "re_allocate_wall3d_section_array",
      &Bmad::re_allocate_wall3d_section_array,
      py::arg("section"),
      py::arg("n"),
      py::arg("exact") = py::none(),
      R"""(Routine to reallocate an array of wall3d%section(:).

Overloaded by re_allocate.

Parameters
----------
section : Wall3DSectionStruct
    Array of vertices
    This parameter is an input/output and is modified in-place. As an output: Allocated array.
n : int
    Minimum size needed for array.
exact : bool, optional
    If present and False then the size of the output array is permitted to be larger than n. Default is True.
)""");
  m.def(
      "wall3d_initializer",
      &Bmad::wall3d_initializer,
      py::arg("wall3d"),
      R"""(Routine to initialize a wall3d_struct

1) Add vertex points if there is symmetry.
2) Compute circular and elliptical centers.
3) Compute spline coefficients, etc.

Parameters
----------
wall3d : Wall3DStruct
    Wall.
    This parameter is an input/output and is modified in-place. As an output: Initialized wall.

Returns
-------
err : bool
    Set true if there is a problem.
)""");
  m.def(
      "wall3d_section_initializer",
      &Bmad::wall3d_section_initializer,
      py::arg("section"),
      R"""(Routine to initialize a wall3d_section_struct:

1) Add vertex points if there is symmetry.
2) Compute circular and elliptical centers.

Parameters
----------
section : Wall3DSectionStruct
    Wall3d section.
    This parameter is an input/output and is modified in-place. As an output: Initialized section-section.

Returns
-------
err : bool
    Set true if there is a problem.
)""");
  m.def(
      "calc_wall_radius",
      &Bmad::calc_wall_radius,
      py::arg("v"),
      py::arg("cos_ang"),
      py::arg("sin_ang"),
      R"""(Routine to calculate the wall radius at a given angle for a given cross-section

Additionally, the transverse directional derivative is calculated.
Module needed:
use wall3d_mod

Parameters
----------
v : Wall3DVertexStruct
    Array of vertices that make up the cross-section.
cos_ang : float
    cosine of the transverse photon position.
sin_ang : float
    sine of the transverse photon position.

Return value is a dictionary containing values below.


Returns
-------
r_wall : float
    Wall radius at given angle.
dr_dtheta : float
    derivative of r_wall.
ix_vertex : int
    Wall at given angle is between v(ix_vertex-1) and v(ix_vertex). If ix_vertex = 1 then Wall at given angle
    is between v(N) and v(1) where N = size(v).
)""");
  py::class_<Bmad::CalcWallRadius, std::unique_ptr<Bmad::CalcWallRadius>>(
      m, "CalcWallRadius", "Fortran routine calc_wall_radius return value")
      .def_readonly("r_wall", &Bmad::CalcWallRadius::r_wall)
      .def_readonly("dr_dtheta", &Bmad::CalcWallRadius::dr_dtheta)
      .def_readonly("ix_vertex", &Bmad::CalcWallRadius::ix_vertex)
      .def("__len__", [](const Bmad::CalcWallRadius&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::CalcWallRadius& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.r_wall);
            if (i == 1)
              return py::cast(s.dr_dtheta);
            if (i == 2)
              return py::cast(s.ix_vertex);
            return py::none();
          });
  m.def(
      "wall3d_d_radius",
      &Bmad::wall3d_d_radius,
      py::arg("position"),
      py::arg("ele"),
      py::arg("ix_wall") = py::none(),
      R"""(no_wall_here, origin, radius_wall, err_flag) result (d_radius)

Routine to calculate the difference radius = particle_radius - wall_radius.
Radiuses are measured along a line from the wall origin with the line passing through
the particle position.
The wall origin itself lies on a line connecting the centers of the bounding sections.
Module needed:
use wall3d_mod

Parameters
----------
position : float
    Particle position in element coordinates. In a patch, with respect to entrance coords. [position(1),
    position(3)] = [x, y] transverse coords. position(5)                = Longitudinal position relative to
    beginning of element. position(6)                = Longitudinal velocity (only +/- sign matters).
ele : EleStruct
    Element with wall
ix_wall : int, optional
    Index of wall in .wall3d(:) array. Default is 1.

Return value is a dictionary containing values below.


Returns
-------
d_radius : float
    r_particle - r_wall
perp : float
    Perpendicular normal to the wall.
ix_section : int
    Set to wall slice section particle is in. That is between ix_section and ix_section+1.
no_wall_here : bool
    True if the sub-chamber under consideration does not exist at the longitudinal location of the particle.
origin : float
    (x, y, s) origin with respect to the radius is measured. Uses the same coords as position.
radius_wall : float
    Radius of the wall.
err_flag : bool
    Set True if error. (EG noassociated .wall3d), false otherwise.
)""");
  py::class_<Bmad::Wall3dDRadius, std::unique_ptr<Bmad::Wall3dDRadius>>(
      m, "Wall3dDRadius", "Fortran routine wall3d_d_radius return value")
      .def_readonly("perp", &Bmad::Wall3dDRadius::perp)
      .def_readonly("ix_section", &Bmad::Wall3dDRadius::ix_section)
      .def_readonly("no_wall_here", &Bmad::Wall3dDRadius::no_wall_here)
      .def_readonly("origin", &Bmad::Wall3dDRadius::origin)
      .def_readonly("radius_wall", &Bmad::Wall3dDRadius::radius_wall)
      .def_readonly("err_flag", &Bmad::Wall3dDRadius::err_flag)
      .def_readonly("d_radius", &Bmad::Wall3dDRadius::d_radius)
      .def("__len__", [](const Bmad::Wall3dDRadius&) { return 7; })
      .def(
          "__getitem__",
          [](const Bmad::Wall3dDRadius& s, size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.perp);
            if (i == 1)
              return py::cast(s.ix_section);
            if (i == 2)
              return py::cast(s.no_wall_here);
            if (i == 3)
              return py::cast(s.origin);
            if (i == 4)
              return py::cast(s.radius_wall);
            if (i == 5)
              return py::cast(s.err_flag);
            if (i == 6)
              return py::cast(s.d_radius);
            return py::none();
          });
  m.def(
      "pointer_to_wall3d",
      &Bmad::pointer_to_wall3d,
      py::arg("ele"),
      py::arg("ix_wall") = py::none(),
      R"""(Function to return a pointer to a wall3d structure associated

with a given lattice element.

Parameters
----------
ele : EleStruct
    lattice element.
ix_wall : int, optional
    index in wall3d(:) array. Default is 1.

Return value is a dictionary containing values below.


Returns
-------
wall3d : Wall3DStruct
    Pointer to the associated wall structure. Will be nullified if there is no associated wall.
ds_offset : float
    Element offset: s(beginning of ele) - s(beginning of wall3d)
is_branch_wall : bool
    Set True if wall3d points to branch.wall3d.
)""");
  py::class_<Bmad::PointerToWall3d, std::unique_ptr<Bmad::PointerToWall3d>>(
      m, "PointerToWall3d", "Fortran routine pointer_to_wall3d return value")
      .def_readonly("ds_offset", &Bmad::PointerToWall3d::ds_offset)
      .def_readonly("is_branch_wall", &Bmad::PointerToWall3d::is_branch_wall)
      .def_readonly("wall3d", &Bmad::PointerToWall3d::wall3d)
      .def("__len__", [](const Bmad::PointerToWall3d&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::PointerToWall3d& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ds_offset);
            if (i == 1)
              return py::cast(s.is_branch_wall);
            if (i == 2)
              return py::cast(s.wall3d);
            return py::none();
          });
  m.def(
      "wall3d_to_position",
      &Bmad::wall3d_to_position,
      py::arg("orbit"),
      py::arg("ele"),
      R"""(Routine to return the suitable postion to be used in calling wall3d_d_radius

This routine assumes that if in a patch the coordinates of orbit are with respect
to the downstream end if orbit%direction*orbit%time_dir = 1 and vice versa.

Parameters
----------
orbit : CoordStruct
    Particle position.
ele : EleStruct
    Element particle is in.

Returns
-------
position : float
    Position used in wall3d_d_radius call.
)""");
  m.def(
      "create_concatenated_wall3d",
      &python_create_concatenated_wall3d,
      py::arg("lat"),
      py::arg("err"),
      R"""(Routine to concatinate lat%branch(i)ele(:)%wall3d%section(:) arrays into

one lat%branch(i)%wall3d%section(:) array.
Exceptions: capillary and aperture elements do not have their walls included.
Module needed:
use wall3d_mod

Parameters
----------
lat : LatStruct
    lattice
    This parameter is an input/output and is modified in-place. As an output: Lattice

Returns
-------
err_flag : bool
    Set True if there is an error, false otherwise.
)""");
  py::class_<
      PyCreateConcatenatedWall3d,
      std::unique_ptr<PyCreateConcatenatedWall3d>>(
      m,
      "CreateConcatenatedWall3d",
      "Fortran routine create_concatenated_wall3d return value")
      .def_readonly("err", &PyCreateConcatenatedWall3d::err)
      .def("__len__", [](const PyCreateConcatenatedWall3d&) { return 1; })
      .def(
          "__getitem__",
          [](const PyCreateConcatenatedWall3d& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "mark_patch_regions",
      &Bmad::mark_patch_regions,
      py::arg("branch"),
      R"""(Routine to mark which regions in a wall3d structure contain patch elements.

This routine should be called by any routine that creates a beam chamber wall.

Parameters
----------
branch : BranchStruct
    Lattice branch with .wall3d beam chamber wall.
    This parameter is an input/output and is modified in-place. As an output: Lattice branch with
    .wall3d.section(i).patch_in_region marked.
)""");
  m.def(
      "angle_between_polars",
      &python_angle_between_polars,
      py::arg("polar1"),
      py::arg("polar2"),
      py::arg("angle"),
      R"""(No docstring available

Parameters
----------
polar1 : 
    (spin_polar_struct)
polar2 : 
    (spin_polar_struct)
angle : 
)""");
  py::class_<PyAngleBetweenPolars, std::unique_ptr<PyAngleBetweenPolars>>(
      m,
      "AngleBetweenPolars",
      "Fortran routine angle_between_polars return value")
      .def_readonly("angle", &PyAngleBetweenPolars::angle)
      .def("__len__", [](const PyAngleBetweenPolars&) { return 1; })
      .def(
          "__getitem__",
          [](const PyAngleBetweenPolars& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.angle);
            return py::none();
          });
  m.def(
      "bbi_kick",
      &Bmad::bbi_kick,
      py::arg("x"),
      py::arg("y"),
      py::arg("sigma"),
      R"""(No docstring available

Parameters
----------
x : float
    X coordinate.
y : float
    Y coordinate.
sigma : float
    Beam (x,y) sigmas.
nk : float
    Normalized, dimensionless kick component. In terms of the the actual kick: nk = [kick_x / (xi_x * sigma_x
    / beta_x), kick_y / (xi_y * sigma_y / beta_y) nk = -4 * pi * [x/sigma_x, y/sigma_y] in the linear region
dnk : float
    derivatives of nk. EG: dnk(2,1) = dnk(2)/dy Note: xi_x = beta_x * bbi_const / sig_x     ! Horizontal tune
    shift parameter xi_y = beta_y * bbi_const / sig_y     ! Vertical   tune shift parameter where bbi_const =
    N_particles_bunch * r_e / (2 * pi * gamma * (sig_x + sig_y)) And the tune shifts are: dQ_x = xi_x = beta_x
    * bbi_const / sig_x dQ_y = xi_y = beta_y * bbi_const / sig_y In the calling routine, the formulas for
    computing the actual kicks, kick_x and kick_y, should be: kick_x = bbi_const * nk(1) ~ -4 * pi * bbi_const
    * x / sigma_x                        [linear region] ~ -2 * N_p * r_e * x / (gamma * sig_x * (sig_x +
    sig_y))   [linear region] ~ -2 * N_p * r_e * x / (gamma * (x^2 + y^2))               [far from beam]
    kick_y = bbi_const * nk(2) ~ -4 * pi * bbi_const * y / sigma_y                        [linear region] ~ -2
    * N_p * r_e * y / (gamma * sig_y * (sig_x + sig_y))   [linear region] ~ -2 * N_p * r_e * y / (gamma * (x^2
    + y^2))               [far from beam] For the beam-ion kick, assuming the ion velocity is neglegeble, the
    formulas are: kick_x = ion_const * nk(1) ~ -4 * pi * ion_const * x / sigma_x
    [linear region] ~ -2 * N_p * r_p * c_light * x / (sig_x * (sig_x + sig_y) * A)  [linear region] ~ -2 * N_p
    * r_p * c_light * x / ((x^2 + y^2) * A)              [far from beam] kick_y = ion_const * nk(2) ~ -4 * pi
    * ion_const * y / sigma_y                             [linear region] ~ -2 * N_p * r_p * c_light * y /
    (sig_y * (sig_x + sig_y) * A)  [linear region] ~ -2 * N_p * r_p * c_light * y / ((x^2 + y^2) * A)
    [far from beam] ion_const = N_particles_bunch * r_p * c_light / (2 * pi * (sig_x + sig_y) * A) A = Mass of
    ion in AMU.
)""");
  py::class_<Bmad::BbiKick, std::unique_ptr<Bmad::BbiKick>>(
      m, "BbiKick", "Fortran routine bbi_kick return value")
      .def_readonly("nk", &Bmad::BbiKick::nk)
      .def_readonly("dnk", &Bmad::BbiKick::dnk)
      .def("__len__", [](const Bmad::BbiKick&) { return 2; })
      .def("__getitem__", [](const Bmad::BbiKick& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.nk);
        if (i == 1)
          return py::cast(s.dnk);
        return py::none();
      });
  m.def(
      "bmad_parser",
      &Bmad::bmad_parser,
      py::arg("lat_file"),
      py::arg("make_mats6") = py::none(),
      py::arg("use_line") = py::none(),
      R"""(No docstring available

Parameters
----------
lat_file : unknown
    Name of the input file.
lat : LatStruct
    Lat structure. See bmad_struct.f90 for more details. .ele(:).mat6      -- This is computed assuming an on-
    axis orbit if make_mats6 = T.
make_mats6 : bool, optional
    Compute the 6x6 transport matrices for the Elements? Default is True. Do not set False unless you know
    what you are doing.
digested_read_ok : bool
    Set True if the digested file was successfully read. False otherwise.
use_line : unknown, optional
    If present and not blank, override the use statement in the lattice file and use use_line instead.
err_flag : bool
    Set true if there is an error, false otherwise. Note: err_flag does *not* include errors in lat_make_mat6
    since if there is a match element, there is an error raised since the Twiss parameters have not been set
    but this is expected.
parse_lat : LatStruct
    List of elements used to construct the lattice. Useful if bmad_parser2 will be called. See bmad_parser2
    documentation.
)""");
  py::class_<Bmad::BmadParser, std::unique_ptr<Bmad::BmadParser>>(
      m, "BmadParser", "Fortran routine bmad_parser return value")
      .def_readonly("lat", &Bmad::BmadParser::lat)
      .def_readonly("digested_read_ok", &Bmad::BmadParser::digested_read_ok)
      .def_readonly("err_flag", &Bmad::BmadParser::err_flag)
      .def_readonly("parse_lat", &Bmad::BmadParser::parse_lat)
      .def("__len__", [](const Bmad::BmadParser&) { return 4; })
      .def(
          "__getitem__", [](const Bmad::BmadParser& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.lat);
            if (i == 1)
              return py::cast(s.digested_read_ok);
            if (i == 2)
              return py::cast(s.err_flag);
            if (i == 3)
              return py::cast(s.parse_lat);
            return py::none();
          });
  m.def(
      "bmad_parser2",
      &python_bmad_parser2,
      py::arg("lat_file"),
      py::arg("lat"),
      py::arg("orbit") = py::none(),
      py::arg("make_mats6") = py::none(),
      py::arg("err_flag") = py::none(),
      py::arg("parse_lat") = py::none(),
      R"""(No docstring available

Parameters
----------
lat_file : unknown
    Input file name.
lat : LatStruct
    lattice with existing layout.
    This parameter is an input/output and is modified in-place. As an output: lattice with modifications.
orbit : CoordStruct, optional
    closed orbit for when bmad_parser2 calls lat_make_mat6
make_mats6 : bool, optional
    Make the 6x6 transport matrices for then Elements? Default is True.
err_flag : 
parse_lat : LatStruct, optional
    Used by bmad_parser to pass to bmad_parser2 a list of elements that were defined in the lattice file but
    not used. This is useful in preventing errors being generated if group/overlay elements definded by
    lat_file refer to unused slaves in parse_lat.
)""");
  py::class_<PyBmadParser2, std::unique_ptr<PyBmadParser2>>(
      m, "BmadParser2", "Fortran routine bmad_parser2 return value")
      .def_readonly("err_flag", &PyBmadParser2::err_flag)
      .def("__len__", [](const PyBmadParser2&) { return 1; })
      .def("__getitem__", [](const PyBmadParser2& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "remove_dead_from_bunch",
      &Bmad::remove_dead_from_bunch,
      py::arg("bunch_in"),
      R"""(No docstring available

Parameters
----------
bunch_in : BunchStruct
    Input bunch with alive and dead particles.
bunch_out : BunchStruct
    Output bunch with only alive and pre_born particles. Note: bunch_out can be the same actual argument as
    bunch_in.
)""");
  m.def(
      "check_controller_controls",
      &Bmad::check_controller_controls,
      py::arg("ele_key"),
      py::arg("contrl"),
      py::arg("name"),
      R"""(No docstring available

Parameters
----------
ele_key : int
    Element type. overlay$, etc.
contrl : ControlStruct
    control info. 1 element for each slave.
name : unknown
    Lord name. Used for error reporting.
err : bool
    Set true if there is a problem. False otherwise.
)""");
  m.def(
      "create_field_overlap",
      &Bmad::create_field_overlap,
      py::arg("lat"),
      py::arg("lord_name"),
      py::arg("slave_name"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lattice
lord_name : unknown
    Name of the element with a field extending beyound it's bounds.
slave_name : unknown
    Name of the element the lord's field overlaps.
err_flag : bool
    Set true if there is a problem (like no elements found).
)""");
  m.def(
      "create_girder",
      &python_create_girder,
      py::arg("lat"),
      py::arg("ix_girder"),
      py::arg("contrl"),
      py::arg("girder_info"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Lat to modify.
    This parameter is an input/output and is modified in-place. As an output: Modified lattice.
ix_girder : int
    Index of girder element.
contrl : ControlStruct
    Array of elements that are supported by the girder. slave.ix_ele       -- Integer: Index in
    lat.branch().ele() of element controlled. .ix_branch      -- Integer: Branch index.
girder_info : EleStruct
    Element containing attributes to be transfered to the Girder element: girder_info.name girder_info.alias
    girder_info.descrip girder_info.value(:)
err_flag : 
)""");
  py::class_<PyCreateGirder, std::unique_ptr<PyCreateGirder>>(
      m, "CreateGirder", "Fortran routine create_girder return value")
      .def_readonly("err_flag", &PyCreateGirder::err_flag)
      .def("__len__", [](const PyCreateGirder&) { return 1; })
      .def("__getitem__", [](const PyCreateGirder& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "create_group",
      &Bmad::create_group,
      py::arg("lord"),
      py::arg("contrl"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
lord : EleStruct
    Group element. .control.type
    This parameter is an input/output and is modified in-place. As an output: Modified group elment
contrl : ControlStruct
    control info. 1 element for each slave. .stack         -- Arithmetic expression stack for evaluating the
    controlled parameter value. .y_knot(:)     -- Knot points for spline interpolation. .slave         --
    Integer: Index to lat.branch().ele() of element controlled. .attribute     -- character(40): Attribute
    name.
err : bool
    Set True if an attribute is not free to be controlled.
)""");
  m.def(
      "create_overlay",
      &Bmad::create_overlay,
      py::arg("lord"),
      py::arg("contrl"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
lord : EleStruct
    Overlay element. .control.type
    This parameter is an input/output and is modified in-place. As an output: Modified overlay elment
contrl : ControlStruct
    control info. 1 element for each slave. .stack(:)      -- Arithmetic expression stack for evaluating the
    controlled parameter value. .y_knot(:)     -- Knot points for spline interpolation. slave.ix_ele   --
    Index of element to control .ix_branch     -- Index of branch element belongs to. .attribute     -- name
    of attribute to be controlled
err : bool
    Set True if an attribute is not free to be controlled.
)""");
  m.def(
      "create_ramper",
      &Bmad::create_ramper,
      py::arg("lord"),
      py::arg("contrl"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
lord : EleStruct
    Ramper element. .control.type
    This parameter is an input/output and is modified in-place. As an output: Modified ramper elment
contrl : ControlStruct
    control info. 1 element for each slave. .stack(:)         -- Arithmetic expression stack for evaluating
    the controlled parameter value. .y_knot(:)        -- Knot points for spline or linear interpolation.
    .attribute        -- name of attribute to be controlled.
err : bool
    Set True if an attribute is not free to be controlled.
)""");
  m.def(
      "crystal_attribute_bookkeeper",
      &Bmad::crystal_attribute_bookkeeper,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Crystal element. .value(bragg_angle_in$) .value(bragg_angle_out$) .value(tilt_corr$) ... etc.
)""");
  m.def(
      "ele_to_spin_taylor",
      &Bmad::ele_to_spin_taylor,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orb0"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
    This parameter is an input/output and is modified in-place. As an output: Element with spin map.
param : unknown
    Branch parameters.
orb0 : CoordStruct
    Starting ref coords.
)""");
  m.def(
      "ele_to_taylor",
      &Bmad::ele_to_taylor,
      py::arg("ele"),
      py::arg("orb0") = py::none(),
      py::arg("taylor_map_includes_offsets") = py::none(),
      py::arg("include_damping") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : ElementStruct
    Element to construct map for.
orb0 : CoordStruct, optional
    Starting coords around which the Taylor map is evaluated. Default is the zero orbit.
taylor_map_includes_offsets : bool, optional
    If present then value overrides ele.taylor_map_includes_offsets. -- Logical, optional: If present then
    value overrides ele.taylor_map_includes_offsets.
include_damping : bool, optional
    Sets if radiation damping is included. Default is what is set in ptc_private.base_state.
orbital_taylor : TaylorStruct
    Orbital taylor map. If not present then the map is put in ele.taylor.
spin_taylor : TaylorStruct
    Spin taylor map. If not present then the map is put in ele.spin_taylor.
)""");
  py::class_<Bmad::EleToTaylor, std::unique_ptr<Bmad::EleToTaylor>>(
      m, "EleToTaylor", "Fortran routine ele_to_taylor return value")
      .def_readonly("orbital_taylor", &Bmad::EleToTaylor::orbital_taylor)
      .def_readonly("spin_taylor", &Bmad::EleToTaylor::spin_taylor)
      .def("__len__", [](const Bmad::EleToTaylor&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::EleToTaylor& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.orbital_taylor);
            if (i == 1)
              return py::cast(s.spin_taylor);
            return py::none();
          });
  m.def(
      "gradient_shift_sr_wake",
      &python_gradient_shift_sr_wake,
      py::arg("ele"),
      py::arg("param"),
      py::arg("grad_shift"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lcavity element.
param : LatParamStruct
    Lattice parameters .n_part        -- Number of particles in a bunch .particle      -- Type of particle
grad_shift : 
)""");
  py::class_<PyGradientShiftSrWake, std::unique_ptr<PyGradientShiftSrWake>>(
      m,
      "GradientShiftSrWake",
      "Fortran routine gradient_shift_sr_wake return value")
      .def_readonly("grad_shift", &PyGradientShiftSrWake::grad_shift)
      .def("__len__", [](const PyGradientShiftSrWake&) { return 1; })
      .def(
          "__getitem__",
          [](const PyGradientShiftSrWake& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.grad_shift);
            return py::none();
          });
  m.def(
      "hdf5_write_beam",
      &python_hdf5_write_beam,
      py::arg("file_name"),
      py::arg("bunches"),
      py::arg("append"),
      py::arg("error"),
      py::arg("lat") = py::none(),
      py::arg("alive_only") = py::none(),
      R"""(No docstring available

Parameters
----------
file_name : 
bunches : 
append : 
error : 
lat : 
alive_only : 
)""");
  py::class_<PyHdf5WriteBeam, std::unique_ptr<PyHdf5WriteBeam>>(
      m, "Hdf5WriteBeam", "Fortran routine hdf5_write_beam return value")
      .def_readonly("file_name", &PyHdf5WriteBeam::file_name)
      .def_readonly("append", &PyHdf5WriteBeam::append)
      .def_readonly("error", &PyHdf5WriteBeam::error)
      .def_readonly("alive_only", &PyHdf5WriteBeam::alive_only)
      .def("__len__", [](const PyHdf5WriteBeam&) { return 4; })
      .def("__getitem__", [](const PyHdf5WriteBeam& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.file_name);
        if (i == 1)
          return py::cast(s.append);
        if (i == 2)
          return py::cast(s.error);
        if (i == 3)
          return py::cast(s.alive_only);
        return py::none();
      });
  m.def(
      "hdf5_write_grid_field",
      &python_hdf5_write_grid_field,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("g_field"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
file_name : 
ele : 
g_field : 
err_flag : 
)""");
  py::class_<PyHdf5WriteGridField, std::unique_ptr<PyHdf5WriteGridField>>(
      m,
      "Hdf5WriteGridField",
      "Fortran routine hdf5_write_grid_field return value")
      .def_readonly("file_name", &PyHdf5WriteGridField::file_name)
      .def_readonly("err_flag", &PyHdf5WriteGridField::err_flag)
      .def("__len__", [](const PyHdf5WriteGridField&) { return 2; })
      .def(
          "__getitem__",
          [](const PyHdf5WriteGridField& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.file_name);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "init_photon_from_a_photon_init_ele",
      &Bmad::init_photon_from_a_photon_init_ele,
      py::arg("ele"),
      py::arg("param"),
      py::arg("random_on") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    patch element.
param : 
    lat_param_struct.
orbit : CoordStruct
    Output photon coords.
random_on : bool, optional
    : Default is True. If False then use zero for all random numbers needed in the calc.
)""");
  m.def(
      "init_bmad_parser_common",
      &Bmad::init_bmad_parser_common,
      py::arg("lat") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : 
)""");
  m.def(
      "init_custom",
      &Bmad::init_custom,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : 
)""");
  m.def(
      "init_wake",
      &Bmad::init_wake,
      py::arg("n_sr_long"),
      py::arg("n_sr_trans"),
      py::arg("n_sr_z"),
      py::arg("n_lr_mode"),
      py::arg("always_allocate") = py::none(),
      R"""(No docstring available

Parameters
----------
wake : WakeStruct
    Initialized structure.
n_sr_long : int
    Number of terms: wake.sr.long.
n_sr_trans : int
    Number of terms: wake.sr.trans.
n_sr_z : int
    Number of terms: wake.sr.z.
n_lr_mode : int
    Number of terms: wake.lr.mode.
always_allocate : bool, optional
    If present and True then allways allocate wake even if n_lr_mode, etc. are all 0. Default is False.
)""");
  m.def(
      "kill_ptc_layouts",
      &Bmad::kill_ptc_layouts,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Bmad lattice with associated layouts.
)""");
  m.def(
      "lat_to_ptc_layout",
      &Bmad::lat_to_ptc_layout,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Input lattice lat.branch(:).ptc              -- Pointers to generated layouts.
    lat.branch(:).ele(:).ptc_fibre -- Pointer to PTC fibres
)""");
  m.def(
      "linear_to_spin_taylor",
      &Bmad::linear_to_spin_taylor,
      py::arg("q_map"),
      R"""(No docstring available

Parameters
----------
q_map : float
    Linear quaternion map.
spin_taylor : TaylorStruct
    Taylor map
)""");
  m.def(
      "map1_inverse",
      &Bmad::map1_inverse,
      py::arg("map1"),
      py::arg("inv_map1"),
      R"""(No docstring available

Parameters
----------
map1 : SpinOrbitMap1Struct
    Input map.
inv_map1 : 
)""");
  m.def(
      "map1_make_unit",
      &Bmad::map1_make_unit,
      R"""(No docstring available

Parameters
----------
map1 : SpinOrbitMap1Struct
    Unit map.
)""");
  m.def(
      "make_mat6_bmad_photon",
      &Bmad::make_mat6_bmad_photon,
      py::arg("ele"),
      py::arg("param"),
      py::arg("start_orb"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with transfer matrix
    This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
param : LatParamStruct
    Parameters are needed for some elements.
start_orb : CoordStruct
    Coordinates at the beginning of element.
end_orb : CoordStruct
    Coordinates at the end of element.
err : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::MakeMat6BmadPhoton,
      std::unique_ptr<Bmad::MakeMat6BmadPhoton>>(
      m,
      "MakeMat6BmadPhoton",
      "Fortran routine make_mat6_bmad_photon return value")
      .def_readonly("end_orb", &Bmad::MakeMat6BmadPhoton::end_orb)
      .def_readonly("err", &Bmad::MakeMat6BmadPhoton::err)
      .def("__len__", [](const Bmad::MakeMat6BmadPhoton&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::MakeMat6BmadPhoton& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_orb);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "multipole_spin_tracking",
      &Bmad::multipole_spin_tracking,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
param : 
    Lat_param_struct
orbit : CoordStruct
    Particle coordinates.
)""");
  m.def(
      "offset_photon",
      &Bmad::offset_photon,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("set"),
      py::arg("offset_position_only") = py::none(),
      py::arg("rot_mat") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
orbit : CoordStruct
    Coordinates of the particle.
    This parameter is an input/output and is modified in-place. As an output: Coordinates of particle.
set : bool
    T (= set$)   -> Translate from lab coords to element coords. F (= unset$) -> Translate from element coords
    to lab coords.
offset_position_only : bool, optional
    If present and True, only offset the position coordinates. -- Logical, optional: If present and True, only
    offset the position coordinates.
rot_mat : float, optional
    Rotation matrix from starting coords to ending coords.
)""");
  m.def(
      "converter_distribution_parser",
      &Bmad::converter_distribution_parser,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Converter element.
    This parameter is an input/output and is modified in-place. As an output: Converter element with
    .converter field set.
delim : unknown
    Ending delimitor.
delim_found : bool
    Has a delimitor been found?
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Bmad::ConverterDistributionParser,
      std::unique_ptr<Bmad::ConverterDistributionParser>>(
      m,
      "ConverterDistributionParser",
      "Fortran routine converter_distribution_parser return value")
      .def_readonly("delim", &Bmad::ConverterDistributionParser::delim)
      .def_readonly(
          "delim_found", &Bmad::ConverterDistributionParser::delim_found)
      .def_readonly("err_flag", &Bmad::ConverterDistributionParser::err_flag)
      .def(
          "__len__", [](const Bmad::ConverterDistributionParser&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ConverterDistributionParser& s,
             size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "polar_to_spinor",
      &Bmad::polar_to_spinor,
      py::arg("polar"),
      py::arg("spinor"),
      R"""(No docstring available

Parameters
----------
polar : SpinPolarStruct
    includes polar phase
spinor : 
)""");
  m.def(
      "polar_to_vec",
      &Bmad::polar_to_vec,
      py::arg("polar"),
      py::arg("vec"),
      R"""(No docstring available

Parameters
----------
polar : 
    Spin_polar_struct
vec : 
)""");
  m.def(
      "ptc_bookkeeper",
      &Bmad::ptc_bookkeeper,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Bmad lattice.
)""");
  m.def(
      "ptc_ran_seed_put",
      &Bmad::ptc_ran_seed_put,
      py::arg("iseed"),
      R"""(No docstring available

Parameters
----------
iseed : int
    0 -> Use system clock.
)""");
  m.def(
      "ptc_set_rf_state_for_c_normal",
      &Bmad::ptc_set_rf_state_for_c_normal,
      py::arg("nocavity"),
      R"""(No docstring available

Parameters
----------
nocavity : bool
    True -> RF is off and vice versa.
)""");
  m.def(
      "ptc_transfer_map_with_spin",
      &Bmad::ptc_transfer_map_with_spin,
      py::arg("branch"),
      py::arg("t_map"),
      py::arg("s_map"),
      py::arg("orb0"),
      py::arg("ix1") = py::none(),
      py::arg("ix2") = py::none(),
      py::arg("one_turn") = py::none(),
      py::arg("unit_start") = py::none(),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    Lattice branch used in the calculation.
t_map : TaylorStruct
    Initial orbital map (used when unit_start = False)
    This parameter is an input/output and is modified in-place. As an output: Orbital transfer map.
s_map : TaylorStruct
    Initial spin map (used when unit_start = False)
    This parameter is an input/output and is modified in-place. As an output: Quaternion spin transfer map.
orb0 : CoordStruct
    Initial orbit around which the map is made.
err_flag : bool
    Set True if problem like number overflow, etc.
ix1 : int, optional
    Element start index for the calculation. Default is 0.
ix2 : int, optional
    Element end index for the calculation. Default is branch.n_ele_track.
one_turn : bool, optional
    If present and True, and if ix1 = ix2, and the lattice is circular, then construct the one-turn map from
    ix1 back to ix1. Default = False.
unit_start : bool, optional
    If present and False then t_map will be used as the starting map instead of the unit map. Default = True
)""");
  m.def(
      "reallocate_beam",
      &python_reallocate_beam,
      py::arg("beam"),
      py::arg("n_bunch"),
      py::arg("n_particle") = py::none(),
      py::arg("extend") = py::none(),
      R"""(No docstring available

Parameters
----------
beam : BeamStruct
    Beam bunches are saved if save = True.
    This parameter is an input/output and is modified in-place. As an output: Allocated beam_struct structure.
n_bunch : int
    Number of bunches.
n_particle : int, optional
    Number of particles. Must be non-negative. If save = True then the number of particles in existing bunches
    will not be touched. If not present, beam.bunch(i).particle(:) will be in an undefined state.
extend : 
)""");
  py::class_<PyReallocateBeam, std::unique_ptr<PyReallocateBeam>>(
      m, "ReallocateBeam", "Fortran routine reallocate_beam return value")
      .def_readonly("extend", &PyReallocateBeam::extend)
      .def("__len__", [](const PyReallocateBeam&) { return 1; })
      .def(
          "__getitem__", [](const PyReallocateBeam& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.extend);
            return py::none();
          });
  m.def(
      "reallocate_bunch",
      &Bmad::reallocate_bunch,
      py::arg("n_particle"),
      py::arg("save") = py::none(),
      R"""(No docstring available

Parameters
----------
bunch : BunchStruct
    Allocated bunch_struct structure.
n_particle : int
    Number of particles. Must be non-negative.
save : bool, optional
    If present and True then save the old bunch info.
)""");
  m.def(
      "rotate_for_curved_surface",
      &Bmad::rotate_for_curved_surface,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("set"),
      py::arg("rot_mat"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    reflecting element
orbit : CoordStruct
    Photon position.
set : bool
    True -> Transform body coords to local curved body coords. False -> Transform local curved body to body
    coords.
rot_mat : float
    When set = False, rotation matrix calculated from previous call with set = True.
    This parameter is an input/output and is modified in-place. As an output: When set = True, calculated
    rotation matrix.
)""");
  m.def(
      "rotate_spin",
      &Bmad::rotate_spin,
      py::arg("rot_vec"),
      py::arg("spin"),
      R"""(No docstring available

Parameters
----------
rot_vec : float
    Rotation axis. Magnitude of rot_vec is the rotation angle.
spin : float
    Initial coords.
    This parameter is an input/output and is modified in-place. As an output: Final coords.
qrot : float
    : rotation quaternion.
)""");
  m.def(
      "rotate_spin_a_step",
      &Bmad::rotate_spin_a_step,
      py::arg("orbit"),
      py::arg("field"),
      py::arg("ele"),
      py::arg("ds"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Initial orbit.
    This parameter is an input/output and is modified in-place. As an output: Orbit with rotated spin
field : EmFieldStruct
    EM Field
ele : 
    ele_struct, Element being tracked through.
ds : float
    Longitudinal step in element body frame.
)""");
  m.def(
      "rotate_spin_given_field",
      &Bmad::rotate_spin_given_field,
      py::arg("orbit"),
      py::arg("sign_z_vel"),
      py::arg("BL") = py::none(),
      py::arg("EL") = py::none(),
      py::arg("qrot") = py::none(),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Initial orbit.
    This parameter is an input/output and is modified in-place. As an output: Orbit with rotated spin
sign_z_vel : int
    +/- 1. Sign of direction of travel relative to the element.
BL : float, optional
    Integrated field strength. Assumed zero if not present.
EL : float, optional
    Integrated field strength. Assumed zero if not present.
qrot : float, optional
    Initial rotation quaternion.
    This parameter is an input/output and is modified in-place. As an output: Rotation quaternion with
    rotation due to the field added in.
)""");
  m.def(
      "save_a_beam_step",
      &Bmad::save_a_beam_step,
      py::arg("ele"),
      py::arg("beam"),
      py::arg("bunch_tracks") = py::none(),
      py::arg("s_body") = py::none(),
      py::arg("is_time_coords") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element being tracked through.
beam : BeamStruct
    Bunches in the beam whose parameters are to be saved.
bunch_tracks : BunchTrackStruct, optional
    Track with current bunch info appended on. This routine does nothing if this argument is not present.
s_body : float, optional
    Body s-position from beginning of element.
is_time_coords : bool, optional
    Default is False. If True, input beam is using time coordinates in which case there will be a conversion
    to s-coords before bunch_params are computed. Ouput:
)""");
  m.def(
      "save_a_bunch_step",
      &Bmad::save_a_bunch_step,
      py::arg("ele"),
      py::arg("bunch"),
      py::arg("bunch_track") = py::none(),
      py::arg("s_body") = py::none(),
      py::arg("is_time_coords") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element being tracked through.
bunch : BunchStruct
    Bunch whose parameters are to be saved.
bunch_track : BunchTrackStruct, optional
    Track with current bunch info appended on. This routine does nothing if this argument is not present.
s_body : float, optional
    Body s-position from beginning of element.
is_time_coords : bool, optional
    Default is False. If True, input bunch is using time coordinates in which case there will be a conversion
    to s-coords before bunch_params are computed. Ouput:
)""");
  m.def(
      "set_emit_from_beam_init",
      &Bmad::set_emit_from_beam_init,
      py::arg("beam_init_in"),
      py::arg("ele"),
      py::arg("species"),
      py::arg("modes") = py::none(),
      py::arg("err_flag") = py::none(),
      py::arg("beam_init_set"),
      R"""(No docstring available

Parameters
----------
beam_init_in : BeamInitStruct
    Input parameters
ele : EleStruct
species : int
    Beam particle species.
modes : NormalModesStruct, optional
    Normal mode parameters. Used if stuff like beam_init_in.a_emit set negative. Ouput:
err_flag : bool, optional
    Set true if there is an error. False otherwise.
beam_init_set : 
)""");
  m.def(
      "set_ptc",
      &Bmad::set_ptc,
      py::arg("e_tot") = py::none(),
      py::arg("particle") = py::none(),
      py::arg("taylor_order") = py::none(),
      py::arg("integ_order") = py::none(),
      py::arg("n_step") = py::none(),
      py::arg("no_cavity") = py::none(),
      py::arg("force_init") = py::none(),
      R"""(import

implicit none
type (ele_struct), target :: ele
type (coord_struct) orbit
real(rp) rf_time
logical reference_active_edge
end subroutine

Parameters
----------
e_tot : float, optional
    Energy in eV.
particle : int, optional
    Type of particle: electron$, proton$, etc.
taylor_order : int, optional
    Maximum order of the taylor polynomials. 0 => Use default.
integ_order : int, optional
    Default Order for the drift-kick-drift sympletic integrator. Possibilities are: 2, 4, or 6 Default = 2
n_step : int, optional
    Default Number of integration steps. Default = 1
no_cavity : bool, optional
    No RF Cavity exists? Default = False. Corresponds to the nocavity option of the PTC init routine.
    no_cavity = .true. will turn any cavity into a drift.
force_init : bool, optional
    If present and True then force a PTC init.
)""");
  m.def(
      "set_ptc_base_state",
      &Bmad::set_ptc_base_state,
      py::arg("component"),
      py::arg("set_val"),
      R"""(No docstring available

Parameters
----------
component : unknown
    Name of component. "TOTALPATH", "SPIN", "NOCAVITY", "TIME", etc. See the PTC internal_state structure for
    component names.
set_val : bool
    Value to set to. For TOTALPATH, True => 1, False => 0.
old_val : bool
    Old value.
)""");
  m.def(
      "set_ele_defaults",
      &Bmad::set_ele_defaults,
      py::arg("ele"),
      py::arg("do_allocate") = py::none(),
      R"""(import

implicit none
type (lat_struct) lat
type (coord_struct), optional :: orb(0:)
integer key
logical on_switch
end subroutine

Parameters
----------
ele : EleStruct
    Element to init. .key          -- Type of element.
    This parameter is an input/output and is modified in-place. As an output: Initialized element.
do_allocate : bool, optional
    Do default allocation of element components? Default is True.
)""");
  m.def(
      "spin_dn_dpz_from_mat8",
      &Bmad::spin_dn_dpz_from_mat8,
      py::arg("mat_1turn"),
      py::arg("dn_dpz_partial") = py::none(),
      py::arg("dn_dpz"),
      R"""(No docstring available

Parameters
----------
mat_1turn : float
    Spin-orbital matrix.
dn_dpz_partial : float, optional
    dn_dpz_partial(i,:) is dn_dpz with only one osccilation mode "excited". So dn_dpz_partial(1,:) represents
    a-mode excitation, etc.
error : bool
    Set True if there is an error. False otherwise.
dn_dpz : 
)""");
  m.def(
      "spin_dn_dpz_from_qmap",
      &Bmad::spin_dn_dpz_from_qmap,
      py::arg("orb_mat"),
      py::arg("q_map"),
      py::arg("dn_dpz_partial"),
      py::arg("dn_dpz_partial2"),
      py::arg("n0") = py::none(),
      py::arg("dn_dpz"),
      R"""(No docstring available

Parameters
----------
orb_mat : float
    1-turn orbital matrix.
q_map : float
    1-turn spin linear quaternion map.
dn_dpz_partial : float
    ) is dn_dpz with only one osccilation mode "excited". So dn_dpz_partial(1,:) represents a-mode excitation,
    etc.
dn_dpz_partial2 : float
    ) is dn_dpz with only two osccilation modes "excited". So dn_dpz_partial(1,:) represents b-mode and c-mode
    excitation without the a-mode, etc.
error : bool
    Set True if there is an error. False otherwise.
n0 : float
    3,0).
dn_dpz : 
)""");
  m.def(
      "spin_map1_normalize",
      &Bmad::spin_map1_normalize,
      py::arg("spin1"),
      R"""(No docstring available

Parameters
----------
spin1 : float
    Unnormalized spin map.
    This parameter is an input/output and is modified in-place. As an output: Normalized spin map.
)""");
  m.def(
      "spin_mat_to_eigen",
      &Bmad::spin_mat_to_eigen,
      py::arg("orb_mat"),
      py::arg("spin_map"),
      R"""(No docstring available

Parameters
----------
orb_mat : float
    Orbital matrix.
spin_map : float
    Quaternion 0th & 1st order map.
orb_eval : complex
    Eigenvalues.
orb_evec : complex
    Orbital eigenvectors. orb_evec(j,:) is the j^th vector.
n0 : float
    n_0 invariant spin
spin_evec : complex
    Spin eigenvectors. spin_evec(j,:) is the j^th vector.
error : bool
    Set true if there is an error. False otherwise.
)""");
  py::class_<Bmad::SpinMatToEigen, std::unique_ptr<Bmad::SpinMatToEigen>>(
      m, "SpinMatToEigen", "Fortran routine spin_mat_to_eigen return value")
      .def_readonly("orb_eval", &Bmad::SpinMatToEigen::orb_eval)
      .def_readonly("orb_evec", &Bmad::SpinMatToEigen::orb_evec)
      .def_readonly("n0", &Bmad::SpinMatToEigen::n0)
      .def_readonly("spin_evec", &Bmad::SpinMatToEigen::spin_evec)
      .def_readonly("error", &Bmad::SpinMatToEigen::error)
      .def("__len__", [](const Bmad::SpinMatToEigen&) { return 5; })
      .def(
          "__getitem__",
          [](const Bmad::SpinMatToEigen& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.orb_eval);
            if (i == 1)
              return py::cast(s.orb_evec);
            if (i == 2)
              return py::cast(s.n0);
            if (i == 3)
              return py::cast(s.spin_evec);
            if (i == 4)
              return py::cast(s.error);
            return py::none();
          });
  m.def(
      "spin_mat8_resonance_strengths",
      &Bmad::spin_mat8_resonance_strengths,
      py::arg("orb_evec"),
      py::arg("mat8"),
      R"""(No docstring available

Parameters
----------
orb_evec : complex
    Orbital eigenvector.
mat8 : float
    Spin/orbital matrix.
xi_sum : float
    Sum resonance strength.
xi_diff : float
    Difference resonance strength.
)""");
  py::class_<
      Bmad::SpinMat8ResonanceStrengths,
      std::unique_ptr<Bmad::SpinMat8ResonanceStrengths>>(
      m,
      "SpinMat8ResonanceStrengths",
      "Fortran routine spin_mat8_resonance_strengths return value")
      .def_readonly("xi_sum", &Bmad::SpinMat8ResonanceStrengths::xi_sum)
      .def_readonly("xi_diff", &Bmad::SpinMat8ResonanceStrengths::xi_diff)
      .def("__len__", [](const Bmad::SpinMat8ResonanceStrengths&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::SpinMat8ResonanceStrengths& s,
             size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.xi_sum);
            if (i == 1)
              return py::cast(s.xi_diff);
            return py::none();
          });
  m.def(
      "spin_omega",
      &python_spin_omega,
      py::arg("field"),
      py::arg("orbit"),
      py::arg("sign_z_vel"),
      py::arg("phase_space_coords") = py::none(),
      py::arg("omega"),
      R"""(No docstring available

Parameters
----------
field : 
orbit : 
sign_z_vel : 
phase_space_coords : 
omega : 
)""");
  py::class_<PySpinOmega, std::unique_ptr<PySpinOmega>>(
      m, "SpinOmega", "Fortran routine spin_omega return value")
      .def_readonly("sign_z_vel", &PySpinOmega::sign_z_vel)
      .def_readonly("phase_space_coords", &PySpinOmega::phase_space_coords)
      .def("__len__", [](const PySpinOmega&) { return 2; })
      .def("__getitem__", [](const PySpinOmega& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.sign_z_vel);
        if (i == 1)
          return py::cast(s.phase_space_coords);
        return py::none();
      });
  m.def(
      "spin_quat_resonance_strengths",
      &Bmad::spin_quat_resonance_strengths,
      py::arg("orb_evec"),
      py::arg("spin_q"),
      R"""(No docstring available

Parameters
----------
orb_evec : complex
    Orbital eigenvector.
spin_q : float
    First order spin map.
xi_sum : float
    Sum resonance strength.
xi_diff : float
    Difference resonance strength.
)""");
  py::class_<
      Bmad::SpinQuatResonanceStrengths,
      std::unique_ptr<Bmad::SpinQuatResonanceStrengths>>(
      m,
      "SpinQuatResonanceStrengths",
      "Fortran routine spin_quat_resonance_strengths return value")
      .def_readonly("xi_sum", &Bmad::SpinQuatResonanceStrengths::xi_sum)
      .def_readonly("xi_diff", &Bmad::SpinQuatResonanceStrengths::xi_diff)
      .def("__len__", [](const Bmad::SpinQuatResonanceStrengths&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::SpinQuatResonanceStrengths& s,
             size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.xi_sum);
            if (i == 1)
              return py::cast(s.xi_diff);
            return py::none();
          });
  m.def(
      "spin_taylor_to_linear",
      &Bmad::spin_taylor_to_linear,
      py::arg("spin_taylor"),
      py::arg("normalize"),
      py::arg("dref_orb"),
      py::arg("is_on"),
      py::arg("spin_map1"),
      R"""(No docstring available

Parameters
----------
spin_taylor : TaylorStruct
    Taylor spin map.
normalize : bool
    If True, normalize the linear map.
dref_orb : float
    Change in Reference orbit: output_map1_ref - input_taylor_ref.
is_on : bool
    Is map turned on? If not spin_map1 will be the unit map.
spin_map1 : 
)""");
  m.def(
      "spinor_to_polar",
      &Bmad::spinor_to_polar,
      py::arg("spinor"),
      py::arg("polar"),
      R"""(No docstring available

Parameters
----------
spinor : complex
    Spinor
polar : 
)""");
  m.def(
      "spinor_to_vec",
      &Bmad::spinor_to_vec,
      py::arg("spinor"),
      py::arg("vec"),
      R"""(No docstring available

Parameters
----------
spinor : complex
    Spinor Output
vec : 
)""");
  m.def(
      "sprint_spin_taylor_map",
      &Bmad::sprint_spin_taylor_map,
      py::arg("ele"),
      py::arg("start_orbit") = py::none(),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element to form map for.
    This parameter is an input/output and is modified in-place. As an output: Element with map.
start_orbit : float, optional
    Reference orbit for the map. Default is zero orbit.
)""");
  m.def(
      "tilt_coords_photon",
      &Bmad::tilt_coords_photon,
      py::arg("tilt_val"),
      py::arg("coord"),
      py::arg("w_mat") = py::none(),
      R"""(No docstring available

Parameters
----------
tilt_val : float
    Tilt value (could be the roll value for a bend)
coord : float
    Coordinates of particle before rotation.
    This parameter is an input/output and is modified in-place. As an output: Coordinates of particle after
    rotation.
w_mat : float, optional
    Rotation matrix before tilt.
    This parameter is an input/output and is modified in-place. As an output: Rotation matrix after tilt.
)""");
  m.def(
      "to_surface_coords",
      &Bmad::to_surface_coords,
      py::arg("lab_orbit"),
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
lab_orbit : CoordStruct
    Photon position in laboratory coords.
ele : EleStruct
    Detector element.
surface_orbit : CoordStruct
    Photon position in element body coordinates. .state      -- Set to lost$ if orbit outside of surface (can
    happen with sperical surface).
)""");
  m.def(
      "track_a_drift_photon",
      &Bmad::track_a_drift_photon,
      py::arg("orb"),
      py::arg("length"),
      py::arg("phase_relative_to_ref"),
      R"""(No docstring available

Parameters
----------
orb : CoordStruct
    Orbit at start of the drift.
    This parameter is an input/output and is modified in-place. As an output: Orbit at end of the drift
length : float
    Longitudinal length to drift through.
phase_relative_to_ref : bool
    If true then E field phase shift is relative to ref particle. -- logical: If true then E field phase shift
    is relative to ref particle.
)""");
  m.def(
      "track_bunch_time",
      &Bmad::track_bunch_time,
      py::arg("bunch"),
      py::arg("branch"),
      py::arg("t_end"),
      py::arg("s_end"),
      py::arg("dt_step") = py::none(),
      py::arg("extra_field") = py::none(),
      R"""(No docstring available

Parameters
----------
bunch : BunchStruct
    Coordinates must be time-coords in element body frame.
    This parameter is an input/output and is modified in-place. As an output: Coordinates will be time-coords
    in element body frame.
branch : BranchStruct
    Lattice branch being tracked through.
t_end : float
    Ending time.
s_end : float
    Ending s-position.
dt_step : float, optional
    Initial step to take for each particle. Overrides bmad_com.init_ds_adaptive_tracking.
    This parameter is an input/output and is modified in-place. As an output: Next RK time step that this
    tracker would take based on the error tolerance.
extra_field : EmFieldStruct, optional
    Per particle static field to be added to the lattice element field. Eg used with space charge.
)""");
  m.def(
      "track_to_surface",
      &Bmad::track_to_surface,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element
orbit : CoordStruct
    Coordinates in the element coordinate frame
    This parameter is an input/output and is modified in-place. As an output: At surface in local surface
    coordinate frame
param : LatParamStruct
    Branch parameters.
w_surface : 
    real(rp), rotation matrix to transform to surface coords.
)""");
  m.def(
      "track1_bmad_photon",
      &Bmad::track1_bmad_photon,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
orbit : CoordStruct
    Starting position
    This parameter is an input/output and is modified in-place. As an output: End position
ele : EleStruct
    Element
param : LatParamStruct
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "track1_bunch_space_charge",
      &Bmad::track1_bunch_space_charge,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("track_to_same_s") = py::none(),
      py::arg("bunch_track") = py::none(),
      R"""(No docstring available

Parameters
----------
bunch : BunchStruct
    Starting bunch position.
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
ele : EleStruct
    Element to track through. Must be part of a lattice.
err : bool
    Set true if there is an error. EG: Too many particles lost for a CSR calc.
track_to_same_s : bool, optional
    Default is True. If True, drift particles to all have the same s-position.
bunch_track : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: track information if the
    tracking method does
)""");
  m.def(
      "track1_spin",
      &python_track1_spin,
      py::arg("start_orb"),
      py::arg("param"),
      py::arg("make_quaternion") = py::none(),
      R"""(No docstring available

Parameters
----------
start_orb : 
ele : EleStruct
    Element to track through .spin_q            -- 1st order spin map made if make_quaternion = True.
param : 
end_orb : CoordStruct
    Ending coords. .spin(2)           -- complex(rp): Ending spin
make_quaternion : 
)""");
  py::class_<PyTrack1Spin, std::unique_ptr<PyTrack1Spin>>(
      m, "Track1Spin", "Fortran routine track1_spin return value")
      .def_readonly("ele", &PyTrack1Spin::ele)
      .def_readonly("end_orb", &PyTrack1Spin::end_orb)
      .def_readonly("make_quaternion", &PyTrack1Spin::make_quaternion)
      .def("__len__", [](const PyTrack1Spin&) { return 3; })
      .def("__getitem__", [](const PyTrack1Spin& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ele);
        if (i == 1)
          return py::cast(s.end_orb);
        if (i == 2)
          return py::cast(s.make_quaternion);
        return py::none();
      });
  m.def(
      "track1_spin_integration",
      &Bmad::track1_spin_integration,
      py::arg("start_orb"),
      py::arg("ele"),
      py::arg("param"),
      R"""(No docstring available

Parameters
----------
start_orb : 
ele : 
param : 
end_orb : CoordStruct
    .spin(3)       -- Ending spin
)""");
  m.def(
      "track1_spin_taylor",
      &Bmad::track1_spin_taylor,
      py::arg("start_orb"),
      py::arg("ele"),
      py::arg("param"),
      R"""(import

implicit none
type (coord_struct) :: start_orb, end_orb
type (ele_struct) ele
type (lat_param_struct) :: param
end subroutine


Returns
-------
end_orb : CoordStruct
    .spin(3)   -- Ending spin
)""");
  m.def(
      "transfer_wake",
      &Bmad::transfer_wake,
      py::arg("wake_in"),
      R"""(No docstring available

Parameters
----------
wake_in : WakeStruct
    Input wake.
wake_out : WakeStruct
    Output wake.
)""");
  m.def(
      "type_coord",
      &Bmad::type_coord,
      py::arg("coord"),
      R"""(No docstring available

Parameters
----------
coord : CoordStruct
    Coordinate
)""");
  m.def(
      "update_fibre_from_ele",
      &Bmad::update_fibre_from_ele,
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Element with corresponding PTC fibre. ele.ptc_fibre -- PTC fibre.
survey_needed : bool
    Set True if a call to survey will be needed. Calling survey is avoided in this routine to save time if
    multiple elements are being updated.
)""");
  m.def(
      "valid_spin_tracking_method",
      &python_valid_spin_tracking_method,
      py::arg("ele"),
      py::arg("spin_tracking_method"),
      py::arg("is_valid"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element.
spin_tracking_method : int
    bmad_standard$, etc.
is_valid : 
)""");
  py::class_<
      PyValidSpinTrackingMethod,
      std::unique_ptr<PyValidSpinTrackingMethod>>(
      m,
      "ValidSpinTrackingMethod",
      "Fortran routine valid_spin_tracking_method return value")
      .def_readonly("is_valid", &PyValidSpinTrackingMethod::is_valid)
      .def("__len__", [](const PyValidSpinTrackingMethod&) { return 1; })
      .def(
          "__getitem__",
          [](const PyValidSpinTrackingMethod& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "vec_to_polar",
      &Bmad::vec_to_polar,
      py::arg("vec"),
      py::arg("phase") = py::none(),
      py::arg("polar"),
      R"""(No docstring available

Parameters
----------
vec : float
    unitary spin vector
phase : float, optional
    Phase of the spinor, if not given then set to zero
polar : 
)""");
  m.def(
      "vec_to_spinor",
      &Bmad::vec_to_spinor,
      py::arg("vec"),
      py::arg("phase") = py::none(),
      py::arg("spinor"),
      R"""(No docstring available

Parameters
----------
vec : float
    Spin vector in cartesian coordinates
phase : float
    Phase of the spinor, if not given then set to zero
spinor : 
)""");
  m.def(
      "write_beam_floor_positions",
      &Bmad::write_beam_floor_positions,
      py::arg("file_name"),
      py::arg("beam"),
      py::arg("ele"),
      py::arg("new_file") = py::none(),
      R"""(No docstring available

Parameters
----------
file_name : unknown
    Name of file.
beam : BeamStruct
    Beam to write
ele : EleStruct
    Element that the beam is at.
new_file : bool, optional
    New file or append? Default = True.
)""");
  m.def(
      "write_bmad_lattice_file",
      &Bmad::write_bmad_lattice_file,
      py::arg("bmad_file"),
      py::arg("lat"),
      py::arg("output_form") = py::none(),
      py::arg("orbit0") = py::none(),
      R"""(No docstring available

Parameters
----------
bmad_file : unknown
    Name of the output lattice file.
lat : LatStruct
    Holds the lattice information.
err : bool
    Set True if, say a file could not be opened.
output_form : int, optional
    binary$   -> Write grid_field info in binary hdf5 form in separate files. Default. All other fields are
    writen in separate files in ASCII ascii$    -> Fields will be put in separate ASCII files. one_file$ ->
    Everything in one file.
orbit0 : CoordStruct, optional
    Initial orbit. Used to write the inital orbit if the lattice geometry is closed.
)""");
  m.def(
      "write_lattice_in_foreign_format",
      &Bmad::write_lattice_in_foreign_format,
      py::arg("out_type"),
      py::arg("out_file_name"),
      py::arg("lat"),
      py::arg("ref_orbit") = py::none(),
      py::arg("use_matrix_model") = py::none(),
      py::arg("include_apertures") = py::none(),
      py::arg("dr12_drift_max") = py::none(),
      py::arg("ix_branch") = py::none(),
      R"""(No docstring available

Parameters
----------
out_type : unknown
    Either 'ELEGANT', 'MAD-8', 'MAD-X', 'SAD', or 'OPAL-T', 'SCIBMAD'.
out_file_name : unknown
    Name of the mad output lattice file.
lat : LatStruct
    Holds the lattice information.
ref_orbit : CoordStruct, optional
    Referece orbit for sad_mult and patch elements. This argument must be present if the lattice has sad_mult
    or patch elements and is being translated to MAD-8 or SAD.
use_matrix_model : bool, optional
    Use a drift-matrix_drift model for wigglers/undulators? [A MAD "matrix" is a 2nd order Taylor map.] This
    switch is ignored for SAD conversion. Default is False -> Use a bend-drift-bend model. Note: sol_quad
    elements always use a drift-matrix-drift model.
include_apertures : bool, optional
    If True (the default), add to the output lattice a zero length collimator element next to any non-
    collimator element that has an aperture. Note: MADX translations for non-drift elements can handle non-
    collimator elements with an aperture so in this case this argument is ignored.
dr12_drift_max : float, optional
    Max deviation for drifts allowed before a correction matrix element is added. Default value is 1d-5. A
    negative number means use default.
ix_branch : int, optional
    Index of lattice branch to use. Default = 0.
err : bool
    Set True if, say a file could not be opened.
)""");
  m.def(
      "write_lattice_in_mad_format",
      &Bmad::write_lattice_in_mad_format,
      py::arg("out_type"),
      py::arg("out_file_name"),
      py::arg("lat"),
      py::arg("ref_orbit") = py::none(),
      py::arg("use_matrix_model") = py::none(),
      py::arg("include_apertures") = py::none(),
      py::arg("dr12_drift_max") = py::none(),
      py::arg("ix_branch") = py::none(),
      R"""(No docstring available

Parameters
----------
out_type : unknown
    Either 'MAD-8', or 'MAD-X'
out_file_name : unknown
    Name of the mad output lattice file.
lat : LatStruct
    Holds the lattice information.
ref_orbit : CoordStruct, optional
    Referece orbit for sad_mult and patch elements. This argument must be present if the lattice has sad_mult
    or patch elements and is being translated to MAD-8 or SAD.
use_matrix_model : bool, optional
    Use a drift-matrix_drift model for wigglers/undulators? [A MAD "matrix" is a 2nd order Taylor map.] This
    switch is ignored for SAD conversion. Default is False -> Use a bend-drift-bend model. Note: sol_quad
    elements always use a drift-matrix-drift model.
include_apertures : bool, optional
    If True (the default), add to the output lattice a zero length collimator element next to any non-
    collimator element that has an aperture. Note: MADX translations for non-drift elements can handle non-
    collimator elements with an aperture so in this case this argument is ignored.
dr12_drift_max : float, optional
    Max deviation for drifts allowed before a correction matrix element is added. Default value is 1d-5. A
    negative number means use default.
ix_branch : int, optional
    Index of lattice branch to use. Default = 0.
err : bool
    Set True if, say a file could not be opened.
)""");
  m.def(
      "write_lattice_in_elegant_format",
      &Bmad::write_lattice_in_elegant_format,
      py::arg("out_file_name"),
      py::arg("lat"),
      py::arg("ref_orbit") = py::none(),
      py::arg("use_matrix_model") = py::none(),
      py::arg("include_apertures") = py::none(),
      py::arg("dr12_drift_max") = py::none(),
      py::arg("ix_branch") = py::none(),
      R"""(No docstring available

Parameters
----------
out_file_name : unknown
    Name of the mad output lattice file.
lat : LatStruct
    Holds the lattice information.
ref_orbit : CoordStruct, optional
    Referece orbit for sad_mult and patch elements. This argument must be present if the lattice has sad_mult
    or patch elements and is being translated to MAD-8 or SAD.
use_matrix_model : bool, optional
    Use a drift-matrix_drift model for wigglers/undulators? [A MAD "matrix" is a 2nd order Taylor map.] This
    switch is ignored for SAD conversion. Default is False -> Use a bend-drift-bend model. Note: sol_quad
    elements always use a drift-matrix-drift model.
include_apertures : bool, optional
    If True (the default), add to the output lattice a zero length collimator element next to any non-
    collimator element that has an aperture. Note: MADX translations for non-drift elements can handle non-
    collimator elements with an aperture so in this case this argument is ignored.
dr12_drift_max : float, optional
    Max deviation for drifts allowed before a correction matrix element is added. Default value is 1d-5. A
    negative number means use default.
ix_branch : int, optional
    Index of lattice branch to use. Default = 0.
err : bool
    Set True if, say a file could not be opened.
)""");
  m.def(
      "write_lattice_in_sad_format",
      &python_write_lattice_in_sad_format,
      py::arg("out_file_name"),
      py::arg("lat"),
      py::arg("include_apertures") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("err") = py::none(),
      R"""(No docstring available

Parameters
----------
out_file_name : 
lat : 
include_apertures : 
ix_branch : 
err : 
)""");
  py::class_<
      PyWriteLatticeInSadFormat,
      std::unique_ptr<PyWriteLatticeInSadFormat>>(
      m,
      "WriteLatticeInSadFormat",
      "Fortran routine write_lattice_in_sad_format return value")
      .def_readonly("out_file_name", &PyWriteLatticeInSadFormat::out_file_name)
      .def_readonly(
          "include_apertures", &PyWriteLatticeInSadFormat::include_apertures)
      .def_readonly("ix_branch", &PyWriteLatticeInSadFormat::ix_branch)
      .def_readonly("err", &PyWriteLatticeInSadFormat::err)
      .def("__len__", [](const PyWriteLatticeInSadFormat&) { return 4; })
      .def(
          "__getitem__",
          [](const PyWriteLatticeInSadFormat& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.out_file_name);
            if (i == 1)
              return py::cast(s.include_apertures);
            if (i == 2)
              return py::cast(s.ix_branch);
            if (i == 3)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "write_lattice_in_scibmad",
      &Bmad::write_lattice_in_scibmad,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
scibmad_file : unknown
    SciBmad lattice file name.
lat : LatStruct
    Lattice
err_flag : bool
    Error flag
)""");
  py::class_<
      Bmad::WriteLatticeInScibmad,
      std::unique_ptr<Bmad::WriteLatticeInScibmad>>(
      m,
      "WriteLatticeInScibmad",
      "Fortran routine write_lattice_in_scibmad return value")
      .def_readonly("scibmad_file", &Bmad::WriteLatticeInScibmad::scibmad_file)
      .def_readonly("err_flag", &Bmad::WriteLatticeInScibmad::err_flag)
      .def("__len__", [](const Bmad::WriteLatticeInScibmad&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::WriteLatticeInScibmad& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.scibmad_file);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "pointer_to_ele1",
      &python_pointer_to_ele1,
      py::arg("lat"),
      py::arg("ix_ele"),
      py::arg("ix_branch") = py::none(),
      py::arg("ele_ptr"),
      R"""(Function to return a pointer to an element in a lattice.

This routine is overloaded by pointer_to_ele.
See pointer_to_ele for more details.


Returns
-------
ele_ptr
)""");
  py::class_<PyPointerToEle1, std::unique_ptr<PyPointerToEle1>>(
      m, "PointerToEle1", "Fortran routine pointer_to_ele1 return value")
      .def_readonly("ix_ele", &PyPointerToEle1::ix_ele)
      .def_readonly("ix_branch", &PyPointerToEle1::ix_branch)
      .def("__len__", [](const PyPointerToEle1&) { return 2; })
      .def("__getitem__", [](const PyPointerToEle1& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ix_ele);
        if (i == 1)
          return py::cast(s.ix_branch);
        return py::none();
      });
  m.def(
      "pointer_to_ele2",
      &Bmad::pointer_to_ele2,
      py::arg("lat"),
      py::arg("ele_loc"),
      py::arg("ele_ptr"),
      R"""(Function to return a pointer to an element in a lattice.

This routine is overloaded by pointer_to_ele.
See pointer_to_ele for more details.


Returns
-------
ele_ptr
)""");
  m.def(
      "pointer_to_ele3",
      &python_pointer_to_ele3,
      py::arg("lat"),
      py::arg("ele_name"),
      py::arg("ele_ptr"),
      R"""(Function to return a pointer to an element in a lattice.

This routine is overloaded by pointer_to_ele.
See pointer_to_ele for more details.


Returns
-------
ele_ptr
)""");
  py::class_<PyPointerToEle3, std::unique_ptr<PyPointerToEle3>>(
      m, "PointerToEle3", "Fortran routine pointer_to_ele3 return value")
      .def_readonly("ele_name", &PyPointerToEle3::ele_name)
      .def("__len__", [](const PyPointerToEle3&) { return 1; })
      .def("__getitem__", [](const PyPointerToEle3& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ele_name);
        return py::none();
      });
  m.def(
      "pointer_to_ele4",
      &Bmad::pointer_to_ele4,
      py::arg("lat"),
      py::arg("foreign_ele"),
      py::arg("ele_ptr"),
      R"""(Function to return a pointer to an element in a lattice.

This routine is overloaded by pointer_to_ele.
See pointer_to_ele for more details.


Returns
-------
ele_ptr
)""");
  m.def(
      "map1_times_map1",
      &Bmad::map1_times_map1,
      py::arg("map2"),
      py::arg("map1"),
      R"""(Routine to concatenate two spin orbital linear maps.

map_out = map2(map1)
Order is like applying matrices. map1 is before map2.

Parameters
----------
map2 : SpinOrbitMap1Struct
    Second map.
map1 : SpinOrbitMap1Struct
    First map.

Returns
-------
map_out : SpinOrbitMap1Struct
    Concatenated map.
)""");
  m.def(
      "em_field_plus_em_field",
      &Bmad::em_field_plus_em_field,
      py::arg("field1"),
      py::arg("field2"),
      R"""(Routine to add fields.

Parameters
----------
field1 : EmFieldStruct
    Input field
field2 : EmFieldStruct
    Input field

Returns
-------
field_tot : EmFieldStruct
    Combined field.
)""");
  m.def(
      "ele_equal_ele",
      &Bmad::ele_equal_ele,
      py::arg("ele_in"),
      R"""(Subroutine that is used to set one element equal to another.

This routine takes care of the pointers in ele_out.

Parameters
----------
ele_in : EleStruct
    Input element.

Returns
-------
ele_out : EleStruct
    Output element.
)""");
  m.def(
      "ele_equals_ele",
      &Bmad::ele_equals_ele,
      py::arg("ele_in"),
      py::arg("update_nametable"),
      R"""(Subroutine that is used to set an element equal to another.

Parameters
----------
ele_in : EleStruct
    Input element.
update_nametable : bool
    If true, update the nametable. If false, do not. Note: nametable updates can take time if this routine is
    called a many times. See remove_eles_from_lat as an example.

Returns
-------
ele_out : EleStruct
    Output element.
)""");
  m.def(
      "ele_vec_equal_ele_vec",
      &Bmad::ele_vec_equal_ele_vec,
      py::arg("ele2"),
      R"""(Subroutine that is used to set one ele vector equal to another.

This routine takes care of the pointers in ele1.
ele1(:) = ele2(:)

Parameters
----------
ele2 : EleStruct
    Input ele vector.

Returns
-------
ele1 : EleStruct
    Output ele vector.

Notes
-----
Note: This subroutine is called by the overloaded equal sign:
)""");
  m.def(
      "lat_equal_lat",
      &Bmad::lat_equal_lat,
      py::arg("lat_in"),
      R"""(Subroutine that is used to set one lat equal to another.

This routine takes care of the pointers in lat_in.

Parameters
----------
lat_in : LatStruct
    Input lat.

Returns
-------
lat_out : LatStruct
    Output lat.
)""");
  m.def(
      "lat_vec_equal_lat_vec",
      &Bmad::lat_vec_equal_lat_vec,
      py::arg("lat2"),
      R"""(Subroutine that is used to set one lat vector equal to another.

This routine takes care of the pointers in lat1.
lat1(:) = lat2(:)

Parameters
----------
lat2 : LatStruct
    Input lat vector.

Returns
-------
lat1 : LatStruct
    Output lat vector.

Notes
-----
Note: This subroutine is called by the overloaded equal sign:
)""");
  m.def(
      "branch_equal_branch",
      &Bmad::branch_equal_branch,
      py::arg("branch2"),
      R"""(Subroutine that is used to set one branch equal to another.

Parameters
----------
branch2 : BranchStruct
    Input branch.

Returns
-------
branch1 : BranchStruct
    Output branch.
)""");
  m.def(
      "coord_equal_coord",
      &Bmad::coord_equal_coord,
      py::arg("coord2"),
      R"""(Subroutine that is used to set one coord equal to another.

Parameters
----------
coord2 : CoordStruct
    Input coord.

Returns
-------
coord1 : CoordStruct
    Output coord.
)""");
  m.def(
      "taylor_equal_taylor",
      &Bmad::taylor_equal_taylor,
      py::arg("taylor2"),
      R"""(Subroutine that is used to set one taylor equal to another.

This routine takes care of the pointers in taylor1.

Parameters
----------
taylor2 : TaylorStruct
    Input taylor.

Returns
-------
taylor1 : TaylorStruct
    Output taylor.
)""");
  m.def(
      "taylors_equal_taylors",
      &Bmad::taylors_equal_taylors,
      py::arg("taylor2"),
      R"""(Subroutine to transfer the values from one taylor map to another:

Taylor1 <= Taylor2

Parameters
----------
taylor2 : TaylorStruct
    Taylor map.

Returns
-------
taylor1 : TaylorStruct
    Taylor map.
)""");
  m.def(
      "em_taylor_equal_em_taylor",
      &Bmad::em_taylor_equal_em_taylor,
      py::arg("em_taylor2"),
      R"""(Subroutine that is used to set one em_taylor equal to another.

Parameters
----------
em_taylor2 : EmTaylorStruct
    Input em_taylor.

Returns
-------
em_taylor1 : EmTaylorStruct
    Output em_taylor.
)""");
  m.def(
      "em_taylors_equal_em_taylors",
      &Bmad::em_taylors_equal_em_taylors,
      py::arg("em_taylor2"),
      R"""(Subroutine to transfer the values from one em_taylor map to another:

Em_taylor1 <= Em_taylor2

Parameters
----------
em_taylor2 : EmTaylorStruct
    Em_taylor map.

Returns
-------
em_taylor1 : EmTaylorStruct
    Em_taylor map.
)""");
  m.def(
      "init_em_taylor_series",
      &Bmad::init_em_taylor_series,
      py::arg("em_taylor"),
      py::arg("n_term"),
      py::arg("save_old") = py::none(),
      R"""(Subroutine to initialize a Bmad Em_taylor series (6 of these series make

a Em_taylor map). Note: This routine does not zero the structure. The calling
routine is responsible for setting all values.

Parameters
----------
em_taylor : EmTaylorStruct
    Old structure.
    This parameter is an input/output and is modified in-place. As an output: Initalized structure.
n_term : int
    Number of terms to allocate. n_term < 0 => em_taylor.term pointer will be disassociated.
save_old : bool, optional
    If True then save any old terms when em_taylor is resized. Default is False.
)""");
  m.def(
      "complex_taylor_equal_complex_taylor",
      &Bmad::complex_taylor_equal_complex_taylor,
      py::arg("complex_taylor2"),
      R"""(Subroutine that is used to set one complex_taylor equal to another.

This routine takes care of the pointers in complex_taylor1.

Parameters
----------
complex_taylor2 : ComplexTaylorStruct
    Input complex_taylor.

Returns
-------
complex_taylor1 : ComplexTaylorStruct
    Output complex_taylor.
)""");
  m.def(
      "complex_taylors_equal_complex_taylors",
      &Bmad::complex_taylors_equal_complex_taylors,
      py::arg("complex_taylor2"),
      R"""(Subroutine to transfer the values from one complex_taylor map to another:

complex_taylor1 <= complex_taylor2

Parameters
----------
complex_taylor2 : ComplexTaylorStruct
    complex_taylor map.

Returns
-------
complex_taylor1 : ComplexTaylorStruct
    complex_taylor map.
)""");
  m.def(
      "init_complex_taylor_series",
      &Bmad::init_complex_taylor_series,
      py::arg("complex_taylor"),
      py::arg("n_term"),
      py::arg("save") = py::none(),
      R"""(Subroutine to initialize a Bmad complex_taylor series (6 of these series make

a complex_taylor map). Note: This routine does not zero the structure. The calling
routine is responsible for setting all values.

Parameters
----------
complex_taylor : ComplexTaylorStruct
    Old structure.
    This parameter is an input/output and is modified in-place. As an output: Initalized structure.
n_term : int
    Number of terms to allocate. n_term < 1 => complex_taylor.term pointer will be disassociated.
save : bool, optional
    If True then save any old terms when complex_taylor is resized. Default is False.
)""");
  m.def(
      "bunch_equal_bunch",
      &Bmad::bunch_equal_bunch,
      py::arg("bunch1"),
      py::arg("bunch2"),
      R"""(Subroutine to set one particle bunch equal to another.

Parameters
----------
bunch2 : BunchStruct
    Input bunch Output
bunch1 : BunchStruct
    Output bunch
)""");
  m.def(
      "beam_equal_beam",
      &Bmad::beam_equal_beam,
      py::arg("beam1"),
      py::arg("beam2"),
      R"""(Subroutine to set one particle beam equal to another taking care of

pointers so that they don't all point to the same place.

Parameters
----------
beam2 : BeamStruct
    Input beam Output
beam1 : BeamStruct
    Output beam
)""");
  m.def(
      "bend_edge_kick",
      &Bmad::bend_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orb"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      py::arg("track_spin") = py::none(),
      R"""(Subroutine to track through the edge field of an sbend.

This routine is called by apply_element_edge_kick only.

Parameters
----------
ele : EleStruct
    SBend element.
param : LatParamStruct
    Rel charge.
particle_at : int
    first_track_edge$, or second_track_edge$.
orb : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
mat6 : float, optional
    Transfer matrix before fringe.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
    including fringe.
make_matrix : bool, optional
    Propagate the transfer matrix? Default is false.
track_spin : bool, optional
    If True then track the spin through the edge fields. Default: False.
)""");
  m.def(
      "linear_bend_edge_kick",
      &Bmad::linear_bend_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orb"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Subroutine to track through the edge field of an sbend.

Apply only the first order kick, which is edge focusing.

Parameters
----------
ele : EleStruct
    SBend element.
param : LatParamStruct
    Rel charge.
particle_at : int
    first_track_edge$, or second_track_edge$,
orb : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
mat6 : float, optional
    Transfer matrix up to the edge.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
    edge.
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "hwang_bend_edge_kick",
      &Bmad::hwang_bend_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orb"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Subroutine to track through the edge field of an sbend using a 2nd order map.

Adapted from:
Hwang and S. Y. Lee,
"Dipole Fringe Field Thin Map for Compact Synchrotrons",
Phys. Rev. ST Accel. Beams, 12, 122401, (2015).
See the Bmad manual for details.

Parameters
----------
orb : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
ele : EleStruct
    SBend element.
param : LatParamStruct
    Rel charge.
particle_at : int
    first_track_edge$, or second_track_edge$
mat6 : float, optional
    Transfer matrix up to the edge.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
    edge.
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "sad_mult_hard_bend_edge_kick",
      &Bmad::sad_mult_hard_bend_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Routine to track through the hard edge bend fringe field for a bend or sad_mult element.

Only the bend field is taken into account here. Higher order multipolse must be handled elsewhere.
This routine assumes that the particle coordinates are with respect to the actual magnet face.
Thus finite e1/e2 must be taken into account by other routines.
SAD calls this the "linear" fringe even though it is nonlinear.

Parameters
----------
ele : EleStruct
    Element with fringe.
param : LatParamStruct
    Tracking parameters.
particle_at : int
    Either first_track_edge$ or second_track_edge$.
orbit : CoordStruct
    Starting coordinates.
    This parameter is an input/output and is modified in-place. As an output: Ending coordinates.
mat6 : float, optional
    Transfer matrix up to the fringe.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
    fringe.
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "soft_quadrupole_edge_kick",
      &Bmad::soft_quadrupole_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Routine to add the SAD "linear" soft edge (for finite f1 or f2).

This routine assumes that the particle orbit has been rotated to the element reference frame.
This routine is called with sad_mult and quadrupole elements.

Parameters
----------
ele : EleStruct
    Element being tracked through
param : LatParamStruct
    Tracking parameters.
particle_at : int
    first_track_edge$, or second_track_edge$.
orbit : CoordStruct
    Position before kick.
    This parameter is an input/output and is modified in-place. As an output: Position after kick.
mat6 : float, optional
    Transfer matrix up to the edge.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix with edge kick
    added on.
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "hard_multipole_edge_kick",
      &Bmad::hard_multipole_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orbit"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Routine to track through the hard edge field of a multipole.

The dipole component is ignored and only quadrupole and higher multipoles are included.
This routine handles elements of type:
sad_mult, sbend, quadrupole, sextupole
For sad_mult elements, ele%a_pole and ele%b_pole ae used for the multipole values.
For the other elements, k1 or k2 is used and it is assumed that we are in the element
frame of reference so tilt = 0.

Parameters
----------
ele : EleStruct
    Element with fringe.
param : LatParamStruct
    Tracking parameters.
particle_at : int
    Either first_track_edge$ or second_track_edge$.
orbit : CoordStruct
    Starting coordinates.
    This parameter is an input/output and is modified in-place. As an output: Ending coordinates.
mat6 : float, optional
    Transfer matrix up to the fringe.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
    fringe.
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "sad_soft_bend_edge_kick",
      &Bmad::sad_soft_bend_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orb"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Subroutine to track through the ("linear") bend soft edge field of an sbend or sad_mult.

Parameters
----------
ele : EleStruct
    SBend or sad_mult element.
param : LatParamStruct
particle_at : int
    first_track_edge$, or second_track_edge$.
orb : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
mat6 : float, optional
    Starting matrix
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix after fringe
    field
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
k0l : float, optional
    Used with sad_mult. If present, use this instead of ele.a_pole/.b_pole.
t0 : float, optional
    Used with sad_mult. If present, use this instead of ele.a_pole/.b_pole. Must be present if k0l is.
)""");
  m.def(
      "exact_bend_edge_kick",
      &Bmad::exact_bend_edge_kick,
      py::arg("ele"),
      py::arg("param"),
      py::arg("particle_at"),
      py::arg("orb"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Subroutine to track through the edge field of an sbend.

Uses routines adapted from PTC

Parameters
----------
ele : EleStruct
    SBend element.
param : LatParamStruct
particle_at : int
    first_track_edge$, or second_track_edge$.
orb : CoordStruct
    Coords after tracking.
mat6 : float, optional
    Transfer matrix up to the edge.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
    edge.
make_matrix : float, optional
    Propagate the transfer matrix? Default is False.
)""");
  m.def(
      "coord_state_name",
      &python_coord_state_name,
      py::arg("coord_state"),
      py::arg("one_word") = py::none(),
      R"""(Routine to return the string representation of a coord%state state.

Parameters
----------
coord_state : int
    coord.state value

Returns
-------
state_str : unknown
    String representation.
)""");
  py::class_<PyCoordStateName, std::unique_ptr<PyCoordStateName>>(
      m, "CoordStateName", "Fortran routine coord_state_name return value")
      .def_readonly("state_str", &PyCoordStateName::state_str)
      .def_readonly("one_word", &PyCoordStateName::one_word)
      .def("__len__", [](const PyCoordStateName&) { return 2; })
      .def(
          "__getitem__", [](const PyCoordStateName& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.state_str);
            if (i == 1)
              return py::cast(s.one_word);
            return py::none();
          });
  m.def(
      "is_attribute",
      &Bmad::is_attribute,
      py::arg("ix_attrib"),
      py::arg("which"),
      R"""(Routine to determine if an attribute index corresponds to a control variable for overlys/groups.

Parameters
----------
ix_attrib : int
    Attribute index.
which : int
    control_var$, old_control_var$, all_control_var$, multipole$, elec_multipole$

Returns
-------
is_attrib : bool
    True if a control variable
)""");
  m.def(
      "pointer_to_slave",
      &Bmad::pointer_to_slave,
      py::arg("lord"),
      py::arg("ix_slave"),
      py::arg("lord_type") = py::none(),
      R"""(Function to point to a slave of a lord.

Parameters
----------
lord : EleStruct
    Lord element
ix_slave : int
    Index of the slave in the list of slaves controled by the lord..
lord_type : int, optional
    See above.

Return value is a dictionary containing values below.


Returns
-------
slave_ptr : EleStruct
    Pointer to the slave. Nullified if there is an error.
control : ControlStruct
    Pointer to control info for this lord/slave relationship. Nullified if there is an error.
ix_lord_back : int
    Index back to the lord. That is, pointer_to_lord(slave_ptr, ix_lord_back) will point back to the lord. Set
    to -1 if there is an error.
ix_control : int
    Index in lat.control(:) array the control argument is at.
ix_ic : int
    Index of the lat.ic(:) element associated with the control argument.

Notes
-----
Related routines:
pointer_to_lord pointer_to_super_lord pointer_to_ele num_lords
)""");
  py::class_<Bmad::PointerToSlave, std::unique_ptr<Bmad::PointerToSlave>>(
      m, "PointerToSlave", "Fortran routine pointer_to_slave return value")
      .def_readonly("control", &Bmad::PointerToSlave::control)
      .def_readonly("ix_lord_back", &Bmad::PointerToSlave::ix_lord_back)
      .def_readonly("ix_control", &Bmad::PointerToSlave::ix_control)
      .def_readonly("ix_ic", &Bmad::PointerToSlave::ix_ic)
      .def_readonly("slave_ptr", &Bmad::PointerToSlave::slave_ptr)
      .def("__len__", [](const Bmad::PointerToSlave&) { return 5; })
      .def(
          "__getitem__",
          [](const Bmad::PointerToSlave& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.control);
            if (i == 1)
              return py::cast(s.ix_lord_back);
            if (i == 2)
              return py::cast(s.ix_control);
            if (i == 3)
              return py::cast(s.ix_ic);
            if (i == 4)
              return py::cast(s.slave_ptr);
            return py::none();
          });
  m.def(
      "ele_finalizer",
      &Bmad::ele_finalizer,
      py::arg("ele"),
      R"""(Finalizer routine for ele_struct instances.

Parameters
----------
ele : EleStruct
    Element to cleanup.
    This parameter is an input/output and is modified in-place. As an output: Element with pointers
    deallocated as needed.
)""");
  m.def(
      "set_active_fixer",
      &Bmad::set_active_fixer,
      py::arg("fixer"),
      py::arg("is_on") = py::none(),
      R"""(Set the acvitive fixer element.

All other fixer/beginning_ele elements in the branch will be deactivated.
If is_on is True (default), the fixer argument becomes the active fixer.
If is_on is False, and fixer%is_on is also False, there is nothing to be done.
If is_on is False, and fixer%is_on is True, turn this fixer off and turn on the beginning element.

Parameters
----------
fixer : EleStruct
    Fixer element to make active.
    This parameter is an input/output and is modified in-place. As an output: Element is now active.
is_on : bool, optional
    If True (default), make this fixer the active element. If False, make the beginning element active.

Returns
-------
orbit : CoordStruct
    Load with stored fixer phase space and spin values.
)""");
  m.def(
      "transfer_fixer_params",
      &Bmad::transfer_fixer_params,
      py::arg("fixer"),
      py::arg("to_stored"),
      py::arg("orbit") = py::none(),
      py::arg("who") = py::none(),
      R"""(Set parameters of fixer.

Parameters
----------
fixer : EleStruct
    Fixer element to set.
to_stored : bool
    If False, set real Twiss from stored. If True, set stored Twiss from real.
orbit : CoordStruct, optional
    Used for 'phase_space' transfers.
who : bool, optional
    Who to set. Possibilities are: Groups: 'all', ' ' (default and same as 'all') Note: This excludes all
    'start' sets., 'twiss', 'a_twiss', 'b_twiss', 'cmat', 'x_dispersion', 'y_dispersion', 'dispersion',
    'chromatic', 'orbit', 'phase_space', 'spin', 'x_plane', 'y_plane', 'z_plane', 'start', 'start_spin',
    'start_phase_space', Individula Parameters: 'x', 'px', 'cmat_11', etc.

Returns
-------
is_ok : 
    logical
)""");
  m.def(
      "odeint_bmad",
      &Bmad::odeint_bmad,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("s1_body"),
      py::arg("s2_body"),
      py::arg("mat6") = py::none(),
      py::arg("make_matrix") = py::none(),
      R"""(Subroutine to do Runge Kutta tracking. This routine is adapted from Numerical

Recipes.  See the NR book for more details.
Notice that this routine has an two tolerances:
bmad_com%rel_tol_adaptive_tracking
bmad_com%abs_tol_adaptive_tracking

Parameters
----------
orbit : CoordStruct
    Starting coords: (x, px, y, py, z, delta) in element body coords.
    This parameter is an input/output and is modified in-place. As an output: Ending coords
ele : EleStruct
    Element to track through.
param : LatParamStruct
    Lattice parameters.
s1_body : float
    Starting point relative to physical entrance.
s2_body : float
    Ending point relative physical entrance.
mat6 : float, optional
    Transfer matrix before the element.
    This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
    through the element.
make_matrix : bool, optional
    If True then make the 6x6 transfer matrix.

Return value is a dictionary containing values below.


Returns
-------
err_flag : bool
    Set True if there is an error. False otherwise. Note: a particle getting lost, for example hitting an
    aperture, is *not* an error.
track : TrackStruct
    Structure holding the track information.
)""");
  py::class_<Bmad::OdeintBmad, std::unique_ptr<Bmad::OdeintBmad>>(
      m, "OdeintBmad", "Fortran routine odeint_bmad return value")
      .def_readonly("err_flag", &Bmad::OdeintBmad::err_flag)
      .def_readonly("track", &Bmad::OdeintBmad::track)
      .def("__len__", [](const Bmad::OdeintBmad&) { return 2; })
      .def(
          "__getitem__", [](const Bmad::OdeintBmad& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.track);
            return py::none();
          });
  m.def(
      "kick_vector_calc",
      &python_kick_vector_calc,
      py::arg("ele"),
      py::arg("param"),
      py::arg("s_body"),
      py::arg("orbit"),
      py::arg("print_err") = py::none(),
      R"""(Subroutine to calculate the dr/ds "kick vector" where

r = [x, p_x, y, p_y, z, p_z, t, spin_x,y,z]
the P0 at the exit end of the element.
dr(1)/ds = dx/ds = dx/dt * dt/ds
where:
dx/dt = v_x = p_x / (1 + p_z)
dt/ds = (1 + g*x) / v_s
g = 1/rho, rho = bending radius (nonzero only in a dipole)
dr(2)/ds = dp_x/ds = dP_x/dt * dt/ds / P0 + g_x * P_z
where:
dP_x/dt = EM_Force_x
g_x = bending in x-plane.
dr(3)/ds = dy/ds = dy/dt * dt/ds
where:
dy/dt = v_x
dr(4)/ds = dp_y/ds = dP_y/dt * ds/dt / P0 + g_y * P_z
where:
dP_y/dt = EM_Force_y
g_y = bending in y-plane.
where:
dt/ds(ref) = 1 / beta(ref)
dr(6)/ds = dp_z/ds = d(EM_Force dot v_hat) * dt/ds / P0
where:
v_hat = velocity normalized to 1.
dr(7)/ds = dt/ds
dr(8:10)/ds = Spin omega vector
dr(11)/ds = dt_ref/ds

Parameters
----------
ele : EleStruct
    Element being tracked thorugh.
param : LatParamStruct
    Lattice parameters.
s_rel : float
    Distance from the start of the element to the particle.
orbit : CoordStruct
    Position of particle.
local_ref_frame : !
    Logical, If True then take the input coordinates -- Logical, If True then take the input coordinates as
    being with respect to the frame of referene of the element.

Return value is a dictionary containing values below.


Returns
-------
dr_ds : float
    Kick vector.
field : EmFieldStruct
    Local field.
err : bool
    Set True if there is an error.

Notes
-----
Remember: In order to simplify the calculation, in the body of any element, P0 is taken to be
NOTE: dr(5)/ds IS IGNORED WHEN CALCULATING Z. SEE TRANSFER_THIS_ORBIT ABOVE. dr(5)/ds = dz/ds = beta * c_light
* [dt/ds(ref) - dt/ds] + dbeta/ds * c_light * [t(ref) - t] = beta * c_light * [dt/ds(ref) - dt/ds] + dbeta/ds
* vec(5) / beta
)""");
  py::class_<PyKickVectorCalc, std::unique_ptr<PyKickVectorCalc>>(
      m, "KickVectorCalc", "Fortran routine kick_vector_calc return value")
      .def_readonly("dr_ds", &PyKickVectorCalc::dr_ds)
      .def_readonly("err", &PyKickVectorCalc::err)
      .def_readonly("print_err", &PyKickVectorCalc::print_err)
      .def("__len__", [](const PyKickVectorCalc&) { return 3; })
      .def(
          "__getitem__", [](const PyKickVectorCalc& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dr_ds);
            if (i == 1)
              return py::cast(s.err);
            if (i == 2)
              return py::cast(s.print_err);
            return py::none();
          });
  m.def(
      "integration_timer_ele",
      &python_integration_timer_ele,
      py::arg("ele"),
      py::arg("param"),
      py::arg("start"),
      py::arg("orb_max"),
      py::arg("tol"),
      R"""(No docstring available

Parameters
----------
ele : 
param : 
start : 
orb_max : 
tol : 
)""");
  py::class_<PyIntegrationTimerEle, std::unique_ptr<PyIntegrationTimerEle>>(
      m,
      "IntegrationTimerEle",
      "Fortran routine integration_timer_ele return value")
      .def_readonly("tol", &PyIntegrationTimerEle::tol)
      .def("__len__", [](const PyIntegrationTimerEle&) { return 1; })
      .def(
          "__getitem__",
          [](const PyIntegrationTimerEle& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.tol);
            return py::none();
          });
  m.def(
      "expression_string_to_tree",
      &Bmad::expression_string_to_tree,
      py::arg("string"),
      py::arg("root_tree"),
      R"""(Routine to create an expression tree array which can be used

to evaluate an arithmethic expression.

Parameters
----------
root_tree : ExpressionTreeStruct
    Only used when recursively called.
string : unknown
    Expression to be converted.

Return value is a dictionary containing values below.


Returns
-------
tree : ExpressionTreeStruct
    Expression evaluation tree.
err_flag : bool
    Set True if there is an error (EG divide by 0).
err_str : unknown
    String describing the error. Make length large to hold the expression.

Notes
-----
Related routines:
expression_value expression_tree_value deallocate_expression_tree Important! trees use pointers as opposed to
allocatable arrays due to the ifort compiler not being able to ) being an allocatable array. Thus
deallocate_expression_tree must be called before any tree instance goes out of scope. plus$ minus$ times$
divide$ power$ unary_minus$ unary_plus$ constant$ numeric$ variable$ function$ root$ parens$ func_parens$
square_brackets$ curly_brackets$ arrow$ equal$ colon$ double_colon$ vertical_bar$ compound$ "->" "::" + - * /
^ = : & [] () {} Root node name is "root" is of type root$ Brackets in the expression string must be matched.
"[]" / square_brackets$ "()" / parens$ func_parens$ "{}" / curley_brackets$ The root node equal nodes all
bracket nodes will have an array of child nodes all of which will be comma nodes. "[A B]" will translate to a
"[]" node with two comma children the first comma child will have a single child "A" the second comma child
will have a single child "B". "(A)" will translate to a "()" node with one comma child this comma child will
have a single child "A". If the string is an equation. For example "A B = C D Z". In this case the root node
will have two equal node children (and not comma children) The first equal node represents the left hand side
of the equation this node will have two comma children. The second equal node child will have three comma
children. :orxit.x" (this is a Tao construct) which get :" "orbit.x" functions line "atan()" are considered
compound vars with children "atan" "()" The funciton argument of a species related function like "He++" in the
construct "mass_of(He++)" will not get split will get marked as a species_const$.
)""");
  py::class_<
      Bmad::ExpressionStringToTree,
      std::unique_ptr<Bmad::ExpressionStringToTree>>(
      m,
      "ExpressionStringToTree",
      "Fortran routine expression_string_to_tree return value")
      .def_readonly("err_flag", &Bmad::ExpressionStringToTree::err_flag)
      .def_readonly("err_str", &Bmad::ExpressionStringToTree::err_str)
      .def("__len__", [](const Bmad::ExpressionStringToTree&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ExpressionStringToTree& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.err_str);
            return py::none();
          });
  m.def(
      "deallocate_expression_tree",
      &Bmad::deallocate_expression_tree,
      py::arg("tree"),
      R"""(Routine to deallocate an expression tree.

Parameters
----------
tree : ExpressionTreeStruct
    Tree to deallocate.
    This parameter is an input/output and is modified in-place. As an output: Deallocated tree.
)""");
  m.def(
      "type_expression_tree",
      &Bmad::type_expression_tree,
      py::arg("tree"),
      py::arg("indent") = py::none(),
      R"""(Routine to print an expression tree in tree form.

Good for debugging.

Parameters
----------
tree : ExpressionTreeStruct
    Tree to print.
indent : int, optional
    Initial indent. Default is zero.
)""");
  m.def(
      "expression_tree_to_string",
      &Bmad::expression_tree_to_string,
      py::arg("tree"),
      py::arg("include_root") = py::none(),
      py::arg("n_node") = py::none(),
      py::arg("parent") = py::none(),
      R"""(Routine to convert an expression tree to a expression string.

Parameters
----------
tree : ExpressionTreeStruct
    Root of tree to print.
include_root : bool, optional
    Default is True. If True, do not inculde in the output string the root node. Note: If the root node is of
    type root$, this node is always ignored.
n_node : int, optional
    Node index. parent.node(n_node) === tree. Internal use only. Used with recursive calls.
parent : ExpressionTreeStruct, optional
    Internal use only. Used with recusive calls.

Returns
-------
str_out : unknown
    Expression string.
)""");
  m.def(
      "re_associate_node_array",
      &Bmad::re_associate_node_array,
      py::arg("tree"),
      py::arg("n"),
      py::arg("exact") = py::none(),
      R"""(Routine to resize the tree%node(:) array.

Parameters
----------
tree : ExpressionTreeStruct
n : int
    Size wanted.
exact : bool, optional
    Default is False. If False, the size of the output array is permitted to be larger than n.
)""");
  m.def(
      "deallocate_tree",
      &Bmad::deallocate_tree,
      py::arg("tree"),
      R"""(Routine to deallocate tree%node(:) and everything below it

Parameters
----------
tree : ExpressionTreeStruct
    Root of tree to deallocate.
    This parameter is an input/output and is modified in-place. As an output: Deallocated tree.
)""");
  m.def(
      "expression_string_to_stack",
      &Bmad::expression_string_to_stack,
      py::arg("string"),
      R"""(This routine creates an expression stack array which can be used

to evaluate an arithmethic expression.
Stack end elements not used are marked stack(i)%type = end_stack$
Stack elements with stack(i)%type = variable$ are elements that need
to be evaluated before calling expression_stack_value.

Parameters
----------
string : unknown
    Expression to be converted.

Return value is a dictionary containing values below.


Returns
-------
stack : ExpressionAtomStruct
    Expression evaluation stack.
n_stack : int
    number of "atoms" used by the expression
err_flag : bool
    Set True if there is an error (EG divide by 0).
err_str : unknown
    String describing the error.

Notes
-----
Related routines:
expression_value expression_stack_value
)""");
  py::class_<
      Bmad::ExpressionStringToStack,
      std::unique_ptr<Bmad::ExpressionStringToStack>>(
      m,
      "ExpressionStringToStack",
      "Fortran routine expression_string_to_stack return value")
      .def_readonly("stack", &Bmad::ExpressionStringToStack::stack)
      .def_readonly("n_stack", &Bmad::ExpressionStringToStack::n_stack)
      .def_readonly("err_flag", &Bmad::ExpressionStringToStack::err_flag)
      .def_readonly("err_str", &Bmad::ExpressionStringToStack::err_str)
      .def("__len__", [](const Bmad::ExpressionStringToStack&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::ExpressionStringToStack& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.stack);
            if (i == 1)
              return py::cast(s.n_stack);
            if (i == 2)
              return py::cast(s.err_flag);
            if (i == 3)
              return py::cast(s.err_str);
            return py::none();
          });
  m.def(
      "expression_value",
      &Bmad::expression_value,
      py::arg("expression"),
      py::arg("var") = py::none(),
      py::arg("use_old") = py::none(),
      R"""(Routine to evaluate a mathematical expression encoded in a string.

Parameters
----------
expression : unknown
    Expression string.
var : ControlVar1Struct, optional
    Array of control variables. Used with Bmad controller elements.
use_old : bool, optional
    Use var.old_value? Must be present if var(:) is present.

Return value is a dictionary containing values below.


Returns
-------
value : float
    Value of the expression.
err_flag : bool
    True if there is an evaluation problem. False otherwise.
err_str : unknown
    Error string explaining error if there is one.

Notes
-----
Related routines:
expression_string_to_stack expression_stack_value
)""");
  py::class_<Bmad::ExpressionValue, std::unique_ptr<Bmad::ExpressionValue>>(
      m, "ExpressionValue", "Fortran routine expression_value return value")
      .def_readonly("err_flag", &Bmad::ExpressionValue::err_flag)
      .def_readonly("err_str", &Bmad::ExpressionValue::err_str)
      .def_readonly("value", &Bmad::ExpressionValue::value)
      .def("__len__", [](const Bmad::ExpressionValue&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ExpressionValue& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.err_str);
            if (i == 2)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "expression_stack_value",
      &Bmad::expression_stack_value,
      py::arg("stack"),
      py::arg("var") = py::none(),
      py::arg("use_old") = py::none(),
      R"""(Routine to evaluate a mathematical expression represented by an "expression stack".

Expression stacks are created by expression_string_to_stack.

Parameters
----------
stack : ExpressionAtomStruct
    Expression to evaluate.
var : ControlVar1Struct, optional
    Array of control variables. Used with Bmad controller elements.
use_old : bool, optional
    Use var.old_value? Must be present if var(:) is present.

Return value is a dictionary containing values below.


Returns
-------
value : float
    Value of the expression.
err_flag : bool
    True if there is an evaluation problem. False otherwise.
err_str : unknown
    Error string explaining error if there is one.

Notes
-----
Related routines:
expression_value expression_string_to_stack
)""");
  py::class_<
      Bmad::ExpressionStackValue,
      std::unique_ptr<Bmad::ExpressionStackValue>>(
      m,
      "ExpressionStackValue",
      "Fortran routine expression_stack_value return value")
      .def_readonly("err_flag", &Bmad::ExpressionStackValue::err_flag)
      .def_readonly("err_str", &Bmad::ExpressionStackValue::err_str)
      .def_readonly("value", &Bmad::ExpressionStackValue::value)
      .def("__len__", [](const Bmad::ExpressionStackValue&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ExpressionStackValue& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.err_str);
            if (i == 2)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "expression_stack_to_string",
      &Bmad::expression_stack_to_string,
      py::arg("stack"),
      py::arg("polish") = py::none(),
      R"""(Routine to convert an expression stack to a string

Parameters
----------
stack : ExpressionAtomStruct
    arithmetic expression
polish : , optional
    logical, optional, Construct expression in reverse polish? Default is False.

Returns
-------
str : unknown
    : Expression in string form.
)""");
  m.def(
      "linear_coef",
      &Bmad::linear_coef,
      py::arg("stack"),
      R"""(Routine to return the linear coefficient of a linear expression.

Parameters
----------
stack : ExpressionAtomStruct
    Expression stack.

Return value is a dictionary containing values below.


Returns
-------
err_flag : bool
    Set True if the expression is not linear
coef : float
    Linear coefficient.
)""");
  py::class_<Bmad::LinearCoef, std::unique_ptr<Bmad::LinearCoef>>(
      m, "LinearCoef", "Fortran routine linear_coef return value")
      .def_readonly("err_flag", &Bmad::LinearCoef::err_flag)
      .def_readonly("coef", &Bmad::LinearCoef::coef)
      .def("__len__", [](const Bmad::LinearCoef&) { return 2; })
      .def(
          "__getitem__", [](const Bmad::LinearCoef& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.coef);
            return py::none();
          });
  m.def(
      "add_superimpose",
      &Bmad::add_superimpose,
      py::arg("lat"),
      py::arg("super_ele_in"),
      py::arg("ix_branch"),
      py::arg("save_null_drift") = py::none(),
      py::arg("create_jumbo_slave") = py::none(),
      py::arg("ix_insert") = py::none(),
      py::arg("mangle_slave_names") = py::none(),
      py::arg("wrap") = py::none(),
      R"""(save_null_drift, create_jumbo_slave, ix_insert, mangle_slave_names, wrap)

Routine to superimpose an element. If the element can be inserted
into the lat without making a super_lord element then this will be done.

Parameters
----------
lat : LatStruct
    Lat to modify.
    This parameter is an input/output and is modified in-place. As an output: Modified lat.
super_ele_in : EleStruct
    Element to superimpose. .s               -- Position of end of element. Negative distances mean distance
    from the end.
ix_branch : int
    Branch index to put element.
save_null_drift : bool, optional
    Save a copy of a drift to be split as a null_ele? This is useful if further superpositions might use this
    drift as a reference element. After all superpositions are done, remove_eles_from_lat can be called to
    remove all null_eles. Default is False.
create_jumbo_slave : bool, optional
    Default is False. If True then super_slaves that are created that have super_ele_in as their super_lord
    are em_field elements.
ix_insert : int, optional
    If present and positive, and super_ele_in has zero length, use ix_insert as the index to insert
    super_ele_in at. ix_insert is useful when superposing next to another element that has zero or negative
    length (EG a patch) and you want to make sure that the superimposed element is on the correct side of the
    element.
mangle_slave_names : bool, optional
    If True (default), adjust slave names appropriately. Name mangeling can take time so bmad_parser will do
    this all at once at the end.
wrap : bool, optional
    If True (default), and if the superimposed element has an end that extends beyond the starting or ending
    edge of the lattice, wrap the element around the lattice so that the beginning portion of the element is
    at the lattice ending edge and the rest of the element is at the lattice start edge. If wrap = False, and
    the superimposed element has an end that extends beyound a lattice edge, extend the lattice to
    accommodate.

Return value is a dictionary containing values below.


Returns
-------
err_flag : bool
    Set True if there is an error. False otherwise
super_ele_out : EleStruct
    Pointer to the super element in the lattice.
)""");
  py::class_<Bmad::AddSuperimpose, std::unique_ptr<Bmad::AddSuperimpose>>(
      m, "AddSuperimpose", "Fortran routine add_superimpose return value")
      .def_readonly("err_flag", &Bmad::AddSuperimpose::err_flag)
      .def_readonly("super_ele_out", &Bmad::AddSuperimpose::super_ele_out)
      .def("__len__", [](const Bmad::AddSuperimpose&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::AddSuperimpose& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.super_ele_out);
            return py::none();
          });
  m.def(
      "adjust_super_slave_names",
      &python_adjust_super_slave_names,
      py::arg("lat"),
      py::arg("ix1_lord"),
      py::arg("ix2_lord"),
      py::arg("first_time") = py::none(),
      R"""(Routine to adjust the names of the slaves.

This routine is used by add_superimpose and is not meant for general use.

)""");
  py::class_<PyAdjustSuperSlaveNames, std::unique_ptr<PyAdjustSuperSlaveNames>>(
      m,
      "AdjustSuperSlaveNames",
      "Fortran routine adjust_super_slave_names return value")
      .def_readonly("ix1_lord", &PyAdjustSuperSlaveNames::ix1_lord)
      .def_readonly("ix2_lord", &PyAdjustSuperSlaveNames::ix2_lord)
      .def_readonly("first_time", &PyAdjustSuperSlaveNames::first_time)
      .def("__len__", [](const PyAdjustSuperSlaveNames&) { return 3; })
      .def(
          "__getitem__",
          [](const PyAdjustSuperSlaveNames& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix1_lord);
            if (i == 1)
              return py::cast(s.ix2_lord);
            if (i == 2)
              return py::cast(s.first_time);
            return py::none();
          });
  m.def(
      "release_rad_int_cache",
      &python_release_rad_int_cache,
      py::arg("ix_cache"),
      R"""(Subroutine to release the memory associated with caching wiggler values.

See the radiation_integrals routine for further details.

Parameters
----------
ix_cache : int
    Cache number.
    This parameter is an input/output and is modified in-place. As an output: Cache number set to 0,
)""");
  py::class_<PyReleaseRadIntCache, std::unique_ptr<PyReleaseRadIntCache>>(
      m,
      "ReleaseRadIntCache",
      "Fortran routine release_rad_int_cache return value")
      .def_readonly("ix_cache", &PyReleaseRadIntCache::ix_cache)
      .def("__len__", [](const PyReleaseRadIntCache&) { return 1; })
      .def(
          "__getitem__",
          [](const PyReleaseRadIntCache& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_cache);
            return py::none();
          });
  m.def(
      "track1_radiation",
      &Bmad::track1_radiation,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("edge"),
      R"""(Subroutine to apply a kick to a particle to account for radiation dampling and/or fluctuations.

For tracking through a given element, this routine should be called initially when
the particle is at the entrance end and at the end when the particle is at the exit end, when
the orbit is with respect to laboratory (not element body) coordinates.
That is, each time this routine is called it applies half the radiation kick for the entire element.

Parameters
----------
orbit : CoordStruct
    Particle position before radiation applied.
    This parameter is an input/output and is modified in-place. As an output: Particle position after
    radiation has been applied.
ele : EleStruct
    Element generating radiation.
edge : int
    Where the particle is: start_edge$ or end_edge$.
)""");
  m.def(
      "radiation_map_setup",
      &Bmad::radiation_map_setup,
      py::arg("ele"),
      py::arg("ref_orbit_in") = py::none(),
      R"""(Routine to calculate the radiation kick for a lattice element.

Parameters
----------
ele : EleStruct
    Element whose map is to be setup.
    This parameter is an input/output and is modified in-place. As an output: Element with map calculated.
ref_orb : CoordStruct, optional
    If present, ignore ele_map.stale setting and make the map around this reference orbit.

Returns
-------
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "track1_radiation_center",
      &Bmad::track1_radiation_center,
      py::arg("orbit"),
      py::arg("ele1"),
      py::arg("ele2"),
      py::arg("rad_damp") = py::none(),
      py::arg("rad_fluct") = py::none(),
      R"""(Used for elements that have been split in half: This routine applies a kick to a particle

to account for radiation dampling and/or fluctuations.

Parameters
----------
orbit : CoordStruct
    Particle at center of element before radiation applied.
    This parameter is an input/output and is modified in-place. As an output: Particle position after
    radiation has been applied.
ele1 : EleStruct
    First half of the split element.
ele2 : EleStruct
    Second half of the split element.
rad_damp : bool, optional
    If present, override setting of bmad_com.radiation_damping_on.
rad_fluct : bool, optional
    If present, override setting of bmad_com.radiation_fluctuations_on.

Notes
-----
Related routines:
track1_radiation.
)""");
  m.def(
      "twiss_and_track_at_s",
      &Bmad::twiss_and_track_at_s,
      py::arg("lat"),
      py::arg("s"),
      py::arg("ele_at_s") = py::none(),
      py::arg("orb") = py::none(),
      py::arg("orb_at_s") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("use_last") = py::none(),
      py::arg("compute_floor_coords") = py::none(),
      R"""(Subroutine to return the twiss parameters and particle orbit at a

given longitudinal position.
When calculating the Twiss parameters, this routine assumes
that the lattice elements already contain the Twiss parameters calculated
for the ends of the elements.
Additionally, the orbit at the ends of the elements (contained in orb(:)) must be
precomputed when orb_at_s is present.
Precomputation of Twiss and orbit at the element ends may be done with the twiss_and_track routine.
See also:
twiss_and_track_from_s_to_s
twiss_and_track_intra_ele

Parameters
----------
lat : LatStruct
    Lattice.
s : float
    Longitudinal position. If s is negative the the position is taken to be lat.param.total_length - s.
ele_at_s : EleStruct, optional
    If the use_last argument is True, ele_at_s is taken to contain valid Twiss parameters stored from a
    previous call to this routine.
    This parameter is an input/output and is modified in-place. As an output: Element structure holding the
    Twiss parameters.
orb : CoordStruct, optional
    Orbit through the Lattice.
orb_at_s : CoordStruct, optional
    If the use_last argument is True, orb_at_s is taken to contain the valid orbit stored from a previous
    call.
    This parameter is an input/output and is modified in-place. As an output: Particle position at the
    position s.
ix_branch : int, optional
    Branch index, Default is 0 (main lattice).
use_last : bool, optional
    If present and True, and if ele_at_s.s < s, then use ele_at_s and orb_at_s as the starting point for the
    present calculation. This can speed things up when the present s-position is in the middle of a long
    complicated element and the tracking (EG: Runge-Kutta) is slow.
compute_floor_coords : bool, optional
    If present and True then the global "floor" coordinates (without -- logical, optional: If present and True
    then the global "floor" coordinates (without misalignments) will be calculated and put in ele_at_s.floor.

Returns
-------
err : bool
    Set True if there is a problem in the calculation, False otherwise.
)""");
  m.def(
      "create_sol_quad_model",
      &Bmad::create_sol_quad_model,
      py::arg("sol_quad"),
      py::arg("lat"),
      R"""(Routine to create series of solenoid and quadrupole elements to serve as a replacement

model for a sol_quad element.
This routine is helpful for translating bmad lattices to a language that does not
implement a combination solenoid/quadrupole.
Not yet implemented!

)""");
  m.def(
      "create_planar_wiggler_model",
      &Bmad::create_planar_wiggler_model,
      py::arg("wiggler_in"),
      py::arg("print_err") = py::none(),
      R"""(Routine to create series of bend and drift elements to serve as a replacement

model for a planar wiggler.
This routine is helpful for translating bmad lattices to a language that does not
implement the Bmad wiggler model.
This routine uses the mrqmin nonlinear optimizer to vary the parameters in the wiggler
model to match:
Integral g^2 (I_2 radiation integral)
Integral g^3 (I_3 radiation integral)
Transfer matrix.
Also the endding horizontal transverse offset of the reference orbit (floor%r(1)) is
matched to zero.

Parameters
----------
wiggler : EleStruct
    Planar model wiggler to match to.
wig_model_com : WigglerModelingCommonStruct
    Global variable that can be used to set weights and step sizes for the optimization.
print_err : bool, optional
    If True (default) print an error message if there is an error.

Return value is a dictionary containing values below.


Returns
-------
lat : LatStruct
    Lattice containing the wiggler model .ele(:)      -- Array of bends and drifts. .n_ele_track -- Number of
    elements in the model.
err_flag : bool
    Set True if there is an error.
)""");
  py::class_<
      Bmad::CreatePlanarWigglerModel,
      std::unique_ptr<Bmad::CreatePlanarWigglerModel>>(
      m,
      "CreatePlanarWigglerModel",
      "Fortran routine create_planar_wiggler_model return value")
      .def_readonly("lat", &Bmad::CreatePlanarWigglerModel::lat)
      .def_readonly("err_flag", &Bmad::CreatePlanarWigglerModel::err_flag)
      .def("__len__", [](const Bmad::CreatePlanarWigglerModel&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::CreatePlanarWigglerModel& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.lat);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "make_mat6_mad",
      &Bmad::make_mat6_mad,
      py::arg("ele"),
      py::arg("param"),
      py::arg("c0"),
      R"""(Subroutine to make the 6x6 transfer matrix for an element from the

2nd order MAD transport map. The map is stored in ele%taylor.
If the map exists then it is simply used to calculate ele%mat6.
If ele%taylor doesn't exist then calculate it.

Parameters
----------
ele : EleStruct
    Element with transfer matrix.
param : LatParamStruct
    Lattice parameters.
map : MadMapStruct
    2nd order map.
c0 : CoordStruct
    Coordinates at the beginning of element.

Returns
-------
c1 : CoordStruct
    Coordinates at the end of element.
)""");
  m.def(
      "mad_tmfoc",
      &Bmad::mad_tmfoc,
      py::arg("el"),
      py::arg("sk1"),
      R"""(Subroutine to compute the linear focussing functions.

The equivalent MAD-8 routine is: TMFOC

Parameters
----------
el : float
    Length.
sk1 : float
    Quadrupole strength.

Return value is a dictionary containing values below.


Returns
-------
c : float
    Cosine-like function.             c(k,l)
s : float
    Sine-like function.               s(k,l)
d : float
    Dispersion function.              d(k,l)
f : float
    Integral of dispersion function.  f(k,l)
)""");
  py::class_<Bmad::MadTmfoc, std::unique_ptr<Bmad::MadTmfoc>>(
      m, "MadTmfoc", "Fortran routine mad_tmfoc return value")
      .def_readonly("c", &Bmad::MadTmfoc::c)
      .def_readonly("s", &Bmad::MadTmfoc::s)
      .def_readonly("d", &Bmad::MadTmfoc::d)
      .def_readonly("f", &Bmad::MadTmfoc::f)
      .def("__len__", [](const Bmad::MadTmfoc&) { return 4; })
      .def("__getitem__", [](const Bmad::MadTmfoc& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.c);
        if (i == 1)
          return py::cast(s.s);
        if (i == 2)
          return py::cast(s.d);
        if (i == 3)
          return py::cast(s.f);
        return py::none();
      });
  m.def(
      "mad_tmsymm",
      &Bmad::mad_tmsymm,
      py::arg("te"),
      R"""(subroutine to symmertrize the 2nd order map t.

The equivalent MAD-8 routine is: tmsymm

Parameters
----------
te : float
    array to be symmertrized.
    This parameter is an input/output and is modified in-place. As an output: symmetrized array.
)""");
  m.def(
      "track1_mad",
      &Bmad::track1_mad,
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("param"),
      R"""(Subroutine to track through an element using a 2nd order transfer map.

Parameters
----------
orbit : CoordStruct
    Starting coords.
    This parameter is an input/output and is modified in-place. As an output: Ending coords.
ele : EleStruct
    Element to track through.
param : LatParamStruct
    Lattice parameters.
)""");
  m.def(
      "t6_to_b123",
      &Bmad::t6_to_b123,
      py::arg("t6"),
      py::arg("abz_tunes"),
      R"""(This decomposes the one-turn matrix according to Equation 56 from

"Alternative approach to general coupled linear optics" by A. Wolski. PRSTAB.

Parameters
----------
t6 : float
    1-turn transfer matrix.  RF assumed to be on.
abz_tunes : float
    a-mode and b-mode tunes.  Used to order eigensystem.

Return value is a dictionary containing values below.


Returns
-------
B1 : float
    Beta matrix associated with a-mode.
B2 : float
    Beta matrix associated with b-mode.
B3 : float
    Beta matrix associated with c-mode.
err_flag : bool
    Set True if there is an error. False otherwise
)""");
  py::class_<Bmad::T6ToB123, std::unique_ptr<Bmad::T6ToB123>>(
      m, "T6ToB123", "Fortran routine t6_to_b123 return value")
      .def_readonly("B1", &Bmad::T6ToB123::B1)
      .def_readonly("B2", &Bmad::T6ToB123::B2)
      .def_readonly("B3", &Bmad::T6ToB123::B3)
      .def_readonly("err_flag", &Bmad::T6ToB123::err_flag)
      .def("__len__", [](const Bmad::T6ToB123&) { return 4; })
      .def("__getitem__", [](const Bmad::T6ToB123& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.B1);
        if (i == 1)
          return py::cast(s.B2);
        if (i == 2)
          return py::cast(s.B3);
        if (i == 3)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "normal_mode3_calc",
      &Bmad::normal_mode3_calc,
      py::arg("t6"),
      py::arg("above_transition") = py::none(),
      py::arg("abz_tunes") = py::none(),
      R"""(Does an Eigen decomposition of the 1-turn transfer matrix (mat) and generates

B, V, H.
If the above_transition argument is present and false, then the 3rd (z) mode is assumed
to have a positive slip factor (z-mode rotates counter clockwise in phase space).
Default is True ==> z-mode has a negative slip factor so the mode rotates clock-wise in phase space.

Parameters
----------
mat : float
    1-turn transfer matrix
above_transition : bool, optional
    If present and false, then z-mode assumes positive slip factor. Else negative slip factor assumed.
abz_tunes : float, optional
    Tunes to order eigensystem by.

Return value is a dictionary containing values below.


Returns
-------
tune : float
    Tunes of the 3 normal modes (radians)
B : float
    B is block diagonal and related to the normal mode Twiss parameters.
HV : float
    Transforms from normal mode coordinates to canonical coordinates: x = H.V.a
)""");
  py::class_<Bmad::NormalMode3Calc, std::unique_ptr<Bmad::NormalMode3Calc>>(
      m, "NormalMode3Calc", "Fortran routine normal_mode3_calc return value")
      .def_readonly("tune", &Bmad::NormalMode3Calc::tune)
      .def_readonly("B", &Bmad::NormalMode3Calc::B)
      .def_readonly("HV", &Bmad::NormalMode3Calc::HV)
      .def("__len__", [](const Bmad::NormalMode3Calc&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::NormalMode3Calc& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.tune);
            if (i == 1)
              return py::cast(s.B);
            if (i == 2)
              return py::cast(s.HV);
            return py::none();
          });
  m.def(
      "make_hvbp",
      &Bmad::make_hvbp,
      py::arg("N"),
      R"""(Parameterizes the eigen-decomposition of the 6x6 transfer matrix into HVBP as defined in:

"From the beam-envelop matrix to synchrotron-radiation integrals" by Ohmi, Hirata, and Oide.
This routine takes N, which is usually made from make_N (also in this module), and decomposes
it into H, V, B, and P.
N is defined by:
M = N.U.Inverse[N] where U is block diagonal and the blocks are 2x2 rotation matrices.
and it is decomposed by this subroutine as,
N = H.V.B.P
P has the same free parameters as B
B "Twiss matrix" has 6 free parameters (Twiss alphas and betas)
B blocks have the form /     sqrt(beta)         0       \
\ -alpha/sqrt(beta) 1/sqrt(beta) /
V "Teng matrix" has 4 free parameters (xy, xpy, ypx, and pxpy coupling)
H "Dispersion matrix" has 8 free parameters (xz, xpz, pxz, pxpz, yz, ypz, pyz, pypz coupling)

Parameters
----------
N : float
    Matrix of eigenvectors prepared by make_N

Return value is a dictionary containing values below.


Returns
-------
B : float
    Block diagonal matrix of Twiss parameters
V : float
    horizontal-vertical coupling information
H : float
    horizontal-longitudinal and vertical-longitudinal coupling information
Vbar : float
    mat_symp_conj(B).V.B
Hbar : float
    mat_symp_conj(B).H.B
)""");
  py::class_<Bmad::MakeHvbp, std::unique_ptr<Bmad::MakeHvbp>>(
      m, "MakeHvbp", "Fortran routine make_hvbp return value")
      .def_readonly("B", &Bmad::MakeHvbp::B)
      .def_readonly("V", &Bmad::MakeHvbp::V)
      .def_readonly("H", &Bmad::MakeHvbp::H)
      .def_readonly("Vbar", &Bmad::MakeHvbp::Vbar)
      .def_readonly("Hbar", &Bmad::MakeHvbp::Hbar)
      .def("__len__", [](const Bmad::MakeHvbp&) { return 5; })
      .def("__getitem__", [](const Bmad::MakeHvbp& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.B);
        if (i == 1)
          return py::cast(s.V);
        if (i == 2)
          return py::cast(s.H);
        if (i == 3)
          return py::cast(s.Vbar);
        if (i == 4)
          return py::cast(s.Hbar);
        return py::none();
      });
  m.def(
      "action_to_xyz",
      &Bmad::action_to_xyz,
      py::arg("ring"),
      py::arg("ix"),
      py::arg("J"),
      R"""(Given the normal mode invariants and phases J of a particle, returns the canonical coordinates.

The J vector looks like:
J = (sqrt(2Ja)cos(phia), -sqrt(2Ja)sin(phia), sqrt(2Jb)cos(phib), -sqrt(2Jb)sin(phib), sqrt(2Jc)cos(phic), -sqrt(2Jc)sin(phic))
X is obtained from:
X = N . J
Where N is from the Eigen decomposition of the 1-turn transfer matrix.

Parameters
----------
ring : LatStruct
    lattice .a.tune   -- a-mode tune (horizontal-like) .b.tune   -- b-mode tune (vertical-like) .z.tune   --
    c-mode tune (synchrotron-like)
ix : int
    element index at which to calculate J
J : float
    Vector containing normal mode invariants and phases

Return value is a dictionary containing values below.


Returns
-------
X : float
    canonical phase space coordinates of the particle
err_flag : bool
    Set to true on error.  Often means Eigen decomposition failed.
)""");
  py::class_<Bmad::ActionToXyz, std::unique_ptr<Bmad::ActionToXyz>>(
      m, "ActionToXyz", "Fortran routine action_to_xyz return value")
      .def_readonly("X", &Bmad::ActionToXyz::X)
      .def_readonly("err_flag", &Bmad::ActionToXyz::err_flag)
      .def("__len__", [](const Bmad::ActionToXyz&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ActionToXyz& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.X);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "eigen_decomp_6mat",
      &Bmad::eigen_decomp_6mat,
      py::arg("mat"),
      R"""(Compute eigenvalues and eigenvectors of a real 6x6 matrix.

The evals and evecs are in general complex.

Parameters
----------
mat : float
    6x6 real matrix.  Usually a transfer matrix or sigma matrix.

Return value is a dictionary containing values below.


Returns
-------
eval : complex
    complex eigenvalues.
evec : complex
    complex eigenvectors arranged down columns.
err_flag : bool
    set to true if an error has occured.
tunes : float
    Mode tunes, in radians.
)""");
  py::class_<Bmad::EigenDecomp6mat, std::unique_ptr<Bmad::EigenDecomp6mat>>(
      m, "EigenDecomp6mat", "Fortran routine eigen_decomp_6mat return value")
      .def_readonly("eval", &Bmad::EigenDecomp6mat::eval)
      .def_readonly("evec", &Bmad::EigenDecomp6mat::evec)
      .def_readonly("err_flag", &Bmad::EigenDecomp6mat::err_flag)
      .def_readonly("tunes", &Bmad::EigenDecomp6mat::tunes)
      .def("__len__", [](const Bmad::EigenDecomp6mat&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::EigenDecomp6mat& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.eval);
            if (i == 1)
              return py::cast(s.evec);
            if (i == 2)
              return py::cast(s.err_flag);
            if (i == 3)
              return py::cast(s.tunes);
            return py::none();
          });
  m.def(
      "mytan",
      &python_mytan,
      py::arg("y"),
      py::arg("x"),
      py::arg("arg"),
      R"""(No docstring available

Parameters
----------
y : 
x : 
arg : 
)""");
  py::class_<PyMytan, std::unique_ptr<PyMytan>>(
      m, "Mytan", "Fortran routine mytan return value")
      .def_readonly("y", &PyMytan::y)
      .def_readonly("x", &PyMytan::x)
      .def_readonly("arg", &PyMytan::arg)
      .def("__len__", [](const PyMytan&) { return 3; })
      .def("__getitem__", [](const PyMytan& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        if (i == 1)
          return py::cast(s.x);
        if (i == 2)
          return py::cast(s.arg);
        return py::none();
      });
  m.def(
      "order_evecs_by_n_similarity",
      &Bmad::order_evecs_by_n_similarity,
      py::arg("eval"),
      py::arg("mat_tunes"),
      py::arg("Nmat"),
      R"""(This subroutine orderes the eigensystem such that Nmat.mat_symp_conj(N) is closest

to the identity.  Nmat is supplied externally.

Parameters
----------
eval : complex
    complex eigenvalues.
evecr : complex
    complex eigenvectors arranged down columns.
mat_tunes : float
    Three normal mode tunes, in radians.
    This parameter is an input/output and is modified in-place. As an output: Ordered normal mode tunes, in
    radians.
Nmat : float
    Normalized, real eigen matrix from make_N.

Return value is a dictionary containing values below.


Returns
-------
evec : complex
    complex eigenvectors arranged down columns.
err_flag : bool
    Set True if there is an error. False otherwise
)""");
  py::class_<
      Bmad::OrderEvecsByNSimilarity,
      std::unique_ptr<Bmad::OrderEvecsByNSimilarity>>(
      m,
      "OrderEvecsByNSimilarity",
      "Fortran routine order_evecs_by_n_similarity return value")
      .def_readonly("evec", &Bmad::OrderEvecsByNSimilarity::evec)
      .def_readonly("err_flag", &Bmad::OrderEvecsByNSimilarity::err_flag)
      .def("__len__", [](const Bmad::OrderEvecsByNSimilarity&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::OrderEvecsByNSimilarity& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.evec);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "order_evecs_by_plane_dominance",
      &Bmad::order_evecs_by_plane_dominance,
      py::arg("evec"),
      py::arg("eval"),
      py::arg("mat_tunes") = py::none(),
      R"""(This subroutine orderes the eigensystem according to which modes dominate the horizontal,

vertical, and longitudinal planes.  This subroutine works well in machines
that are not strongly coupled.  In machines with strong coupling, where the relation
between the three eigenmodes a, b, c and the three lab coordinates x, y, z can change
through the machine, this subroutine will not provide consistent ordering.

Parameters
----------
eval : complex
    complex eigenvalues.
    This parameter is an input/output and is modified in-place. As an output: Ordered complex eigenvalues.
evec : complex
    complex eigenvectors arranged down columns.
    This parameter is an input/output and is modified in-place. As an output: Ordered complex eigenvectors.
mat_tunes : float, optional
    Three normal mode tunes, in radians.
    This parameter is an input/output and is modified in-place. As an output: Reordered same as evecs.
)""");
  m.def(
      "order_evecs_by_tune",
      &Bmad::order_evecs_by_tune,
      py::arg("evec"),
      py::arg("eval"),
      py::arg("mat_tunes"),
      py::arg("abz_tunes"),
      R"""(This subroutine orders the eigensystem by matching the tunes of the eigensystem to

externally supplied tunes abz_tunes.  abz_tunes is in radians.

Parameters
----------
eval : complex
    complex eigenvalues.
    This parameter is an input/output and is modified in-place. As an output: Ordered eigenvalues.
evec : complex
    complex eigenvectors arranged down columns.
    This parameter is an input/output and is modified in-place. As an output: Ordered eigenvectors.
mat_tunes : float
    Three normal mode tunes, in radians.
abz_tunes : float
    Tunes to order eigensystem by.

Returns
-------
err_flag : bool
    Set to true if an error occured.
)""");
  m.def(
      "make_n",
      &Bmad::make_n,
      py::arg("t6"),
      py::arg("abz_tunes") = py::none(),
      R"""(Given a 1-turn transfer matrix, this returns the matrix N.

N converts between normal invarients and phases and canonical coordinates:
X = N.J
N is obtained from the Eigen decomposition of the 1-turn transfer matrix.
It is obtained by applying certain normalizations to the matrix of Eigen vectors, then making
the result real using Q.
If abz_tunes is present, then the eigensystem is ordered by matching the tunes.
If abz_tunes is not present, then the eigensystem is ordered by plane dominance.
It is assumed that the synchrotron tune is less than pi.

Parameters
----------
t6 : float
    1-turn transfer matrix
abz_tunes : float, optional
    a-mode is abz_tunes(1), b-mode is abz_tunes(2), synch tune is abz_tunes(3)

Return value is a dictionary containing values below.


Returns
-------
N : float
    X = N.J
err_flag : bool
    Set to true on error.  Often means Eigen decomposition failed.
tunes_out : float
    Fractional tune (in radians) of the 3 normal modes of t6.
U : float
    U = Inverse(N).t6.N.  Block diagonal matrix of 2x2 rotation matrices.
)""");
  py::class_<Bmad::MakeN, std::unique_ptr<Bmad::MakeN>>(
      m, "MakeN", "Fortran routine make_n return value")
      .def_readonly("N", &Bmad::MakeN::N)
      .def_readonly("err_flag", &Bmad::MakeN::err_flag)
      .def_readonly("tunes_out", &Bmad::MakeN::tunes_out)
      .def_readonly("U", &Bmad::MakeN::U)
      .def("__len__", [](const Bmad::MakeN&) { return 4; })
      .def("__getitem__", [](const Bmad::MakeN& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.N);
        if (i == 1)
          return py::cast(s.err_flag);
        if (i == 2)
          return py::cast(s.tunes_out);
        if (i == 3)
          return py::cast(s.U);
        return py::none();
      });
  m.def(
      "get_emit_from_sigma_mat",
      &Bmad::get_emit_from_sigma_mat,
      py::arg("sigma_mat"),
      py::arg("Nmat") = py::none(),
      R"""(Given a beam envelop sigma matrix sigma_mat, this returns the 3 normal mode

emittances.
The normal mode emittance of the sigma matrix are the eigenvalues of
sigma_mat . S
If Nmat is present, then the modes are ordered such that the eigensystem most
closely resembles Nmat.  If Nmat is not present, then the modes are ordered
according to which plane they dominate.
/ 0  1  0  0  0  0 \
|-1  0  0  0  0  0 |
S = | 0  0  0  1  0  0 |
| 0  0 -1  0  0  0 |
| 0  0  0  0  0  1 |
\ 0  0  0  0 -1  0 /

Parameters
----------
sigma_mat : float
    beam envelop sigma matrix
Nmat : float, optional
    If present, then the emittanced will be ordered such that the eigensystem most closely resembles Nmat.

Return value is a dictionary containing values below.


Returns
-------
normal : float
    normal mode emittances
err_flag : bool
    Set to true if something went wrong.  Otherwise set to false.
)""");
  py::class_<
      Bmad::GetEmitFromSigmaMat,
      std::unique_ptr<Bmad::GetEmitFromSigmaMat>>(
      m,
      "GetEmitFromSigmaMat",
      "Fortran routine get_emit_from_sigma_mat return value")
      .def_readonly("normal", &Bmad::GetEmitFromSigmaMat::normal)
      .def_readonly("err_flag", &Bmad::GetEmitFromSigmaMat::err_flag)
      .def("__len__", [](const Bmad::GetEmitFromSigmaMat&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::GetEmitFromSigmaMat& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.normal);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "beam_tilts",
      &Bmad::beam_tilts,
      py::arg("S"),
      R"""(Given a 6x6 matrix of second-order moments, this routine returns

the beam tilts.
angle_xy is obtained from the projection of the beam envelop into the
xy plane.  The angle is that between the major axis of the projected
beam envelope and the +x axis.  Positive angles are measured towards the
+y axis.
angle_xz is obtained from the projection of the beam envelop into the
xy plane.  The angle is that between the major axis of the projected beam envelope
and the +z axis.  Positive angles are measured towards the +x axis.
angle_yz is obtained from the projection of the beam envelop into the
yz plane.  The angle is that between the major axis of the projected beam envelope
and the +z axis.  Positive angles are measured towards the +y axis.

Parameters
----------
S : float
    matrix of second order moments of beam envelope

Return value is a dictionary containing values below.


Returns
-------
angle_xy : float
    transverse tilt of beam envelope
angle_xz : float
    horizontal crabbing of beam envelope
angle_yz : float
    vertical crabbing of beam envelope
angle_xpz : float
    x-pz coupling
angle_ypz : float
    y-pz coupling
)""");
  py::class_<Bmad::BeamTilts, std::unique_ptr<Bmad::BeamTilts>>(
      m, "BeamTilts", "Fortran routine beam_tilts return value")
      .def_readonly("angle_xy", &Bmad::BeamTilts::angle_xy)
      .def_readonly("angle_xz", &Bmad::BeamTilts::angle_xz)
      .def_readonly("angle_yz", &Bmad::BeamTilts::angle_yz)
      .def_readonly("angle_xpz", &Bmad::BeamTilts::angle_xpz)
      .def_readonly("angle_ypz", &Bmad::BeamTilts::angle_ypz)
      .def("__len__", [](const Bmad::BeamTilts&) { return 5; })
      .def("__getitem__", [](const Bmad::BeamTilts& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.angle_xy);
        if (i == 1)
          return py::cast(s.angle_xz);
        if (i == 2)
          return py::cast(s.angle_yz);
        if (i == 3)
          return py::cast(s.angle_xpz);
        if (i == 4)
          return py::cast(s.angle_ypz);
        return py::none();
      });
  m.def(
      "make_smat_from_abc",
      &Bmad::make_smat_from_abc,
      py::arg("t6"),
      py::arg("mode"),
      R"""(Given the 1-turn transfer matrix and a normal_modes_struct containing the normal mode

emittances, this routine returns the beam envelop sigma matrix.
sigma_mat = N.D.transpose(N)
equivalent to: sigma_mat.S = N.D.mat_symp_conj(N)
One way to populate mode%a%tune and mode%b%tune:
mode%a%tune = mod(lat%ele(lat%n_ele_track)%a%phi, twopi)
mode%b%tune = mod(lat%ele(lat%n_ele_track)%b%phi, twopi)

Parameters
----------
t6 : float
    1-turn transfer matrix
mode : NormalModesStruct
    normal mode emittances .a.emittance -- real(rp): a-mode emittance .b.emittance -- real(rp): b-mode
    emittance .z.emittance -- real(rp): z-mode emittance .a.tune      -- real(rp): a-mode tune.  Used to
    associate emittances with the proper mode. .b.tune      -- real(rp): b-mode tune.  Used to associate
    emittances with the proper mode. .z.tune      -- real(rp): z-mode tune.  Used to associate emittances with
    the proper mode.

Return value is a dictionary containing values below.


Returns
-------
sigma_mat : float
    beam envelop sigma matrix
err_flag : bool
    set to true if something goes wrong.  Usually means Eigen decomposition of the 1-turn matrix failed.
Nout : float
    Contains the normalized eigenvectors that were used to make the sigma matrix.
)""");
  py::class_<Bmad::MakeSmatFromAbc, std::unique_ptr<Bmad::MakeSmatFromAbc>>(
      m, "MakeSmatFromAbc", "Fortran routine make_smat_from_abc return value")
      .def_readonly("sigma_mat", &Bmad::MakeSmatFromAbc::sigma_mat)
      .def_readonly("err_flag", &Bmad::MakeSmatFromAbc::err_flag)
      .def_readonly("Nout", &Bmad::MakeSmatFromAbc::Nout)
      .def("__len__", [](const Bmad::MakeSmatFromAbc&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::MakeSmatFromAbc& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.sigma_mat);
            if (i == 1)
              return py::cast(s.err_flag);
            if (i == 2)
              return py::cast(s.Nout);
            return py::none();
          });
  m.def(
      "normalize_evecs",
      &Bmad::normalize_evecs,
      py::arg("evec"),
      R"""(Normalizes eigenvectors such that transpose(E).S.E = iS, where E = evec_r + i evec_i

Parameters
----------
evec : float
    complex eigenvectors arranged down columns.
    This parameter is an input/output and is modified in-place. As an output: Eigensystem normalized to be
    symplectic.

Returns
-------
err_flag : bool
    Set true of normalization is not possible due to amplitude is zero.
)""");
  m.def(
      "project_emit_to_xyz",
      &Bmad::project_emit_to_xyz,
      py::arg("ring"),
      py::arg("ix"),
      py::arg("mode"),
      R"""(Obtains the projected x, y, and z beamsizes by building the sigma matrix

from the normal mode emittances and 1-turn transfer matrix.
These projectes beamsize are what would be seen by instrumentation.
This method of projecting takes into account transverse and longitudinal coupling.
This method of obtaining the projected beam sizes is from "Alternitive approach to general
coupled linear optics" by Andrzej Wolski.
The normal mode emittances used to generate a beam envelop sigma matrix from the
1-turn transfer matrix.  The projected sizes are from the 1, 1 3, 3 and 5, 5 elements of
the sigma matrix.

Parameters
----------
ring : LatStruct
    the storage ring
ix : int
    element at which to make the projection
mode : NormalModesStruct
    normal mode emittances .a.emittance -- real(rp): a-mode emittance .b.emittance -- real(rp): b-mode
    emittance .z.emittance -- real(rp): z-mode emittance .a.tune      -- real(rp): a-mode tune.  Used to
    associate emittances with the proper mode. .b.tune      -- real(rp): b-mode tune.  Used to associate
    emittances with the proper mode.

Return value is a dictionary containing values below.


Returns
-------
sigma_x : float
    projected horizontal beamsize
sigma_y : float
    projected vertical beamsize
sigma_z : float
    projected longitudinal beamsize
)""");
  py::class_<Bmad::ProjectEmitToXyz, std::unique_ptr<Bmad::ProjectEmitToXyz>>(
      m, "ProjectEmitToXyz", "Fortran routine project_emit_to_xyz return value")
      .def_readonly("sigma_x", &Bmad::ProjectEmitToXyz::sigma_x)
      .def_readonly("sigma_y", &Bmad::ProjectEmitToXyz::sigma_y)
      .def_readonly("sigma_z", &Bmad::ProjectEmitToXyz::sigma_z)
      .def("__len__", [](const Bmad::ProjectEmitToXyz&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ProjectEmitToXyz& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.sigma_x);
            if (i == 1)
              return py::cast(s.sigma_y);
            if (i == 2)
              return py::cast(s.sigma_z);
            return py::none();
          });
  m.def(
      "twiss3_propagate_all",
      &Bmad::twiss3_propagate_all,
      py::arg("lat"),
      py::arg("ix_branch") = py::none(),
      R"""(Subroutine to propagate the twiss parameters using all three normal modes.

Subroutine from original mode3_mod.

Parameters
----------
lat : LatStruct
    Lattice
ix_branch : int, optional
    : Branch index. 0 = default.
)""");
  m.def(
      "twiss3_propagate1",
      &python_twiss3_propagate1,
      py::arg("ele1"),
      py::arg("ele2"),
      py::arg("err_flag"),
      R"""(Subroutine to propagate the twiss parameters using all three normal modes.

Subroutine from original mode3_mod.

)""");
  py::class_<PyTwiss3Propagate1, std::unique_ptr<PyTwiss3Propagate1>>(
      m, "Twiss3Propagate1", "Fortran routine twiss3_propagate1 return value")
      .def_readonly("err_flag", &PyTwiss3Propagate1::err_flag)
      .def("__len__", [](const PyTwiss3Propagate1&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTwiss3Propagate1& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "twiss3_from_twiss2",
      &Bmad::twiss3_from_twiss2,
      py::arg("ele"),
      R"""(Routine to calculate the 3D Twiss parameters given the 2D transverse Twiss parameters and some

longitudinal parameters.

Parameters
----------
ele : EleStruct
    Lattice element at which the calculation is made.
    This parameter is an input/output and is modified in-place. As an output: Element

Notes
-----
Related routines:
twiss3_at_start
)""");
  m.def(
      "twiss3_at_start",
      &python_twiss3_at_start,
      py::arg("lat"),
      py::arg("err_flag"),
      py::arg("ix_branch") = py::none(),
      R"""(Subroutine to calculate the 3D twiss parameters of the three modes of the full 6D 1-turn transfer matrix.

This routine is for lattices with closed geometries. For open lattices see: twiss3_from_twiss2.

Parameters
----------
lat : LatStruct
    Lattice with
ix_branch : int, optional
    Branch index. 0 = default.

Return value is a dictionary containing values below.


Returns
-------
error : bool
    Set True if there is no RF. False otherwise.
tune3 : float
    Normal mode tunes
)""");
  py::class_<PyTwiss3AtStart, std::unique_ptr<PyTwiss3AtStart>>(
      m, "Twiss3AtStart", "Fortran routine twiss3_at_start return value")
      .def_readonly("tune3", &PyTwiss3AtStart::tune3)
      .def_readonly("err_flag", &PyTwiss3AtStart::err_flag)
      .def("__len__", [](const PyTwiss3AtStart&) { return 2; })
      .def("__getitem__", [](const PyTwiss3AtStart& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.tune3);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "attribute_index1",
      &python_attribute_index1,
      py::arg("ele"),
      py::arg("name"),
      py::arg("full_name") = py::none(),
      py::arg("can_abbreviate") = py::none(),
      py::arg("print_error") = py::none(),
      py::arg("attrib_index"),
      R"""(Overloaded by attribute_index. See attribute_index for more details.


Returns
-------
attrib_index
)""");
  py::class_<PyAttributeIndex1, std::unique_ptr<PyAttributeIndex1>>(
      m, "AttributeIndex1", "Fortran routine attribute_index1 return value")
      .def_readonly("name", &PyAttributeIndex1::name)
      .def_readonly("full_name", &PyAttributeIndex1::full_name)
      .def_readonly("can_abbreviate", &PyAttributeIndex1::can_abbreviate)
      .def_readonly("print_error", &PyAttributeIndex1::print_error)
      .def_readonly("attrib_index", &PyAttributeIndex1::attrib_index)
      .def("__len__", [](const PyAttributeIndex1&) { return 5; })
      .def(
          "__getitem__",
          [](const PyAttributeIndex1& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.name);
            if (i == 1)
              return py::cast(s.full_name);
            if (i == 2)
              return py::cast(s.can_abbreviate);
            if (i == 3)
              return py::cast(s.print_error);
            if (i == 4)
              return py::cast(s.attrib_index);
            return py::none();
          });
  m.def(
      "attribute_index2",
      &python_attribute_index2,
      py::arg("key"),
      py::arg("name"),
      py::arg("full_name") = py::none(),
      py::arg("can_abbreviate") = py::none(),
      py::arg("print_error") = py::none(),
      py::arg("attrib_index"),
      R"""(Overloaded by attribute_index. See attribute_index for more details.


Returns
-------
attrib_index
)""");
  py::class_<PyAttributeIndex2, std::unique_ptr<PyAttributeIndex2>>(
      m, "AttributeIndex2", "Fortran routine attribute_index2 return value")
      .def_readonly("key", &PyAttributeIndex2::key)
      .def_readonly("name", &PyAttributeIndex2::name)
      .def_readonly("full_name", &PyAttributeIndex2::full_name)
      .def_readonly("can_abbreviate", &PyAttributeIndex2::can_abbreviate)
      .def_readonly("print_error", &PyAttributeIndex2::print_error)
      .def_readonly("attrib_index", &PyAttributeIndex2::attrib_index)
      .def("__len__", [](const PyAttributeIndex2&) { return 6; })
      .def(
          "__getitem__",
          [](const PyAttributeIndex2& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.key);
            if (i == 1)
              return py::cast(s.name);
            if (i == 2)
              return py::cast(s.full_name);
            if (i == 3)
              return py::cast(s.can_abbreviate);
            if (i == 4)
              return py::cast(s.print_error);
            if (i == 5)
              return py::cast(s.attrib_index);
            return py::none();
          });
  m.def(
      "attribute_name1",
      &python_attribute_name1,
      py::arg("key"),
      py::arg("ix_att"),
      py::arg("show_private") = py::none(),
      py::arg("attrib_name"),
      R"""(Overloaded by attribute_name. See attribute_name for more details.


Returns
-------
attrib_name
)""");
  py::class_<PyAttributeName1, std::unique_ptr<PyAttributeName1>>(
      m, "AttributeName1", "Fortran routine attribute_name1 return value")
      .def_readonly("key", &PyAttributeName1::key)
      .def_readonly("ix_att", &PyAttributeName1::ix_att)
      .def_readonly("show_private", &PyAttributeName1::show_private)
      .def_readonly("attrib_name", &PyAttributeName1::attrib_name)
      .def("__len__", [](const PyAttributeName1&) { return 4; })
      .def(
          "__getitem__", [](const PyAttributeName1& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.key);
            if (i == 1)
              return py::cast(s.ix_att);
            if (i == 2)
              return py::cast(s.show_private);
            if (i == 3)
              return py::cast(s.attrib_name);
            return py::none();
          });
  m.def(
      "attribute_name2",
      &python_attribute_name2,
      py::arg("ele"),
      py::arg("ix_att"),
      py::arg("show_private") = py::none(),
      py::arg("attrib_name"),
      R"""(Overloaded by attribute_name. See attribute_name for more details.


Returns
-------
attrib_name
)""");
  py::class_<PyAttributeName2, std::unique_ptr<PyAttributeName2>>(
      m, "AttributeName2", "Fortran routine attribute_name2 return value")
      .def_readonly("ix_att", &PyAttributeName2::ix_att)
      .def_readonly("show_private", &PyAttributeName2::show_private)
      .def_readonly("attrib_name", &PyAttributeName2::attrib_name)
      .def("__len__", [](const PyAttributeName2&) { return 3; })
      .def(
          "__getitem__", [](const PyAttributeName2& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_att);
            if (i == 1)
              return py::cast(s.show_private);
            if (i == 2)
              return py::cast(s.attrib_name);
            return py::none();
          });
  m.def(
      "init_attribute_name_array",
      &Bmad::init_attribute_name_array,
      R"""(Private routine to initialize the attribute name array used by routines

in attribute_mod. Not meant for general use.

)""");
  m.def(
      "init_attribute_name1",
      &Bmad::init_attribute_name1,
      py::arg("ix_key"),
      py::arg("ix_attrib"),
      py::arg("name"),
      py::arg("attrib_state") = py::none(),
      py::arg("override") = py::none(),
      R"""(Routine to initialize a single name in the element attribute name table.

Parameters
----------
ix_key : int
    Key index.
ix_attrib : int
    Attribute index.
name : unknown
    Attribute name. Should be uppercase if attrib_state = is_free$. Should contain non-uppercase characters if
    attrib_state = private$.
attrib_state : int, optional
    Class of attribute: does_not_exist$, is_free$, etc. Defaults to is_free$.
override : bool, optional
    Normally this routine throws an error if the [ix_key, ix_attrib] has been set previously. If override =
    True then the set is done and no error is generated.
)""");
  m.def(
      "has_orientation_attributes",
      &Bmad::has_orientation_attributes,
      py::arg("ele"),
      R"""(Routine to determine whether an element has orientation attributes like x_offset, etc.

Parameters
----------
ele : EleStruct
    Lattice element.

Returns
-------
has_attribs : bool
    True if ele has orientation attributes. False otherwise.

Notes
-----
Related routines:
has_attribute function.
)""");
  m.def(
      "attribute_type",
      &Bmad::attribute_type,
      py::arg("attrib_name"),
      py::arg("ele") = py::none(),
      R"""(Routine to return the logical type of an attribute.

A "switch" attribute is an attribute whose value corresponds to some string.
For example, the "COUPLER_AT" attirbute with value 1 corresponds to "ENTRANCE_END", etc.
A "struct" attribute is an attribute that is the name for a "structure". For example,
CARTESIAN_MAP is the name of the structure hoding a Cartesian map.
If attrib_name corresponds to a switch attribute, The routine switch_attrib_value_name can
be used to print the name corresponding to the attribute's value.

Parameters
----------
attrib_name : unknown
    Name of the attribute. Must be upper case.
ele : EleStruct, optional
    Element associated with the attribute. Needed if attrib_name can correspond to an overlay or group
    variable.

Returns
-------
attrib_type : int
    Attribute type: is_string$, is_logical$, is_integer$, is_real$, is_switch$, is_struct$ or invalid_name$
    Note: An overlay or group variable will be marked invalid_name$ if ele is missing.
)""");
  m.def(
      "attribute_units",
      &Bmad::attribute_units,
      py::arg("attrib_name"),
      py::arg("unrecognized_units") = py::none(),
      R"""(Routine to return the units associated with an attribute.

Example: attrib_units('P0C') -> 'eV'

Parameters
----------
attrib_name : unknown
    Name of the attribute. Must be upper case.
unrecognized_units : unknown, optional
    String to use if the attribute name is unrecognized. Note: Non-real attributes (EG: 'TRACKING_METHOD') are
    not recognized. Default is ""

Returns
-------
attrib_units : unknown
    Units associated with the attribute.
)""");
  m.def(
      "string_attrib",
      &Bmad::string_attrib,
      py::arg("attrib_name"),
      py::arg("ele"),
      R"""(Routine to return the value of a string attribute of a lattice element.

This routine is useful when attrib_name is specified by the program user.
For example:
call string_attrib ('NAME', ele, attrib_value)  ! Will return attrib_value = ele%name

Parameters
----------
attrib_name : unknown
    Name of the type of element attribute.
ele : EleStruct
    Lattice element.

Returns
-------
attrib_value : unknown
    The string associated with the attribute.
)""");
  m.def(
      "n_attrib_string_max_len",
      &Bmad::n_attrib_string_max_len,
      R"""(Routine to return the the maximum number of characters in any attribute

name known to bmad.


Returns
-------
max_len : int
    Maximum number of characters in any attribute name.
)""");
  m.def(
      "has_attribute",
      &python_has_attribute,
      py::arg("ele"),
      py::arg("attrib"),
      py::arg("has_it"),
      R"""(No docstring available

Parameters
----------
ele : 
attrib : 
has_it : 
)""");
  py::class_<PyHasAttribute, std::unique_ptr<PyHasAttribute>>(
      m, "HasAttribute", "Fortran routine has_attribute return value")
      .def_readonly("attrib", &PyHasAttribute::attrib)
      .def_readonly("has_it", &PyHasAttribute::has_it)
      .def("__len__", [](const PyHasAttribute&) { return 2; })
      .def("__getitem__", [](const PyHasAttribute& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.attrib);
        if (i == 1)
          return py::cast(s.has_it);
        return py::none();
      });
  m.def(
      "custom_attribute_ubound_index",
      &Bmad::custom_attribute_ubound_index,
      py::arg("ele_class"),
      R"""(Routine to return, for a given element class, the upper bound index for the ele%custom(:)

array which is needed to accomodate the registered custom attributes for that class.

Parameters
----------
ele_class : int
    Element class (key). EG: quadrupole$, etc.

Returns
-------
ix_ubound : int
    Maximum index needed.
)""");
  m.def(
      "set_custom_attribute_name",
      &Bmad::set_custom_attribute_name,
      py::arg("custom_name"),
      py::arg("custom_index") = py::none(),
      R"""(Routine to add custom element attributes to the element attribute name table.

Parameters
----------
custom_name : unknown
    Name of the custom attribute. If prefixed by "<class>::" then the custom name will be set only for that
    element class. Example: "quadrupole::error" will set the alias custom namefor quadrupoles.
custom_index : int, optional
    Index used in assigning where in the ele_struct the custom attribute is put. If not present or 0 then the
    next unused slot is used.

Returns
-------
err_flag : bool
    Set True if an error. False otherwise.
)""");
  m.def(
      "attribute_free1",
      &python_attribute_free1,
      py::arg("ix_ele"),
      py::arg("attrib_name"),
      py::arg("lat"),
      py::arg("err_print_flag") = py::none(),
      py::arg("except_overlay") = py::none(),
      py::arg("dependent_attribs_free") = py::none(),
      py::arg("why_not_free") = py::none(),
      py::arg("free"),
      R"""(This function overloaded by attribute_free. See attribute_free for more details.


Returns
-------
free
)""");
  py::class_<PyAttributeFree1, std::unique_ptr<PyAttributeFree1>>(
      m, "AttributeFree1", "Fortran routine attribute_free1 return value")
      .def_readonly("ix_ele", &PyAttributeFree1::ix_ele)
      .def_readonly("attrib_name", &PyAttributeFree1::attrib_name)
      .def_readonly("err_print_flag", &PyAttributeFree1::err_print_flag)
      .def_readonly("except_overlay", &PyAttributeFree1::except_overlay)
      .def_readonly(
          "dependent_attribs_free", &PyAttributeFree1::dependent_attribs_free)
      .def_readonly("why_not_free", &PyAttributeFree1::why_not_free)
      .def_readonly("free", &PyAttributeFree1::free)
      .def("__len__", [](const PyAttributeFree1&) { return 7; })
      .def(
          "__getitem__", [](const PyAttributeFree1& s, size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_ele);
            if (i == 1)
              return py::cast(s.attrib_name);
            if (i == 2)
              return py::cast(s.err_print_flag);
            if (i == 3)
              return py::cast(s.except_overlay);
            if (i == 4)
              return py::cast(s.dependent_attribs_free);
            if (i == 5)
              return py::cast(s.why_not_free);
            if (i == 6)
              return py::cast(s.free);
            return py::none();
          });
  m.def(
      "attribute_free2",
      &python_attribute_free2,
      py::arg("ele"),
      py::arg("attrib_name"),
      py::arg("err_print_flag") = py::none(),
      py::arg("except_overlay") = py::none(),
      py::arg("dependent_attribs_free") = py::none(),
      py::arg("why_not_free") = py::none(),
      py::arg("free"),
      R"""(This function overloaded by attribute_free. See attribute_free for more details.


Returns
-------
free
)""");
  py::class_<PyAttributeFree2, std::unique_ptr<PyAttributeFree2>>(
      m, "AttributeFree2", "Fortran routine attribute_free2 return value")
      .def_readonly("attrib_name", &PyAttributeFree2::attrib_name)
      .def_readonly("err_print_flag", &PyAttributeFree2::err_print_flag)
      .def_readonly("except_overlay", &PyAttributeFree2::except_overlay)
      .def_readonly(
          "dependent_attribs_free", &PyAttributeFree2::dependent_attribs_free)
      .def_readonly("why_not_free", &PyAttributeFree2::why_not_free)
      .def_readonly("free", &PyAttributeFree2::free)
      .def("__len__", [](const PyAttributeFree2&) { return 6; })
      .def(
          "__getitem__", [](const PyAttributeFree2& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.attrib_name);
            if (i == 1)
              return py::cast(s.err_print_flag);
            if (i == 2)
              return py::cast(s.except_overlay);
            if (i == 3)
              return py::cast(s.dependent_attribs_free);
            if (i == 4)
              return py::cast(s.why_not_free);
            if (i == 5)
              return py::cast(s.free);
            return py::none();
          });
  m.def(
      "attribute_free3",
      &python_attribute_free3,
      py::arg("ix_ele"),
      py::arg("ix_branch"),
      py::arg("attrib_name"),
      py::arg("lat"),
      py::arg("err_print_flag") = py::none(),
      py::arg("except_overlay") = py::none(),
      py::arg("dependent_attribs_free") = py::none(),
      py::arg("why_not_free") = py::none(),
      py::arg("free"),
      R"""(err_print_flag, except_overlay, dependent_attribs_free, why_not_free) result (free)

This function overloaded by attribute_free. See attribute_free for more details.

)""");
  py::class_<PyAttributeFree3, std::unique_ptr<PyAttributeFree3>>(
      m, "AttributeFree3", "Fortran routine attribute_free3 return value")
      .def_readonly("ix_ele", &PyAttributeFree3::ix_ele)
      .def_readonly("ix_branch", &PyAttributeFree3::ix_branch)
      .def_readonly("attrib_name", &PyAttributeFree3::attrib_name)
      .def_readonly("err_print_flag", &PyAttributeFree3::err_print_flag)
      .def_readonly("except_overlay", &PyAttributeFree3::except_overlay)
      .def_readonly(
          "dependent_attribs_free", &PyAttributeFree3::dependent_attribs_free)
      .def_readonly("why_not_free", &PyAttributeFree3::why_not_free)
      .def_readonly("free", &PyAttributeFree3::free)
      .def("__len__", [](const PyAttributeFree3&) { return 8; })
      .def(
          "__getitem__", [](const PyAttributeFree3& s, size_t i) -> py::object {
            if (i >= 8)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_ele);
            if (i == 1)
              return py::cast(s.ix_branch);
            if (i == 2)
              return py::cast(s.attrib_name);
            if (i == 3)
              return py::cast(s.err_print_flag);
            if (i == 4)
              return py::cast(s.except_overlay);
            if (i == 5)
              return py::cast(s.dependent_attribs_free);
            if (i == 6)
              return py::cast(s.why_not_free);
            if (i == 7)
              return py::cast(s.free);
            return py::none();
          });
  m.def(
      "field_attribute_free",
      &Bmad::field_attribute_free,
      py::arg("ele"),
      py::arg("attrib_name"),
      R"""(Routine to check if a field attribute is free to vary.

Field attributes are either normalized (EG K2 of a sextupole) or unnormalized (EG B2_GRADIENT of a sextupole).
Whether normalized or unnormalized attributes are free to vary will depend on the setting  of ele%field_master.
Generally, this routine should not be called directly. Use the routine attribute_free instead.

Parameters
----------
ele : EleStruct
    Element containing the attribute
attrib_name : unknown
    Name of the field attribute. Assumed upper case.

Returns
-------
free : bool
    Is the attribute free to vary? If the attribute is not recognized, free = True will be returned.
)""");
  m.def(
      "complex_taylor_clean",
      &Bmad::complex_taylor_clean,
      py::arg("complex_taylor"),
      R"""(No docstring available

Parameters
----------
complex_taylor : 
)""");
  m.def(
      "complex_taylor_make_unit",
      &Bmad::complex_taylor_make_unit,
      R"""(Subroutine to make the unit complex_taylor map:

r(out) = Map * r(in) = r(in)


Returns
-------
complex_taylor : ComplexTaylorStruct
    Unit complex_taylor map .
)""");
  m.def(
      "kill_complex_taylor",
      &Bmad::kill_complex_taylor,
      py::arg("complex_taylor"),
      R"""(Subroutine to deallocate a Bmad complex_taylor map.

Parameters
----------
complex_taylor : ComplexTaylorStruct
    complex_taylor to be deallocated. It is OK if complex_taylor has already been deallocated.
    This parameter is an input/output and is modified in-place. As an output: deallocated complex_taylor
    structure.
)""");
  m.def(
      "sort_complex_taylor_terms",
      &Bmad::sort_complex_taylor_terms,
      py::arg("complex_taylor_in"),
      R"""(Subroutine to sort the complex_taylor terms from "lowest" to "highest" of

a complex_taylor series.
This subroutine is needed because what comes out of PTC is not sorted.
Uses function complex_taylor_exponent_index to sort.

Parameters
----------
complex_taylor_in : ComplexTaylorStruct
    Unsorted complex_taylor series.

Returns
-------
complex_taylor_sorted : ComplexTaylorStruct
    Sorted complex_taylor series.

Notes
-----
Note: complex_taylor_sorted needs to have been initialized.
)""");
  m.def(
      "complex_taylor_exponent_index",
      &Bmad::complex_taylor_exponent_index,
      py::arg("expn"),
      R"""(Function to associate a unique number with a complex_taylor exponent.

The number associated with a complex_taylor_term that is used for the sort is:
number = sum(exp(i))*10^6 + exp(6)*10^5 + ... + exp(1)*10^0
where exp(1) is the exponent for x, exp(2) is the exponent for P_x, etc.

Parameters
----------
expn : int
    complex_taylor exponent

Returns
-------
index : int
    Sorted complex_taylor series.
)""");
  m.def(
      "complex_taylor_to_mat6",
      &Bmad::complex_taylor_to_mat6,
      py::arg("a_complex_taylor"),
      py::arg("r_in"),
      R"""(Subroutine to calculate, from a complex_taylor map and about some trajectory:

The 1st order (Jacobian) transfer matrix.

Parameters
----------
a_complex_taylor : ComplexTaylorStruct
    complex_taylor map.
r_in : complex
    Coordinates at the input.

Return value is a dictionary containing values below.


Returns
-------
vec0 : complex
    0th order tranfsfer map
mat6 : complex
    1st order transfer map (6x6 matrix).
r_out : complex
    Coordinates at output.
)""");
  py::class_<
      Bmad::ComplexTaylorToMat6,
      std::unique_ptr<Bmad::ComplexTaylorToMat6>>(
      m,
      "ComplexTaylorToMat6",
      "Fortran routine complex_taylor_to_mat6 return value")
      .def_readonly("vec0", &Bmad::ComplexTaylorToMat6::vec0)
      .def_readonly("mat6", &Bmad::ComplexTaylorToMat6::mat6)
      .def_readonly("r_out", &Bmad::ComplexTaylorToMat6::r_out)
      .def("__len__", [](const Bmad::ComplexTaylorToMat6&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ComplexTaylorToMat6& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.vec0);
            if (i == 1)
              return py::cast(s.mat6);
            if (i == 2)
              return py::cast(s.r_out);
            return py::none();
          });
  m.def(
      "mat6_to_complex_taylor",
      &Bmad::mat6_to_complex_taylor,
      py::arg("vec0"),
      py::arg("mat6"),
      R"""(Subroutine to form a first order complex_taylor map from the 6x6 transfer

matrix and the 0th order transfer vector.

Parameters
----------
vec0 : 
    0th order transfer vector.
mat6 : 
    6x6 transfer matrix.

Returns
-------
complex_taylor : ComplexTaylorStruct
    first order complex_taylor map.
)""");
  m.def(
      "track_complex_taylor",
      &Bmad::track_complex_taylor,
      py::arg("start_orb"),
      py::arg("complex_taylor"),
      R"""(Subroutine to track using a complex_taylor map.

Parameters
----------
complex_taylor : ComplexTaylorStruct
    complex_taylor map.
start_orb : complex
    Starting coords.

Returns
-------
end_orb : complex
    Ending coords.
)""");
  m.def(
      "truncate_complex_taylor_to_order",
      &Bmad::truncate_complex_taylor_to_order,
      py::arg("complex_taylor_in"),
      py::arg("order"),
      R"""(Subroutine to throw out all terms in a complex_taylor map that are above a certain order.

Parameters
----------
complex_taylor_in : ComplexTaylorStruct
    Input complex_taylor map.
order : int
    Order above which terms are dropped.

Returns
-------
complex_taylor_out : ComplexTaylorStruct
    Truncated complex_taylor map.
)""");
  m.def(
      "track1_bunch_hom",
      &Bmad::track1_bunch_hom,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("direction") = py::none(),
      py::arg("bunch_track") = py::none(),
      R"""(Subroutine to track a bunch of particles through an element including wakefields.

Parameters
----------
bunch : BunchStruct
    Starting bunch position.
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
ele : EleStruct
    The element to track through.
direction : int, optional
    +1 (default) -> Track forward, -1 -> Track backwards.
bunch_track : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: Track information appended to
    track.
)""");
  m.def(
      "init_beam_distribution",
      &python_init_beam_distribution,
      py::arg("ele"),
      py::arg("param"),
      py::arg("beam_init"),
      py::arg("modes") = py::none(),
      py::arg("print_p0c_shift_warning") = py::none(),
      py::arg("conserve_momentum") = py::none(),
      R"""(print_p0c_shift_warning, conserve_momentum)

Subroutine to initialize a beam of particles.
Initialization uses the downstream parameters of ele.

Parameters
----------
ele : EleStruct
    element to initialize distribution at (downstream end).
param : LatParamStruct
    Lattice parameters .particle              -- Type of particle.
beam_init : BeamInitStruct
    Use "getf beam_init_struct" for more details.
modes : NormalModesStruct, optional
    Normal mode parameters. See above.
print_p0c_shift_warning : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
shift_momentum : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.

Return value is a dictionary containing values below.


Returns
-------
beam : BeamStruct
    Structure with initialized particles.
err_flag : bool
    Set true if there is an error, false otherwise.
beam_init_set : BeamInitStruct
    Set to input beam_init with components like .a_emit set what is used in constructing the beam (which is
    different from beam_init.a_emit if this is set negative).
)""");
  py::class_<PyInitBeamDistribution, std::unique_ptr<PyInitBeamDistribution>>(
      m,
      "InitBeamDistribution",
      "Fortran routine init_beam_distribution return value")
      .def_readonly("beam", &PyInitBeamDistribution::beam)
      .def_readonly("err_flag", &PyInitBeamDistribution::err_flag)
      .def_readonly("beam_init_set", &PyInitBeamDistribution::beam_init_set)
      .def_readonly(
          "conserve_momentum", &PyInitBeamDistribution::conserve_momentum)
      .def("__len__", [](const PyInitBeamDistribution&) { return 4; })
      .def(
          "__getitem__",
          [](const PyInitBeamDistribution& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.beam);
            if (i == 1)
              return py::cast(s.err_flag);
            if (i == 2)
              return py::cast(s.beam_init_set);
            if (i == 3)
              return py::cast(s.conserve_momentum);
            return py::none();
          });
  m.def(
      "init_bunch_distribution",
      &python_init_bunch_distribution,
      py::arg("ele"),
      py::arg("param"),
      py::arg("beam_init"),
      py::arg("ix_bunch"),
      py::arg("modes") = py::none(),
      py::arg("print_p0c_shift_warning") = py::none(),
      py::arg("conserve_momentum") = py::none(),
      R"""(print_p0c_shift_warning, conserve_momentum)

Subroutine to initialize a distribution of particles of a bunch.
Initialization uses the downstream parameters of ele.
There are four distributions available:
'', or 'ran_gauss' -- Random gaussian distribution.
'ellipse'  -- concentric ellipses representing a Gaussian distribution
'grid'     -- uniform rectangular grid
'KV'       -- Kapchinsky-Vladimirsky distribution
See the Bmad manual for more information.
The distribution is matched to the Twiss parameters, centroid position, and Energy - z
correlation as specified. Coupling in the element ele is incorporated into the distribution.

Parameters
----------
ele : EleStruct
    element to initialize distribution at (downstream end).
param : LatParamStruct
    Lattice parameters
beam_init : BeamInitStruct
    Use "getf beam_init_struct" for more details.
ix_bunch : int
    Bunch index. 0 = bunch generated at time = 0.
modes : NormalModesStruct, optional
    Normal mode parameters. See above.
print_p0c_shift_warning : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
shift_momentum : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.

Return value is a dictionary containing values below.


Returns
-------
bunch : BunchStruct
    Structure with initialized particles.
err_flag : bool
    Set True if there is an error. False otherwise.
beam_init_used : BeamInitStruct
    Set to input beam_init with components like .a_emit set what is used in constructing the beam (which can
    be different from beam_init.a_emit if this is set negative). If reading from a file, beam_init_used will
    equal beam_init.
)""");
  py::class_<PyInitBunchDistribution, std::unique_ptr<PyInitBunchDistribution>>(
      m,
      "InitBunchDistribution",
      "Fortran routine init_bunch_distribution return value")
      .def_readonly("bunch", &PyInitBunchDistribution::bunch)
      .def_readonly("err_flag", &PyInitBunchDistribution::err_flag)
      .def_readonly("beam_init_used", &PyInitBunchDistribution::beam_init_used)
      .def_readonly(
          "conserve_momentum", &PyInitBunchDistribution::conserve_momentum)
      .def("__len__", [](const PyInitBunchDistribution&) { return 4; })
      .def(
          "__getitem__",
          [](const PyInitBunchDistribution& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.bunch);
            if (i == 1)
              return py::cast(s.err_flag);
            if (i == 2)
              return py::cast(s.beam_init_used);
            if (i == 3)
              return py::cast(s.conserve_momentum);
            return py::none();
          });
  m.def(
      "init_spin_distribution",
      &Bmad::init_spin_distribution,
      py::arg("beam_init"),
      py::arg("ele"),
      R"""(Initializes a spin distribution according to beam_init%spin.

Parameters
----------
beam_init : BeamInitStruct
    Initialization parameters .spin(3)  -- (x, y, z) spin coordinates ele

Returns
-------
bunch : BunchStruct
    Bunch of particles. .particle(:).spin
)""");
  m.def(
      "calc_bunch_params_slice",
      &Bmad::calc_bunch_params_slice,
      py::arg("bunch"),
      py::arg("bunch_params"),
      py::arg("plane"),
      py::arg("slice_center"),
      py::arg("slice_spread"),
      py::arg("err"),
      py::arg("print_err") = py::none(),
      py::arg("is_time_coords") = py::none(),
      py::arg("ele") = py::none(),
      R"""(Finds bunch parameters for a slice of the beam.

Parameters
----------
bunch : 
    bunch_struct
plane : int
    plane to slice through (x$, px$, & etc...)
slice_center : float
    Center to take slice about
slice_spread : float
    +/- spread in slice about center.
print_err : bool, optional
    If present and False then suppress "no eigen-system found" messages.
is_time_coords : bool, optional
    Default is False. If True, input bunch is using time coordinates in which case there will be a conversion
    to s-coords before bunch_params are computed.
ele : EleStruct, optional
    Element being tracked through. Must be present if is_time_coords = True. Output
params : BunchParamsStruct
err : bool
    Set True if there is an error.
)""");
  m.def(
      "calc_bunch_params_z_slice",
      &Bmad::calc_bunch_params_z_slice,
      py::arg("bunch"),
      py::arg("bunch_params"),
      py::arg("slice_bounds"),
      py::arg("err"),
      py::arg("print_err") = py::none(),
      py::arg("is_time_coords") = py::none(),
      py::arg("ele") = py::none(),
      R"""(Finds bunch parameters for a slice of the beam.

The slice is specified in terms of percentage of particles ordered by z-position.
For example, slice_bounds = [0.0, 0.5] specifies the trailing half of the bunch

Parameters
----------
bunch : 
    bunch_struct
slice_bounds : float
    Slice bounds in percentage of particles ordered by z-position. 0.0 is the back of the bunch and 1.0 is the
    front of the bunch.
print_err : bool, optional
    If present and False then suppress "no eigen-system found" messages.
is_time_coords : bool, optional
    Default is False. If True, input bunch is using time coordinates in which case there will be a conversion
    to s-coords before bunch_params are computed.
ele : EleStruct, optional
    Element being tracked through. Must be present if is_time_coords = True. Output
params : BunchParamsStruct
err : bool
    Set True if there is an error.
)""");
  m.def(
      "calc_bunch_params",
      &Bmad::calc_bunch_params,
      py::arg("bunch"),
      py::arg("bunch_params"),
      py::arg("error"),
      py::arg("print_err") = py::none(),
      py::arg("n_mat") = py::none(),
      py::arg("is_time_coords") = py::none(),
      py::arg("ele") = py::none(),
      R"""(Finds all bunch parameters defined in bunch_params_struct, both normal-mode

and projected. Projected parameters are found purely from the geometrical
distribution of the beam. Normal-Mode parameters are found using the method
developed in:
"Alternate approach to general coupled linear optics"
A. Wolski, PRST AB 9, 024001 (2006)

Parameters
----------
bunch : 
    Bunch_struct
print_err : bool, optional
    If present and False then suppress "no eigen-system found" messages.
is_time_coords : bool, optional
    Are particle coords using time coords. Default is False.
ele : EleStruct, optional
    Element being tracked through. Must be present if is_time_coords = True. Output
bunch_params : BunchParamsStruct
error : bool
    Set True if there is an error.
n_mat : float, optional
    N matrix defined in Wolski Eq 44 and used to convert from action-angle coords to lab coords (Wolski Eq
    51.).
)""");
  m.def(
      "calc_emittances_and_twiss_from_sigma_matrix",
      &Bmad::calc_emittances_and_twiss_from_sigma_matrix,
      py::arg("sigma_mat"),
      py::arg("print_err") = py::none(),
      R"""(Routine to calc emittances and Twiss function from a beam sigma matrix.

See: Andy Wolski "Alternative approach to general coupled linear optics".

Parameters
----------
sigma_mat : float
    Sigma matrix.
print_err : bool, optional
    If present and False then suppress "no eigen-system found" messages.

Return value is a dictionary containing values below.


Returns
-------
bunch_params : BunchParamsStruct
    Holds Twiss and emittance info.
error : bool
    Set True if there is an error. Can happen if the emittance of a mode is zero.
n_mat : float
    N matrix defined in Wolski Eq 44 and used to convert from action-angle coords to lab coords (Wolski Eq
    51.).
)""");
  py::class_<
      Bmad::CalcEmittancesAndTwissFromSigmaMatrix,
      std::unique_ptr<Bmad::CalcEmittancesAndTwissFromSigmaMatrix>>(
      m,
      "CalcEmittancesAndTwissFromSigmaMatrix",
      "Fortran routine calc_emittances_and_twiss_from_sigma_matrix return value")
      .def_readonly(
          "bunch_params",
          &Bmad::CalcEmittancesAndTwissFromSigmaMatrix::bunch_params)
      .def_readonly(
          "error", &Bmad::CalcEmittancesAndTwissFromSigmaMatrix::error)
      .def_readonly(
          "n_mat", &Bmad::CalcEmittancesAndTwissFromSigmaMatrix::n_mat)
      .def(
          "__len__",
          [](const Bmad::CalcEmittancesAndTwissFromSigmaMatrix&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::CalcEmittancesAndTwissFromSigmaMatrix& s,
             size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.bunch_params);
            if (i == 1)
              return py::cast(s.error);
            if (i == 2)
              return py::cast(s.n_mat);
            return py::none();
          });
  m.def(
      "calc_spin_params",
      &Bmad::calc_spin_params,
      py::arg("bunch"),
      R"""(Rotine to calculate spin averages

Parameters
----------
bunch : BunchStruct
    Bunch of spins

Returns
-------
bunch_params : BunchParamStruct
    Structure holding average centroid.spin(3) -- (x,y,z) polarization.
)""");
  m.def(
      "calc_bunch_sigma_matrix_etc",
      &python_calc_bunch_sigma_matrix_etc,
      py::arg("particle"),
      py::arg("charge"),
      py::arg("is_time_coords") = py::none(),
      py::arg("ele") = py::none(),
      R"""(Routine to find the sigma matrix elements of a particle distribution.

Parameters
----------
particle : CoordStruct
    Array of particles.
charge : float
    Particle charge or photon intensity.

Returns
-------
bunch_params : BunchParamsStruct
    Bunch parameters. .sigma(6,6) .centroid.vec(6) .centroid.p0c .rel_max(6) .rel_min(6)
)""");
  py::class_<
      PyCalcBunchSigmaMatrixEtc,
      std::unique_ptr<PyCalcBunchSigmaMatrixEtc>>(
      m,
      "CalcBunchSigmaMatrixEtc",
      "Fortran routine calc_bunch_sigma_matrix_etc return value")
      .def_readonly("bunch_params", &PyCalcBunchSigmaMatrixEtc::bunch_params)
      .def_readonly(
          "is_time_coords", &PyCalcBunchSigmaMatrixEtc::is_time_coords)
      .def("__len__", [](const PyCalcBunchSigmaMatrixEtc&) { return 2; })
      .def(
          "__getitem__",
          [](const PyCalcBunchSigmaMatrixEtc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.bunch_params);
            if (i == 1)
              return py::cast(s.is_time_coords);
            return py::none();
          });
  m.def(
      "psi_prime_sca",
      &Bmad::psi_prime_sca,
      py::arg("t"),
      py::arg("p"),
      py::arg("args"),
      R"""(This wraps the array-valued psi_prime function as a scalar.

See psi_prime comments for details.

Parameters
----------
t : float
    time relative to RF bucket
p : float
    psi(t)
args : float
    parameters and constants of DEQ

Returns
-------
dpdt : float
    dpsi_dt
)""");
  m.def(
      "solve_psi_adaptive",
      &Bmad::solve_psi_adaptive,
      py::arg("t0"),
      py::arg("t1"),
      py::arg("p0"),
      py::arg("args"),
      R"""(Solve dpsi/dt for psi(t1) using adaptive steps and method:

"Implicit Bulirsch-Stoer method of Bader and Deuflhard."
The boundary condition p0 is psi(t0)

Parameters
----------
t0 : float
    initial time
t1 : float
    final time
p0 : float
    Boundary condition psi(t0)
args : float
    Parameters.  See psi_prime comments for details.

Returns
-------
p1 : float
    psi(t1)
)""");
  m.def(
      "solve_psi_fixed_steps",
      &Bmad::solve_psi_fixed_steps,
      py::arg("t0"),
      py::arg("t1"),
      py::arg("p0"),
      py::arg("args"),
      R"""(Solve dpsi/dt for psi(t1) using fixed steps and method:

"Implicit Bulirsch-Stoer method of Bader and Deuflhard."
The boundary condition p0 is psi(t0).
Number of steps is determined by SIZE(p).

Parameters
----------
t0 : float
    initial time
t1 : float
    final time
p0 : float
    Boundary condition psi(t0)
args : float
    Parameters.  See psi_prime comments for details.

Return value is a dictionary containing values below.


Returns
-------
t : float
    Array of times from t0 to t1
p : float
    Array of psi evaluated at t(:)
)""");
  py::class_<
      Bmad::SolvePsiFixedSteps,
      std::unique_ptr<Bmad::SolvePsiFixedSteps>>(
      m,
      "SolvePsiFixedSteps",
      "Fortran routine solve_psi_fixed_steps return value")
      .def_readonly("t", &Bmad::SolvePsiFixedSteps::t)
      .def_readonly("p", &Bmad::SolvePsiFixedSteps::p)
      .def("__len__", [](const Bmad::SolvePsiFixedSteps&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::SolvePsiFixedSteps& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.t);
            if (i == 1)
              return py::cast(s.p);
            return py::none();
          });
  m.def(
      "integrate_psi",
      &Bmad::integrate_psi,
      py::arg("bound"),
      py::arg("p0"),
      py::arg("args"),
      R"""(Integrate psi(t) from -bound to +bound.  The integration is done in two parts.  First from 0 to -bound, then from

0 to +bound.

Parameters
----------
bound : float
    integration bound
p0 : float
    psi(0).  Boundary condition.
args : float
    Parameters and constants of DEQ.  See psi_prime comments for details.

Returns
-------
result : float
    Integral of psi from -bound to +bound.
)""");
  m.def(
      "find_normalization",
      &Bmad::find_normalization,
      py::arg("bound"),
      py::arg("p0"),
      py::arg("args"),
      R"""(Finds value for boundary condition psi(0) that results in integral

of psi(t) from -bound to +bound to be 1.0.  This is done with the secant method.
Repeadedly calls integrate_psi with different values for psi(0).

Parameters
----------
bound : float
    -bound and +bound are integration boundaries
p0 : float
    Boundary condition psi(0)
args : float
    Parameters and constants of DEQ.  See psi_prime comments for details.

Returns
-------
pnrml : float
    Value for psi(0) that results in integral of psi(t) from -bound to +bound being equal to 1.0
)""");
  m.def(
      "find_fwhm",
      &Bmad::find_fwhm,
      py::arg("bound"),
      py::arg("args"),
      R"""(Finds the full width at half max of psi(t).  fwhm * c_light / TwoRtTwoLnTwo is taken as the bunch length.

Steps followed:
Find value for p(0) that normalizes the solution to dpsi/dt.
Find max value of p(t) for the value of p(0) found in the previous step.
Find find tlower, tlower < 0, such that p(tlower) = pmax/2.
Find find tupper, tupper > 0, such that p(tupper) = pmax/2.
fwhm is tupper-tlower

Parameters
----------
bound : float
    -bound and +bound is integration bound.
args : float
    Parameters and constants of dpsi/dt.  See comments of psi_prime for details.

Returns
-------
fwhm : float
    Full width at half max of psi(t)
)""");
  m.def(
      "get_bl_from_fwhm",
      &Bmad::get_bl_from_fwhm,
      py::arg("bound"),
      py::arg("args"),
      R"""(Calculate bunch length as fwhm * c_light / TwoRtTwoLnTwo.

Where fwhm is full width at half max of solution to dpsi/dt.

Parameters
----------
bound : float
    -bound and +bound are lower and upper integration bound.
args : float
    Parameters and constants of dpsi/dt.  See comments of psi_prime for details.

Returns
-------
sigma : float
    Bunch length
)""");
  m.def(
      "set_pwd_ele",
      &Bmad::set_pwd_ele,
      py::arg("lat"),
      py::arg("mode0"),
      py::arg("inductance"),
      R"""(Simulates the effect of potential well distortion by adjusting lat%ele(ix_pwd)%taylor(6)%term(2)%coef for an

element in the lattice.  This element will apply a pz kick based on the z coordinate.
Element is assumed to be at lat%ele(1).  The ibs_ring driver program
inserts a taylor element into lat%ele(1) if set to perform pwd calculations.

Parameters
----------
lat : LatStruct
    lattice
mode0 : NormalModesStruct
    .sig_z and .z.sige_e should be populated before calling this subroutine.
inductance : float
    An inductance-like parameter describing the distortion of the potential well.

Returns
-------
sigma : float
    Bunch length
)""");
  m.def(
      "pwd_mat",
      &Bmad::pwd_mat,
      py::arg("lat"),
      py::arg("t6"),
      py::arg("inductance"),
      py::arg("sig_z"),
      R"""(Calculates potential well distortion as RF defocusing.  Calculates t6_pwd=t6.Mpwd,

where Mpwd is identity with 65 element proportional to the inductance.
Vpwd = -inductance * lat%param%n_part * e_charge * c_light**3 / SQRT(twopi) / sig_z**3 / omega_RF  !effective RF voltage from PWD
Mpwd(6,5) = omega_RF * Vpwd / c_light / lat%ele(0)%value(E_TOT$) * branch%ele(i)%value(l$) / lat%param%total_length

Parameters
----------
lat : LatStruct
    Bunch current in # per bunch .ele(0).value(E_TOT$) -- real(rp): Beam energy
t6 : float
    1-turn transfer matrix
inductance : float
    Longitudinal inductance in Henrys.  Something on the order of nH.
sig_z : float
    Bunch length.

Returns
-------
t6_pwd : float
    1-turn transfer matrix with PWD defocusing applied
)""");
  m.def(
      "diffusion_matrix_b",
      &python_diffusion_matrix_b,
      py::arg("gamma"),
      py::arg("g_tot"),
      py::arg("species"),
      py::arg("mat"),
      R"""(No docstring available

Parameters
----------
gamma : 
g_tot : 
species : 
mat : 
)""");
  py::class_<PyDiffusionMatrixB, std::unique_ptr<PyDiffusionMatrixB>>(
      m, "DiffusionMatrixB", "Fortran routine diffusion_matrix_b return value")
      .def_readonly("gamma", &PyDiffusionMatrixB::gamma)
      .def_readonly("g_tot", &PyDiffusionMatrixB::g_tot)
      .def_readonly("species", &PyDiffusionMatrixB::species)
      .def("__len__", [](const PyDiffusionMatrixB&) { return 3; })
      .def(
          "__getitem__",
          [](const PyDiffusionMatrixB& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.gamma);
            if (i == 1)
              return py::cast(s.g_tot);
            if (i == 2)
              return py::cast(s.species);
            return py::none();
          });
  m.def(
      "damping_matrix_d",
      &python_damping_matrix_d,
      py::arg("gamma"),
      py::arg("g_tot"),
      py::arg("B0"),
      py::arg("B1"),
      py::arg("delta"),
      py::arg("species"),
      py::arg("mat"),
      R"""(No docstring available

Parameters
----------
gamma : 
g_tot : 
B0 : 
B1 : 
delta : 
species : 
mat : 
)""");
  py::class_<PyDampingMatrixD, std::unique_ptr<PyDampingMatrixD>>(
      m, "DampingMatrixD", "Fortran routine damping_matrix_d return value")
      .def_readonly("gamma", &PyDampingMatrixD::gamma)
      .def_readonly("g_tot", &PyDampingMatrixD::g_tot)
      .def_readonly("B0", &PyDampingMatrixD::B0)
      .def_readonly("B1", &PyDampingMatrixD::B1)
      .def_readonly("delta", &PyDampingMatrixD::delta)
      .def_readonly("species", &PyDampingMatrixD::species)
      .def("__len__", [](const PyDampingMatrixD&) { return 6; })
      .def(
          "__getitem__", [](const PyDampingMatrixD& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.gamma);
            if (i == 1)
              return py::cast(s.g_tot);
            if (i == 2)
              return py::cast(s.B0);
            if (i == 3)
              return py::cast(s.B1);
            if (i == 4)
              return py::cast(s.delta);
            if (i == 5)
              return py::cast(s.species);
            return py::none();
          });
  m.def(
      "make_v",
      &Bmad::make_v,
      py::arg("M"),
      py::arg("V"),
      py::arg("abz_tunes"),
      R"""(For a one-turn transfer matrix M, this routine find the eigen matrix V.

V is ordered such that the per turn phase advance of its column pairs agree with abz_tunes.
It is normalized to be symplectic.

)""");
  m.def(
      "integrated_mats",
      &Bmad::integrated_mats,
      py::arg("eles"),
      py::arg("coos"),
      py::arg("Lambda"),
      py::arg("Theta"),
      py::arg("Iota"),
      py::arg("mode"),
      R"""()""");
  m.def(
      "envelope_radints_ibs",
      &Bmad::envelope_radints_ibs,
      py::arg("Lambda"),
      py::arg("Theta"),
      py::arg("Iota"),
      py::arg("eles"),
      py::arg("mode"),
      py::arg("tail_cut"),
      py::arg("npart"),
      py::arg("species"),
      R"""(Calculates damping decrement and emittance of the three

normal modes by integrating the IBS, SR diffusion, and SR damping matrices.
The IBS depends on the envelope, and so this routine iterates to
locate the equilibrium beam envelope. This iterative process can fail to converge.
The damping times can obtained from alpha using:
tau = lattice_length/c_light/alpha
alpha and emit are quantities for the three normal modes.
alpha and emit are ordered by plane dominance.
Only radiation from sbends and rbends is taken into account.
The one-turn transfer matrix at each element (slice) is obtained
by concatenating the individual element transfer matrices.

Parameters
----------
Lambda : float
    Integrated damping matrix.
Theta : float
    Integrated diffusion matrix.
Iota : float
    Integrated vertical excitation matrix.
eles : EleStruct
    array of element structures representing ring. .mat6(6,6)            -- real(rp): element transfer matrix.
    .value(l$)            -- real(rp): element (slice) length. .value(E_TOT$)        -- real(rp): Beam energy
    in element.
mode : unknown
    tune of a-mode. .b.tune                  -- real(rp): tune of b-mode. .z.tune                  --
    real(rp): tune of z-mode.
tail_cut : bool
    apply tail cut.
npart : float
    number of particles in bunch.
species : int
    Particle species.

Return value is a dictionary containing values below.


Returns
-------
alpha : float
    Normal mode damping decrements.
emit : float
    Normal mode emittances.
)""");
  py::class_<
      Bmad::EnvelopeRadintsIbs,
      std::unique_ptr<Bmad::EnvelopeRadintsIbs>>(
      m,
      "EnvelopeRadintsIbs",
      "Fortran routine envelope_radints_ibs return value")
      .def_readonly("alpha", &Bmad::EnvelopeRadintsIbs::alpha)
      .def_readonly("emit", &Bmad::EnvelopeRadintsIbs::emit)
      .def("__len__", [](const Bmad::EnvelopeRadintsIbs&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::EnvelopeRadintsIbs& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.alpha);
            if (i == 1)
              return py::cast(s.emit);
            return py::none();
          });
  m.def(
      "envelope_radints",
      &Bmad::envelope_radints,
      py::arg("Lambda"),
      py::arg("Theta"),
      py::arg("Iota"),
      py::arg("alpha"),
      py::arg("emit"),
      R"""(Calculates damping decrement and emittance of the three

normal modes from the integrate diffusion, damping, and vertical
excitation matrices names Lambda, Theta, and Iota, respectively.
These three matrices are obtained from the subroutine integrated_mats.
The damping times can obtained from alpha using:
tau = lattice_length/c_light/alpha

)""");
  m.def(
      "make_pbrh",
      &Bmad::make_pbrh,
      py::arg("M"),
      py::arg("abz_tunes"),
      R"""(Decomposes the 1-turn transfer matrix into normal mode twiss-like parameters,

according to Sec. IIIB of Ohmi, Hirata, and Oide paper.

Parameters
----------
M : float
    1-turn transfer matrix
abz_tunes : float
    tunes for a,b, and c modes.  Used to identify which eigenvector is associated with which mode.

Return value is a dictionary containing values below.


Returns
-------
P : complex
    Eqn. 97.  Phase advances.
Bp : complex
    Eqns. 89 & 101.  Beta functions.
R : complex
    Eqn. 99.  Transverse coupling.
H : complex
    Eqn. 100.  Longitudinal coupling.
)""");
  py::class_<Bmad::MakePbrh, std::unique_ptr<Bmad::MakePbrh>>(
      m, "MakePbrh", "Fortran routine make_pbrh return value")
      .def_readonly("P", &Bmad::MakePbrh::P)
      .def_readonly("Bp", &Bmad::MakePbrh::Bp)
      .def_readonly("R", &Bmad::MakePbrh::R)
      .def_readonly("H", &Bmad::MakePbrh::H)
      .def("__len__", [](const Bmad::MakePbrh&) { return 4; })
      .def("__getitem__", [](const Bmad::MakePbrh& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.P);
        if (i == 1)
          return py::cast(s.Bp);
        if (i == 2)
          return py::cast(s.R);
        if (i == 3)
          return py::cast(s.H);
        return py::none();
      });
  m.def(
      "ibs_matrix_c",
      &python_ibs_matrix_c,
      py::arg("sigma_mat"),
      py::arg("tail_cut"),
      py::arg("tau"),
      py::arg("energy"),
      py::arg("n_part"),
      py::arg("species"),
      py::arg("ibs_mat"),
      R"""(No docstring available

Parameters
----------
sigma_mat : 
tail_cut : 
tau : 
energy : 
n_part : 
species : 
ibs_mat : 
)""");
  py::class_<PyIbsMatrixC, std::unique_ptr<PyIbsMatrixC>>(
      m, "IbsMatrixC", "Fortran routine ibs_matrix_c return value")
      .def_readonly("tail_cut", &PyIbsMatrixC::tail_cut)
      .def_readonly("tau", &PyIbsMatrixC::tau)
      .def_readonly("energy", &PyIbsMatrixC::energy)
      .def_readonly("n_part", &PyIbsMatrixC::n_part)
      .def_readonly("species", &PyIbsMatrixC::species)
      .def("__len__", [](const PyIbsMatrixC&) { return 5; })
      .def("__getitem__", [](const PyIbsMatrixC& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.tail_cut);
        if (i == 1)
          return py::cast(s.tau);
        if (i == 2)
          return py::cast(s.energy);
        if (i == 3)
          return py::cast(s.n_part);
        if (i == 4)
          return py::cast(s.species);
        return py::none();
      });
  m.def(
      "beam_envelope_ibs",
      &Bmad::beam_envelope_ibs,
      py::arg("sigma_mat"),
      py::arg("tail_cut"),
      py::arg("tau"),
      py::arg("energy"),
      py::arg("n_part"),
      py::arg("species"),
      R"""(This is a sigma matrix based IBS calculation.

It takes the beam sigma matrix and returns a matrix with changes to the 2nd order
moments due to IBS.
Use ibs_mat to change the sigma matrix like this:
sigma_matrix_updated = sigma_matrix + ibs_mat*element_length
See subroutine transport_with_sr_and_ibs in this module.

Parameters
----------
sigma_mat : float
    beam sigma_matrix at element entrance
tail_cut : bool
    If true, then apply tail cut to coulomb logarithm.
tau : float
    horizontal betatron damping rate.  Needed if tail_cut is true.
energy : float
    beam energy in eV
n_part : float
    number of particles in the bunch
species : int
    Partical species.

Returns
-------
ibs_mat : float
    changes in 2nd order moments due to IBS are ibs_mat*element_length
)""");
  m.def(
      "etdiv",
      &python_etdiv,
      py::arg("A"),
      py::arg("B"),
      py::arg("C"),
      py::arg("D"),
      py::arg("E"),
      py::arg("F"),
      R"""(No docstring available

Parameters
----------
A : 
B : 
C : 
D : 
E : 
F : 
)""");
  py::class_<PyEtdiv, std::unique_ptr<PyEtdiv>>(
      m, "Etdiv", "Fortran routine etdiv return value")
      .def_readonly("A", &PyEtdiv::A)
      .def_readonly("B", &PyEtdiv::B)
      .def_readonly("C", &PyEtdiv::C)
      .def_readonly("D", &PyEtdiv::D)
      .def_readonly("E", &PyEtdiv::E)
      .def_readonly("F", &PyEtdiv::F)
      .def("__len__", [](const PyEtdiv&) { return 6; })
      .def("__getitem__", [](const PyEtdiv& s, size_t i) -> py::object {
        if (i >= 6)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.A);
        if (i == 1)
          return py::cast(s.B);
        if (i == 2)
          return py::cast(s.C);
        if (i == 3)
          return py::cast(s.D);
        if (i == 4)
          return py::cast(s.E);
        if (i == 5)
          return py::cast(s.F);
        return py::none();
      });
  m.def(
      "touschek_lifetime",
      &Bmad::touschek_lifetime,
      py::arg("mode"),
      py::arg("lat"),
      R"""(Calculates the touschek lifetime for a lattice by calling touschek_rate1

for each element.
The loss rate at each element is averaged over one turn to obtain the lifetime.
This function assumes that the twiss parameters and closed orbit have
been calculated, and that mode has been populated.
This subroutine assumes a fixed momentum aperture.  The loss rate at each element
uses the same momentum aperture, mode%pz_aperture.
A common way to call this function is to first populate mode using
radiation integrals.  If an ideal lattice is used, the vertical
emittance must also be set to a reasonable value.  If the vertical
emittance is due only to quantum excitation, then it will likely be
several orders of magnitude smaller than any real physical situation, in which
case the integral in this function will have problems converging.
In addition to setting mode, also set lat%param%n_part to the number of particles
per bunch.

Parameters
----------
mode : NormalModesStruct
    beam properties .pz_aperture -- Real(rp): momentum aperture
lat : LatStruct
    Accelerator Lattice .param.n_part -- Real(rp): number particles per bunch

Returns
-------
Tl : float
    Touschek lifetime in seconds
)""");
  m.def(
      "touschek_rate1_zap",
      &python_touschek_rate1_zap,
      py::arg("mode"),
      py::arg("rate"),
      py::arg("lat"),
      py::arg("ix") = py::none(),
      py::arg("s") = py::none(),
      R"""(No docstring available

Parameters
----------
mode : 
rate : 
lat : 
ix : 
s : 
)""");
  py::class_<PyTouschekRate1Zap, std::unique_ptr<PyTouschekRate1Zap>>(
      m, "TouschekRate1Zap", "Fortran routine touschek_rate1_zap return value")
      .def_readonly("rate", &PyTouschekRate1Zap::rate)
      .def_readonly("ix", &PyTouschekRate1Zap::ix)
      .def_readonly("s", &PyTouschekRate1Zap::s)
      .def("__len__", [](const PyTouschekRate1Zap&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTouschekRate1Zap& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rate);
            if (i == 1)
              return py::cast(s.ix);
            if (i == 2)
              return py::cast(s.s);
            return py::none();
          });
  m.def(
      "touschek_rate1",
      &Bmad::touschek_rate1,
      py::arg("mode"),
      py::arg("lat"),
      py::arg("ix") = py::none(),
      py::arg("s") = py::none(),
      R"""(Calculates the touschek rate at the location specified by s or ix

This calculation is based on Piwinski 1998 "The Touschek Effect In
Strong Focusing Storage Rings".  This is the most general case, equation
31.
This function uses twiss_and_track_at_s to determine the Twiss parameters
at the location s or element index ix.
A common way to call this function is to first populate mode using
radiation integrals.  If an ideal lattice is used, the vertical
emittance must also be set to a reasonable value.  If the vertical
emittance is due only to quantum excitation, then it will likely be
several orders of magnitude smaller than any real physical situation, in which
case the integral in this function will have problems converging.
Additionally, mode%pz_aperture needs to be set to the momentum aperture.
In addition to setting mode, also set lat%param%n_part to the number of particles
per bunch.
IMPORTANT NOTE: If the lattice type is a circular lattice, then
mode%a%emittance and mode%b%emittance are assumed to
contain the normalized emittences.  If lattice geometry is
open, the emittances are assumed to be
unnormalized.
IMPORTANT NOTE: The output of this subroutine is the loss rate assuming
that two particles are lost per collision, one with too
much energy, and one with too little energy.  This agrees
with Piwinski's original derivation, which assumes that the
positive energy aperture is equal in magnitude to the
negative energy aperture.  If you are studying an
accelerator with a non-symmetric energy aperture, then
this subroutine should be called twice, once with the positive
aperture, and once with the negative aperture, and rate from
each call should be halved and summed.

Parameters
----------
mode : NormalModesStruct
    beam properties
lat : LatStruct
    Lattice
ix : int, optional
    element index (either s or ix must be specified)
s : float, optional
    location in meters (either s or ix must be specified)

Returns
-------
rate : float
    Touschek rate, in units particle per second, assuming two particles per event.
)""");
  m.def(
      "integrand_base",
      &python_integrand_base,
      py::arg("t"),
      py::arg("args"),
      py::arg("func_retval__"),
      R"""(This vectorized private function is the integrand in equation 31 of Piwinski's paper.

This intetegrand has a sharp exponential decay, and so a change of variables from t to y where t=exp(y)
is applied.  This COV makes the integrand more evenly distributed over the domain of integration,
which makes it easier for qtrap to integrate.
The change of variables is done using integrand_base_cov, which is then integrated
using qtrap.

Parameters
----------
t : float
    Array of reals over which to evaluate the integrand. <return value> -- REAL(rp): Array of reals containing
    values of integrand at t(:).
)""");
  py::class_<PyIntegrandBase, std::unique_ptr<PyIntegrandBase>>(
      m, "IntegrandBase", "Fortran routine integrand_base return value")
      .def_readonly("func_retval__", &PyIntegrandBase::func_retval__)
      .def("__len__", [](const PyIntegrandBase&) { return 1; })
      .def("__getitem__", [](const PyIntegrandBase& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.func_retval__);
        return py::none();
      });
  m.def(
      "exp_bessi0",
      &Bmad::exp_bessi0,
      py::arg("t"),
      py::arg("B1"),
      py::arg("B2"),
      R"""(This is essentially the Numercal Recipes bessi0 function multiplied by exp(-B1*t).

This overcomes an issue where exp(B2*t) may be huge and exp(-B1*t) may be small.
Evaluating exp(B2*t) may result in overflow, but exp((B2-B1)*t) has a moderate value.
Simplifying the algebra of B2-B1 suggests that is should always have a moderate magnitude.

Parameters
----------
t : float
    Scalar agrument to evaluate function at.
B1 : float
    Scalar value.  Eq. 33 from Piwinski's paper.
B2 : float
    Scalar value.  Eq. 34 from Piwinski's paper. <return value> -- Real(rp): Scalar return value.
)""");
  m.def(
      "bl_via_vlassov",
      &Bmad::bl_via_vlassov,
      py::arg("current"),
      py::arg("alpha"),
      py::arg("Energy"),
      py::arg("sigma_p"),
      py::arg("Vrf"),
      py::arg("omega"),
      py::arg("U0"),
      py::arg("circ"),
      py::arg("R"),
      py::arg("L"),
      R"""(This is a frontend for get_bl_from_fwhm from longitudinal_profile_mod.

See longitudinal_profile_mod for details.  In short, this implements a model of potential well distortion
based on the Vlassov equation which uses an effective Resistive, Inductive, and Capacitive impedance.

Parameters
----------
current : float
    Beam current in amps
alpha : float
    Momentum compaction
Energy : float
    beam energy
sigma_p : float
    energy spread
Vrf : float
    total RF voltage in Volts
omega : float
    rf frequency in radians/s
U0 : float
    energy loss per turn (eV)
circ : float
    circumpherence
R : float
    Resistive part of effective impedance
L : float
    Inductive part of effective impedance

Returns
-------
sigma_z : float
    Bunch length. FWHM/TwoRootTwoLogTwo from bunch profile
)""");
  m.def(
      "track_beam",
      &Bmad::track_beam,
      py::arg("lat"),
      py::arg("beam"),
      py::arg("ele1") = py::none(),
      py::arg("ele2") = py::none(),
      py::arg("centroid") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("bunch_tracks") = py::none(),
      R"""(Subroutine to track a beam of particles from the end of

ele1 Through to the end of ele2. Both must be in the same lattice branch.

Parameters
----------
lat : LatStruct
    Lattice to track through.
beam : BeamStruct
    Beam at end of element ix1.
    This parameter is an input/output and is modified in-place. As an output: Beam at end of element ix2.
ele1 : EleStruct, optional
    Starting element (this element is NOT tracked through). Default is lat.ele(0).
ele2 : EleStruct, optional
    Ending element. Default is lat.ele(lat.n_ele_track).
centroid : CoordStruct, optional
    Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before beam tracking by
    tracking a single particle.
direction : int, optional
    +1 (default) -> Track forward, -1 -> Track backwards.
bunch_tracks : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: track information if the
    tracking method does

Returns
-------
err : bool
    Set true if there is an error. EG: Too many particles lost for a CSR calc.
)""");
  m.def(
      "track_bunch",
      &Bmad::track_bunch,
      py::arg("lat"),
      py::arg("bunch"),
      py::arg("ele1") = py::none(),
      py::arg("ele2") = py::none(),
      py::arg("centroid") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("bunch_track") = py::none(),
      R"""(Subroutine to track a particle bunch from the end of ele1 Through to the end of ele2.

Both must be in the same lattice branch.
With forward tracking, if ele2 is at or before ele1, the tracking will "wrap" around
the ends of the lattice.

Parameters
----------
lat : LatStruct
    Lattice to track through.
bunch : BunchStruct
    Bunch at end of element ix1.
    This parameter is an input/output and is modified in-place. As an output: Bunch at end of element ix2.
ele1 : EleStruct, optional
    Starting element (this element is NOT tracked through). Default is lat.ele(0).
ele2 : EleStruct, optional
    Ending element. Default is lat.ele(lat.n_ele_track).
centroid : CoordStruct, optional
    Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before bunch tracking by
    tracking a single particle.
direction : int, optional
    +1 (default) -> Track forward, -1 -> Track backwards.
bunch_track : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: track information if the
    tracking method does

Returns
-------
err : bool
    Set true if there is an error. EG: Too many particles lost for a CSR calc.
)""");
  m.def(
      "track1_beam",
      &Bmad::track1_beam,
      py::arg("beam"),
      py::arg("ele"),
      py::arg("centroid") = py::none(),
      py::arg("direction") = py::none(),
      R"""(Subroutine to track a beam of particles through an element.

Parameters
----------
beam : BeamStruct
    Starting beam position.
    This parameter is an input/output and is modified in-place. As an output: Ending beam position.
ele : EleStruct
    element to track through.
centroid : CoordStruct, optional
    Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before beam tracking by
    tracking a single particle.
direction : int, optional
    +1 (default) -> Track forward, -1 -> Track backwards.

Returns
-------
err : bool
    Set true if there is an error. EG: Too many particles lost for a CSR calc.
)""");
  m.def(
      "track1_bunch",
      &Bmad::track1_bunch,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("centroid") = py::none(),
      py::arg("direction") = py::none(),
      py::arg("bunch_track") = py::none(),
      R"""(Subroutine to track a bunch of particles through an element.

Parameters
----------
bunch : BunchStruct
    Starting bunch position.
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
ele : EleStruct
    element to track through.
centroid : CoordStruct, optional
    Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before beam tracking by
    tracking a single particle.
direction : int, optional
    +1 (default) -> Track forward, -1 -> Track backwards.
bunch_track : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: Track information appended to
    track.

Returns
-------
err : bool
    Set true if there is an error. EG: Too many particles lost for a CSR calc.
)""");
  m.def(
      "write_beam_file",
      &Bmad::write_beam_file,
      py::arg("file_name"),
      py::arg("beam"),
      py::arg("new_file") = py::none(),
      py::arg("file_format") = py::none(),
      py::arg("lat") = py::none(),
      py::arg("alive_only") = py::none(),
      R"""(Routine to write a beam file.

A '.h5' suffix will be appended to the created file if hdf5$ format is used and file_name does not
already have a '.h5' or '.hdf5' suffix.

Parameters
----------
file_name : unknown
    Name of file.
beam : BeamStruct
    Beam to write
new_file : bool, optional
    New file or append? Default = True.
file_format : bool, optional
    ascii$, or hdf5$ (default). old_ascii$ (deprecated) is still accepted.
lat : LatStruct, optional
    If present, lattice info will be writen to hdf5 files.
alive_only : bool, optional
    Only write live (includes pre_born) particles to the file? Default is False.
)""");
  m.def(
      "write_ascii_beam_file",
      &Bmad::write_ascii_beam_file,
      py::arg("file_name"),
      py::arg("beam"),
      py::arg("new_file") = py::none(),
      py::arg("alive_only") = py::none(),
      R"""(Routine to write a beam file in ASCII format (version 4).

Parameters
----------
file_name : unknown
    Name of file.
beam : BeamStruct
    Beam to write
new_file : bool, optional
    New file or append? Default = True.
alive_only : bool, optional
    Only write live (includes pre_born) particles to the file? Default is False.
)""");
  m.def(
      "read_beam_file",
      &python_read_beam_file,
      py::arg("file_name"),
      py::arg("beam_init"),
      py::arg("ele") = py::none(),
      py::arg("print_mom_shift_warning") = py::none(),
      py::arg("conserve_momentum") = py::none(),
      R"""(Subroutine to read in a beam definition file.

If non_zero, the following components of beam_init are used to rescale the beam:
%n_bunch
%n_particle
%bunch_charge -> charge_tot
%species
If the beam file has '.h5' or '.hdf5' suffix then the file is taken to be an HDF5 file.
Otherwise the file is assumed to be ASCII.

Parameters
----------
file_name : unknown
    Name of beam file.
beam_init : BeamInitStruct
    See above.
ele : EleStruct, optional
    Element with reference energy, etc.
print_mom_shift_warning : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
shift_momentum : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.

Return value is a dictionary containing values below.


Returns
-------
beam : BeamStruct
    Structure holding the beam information.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<PyReadBeamFile, std::unique_ptr<PyReadBeamFile>>(
      m, "ReadBeamFile", "Fortran routine read_beam_file return value")
      .def_readonly("beam", &PyReadBeamFile::beam)
      .def_readonly("err_flag", &PyReadBeamFile::err_flag)
      .def_readonly("conserve_momentum", &PyReadBeamFile::conserve_momentum)
      .def("__len__", [](const PyReadBeamFile&) { return 3; })
      .def("__getitem__", [](const PyReadBeamFile& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.beam);
        if (i == 1)
          return py::cast(s.err_flag);
        if (i == 2)
          return py::cast(s.conserve_momentum);
        return py::none();
      });
  m.def(
      "read_beam_ascii",
      &Bmad::read_beam_ascii,
      py::arg("file_name"),
      py::arg("beam_init"),
      R"""(Subroutine to read in a beam definition file.

If non_zero, the following components of beam_init are used to rescale the beam:
%n_bunch
%n_particle
%charge_tot
If the beam file has '.h5' or '.hdf5' suffix then the file is taken to be an HDF5 file.
Otherwise the file is assumed to be ASCII.

Parameters
----------
iu : int
    File unit number
file_name : unknown
    Name of beam file.
beam_init : BeamInitStruct
    See above.
ele : EleStruct, optional
    Element with reference energy, etc.
print_mom_shift_warning : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
shift_momentum : bool, optional
    Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.

Return value is a dictionary containing values below.


Returns
-------
beam : BeamStruct
    Structure holding the beam information.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<Bmad::ReadBeamAscii, std::unique_ptr<Bmad::ReadBeamAscii>>(
      m, "ReadBeamAscii", "Fortran routine read_beam_ascii return value")
      .def_readonly("beam", &Bmad::ReadBeamAscii::beam)
      .def_readonly("err_flag", &Bmad::ReadBeamAscii::err_flag)
      .def("__len__", [](const Bmad::ReadBeamAscii&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::ReadBeamAscii& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.beam);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "randomize_lr_wake_frequencies",
      &Bmad::randomize_lr_wake_frequencies,
      py::arg("ele"),
      R"""(Routine to randomize the frequencies of the lr wake HOMs according to:

freq = freq_in * (1 + lr_freq_spread) * rr)
where rr is a Gaussian distributed random number with unit variance.

Parameters
----------
ele : EleStruct
    Element with wake. If no wake then nothing is done. .value(freq_in$)        -- Frequency.
    This parameter is an input/output and is modified in-place. As an output: Element with wake frequencies
    set.

Returns
-------
set_done : bool
    Set True if there where lr wakes to be set. False otherwise.
)""");
  m.def(
      "zero_lr_wakes_in_lat",
      &Bmad::zero_lr_wakes_in_lat,
      py::arg("lat"),
      R"""(Routine to zero the long range wake amplitudes for the elements that have

long range wakes in a lattice.

Parameters
----------
lat : LatStruct
    Lattice
)""");
  m.def(
      "track1_lr_wake",
      &Bmad::track1_lr_wake,
      py::arg("bunch"),
      py::arg("ele"),
      R"""(Subroutine to put in the long-range wakes for particle tracking.

Parameters
----------
ele : EleStruct
    Element with wakes.
    This parameter is an input/output and is modified in-place. As an output: Element with updated wake
    amplitudes.
bunch : BunchStruct
    Bunch to track.
    This parameter is an input/output and is modified in-place. As an output: Kicked bunch.
)""");
  m.def(
      "sr_longitudinal_wake_particle",
      &Bmad::sr_longitudinal_wake_particle,
      py::arg("ele"),
      py::arg("orbit"),
      R"""(Routine to apply the short-range wake longitudinal component kick to a particle and then add

to the existing longitudinal wake the contribution from the particle.

Parameters
----------
ele : EleStruct
    Element with wakes.
orbit : CoordStruct
    Particle coords.
    This parameter is an input/output and is modified in-place. As an output: coords after the kick.
)""");
  m.def(
      "sr_transverse_wake_particle",
      &Bmad::sr_transverse_wake_particle,
      py::arg("ele"),
      py::arg("orbit"),
      R"""(Subroutine to apply the short-range wake transverse component of the kick to a particle and then add

to the existing transverse wake the contribution from the particle.

Parameters
----------
ele : EleStruct
    Element with wakes.
orbit : CoordStruct
    Starting particle coords.
    This parameter is an input/output and is modified in-place. As an output: Ending particle coords.
)""");
  m.def(
      "sr_z_long_wake",
      &Bmad::sr_z_long_wake,
      py::arg("ele"),
      py::arg("bunch"),
      py::arg("z_ave"),
      R"""(Subroutine to apply the short-range z-wake kick to a particle.

Parameters
----------
ele : EleStruct
    Element with wake.
bunch : BunchStruct
    Bunch before wake applied.
z_ave : float
    Average z-position of all live particles.

Returns
-------
orbit : CoordStruct
    Ending particle coords.
)""");
  m.def(
      "order_particles_in_z",
      &Bmad::order_particles_in_z,
      py::arg("bunch"),
      R"""(Routine to order the particles longitudinally in terms of decreasing %vec(5).

That is from large z (head of bunch) to small z.
Only live particles are ordered.

Parameters
----------
bunch : BunchStruct
    collection of particles. .particle(j).vec(5) -- Longitudinal position of j^th particle.
)""");
  m.def(
      "track1_sr_wake",
      &Bmad::track1_sr_wake,
      py::arg("bunch"),
      py::arg("ele"),
      R"""(Subroutine to apply the short range wake fields to a bunch.

Parameters
----------
bunch : BunchStruct
    Bunch of particles.
    This parameter is an input/output and is modified in-place. As an output: Bunch with wakefields applied to
    the particles.
ele : EleStruct
    Element with wakefields.
)""");
  m.def(
      "write_line_element",
      &python_write_line_element,
      py::arg("line"),
      py::arg("iu"),
      py::arg("ele"),
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
line : 
iu : 
ele : 
lat : 
)""");
  py::class_<PyWriteLineElement, std::unique_ptr<PyWriteLineElement>>(
      m, "WriteLineElement", "Fortran routine write_line_element return value")
      .def_readonly("line", &PyWriteLineElement::line)
      .def_readonly("iu", &PyWriteLineElement::iu)
      .def("__len__", [](const PyWriteLineElement&) { return 2; })
      .def(
          "__getitem__",
          [](const PyWriteLineElement& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.line);
            if (i == 1)
              return py::cast(s.iu);
            return py::none();
          });
  m.def(
      "re_str_rp",
      &python_re_str_rp,
      py::arg("rel"),
      py::arg("str_out"),
      R"""(No docstring available

Parameters
----------
rel : 
str_out : 
)""");
  py::class_<PyReStrRp, std::unique_ptr<PyReStrRp>>(
      m, "ReStrRp", "Fortran routine re_str_rp return value")
      .def_readonly("rel", &PyReStrRp::rel)
      .def_readonly("str_out", &PyReStrRp::str_out)
      .def("__len__", [](const PyReStrRp&) { return 2; })
      .def("__getitem__", [](const PyReStrRp& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.rel);
        if (i == 1)
          return py::cast(s.str_out);
        return py::none();
      });
  m.def(
      "re_str_qp",
      &python_re_str_qp,
      py::arg("rel"),
      py::arg("str_out"),
      R"""(No docstring available

Parameters
----------
rel : 
str_out : 
)""");
  py::class_<PyReStrQp, std::unique_ptr<PyReStrQp>>(
      m, "ReStrQp", "Fortran routine re_str_qp return value")
      .def_readonly("rel", &PyReStrQp::rel)
      .def_readonly("str_out", &PyReStrQp::str_out)
      .def("__len__", [](const PyReStrQp&) { return 2; })
      .def("__getitem__", [](const PyReStrQp& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.rel);
        if (i == 1)
          return py::cast(s.str_out);
        return py::none();
      });
  m.def(
      "array_re_str",
      &python_array_re_str,
      py::arg("arr"),
      py::arg("parens_in") = py::none(),
      py::arg("str_out"),
      R"""(No docstring available

Parameters
----------
arr : 
parens_in : 
str_out : 
)""");
  py::class_<PyArrayReStr, std::unique_ptr<PyArrayReStr>>(
      m, "ArrayReStr", "Fortran routine array_re_str return value")
      .def_readonly("parens_in", &PyArrayReStr::parens_in)
      .def_readonly("str_out", &PyArrayReStr::str_out)
      .def("__len__", [](const PyArrayReStr&) { return 2; })
      .def("__getitem__", [](const PyArrayReStr& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.parens_in);
        if (i == 1)
          return py::cast(s.str_out);
        return py::none();
      });
  m.def(
      "cmplx_re_str",
      &python_cmplx_re_str,
      py::arg("cmp"),
      py::arg("str_out"),
      R"""(No docstring available

Parameters
----------
cmp : 
str_out : 
)""");
  py::class_<PyCmplxReStr, std::unique_ptr<PyCmplxReStr>>(
      m, "CmplxReStr", "Fortran routine cmplx_re_str return value")
      .def_readonly("cmp", &PyCmplxReStr::cmp)
      .def_readonly("str_out", &PyCmplxReStr::str_out)
      .def("__len__", [](const PyCmplxReStr&) { return 2; })
      .def("__getitem__", [](const PyCmplxReStr& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.cmp);
        if (i == 1)
          return py::cast(s.str_out);
        return py::none();
      });
  m.def(
      "rchomp",
      &python_rchomp,
      py::arg("rel"),
      py::arg("plc"),
      py::arg("out"),
      R"""(No docstring available

Parameters
----------
rel : 
plc : 
out : 
)""");
  py::class_<PyRchomp, std::unique_ptr<PyRchomp>>(
      m, "Rchomp", "Fortran routine rchomp return value")
      .def_readonly("rel", &PyRchomp::rel)
      .def_readonly("plc", &PyRchomp::plc)
      .def_readonly("out", &PyRchomp::out)
      .def("__len__", [](const PyRchomp&) { return 3; })
      .def("__getitem__", [](const PyRchomp& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.rel);
        if (i == 1)
          return py::cast(s.plc);
        if (i == 2)
          return py::cast(s.out);
        return py::none();
      });
  m.def(
      "write_lat_line",
      &python_write_lat_line,
      py::arg("line"),
      py::arg("iu"),
      py::arg("end_is_neigh"),
      py::arg("do_split") = py::none(),
      py::arg("scibmad") = py::none(),
      R"""(Routine to write strings to a lattice file.

This routine will break the string up into multiple lines
if the string is too long and add a continuation character if needed.
If the "line" arg does not represent a full "sentence" (end_is_neigh = False),
then only part of the line may be written and the part not written will be returned.

Parameters
----------
line : unknown
    String of text.
    This parameter is an input/output and is modified in-place. As an output: part of the string not written.
iu : int
    Unit number to write to.
end_is_neigh : bool
    If true then write out everything. Otherwise wait for a full line of max_char characters or so.
do_split : bool, optional
    Split line if overlength? Default is True. False is used when line has already been split for expressions
    since the expression splitting routine does a much better job of it.
scibmad : bool, optional
    Default False. If True then do not include "&" line continuation
)""");
  py::class_<PyWriteLatLine, std::unique_ptr<PyWriteLatLine>>(
      m, "WriteLatLine", "Fortran routine write_lat_line return value")
      .def_readonly("line", &PyWriteLatLine::line)
      .def("__len__", [](const PyWriteLatLine&) { return 1; })
      .def("__getitem__", [](const PyWriteLatLine& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        return py::none();
      });
  m.def(
      "value_to_line",
      &python_value_to_line,
      py::arg("line"),
      py::arg("value"),
      py::arg("str"),
      py::arg("typ"),
      py::arg("ignore_if_zero") = py::none(),
      py::arg("use_comma") = py::none(),
      R"""(No docstring available

Parameters
----------
line : 
value : 
str : 
typ : 
ignore_if_zero : 
use_comma : 
)""");
  py::class_<PyValueToLine, std::unique_ptr<PyValueToLine>>(
      m, "ValueToLine", "Fortran routine value_to_line return value")
      .def_readonly("line", &PyValueToLine::line)
      .def_readonly("value", &PyValueToLine::value)
      .def_readonly("str", &PyValueToLine::str)
      .def_readonly("typ", &PyValueToLine::typ)
      .def_readonly("ignore_if_zero", &PyValueToLine::ignore_if_zero)
      .def_readonly("use_comma", &PyValueToLine::use_comma)
      .def("__len__", [](const PyValueToLine&) { return 6; })
      .def("__getitem__", [](const PyValueToLine& s, size_t i) -> py::object {
        if (i >= 6)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        if (i == 1)
          return py::cast(s.value);
        if (i == 2)
          return py::cast(s.str);
        if (i == 3)
          return py::cast(s.typ);
        if (i == 4)
          return py::cast(s.ignore_if_zero);
        if (i == 5)
          return py::cast(s.use_comma);
        return py::none();
      });
  m.def(
      "write_binary_cartesian_map",
      &Bmad::write_binary_cartesian_map,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("cart_map"),
      py::arg("err_flag"),
      R"""(Routine to write a binary cartesian_map structure.

Parameters
----------
file_name : unknown
    File to create.
ele : EleStruct
    Element associated with the map.
cart_map : CartesianMapStruct
    Cartesian map. Ouput:
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "read_binary_cartesian_map",
      &Bmad::read_binary_cartesian_map,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("cart_map"),
      py::arg("err_flag"),
      R"""(Routine to read a binary cartesian_map structure.

Parameters
----------
file_name : unknown
    File to create.
ele : EleStruct
    Element associated with the map. Ouput:
cart_map : 
    cartesian_map_struct, cartesian map.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "write_binary_cylindrical_map",
      &Bmad::write_binary_cylindrical_map,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("cl_map"),
      py::arg("err_flag"),
      R"""(Routine to write a binary cylindrical_map structure.

Parameters
----------
file_name : unknown
    File to create.
ele : EleStruct
    Element associated with the map.
cl_map : CylindricalMapStruct
    Cylindrical map. Ouput:
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "read_binary_cylindrical_map",
      &Bmad::read_binary_cylindrical_map,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("cl_map"),
      py::arg("err_flag"),
      R"""(Routine to read a binary cylindrical_map structure.

Parameters
----------
file_name : unknown
    File to create.
ele : EleStruct
    Element associated with the map. Ouput:
cl_map : 
    cylindrical_map_struct, cylindrical map.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "write_binary_grid_field",
      &Bmad::write_binary_grid_field,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("g_field"),
      py::arg("err_flag"),
      R"""(Routine to write a binary grid_field structure.

Parameters
----------
file_name : unknown
    File to create.
ele : EleStruct
    Element associated with the map.
g_field : GridFieldStruct
    Cylindrical map. Ouput:
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "read_binary_grid_field",
      &Bmad::read_binary_grid_field,
      py::arg("file_name"),
      py::arg("ele"),
      py::arg("g_field"),
      py::arg("err_flag"),
      R"""(Routine to read a binary grid_field structure.

Parameters
----------
file_name : unknown
    File to create.
ele : EleStruct
    Element associated with the map. Ouput:
g_field : 
    grid_field_struct, cylindrical map.
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "open_binary_file",
      &Bmad::open_binary_file,
      py::arg("file_name"),
      py::arg("action"),
      py::arg("r_name"),
      R"""(Routine to open a binary file for reading or writing.

Parameters
----------
file_name : unknown
    File to create.
action : unknown
    'READ' or 'WRITE'
r_name : unknown
    Calling routine name for error messages.

Return value is a dictionary containing values below.


Returns
-------
iu : int
    Unit number of opened file.
iver : int
    Version number if action = 'READ'
is_ok : bool
    Open OK?
)""");
  py::class_<Bmad::OpenBinaryFile, std::unique_ptr<Bmad::OpenBinaryFile>>(
      m, "OpenBinaryFile", "Fortran routine open_binary_file return value")
      .def_readonly("iu", &Bmad::OpenBinaryFile::iu)
      .def_readonly("iver", &Bmad::OpenBinaryFile::iver)
      .def_readonly("is_ok", &Bmad::OpenBinaryFile::is_ok)
      .def("__len__", [](const Bmad::OpenBinaryFile&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::OpenBinaryFile& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.iu);
            if (i == 1)
              return py::cast(s.iver);
            if (i == 2)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "nint_chk",
      &Bmad::nint_chk,
      py::arg("re_val"),
      R"""(Returns the nearest integer to re_val.

Also does out-of-bounds error checking.
Used with bmad parsing.

Parameters
----------
re_val : float
    Input real number.

Returns
-------
int_val : int
    Output nearest integer.
)""");
  m.def(
      "get_called_file",
      &python_get_called_file,
      py::arg("delim"),
      py::arg("call_file"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
delim : 
call_file : 
err : 
)""");
  py::class_<PyGetCalledFile, std::unique_ptr<PyGetCalledFile>>(
      m, "GetCalledFile", "Fortran routine get_called_file return value")
      .def_readonly("delim", &PyGetCalledFile::delim)
      .def_readonly("call_file", &PyGetCalledFile::call_file)
      .def_readonly("err", &PyGetCalledFile::err)
      .def("__len__", [](const PyGetCalledFile&) { return 3; })
      .def("__getitem__", [](const PyGetCalledFile& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.delim);
        if (i == 1)
          return py::cast(s.call_file);
        if (i == 2)
          return py::cast(s.err);
        return py::none();
      });
  m.def(
      "add_this_taylor_term",
      &python_add_this_taylor_term,
      py::arg("ele"),
      py::arg("i_out"),
      py::arg("coef"),
      py::arg("expn"),
      R"""(Subroutine used by bmad_parser and bmad_parser2 to parse the input file.

This subroutine is not intended for general use.

)""");
  py::class_<PyAddThisTaylorTerm, std::unique_ptr<PyAddThisTaylorTerm>>(
      m,
      "AddThisTaylorTerm",
      "Fortran routine add_this_taylor_term return value")
      .def_readonly("i_out", &PyAddThisTaylorTerm::i_out)
      .def_readonly("coef", &PyAddThisTaylorTerm::coef)
      .def("__len__", [](const PyAddThisTaylorTerm&) { return 2; })
      .def(
          "__getitem__",
          [](const PyAddThisTaylorTerm& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.i_out);
            if (i == 1)
              return py::cast(s.coef);
            return py::none();
          });
  m.def(
      "parser_call_check",
      &python_parser_call_check,
      py::arg("word"),
      py::arg("ix_word"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("call_found"),
      py::arg("err_flag") = py::none(),
      R"""(Routine to check if there is a "call::XXX" construct in the input stream.

)""");
  py::class_<PyParserCallCheck, std::unique_ptr<PyParserCallCheck>>(
      m, "ParserCallCheck", "Fortran routine parser_call_check return value")
      .def_readonly("word", &PyParserCallCheck::word)
      .def_readonly("ix_word", &PyParserCallCheck::ix_word)
      .def_readonly("delim", &PyParserCallCheck::delim)
      .def_readonly("delim_found", &PyParserCallCheck::delim_found)
      .def_readonly("call_found", &PyParserCallCheck::call_found)
      .def_readonly("err_flag", &PyParserCallCheck::err_flag)
      .def("__len__", [](const PyParserCallCheck&) { return 6; })
      .def(
          "__getitem__",
          [](const PyParserCallCheck& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.word);
            if (i == 1)
              return py::cast(s.ix_word);
            if (i == 2)
              return py::cast(s.delim);
            if (i == 3)
              return py::cast(s.delim_found);
            if (i == 4)
              return py::cast(s.call_found);
            if (i == 5)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "get_next_word",
      &Bmad::get_next_word,
      py::arg("word"),
      py::arg("ix_word"),
      py::arg("delim_list"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("upper_case_word") = py::none(),
      py::arg("call_check") = py::none(),
      py::arg("err_flag") = py::none(),
      R"""(Subroutine to get the next word from the input stream.

This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

Parameters
----------
word : unknown
    Word returned
delim_list : unknown
    List of valid delimiters
upper_case_word : bool, optional
    if True then convert word to upper case. Default is True.
call_check : bool, optional
    If present and True then check for 'call::<filename>' construct. Default is False. Output
ix_word : int
    length of word argument
delim : unknown
    Actual delimiter found
delim_found : bool
    Set true if a delimiter found. A delimiter may not be found if the end of the line is reached first.
err_flag : bool, optional
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "parser_file_stack",
      &python_parser_file_stack,
      py::arg("how"),
      py::arg("file_name_in") = py::none(),
      py::arg("finished") = py::none(),
      py::arg("err") = py::none(),
      py::arg("open_file") = py::none(),
      py::arg("abort_on_open_error") = py::none(),
      R"""(Subroutine to keep track of the files that are opened for reading.

This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

)""");
  py::class_<PyParserFileStack, std::unique_ptr<PyParserFileStack>>(
      m, "ParserFileStack", "Fortran routine parser_file_stack return value")
      .def_readonly("how", &PyParserFileStack::how)
      .def_readonly("file_name_in", &PyParserFileStack::file_name_in)
      .def_readonly("finished", &PyParserFileStack::finished)
      .def_readonly("err", &PyParserFileStack::err)
      .def_readonly("open_file", &PyParserFileStack::open_file)
      .def_readonly(
          "abort_on_open_error", &PyParserFileStack::abort_on_open_error)
      .def("__len__", [](const PyParserFileStack&) { return 6; })
      .def(
          "__getitem__",
          [](const PyParserFileStack& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.how);
            if (i == 1)
              return py::cast(s.file_name_in);
            if (i == 2)
              return py::cast(s.finished);
            if (i == 3)
              return py::cast(s.err);
            if (i == 4)
              return py::cast(s.open_file);
            if (i == 5)
              return py::cast(s.abort_on_open_error);
            return py::none();
          });
  m.def(
      "load_parse_line",
      &Bmad::load_parse_line,
      py::arg("action"),
      py::arg("ix_start"),
      R"""(Subroutine to load characters from the input file.

This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

Parameters
----------
action : unknown
    'continue', 'new_command', or 'init'
ix_start : int
    Index in bp_com.parse_line string where to append stuff.

Return value is a dictionary containing values below.


Returns
-------
end_of_file : bool
    End of file reached?
err_flag : bool
    Set True if there is an error. False otherwise bp_com.parse_line -- string to append to.
)""");
  py::class_<Bmad::LoadParseLine, std::unique_ptr<Bmad::LoadParseLine>>(
      m, "LoadParseLine", "Fortran routine load_parse_line return value")
      .def_readonly("end_of_file", &Bmad::LoadParseLine::end_of_file)
      .def_readonly("err_flag", &Bmad::LoadParseLine::err_flag)
      .def("__len__", [](const Bmad::LoadParseLine&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::LoadParseLine& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_of_file);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "evaluate_array_index",
      &Bmad::evaluate_array_index,
      py::arg("delim_list1"),
      py::arg("delim_list2"),
      R"""(Function of evaluate the index of an array. Typically the text being parsed looks like:

"5) = ..."         or
"6).COMP = ..."

Parameters
----------
delim_list1 : unknown
    Delimitor after the integer. Normally ')'.
delim_list2 : unknown
    Delimitor list to mark the end of word2. Normally '='.

Return value is a dictionary containing values below.


Returns
-------
err_flag : bool
    Set True if there is an error. False otherwise.
word2 : unknown
    Word found after delim1. Normally this should be blank.
delim2 : unknown
    Actual delimitor found after word2.
this_index : int
    Integer value
)""");
  py::class_<
      Bmad::EvaluateArrayIndex,
      std::unique_ptr<Bmad::EvaluateArrayIndex>>(
      m,
      "EvaluateArrayIndex",
      "Fortran routine evaluate_array_index return value")
      .def_readonly("err_flag", &Bmad::EvaluateArrayIndex::err_flag)
      .def_readonly("word2", &Bmad::EvaluateArrayIndex::word2)
      .def_readonly("delim2", &Bmad::EvaluateArrayIndex::delim2)
      .def_readonly("this_index", &Bmad::EvaluateArrayIndex::this_index)
      .def("__len__", [](const Bmad::EvaluateArrayIndex&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::EvaluateArrayIndex& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.word2);
            if (i == 2)
              return py::cast(s.delim2);
            if (i == 3)
              return py::cast(s.this_index);
            return py::none();
          });
  m.def(
      "evaluate_logical",
      &Bmad::evaluate_logical,
      py::arg("word"),
      R"""(Function of convert a string into a logical value.

Accepted possibilities are:
.TRUE.  .FALSE.
TRUE    FALSE
T       F

Parameters
----------
word : unknown
    Input string.

Return value is a dictionary containing values below.


Returns
-------
this_logic : bool
    Result.
iostat : int
    Status: Returns 0 if conversion successful.
)""");
  py::class_<Bmad::EvaluateLogical, std::unique_ptr<Bmad::EvaluateLogical>>(
      m, "EvaluateLogical", "Fortran routine evaluate_logical return value")
      .def_readonly("iostat", &Bmad::EvaluateLogical::iostat)
      .def_readonly("this_logic", &Bmad::EvaluateLogical::this_logic)
      .def("__len__", [](const Bmad::EvaluateLogical&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::EvaluateLogical& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.iostat);
            if (i == 1)
              return py::cast(s.this_logic);
            return py::none();
          });
  m.def(
      "word_to_value",
      &python_word_to_value,
      py::arg("word"),
      py::arg("lat"),
      py::arg("value"),
      py::arg("err_flag"),
      py::arg("ele") = py::none(),
      R"""(No docstring available

Parameters
----------
word : 
lat : 
value : 
err_flag : 
ele : 
)""");
  py::class_<PyWordToValue, std::unique_ptr<PyWordToValue>>(
      m, "WordToValue", "Fortran routine word_to_value return value")
      .def_readonly("word", &PyWordToValue::word)
      .def_readonly("value", &PyWordToValue::value)
      .def_readonly("err_flag", &PyWordToValue::err_flag)
      .def("__len__", [](const PyWordToValue&) { return 3; })
      .def("__getitem__", [](const PyWordToValue& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.word);
        if (i == 1)
          return py::cast(s.value);
        if (i == 2)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "parser_add_constant",
      &python_parser_add_constant,
      py::arg("word"),
      py::arg("lat"),
      py::arg("redef_is_error"),
      R"""(No docstring available

Parameters
----------
word : 
lat : 
redef_is_error : 
)""");
  py::class_<PyParserAddConstant, std::unique_ptr<PyParserAddConstant>>(
      m,
      "ParserAddConstant",
      "Fortran routine parser_add_constant return value")
      .def_readonly("word", &PyParserAddConstant::word)
      .def_readonly("redef_is_error", &PyParserAddConstant::redef_is_error)
      .def("__len__", [](const PyParserAddConstant&) { return 2; })
      .def(
          "__getitem__",
          [](const PyParserAddConstant& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.word);
            if (i == 1)
              return py::cast(s.redef_is_error);
            return py::none();
          });
  m.def(
      "parser_read_sr_wake",
      &python_parser_read_sr_wake,
      py::arg("ele"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err_flag"),
      R"""(Subroutine to read in a short-range wake field.

This subroutine is used by bmad_parser and bmad_parser2.

Parameters
----------
ele : EleStruct
    Element containing wake structure.
    This parameter is an input/output and is modified in-place. As an output: Element with wake information.
)""");
  py::class_<PyParserReadSrWake, std::unique_ptr<PyParserReadSrWake>>(
      m, "ParserReadSrWake", "Fortran routine parser_read_sr_wake return value")
      .def_readonly("delim", &PyParserReadSrWake::delim)
      .def_readonly("delim_found", &PyParserReadSrWake::delim_found)
      .def_readonly("err_flag", &PyParserReadSrWake::err_flag)
      .def("__len__", [](const PyParserReadSrWake&) { return 3; })
      .def(
          "__getitem__",
          [](const PyParserReadSrWake& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "parser_read_lr_wake",
      &python_parser_read_lr_wake,
      py::arg("ele"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err_flag"),
      R"""(Subroutine to read in a long-range wake field from an external file.

This subroutine is used by bmad_parser and bmad_parser2.

Parameters
----------
ele : EleStruct
    Element containing wake structure.
    This parameter is an input/output and is modified in-place. As an output: Element with wake information.
)""");
  py::class_<PyParserReadLrWake, std::unique_ptr<PyParserReadLrWake>>(
      m, "ParserReadLrWake", "Fortran routine parser_read_lr_wake return value")
      .def_readonly("delim", &PyParserReadLrWake::delim)
      .def_readonly("delim_found", &PyParserReadLrWake::delim_found)
      .def_readonly("err_flag", &PyParserReadLrWake::err_flag)
      .def("__len__", [](const PyParserReadLrWake&) { return 3; })
      .def(
          "__getitem__",
          [](const PyParserReadLrWake& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "parser_read_old_format_lr_wake",
      &Bmad::parser_read_old_format_lr_wake,
      py::arg("ele"),
      py::arg("lr_file_name"),
      R"""(Subroutine to read in a long-range wake field from an external file.

This subroutine is used by bmad_parser and bmad_parser2.

Parameters
----------
ele : EleStruct
    Element containing wake structure.
    This parameter is an input/output and is modified in-place. As an output: Element with wake information.
lr_file_name : unknown
    Name of long-range wake field file.
)""");
  m.def(
      "parser_read_old_format_sr_wake",
      &Bmad::parser_read_old_format_sr_wake,
      py::arg("ele"),
      py::arg("sr_file_name"),
      R"""(Subroutine to read in a short-range wake field from an external file.

This subroutine is used by bmad_parser and bmad_parser2.

Parameters
----------
ele : EleStruct
    Element containing wake structure.
    This parameter is an input/output and is modified in-place. As an output: Element with wake information.
sr_file_name : unknown
    Name of short-range wake field file.
)""");
  m.def(
      "verify_valid_name",
      &Bmad::verify_valid_name,
      py::arg("name"),
      py::arg("ix_name"),
      py::arg("pure_name") = py::none(),
      py::arg("include_wild") = py::none(),
      R"""(Routine to check if a name is well formed. Examples:

"0>>Q0"                           -- Invalid (will only be valid after lattice expansion).
"Q1##1"                           -- Invalid (double hash not accepted).
"Q2A_C.\7#"                       -- Pure name (no "[", "]", "(", ")", "%" characters present).
"Q3[GRID_FIELD(1)%FIELD_SCALE]"   -- Valid but not a pure name.
"RFCAVITY::*"                     -- Valid if include_wild = True.
This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

Parameters
----------
name : unknown
    Name(1:ix_name) is the string to check.
ix_name : int
    Number of characters in the name.
pure_name : bool, optional
    If True, reject names that contain "[", "]", "(", ")", "." characters. Default is False.
include_wild : bool, optional
    Name can include wild card characters and additionally type prefixes like "QUAD::". Default is False.

Returns
-------
is_valid : bool
    True if name is well formed. False otherwise.
)""");
  m.def(
      "add_this_multipass",
      &Bmad::add_this_multipass,
      py::arg("lat"),
      py::arg("m_slaves"),
      py::arg("lord_in") = py::none(),
      R"""(No docstring available

Parameters
----------
lat : 
m_slaves : 
lord_in : 
)""");
  m.def(
      "drift_multipass_name_correction",
      &Bmad::drift_multipass_name_correction,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : 
)""");
  m.def(
      "reallocate_bp_com_const",
      &Bmad::reallocate_bp_com_const,
      R"""(No docstring available

)""");
  m.def(
      "check_for_superimpose_problem",
      &python_check_for_superimpose_problem,
      py::arg("branch"),
      py::arg("super_ele"),
      py::arg("err_flag"),
      py::arg("ref_ele") = py::none(),
      py::arg("wrap"),
      R"""(Subroutine to check if there is a problem superimposing an element when there is multipass.

In particular will check that:
1) If the ref_ele is part of a multipass region then super_ele must be superimposed
within the region.
Or:
2) If the ref_ele is not part of a multipass region then super_ele must also not
be part of a multipass region.
This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

)""");
  py::class_<
      PyCheckForSuperimposeProblem,
      std::unique_ptr<PyCheckForSuperimposeProblem>>(
      m,
      "CheckForSuperimposeProblem",
      "Fortran routine check_for_superimpose_problem return value")
      .def_readonly("err_flag", &PyCheckForSuperimposeProblem::err_flag)
      .def_readonly("wrap", &PyCheckForSuperimposeProblem::wrap)
      .def("__len__", [](const PyCheckForSuperimposeProblem&) { return 2; })
      .def(
          "__getitem__",
          [](const PyCheckForSuperimposeProblem& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.wrap);
            return py::none();
          });
  m.def(
      "drift_and_pipe_track_methods_adjustment",
      &Bmad::drift_and_pipe_track_methods_adjustment,
      py::arg("lat"),
      R"""(Drift and pipe elements can be used in both photon and non-photon lines.

A problem occures if, for example, a lattice file with both photon and
non-photon lines contains a line like:
drift::*[tracking_method] = taylor
So this routine resets drift and pipe tracking_method and mat6_calc_method
parameters in photon lines to bmad_standard if needed.

Parameters
----------
lat : LatStruct
    Lattice
    This parameter is an input/output and is modified in-place. As an output: Lattice with tracking methods
    adjusted if needed.
)""");
  m.def(
      "settable_dep_var_bookkeeping",
      &Bmad::settable_dep_var_bookkeeping,
      py::arg("ele"),
      R"""(Subroutine to initialize dependent variables in an element.

This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

)""");
  m.def(
      "form_digested_bmad_file_name",
      &Bmad::form_digested_bmad_file_name,
      py::arg("lat_file"),
      py::arg("use_line") = py::none(),
      R"""(Subroutine to form the standard name of the Bmad digested file.

The standard digested file name has the suffix added to the file name:
suffix = '.digested' + bmad_inc_version$
Exception: If the use_line argument is present and not blank, the suffix will be:
suffix = '.' + use_line + '.digested' + bmad_inc_version$

Parameters
----------
lat_file : unknown
    Input lattice file name.
use_line : unknown, optional
    Line used for lattice expansion. If not present or blank, the line used is the one that was specified in
    the lattice file.

Return value is a dictionary containing values below.


Returns
-------
digested_file : unknown
    Name of the digested file.
full_lat_file : unknown
    Input lattice file name with full directory. Can be used for error messages.
)""");
  py::class_<
      Bmad::FormDigestedBmadFileName,
      std::unique_ptr<Bmad::FormDigestedBmadFileName>>(
      m,
      "FormDigestedBmadFileName",
      "Fortran routine form_digested_bmad_file_name return value")
      .def_readonly(
          "digested_file", &Bmad::FormDigestedBmadFileName::digested_file)
      .def_readonly(
          "full_lat_file", &Bmad::FormDigestedBmadFileName::full_lat_file)
      .def("__len__", [](const Bmad::FormDigestedBmadFileName&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::FormDigestedBmadFileName& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.digested_file);
            if (i == 1)
              return py::cast(s.full_lat_file);
            return py::none();
          });
  m.def(
      "parser_identify_fork_to_element",
      &Bmad::parser_identify_fork_to_element,
      py::arg("lat"),
      R"""(Routine to identify the elements the forks in a lattice are branching to.

This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is not intended for general use.

)""");
  m.def(
      "bp_set_ran_status",
      &Bmad::bp_set_ran_status,
      R"""(No docstring available

)""");
  m.def(
      "parse_cartesian_map",
      &python_parse_cartesian_map,
      py::arg("ct_map"),
      py::arg("ele"),
      py::arg("lat"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err_flag"),
      R"""(Subroutine to parse a "cartesian_map = {}" construct

This subroutine is used by bmad_parser and bmad_parser2.
This subroutine is private to bmad_parser_mod.
This must read in:
{type = ,
dr = ,
r0 = ,
pt(i,j,k) = ( (ex_re, ex_im), .... (bz_re, bz_im) )
.
.
. ) },

)""");
  py::class_<PyParseCartesianMap, std::unique_ptr<PyParseCartesianMap>>(
      m,
      "ParseCartesianMap",
      "Fortran routine parse_cartesian_map return value")
      .def_readonly("delim", &PyParseCartesianMap::delim)
      .def_readonly("delim_found", &PyParseCartesianMap::delim_found)
      .def_readonly("err_flag", &PyParseCartesianMap::err_flag)
      .def("__len__", [](const PyParseCartesianMap&) { return 3; })
      .def(
          "__getitem__",
          [](const PyParseCartesianMap& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "parse_cylindrical_map",
      &python_parse_cylindrical_map,
      py::arg("cl_map"),
      py::arg("ele"),
      py::arg("lat"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
cl_map : 
ele : 
lat : 
delim : 
delim_found : 
err_flag : 
)""");
  py::class_<PyParseCylindricalMap, std::unique_ptr<PyParseCylindricalMap>>(
      m,
      "ParseCylindricalMap",
      "Fortran routine parse_cylindrical_map return value")
      .def_readonly("delim", &PyParseCylindricalMap::delim)
      .def_readonly("delim_found", &PyParseCylindricalMap::delim_found)
      .def_readonly("err_flag", &PyParseCylindricalMap::err_flag)
      .def("__len__", [](const PyParseCylindricalMap&) { return 3; })
      .def(
          "__getitem__",
          [](const PyParseCylindricalMap& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "parse_grid_field",
      &python_parse_grid_field,
      py::arg("g_field"),
      py::arg("ele"),
      py::arg("lat"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
g_field : 
ele : 
lat : 
delim : 
delim_found : 
err_flag : 
)""");
  py::class_<PyParseGridField, std::unique_ptr<PyParseGridField>>(
      m, "ParseGridField", "Fortran routine parse_grid_field return value")
      .def_readonly("delim", &PyParseGridField::delim)
      .def_readonly("delim_found", &PyParseGridField::delim_found)
      .def_readonly("err_flag", &PyParseGridField::err_flag)
      .def("__len__", [](const PyParseGridField&) { return 3; })
      .def(
          "__getitem__", [](const PyParseGridField& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "parse_gen_grad_map",
      &python_parse_gen_grad_map,
      py::arg("gg_map"),
      py::arg("ele"),
      py::arg("lat"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err_flag"),
      R"""(Subroutine to parse a "gen_grad_map = {}" construct

)""");
  py::class_<PyParseGenGradMap, std::unique_ptr<PyParseGenGradMap>>(
      m, "ParseGenGradMap", "Fortran routine parse_gen_grad_map return value")
      .def_readonly("delim", &PyParseGenGradMap::delim)
      .def_readonly("delim_found", &PyParseGenGradMap::delim_found)
      .def_readonly("err_flag", &PyParseGenGradMap::err_flag)
      .def("__len__", [](const PyParseGenGradMap&) { return 3; })
      .def(
          "__getitem__",
          [](const PyParseGenGradMap& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "parse_integer_list",
      &python_parse_integer_list,
      py::arg("err_str"),
      py::arg("lat"),
      py::arg("int_array"),
      py::arg("exact_size"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("open_delim") = py::none(),
      py::arg("separator") = py::none(),
      py::arg("close_delim") = py::none(),
      py::arg("default_value") = py::none(),
      py::arg("is_ok"),
      R"""(separator, close_delim, default_value) result (is_ok)

Routine to parse a list of integers of the form:
open_delim integer_1 separator integer_2 . . . close_delim
Example:   "(1.2, 2.3, 4.4, 8.5)"
Similar to parse_integer_list2 except does not use allocatable array.
See parse_integer_list2 for more details

)""");
  py::class_<PyParseIntegerList, std::unique_ptr<PyParseIntegerList>>(
      m, "ParseIntegerList", "Fortran routine parse_integer_list return value")
      .def_readonly("err_str", &PyParseIntegerList::err_str)
      .def_readonly("exact_size", &PyParseIntegerList::exact_size)
      .def_readonly("delim", &PyParseIntegerList::delim)
      .def_readonly("delim_found", &PyParseIntegerList::delim_found)
      .def_readonly("open_delim", &PyParseIntegerList::open_delim)
      .def_readonly("separator", &PyParseIntegerList::separator)
      .def_readonly("close_delim", &PyParseIntegerList::close_delim)
      .def_readonly("default_value", &PyParseIntegerList::default_value)
      .def_readonly("is_ok", &PyParseIntegerList::is_ok)
      .def("__len__", [](const PyParseIntegerList&) { return 9; })
      .def(
          "__getitem__",
          [](const PyParseIntegerList& s, size_t i) -> py::object {
            if (i >= 9)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_str);
            if (i == 1)
              return py::cast(s.exact_size);
            if (i == 2)
              return py::cast(s.delim);
            if (i == 3)
              return py::cast(s.delim_found);
            if (i == 4)
              return py::cast(s.open_delim);
            if (i == 5)
              return py::cast(s.separator);
            if (i == 6)
              return py::cast(s.close_delim);
            if (i == 7)
              return py::cast(s.default_value);
            if (i == 8)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "parse_integer_list2",
      &python_parse_integer_list2,
      py::arg("err_str"),
      py::arg("lat"),
      py::arg("int_array"),
      py::arg("num_expected") = py::none(),
      py::arg("open_delim") = py::none(),
      py::arg("separator") = py::none(),
      py::arg("close_delim") = py::none(),
      py::arg("default_value") = py::none(),
      R"""(open_delim, separator, close_delim, default_value) result (is_ok)

Routine to parse a list of integers of the form
open_delim integer_1 separator integer_2 . . . close_delim
Example:   (1, 2, 4, 8)

Parameters
----------
err_str : unknown
    Error string to print if there is an error.
lat : LatStruct
    lattice
int_array : int
    the array to be read in Optional: num_expected = 1     -- integer: number of expected arguments. Used to
    initialize int_array. open_delim   = '('   -- character(1): opening delimeter. separator    = ','   --
    character(1): separating character. close_delim  = ')'   -- character(1): closing delimeter. default_value
    = 0    -- real(rp): inital assignment of int_array elements.
    This parameter is an input/output and is modified in-place. As an output: Array of values.

Return value is a dictionary containing values below.


Returns
-------
is_ok : bool
    Set True if everything is ok.
num_found : int
    number of elements.
delim : unknown
    Delimiter found where the parsing of the input line stops.
delim_found : bool
    Delimiter found? False if end of input command.
)""");
  py::class_<PyParseIntegerList2, std::unique_ptr<PyParseIntegerList2>>(
      m,
      "ParseIntegerList2",
      "Fortran routine parse_integer_list2 return value")
      .def_readonly("num_found", &PyParseIntegerList2::num_found)
      .def_readonly("delim", &PyParseIntegerList2::delim)
      .def_readonly("delim_found", &PyParseIntegerList2::delim_found)
      .def_readonly("is_ok", &PyParseIntegerList2::is_ok)
      .def_readonly("num_expected", &PyParseIntegerList2::num_expected)
      .def_readonly("open_delim", &PyParseIntegerList2::open_delim)
      .def_readonly("separator", &PyParseIntegerList2::separator)
      .def_readonly("close_delim", &PyParseIntegerList2::close_delim)
      .def_readonly("default_value", &PyParseIntegerList2::default_value)
      .def("__len__", [](const PyParseIntegerList2&) { return 9; })
      .def(
          "__getitem__",
          [](const PyParseIntegerList2& s, size_t i) -> py::object {
            if (i >= 9)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.num_found);
            if (i == 1)
              return py::cast(s.delim);
            if (i == 2)
              return py::cast(s.delim_found);
            if (i == 3)
              return py::cast(s.is_ok);
            if (i == 4)
              return py::cast(s.num_expected);
            if (i == 5)
              return py::cast(s.open_delim);
            if (i == 6)
              return py::cast(s.separator);
            if (i == 7)
              return py::cast(s.close_delim);
            if (i == 8)
              return py::cast(s.default_value);
            return py::none();
          });
  m.def(
      "parse_real_list",
      &Bmad::parse_real_list,
      py::arg("lat"),
      py::arg("err_str"),
      py::arg("exact_size"),
      py::arg("open_delim") = py::none(),
      py::arg("separator") = py::none(),
      py::arg("close_delim") = py::none(),
      py::arg("default_value") = py::none(),
      R"""(separator, close_delim, default_value, num_found) result (is_ok)

Routine to parse a list of reals of the form:
open_delim real_1 separator real_2 . . . close_delim
Example:   "(1.2, 2.3, 4.4, 8.5)"
Similar to parse_real_list2 except does not use allocatable array.

Parameters
----------
lat : LatStruct
    Lattice
err_str : unknown
    Error string to print if there is an error.
exact_size : 
open_delim : 
separator : 
close_delim : 
default_value : 

Return value is a dictionary containing values below.


Returns
-------
real_array : 
delim : 
delim_found : 
num_found : 

Notes
-----
Related routines:
parse_real_matrix.
)""");
  py::class_<Bmad::ParseRealList, std::unique_ptr<Bmad::ParseRealList>>(
      m, "ParseRealList", "Fortran routine parse_real_list return value")
      .def_readonly("real_array", &Bmad::ParseRealList::real_array)
      .def_readonly("delim", &Bmad::ParseRealList::delim)
      .def_readonly("delim_found", &Bmad::ParseRealList::delim_found)
      .def_readonly("num_found", &Bmad::ParseRealList::num_found)
      .def_readonly("is_ok", &Bmad::ParseRealList::is_ok)
      .def("__len__", [](const Bmad::ParseRealList&) { return 5; })
      .def(
          "__getitem__",
          [](const Bmad::ParseRealList& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.real_array);
            if (i == 1)
              return py::cast(s.delim);
            if (i == 2)
              return py::cast(s.delim_found);
            if (i == 3)
              return py::cast(s.num_found);
            if (i == 4)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "parse_real_list2",
      &python_parse_real_list2,
      py::arg("lat"),
      py::arg("err_str"),
      py::arg("real_array"),
      py::arg("num_expected") = py::none(),
      py::arg("open_brace") = py::none(),
      py::arg("separator") = py::none(),
      py::arg("close_brace") = py::none(),
      py::arg("default_value") = py::none(),
      py::arg("single_value") = py::none(),
      R"""(open_delim, separator, close_delim, default_value, single_value) result (is_ok)

Routine to parse a list of reals of the form:
open_brace real_1 separator real_2 . . . close_brace
Example:   "(1.2, 2.3, 4.4, 8.5)"

Parameters
----------
lat : LatStruct
    lattice
err_str : unknown
    Error string to print if there is an error.
real_array : float
    the array to be read in num_expected = 10       -- integer, optional: number of expected arguments Used to
    initialize real_array open_brace   = '('      -- character(1), optional: opening delimeter. separator    =
    ','      -- character(1), optional: separating character close_brace  = ')'      -- character(1),
    optional: closing delimeter default_value = 0.0_rp  -- real(rp), optional: inital assignment of real_array
    elements. single_value = False    -- logical, optional: If true then an array with a single value and no
    braces is accepted.
    This parameter is an input/output and is modified in-place. As an output: Array of values

Return value is a dictionary containing values below.


Returns
-------
is_ok : bool
    Set True if everything is ok
num_found : int
    number of elements
delim : unknown
    Delimiter found where the parsing of the input line stops.
delim_found : bool
    Stopping delimiter found? False if end of input command.

Notes
-----
Related routines:
pase_real_list parse_real_matrix.
)""");
  py::class_<PyParseRealList2, std::unique_ptr<PyParseRealList2>>(
      m, "ParseRealList2", "Fortran routine parse_real_list2 return value")
      .def_readonly("num_found", &PyParseRealList2::num_found)
      .def_readonly("delim", &PyParseRealList2::delim)
      .def_readonly("delim_found", &PyParseRealList2::delim_found)
      .def_readonly("is_ok", &PyParseRealList2::is_ok)
      .def_readonly("num_expected", &PyParseRealList2::num_expected)
      .def_readonly("open_brace", &PyParseRealList2::open_brace)
      .def_readonly("separator", &PyParseRealList2::separator)
      .def_readonly("close_brace", &PyParseRealList2::close_brace)
      .def_readonly("default_value", &PyParseRealList2::default_value)
      .def_readonly("single_value", &PyParseRealList2::single_value)
      .def("__len__", [](const PyParseRealList2&) { return 10; })
      .def(
          "__getitem__", [](const PyParseRealList2& s, size_t i) -> py::object {
            if (i >= 10)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.num_found);
            if (i == 1)
              return py::cast(s.delim);
            if (i == 2)
              return py::cast(s.delim_found);
            if (i == 3)
              return py::cast(s.is_ok);
            if (i == 4)
              return py::cast(s.num_expected);
            if (i == 5)
              return py::cast(s.open_brace);
            if (i == 6)
              return py::cast(s.separator);
            if (i == 7)
              return py::cast(s.close_brace);
            if (i == 8)
              return py::cast(s.default_value);
            if (i == 9)
              return py::cast(s.single_value);
            return py::none();
          });
  m.def(
      "parser_get_integer",
      &python_parser_get_integer,
      py::arg("int_val"),
      py::arg("word"),
      py::arg("ix_word"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err"),
      py::arg("str1") = py::none(),
      py::arg("str2") = py::none(),
      R"""(No docstring available

Parameters
----------
int_val : 
word : 
ix_word : 
delim : 
delim_found : 
err : 
str1 : 
str2 : 
)""");
  py::class_<PyParserGetInteger, std::unique_ptr<PyParserGetInteger>>(
      m, "ParserGetInteger", "Fortran routine parser_get_integer return value")
      .def_readonly("int_val", &PyParserGetInteger::int_val)
      .def_readonly("word", &PyParserGetInteger::word)
      .def_readonly("ix_word", &PyParserGetInteger::ix_word)
      .def_readonly("delim", &PyParserGetInteger::delim)
      .def_readonly("delim_found", &PyParserGetInteger::delim_found)
      .def_readonly("err", &PyParserGetInteger::err)
      .def_readonly("str1", &PyParserGetInteger::str1)
      .def_readonly("str2", &PyParserGetInteger::str2)
      .def("__len__", [](const PyParserGetInteger&) { return 8; })
      .def(
          "__getitem__",
          [](const PyParserGetInteger& s, size_t i) -> py::object {
            if (i >= 8)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.int_val);
            if (i == 1)
              return py::cast(s.word);
            if (i == 2)
              return py::cast(s.ix_word);
            if (i == 3)
              return py::cast(s.delim);
            if (i == 4)
              return py::cast(s.delim_found);
            if (i == 5)
              return py::cast(s.err);
            if (i == 6)
              return py::cast(s.str1);
            if (i == 7)
              return py::cast(s.str2);
            return py::none();
          });
  m.def(
      "parser_get_logical",
      &python_parser_get_logical,
      py::arg("attrib_name"),
      py::arg("this_logic"),
      py::arg("ele_name"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
attrib_name : 
this_logic : 
ele_name : 
delim : 
delim_found : 
err : 
)""");
  py::class_<PyParserGetLogical, std::unique_ptr<PyParserGetLogical>>(
      m, "ParserGetLogical", "Fortran routine parser_get_logical return value")
      .def_readonly("attrib_name", &PyParserGetLogical::attrib_name)
      .def_readonly("this_logic", &PyParserGetLogical::this_logic)
      .def_readonly("ele_name", &PyParserGetLogical::ele_name)
      .def_readonly("delim", &PyParserGetLogical::delim)
      .def_readonly("delim_found", &PyParserGetLogical::delim_found)
      .def_readonly("err", &PyParserGetLogical::err)
      .def("__len__", [](const PyParserGetLogical&) { return 6; })
      .def(
          "__getitem__",
          [](const PyParserGetLogical& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.attrib_name);
            if (i == 1)
              return py::cast(s.this_logic);
            if (i == 2)
              return py::cast(s.ele_name);
            if (i == 3)
              return py::cast(s.delim);
            if (i == 4)
              return py::cast(s.delim_found);
            if (i == 5)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "expect_this",
      &Bmad::expect_this,
      py::arg("expecting"),
      py::arg("check_delim"),
      py::arg("call_check"),
      py::arg("err_str"),
      py::arg("ele"),
      R"""(Checks that the next character or characters in the parse stream corresponds to the

characters in the expecting argument. For example, if expecting is ')={' these three characters
should be the next non-blank characters in the parse stream.

Parameters
----------
expecting : unknown
    list of characters that are expected to be next in the parse stream.
check_delim : bool
    If True then use delim argument as first token to check. A blank character indicates end of command is
    expected.
call_check : bool
    If True then check for 'call::<filename>' construct.
err_str : unknown
    String used for error messages.
ele : EleStruct
    Element parameters being parsed.

Return value is a dictionary containing values below.


Returns
-------
delim : unknown
    Final delim
delim_found : bool
    Is there a final delim (as opposed to end of command).

Notes
-----
Related routines:
expect_one_of
)""");
  py::class_<Bmad::ExpectThis, std::unique_ptr<Bmad::ExpectThis>>(
      m, "ExpectThis", "Fortran routine expect_this return value")
      .def_readonly("delim", &Bmad::ExpectThis::delim)
      .def_readonly("delim_found", &Bmad::ExpectThis::delim_found)
      .def_readonly("is_ok", &Bmad::ExpectThis::is_ok)
      .def("__len__", [](const Bmad::ExpectThis&) { return 3; })
      .def(
          "__getitem__", [](const Bmad::ExpectThis& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim);
            if (i == 1)
              return py::cast(s.delim_found);
            if (i == 2)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "expect_one_of",
      &python_expect_one_of,
      py::arg("delim_list"),
      py::arg("check_input_delim"),
      py::arg("ele_name"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("is_ok"),
      R"""(Routine to check either that the current delimitor or the next character in the parse stream is the

expected delimitor.
This routine is used for Bmad lattice file parsing and is not meant for general use.

Parameters
----------
delim_list : unknown
    List of expected (valid) delimitors. If list contains a space character then no delimitor (indicating the
    end of the command) is a valid possibility.
check_input_delim : bool
    If True, then check if delim argument is in the delim_list. -- logical: If True, then check if delim
    argument is in the delim_list. If False, check that the next character in the parse stream is an expected
    delimitor.
ele_name : unknown
    Lattice element under construction. Used for error messages.
delim : unknown
    Current delimitor that will be checked if check_input_delim = .true.
    This parameter is an input/output and is modified in-place. As an output: Next delim if check_input_delim
    = False.

Returns
-------
is_ok

Notes
-----
Related routines:
expect_this
)""");
  py::class_<PyExpectOneOf, std::unique_ptr<PyExpectOneOf>>(
      m, "ExpectOneOf", "Fortran routine expect_one_of return value")
      .def_readonly("delim", &PyExpectOneOf::delim)
      .def_readonly("delim_found", &PyExpectOneOf::delim_found)
      .def_readonly("is_ok", &PyExpectOneOf::is_ok)
      .def("__len__", [](const PyExpectOneOf&) { return 3; })
      .def("__getitem__", [](const PyExpectOneOf& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.delim);
        if (i == 1)
          return py::cast(s.delim_found);
        if (i == 2)
          return py::cast(s.is_ok);
        return py::none();
      });
  m.def(
      "equal_sign_here",
      &python_equal_sign_here,
      py::arg("ele"),
      py::arg("delim"),
      py::arg("is_here"),
      R"""(No docstring available

Parameters
----------
ele : 
delim : 
is_here : 
)""");
  py::class_<PyEqualSignHere, std::unique_ptr<PyEqualSignHere>>(
      m, "EqualSignHere", "Fortran routine equal_sign_here return value")
      .def_readonly("delim", &PyEqualSignHere::delim)
      .def_readonly("is_here", &PyEqualSignHere::is_here)
      .def("__len__", [](const PyEqualSignHere&) { return 2; })
      .def("__getitem__", [](const PyEqualSignHere& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.delim);
        if (i == 1)
          return py::cast(s.is_here);
        return py::none();
      });
  m.def(
      "parser_print_line",
      &python_parser_print_line,
      py::arg("lat"),
      py::arg("end_of_file"),
      R"""(This routine is called when a print statement is found in the lattice file.

)""");
  py::class_<PyParserPrintLine, std::unique_ptr<PyParserPrintLine>>(
      m, "ParserPrintLine", "Fortran routine parser_print_line return value")
      .def_readonly("end_of_file", &PyParserPrintLine::end_of_file)
      .def("__len__", [](const PyParserPrintLine&) { return 1; })
      .def(
          "__getitem__",
          [](const PyParserPrintLine& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.end_of_file);
            return py::none();
          });
  m.def(
      "parser_init_custom_elements",
      &Bmad::parser_init_custom_elements,
      py::arg("lat"),
      R"""()""");
  m.def(
      "init_surface_segment",
      &python_init_surface_segment,
      py::arg("phot"),
      py::arg("ix"),
      py::arg("iy"),
      R"""(Routine to init the componentes in ele%photon%segmented%pt(ix,iy) for use with segmented surface calculations.

Parameters
----------
phot : unknown
    index of grid point to init.
)""");
  py::class_<PyInitSurfaceSegment, std::unique_ptr<PyInitSurfaceSegment>>(
      m,
      "InitSurfaceSegment",
      "Fortran routine init_surface_segment return value")
      .def_readonly("ix", &PyInitSurfaceSegment::ix)
      .def_readonly("iy", &PyInitSurfaceSegment::iy)
      .def("__len__", [](const PyInitSurfaceSegment&) { return 2; })
      .def(
          "__getitem__",
          [](const PyInitSurfaceSegment& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix);
            if (i == 1)
              return py::cast(s.iy);
            return py::none();
          });
  m.def(
      "parser_transfer_control_struct",
      &Bmad::parser_transfer_control_struct,
      py::arg("con_in"),
      py::arg("lord"),
      py::arg("ix_var"),
      R"""(Routine to transfer the information from an input control_struct (which stores

the user input parameters) to a control_struct that will be stored in the lat%control
or lord%control%ramp for a ramper.

Parameters
----------
con_in : ControlStruct
    Input control structure.
lord : EleStruct
    Lord element associated with the control_struct.
ix_var : int
    If an expression stack evaluates to a constant, this routine will modify the expression stack to evaluate
    to the value of: lord.control.var(ix_var) * constant

Returns
-------
con_out : ControlStruct
    Output control structure.
)""");
  m.def(
      "parser_fast_integer_read",
      &python_parser_fast_integer_read,
      py::arg("int_vec"),
      py::arg("ele"),
      py::arg("delim_wanted"),
      py::arg("err_str"),
      py::arg("is_ok"),
      R"""(
Returns
-------
is_ok
)""");
  py::class_<PyParserFastIntegerRead, std::unique_ptr<PyParserFastIntegerRead>>(
      m,
      "ParserFastIntegerRead",
      "Fortran routine parser_fast_integer_read return value")
      .def_readonly("delim_wanted", &PyParserFastIntegerRead::delim_wanted)
      .def_readonly("err_str", &PyParserFastIntegerRead::err_str)
      .def_readonly("is_ok", &PyParserFastIntegerRead::is_ok)
      .def("__len__", [](const PyParserFastIntegerRead&) { return 3; })
      .def(
          "__getitem__",
          [](const PyParserFastIntegerRead& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.delim_wanted);
            if (i == 1)
              return py::cast(s.err_str);
            if (i == 2)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "parser_fast_complex_read",
      &Bmad::parser_fast_complex_read,
      py::arg("ele"),
      py::arg("err_str"),
      R"""(Routine to read an array of complex numbers.

This routine assumes that the array values are pure numbers in the form "<re>" or "(<re> <im>)"
where <re> and <im> are real numbers (not expressions) and there are no commas except possibly
at the end of the array.

Parameters
----------
ele : EleStruct
    Lattice element associated with the array. Used for error messages.
err_str : unknown
    String used when printing error messages identifying where in the lattice file the error is occuring.

Return value is a dictionary containing values below.


Returns
-------
cmplx_vec : complex
    Complex vector.
delim : unknown
    Delimitor at end of array. Must be "," or "}"
is_ok : bool
    True if everything OK. False otherwise.
)""");
  py::class_<
      Bmad::ParserFastComplexRead,
      std::unique_ptr<Bmad::ParserFastComplexRead>>(
      m,
      "ParserFastComplexRead",
      "Fortran routine parser_fast_complex_read return value")
      .def_readonly("cmplx_vec", &Bmad::ParserFastComplexRead::cmplx_vec)
      .def_readonly("delim", &Bmad::ParserFastComplexRead::delim)
      .def_readonly("is_ok", &Bmad::ParserFastComplexRead::is_ok)
      .def("__len__", [](const Bmad::ParserFastComplexRead&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::ParserFastComplexRead& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.cmplx_vec);
            if (i == 1)
              return py::cast(s.delim);
            if (i == 2)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "parser_fast_real_read",
      &Bmad::parser_fast_real_read,
      py::arg("ele"),
      py::arg("end_delims"),
      py::arg("err_str"),
      py::arg("exact_size") = py::none(),
      R"""(Routine to read an array of real numbers.

This routine assumes that the array values are pure numbers in the form "<re1> <re2> ...,"
where <re1>, <re2>, etc. are real numbers (not expressions) and there are no commas except possibly,
at the end of the array.

Parameters
----------
ele : EleStruct
    Lattice element associated with the array. Used for error messages.
end_delims : unknown
    List of possible ending delimitors.
err_str : unknown
    String used when printing error messages identifying where in the lattice file the error is occuring.
exact_size : bool, optional
    If True (default), number of values must match real_vec size.

Return value is a dictionary containing values below.


Returns
-------
real_vec : complex
    Real vector.
delim : unknown
    Delimitor at end of array.
is_ok : bool
    True if everything OK. False otherwise.
n_real : int
    Number of elements found.
)""");
  py::class_<
      Bmad::ParserFastRealRead,
      std::unique_ptr<Bmad::ParserFastRealRead>>(
      m,
      "ParserFastRealRead",
      "Fortran routine parser_fast_real_read return value")
      .def_readonly("real_vec", &Bmad::ParserFastRealRead::real_vec)
      .def_readonly("delim", &Bmad::ParserFastRealRead::delim)
      .def_readonly("n_real", &Bmad::ParserFastRealRead::n_real)
      .def_readonly("is_ok", &Bmad::ParserFastRealRead::is_ok)
      .def("__len__", [](const Bmad::ParserFastRealRead&) { return 4; })
      .def(
          "__getitem__",
          [](const Bmad::ParserFastRealRead& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.real_vec);
            if (i == 1)
              return py::cast(s.delim);
            if (i == 2)
              return py::cast(s.n_real);
            if (i == 3)
              return py::cast(s.is_ok);
            return py::none();
          });
  m.def(
      "photon_reflection_std_surface_init",
      &Bmad::photon_reflection_std_surface_init,
      R"""(Routine to initialize the standard proton reflection probability tables.

The standard tables are for 10 nm C film on Al substrate.
The surface roughness for diffuse scattering is 200 nm and the
the surface roughness correlation length is 5.5 um.


Returns
-------
surface : 
    photon_reflect_surface_struct
)""");
  m.def(
      "finalize_reflectivity_table",
      &Bmad::finalize_reflectivity_table,
      py::arg("table"),
      py::arg("in_degrees"),
      R"""(Routine to finalize the construction of the reflectivity tables for a surface.

Parameters
----------
table : PhotonReflectTableStruct
    Surface tables to be finalized.
    This parameter is an input/output and is modified in-place. As an output: Finalized surface tables.
in_degrees : bool
    Table angles in degrees?
)""");
  m.def(
      "read_surface_reflection_file",
      &Bmad::read_surface_reflection_file,
      py::arg("file_name"),
      R"""(Routine to read the reflection probability data for a given type of surface from a file.

Parameters
----------
file_name : unknown
    Name of the file.

Returns
-------
surface : PhotonReflectSurfaceStruct
    Surface info.
)""");
  m.def(
      "photon_reflectivity",
      &Bmad::photon_reflectivity,
      py::arg("angle"),
      py::arg("energy"),
      py::arg("surface"),
      R"""(Routine to evaluate the photon reflectivity.

probability of absorption          = 1 - p_reflect
probability of reflection          = p_reflect
probability of specular reflection = p_reflect * rel_p_specular
probability of diffuse reflection  = p_reflect * (1 - rel_p_specular)
Use photon_reflection_std_surface_init or read_surface_reflection_file to get surface info.

Parameters
----------
angle : float
    Incident grazing angle in radians.
energy : float
    Photon energy in eV.
surface : PhotonReflectSurfaceStruct
    surface info

Return value is a dictionary containing values below.


Returns
-------
p_reflect : float
    Reflection probability.
rel_p_specular : float
    Relative specular reflection probability.
)""");
  py::class_<
      Bmad::PhotonReflectivity,
      std::unique_ptr<Bmad::PhotonReflectivity>>(
      m,
      "PhotonReflectivity",
      "Fortran routine photon_reflectivity return value")
      .def_readonly("p_reflect", &Bmad::PhotonReflectivity::p_reflect)
      .def_readonly("rel_p_specular", &Bmad::PhotonReflectivity::rel_p_specular)
      .def("__len__", [](const Bmad::PhotonReflectivity&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::PhotonReflectivity& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.p_reflect);
            if (i == 1)
              return py::cast(s.rel_p_specular);
            return py::none();
          });
  m.def(
      "photon_reflection",
      &Bmad::photon_reflection,
      py::arg("graze_angle_in"),
      py::arg("energy"),
      py::arg("surface"),
      R"""(Routine to reflect a photon from a surface including both diffuse and specular reflections.

Parameters
----------
graze_angle_in : float
    Incident grazing (not polar) angle in radians.
energy : float
    Photon energy in eV.
surface : PhotonReflectSurfaceStruct
    surface info

Return value is a dictionary containing values below.


Returns
-------
graze_angle_out : float
    graze_angle in radians.
phi_out : float
    Azimuthal angle in radians.
)""");
  py::class_<Bmad::PhotonReflection, std::unique_ptr<Bmad::PhotonReflection>>(
      m, "PhotonReflection", "Fortran routine photon_reflection return value")
      .def_readonly("graze_angle_out", &Bmad::PhotonReflection::graze_angle_out)
      .def_readonly("phi_out", &Bmad::PhotonReflection::phi_out)
      .def("__len__", [](const Bmad::PhotonReflection&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::PhotonReflection& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.graze_angle_out);
            if (i == 1)
              return py::cast(s.phi_out);
            return py::none();
          });
  m.def(
      "has_curvature",
      &Bmad::has_curvature,
      py::arg("phot_ele"),
      R"""(Routine to determine if a surface is potentially curved or is flat.

Parameters
----------
phot_ele : PhotonElementStruct
    From ele.photon

Returns
-------
curved : bool
    Set True if phot_eleace is curved.
)""");
  m.def(
      "photon_type",
      &Bmad::photon_type,
      py::arg("ele"),
      R"""(Routine to return the type of photon to be tracked: coherent$ or incoherent$.

Parameters
----------
ele : EleStruct
    Element being tracked through.

Returns
-------
e_type : int
    coherent$ or incoherent$
)""");
  m.def(
      "z_at_surface",
      &python_z_at_surface,
      py::arg("ele"),
      py::arg("x"),
      py::arg("y"),
      py::arg("extend_grid") = py::none(),
      R"""(Routine return the height (z) of the surface for a particular (x,y) position.

Parameters
----------
ele : EleStruct
    Element x, y        -- real(rp): Photon coordinates on surface.
extend_grid : bool, optional
    If a grid is involved and (x, y) is outside of the grid, and extend_grid = True: Pretend (x, y) is at
    edge. Default is False.

Return value is a dictionary containing values below.


Returns
-------
z : float
    z coordinate.
err_flag : bool
    Set True if cannot compute z due to, say, point being outside of ellipseoid or grid bounds.
dz_dxy : float
    Surface slope at (x, y).

Notes
-----
Remember: +z points into the element.
)""");
  py::class_<PyZAtSurface, std::unique_ptr<PyZAtSurface>>(
      m, "ZAtSurface", "Fortran routine z_at_surface return value")
      .def_readonly("err_flag", &PyZAtSurface::err_flag)
      .def_readonly("dz_dxy", &PyZAtSurface::dz_dxy)
      .def_readonly("z", &PyZAtSurface::z)
      .def_readonly("x", &PyZAtSurface::x)
      .def_readonly("y", &PyZAtSurface::y)
      .def("__len__", [](const PyZAtSurface&) { return 5; })
      .def("__getitem__", [](const PyZAtSurface& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        if (i == 1)
          return py::cast(s.dz_dxy);
        if (i == 2)
          return py::cast(s.z);
        if (i == 3)
          return py::cast(s.x);
        if (i == 4)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "surface_grid_displacement",
      &python_surface_grid_displacement,
      py::arg("ele"),
      py::arg("x"),
      py::arg("y"),
      py::arg("err_flag"),
      py::arg("z"),
      py::arg("dz_dxy") = py::none(),
      py::arg("extend_grid") = py::none(),
      R"""(Routine to add in the z displacement defined by the grid

Parameters
----------
ele : EleStruct
    Element containing the grid x, y          -- real(rp): Photon coords at surface.
extend_grid : bool, optional
    If (x,y) past grid pretend (x,y) is at grid boundary. Default is False. Output
err_flag : bool
    Set True if there is a problem.
z : float
    surface height at (x, y).
dz_dxy : float, optional
    Surface slope at (x, y).
)""");
  py::class_<
      PySurfaceGridDisplacement,
      std::unique_ptr<PySurfaceGridDisplacement>>(
      m,
      "SurfaceGridDisplacement",
      "Fortran routine surface_grid_displacement return value")
      .def_readonly("x", &PySurfaceGridDisplacement::x)
      .def_readonly("y", &PySurfaceGridDisplacement::y)
      .def("__len__", [](const PySurfaceGridDisplacement&) { return 2; })
      .def(
          "__getitem__",
          [](const PySurfaceGridDisplacement& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.x);
            if (i == 1)
              return py::cast(s.y);
            return py::none();
          });
  m.def(
      "pointer_to_surface_segmented_pt",
      &python_pointer_to_surface_segmented_pt,
      py::arg("ele"),
      py::arg("nearest"),
      py::arg("x"),
      py::arg("y"),
      py::arg("ix") = py::none(),
      py::arg("iy") = py::none(),
      py::arg("extend_grid") = py::none(),
      py::arg("xx") = py::none(),
      py::arg("yy") = py::none(),
      R"""(Routine to point to the grid point struct associated with point (x,y).

Parameters
----------
ele : EleStruct
    Element containing the grid
nearest : bool
    If True, return pointer to nearest grid point. If False, return pointer to the grid point lower and left
    of (x,y). x, y        -- real(rp): Photon position.
extend_grid : bool, optional
    If (x,y) past grid pretend (x,y) is at grid boundary. Default is False. ix, iy      -- integer, optional:
    Grid point index.

Returns
-------
pt : GridPointStruct
    Pointer to grid point. Will not be associated if (x,y) outside the grid. xx, yy      -- real(rp),
    optional: Set equal to (x, y) except if (x,y) is outside of the grid. In this case, (xx, yy) will be set
    to be on the nearest grid boundary point.
)""");
  py::class_<
      PyPointerToSurfaceSegmentedPt,
      std::unique_ptr<PyPointerToSurfaceSegmentedPt>>(
      m,
      "PointerToSurfaceSegmentedPt",
      "Fortran routine pointer_to_surface_segmented_pt return value")
      .def_readonly("pt", &PyPointerToSurfaceSegmentedPt::pt)
      .def_readonly("x", &PyPointerToSurfaceSegmentedPt::x)
      .def_readonly("y", &PyPointerToSurfaceSegmentedPt::y)
      .def_readonly("ix", &PyPointerToSurfaceSegmentedPt::ix)
      .def_readonly("iy", &PyPointerToSurfaceSegmentedPt::iy)
      .def_readonly("xx", &PyPointerToSurfaceSegmentedPt::xx)
      .def_readonly("yy", &PyPointerToSurfaceSegmentedPt::yy)
      .def("__len__", [](const PyPointerToSurfaceSegmentedPt&) { return 7; })
      .def(
          "__getitem__",
          [](const PyPointerToSurfaceSegmentedPt& s, size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.pt);
            if (i == 1)
              return py::cast(s.x);
            if (i == 2)
              return py::cast(s.y);
            if (i == 3)
              return py::cast(s.ix);
            if (i == 4)
              return py::cast(s.iy);
            if (i == 5)
              return py::cast(s.xx);
            if (i == 6)
              return py::cast(s.yy);
            return py::none();
          });
  m.def(
      "pointer_to_surface_displacement_pt",
      &python_pointer_to_surface_displacement_pt,
      py::arg("ele"),
      py::arg("nearest"),
      py::arg("x"),
      py::arg("y"),
      py::arg("ix") = py::none(),
      py::arg("iy") = py::none(),
      py::arg("extend_grid") = py::none(),
      py::arg("xx") = py::none(),
      py::arg("yy") = py::none(),
      R"""(Routine to point to the grid point struct associated with point (x,y).

Parameters
----------
ele : EleStruct
    Element containing the grid
nearest : bool
    If True, return pointer to nearest grid point. If False, return pointer to the grid point lower and left
    of (x,y). x, y        -- real(rp): Photon position.
extend_grid : bool, optional
    If (x,y) past grid pretend (x,y) is at grid boundary. Default is False. ix, iy      -- integer, optional:
    Grid point index.

Returns
-------
pt : GridPointStruct
    Pointer to grid point. Will not be associated if (x,y) outside the grid. xx, yy      -- real(rp),
    optional: Set equal to (x, y) except if (x,y) is outside of the grid. In this case, (xx, yy) will be set
    to be on the nearest grid boundary point.
)""");
  py::class_<
      PyPointerToSurfaceDisplacementPt,
      std::unique_ptr<PyPointerToSurfaceDisplacementPt>>(
      m,
      "PointerToSurfaceDisplacementPt",
      "Fortran routine pointer_to_surface_displacement_pt return value")
      .def_readonly("pt", &PyPointerToSurfaceDisplacementPt::pt)
      .def_readonly("x", &PyPointerToSurfaceDisplacementPt::x)
      .def_readonly("y", &PyPointerToSurfaceDisplacementPt::y)
      .def_readonly("ix", &PyPointerToSurfaceDisplacementPt::ix)
      .def_readonly("iy", &PyPointerToSurfaceDisplacementPt::iy)
      .def_readonly("xx", &PyPointerToSurfaceDisplacementPt::xx)
      .def_readonly("yy", &PyPointerToSurfaceDisplacementPt::yy)
      .def("__len__", [](const PyPointerToSurfaceDisplacementPt&) { return 7; })
      .def(
          "__getitem__",
          [](const PyPointerToSurfaceDisplacementPt& s,
             size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.pt);
            if (i == 1)
              return py::cast(s.x);
            if (i == 2)
              return py::cast(s.y);
            if (i == 3)
              return py::cast(s.ix);
            if (i == 4)
              return py::cast(s.iy);
            if (i == 5)
              return py::cast(s.xx);
            if (i == 6)
              return py::cast(s.yy);
            return py::none();
          });
  m.def(
      "track1_lens",
      &Bmad::track1_lens,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track through a lens.

Parameters
----------
ele : EleStruct
    Element tracking through.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "track_a_patch_photon",
      &Bmad::track_a_patch_photon,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("drift_to_exit") = py::none(),
      py::arg("use_z_pos") = py::none(),
      R"""(Routine to track through a patch element with a photon.

The steps for tracking are:
1) Transform from entrance to exit coordinates.
2) Drift particle from the entrance to the exit coordinants.

Parameters
----------
ele : EleStruct
    patch element.
orbit : CoordStruct
    Starting phase space coords
    This parameter is an input/output and is modified in-place. As an output: Coords after applying a patch
    transformation.
drift_to_exit : bool, optional
    If False then do not drift the particle from start to ending faces. Default is True.
use_z_pos : unknown, optional
    If present and True, use orbit.vec(5) as the true z-position relative to the start of the element instead
    of assuming that the particle is at the patch edge.
)""");
  m.def(
      "track1_diffraction_plate_or_mask",
      &Bmad::track1_diffraction_plate_or_mask,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track through diffraction plate and mask elements.

Parameters
----------
ele : EleStruct
    Diffraction plate or mask element.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "track1_sample",
      &Bmad::track1_sample,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track reflection from a sample element.

Parameters
----------
ele : EleStruct
    Element tracking through.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "point_photon_emission",
      &Bmad::point_photon_emission,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      py::arg("direction"),
      py::arg("max_target_area"),
      py::arg("w_to_surface") = py::none(),
      R"""(Routine to emit a photon from a point that may be on a surface.

If there is a downstream target, the emission calc will take this into account.

Parameters
----------
ele : EleStruct
    Emitting element.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords of photon. --   Will be in curved surface coords if there is a curved surface.
    This parameter is an input/output and is modified in-place. As an output: Final phase-space coords
direction : int
    +1 -> Emit in forward +z direction, -1 -> emit backwards.
max_target_area : float
    Area of the solid angle photons may be emitted over. max_target_area is used for normalizing the photon
    field. generally will be equal to twopi or fourpi.
w_to_surface : float, optional
    Rotation matrix for curved surface.
)""");
  m.def(
      "track1_mirror",
      &Bmad::track1_mirror,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track reflection from a mirror.

Parameters
----------
ele : EleStruct
    Element tracking through.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "track1_multilayer_mirror",
      &Bmad::track1_multilayer_mirror,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track reflection from a multilayer_mirror.

Basic equations are from Kohn, "On the Theory of Reflectivity of an X-Ray Multilayer Mirror".

Parameters
----------
ele : EleStruct
    Element tracking through.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "track1_mosaic_crystal",
      &Bmad::track1_mosaic_crystal,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track diffraction from a crystal.

Parameters
----------
ele : EleStruct
    Element tracking through.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "track1_crystal",
      &Bmad::track1_crystal,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to track diffraction from a crystal.

Parameters
----------
ele : EleStruct
    Element tracking through.
param : LatParamStruct
    lattice parameters.
orbit : CoordStruct
    phase-space coords to be transformed
    This parameter is an input/output and is modified in-place. As an output: final phase-space coords
)""");
  m.def(
      "crystal_h_misalign",
      &Bmad::crystal_h_misalign,
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("h_vec"),
      R"""(Routine reorient the crystal H vector due to local imperfections in the crystal lattice.

Parameters
----------
ele : EleStruct
    Crystal element
orbit : CoordStruct
    Photon position at crystal surface.
h_vec : float
    H vector before misalignment.
    This parameter is an input/output and is modified in-place. As an output: H vector after misalignment.
)""");
  m.def(
      "target_rot_mats",
      &Bmad::target_rot_mats,
      py::arg("r_center"),
      R"""(Routine to calculate the rotation matrices between ele coords and "target" coords.

By definition, in target coords r_center = [0, 0, 1].

Parameters
----------
r_center : float
    In lab coords: Center of target relative to phton emission point.

Return value is a dictionary containing values below.


Returns
-------
w_to_target : float
    Rotation matrix from ele to target coords.
w_to_ele : float
    Rotation matrix from target to ele coords.
)""");
  py::class_<Bmad::TargetRotMats, std::unique_ptr<Bmad::TargetRotMats>>(
      m, "TargetRotMats", "Fortran routine target_rot_mats return value")
      .def_readonly("w_to_target", &Bmad::TargetRotMats::w_to_target)
      .def_readonly("w_to_ele", &Bmad::TargetRotMats::w_to_ele)
      .def("__len__", [](const Bmad::TargetRotMats&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TargetRotMats& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.w_to_target);
            if (i == 1)
              return py::cast(s.w_to_ele);
            return py::none();
          });
  m.def(
      "target_min_max_calc",
      &python_target_min_max_calc,
      py::arg("r_corner1"),
      py::arg("r_corner2"),
      py::arg("y_min"),
      py::arg("y_max"),
      py::arg("phi_min"),
      py::arg("phi_max"),
      py::arg("initial") = py::none(),
      R"""(Routine to calculate the min/max values for (y, phi).

min/max values are cumulative.

Parameters
----------
r_corner1 : float
    In target coords: A corner of the target. Must be normalized to 1.
r_corner2 : float
    In target coords: Adjacent corner of the target. Must be normalized to 1. y_min, y_max     -- real(rp):
    min/max values. Only needed if initial = False. phi_min, phi_max -- real(rp): min/max values. Only needed
    if initial = False.
initial : bool, optional
    If present and True then this is the first edge for computation. y_min, y_max     -- real(rp): min/max
    values. phi_min, phi_max -- real(rp): min/max values.
)""");
  py::class_<PyTargetMinMaxCalc, std::unique_ptr<PyTargetMinMaxCalc>>(
      m, "TargetMinMaxCalc", "Fortran routine target_min_max_calc return value")
      .def_readonly("y_min", &PyTargetMinMaxCalc::y_min)
      .def_readonly("y_max", &PyTargetMinMaxCalc::y_max)
      .def_readonly("phi_min", &PyTargetMinMaxCalc::phi_min)
      .def_readonly("phi_max", &PyTargetMinMaxCalc::phi_max)
      .def("__len__", [](const PyTargetMinMaxCalc&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTargetMinMaxCalc& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.y_min);
            if (i == 1)
              return py::cast(s.y_max);
            if (i == 2)
              return py::cast(s.phi_min);
            if (i == 3)
              return py::cast(s.phi_max);
            return py::none();
          });
  m.def(
      "track_a_bend_photon",
      &Bmad::track_a_bend_photon,
      py::arg("orb"),
      py::arg("ele"),
      py::arg("length"),
      R"""(Routine to track a photon through a dipole bend.

The photon is traveling in a straight line but the reference frame
is curved in a circular shape.

Parameters
----------
orb : CoordStruct
    Starting position.
    This parameter is an input/output and is modified in-place. As an output: End position.
ele : EleStruct
    Bend element.
length : float
    length to track.
)""");
  m.def(
      "photon_target_setup",
      &Bmad::photon_target_setup,
      py::arg("ele"),
      R"""(Routine to calculate and store the parmeters needed for photon targeting.

This routine is called by Bmad parsing routines and is not meant for general use.
Photon initialization with targeting is done by the routine init_photon_from_a_photon_init_ele
Which is called by init_coord.

Parameters
----------
ele : EleStruct
    Source element to setup. Element will be of type: sample, diffraction_plate or photon_init.
    This parameter is an input/output and is modified in-place. As an output: Source element with target
    parameters setup in ele.photon.target.
)""");
  m.def(
      "photon_target_corner_calc",
      &python_photon_target_corner_calc,
      py::arg("aperture_ele"),
      py::arg("x_lim"),
      py::arg("y_lim"),
      py::arg("z_lim"),
      py::arg("source_ele"),
      R"""(Routine to calculate the corner coords in the source_ele ref frame.

Parameters
----------
aperture_ele : EleStruct
    Element containing the aperture x_lim, y_lim  -- real(rp): Transverse corner points in aperture_ele coord
    frame.
source_ele : EleStruct
    Photon source element.

Returns
-------
corner : TargetPointStruct
    Corner coords in source_ele ref frame.
)""");
  py::class_<
      PyPhotonTargetCornerCalc,
      std::unique_ptr<PyPhotonTargetCornerCalc>>(
      m,
      "PhotonTargetCornerCalc",
      "Fortran routine photon_target_corner_calc return value")
      .def_readonly("corner", &PyPhotonTargetCornerCalc::corner)
      .def_readonly("x_lim", &PyPhotonTargetCornerCalc::x_lim)
      .def_readonly("y_lim", &PyPhotonTargetCornerCalc::y_lim)
      .def_readonly("z_lim", &PyPhotonTargetCornerCalc::z_lim)
      .def("__len__", [](const PyPhotonTargetCornerCalc&) { return 4; })
      .def(
          "__getitem__",
          [](const PyPhotonTargetCornerCalc& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.corner);
            if (i == 1)
              return py::cast(s.x_lim);
            if (i == 2)
              return py::cast(s.y_lim);
            if (i == 3)
              return py::cast(s.z_lim);
            return py::none();
          });
  m.def(
      "photon_add_to_detector_statistics",
      &python_photon_add_to_detector_statistics,
      py::arg("orbit0"),
      py::arg("orbit"),
      py::arg("ele"),
      py::arg("ix_pt") = py::none(),
      py::arg("iy_pt") = py::none(),
      py::arg("pixel_pt") = py::none(),
      R"""(Routine to add photon statistics to the appropriate pixel of a "detector" grid.

It is assumed that track_to_surface has been called so that the photon is at the
detector surface and that orbit%vec(1) and %vec(3) are in surface coords (needed for curved detectors).

Parameters
----------
orbit0 : CoordStruct
    Photon coords at beginning of lattice
orbit : CoordStruct
    Photon coords at the detector.
ele : EleStruct
    Element with grid.
    This parameter is an input/output and is modified in-place. As an output: Element with updatted grid.
pixel_pt : PixelPtStruct, optional
    If present then use this grid point instead of the grid point determined by the (x, y) coords of the
    photon
)""");
  py::class_<
      PyPhotonAddToDetectorStatistics,
      std::unique_ptr<PyPhotonAddToDetectorStatistics>>(
      m,
      "PhotonAddToDetectorStatistics",
      "Fortran routine photon_add_to_detector_statistics return value")
      .def_readonly("ix_pt", &PyPhotonAddToDetectorStatistics::ix_pt)
      .def_readonly("iy_pt", &PyPhotonAddToDetectorStatistics::iy_pt)
      .def("__len__", [](const PyPhotonAddToDetectorStatistics&) { return 2; })
      .def(
          "__getitem__",
          [](const PyPhotonAddToDetectorStatistics& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_pt);
            if (i == 1)
              return py::cast(s.iy_pt);
            return py::none();
          });
  m.def(
      "detector_pixel_pt",
      &Bmad::detector_pixel_pt,
      py::arg("orbit"),
      py::arg("ele"),
      R"""(Routine to return the pixel a particle is hitting.

Parameters
----------
orbit : CoordStruct
    Orbit at surface.
ele : EleStruct
    Detector element.

Returns
-------
ix_pix : int
    index of ele.photon.pixel.pt(:,:) the particle is in.
)""");
  m.def(
      "to_photon_angle_coords",
      &Bmad::to_photon_angle_coords,
      py::arg("orb_in"),
      py::arg("ele"),
      R"""(Routine to convert from standard photon coords to "angle" coords defined as:

x, angle_x, y, angle_y, z, E-E_ref

Parameters
----------
orb_in : CoordStruct
    orbit in standard photon coords.
ele : EleStruct
    Reference element (generally the detector element.)

Returns
-------
orb_out : CoordStruct
    Transformed coordinates.
)""");
  m.def(
      "absolute_photon_position",
      &Bmad::absolute_photon_position,
      py::arg("e_orb"),
      py::arg("photon_orb"),
      R"""(Routine to calculate the photon phase space coordinates given:

1) The phase space coords of the emitting charged particle and
2) The photon phase space coords relative to the emitting particle.
The photon (x, y, z) position is ignored (it is assumed the photon is emitted at
the charged particle position) and only the photon's (vx, vy, vz) velocity matters.

Parameters
----------
e_orb : CoordStruct
    charged particle position.
photon_orb : CoordStruct
    Photon position relative to e_orb.
    This parameter is an input/output and is modified in-place. As an output: Absolute photon position.
)""");
  m.def(
      "bend_photon_init",
      &Bmad::bend_photon_init,
      py::arg("g_bend_x"),
      py::arg("g_bend_y"),
      py::arg("gamma"),
      py::arg("E_min") = py::none(),
      py::arg("E_max") = py::none(),
      py::arg("E_integ_prob") = py::none(),
      py::arg("vert_angle_min") = py::none(),
      py::arg("vert_angle_max") = py::none(),
      py::arg("vert_angle_symmetric") = py::none(),
      py::arg("emit_probability") = py::none(),
      R"""(vert_angle_min, vert_angle_max, vert_angle_symmetric, emit_probability)

Routine to initalize a photon for dipole bends and wigglers (but not undulators).
The photon is initialized using the standard formulas for bending radiation.
The energy of the photon is calculated in one of two ways:
1) If E_integ_prob is present and non-negative, the photon energy E will be such that the integrated
probability  [E_min, E] relative to the integrated probability in the range [E_min, E_max] is E_integ_prob.
That is, E_integ_prob can be used to to give a set of photon energies equally spaced in terms of the
integrated probability distribution.
2) If E_integ_prob is not present, or is negative, the photon energy is chosen at random in
the range [E_min, E_max].
An E_integ_prob of zero means that the generated photon will have energy E_min.
An E_integ_prob of one means that the generated photon will have energy E_max.
The photon's polarization, will have unit amplitude.
This routine assumes that the emitting charged particle is on-axis and moving in
the forward direction. To correct for the actual charged particle postion use the routine
absolute_photon_position

Parameters
----------
g_bend_x : float
    Bending 1/rho component in horizontal plane.
g_bend_y : float
    Bending 1/rho component in vertical plane.
gamma : float
    Relativistic gamma factor of generating charged particle.
E_min : float, optional
    Minimum photon energy. Default is zero. Ignored if negative.
E_max : float, optional
    Maximum photon energy.  Default is Infinity. Ignored if negative. If non-positive then E_max will be taken
    to be Infinity.
E_integ_prob : float
    , optional :: integrated energy probability. See above. If E_integ_prob is non-negative, it must be in the
    range [0, 1].
vert_angle_min : float, optional
    Minimum vertical angle to emit a photon. -pi/2 is used if argument not present or if argument is less than
    -pi/2.
vert_angle_max : float, optional
    Maximum vertical angle to emit a photon. pi/2 is used if argument not present or if argument is greater
    than pi/2.
vert_angle_symmetric : bool, optional
    Default is False. If True, photons will be emitted in the range [-vert_angle_max, -vert_angle_min] as well
    as the range [vert_angle_min, vert_angle_max]. In this case vert_angle_min/max must be positive.
emit_probability : float, optional
    Probability of emitting a photon in the range [E_min, E_max] or in the vertical angular range given. The
    probability is normalized so that the probability of emitting if no ranges are given is 1.

Returns
-------
orbit : CoordStruct
    Initialized photon.
)""");
  m.def(
      "bend_photon_energy_integ_prob",
      &Bmad::bend_photon_energy_integ_prob,
      py::arg("E_photon"),
      py::arg("g_bend"),
      py::arg("gamma"),
      R"""(Routine to find the integrated probability corresponding to emitting a photon

from a bend in the range [0, E_photon].

Parameters
----------
E_photon : float
    Photon energy.
g_bend : float
    1/rho bending strength.
gamma : float
    Relativistic gamma factor of generating charged particle.

Returns
-------
integ_prob : float
    Integrated probability. Will be in the range [0, 1].
)""");
  m.def(
      "bend_vert_angle_integ_prob",
      &Bmad::bend_vert_angle_integ_prob,
      py::arg("vert_angle"),
      py::arg("E_rel"),
      py::arg("gamma"),
      R"""(Routine to find the integrated probability corresponding to emitting a photon

from a bend and with relative energy E_rel in the vertical angle range [-pi/2, vert_angle/2].

Parameters
----------
vert_angle : float
    Vertical angle.
E_rel : float
    Relative photon energy E/E_crit.
gamma : float
    Relativistic gamma factor of generating charged particle.

Returns
-------
integ_prob : float
    Integrated probability. Will be in the range [0, 1].
)""");
  m.def(
      "bend_photon_polarization_init",
      &Bmad::bend_photon_polarization_init,
      py::arg("g_bend_x"),
      py::arg("g_bend_y"),
      py::arg("E_rel"),
      py::arg("gamma_phi"),
      R"""(Routine to set a photon's polarization.

The photon's polarization will be either in the plane of the bend or out of the plane and
the magnitude will be 1.

Parameters
----------
g_bend_x : float
    Bending 1/rho component in horizontal plane.
g_bend_y : float
    Bending 1/rho component in vertical plane.
E_rel : float
    Relative photon energy E/E_crit.
gamma_phi : float
    gamma * phi where gamma is the beam relativistic factor and phi is the vertical photon angle (in radians).

Returns
-------
orbit : CoordStruct
    Photon coords .field(2)     -- (x,y) polaraization. Will have unit magnitude .phase(2)     -- (x,y)
    phases. Will be [0, pi/2].
)""");
  m.def(
      "bend_photon_vert_angle_init",
      &Bmad::bend_photon_vert_angle_init,
      py::arg("E_rel"),
      py::arg("gamma"),
      py::arg("r_in") = py::none(),
      py::arg("invert") = py::none(),
      R"""(Routine to convert an integrated probability to a vertical angle for emitting a photon from a bend.

The integrated probability is in the range [0,1] with 0 corresponding to a phi = -pi/2 and
integrated probability of 1 corresponding to phi = pi/2.

Parameters
----------
E_rel : float
    Relative photon energy E/E_crit.
gamma : float
    beam relativistic factor
r_in : float, optional
    Integrated probability in the range [0,1]. If not present, a random number will be used.
invert : float, optional
    If True then take r_in as the inverse integrated probability with inverted probability = 1 - probability.
    This is useful to avoid round-off errors when for looking at the tail of the distribution where the
    integrated prob is very close to 1 and small deviations can have large effects. Default is False.

Returns
-------
phi : float
    The photon vertical emission angle (in radians). Note: phi is an increasing monotonic function of r_in.
)""");
  m.def(
      "bend_photon_e_rel_init",
      &Bmad::bend_photon_e_rel_init,
      py::arg("r_in") = py::none(),
      R"""(Routine to convert a random number in the interval [0,1] to a photon energy.

The photon probability spectrum is:
P(E_rel) = (3 / (5 * Pi)) * Integral_{E_rel}^{Infty} K_{5/3}(x) dx
Where
P(E_rel)) = Probability of finding a photon at relative energy E_rel.
E_rel     = Relative photon energy: E / E_crit, E_crit = Critical energy.
K_{5/3}   = Modified Bessel function.
Notice that the P(E) is not the same as the distribution radiation energy since
the photons must be energy weighted.
There is a cut-off built into the calculation so that E_rel will be in the
range [0, 31.4]. The error in neglecting photons with E_rel > 31.4 translates
to neglecting one photon for every 10^15 generated.
If r_in is present:
r_in = 0 => E_rel = 0
r_in = 1 => E_rel = 31.4

Parameters
----------
r_in : float, optional
    Integrated probability in the range [0,1]. If not present, a random number will be used.

Returns
-------
E_rel : float
    Relative photon energy E/E_crit.
)""");
  m.def(
      "bend_photon_energy_normalized_probability",
      &Bmad::bend_photon_energy_normalized_probability,
      py::arg("E_rel"),
      R"""(Routine to return the normalized probability that a photon will be emitted in a bend with energy

E_rel relative to the critical energy. The probability is normalized such that
Integral[0,Infinity] dE_rel P(E_rel) = 1

Parameters
----------
E_rel : float
    Photon energy relative to the critical energy.

Returns
-------
prob : float
    Normalized probability.
)""");
  m.def(
      "e_crit_photon",
      &Bmad::e_crit_photon,
      py::arg("gamma"),
      py::arg("g_bend"),
      R"""(Routine to calculate the photon critical energy in a bend.

Parameters
----------
gamma : float
    Gamma factor of charged particle emitting photon.
g_bend : float
    1/radius bending strength.

Returns
-------
E_crit : float
    Critical photon energy.
)""");
  m.def(
      "init_photon_integ_prob",
      &Bmad::init_photon_integ_prob,
      py::arg("gamma"),
      py::arg("g"),
      py::arg("E_min"),
      py::arg("E_max"),
      py::arg("vert_angle_min") = py::none(),
      py::arg("vert_angle_max") = py::none(),
      py::arg("vert_angle_symmetric") = py::none(),
      py::arg("energy_integ_prob") = py::none(),
      R"""(vert_angle_max, vert_angle_symmetric, energy_integ_prob, E_photon) result (integ_prob)

Routine to calcuate the integrated probability of emitting a photon in a given vertical angle range
and in a given energy range

Parameters
----------
gamma : float
    Gamma factor of charged particle emitting photon.
g : float
    1/rho bending strength.
E_min : float
    Minimum photon energy.
E_max : float
    Maximum photon energy.
vert_angle_min : float, optional
    Lower bound of vertical angle range.
vert_angle_max : float, optional
    Upper bound of vertical angle range.
vert_angle_symmetric : float, optional
    Use two symmetric ranges [-vert_angle_max, -vert_angle_min] and [vert_angle_min, vert_angle_max] instead
    of just [vert_angle_min, vert_angle_max]?
energy_integ_prob : float, optional
    If present, E_photon will be set to the photon energy such that the integrated probability of generating a
    photon in the given angle and energy range in the interval [E_min, E_photon] is energy_integ_prob. That
    is, energy_integ_prob = 0 => E_photon = E_min and energy_integ_prob = 1 => E_photon = E_max.

Return value is a dictionary containing values below.


Returns
-------
E_photon : float
    See energy_integ_prob. E_photon must be present if energy_integ_prob is.
integ_prob : float
    Integrated probablility of emitting a photon in given angle and energy range.
)""");
  py::class_<
      Bmad::InitPhotonIntegProb,
      std::unique_ptr<Bmad::InitPhotonIntegProb>>(
      m,
      "InitPhotonIntegProb",
      "Fortran routine init_photon_integ_prob return value")
      .def_readonly("E_photon", &Bmad::InitPhotonIntegProb::E_photon)
      .def_readonly("integ_prob", &Bmad::InitPhotonIntegProb::integ_prob)
      .def("__len__", [](const Bmad::InitPhotonIntegProb&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::InitPhotonIntegProb& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.E_photon);
            if (i == 1)
              return py::cast(s.integ_prob);
            return py::none();
          });
  m.def(
      "track_a_capillary",
      &Bmad::track_a_capillary,
      py::arg("orb"),
      py::arg("ele"),
      R"""(Routine to track through a capillary.

Parameters
----------
orb : CoordStruct
    Input photon coordinates.
    This parameter is an input/output and is modified in-place. As an output: Output photon coordinates.
ele : EleStruct
    Capillary element
)""");
  m.def(
      "branch_to_ptc_m_u",
      &Bmad::branch_to_ptc_m_u,
      py::arg("branch"),
      R"""(Subroutine to create a PTC layout from a Bmad lattice branch.

will be three corresponding PTC fibre elements: (drift, RF. drift) for example.
In this case, ele%ptc_fibre will be set to point to the last PTC fibre. That is the
exit end of ele will correspond to the exit end of ele%ptc_fibre.

Parameters
----------
branch : BranchStruct
    Input branch. branch(:).ptc              -- Pointers to generated layouts. branch(:).ele(:).ptc_fibre --
    Pointer to PTC fibres

Notes
-----
Note: If a Bmad element is using a hard edge model (EG: RFcavity element), there
)""");
  m.def(
      "ptc_one_turn_mat_and_closed_orbit_calc",
      &Bmad::ptc_one_turn_mat_and_closed_orbit_calc,
      py::arg("branch"),
      py::arg("pz") = py::none(),
      R"""(Routine to compute the transfer matrices for the individual elements and closed orbit

for a lattice branch with closed geometry.

Parameters
----------
branch : BranchStruct
    Lattice branch.
    This parameter is an input/output and is modified in-place. As an output: Lattice branch containing the
    matrices.
pz : float, optional
    energy offset around which to calculate the matrices if there is no RF.
)""");
  m.def(
      "ptc_emit_calc",
      &Bmad::ptc_emit_calc,
      py::arg("ele"),
      py::arg("sigma_mat"),
      R"""(Routine to calculate emittances, etc.

Parameters
----------
ele : EleStruct
    Element at which to evaluate the parameters.

Return value is a dictionary containing values below.


Returns
-------
norm_mode : 
    Normal_modes_struct %a%tune, %b%tune, %z%tune %a%alpha_damp, etc. %a%emittance, etc.
sigma_map : float
    Sigma matrix (Bmad coordinates).
closed_orb : CoordStruct
    Closed orbit at ele (Bmad coordinates). Notice: This closed orbit is the closed orbit with radiation on.
)""");
  py::class_<Bmad::PtcEmitCalc, std::unique_ptr<Bmad::PtcEmitCalc>>(
      m, "PtcEmitCalc", "Fortran routine ptc_emit_calc return value")
      .def_readonly("norm_mode", &Bmad::PtcEmitCalc::norm_mode)
      .def_readonly("closed_orb", &Bmad::PtcEmitCalc::closed_orb)
      .def("__len__", [](const Bmad::PtcEmitCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::PtcEmitCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.norm_mode);
            if (i == 1)
              return py::cast(s.closed_orb);
            return py::none();
          });
  m.def(
      "ptc_spin_calc",
      &Bmad::ptc_spin_calc,
      py::arg("ele"),
      py::arg("sigma_mat"),
      R"""(Routine to equilibrium polarizations, etc.

Parameters
----------
ele : EleStruct
    Element at which to evaluate the parameters.

Return value is a dictionary containing values below.


Returns
-------
norm_mode : 
    Normal_modes_struct %a%tune, %b%tune, %z%tune %a%alpha_damp, etc. %a%emittance, etc.
sigma_map : float
    Sigma matrix (Bmad coordinates).
closed_orb : CoordStruct
    Closed orbit at ele (Bmad coordinates). Notice: This closed orbit is the closed orbit with radiation on.
)""");
  py::class_<Bmad::PtcSpinCalc, std::unique_ptr<Bmad::PtcSpinCalc>>(
      m, "PtcSpinCalc", "Fortran routine ptc_spin_calc return value")
      .def_readonly("norm_mode", &Bmad::PtcSpinCalc::norm_mode)
      .def_readonly("closed_orb", &Bmad::PtcSpinCalc::closed_orb)
      .def("__len__", [](const Bmad::PtcSpinCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::PtcSpinCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.norm_mode);
            if (i == 1)
              return py::cast(s.closed_orb);
            return py::none();
          });
  m.def(
      "ptc_track_all",
      &Bmad::ptc_track_all,
      py::arg("branch"),
      py::arg("orbit"),
      R"""(Routine to track from the start to the end of a lattice branch.

Parameters
----------
branch : LatStruct
    Lat to track through.
orbit : CoordStruct
    Coordinates at beginning of branch.
    This parameter is an input/output and is modified in-place. As an output: Orbit array.

Return value is a dictionary containing values below.


Returns
-------
track_state : int
    Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
err_flag : bool
    Set true if particle lost or error. False otherwise
)""");
  py::class_<Bmad::PtcTrackAll, std::unique_ptr<Bmad::PtcTrackAll>>(
      m, "PtcTrackAll", "Fortran routine ptc_track_all return value")
      .def_readonly("track_state", &Bmad::PtcTrackAll::track_state)
      .def_readonly("err_flag", &Bmad::PtcTrackAll::err_flag)
      .def("__len__", [](const Bmad::PtcTrackAll&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::PtcTrackAll& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.track_state);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "ptc_closed_orbit_calc",
      &Bmad::ptc_closed_orbit_calc,
      py::arg("branch"),
      py::arg("radiation_damping_on") = py::none(),
      R"""(Routine to calculate the closed orbit of a lattice branch using PTC.

This routine assumes the associated PTC layout has been crated
with lat_to_ptc_layout.

Parameters
----------
branch : BranchStruct
    Branch of a lattice.
radiation_damping_on : bool, optional
    If True, radiation dampling is included in the calculation. -- logical, optional: If True, radiation
    dampling is included in the calculation. Default is the setting of bmad_com..radiation_damping_on.

Returns
-------
closed_orbit : CoordStruct
    closed_orbit
)""");
  m.def(
      "normal_form_taylors",
      &Bmad::normal_form_taylors,
      py::arg("one_turn_taylor"),
      py::arg("rf_on"),
      R"""(Do a normal form decomposition on a one-turn taylor map M:

M = A o R o A_inverse
where A maps Floquet (fully normalized) coordinates to lab coordinates.
In Floquet coordinates, the amplitudes are defined as J_i = (1/2) (x_i^2 + p_i^2).
The map R = exp(:h:) is a pure rotation with h = h(J) is a function of the amplitudes only.
The angles (phase advances) are given by phi_i = 2pi*dh/dJ_i.
The taylor terms of dhdj are therefore the tunes, chromaticities, amplitude dependent tune shifts, etc.
The mapping procedure for one turn is:
z_Floquet_in = A_inverse o z_Lab_in
[phi_a, phi_b, phi_c] = 2 pi * dhdj o z_Floquet_in
z_Floquet_out = RotationMatrix(phi_a, phi_b, phi_c) . z_Floquet_in
z_Lab_out = A o z_Floquet_out

Parameters
----------
one_turn_taylor : TaylorStruct
    one turn taylor map
rf_on : bool
    Was the map calculated with RF on?

Return value is a dictionary containing values below.


Returns
-------
A : TaylorStruct
    Map from Floquet coordinates to Lab coordinates
A_inverse : TaylorStruct
    Map from Lab coordinates to Floquet coordinates
dhdj : TaylorStruct
    Map from Floquet coordinates to phase advances
)""");
  py::class_<Bmad::NormalFormTaylors, std::unique_ptr<Bmad::NormalFormTaylors>>(
      m,
      "NormalFormTaylors",
      "Fortran routine normal_form_taylors return value")
      .def_readonly("dhdj", &Bmad::NormalFormTaylors::dhdj)
      .def_readonly("A", &Bmad::NormalFormTaylors::A)
      .def_readonly("A_inverse", &Bmad::NormalFormTaylors::A_inverse)
      .def("__len__", [](const Bmad::NormalFormTaylors&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::NormalFormTaylors& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dhdj);
            if (i == 1)
              return py::cast(s.A);
            if (i == 2)
              return py::cast(s.A_inverse);
            return py::none();
          });
  m.def(
      "normal_form_complex_taylors",
      &python_normal_form_complex_taylors,
      py::arg("one_turn_taylor"),
      py::arg("rf_on"),
      py::arg("F") = py::none(),
      py::arg("L") = py::none(),
      py::arg("A") = py::none(),
      py::arg("A_inverse") = py::none(),
      py::arg("order") = py::none(),
      R"""(No docstring available

Parameters
----------
one_turn_taylor : 
rf_on : 
F : 
L : 
A : 
A_inverse : 
order : 
)""");
  py::class_<
      PyNormalFormComplexTaylors,
      std::unique_ptr<PyNormalFormComplexTaylors>>(
      m,
      "NormalFormComplexTaylors",
      "Fortran routine normal_form_complex_taylors return value")
      .def_readonly("rf_on", &PyNormalFormComplexTaylors::rf_on)
      .def_readonly("order", &PyNormalFormComplexTaylors::order)
      .def("__len__", [](const PyNormalFormComplexTaylors&) { return 2; })
      .def(
          "__getitem__",
          [](const PyNormalFormComplexTaylors& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rf_on);
            if (i == 1)
              return py::cast(s.order);
            return py::none();
          });
  m.def(
      "set_ptc_verbose",
      &python_set_ptc_verbose,
      py::arg("on"),
      R"""(No docstring available

Parameters
----------
on : 
)""");
  py::class_<PySetPtcVerbose, std::unique_ptr<PySetPtcVerbose>>(
      m, "SetPtcVerbose", "Fortran routine set_ptc_verbose return value")
      .def_readonly("on", &PySetPtcVerbose::on)
      .def("__len__", [](const PySetPtcVerbose&) { return 1; })
      .def("__getitem__", [](const PySetPtcVerbose& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.on);
        return py::none();
      });
  m.def(
      "update_ele_from_fibre",
      &Bmad::update_ele_from_fibre,
      py::arg("ele"),
      R"""(Routine to update a bmad lattice element when the associated PTC fibre has been modified.

Parameters
----------
ele : EleStruct
    Element with corresponding ele.ptc_fibre fibre.
    This parameter is an input/output and is modified in-place. As an output: Modified element.

Notes
-----
Remember to call lattice_bookkeeper after calling this routine.
)""");
  m.def(
      "ptc_layouts_resplit",
      &Bmad::ptc_layouts_resplit,
      py::arg("dKL_max"),
      py::arg("l_max"),
      py::arg("l_max_drift_only"),
      py::arg("bend_dorb"),
      py::arg("sex_dx"),
      py::arg("even") = py::none(),
      py::arg("crossover") = py::none(),
      py::arg("crossover_wiggler") = py::none(),
      R"""(even, crossover, crossover_wiggler)

Routine to resplit (that is, recalculate the number of integration steps for an element)
For the fibres in all layouts. After doing a resplit, the tune (and any other relavent
"adjustable" parameters) should be adjusted to the correct values.

Parameters
----------
dKL_max : float
    Maximum K1 * L quadrupole strength allowed for an integration step. Reasonable value would be something
    like 0.04.
l_max : float
    Maximum step length. Ignored if set to 0.
l_max_drift_only : bool
    If True then l_max is only used for splitting drifts. -- logical: If True then l_max is only used for
    splitting drifts.
bend_dorb : float
    Residual bend orbit error. With some integration methods a zero orbit at the start of the bend will not be
    zero at the end. In this case, bend_dorb sets a maximum allowable orbit deviation. If set to zero, this
    argument will be ignored. A resonable value is 10d-7. Note that the actual orbit deviation is not simply
    related to bend_dorb and can be larger. In any case, lowering bend_dorb (without making it zero) will
    lower the
sex_dx : float
    To split sextupoles, sex_dx is used as the reference position about which the quadrupole strength is
    calculated. This quadrupole strength is then used with dKL_max to calculate the number of integration
    steps. Set to zero to ignore.
even : bool, optional
    If True then each fibre  will have an even number of steps. If False then the number of steps will be odd.
    If not present then number of steps is not constrained to be even or odd.
crossover : int, optional
    crossover(1) sets the maximum number of 2nd order integration steps to use. If the number of steps would
    exceed crossover(1) then integration is switched to 4th order. crossover(2) sets the maximum number of 4th
    order integration steps. If this number is exceeded, 6th order integration is used. Currently the default
    in PTC is [4, 18].
crossover_wiggler(2) : int, optional
    crossover for wiggler elements. -- integer, optional: crossover for wiggler elements.
)""");
  m.def(
      "ptc_set_taylor_order_if_needed",
      &Bmad::ptc_set_taylor_order_if_needed,
      R"""(Routine to see if the taylor_order for PTC needs to be set/changed.

For example, for a change in bmad_com%taylor_order.

)""");
  m.def(
      "kind_name",
      &Bmad::kind_name,
      py::arg("this_kind"),
      R"""(function to return the name of a PTC kind.

Parameters
----------
this_kind : int
    PTC kind

Returns
-------
kind_str : unknown
    String representation
)""");
  m.def(
      "set_ptc_com_pointers",
      &Bmad::set_ptc_com_pointers,
      R"""(Routine to set ptc_com pointers to PTC global variables.

)""");
  m.def(
      "sigma_mat_ptc_to_bmad",
      &Bmad::sigma_mat_ptc_to_bmad,
      py::arg("sigma_mat_ptc"),
      py::arg("beta0"),
      R"""(Routine to convert a PTC sigma matrix to a Bmad sigma matrix.

The conversion includes the conversion between Bmad and PTC time coordinate systems.
Since PTC uses delta_E/P0c and Bmad uses delta_P/P0c coordinates, and since
the relationship between delta_E and delta_P is nonlinear, this routine
simplifies the calculation and assumes that the particle beta is constant
over the range of particle energies.

Parameters
----------
sigma_mat_ptc : float
    PTC sigma matrix.
beta0 : float
    Reference particle velocity

Returns
-------
sigma_mat_bmad : float
    Bmad sigma matrix.
)""");
  m.def(
      "form_complex_taylor",
      &Bmad::form_complex_taylor,
      py::arg("re_taylor"),
      py::arg("im_taylor"),
      R"""(Subroutine to form a complex taylor from two taylor series representing

the real and imaginary parts

Parameters
----------
re_taylor : TaylorStruct
    Real part
im_taylor : TaylorStruct
    Imaginary part

Returns
-------
complex_taylor : ComplexTaylorStruct
    combined complex taylor
)""");
  m.def(
      "remove_constant_taylor",
      &Bmad::remove_constant_taylor,
      py::arg("taylor_in"),
      py::arg("remove_higher_order_terms"),
      R"""(Subroutine to remove the constant part of a taylor map.

Optionally terms that are higher order than bmad_com%taylor_order can
be removed.

Parameters
----------
taylor_in : TaylorStruct
    Input taylor map.
remove_higher_order_terms : bool
    If True then terms that are higher order than bmad_com.taylor_order are removed.

Return value is a dictionary containing values below.


Returns
-------
taylor_out : TaylorStruct
    Taylor with constant terms removed.
c0 : float
    The constant part of the taylor map
)""");
  py::class_<
      Bmad::RemoveConstantTaylor,
      std::unique_ptr<Bmad::RemoveConstantTaylor>>(
      m,
      "RemoveConstantTaylor",
      "Fortran routine remove_constant_taylor return value")
      .def_readonly("taylor_out", &Bmad::RemoveConstantTaylor::taylor_out)
      .def_readonly("c0", &Bmad::RemoveConstantTaylor::c0)
      .def("__len__", [](const Bmad::RemoveConstantTaylor&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::RemoveConstantTaylor& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.taylor_out);
            if (i == 1)
              return py::cast(s.c0);
            return py::none();
          });
  m.def(
      "taylor_inverse",
      &Bmad::taylor_inverse,
      py::arg("taylor_in"),
      R"""(Subroutine to invert a taylor map. Since the inverse map is truncated, it is not exact.

Parameters
----------
taylor_in : TaylorStruct
    Input taylor map.

Return value is a dictionary containing values below.


Returns
-------
taylor_inv : TaylorStruct
    Inverted taylor map.
err : bool
    Set True if there is no inverse. If not present then print an error message.
)""");
  py::class_<Bmad::TaylorInverse, std::unique_ptr<Bmad::TaylorInverse>>(
      m, "TaylorInverse", "Fortran routine taylor_inverse return value")
      .def_readonly("taylor_inv", &Bmad::TaylorInverse::taylor_inv)
      .def_readonly("err", &Bmad::TaylorInverse::err)
      .def("__len__", [](const Bmad::TaylorInverse&) { return 2; })
      .def(
          "__getitem__",
          [](const Bmad::TaylorInverse& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.taylor_inv);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "concat_taylor",
      &Bmad::concat_taylor,
      py::arg("taylor1"),
      py::arg("taylor2"),
      py::arg("taylor3"),
      R"""(Subroutine to concatinate two taylor maps:

taylor3[x] = taylor2(taylor1[x])

Parameters
----------
taylor1 : TaylorStruct
    Taylor map.
taylor2 : TaylorStruct
    Taylor map. Output
taylor3 : TaylorStruct
    Concatinated map
)""");
  m.def(
      "concat_ele_taylor",
      &Bmad::concat_ele_taylor,
      py::arg("orb_taylor"),
      py::arg("ele"),
      py::arg("err_flag"),
      py::arg("spin_taylor") = py::none(),
      R"""(Routine to concatinate an orbital taylor map and, optionally if present and

bmad_com%spin_tracking_on = T, a spin taylor map.
Transform:
orb_taylor[x] -> ele_taylor(orb_taylor[x])
If ele%taylor_map_includes_offsets = True:  ele_taylor == ele%taylor
If ele%taylor_map_includes_offsets = False: ele_taylor == ele%taylor + offset corrections.

Parameters
----------
orb_taylor : TaylorStruct
    Orbital Taylor map.
ele : EleStruct
    Element containing a Taylor map.
spin_taylor : TaylorStruct, optional
    Spin map to propagate Output
orb_taylor : TaylorStruct
    Concatinated orbital map
err_flag : bool
    Set True if there is an error. False otherwise.
spin_taylor : TaylorStruct, optional
    Concatinated spin map.

Notes
-----
Related routines:
concat_taylor
)""");
  m.def(
      "taylor_propagate1",
      &Bmad::taylor_propagate1,
      py::arg("orb_taylor"),
      py::arg("ele"),
      py::arg("param"),
      py::arg("ref_in") = py::none(),
      py::arg("spin_taylor") = py::none(),
      R"""(Subroutine to track (symplectic integration) a orbital map, and optionally a spin map, through an element.

The spin tracking is only done if spin_taylor is present and bmad_com%spin_tracking_on = T.
The alternative routine, if ele has a taylor map, is concat_taylor.
This routine will fail if there is no corresponding ptc fibre for this
element. In general, the transfer_map_calc routine should be used instead.

Parameters
----------
orb_taylor : TaylorStruct
    Map to be tracked
    This parameter is an input/output and is modified in-place. As an output: Map through element.
ele : EleStruct
    Element to track through
param : LatParamStruct
ref_in : CoordStruct, optional
    Particle to be tracked. Must be present if the particle to be tracked is not the reference particle or if
    the direction of propagation is backwards.
spin_taylor : TaylorStruct, optional
    Spin map to be tracked
    This parameter is an input/output and is modified in-place. As an output: Tracked spin map.

Returns
-------
err_flag : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "bmad_patch_parameters_to_ptc",
      &Bmad::bmad_patch_parameters_to_ptc,
      py::arg("ang"),
      py::arg("exi"),
      R"""(No docstring available

Parameters
----------
ang : 
exi : 
)""");
  m.def(
      "ele_to_ptc_magnetic_bn_an",
      &Bmad::ele_to_ptc_magnetic_bn_an,
      py::arg("ele"),
      R"""(Routine to compute the a(n) and b(n) magnetic multipole components of a magnet.

This is used to interface between eles and PTC fibres

Parameters
----------
ele : EleStruct
    Bmad Element.

Return value is a dictionary containing values below.


Returns
-------
bn : float
    Normal multipole component.
an : float
    Skew multipole component.
n_max : int
    Maximum non-zero multipole component. Set to zero if there are no multipoles.
)""");
  py::class_<
      Bmad::EleToPtcMagneticBnAn,
      std::unique_ptr<Bmad::EleToPtcMagneticBnAn>>(
      m,
      "EleToPtcMagneticBnAn",
      "Fortran routine ele_to_ptc_magnetic_bn_an return value")
      .def_readonly("bn", &Bmad::EleToPtcMagneticBnAn::bn)
      .def_readonly("an", &Bmad::EleToPtcMagneticBnAn::an)
      .def_readonly("n_max", &Bmad::EleToPtcMagneticBnAn::n_max)
      .def("__len__", [](const Bmad::EleToPtcMagneticBnAn&) { return 3; })
      .def(
          "__getitem__",
          [](const Bmad::EleToPtcMagneticBnAn& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.bn);
            if (i == 1)
              return py::cast(s.an);
            if (i == 2)
              return py::cast(s.n_max);
            return py::none();
          });
  m.def(
      "apply_patch_to_ptc_fibre",
      &Bmad::apply_patch_to_ptc_fibre,
      py::arg("ele"),
      R"""(Routine to take the patch parameters from a Bmad patch element and

transfer them to the associated PTC fibre.

Parameters
----------
ele : EleStruct
    Patch element. ele.ptc_fibre -- PTC Fibre which should be a marker.
)""");
  m.def(
      "set_ptc_quiet",
      &python_set_ptc_quiet,
      py::arg("channel"),
      py::arg("set"),
      py::arg("old_val"),
      R"""(Routine to set the lielib_print(:) array or c_verbose logical to suppress informational messages

that can clutter the output from a program using PTC.

Parameters
----------
channel : int
    Index in the lielib_print(:) array to set. 0 => c_verbose.
set : bool
    If set$ then set lielib_print(:). If unset$ then undo a previous set$.
old_val : int
    Old value needed for set = unset$.
    This parameter is an input/output and is modified in-place. As an output: Saved value for set = set$.
)""");
  py::class_<PySetPtcQuiet, std::unique_ptr<PySetPtcQuiet>>(
      m, "SetPtcQuiet", "Fortran routine set_ptc_quiet return value")
      .def_readonly("old_val", &PySetPtcQuiet::old_val)
      .def("__len__", [](const PySetPtcQuiet&) { return 1; })
      .def("__getitem__", [](const PySetPtcQuiet& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.old_val);
        return py::none();
      });
  m.def(
      "track1_bunch_csr",
      &Bmad::track1_bunch_csr,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("centroid"),
      py::arg("s_start") = py::none(),
      py::arg("s_end") = py::none(),
      py::arg("bunch_track") = py::none(),
      R"""(Routine to track a bunch of particles through an element with csr radiation effects.

Parameters
----------
bunch : BunchStruct
    Starting bunch position.
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
ele : EleStruct
    The element to track through. Must be part of a lattice.
centroid : 
    coord_struct, Approximate beam centroid orbit for the lattice branch. Calculate this before beam tracking
    by tracking a single particle.
s_start : float, optional
    Starting position relative to ele. Default = 0
s_end : float, optional
    Ending position. Default is ele length.
bunch_track : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: track information if the
    tracking method does

Returns
-------
err : bool
    Set true if there is an error. EG: Too many particles lost.
)""");
  m.def(
      "dspline_len",
      &Bmad::dspline_len,
      py::arg("s_chord0"),
      py::arg("s_chord1"),
      py::arg("spline"),
      py::arg("dtheta_ref") = py::none(),
      R"""(Routine to calculate the difference in length between the spline curve length and a referece line.

Referece line is centroid chord (referece system of the spline) rotated by dtheta_ref.

Parameters
----------
s_chord0 : float
    Start position along centroid chord.
s_chord1 : float
    Stop position along central_chord.
spline : SplineStruct
    Spline of x-position as a function of s.
dtheta_ref : float, optional
    angle to rotate the reference line from the centroid chord. Default is 0.

Returns
-------
dlen : float
    L_spline - L_chord
)""");
  m.def(
      "track1_bunch_csr3d",
      &Bmad::track1_bunch_csr3d,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("centroid"),
      py::arg("s_start") = py::none(),
      py::arg("s_end") = py::none(),
      py::arg("bunch_track") = py::none(),
      R"""(EXPERIMENTAL. NOT CURRENTLY OPERATIONAL!

Routine to track a bunch of particles through an element using
steady-state 3D CSR.

Parameters
----------
bunch : BunchStruct
    Starting bunch position.
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
ele : EleStruct
    The element to track through. Must be part of a lattice.
centroid : 
    coord_struct, Approximate beam centroid orbit for the lattice branch. Calculate this before beam tracking
    by tracking a single particle.
s_start : float, optional
    Starting position relative to ele. Default = 0
s_end : float, optional
    Ending position. Default is ele length.
bunch_track : BunchTrackStruct, optional
    Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
    This parameter is an input/output and is modified in-place. As an output: track information if the
    tracking method does

Returns
-------
err : bool
    Set true if there is an error. EG: Too many particles lost.
)""");
  m.def(
      "setup_high_energy_space_charge_calc",
      &Bmad::setup_high_energy_space_charge_calc,
      py::arg("calc_on"),
      py::arg("branch"),
      py::arg("n_part"),
      py::arg("mode"),
      py::arg("closed_orb") = py::none(),
      R"""(Routine to initialize constants needed by the ultra relativistic space charge

tracking routine track1_high_energy_space_charge. This setup routine must be called if
the lattice or any of the other input parameters are changed.

Parameters
----------
calc_on : bool
    Turns on or off the space charge calculation.
branch : BranchStruct
    Lattice for tracking.
n_part : float
    Number of actual particles in a bunch. Used to compute the bunch charge.
mode : NormalModesStruct
    Structure holding the beam info. .a.emittance  -- a-mode unnormalized emittance. .b.emittance  -- b-mode
    unnormalized emittance. .sig_z        -- Real(rp): Bunch length. .sigE_E       -- Real(rp): Sigma_E/E
    relative energy spread
closed_orb : CoordStruct, optional
    Closed orbit. If not present the closed orbit is taken to be zero.
)""");
  m.def(
      "track1_high_energy_space_charge",
      &Bmad::track1_high_energy_space_charge,
      py::arg("ele"),
      py::arg("param"),
      py::arg("orbit"),
      R"""(Routine to apply the ultra-relative space charge kick to a particle at the end of an element.

The routine setup_high_energy_space_charge_calc must be called initially before any tracking is done.
This routine assumes a Gaussian bunch and is only valid with relativistic particles where the
effect of the space charge is small.

Parameters
----------
orbit : CoordStruct
    Starting position
    This parameter is an input/output and is modified in-place. As an output: End position
ele : EleStruct
    Element tracked through.
param : LatParamStruct
)""");
  m.def(
      "make_mat6_high_energy_space_charge",
      &Bmad::make_mat6_high_energy_space_charge,
      py::arg("ele"),
      py::arg("param"),
      R"""(Routine to add the ultra relativistic space charge kick to the element transfer matrix.

The routine setup_space_charge_calc must be called
initially before any tracking is done. This routine assumes a Gaussian
bunch and is only valid with relativistic particles where the effect
of the space charge is small.

Parameters
----------
ele : EleStruct
    Element tracked through.
param : LatParamStruct

Returns
-------
end : CoordStruct
    End position
)""");
  m.def(
      "osc_alloc_freespace_array",
      &Bmad::osc_alloc_freespace_array,
      py::arg("nlo"),
      py::arg("nhi"),
      py::arg("npad"),
      R"""(No docstring available

Parameters
----------
nlo : 
nhi : 
npad : 
)""");
  m.def(
      "coulombfun",
      &python_coulombfun,
      py::arg("u"),
      py::arg("v"),
      py::arg("w"),
      py::arg("gam"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
u : 
v : 
w : 
gam : 
res : 
)""");
  py::class_<PyCoulombfun, std::unique_ptr<PyCoulombfun>>(
      m, "Coulombfun", "Fortran routine coulombfun return value")
      .def_readonly("u", &PyCoulombfun::u)
      .def_readonly("v", &PyCoulombfun::v)
      .def_readonly("w", &PyCoulombfun::w)
      .def_readonly("gam", &PyCoulombfun::gam)
      .def_readonly("res", &PyCoulombfun::res)
      .def("__len__", [](const PyCoulombfun&) { return 5; })
      .def("__getitem__", [](const PyCoulombfun& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.u);
        if (i == 1)
          return py::cast(s.v);
        if (i == 2)
          return py::cast(s.w);
        if (i == 3)
          return py::cast(s.gam);
        if (i == 4)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "igfcoulombfun",
      &python_igfcoulombfun,
      py::arg("u"),
      py::arg("v"),
      py::arg("w"),
      py::arg("gam"),
      py::arg("dx"),
      py::arg("dy"),
      py::arg("dz"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
u : 
v : 
w : 
gam : 
dx : 
dy : 
dz : 
res : 
)""");
  py::class_<PyIgfcoulombfun, std::unique_ptr<PyIgfcoulombfun>>(
      m, "Igfcoulombfun", "Fortran routine igfcoulombfun return value")
      .def_readonly("u", &PyIgfcoulombfun::u)
      .def_readonly("v", &PyIgfcoulombfun::v)
      .def_readonly("w", &PyIgfcoulombfun::w)
      .def_readonly("gam", &PyIgfcoulombfun::gam)
      .def_readonly("dx", &PyIgfcoulombfun::dx)
      .def_readonly("dy", &PyIgfcoulombfun::dy)
      .def_readonly("dz", &PyIgfcoulombfun::dz)
      .def_readonly("res", &PyIgfcoulombfun::res)
      .def("__len__", [](const PyIgfcoulombfun&) { return 8; })
      .def("__getitem__", [](const PyIgfcoulombfun& s, size_t i) -> py::object {
        if (i >= 8)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.u);
        if (i == 1)
          return py::cast(s.v);
        if (i == 2)
          return py::cast(s.w);
        if (i == 3)
          return py::cast(s.gam);
        if (i == 4)
          return py::cast(s.dx);
        if (i == 5)
          return py::cast(s.dy);
        if (i == 6)
          return py::cast(s.dz);
        if (i == 7)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "lafun",
      &python_lafun,
      py::arg("x"),
      py::arg("y"),
      py::arg("z"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
x : 
y : 
z : 
res : 
)""");
  py::class_<PyLafun, std::unique_ptr<PyLafun>>(
      m, "Lafun", "Fortran routine lafun return value")
      .def_readonly("x", &PyLafun::x)
      .def_readonly("y", &PyLafun::y)
      .def_readonly("z", &PyLafun::z)
      .def_readonly("res", &PyLafun::res)
      .def("__len__", [](const PyLafun&) { return 4; })
      .def("__getitem__", [](const PyLafun& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.x);
        if (i == 1)
          return py::cast(s.y);
        if (i == 2)
          return py::cast(s.z);
        if (i == 3)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "igfexfun",
      &python_igfexfun,
      py::arg("u"),
      py::arg("v"),
      py::arg("w"),
      py::arg("gam"),
      py::arg("dx"),
      py::arg("dy"),
      py::arg("dz"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
u : 
v : 
w : 
gam : 
dx : 
dy : 
dz : 
res : 
)""");
  py::class_<PyIgfexfun, std::unique_ptr<PyIgfexfun>>(
      m, "Igfexfun", "Fortran routine igfexfun return value")
      .def_readonly("u", &PyIgfexfun::u)
      .def_readonly("v", &PyIgfexfun::v)
      .def_readonly("w", &PyIgfexfun::w)
      .def_readonly("gam", &PyIgfexfun::gam)
      .def_readonly("dx", &PyIgfexfun::dx)
      .def_readonly("dy", &PyIgfexfun::dy)
      .def_readonly("dz", &PyIgfexfun::dz)
      .def_readonly("res", &PyIgfexfun::res)
      .def("__len__", [](const PyIgfexfun&) { return 8; })
      .def("__getitem__", [](const PyIgfexfun& s, size_t i) -> py::object {
        if (i >= 8)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.u);
        if (i == 1)
          return py::cast(s.v);
        if (i == 2)
          return py::cast(s.w);
        if (i == 3)
          return py::cast(s.gam);
        if (i == 4)
          return py::cast(s.dx);
        if (i == 5)
          return py::cast(s.dy);
        if (i == 6)
          return py::cast(s.dz);
        if (i == 7)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "igfeyfun",
      &python_igfeyfun,
      py::arg("u"),
      py::arg("v"),
      py::arg("w"),
      py::arg("gam"),
      py::arg("dx"),
      py::arg("dy"),
      py::arg("dz"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
u : 
v : 
w : 
gam : 
dx : 
dy : 
dz : 
res : 
)""");
  py::class_<PyIgfeyfun, std::unique_ptr<PyIgfeyfun>>(
      m, "Igfeyfun", "Fortran routine igfeyfun return value")
      .def_readonly("u", &PyIgfeyfun::u)
      .def_readonly("v", &PyIgfeyfun::v)
      .def_readonly("w", &PyIgfeyfun::w)
      .def_readonly("gam", &PyIgfeyfun::gam)
      .def_readonly("dx", &PyIgfeyfun::dx)
      .def_readonly("dy", &PyIgfeyfun::dy)
      .def_readonly("dz", &PyIgfeyfun::dz)
      .def_readonly("res", &PyIgfeyfun::res)
      .def("__len__", [](const PyIgfeyfun&) { return 8; })
      .def("__getitem__", [](const PyIgfeyfun& s, size_t i) -> py::object {
        if (i >= 8)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.u);
        if (i == 1)
          return py::cast(s.v);
        if (i == 2)
          return py::cast(s.w);
        if (i == 3)
          return py::cast(s.gam);
        if (i == 4)
          return py::cast(s.dx);
        if (i == 5)
          return py::cast(s.dy);
        if (i == 6)
          return py::cast(s.dz);
        if (i == 7)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "igfezfun",
      &python_igfezfun,
      py::arg("u"),
      py::arg("v"),
      py::arg("w"),
      py::arg("gam"),
      py::arg("dx"),
      py::arg("dy"),
      py::arg("dz"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
u : 
v : 
w : 
gam : 
dx : 
dy : 
dz : 
res : 
)""");
  py::class_<PyIgfezfun, std::unique_ptr<PyIgfezfun>>(
      m, "Igfezfun", "Fortran routine igfezfun return value")
      .def_readonly("u", &PyIgfezfun::u)
      .def_readonly("v", &PyIgfezfun::v)
      .def_readonly("w", &PyIgfezfun::w)
      .def_readonly("gam", &PyIgfezfun::gam)
      .def_readonly("dx", &PyIgfezfun::dx)
      .def_readonly("dy", &PyIgfezfun::dy)
      .def_readonly("dz", &PyIgfezfun::dz)
      .def_readonly("res", &PyIgfezfun::res)
      .def("__len__", [](const PyIgfezfun&) { return 8; })
      .def("__getitem__", [](const PyIgfezfun& s, size_t i) -> py::object {
        if (i >= 8)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.u);
        if (i == 1)
          return py::cast(s.v);
        if (i == 2)
          return py::cast(s.w);
        if (i == 3)
          return py::cast(s.gam);
        if (i == 4)
          return py::cast(s.dx);
        if (i == 5)
          return py::cast(s.dy);
        if (i == 6)
          return py::cast(s.dz);
        if (i == 7)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "xlafun",
      &python_xlafun,
      py::arg("x"),
      py::arg("y"),
      py::arg("z"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
x : 
y : 
z : 
res : 
)""");
  py::class_<PyXlafun, std::unique_ptr<PyXlafun>>(
      m, "Xlafun", "Fortran routine xlafun return value")
      .def_readonly("x", &PyXlafun::x)
      .def_readonly("y", &PyXlafun::y)
      .def_readonly("z", &PyXlafun::z)
      .def_readonly("res", &PyXlafun::res)
      .def("__len__", [](const PyXlafun&) { return 4; })
      .def("__getitem__", [](const PyXlafun& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.x);
        if (i == 1)
          return py::cast(s.y);
        if (i == 2)
          return py::cast(s.z);
        if (i == 3)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "ylafun",
      &python_ylafun,
      py::arg("x"),
      py::arg("y"),
      py::arg("z"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
x : 
y : 
z : 
res : 
)""");
  py::class_<PyYlafun, std::unique_ptr<PyYlafun>>(
      m, "Ylafun", "Fortran routine ylafun return value")
      .def_readonly("x", &PyYlafun::x)
      .def_readonly("y", &PyYlafun::y)
      .def_readonly("z", &PyYlafun::z)
      .def_readonly("res", &PyYlafun::res)
      .def("__len__", [](const PyYlafun&) { return 4; })
      .def("__getitem__", [](const PyYlafun& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.x);
        if (i == 1)
          return py::cast(s.y);
        if (i == 2)
          return py::cast(s.z);
        if (i == 3)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "zlafun",
      &python_zlafun,
      py::arg("x"),
      py::arg("y"),
      py::arg("z"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
x : 
y : 
z : 
res : 
)""");
  py::class_<PyZlafun, std::unique_ptr<PyZlafun>>(
      m, "Zlafun", "Fortran routine zlafun return value")
      .def_readonly("x", &PyZlafun::x)
      .def_readonly("y", &PyZlafun::y)
      .def_readonly("z", &PyZlafun::z)
      .def_readonly("res", &PyZlafun::res)
      .def("__len__", [](const PyZlafun&) { return 4; })
      .def("__getitem__", [](const PyZlafun& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.x);
        if (i == 1)
          return py::cast(s.y);
        if (i == 2)
          return py::cast(s.z);
        if (i == 3)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "osc_getgrnpipe",
      &python_osc_getgrnpipe,
      py::arg("gam"),
      py::arg("a"),
      py::arg("b"),
      py::arg("delta"),
      py::arg("umin"),
      py::arg("npad"),
      R"""(No docstring available

Parameters
----------
gam : 
a : 
b : 
delta : 
umin : 
npad : 
)""");
  py::class_<PyOscGetgrnpipe, std::unique_ptr<PyOscGetgrnpipe>>(
      m, "OscGetgrnpipe", "Fortran routine osc_getgrnpipe return value")
      .def_readonly("gam", &PyOscGetgrnpipe::gam)
      .def_readonly("a", &PyOscGetgrnpipe::a)
      .def_readonly("b", &PyOscGetgrnpipe::b)
      .def("__len__", [](const PyOscGetgrnpipe&) { return 3; })
      .def("__getitem__", [](const PyOscGetgrnpipe& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.gam);
        if (i == 1)
          return py::cast(s.a);
        if (i == 2)
          return py::cast(s.b);
        return py::none();
      });
  m.def(
      "rfun",
      &python_rfun,
      py::arg("u"),
      py::arg("v"),
      py::arg("w"),
      py::arg("gam"),
      py::arg("a"),
      py::arg("b"),
      py::arg("hz"),
      py::arg("i"),
      py::arg("j"),
      py::arg("res"),
      R"""(No docstring available

Parameters
----------
u : 
v : 
w : 
gam : 
a : 
b : 
hz : 
i : 
j : 
res : 
)""");
  py::class_<PyRfun, std::unique_ptr<PyRfun>>(
      m, "Rfun", "Fortran routine rfun return value")
      .def_readonly("u", &PyRfun::u)
      .def_readonly("v", &PyRfun::v)
      .def_readonly("w", &PyRfun::w)
      .def_readonly("gam", &PyRfun::gam)
      .def_readonly("a", &PyRfun::a)
      .def_readonly("b", &PyRfun::b)
      .def_readonly("hz", &PyRfun::hz)
      .def_readonly("i", &PyRfun::i)
      .def_readonly("j", &PyRfun::j)
      .def_readonly("res", &PyRfun::res)
      .def("__len__", [](const PyRfun&) { return 10; })
      .def("__getitem__", [](const PyRfun& s, size_t i) -> py::object {
        if (i >= 10)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.u);
        if (i == 1)
          return py::cast(s.v);
        if (i == 2)
          return py::cast(s.w);
        if (i == 3)
          return py::cast(s.gam);
        if (i == 4)
          return py::cast(s.a);
        if (i == 5)
          return py::cast(s.b);
        if (i == 6)
          return py::cast(s.hz);
        if (i == 7)
          return py::cast(s.i);
        if (i == 8)
          return py::cast(s.j);
        if (i == 9)
          return py::cast(s.res);
        return py::none();
      });
  m.def(
      "osc_read_rectpipe_grn",
      &Bmad::osc_read_rectpipe_grn,
      R"""(No docstring available

)""");
  m.def(
      "osc_write_rectpipe_grn",
      &python_osc_write_rectpipe_grn,
      py::arg("apipe"),
      py::arg("bpipe"),
      py::arg("delta"),
      py::arg("umin"),
      py::arg("umax"),
      py::arg("nlo"),
      py::arg("nhi"),
      py::arg("gamma"),
      R"""(No docstring available

Parameters
----------
apipe : 
bpipe : 
delta : 
umin : 
umax : 
nlo : 
nhi : 
gamma : 
)""");
  py::class_<PyOscWriteRectpipeGrn, std::unique_ptr<PyOscWriteRectpipeGrn>>(
      m,
      "OscWriteRectpipeGrn",
      "Fortran routine osc_write_rectpipe_grn return value")
      .def_readonly("apipe", &PyOscWriteRectpipeGrn::apipe)
      .def_readonly("bpipe", &PyOscWriteRectpipeGrn::bpipe)
      .def_readonly("gamma", &PyOscWriteRectpipeGrn::gamma)
      .def("__len__", [](const PyOscWriteRectpipeGrn&) { return 3; })
      .def(
          "__getitem__",
          [](const PyOscWriteRectpipeGrn& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.apipe);
            if (i == 1)
              return py::cast(s.bpipe);
            if (i == 2)
              return py::cast(s.gamma);
            return py::none();
          });
  m.def(
      "osc_alloc_rectpipe_arrays",
      &Bmad::osc_alloc_rectpipe_arrays,
      py::arg("nlo"),
      py::arg("nhi"),
      py::arg("npad"),
      R"""(No docstring available

Parameters
----------
nlo : 
nhi : 
npad : 
)""");
  m.def(
      "osc_alloc_image_array",
      &Bmad::osc_alloc_image_array,
      py::arg("nlo"),
      py::arg("nhi"),
      py::arg("npad"),
      R"""(No docstring available

Parameters
----------
nlo : 
nhi : 
npad : 
)""");
  m.def(
      "fft1",
      &Bmad::fft1,
      py::arg("a"),
      py::arg("b"),
      py::arg("n"),
      py::arg("isn"),
      R"""(No docstring available

Parameters
----------
a : 
b : 
n : 
isn : 
ierr : 
)""");
  m.def(
      "mfft1",
      &Bmad::mfft1,
      py::arg("a"),
      py::arg("b"),
      py::arg("n"),
      py::arg("ndim"),
      py::arg("isn"),
      R"""(No docstring available

Parameters
----------
a : 
b : 
n : 
ndim : 
isn : 
ierr : 
)""");
  m.def(
      "ellipinc_test",
      &Bmad::ellipinc_test,
      R"""(No docstring available

)""");
  m.def(
      "sc_step",
      &python_sc_step,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("include_image"),
      py::arg("t_end"),
      py::arg("sc_field"),
      R"""(Subroutine to track a bunch through a given time step with space charge

Parameters
----------
bunch : BunchStruct
    Starting bunch position in t-based coordinates
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position in t-based
    coordinates after space charge kick.
ele : EleStruct
    Nominal element being tracked through.
include_image : bool
    Include image charge forces?
    This parameter is an input/output and is modified in-place. As an output: Set False if image charge calc
    no longer needed (Note
t_end : float
    Time at which the tracking ends.
sc_field : unknown
    : Array to hold space charge fields. Its length should be the number of particles.

Returns
-------
n_emit : int
    The number of particles emitted in this step.
)""");
  py::class_<PyScStep, std::unique_ptr<PyScStep>>(
      m, "ScStep", "Fortran routine sc_step return value")
      .def_readonly("n_emit", &PyScStep::n_emit)
      .def_readonly("include_image", &PyScStep::include_image)
      .def("__len__", [](const PyScStep&) { return 2; })
      .def("__getitem__", [](const PyScStep& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n_emit);
        if (i == 1)
          return py::cast(s.include_image);
        return py::none();
      });
  m.def(
      "sc_adaptive_step",
      &python_sc_adaptive_step,
      py::arg("bunch"),
      py::arg("ele"),
      py::arg("include_image"),
      py::arg("t_now"),
      py::arg("dt_step"),
      py::arg("sc_field"),
      R"""(Routine to track a bunch of particles with space charge for one step using

adaptive step size control and determine appropriate step size for the next step

Parameters
----------
bunch : BunchStruct
    Starting bunch position in t-based coordinates
    This parameter is an input/output and is modified in-place. As an output: Ending bunch position in t-based
    coordinates.
ele : EleStruct
    Nominal lattice element being tracked through.
include_image : bool
    Include image charge forces?
    This parameter is an input/output and is modified in-place. As an output: Set False if image charge calc
    no longer needed (Note
t_now : float
    Current time at the beginning of tracking
dt_step : float
    Initial SC time step to take
    This parameter is an input/output and is modified in-place. As an output: Step done.
sc_field : unknown
    : Array to hold space charge fields. Its length should be the number of particles.

Returns
-------
dt_next : float
    Next SC time step the tracker would take based on the error tolerance
)""");
  py::class_<PyScAdaptiveStep, std::unique_ptr<PyScAdaptiveStep>>(
      m, "ScAdaptiveStep", "Fortran routine sc_adaptive_step return value")
      .def_readonly("dt_next", &PyScAdaptiveStep::dt_next)
      .def_readonly("include_image", &PyScAdaptiveStep::include_image)
      .def_readonly("dt_step", &PyScAdaptiveStep::dt_step)
      .def("__len__", [](const PyScAdaptiveStep&) { return 3; })
      .def(
          "__getitem__", [](const PyScAdaptiveStep& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dt_next);
            if (i == 1)
              return py::cast(s.include_image);
            if (i == 2)
              return py::cast(s.dt_step);
            return py::none();
          });
  m.def(
      "track_bunch_to_s",
      &Bmad::track_bunch_to_s,
      py::arg("bunch"),
      py::arg("s"),
      py::arg("branch"),
      R"""(Drift a bunch of particles to the same s coordinate

Parameters
----------
bunch : BunchStruct
    Input bunch position in s-based coordinate.
    This parameter is an input/output and is modified in-place. As an output: Output bunch position in s-based
    coordinate. Particles will be at the same s coordinate
s : float
    Target coordinate.
branch : BranchStruct
    Branch being tracked through.
)""");
  m.def(
      "track_bunch_to_t",
      &Bmad::track_bunch_to_t,
      py::arg("bunch"),
      py::arg("t_target"),
      py::arg("branch"),
      R"""(Drift a bunch of particles to the same t coordinate

Parameters
----------
bunch : BunchStruct
    Input bunch position in s-based coordinate.
    This parameter is an input/output and is modified in-place. As an output: Output bunch position in s-based
    coordinate. Particles will be at the same t coordinate
t_target : float
    Target t coordinate.
branch : BranchStruct
    Lattice branch being tracked through.
)""");
  m.def(
      "drift_particle_to_s",
      &Bmad::drift_particle_to_s,
      py::arg("p"),
      py::arg("s"),
      py::arg("branch"),
      R"""(Drift a particle to a given s-coordinate

Parameters
----------
p : CoordStruct
    Init particle position.
    This parameter is an input/output and is modified in-place. As an output: Final particle position.
s : float
    Target s coordinate.
branch : BranchStruct
    Branch being tracked through.
)""");
  m.def(
      "drift_particle_to_t",
      &Bmad::drift_particle_to_t,
      py::arg("p"),
      py::arg("t"),
      py::arg("branch"),
      R"""(Drift a particle to a given t-coordinate

Parameters
----------
p : CoordStruct
    Init particle position.
    This parameter is an input/output and is modified in-place. As an output: Final particle position.
t : float
    Target t coordinate.
branch : BranchStruct
    Lattice branch being tracked through.
)""");
  m.def(
      "antiparticle",
      &SimUtils::antiparticle,
      py::arg("species"),
      R"""(Routine to return the antiparticle ID given the particle ID.

For a molecule the anti-species is just the molecude with the charge reversed.

Parameters
----------
species : int
    Particle ID.

Returns
-------
anti_species : int
    Antiparticle ID.
)""");
  m.def(
      "species_of",
      &SimUtils::species_of,
      py::arg("mass"),
      py::arg("charge"),
      R"""(Routine to return the integer ID index of a particle species given the mass and charge.

Parameters
----------
mass : float
    Mass of the particle
charge : int
    Charge of the particle.

Returns
-------
species : int
    Species ID. Will return invalid$ if name is not valid.
)""");
  m.def(
      "species_id",
      &SimUtils::species_id,
      py::arg("name"),
      py::arg("default_") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(Routine to return the integer ID index of a particle species given the name.

For subatomic particles, the case does not matter.
For all other types of particles, the case does matter.

Parameters
----------
name : unknown
    Name of the species.
default : int, optional
    Default species to use if name is blank or 'ref_species'. If not present, a blank name is an error.
print_err : bool, optional
    Print error message? Default is True. If False, return species = invalid$,

Returns
-------
species : int
    Species ID. Will return invalid$ if name is not valid. Will return not_set$ if name is blank
)""");
  m.def(
      "atomic_species_id",
      &SimUtils::atomic_species_id,
      py::arg("charge"),
      py::arg("is_anti"),
      py::arg("atomic_num"),
      py::arg("n_nuc"),
      R"""(Routine to return the species ID for an atom

Parameters
----------
charge : int
    Charge of the atom.
is_anti : bool
    Is an anti-atom.
atomic_num : int
    Atomic number.
n_nuc : int
    Number of nucleons.

Returns
-------
species_id : int
    Species ID number.
)""");
  m.def(
      "species_name",
      &SimUtils::species_name,
      py::arg("species"),
      R"""(Routine to return the name of a particle species given the integer index.

Parameters
----------
species : int
    Species ID.

Returns
-------
name : unknown
    Name of the species. Will return 'INVALID!' (= invalid_name) if index is not valid.
)""");
  m.def(
      "species_id_from_openpmd",
      &SimUtils::species_id_from_openpmd,
      py::arg("pmd_name"),
      py::arg("charge"),
      R"""(Routine to return the Bmad species ID given the openPMD species name and given particle charge.

Parameters
----------
pmd_name : unknown
    OpenPMD species name.
charge : int
    Species charge. Ignored for subatomic particles.

Returns
-------
species : int
    Bmad spicies ID number.
)""");
  m.def(
      "openpmd_species_name",
      &SimUtils::openpmd_species_name,
      py::arg("species"),
      R"""(Routine to return the openPMD name of a particle species given the Bmad species ID.

Parameters
----------
species : int
    Bmad species ID number.

Returns
-------
pmd_name : unknown
    Name of the species. Will return 'INVALID!' (= invalid_name) if index is not valid.
)""");
  m.def(
      "anomalous_moment_of",
      &SimUtils::anomalous_moment_of,
      py::arg("species"),
      R"""(Routine to return the anomolous moment for subatomic species type. Otherwise returns 0.

Parameters
----------
species : int
    Species ID.

Returns
-------
moment : float
    Anomalous moment.
)""");
  m.def(
      "spin_of",
      &SimUtils::spin_of,
      py::arg("species"),
      py::arg("non_subatomic_default") = py::none(),
      R"""(Routine to return the spin, in units of hbar, of a particle.

This routine is only valid for subatomic particles.
For all other particles, the returned spin value will be the value of non_subatomic_default.

Parameters
----------
species : int
    Species ID.
non_subatomic_default : float, optional
    Default value to be used for non-subatomic species. Default value of this argument is zero.

Returns
-------
spin : float
    Particle spin.
)""");
  m.def(
      "charge_of",
      &SimUtils::charge_of,
      py::arg("species"),
      py::arg("default_") = py::none(),
      R"""(Routine to return the charge, in units of e+, of a particle.

Parameters
----------
species : int
    Species ID.
default : int, optional
    If present then use default value if species = not_set$.

Returns
-------
charge : int
    particle charge.
)""");
  m.def(
      "mass_of",
      &SimUtils::mass_of,
      py::arg("species"),
      R"""(Routine to return the mass, in units of eV/c^2, of a particle.

To convert to AMU divide mass_of value by the constant atomic_mass_unit.
binding energy effects. Exception: For #1H+ (proton) and #2H+ (deuteron) the exact mass is used since it is known.

Parameters
----------
species : int
    Species ID.

Returns
-------
mass : float
    particle mass. Set to real_garbage$ if species value is invalid.

Notes
-----
Note: For atoms where the isotopic number is given, the mass is calculated using the neutral atomic mass
adjusted by the weight of any added or missing electrons. The calculated mass is off very slightly due to
)""");
  m.def(
      "charge_to_mass_of",
      &SimUtils::charge_to_mass_of,
      py::arg("species"),
      R"""(Routine to return the charge (in units of e+) to mass (in units of eV) ratio of a particle.

Parameters
----------
species : int
    Species ID.

Returns
-------
charge_mass_ratio : float
    particle charge to mass ratio. (1/eV)
)""");
  m.def(
      "set_species_charge",
      &SimUtils::set_species_charge,
      py::arg("species_in"),
      py::arg("charge"),
      R"""(Routine to return the ID for a particle of the same type as species_in but with a different charge.

Exception: If species_in corresponds to a subatomic particle, the charge argument is ignored and
species_charged will be set equal to species_in.

Parameters
----------
species_in : int
    Input species.
charge : int
    Charge to set species_charged to.

Returns
-------
species_charged : int
    Species of the same type as species_in but with different charge.
)""");
  m.def(
      "x0_radiation_length",
      &SimUtils::x0_radiation_length,
      py::arg("species"),
      R"""(Routine to return the X0 raidation length for atomes.

Parameters
----------
Species : int
    Species ID.

Returns
-------
x0 : float
    Radiation length in kg/m^2. Set to real_garbage$ if species is not atomic or has atomic index greater than
    92.
)""");
  m.def(
      "atomic_number",
      &SimUtils::atomic_number,
      py::arg("species"),
      R"""(Routine to return the atomic number Z if species argument corresponds to an atomic particle  or is a proton.

Set to the charge for atomic particles.
Set to zero for molecules.

Parameters
----------
species : int
    Spicies ID.

Returns
-------
atomic_num : int
    Atomic index. Set to zero if a molecule
)""");
  m.def(
      "is_subatomic_species",
      &SimUtils::is_subatomic_species,
      py::arg("species"),
      R"""(Routine to return True if species argument corresponds to a subatomic particle.

Parameters
----------
species : int
    Spicies ID.

Returns
-------
is_subatomic : bool
    Set True if species corresponds to a subatomic particle.
)""");
  m.def(
      "is_true",
      &SimUtils::is_true,
      py::arg("param"),
      R"""(Routine to translate from a real number to a boolian True or False.

Translation: 0 = False, nonzero = True

Parameters
----------
param : float
    Real number to be translated

Returns
-------
this_true : bool
    Set False if param is zero. True otherwise.

Notes
-----
Related routines:
is_false int_logic ) which is a real array. Some of the elements in the %value array are used to specify
boolian attributes. For example quadrupoles use ele%value(scale_multipoles$).
)""");
  m.def(
      "is_false",
      &SimUtils::is_false,
      py::arg("param"),
      R"""(Routine to translate from a real number to a boolian True or False.

Translation: 0 = False, nonzero = True

Parameters
----------
param : float
    Real number to be translated

Returns
-------
this_false : bool
    Set True if param is zero. False otherwise.

Notes
-----
Related routines:
is_true int_logic ) which is a real array. Some of the elements in the %value array are used to specify
boolian attributes. For example quadrupoles use ele%value(scale_multipoles$).
)""");
  m.def(
      "rp8",
      &SimUtils::rp8,
      py::arg("int_in"),
      R"""(Routine to convert from integer to real of type rp.

This routine is used to avoid the implicit integer to single precision that happens when
multiplying int*real(rp).

Parameters
----------
int_in : int
    Input integer.

Returns
-------
re_out : float
    Equiv real.
)""");
  m.def(
      "set_parameter",
      py::overload_cast<double, double, double>(&python_set_parameter_real),
      py::arg("param_val"),
      py::arg("set_val"),
      py::arg("save_val"),
      R"""(No docstring available

Parameters
----------
param_val : 
set_val : 
save_val : 
)""");
  py::class_<PySetParameterReal, std::unique_ptr<PySetParameterReal>>(
      m, "SetParameterReal", "Fortran routine set_parameter_real return value")
      .def_readonly("param_val", &PySetParameterReal::param_val)
      .def_readonly("set_val", &PySetParameterReal::set_val)
      .def_readonly("save_val", &PySetParameterReal::save_val)
      .def("__len__", [](const PySetParameterReal&) { return 3; })
      .def(
          "__getitem__",
          [](const PySetParameterReal& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.param_val);
            if (i == 1)
              return py::cast(s.set_val);
            if (i == 2)
              return py::cast(s.save_val);
            return py::none();
          });
  m.def(
      "set_parameter",
      py::overload_cast<int, int, int>(&python_set_parameter_int),
      py::arg("param_val"),
      py::arg("set_val"),
      py::arg("save_val"),
      R"""(No docstring available

Parameters
----------
param_val : 
set_val : 
save_val : 
)""");
  py::class_<PySetParameterInt, std::unique_ptr<PySetParameterInt>>(
      m, "SetParameterInt", "Fortran routine set_parameter_int return value")
      .def_readonly("param_val", &PySetParameterInt::param_val)
      .def_readonly("set_val", &PySetParameterInt::set_val)
      .def_readonly("save_val", &PySetParameterInt::save_val)
      .def("__len__", [](const PySetParameterInt&) { return 3; })
      .def(
          "__getitem__",
          [](const PySetParameterInt& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.param_val);
            if (i == 1)
              return py::cast(s.set_val);
            if (i == 2)
              return py::cast(s.save_val);
            return py::none();
          });
  m.def(
      "set_parameter",
      py::overload_cast<bool, bool, bool>(&python_set_parameter_logic),
      py::arg("param_val"),
      py::arg("set_val"),
      py::arg("save_val"),
      R"""(No docstring available

Parameters
----------
param_val : 
set_val : 
save_val : 
)""");
  py::class_<PySetParameterLogic, std::unique_ptr<PySetParameterLogic>>(
      m,
      "SetParameterLogic",
      "Fortran routine set_parameter_logic return value")
      .def_readonly("param_val", &PySetParameterLogic::param_val)
      .def_readonly("set_val", &PySetParameterLogic::set_val)
      .def_readonly("save_val", &PySetParameterLogic::save_val)
      .def("__len__", [](const PySetParameterLogic&) { return 3; })
      .def(
          "__getitem__",
          [](const PySetParameterLogic& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.param_val);
            if (i == 1)
              return py::cast(s.set_val);
            if (i == 2)
              return py::cast(s.save_val);
            return py::none();
          });
  m.def(
      "cosc",
      &python_cosc,
      py::arg("x"),
      py::arg("nd") = py::none(),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
x : 
nd : 
y : 
)""");
  py::class_<PyCosc, std::unique_ptr<PyCosc>>(
      m, "Cosc", "Fortran routine cosc return value")
      .def_readonly("y", &PyCosc::y)
      .def("__len__", [](const PyCosc&) { return 1; })
      .def("__getitem__", [](const PyCosc& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "asinc",
      &python_asinc,
      py::arg("x"),
      py::arg("nd") = py::none(),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
x : 
nd : 
y : 
)""");
  py::class_<PyAsinc, std::unique_ptr<PyAsinc>>(
      m, "Asinc", "Fortran routine asinc return value")
      .def_readonly("y", &PyAsinc::y)
      .def("__len__", [](const PyAsinc&) { return 1; })
      .def("__getitem__", [](const PyAsinc& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "assert_equal",
      &python_assert_equal,
      py::arg("int_arr"),
      py::arg("err_str"),
      py::arg("ival"),
      R"""(No docstring available

Parameters
----------
int_arr : 
err_str : 
ival : 
)""");
  py::class_<PyAssertEqual, std::unique_ptr<PyAssertEqual>>(
      m, "AssertEqual", "Fortran routine assert_equal return value")
      .def_readonly("err_str", &PyAssertEqual::err_str)
      .def_readonly("ival", &PyAssertEqual::ival)
      .def("__len__", [](const PyAssertEqual&) { return 2; })
      .def("__getitem__", [](const PyAssertEqual& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_str);
        if (i == 1)
          return py::cast(s.ival);
        return py::none();
      });
  m.def(
      "calc_file_number",
      &python_calc_file_number,
      py::arg("file_name"),
      py::arg("num_in"),
      py::arg("num_out"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
file_name : 
num_in : 
num_out : 
err_flag : 
)""");
  py::class_<PyCalcFileNumber, std::unique_ptr<PyCalcFileNumber>>(
      m, "CalcFileNumber", "Fortran routine calc_file_number return value")
      .def_readonly("file_name", &PyCalcFileNumber::file_name)
      .def_readonly("num_in", &PyCalcFileNumber::num_in)
      .def_readonly("num_out", &PyCalcFileNumber::num_out)
      .def_readonly("err_flag", &PyCalcFileNumber::err_flag)
      .def("__len__", [](const PyCalcFileNumber&) { return 4; })
      .def(
          "__getitem__", [](const PyCalcFileNumber& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.file_name);
            if (i == 1)
              return py::cast(s.num_in);
            if (i == 2)
              return py::cast(s.num_out);
            if (i == 3)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "change_file_number",
      &python_change_file_number,
      py::arg("file_name"),
      py::arg("change"),
      R"""(No docstring available

Parameters
----------
file_name : 
change : 
)""");
  py::class_<PyChangeFileNumber, std::unique_ptr<PyChangeFileNumber>>(
      m, "ChangeFileNumber", "Fortran routine change_file_number return value")
      .def_readonly("file_name", &PyChangeFileNumber::file_name)
      .def_readonly("change", &PyChangeFileNumber::change)
      .def("__len__", [](const PyChangeFileNumber&) { return 2; })
      .def(
          "__getitem__",
          [](const PyChangeFileNumber& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.file_name);
            if (i == 1)
              return py::cast(s.change);
            return py::none();
          });
  m.def(
      "cos_one",
      &python_cos_one,
      py::arg("angle"),
      py::arg("cos1"),
      R"""(No docstring available

Parameters
----------
angle : 
cos1 : 
)""");
  py::class_<PyCosOne, std::unique_ptr<PyCosOne>>(
      m, "CosOne", "Fortran routine cos_one return value")
      .def_readonly("cos1", &PyCosOne::cos1)
      .def("__len__", [](const PyCosOne&) { return 1; })
      .def("__getitem__", [](const PyCosOne& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.cos1);
        return py::none();
      });
  m.def(
      "complex_error_function",
      &python_complex_error_function,
      py::arg("wr"),
      py::arg("wi"),
      py::arg("zr"),
      py::arg("zi"),
      R"""(No docstring available

Parameters
----------
wr : 
wi : 
zr : 
zi : 
)""");
  py::class_<PyComplexErrorFunction, std::unique_ptr<PyComplexErrorFunction>>(
      m,
      "ComplexErrorFunction",
      "Fortran routine complex_error_function return value")
      .def_readonly("wr", &PyComplexErrorFunction::wr)
      .def_readonly("wi", &PyComplexErrorFunction::wi)
      .def_readonly("zr", &PyComplexErrorFunction::zr)
      .def_readonly("zi", &PyComplexErrorFunction::zi)
      .def("__len__", [](const PyComplexErrorFunction&) { return 4; })
      .def(
          "__getitem__",
          [](const PyComplexErrorFunction& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.wr);
            if (i == 1)
              return py::cast(s.wi);
            if (i == 2)
              return py::cast(s.zr);
            if (i == 3)
              return py::cast(s.zi);
            return py::none();
          });
  m.def(
      "cross_product",
      &SimUtils::cross_product,
      py::arg("a"),
      py::arg("b"),
      py::arg("c"),
      R"""(No docstring available

Parameters
----------
a : float
    Input vectors.
b : 
c : 
)""");
  m.def(
      "date_and_time_stamp",
      &python_date_and_time_stamp,
      py::arg("string"),
      py::arg("numeric_month") = py::none(),
      py::arg("include_zone") = py::none(),
      R"""(No docstring available

Parameters
----------
string : 
numeric_month : 
include_zone : 
)""");
  py::class_<PyDateAndTimeStamp, std::unique_ptr<PyDateAndTimeStamp>>(
      m, "DateAndTimeStamp", "Fortran routine date_and_time_stamp return value")
      .def_readonly("string", &PyDateAndTimeStamp::string)
      .def_readonly("numeric_month", &PyDateAndTimeStamp::numeric_month)
      .def_readonly("include_zone", &PyDateAndTimeStamp::include_zone)
      .def("__len__", [](const PyDateAndTimeStamp&) { return 3; })
      .def(
          "__getitem__",
          [](const PyDateAndTimeStamp& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.string);
            if (i == 1)
              return py::cast(s.numeric_month);
            if (i == 2)
              return py::cast(s.include_zone);
            return py::none();
          });
  m.def(
      "detab",
      &python_detab,
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
str : 
)""");
  py::class_<PyDetab, std::unique_ptr<PyDetab>>(
      m, "Detab", "Fortran routine detab return value")
      .def_readonly("str", &PyDetab::str)
      .def("__len__", [](const PyDetab&) { return 1; })
      .def("__getitem__", [](const PyDetab& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "display_size_and_resolution",
      &python_display_size_and_resolution,
      py::arg("ix_screen"),
      py::arg("x_size"),
      py::arg("y_size"),
      py::arg("x_res"),
      py::arg("y_res"),
      R"""(No docstring available

Parameters
----------
ix_screen : 
x_size : 
y_size : 
x_res : 
y_res : 
)""");
  py::class_<
      PyDisplaySizeAndResolution,
      std::unique_ptr<PyDisplaySizeAndResolution>>(
      m,
      "DisplaySizeAndResolution",
      "Fortran routine display_size_and_resolution return value")
      .def_readonly("ix_screen", &PyDisplaySizeAndResolution::ix_screen)
      .def_readonly("x_size", &PyDisplaySizeAndResolution::x_size)
      .def_readonly("y_size", &PyDisplaySizeAndResolution::y_size)
      .def_readonly("x_res", &PyDisplaySizeAndResolution::x_res)
      .def_readonly("y_res", &PyDisplaySizeAndResolution::y_res)
      .def("__len__", [](const PyDisplaySizeAndResolution&) { return 5; })
      .def(
          "__getitem__",
          [](const PyDisplaySizeAndResolution& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_screen);
            if (i == 1)
              return py::cast(s.x_size);
            if (i == 2)
              return py::cast(s.y_size);
            if (i == 3)
              return py::cast(s.x_res);
            if (i == 4)
              return py::cast(s.y_res);
            return py::none();
          });
  m.def(
      "dj_bessel",
      &python_dj_bessel,
      py::arg("m"),
      py::arg("arg"),
      py::arg("dj_bes"),
      R"""(No docstring available

Parameters
----------
m : 
arg : 
dj_bes : 
)""");
  py::class_<PyDjBessel, std::unique_ptr<PyDjBessel>>(
      m, "DjBessel", "Fortran routine dj_bessel return value")
      .def_readonly("m", &PyDjBessel::m)
      .def_readonly("arg", &PyDjBessel::arg)
      .def_readonly("dj_bes", &PyDjBessel::dj_bes)
      .def("__len__", [](const PyDjBessel&) { return 3; })
      .def("__getitem__", [](const PyDjBessel& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.m);
        if (i == 1)
          return py::cast(s.arg);
        if (i == 2)
          return py::cast(s.dj_bes);
        return py::none();
      });
  m.def(
      "djb_hash",
      &python_djb_hash,
      py::arg("str"),
      py::arg("old_hash") = py::none(),
      py::arg("hash"),
      R"""(No docstring available

Parameters
----------
str : 
old_hash : 
hash : 
)""");
  py::class_<PyDjbHash, std::unique_ptr<PyDjbHash>>(
      m, "DjbHash", "Fortran routine djb_hash return value")
      .def_readonly("str", &PyDjbHash::str)
      .def_readonly("old_hash", &PyDjbHash::old_hash)
      .def_readonly("hash", &PyDjbHash::hash)
      .def("__len__", [](const PyDjbHash&) { return 3; })
      .def("__getitem__", [](const PyDjbHash& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        if (i == 1)
          return py::cast(s.old_hash);
        if (i == 2)
          return py::cast(s.hash);
        return py::none();
      });
  m.def(
      "djb_str_hash",
      &python_djb_str_hash,
      py::arg("in_str"),
      py::arg("hash_str"),
      R"""(No docstring available

Parameters
----------
in_str : 
hash_str : 
)""");
  py::class_<PyDjbStrHash, std::unique_ptr<PyDjbStrHash>>(
      m, "DjbStrHash", "Fortran routine djb_str_hash return value")
      .def_readonly("in_str", &PyDjbStrHash::in_str)
      .def_readonly("hash_str", &PyDjbStrHash::hash_str)
      .def("__len__", [](const PyDjbStrHash&) { return 2; })
      .def("__getitem__", [](const PyDjbStrHash& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.in_str);
        if (i == 1)
          return py::cast(s.hash_str);
        return py::none();
      });
  m.def(
      "downcase_string",
      &python_downcase_string,
      py::arg("string"),
      R"""(No docstring available

Parameters
----------
string : 
)""");
  py::class_<PyDowncaseString, std::unique_ptr<PyDowncaseString>>(
      m, "DowncaseString", "Fortran routine downcase_string return value")
      .def_readonly("string", &PyDowncaseString::string)
      .def("__len__", [](const PyDowncaseString&) { return 1; })
      .def(
          "__getitem__", [](const PyDowncaseString& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.string);
            return py::none();
          });
  m.def(
      "err_exit",
      &python_err_exit,
      py::arg("err_str") = py::none(),
      R"""(No docstring available

Parameters
----------
err_str : 
)""");
  py::class_<PyErrExit, std::unique_ptr<PyErrExit>>(
      m, "ErrExit", "Fortran routine err_exit return value")
      .def_readonly("err_str", &PyErrExit::err_str)
      .def("__len__", [](const PyErrExit&) { return 1; })
      .def("__getitem__", [](const PyErrExit& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_str);
        return py::none();
      });
  m.def(
      "factorial",
      &python_factorial,
      py::arg("n"),
      py::arg("fact"),
      R"""(No docstring available

Parameters
----------
n : 
fact : 
)""");
  py::class_<PyFactorial, std::unique_ptr<PyFactorial>>(
      m, "Factorial", "Fortran routine factorial return value")
      .def_readonly("n", &PyFactorial::n)
      .def_readonly("fact", &PyFactorial::fact)
      .def("__len__", [](const PyFactorial&) { return 2; })
      .def("__getitem__", [](const PyFactorial& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n);
        if (i == 1)
          return py::cast(s.fact);
        return py::none();
      });
  m.def(
      "faddeeva_function",
      &SimUtils::faddeeva_function,
      py::arg("z"),
      py::arg("w"),
      py::arg("dw"),
      R"""(No docstring available

Parameters
----------
z : 
w : 
dw : 
)""");
  m.def(
      "fft_1d",
      &SimUtils::fft_1d,
      py::arg("arr"),
      py::arg("isign"),
      R"""(implicit none

character(*) line
logical error
end subroutine

Parameters
----------
arr : complex
    Input array.
    This parameter is an input/output and is modified in-place. As an output: FFT of array.
isign : int
    -1 => "Forward" transform, +1 => "Backwards" transform.
)""");
  m.def(
      "file_directorizer",
      &python_file_directorizer,
      py::arg("in_file"),
      py::arg("out_file"),
      py::arg("directory"),
      py::arg("add_switch"),
      R"""(No docstring available

Parameters
----------
in_file : 
out_file : 
directory : 
add_switch : 
)""");
  py::class_<PyFileDirectorizer, std::unique_ptr<PyFileDirectorizer>>(
      m, "FileDirectorizer", "Fortran routine file_directorizer return value")
      .def_readonly("in_file", &PyFileDirectorizer::in_file)
      .def_readonly("out_file", &PyFileDirectorizer::out_file)
      .def_readonly("directory", &PyFileDirectorizer::directory)
      .def_readonly("add_switch", &PyFileDirectorizer::add_switch)
      .def("__len__", [](const PyFileDirectorizer&) { return 4; })
      .def(
          "__getitem__",
          [](const PyFileDirectorizer& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.in_file);
            if (i == 1)
              return py::cast(s.out_file);
            if (i == 2)
              return py::cast(s.directory);
            if (i == 3)
              return py::cast(s.add_switch);
            return py::none();
          });
  m.def(
      "file_get",
      &python_file_get,
      py::arg("string"),
      py::arg("dflt_file_name"),
      py::arg("file_name"),
      R"""(No docstring available

Parameters
----------
string : 
dflt_file_name : 
file_name : 
)""");
  py::class_<PyFileGet, std::unique_ptr<PyFileGet>>(
      m, "FileGet", "Fortran routine file_get return value")
      .def_readonly("string", &PyFileGet::string)
      .def_readonly("dflt_file_name", &PyFileGet::dflt_file_name)
      .def_readonly("file_name", &PyFileGet::file_name)
      .def("__len__", [](const PyFileGet&) { return 3; })
      .def("__getitem__", [](const PyFileGet& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.dflt_file_name);
        if (i == 2)
          return py::cast(s.file_name);
        return py::none();
      });
  m.def(
      "file_get_open",
      &python_file_get_open,
      py::arg("string"),
      py::arg("dflt_file_name"),
      py::arg("file_name"),
      py::arg("file_unit"),
      py::arg("readonly"),
      R"""(No docstring available

Parameters
----------
string : 
dflt_file_name : 
file_name : 
file_unit : 
readonly : 
)""");
  py::class_<PyFileGetOpen, std::unique_ptr<PyFileGetOpen>>(
      m, "FileGetOpen", "Fortran routine file_get_open return value")
      .def_readonly("string", &PyFileGetOpen::string)
      .def_readonly("dflt_file_name", &PyFileGetOpen::dflt_file_name)
      .def_readonly("file_name", &PyFileGetOpen::file_name)
      .def_readonly("file_unit", &PyFileGetOpen::file_unit)
      .def_readonly("readonly", &PyFileGetOpen::readonly)
      .def("__len__", [](const PyFileGetOpen&) { return 5; })
      .def("__getitem__", [](const PyFileGetOpen& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.dflt_file_name);
        if (i == 2)
          return py::cast(s.file_name);
        if (i == 3)
          return py::cast(s.file_unit);
        if (i == 4)
          return py::cast(s.readonly);
        return py::none();
      });
  m.def(
      "file_suffixer",
      &python_file_suffixer,
      py::arg("in_file_name"),
      py::arg("out_file_name"),
      py::arg("suffix"),
      py::arg("add_switch"),
      R"""(No docstring available

Parameters
----------
in_file_name : 
out_file_name : 
suffix : 
add_switch : 
)""");
  py::class_<PyFileSuffixer, std::unique_ptr<PyFileSuffixer>>(
      m, "FileSuffixer", "Fortran routine file_suffixer return value")
      .def_readonly("in_file_name", &PyFileSuffixer::in_file_name)
      .def_readonly("out_file_name", &PyFileSuffixer::out_file_name)
      .def_readonly("suffix", &PyFileSuffixer::suffix)
      .def_readonly("add_switch", &PyFileSuffixer::add_switch)
      .def("__len__", [](const PyFileSuffixer&) { return 4; })
      .def("__getitem__", [](const PyFileSuffixer& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.in_file_name);
        if (i == 1)
          return py::cast(s.out_file_name);
        if (i == 2)
          return py::cast(s.suffix);
        if (i == 3)
          return py::cast(s.add_switch);
        return py::none();
      });
  m.def(
      "gen_complete_elliptic",
      &python_gen_complete_elliptic,
      py::arg("kc"),
      py::arg("p"),
      py::arg("c"),
      py::arg("s"),
      py::arg("err_tol") = py::none(),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
kc : 
p : 
c : 
s : 
err_tol : 
value : 
)""");
  py::class_<PyGenCompleteElliptic, std::unique_ptr<PyGenCompleteElliptic>>(
      m,
      "GenCompleteElliptic",
      "Fortran routine gen_complete_elliptic return value")
      .def_readonly("kc", &PyGenCompleteElliptic::kc)
      .def_readonly("p", &PyGenCompleteElliptic::p)
      .def_readonly("c", &PyGenCompleteElliptic::c)
      .def_readonly("s", &PyGenCompleteElliptic::s)
      .def_readonly("err_tol", &PyGenCompleteElliptic::err_tol)
      .def_readonly("value", &PyGenCompleteElliptic::value)
      .def("__len__", [](const PyGenCompleteElliptic&) { return 6; })
      .def(
          "__getitem__",
          [](const PyGenCompleteElliptic& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.kc);
            if (i == 1)
              return py::cast(s.p);
            if (i == 2)
              return py::cast(s.c);
            if (i == 3)
              return py::cast(s.s);
            if (i == 4)
              return py::cast(s.err_tol);
            if (i == 5)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "get_file_number",
      &python_get_file_number,
      py::arg("file_name"),
      py::arg("cnum_in"),
      py::arg("num_out"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
file_name : 
cnum_in : 
num_out : 
err_flag : 
)""");
  py::class_<PyGetFileNumber, std::unique_ptr<PyGetFileNumber>>(
      m, "GetFileNumber", "Fortran routine get_file_number return value")
      .def_readonly("file_name", &PyGetFileNumber::file_name)
      .def_readonly("cnum_in", &PyGetFileNumber::cnum_in)
      .def_readonly("num_out", &PyGetFileNumber::num_out)
      .def_readonly("err_flag", &PyGetFileNumber::err_flag)
      .def("__len__", [](const PyGetFileNumber&) { return 4; })
      .def("__getitem__", [](const PyGetFileNumber& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.file_name);
        if (i == 1)
          return py::cast(s.cnum_in);
        if (i == 2)
          return py::cast(s.num_out);
        if (i == 3)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "get_file_time_stamp",
      &python_get_file_time_stamp,
      py::arg("file"),
      py::arg("time_stamp"),
      R"""(implicit none

character(*) filein
character(*) cnum
integer digits
end subroutine

)""");
  py::class_<PyGetFileTimeStamp, std::unique_ptr<PyGetFileTimeStamp>>(
      m, "GetFileTimeStamp", "Fortran routine get_file_time_stamp return value")
      .def_readonly("file", &PyGetFileTimeStamp::file)
      .def_readonly("time_stamp", &PyGetFileTimeStamp::time_stamp)
      .def("__len__", [](const PyGetFileTimeStamp&) { return 2; })
      .def(
          "__getitem__",
          [](const PyGetFileTimeStamp& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.file);
            if (i == 1)
              return py::cast(s.time_stamp);
            return py::none();
          });
  m.def(
      "i_bessel",
      &python_i_bessel,
      py::arg("m"),
      py::arg("arg"),
      py::arg("i_bes"),
      R"""(No docstring available

Parameters
----------
m : 
arg : 
i_bes : 
)""");
  py::class_<PyIBessel, std::unique_ptr<PyIBessel>>(
      m, "IBessel", "Fortran routine i_bessel return value")
      .def_readonly("m", &PyIBessel::m)
      .def_readonly("arg", &PyIBessel::arg)
      .def_readonly("i_bes", &PyIBessel::i_bes)
      .def("__len__", [](const PyIBessel&) { return 3; })
      .def("__getitem__", [](const PyIBessel& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.m);
        if (i == 1)
          return py::cast(s.arg);
        if (i == 2)
          return py::cast(s.i_bes);
        return py::none();
      });
  m.def(
      "i_bessel_extended",
      &python_i_bessel_extended,
      py::arg("m"),
      py::arg("arg"),
      py::arg("i_bes"),
      R"""(No docstring available

Parameters
----------
m : 
arg : 
i_bes : 
)""");
  py::class_<PyIBesselExtended, std::unique_ptr<PyIBesselExtended>>(
      m, "IBesselExtended", "Fortran routine i_bessel_extended return value")
      .def_readonly("m", &PyIBesselExtended::m)
      .def_readonly("arg", &PyIBesselExtended::arg)
      .def_readonly("i_bes", &PyIBesselExtended::i_bes)
      .def("__len__", [](const PyIBesselExtended&) { return 3; })
      .def(
          "__getitem__",
          [](const PyIBesselExtended& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.m);
            if (i == 1)
              return py::cast(s.arg);
            if (i == 2)
              return py::cast(s.i_bes);
            return py::none();
          });
  m.def(
      "increment_file_number",
      &python_increment_file_number,
      py::arg("file_name"),
      py::arg("digits"),
      py::arg("number"),
      py::arg("cnumber"),
      R"""(No docstring available

Parameters
----------
file_name : 
digits : 
number : 
cnumber : 
)""");
  py::class_<PyIncrementFileNumber, std::unique_ptr<PyIncrementFileNumber>>(
      m,
      "IncrementFileNumber",
      "Fortran routine increment_file_number return value")
      .def_readonly("file_name", &PyIncrementFileNumber::file_name)
      .def_readonly("digits", &PyIncrementFileNumber::digits)
      .def_readonly("number", &PyIncrementFileNumber::number)
      .def_readonly("cnumber", &PyIncrementFileNumber::cnumber)
      .def("__len__", [](const PyIncrementFileNumber&) { return 4; })
      .def(
          "__getitem__",
          [](const PyIncrementFileNumber& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.file_name);
            if (i == 1)
              return py::cast(s.digits);
            if (i == 2)
              return py::cast(s.number);
            if (i == 3)
              return py::cast(s.cnumber);
            return py::none();
          });
  m.def(
      "index_nocase",
      &python_index_nocase,
      py::arg("string1"),
      py::arg("string2"),
      py::arg("indx"),
      R"""(No docstring available

Parameters
----------
string1 : 
string2 : 
indx : 
)""");
  py::class_<PyIndexNocase, std::unique_ptr<PyIndexNocase>>(
      m, "IndexNocase", "Fortran routine index_nocase return value")
      .def_readonly("string1", &PyIndexNocase::string1)
      .def_readonly("string2", &PyIndexNocase::string2)
      .def_readonly("indx", &PyIndexNocase::indx)
      .def("__len__", [](const PyIndexNocase&) { return 3; })
      .def("__getitem__", [](const PyIndexNocase& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string1);
        if (i == 1)
          return py::cast(s.string2);
        if (i == 2)
          return py::cast(s.indx);
        return py::none();
      });
  m.def(
      "int_str",
      &python_int_str,
      py::arg("int_"),
      py::arg("width") = py::none(),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
int : 
width : 
str : 
)""");
  py::class_<PyIntStr, std::unique_ptr<PyIntStr>>(
      m, "IntStr", "Fortran routine int_str return value")
      .def_readonly("int_", &PyIntStr::int_)
      .def_readonly("width", &PyIntStr::width)
      .def_readonly("str", &PyIntStr::str)
      .def("__len__", [](const PyIntStr&) { return 3; })
      .def("__getitem__", [](const PyIntStr& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.int_);
        if (i == 1)
          return py::cast(s.width);
        if (i == 2)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "is_alphabetic",
      &python_is_alphabetic,
      py::arg("string"),
      py::arg("valid_chars") = py::none(),
      py::arg("is_alpha"),
      R"""(import

implicit none
real(rp) prob
real(rp) val
end function


Returns
-------
prob
)""");
  py::class_<PyIsAlphabetic, std::unique_ptr<PyIsAlphabetic>>(
      m, "IsAlphabetic", "Fortran routine is_alphabetic return value")
      .def_readonly("string", &PyIsAlphabetic::string)
      .def_readonly("valid_chars", &PyIsAlphabetic::valid_chars)
      .def_readonly("is_alpha", &PyIsAlphabetic::is_alpha)
      .def("__len__", [](const PyIsAlphabetic&) { return 3; })
      .def("__getitem__", [](const PyIsAlphabetic& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.valid_chars);
        if (i == 2)
          return py::cast(s.is_alpha);
        return py::none();
      });
  m.def(
      "is_decreasing_sequence",
      &python_is_decreasing_sequence,
      py::arg("array"),
      py::arg("strict") = py::none(),
      py::arg("is_decreasing"),
      R"""(No docstring available

Parameters
----------
array : float
    Sequence.
strict : bool, optional
    If True (default) sequence must be strictly decreasing.
is_decreasing : 
)""");
  py::class_<PyIsDecreasingSequence, std::unique_ptr<PyIsDecreasingSequence>>(
      m,
      "IsDecreasingSequence",
      "Fortran routine is_decreasing_sequence return value")
      .def_readonly("is_decreasing", &PyIsDecreasingSequence::is_decreasing)
      .def("__len__", [](const PyIsDecreasingSequence&) { return 1; })
      .def(
          "__getitem__",
          [](const PyIsDecreasingSequence& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_decreasing);
            return py::none();
          });
  m.def(
      "is_increasing_sequence",
      &python_is_increasing_sequence,
      py::arg("array"),
      py::arg("strict") = py::none(),
      py::arg("is_increasing"),
      R"""(No docstring available

Parameters
----------
array : float
    Sequence.
strict : bool, optional
    If True (default) sequence must be strictly increasing.
is_increasing : 
)""");
  py::class_<PyIsIncreasingSequence, std::unique_ptr<PyIsIncreasingSequence>>(
      m,
      "IsIncreasingSequence",
      "Fortran routine is_increasing_sequence return value")
      .def_readonly("is_increasing", &PyIsIncreasingSequence::is_increasing)
      .def("__len__", [](const PyIsIncreasingSequence&) { return 1; })
      .def(
          "__getitem__",
          [](const PyIsIncreasingSequence& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_increasing);
            return py::none();
          });
  m.def(
      "is_integer",
      &python_is_integer,
      py::arg("string"),
      py::arg("int_") = py::none(),
      py::arg("delims") = py::none(),
      py::arg("ix_word") = py::none(),
      py::arg("valid"),
      R"""(No docstring available

Parameters
----------
string : 
int : 
delims : 
ix_word : 
valid : 
)""");
  py::class_<PyIsInteger, std::unique_ptr<PyIsInteger>>(
      m, "IsInteger", "Fortran routine is_integer return value")
      .def_readonly("string", &PyIsInteger::string)
      .def_readonly("int_", &PyIsInteger::int_)
      .def_readonly("delims", &PyIsInteger::delims)
      .def_readonly("ix_word", &PyIsInteger::ix_word)
      .def_readonly("valid", &PyIsInteger::valid)
      .def("__len__", [](const PyIsInteger&) { return 5; })
      .def("__getitem__", [](const PyIsInteger& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.int_);
        if (i == 2)
          return py::cast(s.delims);
        if (i == 3)
          return py::cast(s.ix_word);
        if (i == 4)
          return py::cast(s.valid);
        return py::none();
      });
  m.def(
      "is_logical",
      &python_is_logical,
      py::arg("string"),
      py::arg("ignore") = py::none(),
      py::arg("valid"),
      R"""(No docstring available

Parameters
----------
string : 
ignore : 
valid : 
)""");
  py::class_<PyIsLogical, std::unique_ptr<PyIsLogical>>(
      m, "IsLogical", "Fortran routine is_logical return value")
      .def_readonly("string", &PyIsLogical::string)
      .def_readonly("ignore", &PyIsLogical::ignore)
      .def_readonly("valid", &PyIsLogical::valid)
      .def("__len__", [](const PyIsLogical&) { return 3; })
      .def("__getitem__", [](const PyIsLogical& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.ignore);
        if (i == 2)
          return py::cast(s.valid);
        return py::none();
      });
  m.def(
      "is_real",
      &python_is_real,
      py::arg("string"),
      py::arg("ignore") = py::none(),
      py::arg("real_num") = py::none(),
      py::arg("valid"),
      R"""(No docstring available

Parameters
----------
string : 
ignore : 
real_num : 
valid : 
)""");
  py::class_<PyIsReal, std::unique_ptr<PyIsReal>>(
      m, "IsReal", "Fortran routine is_real return value")
      .def_readonly("string", &PyIsReal::string)
      .def_readonly("ignore", &PyIsReal::ignore)
      .def_readonly("real_num", &PyIsReal::real_num)
      .def_readonly("valid", &PyIsReal::valid)
      .def("__len__", [](const PyIsReal&) { return 4; })
      .def("__getitem__", [](const PyIsReal& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.ignore);
        if (i == 2)
          return py::cast(s.real_num);
        if (i == 3)
          return py::cast(s.valid);
        return py::none();
      });
  m.def(
      "j_bessel",
      &python_j_bessel,
      py::arg("m"),
      py::arg("arg"),
      py::arg("j_bes"),
      R"""(No docstring available

Parameters
----------
m : 
arg : 
j_bes : 
)""");
  py::class_<PyJBessel, std::unique_ptr<PyJBessel>>(
      m, "JBessel", "Fortran routine j_bessel return value")
      .def_readonly("m", &PyJBessel::m)
      .def_readonly("arg", &PyJBessel::arg)
      .def_readonly("j_bes", &PyJBessel::j_bes)
      .def("__len__", [](const PyJBessel&) { return 3; })
      .def("__getitem__", [](const PyJBessel& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.m);
        if (i == 1)
          return py::cast(s.arg);
        if (i == 2)
          return py::cast(s.j_bes);
        return py::none();
      });
  m.def(
      "linear_fit",
      &python_linear_fit,
      py::arg("x"),
      py::arg("y"),
      py::arg("n_data"),
      py::arg("a"),
      py::arg("b"),
      py::arg("sig_a"),
      py::arg("sig_b"),
      R"""(No docstring available

Parameters
----------
x : 
y : 
n_data : 
a : 
b : 
sig_a : 
sig_b : 
)""");
  py::class_<PyLinearFit, std::unique_ptr<PyLinearFit>>(
      m, "LinearFit", "Fortran routine linear_fit return value")
      .def_readonly("n_data", &PyLinearFit::n_data)
      .def_readonly("a", &PyLinearFit::a)
      .def_readonly("b", &PyLinearFit::b)
      .def_readonly("sig_a", &PyLinearFit::sig_a)
      .def_readonly("sig_b", &PyLinearFit::sig_b)
      .def("__len__", [](const PyLinearFit&) { return 5; })
      .def("__getitem__", [](const PyLinearFit& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n_data);
        if (i == 1)
          return py::cast(s.a);
        if (i == 2)
          return py::cast(s.b);
        if (i == 3)
          return py::cast(s.sig_a);
        if (i == 4)
          return py::cast(s.sig_b);
        return py::none();
      });
  m.def(
      "linear_fit_2d",
      &SimUtils::linear_fit_2d,
      py::arg("x"),
      py::arg("y"),
      py::arg("z"),
      R"""(No docstring available

Parameters
----------
x : float
    Array of x-values.
y : float
    Array of y-values.
z : float
    Array of z-values
coef : float
    Coefficients of the linear fit
)""");
  m.def(
      "logic_str",
      &python_logic_str,
      py::arg("logic"),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
logic : 
str : 
)""");
  py::class_<PyLogicStr, std::unique_ptr<PyLogicStr>>(
      m, "LogicStr", "Fortran routine logic_str return value")
      .def_readonly("logic", &PyLogicStr::logic)
      .def_readonly("str", &PyLogicStr::str)
      .def("__len__", [](const PyLogicStr&) { return 2; })
      .def("__getitem__", [](const PyLogicStr& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.logic);
        if (i == 1)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "lunget",
      &SimUtils::lunget,
      R"""(No docstring available

Parameters
----------
lunget : 
)""");
  m.def(
      "match_reg",
      &python_match_reg,
      py::arg("str"),
      py::arg("pat"),
      py::arg("is_match"),
      R"""(No docstring available

Parameters
----------
str : 
pat : 
is_match : 
)""");
  py::class_<PyMatchReg, std::unique_ptr<PyMatchReg>>(
      m, "MatchReg", "Fortran routine match_reg return value")
      .def_readonly("str", &PyMatchReg::str)
      .def_readonly("pat", &PyMatchReg::pat)
      .def_readonly("is_match", &PyMatchReg::is_match)
      .def("__len__", [](const PyMatchReg&) { return 3; })
      .def("__getitem__", [](const PyMatchReg& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        if (i == 1)
          return py::cast(s.pat);
        if (i == 2)
          return py::cast(s.is_match);
        return py::none();
      });
  m.def(
      "milli_sleep",
      &python_milli_sleep,
      py::arg("milli_sec"),
      R"""(No docstring available

Parameters
----------
milli_sec : 
)""");
  py::class_<PyMilliSleep, std::unique_ptr<PyMilliSleep>>(
      m, "MilliSleep", "Fortran routine milli_sleep return value")
      .def_readonly("milli_sec", &PyMilliSleep::milli_sec)
      .def("__len__", [](const PyMilliSleep&) { return 1; })
      .def("__getitem__", [](const PyMilliSleep& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.milli_sec);
        return py::none();
      });
  m.def(
      "make_legal_comment",
      &python_make_legal_comment,
      py::arg("comment_in"),
      py::arg("comment_out"),
      R"""(No docstring available

Parameters
----------
comment_in : 
comment_out : 
)""");
  py::class_<PyMakeLegalComment, std::unique_ptr<PyMakeLegalComment>>(
      m, "MakeLegalComment", "Fortran routine make_legal_comment return value")
      .def_readonly("comment_in", &PyMakeLegalComment::comment_in)
      .def_readonly("comment_out", &PyMakeLegalComment::comment_out)
      .def("__len__", [](const PyMakeLegalComment&) { return 2; })
      .def(
          "__getitem__",
          [](const PyMakeLegalComment& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.comment_in);
            if (i == 1)
              return py::cast(s.comment_out);
            return py::none();
          });
  m.def(
      "match_wild",
      &python_match_wild,
      py::arg("string"),
      py::arg("template_"),
      py::arg("is_match"),
      R"""(No docstring available

Parameters
----------
string : 
template : 
is_match : 
)""");
  py::class_<PyMatchWild, std::unique_ptr<PyMatchWild>>(
      m, "MatchWild", "Fortran routine match_wild return value")
      .def_readonly("string", &PyMatchWild::string)
      .def_readonly("template_", &PyMatchWild::template_)
      .def_readonly("is_match", &PyMatchWild::is_match)
      .def("__len__", [](const PyMatchWild&) { return 3; })
      .def("__getitem__", [](const PyMatchWild& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.template_);
        if (i == 2)
          return py::cast(s.is_match);
        return py::none();
      });
  m.def(
      "n_choose_k",
      &python_n_choose_k,
      py::arg("n"),
      py::arg("k"),
      py::arg("nck"),
      R"""(No docstring available

Parameters
----------
n : 
k : 
nck : 
)""");
  py::class_<PyNChooseK, std::unique_ptr<PyNChooseK>>(
      m, "NChooseK", "Fortran routine n_choose_k return value")
      .def_readonly("n", &PyNChooseK::n)
      .def_readonly("k", &PyNChooseK::k)
      .def_readonly("nck", &PyNChooseK::nck)
      .def("__len__", [](const PyNChooseK&) { return 3; })
      .def("__getitem__", [](const PyNChooseK& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n);
        if (i == 1)
          return py::cast(s.k);
        if (i == 2)
          return py::cast(s.nck);
        return py::none();
      });
  m.def(
      "n_spline_create",
      &SimUtils::n_spline_create,
      py::arg("deriv0"),
      py::arg("deriv1"),
      py::arg("x1"),
      R"""(No docstring available

Parameters
----------
deriv0 : float
    Derivative vector from order 0 to some order n at x = 0.
deriv1 : float
    Derivative vector from order 0 to some order n at x = x1.
x1 : float
    Location where deriv1 derivatives have been evaluated.
n_spline : 
    real(rp), Derivative vector from order 0 to order 2*n+1 of the interpolation spline.
)""");
  m.def(
      "nametable_add",
      &python_nametable_add,
      py::arg("nametable"),
      py::arg("name"),
      py::arg("ix_name"),
      R"""(No docstring available

Parameters
----------
nametable : 
name : 
ix_name : 
)""");
  py::class_<PyNametableAdd, std::unique_ptr<PyNametableAdd>>(
      m, "NametableAdd", "Fortran routine nametable_add return value")
      .def_readonly("name", &PyNametableAdd::name)
      .def_readonly("ix_name", &PyNametableAdd::ix_name)
      .def("__len__", [](const PyNametableAdd&) { return 2; })
      .def("__getitem__", [](const PyNametableAdd& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.name);
        if (i == 1)
          return py::cast(s.ix_name);
        return py::none();
      });
  m.def(
      "nametable_bracket_indexx",
      &python_nametable_bracket_indexx,
      py::arg("nametable"),
      py::arg("name"),
      py::arg("n_match") = py::none(),
      py::arg("ix_max"),
      R"""(No docstring available

Parameters
----------
nametable : 
name : 
n_match : 
ix_max : 
)""");
  py::class_<
      PyNametableBracketIndexx,
      std::unique_ptr<PyNametableBracketIndexx>>(
      m,
      "NametableBracketIndexx",
      "Fortran routine nametable_bracket_indexx return value")
      .def_readonly("name", &PyNametableBracketIndexx::name)
      .def_readonly("n_match", &PyNametableBracketIndexx::n_match)
      .def_readonly("ix_max", &PyNametableBracketIndexx::ix_max)
      .def("__len__", [](const PyNametableBracketIndexx&) { return 3; })
      .def(
          "__getitem__",
          [](const PyNametableBracketIndexx& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.name);
            if (i == 1)
              return py::cast(s.n_match);
            if (i == 2)
              return py::cast(s.ix_max);
            return py::none();
          });
  m.def(
      "nametable_change1",
      &python_nametable_change1,
      py::arg("nametable"),
      py::arg("name"),
      py::arg("ix_name"),
      R"""(No docstring available

Parameters
----------
nametable : 
name : 
ix_name : 
)""");
  py::class_<PyNametableChange1, std::unique_ptr<PyNametableChange1>>(
      m, "NametableChange1", "Fortran routine nametable_change1 return value")
      .def_readonly("name", &PyNametableChange1::name)
      .def_readonly("ix_name", &PyNametableChange1::ix_name)
      .def("__len__", [](const PyNametableChange1&) { return 2; })
      .def(
          "__getitem__",
          [](const PyNametableChange1& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.name);
            if (i == 1)
              return py::cast(s.ix_name);
            return py::none();
          });
  m.def(
      "nametable_init",
      &python_nametable_init,
      py::arg("nametable"),
      py::arg("n_min") = py::none(),
      py::arg("n_max") = py::none(),
      R"""(No docstring available

Parameters
----------
nametable : 
n_min : 
n_max : 
)""");
  py::class_<PyNametableInit, std::unique_ptr<PyNametableInit>>(
      m, "NametableInit", "Fortran routine nametable_init return value")
      .def_readonly("n_min", &PyNametableInit::n_min)
      .def_readonly("n_max", &PyNametableInit::n_max)
      .def("__len__", [](const PyNametableInit&) { return 2; })
      .def("__getitem__", [](const PyNametableInit& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n_min);
        if (i == 1)
          return py::cast(s.n_max);
        return py::none();
      });
  m.def(
      "nametable_remove",
      &python_nametable_remove,
      py::arg("nametable"),
      py::arg("ix_name"),
      R"""(No docstring available

Parameters
----------
nametable : 
ix_name : 
)""");
  py::class_<PyNametableRemove, std::unique_ptr<PyNametableRemove>>(
      m, "NametableRemove", "Fortran routine nametable_remove return value")
      .def_readonly("ix_name", &PyNametableRemove::ix_name)
      .def("__len__", [](const PyNametableRemove&) { return 1; })
      .def(
          "__getitem__",
          [](const PyNametableRemove& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_name);
            return py::none();
          });
  m.def(
      "ordinal_str",
      &python_ordinal_str,
      py::arg("n"),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
n : 
str : 
)""");
  py::class_<PyOrdinalStr, std::unique_ptr<PyOrdinalStr>>(
      m, "OrdinalStr", "Fortran routine ordinal_str return value")
      .def_readonly("n", &PyOrdinalStr::n)
      .def_readonly("str", &PyOrdinalStr::str)
      .def("__len__", [](const PyOrdinalStr&) { return 2; })
      .def("__getitem__", [](const PyOrdinalStr& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.n);
        if (i == 1)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "parse_fortran_format",
      &python_parse_fortran_format,
      py::arg("format_str"),
      py::arg("n_repeat"),
      py::arg("power"),
      py::arg("descrip"),
      py::arg("width"),
      py::arg("digits"),
      R"""(No docstring available

Parameters
----------
format_str : 
n_repeat : 
power : 
descrip : 
width : 
digits : 
)""");
  py::class_<PyParseFortranFormat, std::unique_ptr<PyParseFortranFormat>>(
      m,
      "ParseFortranFormat",
      "Fortran routine parse_fortran_format return value")
      .def_readonly("format_str", &PyParseFortranFormat::format_str)
      .def_readonly("n_repeat", &PyParseFortranFormat::n_repeat)
      .def_readonly("power", &PyParseFortranFormat::power)
      .def_readonly("descrip", &PyParseFortranFormat::descrip)
      .def_readonly("width", &PyParseFortranFormat::width)
      .def_readonly("digits", &PyParseFortranFormat::digits)
      .def("__len__", [](const PyParseFortranFormat&) { return 6; })
      .def(
          "__getitem__",
          [](const PyParseFortranFormat& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.format_str);
            if (i == 1)
              return py::cast(s.n_repeat);
            if (i == 2)
              return py::cast(s.power);
            if (i == 3)
              return py::cast(s.descrip);
            if (i == 4)
              return py::cast(s.width);
            if (i == 5)
              return py::cast(s.digits);
            return py::none();
          });
  m.def(
      "poly_eval",
      &python_poly_eval,
      py::arg("poly"),
      py::arg("x"),
      py::arg("diff_coef") = py::none(),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
poly : float
    Polynomial
x : float
    Point to evaluate at.
diff_coef : bool, optional
    poly(:) array are differentials? Default is False.
y : 
)""");
  py::class_<PyPolyEval, std::unique_ptr<PyPolyEval>>(
      m, "PolyEval", "Fortran routine poly_eval return value")
      .def_readonly("y", &PyPolyEval::y)
      .def("__len__", [](const PyPolyEval&) { return 1; })
      .def("__getitem__", [](const PyPolyEval& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "probability_funct",
      &python_probability_funct,
      py::arg("x"),
      py::arg("prob"),
      R"""(No docstring available

Parameters
----------
x : float
    Function argument.
prob : 
)""");
  py::class_<PyProbabilityFunct, std::unique_ptr<PyProbabilityFunct>>(
      m, "ProbabilityFunct", "Fortran routine probability_funct return value")
      .def_readonly("prob", &PyProbabilityFunct::prob)
      .def("__len__", [](const PyProbabilityFunct&) { return 1; })
      .def(
          "__getitem__",
          [](const PyProbabilityFunct& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.prob);
            return py::none();
          });
  m.def(
      "quadratic_roots",
      &SimUtils::quadratic_roots,
      py::arg("coefs"),
      py::arg("root"),
      R"""(No docstring available

Parameters
----------
coefs : float
    Coefficients of the quadratic equation with 0 = coefs(1) + coefs(2) * x + coefs(3) * x^2
root : 
)""");
  m.def(
      "query_string",
      &python_query_string,
      py::arg("query_str"),
      py::arg("upcase"),
      py::arg("return_str"),
      py::arg("ix"),
      py::arg("ios"),
      R"""(No docstring available

Parameters
----------
query_str : 
upcase : 
return_str : 
ix : 
ios : 
)""");
  py::class_<PyQueryString, std::unique_ptr<PyQueryString>>(
      m, "QueryString", "Fortran routine query_string return value")
      .def_readonly("query_str", &PyQueryString::query_str)
      .def_readonly("upcase", &PyQueryString::upcase)
      .def_readonly("return_str", &PyQueryString::return_str)
      .def_readonly("ix", &PyQueryString::ix)
      .def_readonly("ios", &PyQueryString::ios)
      .def("__len__", [](const PyQueryString&) { return 5; })
      .def("__getitem__", [](const PyQueryString& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.query_str);
        if (i == 1)
          return py::cast(s.upcase);
        if (i == 2)
          return py::cast(s.return_str);
        if (i == 3)
          return py::cast(s.ix);
        if (i == 4)
          return py::cast(s.ios);
        return py::none();
      });
  m.def(
      "quote",
      &python_quote,
      py::arg("str"),
      py::arg("q_str"),
      R"""(No docstring available

Parameters
----------
str : 
q_str : 
)""");
  py::class_<PyQuote, std::unique_ptr<PyQuote>>(
      m, "Quote", "Fortran routine quote return value")
      .def_readonly("str", &PyQuote::str)
      .def_readonly("q_str", &PyQuote::q_str)
      .def("__len__", [](const PyQuote&) { return 2; })
      .def("__getitem__", [](const PyQuote& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        if (i == 1)
          return py::cast(s.q_str);
        return py::none();
      });
  m.def(
      "real_to_string",
      &python_real_to_string,
      py::arg("real_num"),
      py::arg("width"),
      py::arg("n_signif") = py::none(),
      py::arg("n_decimal") = py::none(),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
real_num : 
width : 
n_signif : 
n_decimal : 
str : 
)""");
  py::class_<PyRealToString, std::unique_ptr<PyRealToString>>(
      m, "RealToString", "Fortran routine real_to_string return value")
      .def_readonly("real_num", &PyRealToString::real_num)
      .def_readonly("width", &PyRealToString::width)
      .def_readonly("n_signif", &PyRealToString::n_signif)
      .def_readonly("n_decimal", &PyRealToString::n_decimal)
      .def_readonly("str", &PyRealToString::str)
      .def("__len__", [](const PyRealToString&) { return 5; })
      .def("__getitem__", [](const PyRealToString& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.real_num);
        if (i == 1)
          return py::cast(s.width);
        if (i == 2)
          return py::cast(s.n_signif);
        if (i == 3)
          return py::cast(s.n_decimal);
        if (i == 4)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "real_num_fortran_format",
      &python_real_num_fortran_format,
      py::arg("number"),
      py::arg("width"),
      py::arg("n_blanks") = py::none(),
      py::arg("fmt_str"),
      R"""(No docstring available

Parameters
----------
number : 
width : 
n_blanks : 
fmt_str : 
)""");
  py::class_<PyRealNumFortranFormat, std::unique_ptr<PyRealNumFortranFormat>>(
      m,
      "RealNumFortranFormat",
      "Fortran routine real_num_fortran_format return value")
      .def_readonly("number", &PyRealNumFortranFormat::number)
      .def_readonly("width", &PyRealNumFortranFormat::width)
      .def_readonly("n_blanks", &PyRealNumFortranFormat::n_blanks)
      .def_readonly("fmt_str", &PyRealNumFortranFormat::fmt_str)
      .def("__len__", [](const PyRealNumFortranFormat&) { return 4; })
      .def(
          "__getitem__",
          [](const PyRealNumFortranFormat& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.number);
            if (i == 1)
              return py::cast(s.width);
            if (i == 2)
              return py::cast(s.n_blanks);
            if (i == 3)
              return py::cast(s.fmt_str);
            return py::none();
          });
  m.def(
      "str_count",
      &python_str_count,
      py::arg("str"),
      py::arg("match"),
      py::arg("num"),
      R"""(No docstring available

Parameters
----------
str : 
match : 
num : 
)""");
  py::class_<PyStrCount, std::unique_ptr<PyStrCount>>(
      m, "StrCount", "Fortran routine str_count return value")
      .def_readonly("str", &PyStrCount::str)
      .def_readonly("match", &PyStrCount::match)
      .def_readonly("num", &PyStrCount::num)
      .def("__len__", [](const PyStrCount&) { return 3; })
      .def("__getitem__", [](const PyStrCount& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        if (i == 1)
          return py::cast(s.match);
        if (i == 2)
          return py::cast(s.num);
        return py::none();
      });
  m.def(
      "real_path",
      &python_real_path,
      py::arg("path_in"),
      py::arg("path_out"),
      py::arg("is_ok"),
      R"""(No docstring available

Parameters
----------
path_in : 
path_out : 
is_ok : 
)""");
  py::class_<PyRealPath, std::unique_ptr<PyRealPath>>(
      m, "RealPath", "Fortran routine real_path return value")
      .def_readonly("path_in", &PyRealPath::path_in)
      .def_readonly("path_out", &PyRealPath::path_out)
      .def_readonly("is_ok", &PyRealPath::is_ok)
      .def("__len__", [](const PyRealPath&) { return 3; })
      .def("__getitem__", [](const PyRealPath& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.path_in);
        if (i == 1)
          return py::cast(s.path_out);
        if (i == 2)
          return py::cast(s.is_ok);
        return py::none();
      });
  m.def(
      "real_str",
      &python_real_str,
      py::arg("r_num"),
      py::arg("n_signif") = py::none(),
      py::arg("n_decimal") = py::none(),
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
r_num : 
n_signif : 
n_decimal : 
str : 
)""");
  py::class_<PyRealStr, std::unique_ptr<PyRealStr>>(
      m, "RealStr", "Fortran routine real_str return value")
      .def_readonly("r_num", &PyRealStr::r_num)
      .def_readonly("n_signif", &PyRealStr::n_signif)
      .def_readonly("n_decimal", &PyRealStr::n_decimal)
      .def_readonly("str", &PyRealStr::str)
      .def("__len__", [](const PyRealStr&) { return 4; })
      .def("__getitem__", [](const PyRealStr& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.r_num);
        if (i == 1)
          return py::cast(s.n_signif);
        if (i == 2)
          return py::cast(s.n_decimal);
        if (i == 3)
          return py::cast(s.str);
        return py::none();
      });
  m.def(
      "rms_value",
      &python_rms_value,
      py::arg("val_arr"),
      py::arg("good_val") = py::none(),
      py::arg("rms_val"),
      R"""(No docstring available

Parameters
----------
val_arr : float
    Array of reals.
good_val : bool, optional
    If present, only calculate RMS where good_val(i) = True.
ave_val : float
    average value.
rms_val : 
)""");
  py::class_<PyRmsValue, std::unique_ptr<PyRmsValue>>(
      m, "RmsValue", "Fortran routine rms_value return value")
      .def_readonly("ave_val", &PyRmsValue::ave_val)
      .def_readonly("rms_val", &PyRmsValue::rms_val)
      .def("__len__", [](const PyRmsValue&) { return 2; })
      .def("__getitem__", [](const PyRmsValue& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ave_val);
        if (i == 1)
          return py::cast(s.rms_val);
        return py::none();
      });
  m.def(
      "rot_2d",
      &SimUtils::rot_2d,
      py::arg("vec_in"),
      py::arg("angle"),
      py::arg("vec_out"),
      R"""(No docstring available

Parameters
----------
vec_in : float
    Init vec
angle : float
    angle in radians.
vec_out : 
)""");
  m.def(
      "run_timer",
      &python_run_timer,
      py::arg("command"),
      py::arg("time") = py::none(),
      py::arg("time0") = py::none(),
      R"""(No docstring available

Parameters
----------
command : 
time : 
time0 : 
)""");
  py::class_<PyRunTimer, std::unique_ptr<PyRunTimer>>(
      m, "RunTimer", "Fortran routine run_timer return value")
      .def_readonly("command", &PyRunTimer::command)
      .def_readonly("time", &PyRunTimer::time)
      .def_readonly("time0", &PyRunTimer::time0)
      .def("__len__", [](const PyRunTimer&) { return 3; })
      .def("__getitem__", [](const PyRunTimer& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.command);
        if (i == 1)
          return py::cast(s.time);
        if (i == 2)
          return py::cast(s.time0);
        return py::none();
      });
  m.def(
      "sinc",
      &python_sinc,
      py::arg("x"),
      py::arg("nd") = py::none(),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
x : 
nd : 
y : 
)""");
  py::class_<PySinc, std::unique_ptr<PySinc>>(
      m, "Sinc", "Fortran routine sinc return value")
      .def_readonly("y", &PySinc::y)
      .def("__len__", [](const PySinc&) { return 1; })
      .def("__getitem__", [](const PySinc& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "sincc",
      &python_sincc,
      py::arg("x"),
      py::arg("nd") = py::none(),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
x : 
nd : 
y : 
)""");
  py::class_<PySincc, std::unique_ptr<PySincc>>(
      m, "Sincc", "Fortran routine sincc return value")
      .def_readonly("y", &PySincc::y)
      .def("__len__", [](const PySincc&) { return 1; })
      .def("__getitem__", [](const PySincc& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "sinhx_x",
      &python_sinhx_x,
      py::arg("x"),
      py::arg("nd") = py::none(),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
x : 
nd : 
y : 
)""");
  py::class_<PySinhxX, std::unique_ptr<PySinhxX>>(
      m, "SinhxX", "Fortran routine sinhx_x return value")
      .def_readonly("y", &PySinhxX::y)
      .def("__len__", [](const PySinhxX&) { return 1; })
      .def("__getitem__", [](const PySinhxX& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "skip_header",
      &python_skip_header,
      py::arg("ix_unit"),
      py::arg("error_flag"),
      R"""(No docstring available

Parameters
----------
ix_unit : 
error_flag : 
)""");
  py::class_<PySkipHeader, std::unique_ptr<PySkipHeader>>(
      m, "SkipHeader", "Fortran routine skip_header return value")
      .def_readonly("ix_unit", &PySkipHeader::ix_unit)
      .def_readonly("error_flag", &PySkipHeader::error_flag)
      .def("__len__", [](const PySkipHeader&) { return 2; })
      .def("__getitem__", [](const PySkipHeader& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ix_unit);
        if (i == 1)
          return py::cast(s.error_flag);
        return py::none();
      });
  m.def(
      "sqrt_one",
      &python_sqrt_one,
      py::arg("x"),
      py::arg("nd") = py::none(),
      py::arg("ds1"),
      R"""(No docstring available

Parameters
----------
x : 
nd : 
ds1 : 
)""");
  py::class_<PySqrtOne, std::unique_ptr<PySqrtOne>>(
      m, "SqrtOne", "Fortran routine sqrt_one return value")
      .def_readonly("ds1", &PySqrtOne::ds1)
      .def("__len__", [](const PySqrtOne&) { return 1; })
      .def("__getitem__", [](const PySqrtOne& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ds1);
        return py::none();
      });
  m.def(
      "sqrt_alpha",
      &python_sqrt_alpha,
      py::arg("alpha"),
      py::arg("x"),
      py::arg("y"),
      R"""(No docstring available

Parameters
----------
alpha : 
x : 
y : 
)""");
  py::class_<PySqrtAlpha, std::unique_ptr<PySqrtAlpha>>(
      m, "SqrtAlpha", "Fortran routine sqrt_alpha return value")
      .def_readonly("y", &PySqrtAlpha::y)
      .def("__len__", [](const PySqrtAlpha&) { return 1; })
      .def("__getitem__", [](const PySqrtAlpha& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.y);
        return py::none();
      });
  m.def(
      "str_first_in_set",
      &python_str_first_in_set,
      py::arg("line"),
      py::arg("set"),
      py::arg("ignore_clauses") = py::none(),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
line : 
set : 
ignore_clauses : 
ix_match : 
)""");
  py::class_<PyStrFirstInSet, std::unique_ptr<PyStrFirstInSet>>(
      m, "StrFirstInSet", "Fortran routine str_first_in_set return value")
      .def_readonly("line", &PyStrFirstInSet::line)
      .def_readonly("set", &PyStrFirstInSet::set)
      .def_readonly("ignore_clauses", &PyStrFirstInSet::ignore_clauses)
      .def_readonly("ix_match", &PyStrFirstInSet::ix_match)
      .def("__len__", [](const PyStrFirstInSet&) { return 4; })
      .def("__getitem__", [](const PyStrFirstInSet& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        if (i == 1)
          return py::cast(s.set);
        if (i == 2)
          return py::cast(s.ignore_clauses);
        if (i == 3)
          return py::cast(s.ix_match);
        return py::none();
      });
  m.def(
      "str_first_not_in_set",
      &python_str_first_not_in_set,
      py::arg("line"),
      py::arg("set"),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
line : 
set : 
ix_match : 
)""");
  py::class_<PyStrFirstNotInSet, std::unique_ptr<PyStrFirstNotInSet>>(
      m,
      "StrFirstNotInSet",
      "Fortran routine str_first_not_in_set return value")
      .def_readonly("line", &PyStrFirstNotInSet::line)
      .def_readonly("set", &PyStrFirstNotInSet::set)
      .def_readonly("ix_match", &PyStrFirstNotInSet::ix_match)
      .def("__len__", [](const PyStrFirstNotInSet&) { return 3; })
      .def(
          "__getitem__",
          [](const PyStrFirstNotInSet& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.line);
            if (i == 1)
              return py::cast(s.set);
            if (i == 2)
              return py::cast(s.ix_match);
            return py::none();
          });
  m.def(
      "str_last_in_set",
      &python_str_last_in_set,
      py::arg("line"),
      py::arg("set"),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
line : 
set : 
ix_match : 
)""");
  py::class_<PyStrLastInSet, std::unique_ptr<PyStrLastInSet>>(
      m, "StrLastInSet", "Fortran routine str_last_in_set return value")
      .def_readonly("line", &PyStrLastInSet::line)
      .def_readonly("set", &PyStrLastInSet::set)
      .def_readonly("ix_match", &PyStrLastInSet::ix_match)
      .def("__len__", [](const PyStrLastInSet&) { return 3; })
      .def("__getitem__", [](const PyStrLastInSet& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        if (i == 1)
          return py::cast(s.set);
        if (i == 2)
          return py::cast(s.ix_match);
        return py::none();
      });
  m.def(
      "str_last_not_in_set",
      &python_str_last_not_in_set,
      py::arg("line"),
      py::arg("set"),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
line : 
set : 
ix_match : 
)""");
  py::class_<PyStrLastNotInSet, std::unique_ptr<PyStrLastNotInSet>>(
      m, "StrLastNotInSet", "Fortran routine str_last_not_in_set return value")
      .def_readonly("line", &PyStrLastNotInSet::line)
      .def_readonly("set", &PyStrLastNotInSet::set)
      .def_readonly("ix_match", &PyStrLastNotInSet::ix_match)
      .def("__len__", [](const PyStrLastNotInSet&) { return 3; })
      .def(
          "__getitem__",
          [](const PyStrLastNotInSet& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.line);
            if (i == 1)
              return py::cast(s.set);
            if (i == 2)
              return py::cast(s.ix_match);
            return py::none();
          });
  m.def(
      "string_to_int",
      &python_string_to_int,
      py::arg("line"),
      py::arg("default_"),
      py::arg("err_flag"),
      py::arg("err_print_flag") = py::none(),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
line : 
default : 
err_flag : 
err_print_flag : 
value : 
)""");
  py::class_<PyStringToInt, std::unique_ptr<PyStringToInt>>(
      m, "StringToInt", "Fortran routine string_to_int return value")
      .def_readonly("line", &PyStringToInt::line)
      .def_readonly("default_", &PyStringToInt::default_)
      .def_readonly("err_flag", &PyStringToInt::err_flag)
      .def_readonly("err_print_flag", &PyStringToInt::err_print_flag)
      .def_readonly("value", &PyStringToInt::value)
      .def("__len__", [](const PyStringToInt&) { return 5; })
      .def("__getitem__", [](const PyStringToInt& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        if (i == 1)
          return py::cast(s.default_);
        if (i == 2)
          return py::cast(s.err_flag);
        if (i == 3)
          return py::cast(s.err_print_flag);
        if (i == 4)
          return py::cast(s.value);
        return py::none();
      });
  m.def(
      "string_to_real",
      &python_string_to_real,
      py::arg("line"),
      py::arg("default_"),
      py::arg("err_flag"),
      py::arg("err_print_flag") = py::none(),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
line : 
default : 
err_flag : 
err_print_flag : 
value : 
)""");
  py::class_<PyStringToReal, std::unique_ptr<PyStringToReal>>(
      m, "StringToReal", "Fortran routine string_to_real return value")
      .def_readonly("line", &PyStringToReal::line)
      .def_readonly("default_", &PyStringToReal::default_)
      .def_readonly("err_flag", &PyStringToReal::err_flag)
      .def_readonly("err_print_flag", &PyStringToReal::err_print_flag)
      .def_readonly("value", &PyStringToReal::value)
      .def("__len__", [](const PyStringToReal&) { return 5; })
      .def("__getitem__", [](const PyStringToReal& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        if (i == 1)
          return py::cast(s.default_);
        if (i == 2)
          return py::cast(s.err_flag);
        if (i == 3)
          return py::cast(s.err_print_flag);
        if (i == 4)
          return py::cast(s.value);
        return py::none();
      });
  m.def(
      "string_trim2",
      &python_string_trim2,
      py::arg("in_str"),
      py::arg("delimitors"),
      py::arg("out_str"),
      py::arg("ix_word"),
      py::arg("delim"),
      py::arg("ix_next"),
      R"""(No docstring available

Parameters
----------
in_str : 
delimitors : 
out_str : 
ix_word : 
delim : 
ix_next : 
)""");
  py::class_<PyStringTrim2, std::unique_ptr<PyStringTrim2>>(
      m, "StringTrim2", "Fortran routine string_trim2 return value")
      .def_readonly("in_str", &PyStringTrim2::in_str)
      .def_readonly("delimitors", &PyStringTrim2::delimitors)
      .def_readonly("out_str", &PyStringTrim2::out_str)
      .def_readonly("ix_word", &PyStringTrim2::ix_word)
      .def_readonly("delim", &PyStringTrim2::delim)
      .def_readonly("ix_next", &PyStringTrim2::ix_next)
      .def("__len__", [](const PyStringTrim2&) { return 6; })
      .def("__getitem__", [](const PyStringTrim2& s, size_t i) -> py::object {
        if (i >= 6)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.in_str);
        if (i == 1)
          return py::cast(s.delimitors);
        if (i == 2)
          return py::cast(s.out_str);
        if (i == 3)
          return py::cast(s.ix_word);
        if (i == 4)
          return py::cast(s.delim);
        if (i == 5)
          return py::cast(s.ix_next);
        return py::none();
      });
  m.def(
      "to_str",
      &python_to_str,
      py::arg("num"),
      py::arg("max_signif") = py::none(),
      py::arg("string"),
      R"""(implicit none

logical tracker_locked(2)
end subroutine

)""");
  py::class_<PyToStr, std::unique_ptr<PyToStr>>(
      m, "ToStr", "Fortran routine to_str return value")
      .def_readonly("num", &PyToStr::num)
      .def_readonly("max_signif", &PyToStr::max_signif)
      .def_readonly("string", &PyToStr::string)
      .def("__len__", [](const PyToStr&) { return 3; })
      .def("__getitem__", [](const PyToStr& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.num);
        if (i == 1)
          return py::cast(s.max_signif);
        if (i == 2)
          return py::cast(s.string);
        return py::none();
      });
  m.def(
      "type_this_file",
      &python_type_this_file,
      py::arg("filename"),
      R"""(No docstring available

Parameters
----------
filename : 
)""");
  py::class_<PyTypeThisFile, std::unique_ptr<PyTypeThisFile>>(
      m, "TypeThisFile", "Fortran routine type_this_file return value")
      .def_readonly("filename", &PyTypeThisFile::filename)
      .def("__len__", [](const PyTypeThisFile&) { return 1; })
      .def("__getitem__", [](const PyTypeThisFile& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.filename);
        return py::none();
      });
  m.def(
      "upcase_string",
      &python_upcase_string,
      py::arg("string"),
      R"""(No docstring available

Parameters
----------
string : 
)""");
  py::class_<PyUpcaseString, std::unique_ptr<PyUpcaseString>>(
      m, "UpcaseString", "Fortran routine upcase_string return value")
      .def_readonly("string", &PyUpcaseString::string)
      .def("__len__", [](const PyUpcaseString&) { return 1; })
      .def("__getitem__", [](const PyUpcaseString& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        return py::none();
      });
  m.def(
      "word_len",
      &python_word_len,
      py::arg("wording"),
      py::arg("wlen"),
      R"""(No docstring available

Parameters
----------
wording : 
wlen : 
)""");
  py::class_<PyWordLen, std::unique_ptr<PyWordLen>>(
      m, "WordLen", "Fortran routine word_len return value")
      .def_readonly("wording", &PyWordLen::wording)
      .def_readonly("wlen", &PyWordLen::wlen)
      .def("__len__", [](const PyWordLen&) { return 2; })
      .def("__getitem__", [](const PyWordLen& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.wording);
        if (i == 1)
          return py::cast(s.wlen);
        return py::none();
      });
  m.def(
      "word_read",
      &python_word_read,
      py::arg("in_str"),
      py::arg("delim_list"),
      py::arg("word"),
      py::arg("ix_word"),
      py::arg("delim"),
      py::arg("delim_found"),
      py::arg("out_str"),
      py::arg("ignore_interior") = py::none(),
      R"""(No docstring available

Parameters
----------
in_str : 
delim_list : 
word : 
ix_word : 
delim : 
delim_found : 
out_str : 
ignore_interior : 
)""");
  py::class_<PyWordRead, std::unique_ptr<PyWordRead>>(
      m, "WordRead", "Fortran routine word_read return value")
      .def_readonly("in_str", &PyWordRead::in_str)
      .def_readonly("delim_list", &PyWordRead::delim_list)
      .def_readonly("word", &PyWordRead::word)
      .def_readonly("ix_word", &PyWordRead::ix_word)
      .def_readonly("delim", &PyWordRead::delim)
      .def_readonly("delim_found", &PyWordRead::delim_found)
      .def_readonly("out_str", &PyWordRead::out_str)
      .def_readonly("ignore_interior", &PyWordRead::ignore_interior)
      .def("__len__", [](const PyWordRead&) { return 8; })
      .def("__getitem__", [](const PyWordRead& s, size_t i) -> py::object {
        if (i >= 8)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.in_str);
        if (i == 1)
          return py::cast(s.delim_list);
        if (i == 2)
          return py::cast(s.word);
        if (i == 3)
          return py::cast(s.ix_word);
        if (i == 4)
          return py::cast(s.delim);
        if (i == 5)
          return py::cast(s.delim_found);
        if (i == 6)
          return py::cast(s.out_str);
        if (i == 7)
          return py::cast(s.ignore_interior);
        return py::none();
      });
  m.def(
      "str_substitute",
      &python_str_substitute,
      py::arg("string"),
      py::arg("str_match") = py::none(),
      py::arg("str_replace") = py::none(),
      py::arg("do_trim") = py::none(),
      py::arg("ignore_escaped") = py::none(),
      R"""(No docstring available

Parameters
----------
string : 
str_match : 
str_replace : 
do_trim : 
ignore_escaped : 
)""");
  py::class_<PyStrSubstitute, std::unique_ptr<PyStrSubstitute>>(
      m, "StrSubstitute", "Fortran routine str_substitute return value")
      .def_readonly("string", &PyStrSubstitute::string)
      .def_readonly("str_match", &PyStrSubstitute::str_match)
      .def_readonly("str_replace", &PyStrSubstitute::str_replace)
      .def_readonly("do_trim", &PyStrSubstitute::do_trim)
      .def_readonly("ignore_escaped", &PyStrSubstitute::ignore_escaped)
      .def("__len__", [](const PyStrSubstitute&) { return 5; })
      .def("__getitem__", [](const PyStrSubstitute& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.str_match);
        if (i == 2)
          return py::cast(s.str_replace);
        if (i == 3)
          return py::cast(s.do_trim);
        if (i == 4)
          return py::cast(s.ignore_escaped);
        return py::none();
      });
  m.def(
      "str_match_wild",
      &python_str_match_wild,
      py::arg("str"),
      py::arg("pat"),
      py::arg("a_match"),
      R"""(No docstring available

Parameters
----------
str : 
pat : 
a_match : 
)""");
  py::class_<PyStrMatchWild, std::unique_ptr<PyStrMatchWild>>(
      m, "StrMatchWild", "Fortran routine str_match_wild return value")
      .def_readonly("str", &PyStrMatchWild::str)
      .def_readonly("pat", &PyStrMatchWild::pat)
      .def_readonly("a_match", &PyStrMatchWild::a_match)
      .def("__len__", [](const PyStrMatchWild&) { return 3; })
      .def("__getitem__", [](const PyStrMatchWild& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        if (i == 1)
          return py::cast(s.pat);
        if (i == 2)
          return py::cast(s.a_match);
        return py::none();
      });
  m.def(
      "str_upcase",
      &SimUtils::str_upcase,
      py::arg("src"),
      R"""(No docstring available

Parameters
----------
dst : 
src : 
)""");
  m.def(
      "str_downcase",
      &SimUtils::str_downcase,
      py::arg("src"),
      R"""(No docstring available

Parameters
----------
dst : 
src : 
)""");
  m.def(
      "system_command",
      &python_system_command,
      py::arg("line"),
      py::arg("err_flag") = py::none(),
      R"""(No docstring available

Parameters
----------
line : 
err_flag : 
)""");
  py::class_<PySystemCommand, std::unique_ptr<PySystemCommand>>(
      m, "SystemCommand", "Fortran routine system_command return value")
      .def_readonly("line", &PySystemCommand::line)
      .def_readonly("err_flag", &PySystemCommand::err_flag)
      .def("__len__", [](const PySystemCommand&) { return 2; })
      .def("__getitem__", [](const PySystemCommand& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.line);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "string_trim",
      &python_string_trim,
      py::arg("in_string"),
      py::arg("out_string"),
      py::arg("word_len"),
      R"""(No docstring available

Parameters
----------
in_string : 
out_string : 
word_len : 
)""");
  py::class_<PyStringTrim, std::unique_ptr<PyStringTrim>>(
      m, "StringTrim", "Fortran routine string_trim return value")
      .def_readonly("in_string", &PyStringTrim::in_string)
      .def_readonly("out_string", &PyStringTrim::out_string)
      .def_readonly("word_len", &PyStringTrim::word_len)
      .def("__len__", [](const PyStringTrim&) { return 3; })
      .def("__getitem__", [](const PyStringTrim& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.in_string);
        if (i == 1)
          return py::cast(s.out_string);
        if (i == 2)
          return py::cast(s.word_len);
        return py::none();
      });
  m.def(
      "virtual_memory_usage",
      &SimUtils::virtual_memory_usage,
      R"""(No docstring available

Parameters
----------
usage : 
)""");
  m.def(
      "find_location",
      py::overload_cast<RealAlloc1D&, double, int>(&python_find_location_real),
      py::arg("arr"),
      py::arg("value"),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
arr : 
    real(rp), logical, or integer
value : unknown
    :).
ix_match : 
)""");
  py::class_<PyFindLocationReal, std::unique_ptr<PyFindLocationReal>>(
      m, "FindLocationReal", "Fortran routine find_location_real return value")
      .def_readonly("ix_match", &PyFindLocationReal::ix_match)
      .def("__len__", [](const PyFindLocationReal&) { return 1; })
      .def(
          "__getitem__",
          [](const PyFindLocationReal& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_match);
            return py::none();
          });
  m.def(
      "find_location",
      py::overload_cast<IntAlloc1D&, int, int>(&python_find_location_int),
      py::arg("arr"),
      py::arg("value"),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
arr : 
value : 
ix_match : 
)""");
  py::class_<PyFindLocationInt, std::unique_ptr<PyFindLocationInt>>(
      m, "FindLocationInt", "Fortran routine find_location_int return value")
      .def_readonly("value", &PyFindLocationInt::value)
      .def_readonly("ix_match", &PyFindLocationInt::ix_match)
      .def("__len__", [](const PyFindLocationInt&) { return 2; })
      .def(
          "__getitem__",
          [](const PyFindLocationInt& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.value);
            if (i == 1)
              return py::cast(s.ix_match);
            return py::none();
          });
  m.def(
      "find_location",
      py::overload_cast<BoolAlloc1D&, bool, int>(&python_find_location_logic),
      py::arg("arr"),
      py::arg("value"),
      py::arg("ix_match"),
      R"""(No docstring available

Parameters
----------
arr : 
value : 
ix_match : 
)""");
  py::class_<PyFindLocationLogic, std::unique_ptr<PyFindLocationLogic>>(
      m,
      "FindLocationLogic",
      "Fortran routine find_location_logic return value")
      .def_readonly("value", &PyFindLocationLogic::value)
      .def_readonly("ix_match", &PyFindLocationLogic::ix_match)
      .def("__len__", [](const PyFindLocationLogic&) { return 2; })
      .def(
          "__getitem__",
          [](const PyFindLocationLogic& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.value);
            if (i == 1)
              return py::cast(s.ix_match);
            return py::none();
          });
  m.def(
      "coarse_frequency_estimate",
      &python_coarse_frequency_estimate,
      py::arg("data"),
      py::arg("error") = py::none(),
      R"""(Simple function to take periodic data and estimate

the most dominant frequency by FFT.

Parameters
----------
data : float
    data to analyze. Preferably size(data) is a power of 2 Otherwise the data is padded with zeros.

Return value is a dictionary containing values below.


Returns
-------
frequency : float
    Frequency corresponding to the largest FFT amplitude
err : bool
    Error: not enough data. Frequency is near 0 or 0.5
)""");
  py::class_<
      PyCoarseFrequencyEstimate,
      std::unique_ptr<PyCoarseFrequencyEstimate>>(
      m,
      "CoarseFrequencyEstimate",
      "Fortran routine coarse_frequency_estimate return value")
      .def_readonly("frequency", &PyCoarseFrequencyEstimate::frequency)
      .def_readonly("error", &PyCoarseFrequencyEstimate::error)
      .def("__len__", [](const PyCoarseFrequencyEstimate&) { return 2; })
      .def(
          "__getitem__",
          [](const PyCoarseFrequencyEstimate& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.frequency);
            if (i == 1)
              return py::cast(s.error);
            return py::none();
          });
  m.def(
      "fine_frequency_estimate",
      &SimUtils::fine_frequency_estimate,
      py::arg("data"),
      R"""(Uses Laskar's method to accurately find the most dominant frequency

A coarse estimate is first made by FFT.

Parameters
----------
data : float
    data to analyze

Returns
-------
frequency : float
    Frequency corresponding to the largest FFT amplitude
)""");
  m.def(
      "fourier_amplitude",
      &SimUtils::fourier_amplitude,
      py::arg("data"),
      py::arg("frequency"),
      R"""(Computes cos_amp = (1/N) * sum_n=0^{N-1} data(n-1) cos(twopi*frequency*n)

and  sin_amp = (1/N) * sum_n=0^{N-1} data(n-1) sin(twopi*frequency*n)
and optionally dcos_amp = d/dfrequency cos_amp
dsin_amp = d/dfrequency sin_amp

Parameters
----------
data : float
    data to analyze
frequency : float
    frequency

Return value is a dictionary containing values below.


Returns
-------
cos_amp : float
    cosine amplitude
sin_amp : float
    sine amplitude
dcos_amp : float
    cosine amplitude derivative
dsin_amp : float
    sine amplitude derivative
)""");
  py::class_<
      SimUtils::FourierAmplitude,
      std::unique_ptr<SimUtils::FourierAmplitude>>(
      m, "FourierAmplitude", "Fortran routine fourier_amplitude return value")
      .def_readonly("cos_amp", &SimUtils::FourierAmplitude::cos_amp)
      .def_readonly("sin_amp", &SimUtils::FourierAmplitude::sin_amp)
      .def_readonly("dcos_amp", &SimUtils::FourierAmplitude::dcos_amp)
      .def_readonly("dsin_amp", &SimUtils::FourierAmplitude::dsin_amp)
      .def("__len__", [](const SimUtils::FourierAmplitude&) { return 4; })
      .def(
          "__getitem__",
          [](const SimUtils::FourierAmplitude& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.cos_amp);
            if (i == 1)
              return py::cast(s.sin_amp);
            if (i == 2)
              return py::cast(s.dcos_amp);
            if (i == 3)
              return py::cast(s.dsin_amp);
            return py::none();
          });
  m.def(
      "w_mat_to_axis_angle",
      &SimUtils::w_mat_to_axis_angle,
      py::arg("w_mat"),
      R"""(Routine to find the rotation axis and rotation angle corresponding to a given

3D rotation matrix.
The rotation angle is chosen in the range [0, pi].

Parameters
----------
w_mat : float
    Rotation matrix.

Return value is a dictionary containing values below.


Returns
-------
axis : float
    Rotation axis. Normalized to 1.
angle : float
    Rotation angle in the range [0, pi].
)""");
  py::class_<
      SimUtils::WMatToAxisAngle,
      std::unique_ptr<SimUtils::WMatToAxisAngle>>(
      m, "WMatToAxisAngle", "Fortran routine w_mat_to_axis_angle return value")
      .def_readonly("axis", &SimUtils::WMatToAxisAngle::axis)
      .def_readonly("angle", &SimUtils::WMatToAxisAngle::angle)
      .def("__len__", [](const SimUtils::WMatToAxisAngle&) { return 2; })
      .def(
          "__getitem__",
          [](const SimUtils::WMatToAxisAngle& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.axis);
            if (i == 1)
              return py::cast(s.angle);
            return py::none();
          });
  m.def(
      "w_mat_to_quat",
      &SimUtils::w_mat_to_quat,
      py::arg("w_mat"),
      R"""(Routine to find the quaternion corresponding to a given 3D rotation matrix.

Parameters
----------
w_mat : float
    Rotation matrix

Returns
-------
quat : float
    Quaternion.
)""");
  m.def(
      "quat_to_w_mat",
      &SimUtils::quat_to_w_mat,
      py::arg("quat"),
      R"""(Routine to construct the 3D rotation matrix w_mat given a rotation quaternion

Parameters
----------
quat : float
    Quaternion.

Returns
-------
w_mat : float
    Rotation matrix
)""");
  m.def(
      "axis_angle_to_w_mat",
      &SimUtils::axis_angle_to_w_mat,
      py::arg("axis"),
      py::arg("angle"),
      R"""(Routine to construct the 3D rotation matrix w_mat given an axis of rotation

and a rotation angle.

Parameters
----------
axis : float
    Rotation axis. Does not have to be normalized.
angle : float
    Rotation angle in the range [-pi, pi].

Returns
-------
w_mat : float
    Rotation matrix
)""");
  m.def(
      "quat_to_omega",
      &SimUtils::quat_to_omega,
      py::arg("quat"),
      R"""(Routine to convert rotation from quaternion representation to omega (axis + angle).

Parameters
----------
quat : float
    Rotation quaternion. Assumed normalized.

Returns
-------
omega : float
    Axis of rotation + magnitude = rotation angle.
)""");
  m.def(
      "omega_to_quat",
      &SimUtils::omega_to_quat,
      py::arg("omega"),
      R"""(Routine to convert from omega + angle representation to a quaternion.

Parameters
----------
omega : float
    Axis of rotation + magnitude = rotation angle.

Returns
-------
quat : float
    Rotation quaternion.
)""");
  m.def(
      "quat_to_axis_angle",
      &SimUtils::quat_to_axis_angle,
      py::arg("quat"),
      R"""(Routine to convert from quaternion to axis + angle representation.

The angle will be in the range 0 <= angle <= pi.

Parameters
----------
quat : float
    Rotation quaternion. Assumed normalized.

Return value is a dictionary containing values below.


Returns
-------
axis : float
    Axis of rotation.
angle : float
    angle of rotation in range [0, pi].
)""");
  py::class_<
      SimUtils::QuatToAxisAngle,
      std::unique_ptr<SimUtils::QuatToAxisAngle>>(
      m, "QuatToAxisAngle", "Fortran routine quat_to_axis_angle return value")
      .def_readonly("axis", &SimUtils::QuatToAxisAngle::axis)
      .def_readonly("angle", &SimUtils::QuatToAxisAngle::angle)
      .def("__len__", [](const SimUtils::QuatToAxisAngle&) { return 2; })
      .def(
          "__getitem__",
          [](const SimUtils::QuatToAxisAngle& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.axis);
            if (i == 1)
              return py::cast(s.angle);
            return py::none();
          });
  m.def(
      "axis_angle_to_quat",
      &SimUtils::axis_angle_to_quat,
      py::arg("axis"),
      py::arg("angle"),
      R"""(Routine to convert from axis + angle representation to a quaternion.

Parameters
----------
axis : float
    Axis of rotation.
angle : float
    angle of rotation.

Returns
-------
quat : float
    Rotation quaternion.
)""");
  m.def(
      "quat_conj_real",
      &SimUtils::quat_conj_real,
      py::arg("q_in"),
      R"""(Routine to create the conjugate of a quaternian.

Overloaded by quat_conj.

Parameters
----------
q_in : float
    Quaternion input.

Returns
-------
q_out : float
    Conjugate quaternion.
)""");
  m.def(
      "quat_conj_complex",
      &SimUtils::quat_conj_complex,
      py::arg("q_in"),
      R"""(Routine to create the conjugate of a quaternian.

Overloaded by quat_conj.

Parameters
----------
q_in : float
    Quaternion input.

Returns
-------
q_out : float
    Conjugate quaternion.
)""");
  m.def(
      "quat_inverse",
      &SimUtils::quat_inverse,
      py::arg("q_in"),
      R"""(Routine to create the inverse of a quaternian.

Parameters
----------
q_in : float
    Quaternion input.

Returns
-------
q_out : float
    Inverse quaternion.
)""");
  m.def(
      "quat_mul_real",
      &SimUtils::quat_mul_real,
      py::arg("q1"),
      py::arg("q2"),
      py::arg("q3") = py::none(),
      py::arg("q4") = py::none(),
      py::arg("q5") = py::none(),
      py::arg("q6") = py::none(),
      py::arg("q7") = py::none(),
      py::arg("q8") = py::none(),
      py::arg("q9") = py::none(),
      R"""(Routine to multiply quaternions q_out = q1 * q2 * q3 * q4 * ...

Overloaded by quat_mul.

Parameters
----------
q1 : float
    Quaternions.
q3 : float, optional
    More quaternions.

Returns
-------
q_out : float
    Resultant q1 * q2
)""");
  m.def(
      "quat_mul_complex",
      &SimUtils::quat_mul_complex,
      py::arg("q1"),
      py::arg("q2"),
      py::arg("q3") = py::none(),
      py::arg("q4") = py::none(),
      py::arg("q5") = py::none(),
      py::arg("q6") = py::none(),
      py::arg("q7") = py::none(),
      py::arg("q8") = py::none(),
      py::arg("q9") = py::none(),
      R"""(Routine to multiply quaternions q_out = q1 * q2 * q3 * q4 * ...

Overloaded by quat_mul.

Parameters
----------
q1 : complex
    Quaternions.
q3 : complex, optional
    More quaternions.

Returns
-------
q_out : complex
    Resultant q1 * q2
)""");
  m.def(
      "quat_rotate_real",
      &SimUtils::quat_rotate_real,
      py::arg("quat"),
      py::arg("vec_in"),
      R"""(Routine to rotate a vector using a quaternion..

Parameters
----------
quat : float
    Quaternion to rotate with. Does not have to be normalized.
vec_in : float
    Initial vector.

Returns
-------
vec_out : float
    Final vector.
)""");
  m.def(
      "quat_rotate_complex",
      &SimUtils::quat_rotate_complex,
      py::arg("quat"),
      py::arg("vec_in"),
      R"""(Routine to rotate a vector using a quaternion..

Parameters
----------
quat : complex
    Quaternion to rotate with. Does not have to be normalized.
vec_in : complex
    Initial vector.

Returns
-------
vec_out : complex
    Final vector.
)""");
  m.def(
      "rotate_vec_given_axis_angle",
      &SimUtils::rotate_vec_given_axis_angle,
      py::arg("vec_in"),
      py::arg("axis"),
      py::arg("angle"),
      R"""(Routine to rotate a vector.

Parameters
----------
vec_in : float
    Initial vector.
axis : float
    Axis of rotation. Must be normalized to 1.
angle : float
    Angle to rotate by

Returns
-------
vec_out : float
    Final vector.
)""");
  m.def(
      "rotate_vec",
      &SimUtils::rotate_vec,
      py::arg("vec"),
      py::arg("axis"),
      py::arg("angle"),
      R"""(Basic routine to rotate vector components around the x, y, or z axis.

Parameters
----------
vec : float
    vector
    This parameter is an input/output and is modified in-place. As an output: Rotated vector.
axis : int
    x_axis$, y_axis$, or z_axis$
angle : float
    angle to rotate.
)""");
  m.def(
      "naff",
      &python_naff,
      py::arg("cdata"),
      py::arg("freqs"),
      py::arg("amps"),
      py::arg("opt_dump_spectra") = py::none(),
      py::arg("opt_zero_first") = py::none(),
      R"""(This subroutine implements the NAFF algorithm for calculating the spectra

of periodic data.
See naff_mod documentation for details.
Frequencies returned are in units of 2pi. That is, freqs ranges from 0 to 1.
freqs and amps must be allocated before hand.  This subroutine will repeat the
decomposition loop until all elements of freqs and amps are populated.

)""");
  py::class_<PyNaff, std::unique_ptr<PyNaff>>(
      m, "Naff", "Fortran routine naff return value")
      .def_readonly("opt_dump_spectra", &PyNaff::opt_dump_spectra)
      .def_readonly("opt_zero_first", &PyNaff::opt_zero_first)
      .def("__len__", [](const PyNaff&) { return 2; })
      .def("__getitem__", [](const PyNaff& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.opt_dump_spectra);
        if (i == 1)
          return py::cast(s.opt_zero_first);
        return py::none();
      });
  m.def(
      "projdd",
      &python_projdd,
      py::arg("a"),
      py::arg("b"),
      py::arg("func_retval__"),
      R"""(No docstring available

Parameters
----------
a : 
b : 
projdd : 
)""");
  py::class_<PyProjdd, std::unique_ptr<PyProjdd>>(
      m, "Projdd", "Fortran routine projdd return value")
      .def_readonly("func_retval__", &PyProjdd::func_retval__)
      .def("__len__", [](const PyProjdd&) { return 1; })
      .def("__getitem__", [](const PyProjdd& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.func_retval__);
        return py::none();
      });
  m.def(
      "maximize_projection",
      &python_maximize_projection,
      py::arg("seed"),
      py::arg("cdata"),
      py::arg("func_retval__"),
      R"""(Optimizer that uses Numerical Recipes brent to find a local maximum,

which is the frequency that maximizes the projection.

)""");
  py::class_<PyMaximizeProjection, std::unique_ptr<PyMaximizeProjection>>(
      m,
      "MaximizeProjection",
      "Fortran routine maximize_projection return value")
      .def_readonly("seed", &PyMaximizeProjection::seed)
      .def_readonly("func_retval__", &PyMaximizeProjection::func_retval__)
      .def("__len__", [](const PyMaximizeProjection&) { return 2; })
      .def(
          "__getitem__",
          [](const PyMaximizeProjection& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.seed);
            if (i == 1)
              return py::cast(s.func_retval__);
            return py::none();
          });
  m.def(
      "interpolated_fft_gsl",
      &python_interpolated_fft_gsl,
      py::arg("cdata"),
      py::arg("calc_ok"),
      py::arg("opt_dump_spectrum") = py::none(),
      py::arg("opt_dump_index") = py::none(),
      py::arg("this_fft"),
      R"""(Windows the complex data and uses a mixed-radix GSL routine to find the peak in the spectrum.

The result is interpolated to improve the accuracy.  Hanning and Gaussian windowing are
available.

)""");
  py::class_<PyInterpolatedFftGsl, std::unique_ptr<PyInterpolatedFftGsl>>(
      m,
      "InterpolatedFftGsl",
      "Fortran routine interpolated_fft_gsl return value")
      .def_readonly("calc_ok", &PyInterpolatedFftGsl::calc_ok)
      .def_readonly(
          "opt_dump_spectrum", &PyInterpolatedFftGsl::opt_dump_spectrum)
      .def_readonly("opt_dump_index", &PyInterpolatedFftGsl::opt_dump_index)
      .def_readonly("this_fft", &PyInterpolatedFftGsl::this_fft)
      .def("__len__", [](const PyInterpolatedFftGsl&) { return 4; })
      .def(
          "__getitem__",
          [](const PyInterpolatedFftGsl& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.calc_ok);
            if (i == 1)
              return py::cast(s.opt_dump_spectrum);
            if (i == 2)
              return py::cast(s.opt_dump_index);
            if (i == 3)
              return py::cast(s.this_fft);
            return py::none();
          });
  m.def(
      "interpolated_fft",
      &python_interpolated_fft,
      py::arg("cdata"),
      py::arg("calc_ok"),
      py::arg("opt_dump_spectrum") = py::none(),
      py::arg("opt_dump_index") = py::none(),
      py::arg("this_fft"),
      R"""(Windows the complex data and used Numerical Recipes four1 to find the peak in the spectrum.

The result is interpolated to improve the accuracy.  Hanning and Gaussian windowing are
available.


Returns
-------
this_fft
)""");
  py::class_<PyInterpolatedFft, std::unique_ptr<PyInterpolatedFft>>(
      m, "InterpolatedFft", "Fortran routine interpolated_fft return value")
      .def_readonly("calc_ok", &PyInterpolatedFft::calc_ok)
      .def_readonly("opt_dump_spectrum", &PyInterpolatedFft::opt_dump_spectrum)
      .def_readonly("opt_dump_index", &PyInterpolatedFft::opt_dump_index)
      .def_readonly("this_fft", &PyInterpolatedFft::this_fft)
      .def("__len__", [](const PyInterpolatedFft&) { return 4; })
      .def(
          "__getitem__",
          [](const PyInterpolatedFft& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.calc_ok);
            if (i == 1)
              return py::cast(s.opt_dump_spectrum);
            if (i == 2)
              return py::cast(s.opt_dump_index);
            if (i == 3)
              return py::cast(s.this_fft);
            return py::none();
          });
  m.def(
      "initfixedwindowls",
      &SimUtils::initfixedwindowls,
      py::arg("N"),
      py::arg("dt"),
      py::arg("order"),
      py::arg("der"),
      R"""(Initializes an instance of the fixed window least squares module.

See module documentation (getf windowLS_mod) for use details.
Any instance of windowLS created with this module should be destroyed with destFixedWindowLS.

Parameters
----------
N : int
    Number of data points to fit over. aka window size.
dt : float
    Time interval between data points. It is assumed that the data is separated by fixed time intervals.
order : int
    Order of fit polynomial.  Must be greater than or equal to der.
der : int
    Order of derivative to be returned. Set der=0 to obtain the fit. <return value>  -- INTEGER: id of
    windowLS instance created.
)""");
  m.def(
      "destfixedwindowls",
      &SimUtils::destfixedwindowls,
      py::arg("id"),
      R"""(No docstring available

Parameters
----------
id : 
)""");
  m.def(
      "fixedwindowls",
      &python_fixedwindowls,
      py::arg("ynew"),
      py::arg("id"),
      py::arg("z"),
      R"""(Main function of the windowLS modult.  Each call to this function adds a data point to the fit

and returns the derivative evaluated at the end of the window.  It is assumed that all data points
are separeted by the same interval.
This module is initialized with zeros for all data points, and so the results are unreliable until
a number of data points equal to N has been entered.
initFixedWindowLS must be called prior to calling this function.  destFixedWindowLS should be
called when the instance is no longer needed.

)""");
  py::class_<PyFixedwindowls, std::unique_ptr<PyFixedwindowls>>(
      m, "Fixedwindowls", "Fortran routine fixedwindowls return value")
      .def_readonly("z", &PyFixedwindowls::z)
      .def("__len__", [](const PyFixedwindowls&) { return 1; })
      .def("__getitem__", [](const PyFixedwindowls& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.z);
        return py::none();
      });
  m.def(
      "super_bicubic_interpolation",
      &SimUtils::super_bicubic_interpolation,
      py::arg("y"),
      py::arg("y1"),
      py::arg("y2"),
      py::arg("y12"),
      py::arg("x1l"),
      py::arg("x1u"),
      py::arg("x2l"),
      py::arg("x2u"),
      py::arg("x1"),
      py::arg("x2"),
      R"""(Routine to do bicubic interpolation.

This is from NR bcuint.
Note! The four grid points are arrayed in counter-clockwise order beginning from the lower left.
So, for example, y = [y_ll, y_lu, y_uu, y_ul] where "l" = lower, "u" = upper index.

Parameters
----------
y : float
    Function values at grid points.
y1 : float
    dy/dx1 derivatives.
y2 : float
    dy/dx2 derivatives.
y12 : float
    d2y/dx1*dx2 second derivatives.
x1l : float
    1-direction coordinate at lower points.
x1u : float
    1-direction coordinate at upper points
x2l : float
    2-direction coordinate at lower points.
x2u : float
    2-direction coordinate at upper points
x1 : float
    1-direction coordinate at point to evaluate.
x2 : float
    2-direction coordinate at point to evaluate.

Return value is a dictionary containing values below.


Returns
-------
ansy : float
    Interpolation value.
ansy1 : float
    1-direction derivative at interpolation point.
ansy2 : float
    2-direction derivative at interpolation point.
)""");
  py::class_<
      SimUtils::SuperBicubicInterpolation,
      std::unique_ptr<SimUtils::SuperBicubicInterpolation>>(
      m,
      "SuperBicubicInterpolation",
      "Fortran routine super_bicubic_interpolation return value")
      .def_readonly("ansy", &SimUtils::SuperBicubicInterpolation::ansy)
      .def_readonly("ansy1", &SimUtils::SuperBicubicInterpolation::ansy1)
      .def_readonly("ansy2", &SimUtils::SuperBicubicInterpolation::ansy2)
      .def(
          "__len__",
          [](const SimUtils::SuperBicubicInterpolation&) { return 3; })
      .def(
          "__getitem__",
          [](const SimUtils::SuperBicubicInterpolation& s,
             size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ansy);
            if (i == 1)
              return py::cast(s.ansy1);
            if (i == 2)
              return py::cast(s.ansy2);
            return py::none();
          });
  m.def(
      "super_bicubic_coef",
      &SimUtils::super_bicubic_coef,
      py::arg("y"),
      py::arg("y1"),
      py::arg("y2"),
      py::arg("y12"),
      py::arg("d1"),
      py::arg("d2"),
      R"""(Routine to compute coefficients for bicubic interpolation.

This is from NR bcucof.

Parameters
----------
y : float
    Function values at grid points.
y1 : float
    dy/dx1 derivatives.
y2 : float
    dy/dx2 derivatives.
y12 : float
    d2y/dx1*dx2 second derivatives.
d1 : float
    Grid width in 1-direction.
d2 : float
    Grid width in 2-direction.

Returns
-------
c : float
    Coefficients.
)""");
  m.def(
      "super_sort",
      &SimUtils::super_sort,
      py::arg("arr"),
      R"""(Routine to sort an integer array in place.

This is the NR routine sort modified to sort integers.

Parameters
----------
arr : int
    Array of integers.
    This parameter is an input/output and is modified in-place. As an output: Sorted array.
)""");
  m.def(
      "super_polint",
      &SimUtils::super_polint,
      py::arg("xa"),
      py::arg("ya"),
      py::arg("x"),
      R"""(This is essentially polint from Numerical Recipes.

Parameters
----------
xa : float
x : float

Return value is a dictionary containing values below.


Returns
-------
y : float
dy : float
)""");
  py::class_<SimUtils::SuperPolint, std::unique_ptr<SimUtils::SuperPolint>>(
      m, "SuperPolint", "Fortran routine super_polint return value")
      .def_readonly("y", &SimUtils::SuperPolint::y)
      .def_readonly("dy", &SimUtils::SuperPolint::dy)
      .def("__len__", [](const SimUtils::SuperPolint&) { return 2; })
      .def(
          "__getitem__",
          [](const SimUtils::SuperPolint& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.y);
            if (i == 1)
              return py::cast(s.dy);
            return py::none();
          });
  m.def(
      "super_poly",
      &SimUtils::super_poly,
      py::arg("x"),
      py::arg("coeffs"),
      R"""(Routine to compute Sum: coef(i)*x^i

Parameters
----------
x : float
    Variable.
coef : float
    Coefficients.

Returns
-------
value : float
    Polynomial value.
)""");
  m.def(
      "ran_seed_put",
      &SimUtils::ran_seed_put,
      py::arg("seed"),
      py::arg("mpi_offset") = py::none(),
      R"""(Routine to seed a random number generator.

If a program never calls ran_seed_put, or ran_seed_put is called with seed = 0,
the system clock will be used to generate the seed.

Parameters
----------
seed : int
    Seed number. If seed = 0 then a seed will be choosen based upon the system clock.
mpi_offset : int, optional
    Offset added to seed. Default is zero. Used with MPI processes ensure different threads use different
    random numbers.

Notes
-----
Note: The seed is only used with the pseudo_random$ engine.
Note: Use the subroutine ran_seed_get(seed) to get the seed used.
)""");
  m.def(
      "ran_seed_get",
      &SimUtils::ran_seed_get,
      R"""(Routine to return the seed used for the random number generator.

Parameters
----------
ran_state : RandomStateStruct, optional
    Internal state. See the ran_seed_put documentation for more details.

Returns
-------
seed : int
    Random number seed used.
)""");
  m.def(
      "allocate_thread_states",
      &SimUtils::allocate_thread_states,
      R"""(Routine to allocate random number state structures when openMP is used.

)""");
  m.def(
      "bicubic_cmplx_eval",
      &SimUtils::bicubic_cmplx_eval,
      py::arg("x_norm"),
      py::arg("y_norm"),
      py::arg("bi_coef"),
      R"""(Routine to evaluate a bicubic interpolating complex function.

Use the routine bicubic_interpolation_cmplx_coefs to generate bi_coef.

Parameters
----------
x_norm : float
    x_norm = (x - x0) / dx
y_norm : float
    y_norm = (y - y0) / dy
bi_coef : BicubicCmplxCoefStruct
    Coefficients.

Return value is a dictionary containing values below.


Returns
-------
f_val : complex
    Value of f.
df_dx : complex
    Normalized first derivative: True df/dx = df_dx * dx
df_dy : complex
    Normalized first derivative: True df/dy = df_dy * dy
)""");
  py::class_<
      SimUtils::BicubicCmplxEval,
      std::unique_ptr<SimUtils::BicubicCmplxEval>>(
      m, "BicubicCmplxEval", "Fortran routine bicubic_cmplx_eval return value")
      .def_readonly("df_dx", &SimUtils::BicubicCmplxEval::df_dx)
      .def_readonly("df_dy", &SimUtils::BicubicCmplxEval::df_dy)
      .def_readonly("f_val", &SimUtils::BicubicCmplxEval::f_val)
      .def("__len__", [](const SimUtils::BicubicCmplxEval&) { return 3; })
      .def(
          "__getitem__",
          [](const SimUtils::BicubicCmplxEval& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.df_dx);
            if (i == 1)
              return py::cast(s.df_dy);
            if (i == 2)
              return py::cast(s.f_val);
            return py::none();
          });
  m.def(
      "tricubic_cmplx_eval",
      &SimUtils::tricubic_cmplx_eval,
      py::arg("x_norm"),
      py::arg("y_norm"),
      py::arg("z_norm"),
      py::arg("tri_coef"),
      R"""(Routine to evaluate a tricubic interpolating complex function.

Use the routine tricubic_interpolation_cmplx_coefs to generate tri_coef.

Parameters
----------
x_norm : float
    x_norm = (x - x0) / dx
y_norm : float
    y_norm = (y - y0) / dy
z_norm : float
    z_norm = (z - z0) / dz
tri_coef : TricubicCmplxCoefStruct
    Coefficients.

Return value is a dictionary containing values below.


Returns
-------
f_val : complex
    Value of f.
df_dx : complex
    Normalized first derivative: True df/dx = df_dx * dx
df_dy : complex
    Normalized first derivative: True df/dy = df_dy * dy
df_dz : complex
    Normalized first derivative: True df/dz = df_dz * dz
)""");
  py::class_<
      SimUtils::TricubicCmplxEval,
      std::unique_ptr<SimUtils::TricubicCmplxEval>>(
      m,
      "TricubicCmplxEval",
      "Fortran routine tricubic_cmplx_eval return value")
      .def_readonly("df_dx", &SimUtils::TricubicCmplxEval::df_dx)
      .def_readonly("df_dy", &SimUtils::TricubicCmplxEval::df_dy)
      .def_readonly("df_dz", &SimUtils::TricubicCmplxEval::df_dz)
      .def_readonly("f_val", &SimUtils::TricubicCmplxEval::f_val)
      .def("__len__", [](const SimUtils::TricubicCmplxEval&) { return 4; })
      .def(
          "__getitem__",
          [](const SimUtils::TricubicCmplxEval& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.df_dx);
            if (i == 1)
              return py::cast(s.df_dy);
            if (i == 2)
              return py::cast(s.df_dz);
            if (i == 3)
              return py::cast(s.f_val);
            return py::none();
          });
  m.def(
      "bin_index",
      &SimUtils::bin_index,
      py::arg("x"),
      py::arg("bin1_x_min"),
      py::arg("bin_delta"),
      R"""(Helper function to locate the appropriate histogram bin index.

Parameters
----------
x : float
    Input value to bin.
bin1_x_min : float
    Minimum value of bin with index 1.
bin_delta : float
    Bin width.

Returns
-------
ix_bin : int
    Index of bin x is in.
)""");
  m.def(
      "bin_x_center",
      &python_bin_x_center,
      py::arg("ix_bin"),
      py::arg("bin1_x_min"),
      py::arg("bin_delta"),
      R"""(Helper function to locate the center of a histogram bin.

Parameters
----------
ix_bin : int
    Index of bin under question.
bin1_x_min : float
    Minimum value of bin with index 1.
bin_delta : float
    Bin width.

Returns
-------
x_center
)""");
  py::class_<PyBinXCenter, std::unique_ptr<PyBinXCenter>>(
      m, "BinXCenter", "Fortran routine bin_x_center return value")
      .def_readonly("x_center", &PyBinXCenter::x_center)
      .def_readonly("ix_bin", &PyBinXCenter::ix_bin)
      .def("__len__", [](const PyBinXCenter&) { return 2; })
      .def("__getitem__", [](const PyBinXCenter& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.x_center);
        if (i == 1)
          return py::cast(s.ix_bin);
        return py::none();
      });
  m.def(
      "n_bins_automatic",
      &python_n_bins_automatic,
      py::arg("n_data"),
      py::arg("n"),
      R"""()""");
  py::class_<PyNBinsAutomatic, std::unique_ptr<PyNBinsAutomatic>>(
      m, "NBinsAutomatic", "Fortran routine n_bins_automatic return value")
      .def_readonly("n_data", &PyNBinsAutomatic::n_data)
      .def_readonly("n", &PyNBinsAutomatic::n)
      .def("__len__", [](const PyNBinsAutomatic&) { return 2; })
      .def(
          "__getitem__", [](const PyNBinsAutomatic& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.n_data);
            if (i == 1)
              return py::cast(s.n);
            return py::none();
          });
  m.def(
      "reallocate_spline",
      &SimUtils::reallocate_spline,
      py::arg("spline"),
      py::arg("n"),
      py::arg("n_min") = py::none(),
      py::arg("exact") = py::none(),
      R"""(Subroutine to allocate an allocatable spline_struct array.

The data of the array is preserved but data at the end of the
array will be lost if n is less than the original size of the array

Parameters
----------
spline : SplineStruct
    Spline to reallocate.
    This parameter is an input/output and is modified in-place. As an output: Allocated spline.
n : int
    Upper bound needed for 1-dimensional arrays.
n_min : int, optional
    Lower bound of spline array. Default is 1.
exact : bool, optional
    If present and False then the size of the output array is permitted to be larger than n. Default is True.
)""");
  m.def(
      "create_a_spline",
      &SimUtils::create_a_spline,
      py::arg("r0"),
      py::arg("r1"),
      py::arg("slope0"),
      py::arg("slope1"),
      R"""(Routine to create a single spline given end point positions and slopes.

The spline will pass through the data points and have the given slopes
at these points.
Modules used:
use spline_mod

Parameters
----------
r0 : float
    Start (x, y) point.
r1 : float
    End (x, y) point.
slope0 : float
    Starting slope.
slope1 : float
    End slope.

Returns
-------
spline : SplineStruct
    Spline.
)""");
  m.def(
      "spline_akima_interpolate",
      &SimUtils::spline_akima_interpolate,
      py::arg("x_knot"),
      py::arg("y_knot"),
      py::arg("x"),
      R"""(Routine to interpolate using an akima spline.

When evaluating at enough points, this routine is slower than calling spline_akima to
first evaluate the spline coefficients and then repeatedly calling spline_evaluate.
The advantage of this routine is that only the (x, y) knot points need to be stored
and it will be faster if the number of evaluations is small.
This routine will extrapolate past the range of x_knot(:) up to a distance equal to the
length between an end point and the point just inside the end point.

Parameters
----------
x_knot : float
    Array of x values for the knot points. Must have more than 2 points and be in asending order.
y_knot : float
    Array of y values for the knot points. Must be same size as x_knot(:).
x : float
    Point to evaluate at.

Return value is a dictionary containing values below.


Returns
-------
ok : bool
    Set .true. if everything ok, That is, x is within the spline range.
y : float
    Spline interpolation.
dy : float
    Spline derivative interpolation.
)""");
  py::class_<
      SimUtils::SplineAkimaInterpolate,
      std::unique_ptr<SimUtils::SplineAkimaInterpolate>>(
      m,
      "SplineAkimaInterpolate",
      "Fortran routine spline_akima_interpolate return value")
      .def_readonly("ok", &SimUtils::SplineAkimaInterpolate::ok)
      .def_readonly("y", &SimUtils::SplineAkimaInterpolate::y)
      .def_readonly("dy", &SimUtils::SplineAkimaInterpolate::dy)
      .def("__len__", [](const SimUtils::SplineAkimaInterpolate&) { return 3; })
      .def(
          "__getitem__",
          [](const SimUtils::SplineAkimaInterpolate& s,
             size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ok);
            if (i == 1)
              return py::cast(s.y);
            if (i == 2)
              return py::cast(s.dy);
            return py::none();
          });
  m.def(
      "spline_evaluate",
      &SimUtils::spline_evaluate,
      py::arg("spline"),
      py::arg("x"),
      R"""(Subroutine to evalueate a spline at a set of points.

A point outside of the range of knot points is an error.

Parameters
----------
spline : SplineStruct
    Spline structure.
x : float
    point for evaluation.

Return value is a dictionary containing values below.


Returns
-------
ok : bool
    Set .true. if everything ok. That is, x is within the spline range.
y : float
    Spline interpolation.
dy : float
    Spline derivative interpolation.

Notes
-----
Related routines:
spline1 spline_akima_interpolate A spline may be generated using for example the spline_akima routine. use
spline_mod
)""");
  py::class_<
      SimUtils::SplineEvaluate,
      std::unique_ptr<SimUtils::SplineEvaluate>>(
      m, "SplineEvaluate", "Fortran routine spline_evaluate return value")
      .def_readonly("ok", &SimUtils::SplineEvaluate::ok)
      .def_readonly("y", &SimUtils::SplineEvaluate::y)
      .def_readonly("dy", &SimUtils::SplineEvaluate::dy)
      .def("__len__", [](const SimUtils::SplineEvaluate&) { return 3; })
      .def(
          "__getitem__",
          [](const SimUtils::SplineEvaluate& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ok);
            if (i == 1)
              return py::cast(s.y);
            if (i == 2)
              return py::cast(s.dy);
            return py::none();
          });
  m.def(
      "bracket_index_for_spline",
      &SimUtils::bracket_index_for_spline,
      py::arg("x_knot"),
      py::arg("x"),
      py::arg("strict") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(Routine to find which interval to use for evaluating a spline.

If strict = False (default), x is in range if
x_knot(1) - (x_knot(2) - x_knot(1)) < x < x_knot(n) + (x_knot(n) - x_knot(n-1))
If stric = True, x is in range if
x_knot(1) <= x <= x_knot(n)
where n = size(x_knot)

Parameters
----------
x_knot : float
    Array of x values.
x : float
    Evaluation point.
strict : bool, optional
    Default is False. Determines acceptible range.
print_err : bool, optional
    Default is True. Print error message if out of range?

Return value is a dictionary containing values below.


Returns
-------
ix0 : int
    If ok = True, x is in the interval [x_knot(ix0), x_knot(ix0+1)]
ok : bool
    True if x is in range. False otherwise.
)""");
  py::class_<
      SimUtils::BracketIndexForSpline,
      std::unique_ptr<SimUtils::BracketIndexForSpline>>(
      m,
      "BracketIndexForSpline",
      "Fortran routine bracket_index_for_spline return value")
      .def_readonly("ix0", &SimUtils::BracketIndexForSpline::ix0)
      .def_readonly("ok", &SimUtils::BracketIndexForSpline::ok)
      .def("__len__", [](const SimUtils::BracketIndexForSpline&) { return 2; })
      .def(
          "__getitem__",
          [](const SimUtils::BracketIndexForSpline& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix0);
            if (i == 1)
              return py::cast(s.ok);
            return py::none();
          });
  m.def(
      "spline1",
      &SimUtils::spline1,
      py::arg("a_spline"),
      py::arg("x"),
      py::arg("n") = py::none(),
      R"""(Function for spline evaluation using a single spline (instead of a spline array).

Parameters
----------
a_spline : SplineStruct
    Single spline structure.
x : float
    Point for evaluation.
n : int, optional
    Output derivative order. May be -1, 0, 1, 2, or 3. Default is 0. n = -1 => output is integral of y from
    a_spline.x0 to x. n = 1 => output is dy/dx, n = 2 => output is d^2y/dx^2, etc.

Returns
-------
y : float
    Interpolated spline value or derivative.

Notes
-----
Related routines:
spline_evaluate spline_akima_interpolate use spline_mod
)""");
  m.def(
      "spline_akima",
      &SimUtils::spline_akima,
      py::arg("spline"),
      R"""(Given a set of (x,y) points we want to interpolate between the points.

This subroutine computes the semi-hermite cubic spline developed by
Hiroshi Akima. The spline goes thorugh all the points (that is, it is
not a smoothing spline). For interpolation use:
spline_evaluate
spline_akima_interpolate ! You do not need to call spline_akima if you use this routine.
Reference:
H Akima, "A New Method of Interpolation and Smooth Curve Fitting Based
on Local Procedures", J. Assoc. Comp. Mach., Vol 17(4), 589-602 (1970).
Modules used:
use spline_mod

Parameters
----------
spline : SplineStruct
    .x0  -- X-component of a point. Note: points must be in assending order. .y0  -- Y-component of a point.

Returns
-------
ok : bool
    Set .false. if something is wrong (like less than 2 points used).
)""");
  m.def(
      "end_akima_spline_calc",
      &SimUtils::end_akima_spline_calc,
      py::arg("spline"),
      py::arg("which_end"),
      R"""(Routine to calculate the slopes at the ends of a spline array

Parameters
----------
spline : SplineStruct
    Array of splines.
    This parameter is an input/output and is modified in-place. As an output: Array with slopes at end
    calculated.
which_end : int
    0 => calculate slopes for the start end of the array. 1 => calculate slopes for the end end of the array.
)""");
  m.def(
      "apfft_corr",
      &SimUtils::apfft_corr,
      py::arg("rdata_in"),
      py::arg("bounds") = py::none(),
      py::arg("window"),
      py::arg("diag") = py::none(),
      R"""(For real signal rdata_in, computes phase, frequency, and amplitude

of peak found within bounds.  Algorithm is corrected all-phase FFT and should.
This routine finds only one peak:  the largest amplitude within the bound.  Signals with multiple
components can be investigated by varying bounds appropriately.

Parameters
----------
rdata_in : float
    signal data.
bounds : float
    range within which to search for peak.
window : unknown
    'rec' or 'han' for rectangular or Hann window.
diag : int, optional
    causes low-level routine apfft_ext to produce a fort.X file where X=9000+fid containing diag information.

Return value is a dictionary containing values below.


Returns
-------
phase : float
    phase of peak found in signal.
freq : float
    frequency of peak
amp : float
    amplitude of peak
)""");
  py::class_<SimUtils::ApfftCorr, std::unique_ptr<SimUtils::ApfftCorr>>(
      m, "ApfftCorr", "Fortran routine apfft_corr return value")
      .def_readonly("phase", &SimUtils::ApfftCorr::phase)
      .def_readonly("amp", &SimUtils::ApfftCorr::amp)
      .def_readonly("freq", &SimUtils::ApfftCorr::freq)
      .def("__len__", [](const SimUtils::ApfftCorr&) { return 3; })
      .def(
          "__getitem__",
          [](const SimUtils::ApfftCorr& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.phase);
            if (i == 1)
              return py::cast(s.amp);
            if (i == 2)
              return py::cast(s.freq);
            return py::none();
          });
  m.def(
      "apfft",
      &python_apfft,
      py::arg("rdata_in"),
      py::arg("bounds"),
      py::arg("window"),
      py::arg("phase"),
      py::arg("diag") = py::none(),
      R"""(Implements the All Phase FFT method for obtaining accurate phase from signal data.

The signal data is truncated to an odd length, and the phase is relative to the central point.

)""");
  py::class_<PyApfft, std::unique_ptr<PyApfft>>(
      m, "Apfft", "Fortran routine apfft return value")
      .def_readonly("window", &PyApfft::window)
      .def_readonly("phase", &PyApfft::phase)
      .def_readonly("diag", &PyApfft::diag)
      .def("__len__", [](const PyApfft&) { return 3; })
      .def("__getitem__", [](const PyApfft& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.window);
        if (i == 1)
          return py::cast(s.phase);
        if (i == 2)
          return py::cast(s.diag);
        return py::none();
      });
  m.def(
      "apfft_ext",
      &python_apfft_ext,
      py::arg("rdata"),
      py::arg("bounds"),
      py::arg("window"),
      py::arg("phase"),
      py::arg("amp"),
      py::arg("freq"),
      py::arg("diag") = py::none(),
      R"""(Implements the All Phase FFT method for obtaining accurate phase from signal data.

This "extended" apfft subroutine returns the amplitudes and frequency as well, for use
by the corrected apfft subroutine in this module.

)""");
  py::class_<PyApfftExt, std::unique_ptr<PyApfftExt>>(
      m, "ApfftExt", "Fortran routine apfft_ext return value")
      .def_readonly("window", &PyApfftExt::window)
      .def_readonly("phase", &PyApfftExt::phase)
      .def_readonly("amp", &PyApfftExt::amp)
      .def_readonly("freq", &PyApfftExt::freq)
      .def_readonly("diag", &PyApfftExt::diag)
      .def("__len__", [](const PyApfftExt&) { return 5; })
      .def("__getitem__", [](const PyApfftExt& s, size_t i) -> py::object {
        if (i >= 5)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.window);
        if (i == 1)
          return py::cast(s.phase);
        if (i == 2)
          return py::cast(s.amp);
        if (i == 3)
          return py::cast(s.freq);
        if (i == 4)
          return py::cast(s.diag);
        return py::none();
      });
  m.def(
      "hanhan",
      &python_hanhan,
      py::arg("N"),
      py::arg("hh"),
      R"""(No docstring available

Parameters
----------
N : 
hh : 
)""");
  py::class_<PyHanhan, std::unique_ptr<PyHanhan>>(
      m, "Hanhan", "Fortran routine hanhan return value")
      .def_readonly("N", &PyHanhan::N)
      .def("__len__", [](const PyHanhan&) { return 1; })
      .def("__getitem__", [](const PyHanhan& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.N);
        return py::none();
      });
  m.def(
      "bit_set",
      &python_bit_set,
      py::arg("word"),
      py::arg("pos"),
      py::arg("set_to_1"),
      R"""(Routine to set a bit in a word.

Parameters
----------
word : int
    Input word
    This parameter is an input/output and is modified in-place. As an output: Word with bit set.
pos : int
    position to set.
set_to_1 : bool
    If True then bit is set to 1. If False bit is set to 0.
)""");
  py::class_<PyBitSet, std::unique_ptr<PyBitSet>>(
      m, "BitSet", "Fortran routine bit_set return value")
      .def_readonly("word", &PyBitSet::word)
      .def("__len__", [](const PyBitSet&) { return 1; })
      .def("__getitem__", [](const PyBitSet& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.word);
        return py::none();
      });
  m.def(
      "tao_deallocate_plot_cache",
      &Tao::tao_deallocate_plot_cache,
      py::arg("plot_cache"),
      R"""(No docstring available

Parameters
----------
plot_cache : 
)""");
  m.def(
      "tao_lattice_branches_equal_tao_lattice_branches",
      &Tao::tao_lattice_branches_equal_tao_lattice_branches,
      py::arg("tlb1"),
      py::arg("tlb2"),
      R"""(No docstring available

Parameters
----------
tlb1 : 
tlb2 : 
)""");
  m.def(
      "tao_lattice_equal_tao_lattice",
      &Tao::tao_lattice_equal_tao_lattice,
      py::arg("lat1"),
      py::arg("lat2"),
      R"""(No docstring available

Parameters
----------
lat1 : 
lat2 : 
)""");
  m.def(
      "tao_turn_on_special_calcs_if_needed_for_plotting",
      &Tao::tao_turn_on_special_calcs_if_needed_for_plotting,
      R"""(No docstring available

)""");
  m.def(
      "tao_pointer_to_tao_lat",
      &Tao::tao_pointer_to_tao_lat,
      py::arg("u"),
      py::arg("lat_type") = py::none(),
      py::arg("tao_lat"),
      R"""(No docstring available

Parameters
----------
u : TaoUniverseStruct
    Universe to work with
lat_type : int, optional
    model$ (default), design$, or base$.
tao_lat : 
)""");
  m.def(
      "tao_de_optimizer",
      &Tao::tao_de_optimizer,
      R"""(No docstring available

Parameters
----------
abort : bool
    Set True if an user stop signal detected.
)""");
  m.def(
      "tao_geodesic_lm_optimizer",
      &Tao::tao_geodesic_lm_optimizer,
      R"""(Routine to minimize the merit function by varying variables until

the "data" as calculated from the model matches the measured data.
This subroutine is a wrapper for the "geodesic"
Levenburg - Marquardt method.


Returns
-------
abort : bool
    Set True if an user stop signal detected.
)""");
  m.def(
      "tao_branch_index",
      &python_tao_branch_index,
      py::arg("ix_branch"),
      py::arg("ix_this"),
      R"""(No docstring available

Parameters
----------
ix_branch : int
    Nominal branch number.
ix_this : 
)""");
  py::class_<PyTaoBranchIndex, std::unique_ptr<PyTaoBranchIndex>>(
      m, "TaoBranchIndex", "Fortran routine tao_branch_index return value")
      .def_readonly("ix_this", &PyTaoBranchIndex::ix_this)
      .def("__len__", [](const PyTaoBranchIndex&) { return 1; })
      .def(
          "__getitem__", [](const PyTaoBranchIndex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_this);
            return py::none();
          });
  m.def(
      "tao_limit_calc",
      &Tao::tao_limit_calc,
      R"""(No docstring available

Parameters
----------
limited : bool
    Set True if a variable is past a limit.
)""");
  m.def(
      "tao_alias_cmd",
      &Tao::tao_alias_cmd,
      py::arg("alias"),
      py::arg("string"),
      R"""(No docstring available

Parameters
----------
alias : 
    Name of the tao command file.
string : 
    Command file arguments.
)""");
  m.def(
      "tao_top_level",
      &Tao::tao_top_level,
      py::arg("command") = py::none(),
      R"""(No docstring available

Parameters
----------
command : unknown, optional
    Tao command string. If present, getting user input from the terminal is bypassed. This is used when
    interfacing to Python.
errcode : int
    Return error code: 0 => OK, Not 0 => Err.
)""");
  m.def(
      "tao_universe_index",
      &python_tao_universe_index,
      py::arg("i_uni"),
      py::arg("neg2_to_default") = py::none(),
      py::arg("i_this_uni"),
      R"""(No docstring available

Parameters
----------
i_uni : int
    Nominal universe number.
neg2_to_default : bool, optional
    i_uni = -2 (all universes) maps to the default uni? Default if False.
i_this_uni : 
)""");
  py::class_<PyTaoUniverseIndex, std::unique_ptr<PyTaoUniverseIndex>>(
      m, "TaoUniverseIndex", "Fortran routine tao_universe_index return value")
      .def_readonly("i_this_uni", &PyTaoUniverseIndex::i_this_uni)
      .def("__len__", [](const PyTaoUniverseIndex&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoUniverseIndex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.i_this_uni);
            return py::none();
          });
  m.def(
      "tao_to_real",
      &Tao::tao_to_real,
      py::arg("expression"),
      R"""(No docstring available

Parameters
----------
expression : unknown
    arithmetic expression
value : float
    Value of arithmetic expression.
err_flag : bool
    TRUE on error.
)""");
  py::class_<Tao::TaoToReal, std::unique_ptr<Tao::TaoToReal>>(
      m, "TaoToReal", "Fortran routine tao_to_real return value")
      .def_readonly("value", &Tao::TaoToReal::value)
      .def_readonly("err_flag", &Tao::TaoToReal::err_flag)
      .def("__len__", [](const Tao::TaoToReal&) { return 2; })
      .def("__getitem__", [](const Tao::TaoToReal& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.value);
        if (i == 1)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "tao_split_component",
      &Tao::tao_split_component,
      py::arg("comp_str"),
      R"""(No docstring available

Parameters
----------
comp_str : unknown
    Components. EG: 'meas - design'
comp : TaoDataVarComponentStruct
    Array of individual components.
err : bool
    Set True if there is an error, False otherwise.
)""");
  py::class_<Tao::TaoSplitComponent, std::unique_ptr<Tao::TaoSplitComponent>>(
      m,
      "TaoSplitComponent",
      "Fortran routine tao_split_component return value")
      .def_readonly("comp", &Tao::TaoSplitComponent::comp)
      .def_readonly("err", &Tao::TaoSplitComponent::err)
      .def("__len__", [](const Tao::TaoSplitComponent&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoSplitComponent& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.comp);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "tao_floor_to_screen_coords",
      &Tao::tao_floor_to_screen_coords,
      py::arg("graph"),
      py::arg("floor"),
      R"""(No docstring available

Parameters
----------
graph : TaoGraphStruct
    Graph defining the projection plane.
floor : FloorPositionStruct
    3D coordinate.
screen : FloorPositionStruct
    Projected point .r(3)   -- projected (x, y) = (.r(1), .r(2)) .theta  -- angle in (x, y) plane of
    projection of the orientation vector.
)""");
  m.def(
      "tao_data_sanity_check",
      &python_tao_data_sanity_check,
      py::arg("datum"),
      py::arg("print_err"),
      py::arg("default_data_type"),
      py::arg("uni") = py::none(),
      py::arg("is_valid"),
      R"""(No docstring available

Parameters
----------
datum : TaoDataStruct
    Datum to check.
print_err : bool
    Print error message if data is not valid?
default_data_type : unknown
    Default data type associated with the datum's d2 structure.
uni : TaoUniverseStruct, optional
    Universe to use instead of datum.d1.d2.ix_universe
is_valid : 
)""");
  py::class_<PyTaoDataSanityCheck, std::unique_ptr<PyTaoDataSanityCheck>>(
      m,
      "TaoDataSanityCheck",
      "Fortran routine tao_data_sanity_check return value")
      .def_readonly("is_valid", &PyTaoDataSanityCheck::is_valid)
      .def("__len__", [](const PyTaoDataSanityCheck&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoDataSanityCheck& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "tao_command",
      &python_tao_command,
      py::arg("command_line"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
command_line : unknown
    command line
err : 
err_is_fatal : bool
    Set True on non-recoverable error. False otherwise
)""");
  py::class_<PyTaoCommand, std::unique_ptr<PyTaoCommand>>(
      m, "TaoCommand", "Fortran routine tao_command return value")
      .def_readonly("err_is_fatal", &PyTaoCommand::err_is_fatal)
      .def_readonly("err", &PyTaoCommand::err)
      .def("__len__", [](const PyTaoCommand&) { return 2; })
      .def("__getitem__", [](const PyTaoCommand& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_is_fatal);
        if (i == 1)
          return py::cast(s.err);
        return py::none();
      });
  m.def(
      "tao_graph_name",
      &python_tao_graph_name,
      py::arg("graph"),
      py::arg("use_region") = py::none(),
      py::arg("graph_name"),
      R"""(No docstring available

Parameters
----------
graph : TaoGraphStruct
    Graph
use_region : bool
    If present and True then use the region name instead of the plot name. Region name is 'NULL_REGION' if
    there is no assocaited region.
graph_name : 
)""");
  py::class_<PyTaoGraphName, std::unique_ptr<PyTaoGraphName>>(
      m, "TaoGraphName", "Fortran routine tao_graph_name return value")
      .def_readonly("graph_name", &PyTaoGraphName::graph_name)
      .def("__len__", [](const PyTaoGraphName&) { return 1; })
      .def("__getitem__", [](const PyTaoGraphName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.graph_name);
        return py::none();
      });
  m.def(
      "tao_scale_cmd",
      &Tao::tao_scale_cmd,
      py::arg("where"),
      py::arg("y_min_in"),
      py::arg("y_max_in"),
      py::arg("axis") = py::none(),
      py::arg("include_wall") = py::none(),
      py::arg("gang") = py::none(),
      py::arg("exact") = py::none(),
      py::arg("turn_autoscale_off") = py::none(),
      R"""(Routine to scale a plot.

If y_min = y_max, the scales will be chosen to show all the data.

Parameters
----------
where : unknown
    Region to scale. Eg: "top:x"
y_min_in : float
    Plot y-axis min value.
y_max_in : float
    Plot y-axis max value.
axis : unknown, optional
    'y', 'y2', or '' (both). Default = ''.
include_wall : bool, optional
    Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
    include the building wall position will be included in determining the the scale.
gang : unknown, optional
    'gang', 'nogang', ''. Default = ''.
exact : bool, optional
    Exact plot y_max, y_min to correspond to y_min_in, y_max_in? Default is False. Only relavent when y_min_in
    /= y_max_in.
turn_autoscale_off : bool, optional
    If True (default) then turn off plot.autoscale_y logical for all plots that are scaled.
)""");
  m.def(
      "tao_scale_plot",
      &Tao::tao_scale_plot,
      py::arg("plot"),
      py::arg("y_min_in"),
      py::arg("y_max_in"),
      py::arg("axis") = py::none(),
      py::arg("include_wall") = py::none(),
      py::arg("gang") = py::none(),
      py::arg("skip_lat_layout") = py::none(),
      R"""(Routine to scale the y-axis and/or y2-axis of the graphs of the plot.

If y_min_in = y_max_in then autoscaling will be done and the particular value
of y_min_in and y_max_in is ignored.

Parameters
----------
plot : TaoPlotStruct
    Plot with graphs to be scaled.
    This parameter is an input/output and is modified in-place. As an output: Plot with scaled graphs.
y_min_in : float
    Axis [min, max] must cover [y_min_in, y_max_in] if not autoscaling.
y_max_in : float
    Axis [min, max] must cover [y_min_in, y_max_in] if not autoscaling.
axis : unknown, optional
    Axis to scale. ''   -> scale y and y2 (default). 'y'  -> scale y-axis. 'y2' -> scale y2-axis
include_wall : bool, optional
    Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
    include the building wall position will be included in determining the the scale.
gang : unknown, optional
    If autoscale then make all graph y-axes the same and/or make all y2-axes the same? ''        -> (default)
    Use setting of plot.autoscale_gang_y 'gang'    -> Gang graphs. 'nogang'  -> Do not gang graphs.
skip_lat_layout : bool, optional
    If True, skip scaling any lat_layout graphs. Default is false.
)""");
  m.def(
      "tao_scale_graph",
      &Tao::tao_scale_graph,
      py::arg("graph"),
      py::arg("y_min"),
      py::arg("y_max"),
      py::arg("axis") = py::none(),
      py::arg("include_wall") = py::none(),
      R"""(Routine to scale the y-axis and/or y2-axis of a graph

If y_min = y_max then autoscaling will be done and the particular value of y_min and y_max is ignored.

Parameters
----------
graph : TaoGraphStruct
    Graph with axis/axes to be scaled.
    This parameter is an input/output and is modified in-place. As an output: Graph with scaled axis/axes.
y_min : float
    Axis [min, max] must cover [y_min, y_max] if not autoscaling.
y_max : float
    Axis [min, max] must cover [y_min, y_max] if not autoscaling.
axis : unknown, optional
    Axis to scale. ''   -> scale y and y2 (default). 'y'  -> scale y-axis. 'y2' -> scale y2-axis
include_wall : bool, optional
    Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
    include the building wall position will be included in determining the the scale.

Return value is a dictionary containing values below.


Returns
-------
y_range : float
    Only used by tao_scale_plot when ganging graphs.
y2_range : float
    Only used by tao_scale_plot when ganging graphs.
)""");
  py::class_<Tao::TaoScaleGraph, std::unique_ptr<Tao::TaoScaleGraph>>(
      m, "TaoScaleGraph", "Fortran routine tao_scale_graph return value")
      .def_readonly("y_range", &Tao::TaoScaleGraph::y_range)
      .def_readonly("y2_range", &Tao::TaoScaleGraph::y2_range)
      .def("__len__", [](const Tao::TaoScaleGraph&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoScaleGraph& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.y_range);
            if (i == 1)
              return py::cast(s.y2_range);
            return py::none();
          });
  m.def(
      "tao_pointer_to_datum",
      &Tao::tao_pointer_to_datum,
      py::arg("d1"),
      py::arg("ele_name"),
      py::arg("datum_ptr"),
      R"""(No docstring available

Parameters
----------
d1 : TaoD1DataStruct
    D1 data struct to search.
ele_name : unknown
    Name of lattice element to match to. Ouput:
datum_ptr : 
)""");
  m.def(
      "tao_lat_sigma_calc_needed",
      &python_tao_lat_sigma_calc_needed,
      py::arg("data_type"),
      py::arg("data_source"),
      py::arg("do_lat_sigma"),
      R"""(No docstring available

Parameters
----------
data_type : 
data_source : 
do_lat_sigma : 
)""");
  py::class_<PyTaoLatSigmaCalcNeeded, std::unique_ptr<PyTaoLatSigmaCalcNeeded>>(
      m,
      "TaoLatSigmaCalcNeeded",
      "Fortran routine tao_lat_sigma_calc_needed return value")
      .def_readonly("data_type", &PyTaoLatSigmaCalcNeeded::data_type)
      .def_readonly("data_source", &PyTaoLatSigmaCalcNeeded::data_source)
      .def_readonly("do_lat_sigma", &PyTaoLatSigmaCalcNeeded::do_lat_sigma)
      .def("__len__", [](const PyTaoLatSigmaCalcNeeded&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoLatSigmaCalcNeeded& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data_type);
            if (i == 1)
              return py::cast(s.data_source);
            if (i == 2)
              return py::cast(s.do_lat_sigma);
            return py::none();
          });
  m.def(
      "tao_single_track",
      &Tao::tao_single_track,
      py::arg("tao_lat"),
      py::arg("ix_branch"),
      py::arg("print_err") = py::none(),
      R"""(Routine to track a single particle and calculate lattice functions through a lattice.

Parameters
----------
tao_lat : TaoLatticeStruct
    Structure containing the lattice.
ix_branch : int
    Branch index to track through.
print_err : bool, optional
    Default False. Print error messages if, eg, lattice is unstable?

Returns
-------
calc_ok : bool
    Set True if there were no problems, False otherwise.
)""");
  m.def(
      "tao_lat_sigma_track",
      &Tao::tao_lat_sigma_track,
      py::arg("tao_lat"),
      py::arg("ix_branch"),
      py::arg("print_err") = py::none(),
      py::arg("force_calc") = py::none(),
      R"""(Routine to track the 6x6 sigma matrix through the lattice using the lattice linear transfer matrices.

Parameters
----------
tao_lat : TaoLatticeStruct
    Structure containing the lattice.
ix_branch : int
    Branch index to track through.
print_err : bool, optional
    Default is False. Print error messages if, eg, lattice is unstable?
force_calc : bool, optional
    Default is False. If True, force the calculation to be done.

Returns
-------
calc_ok : bool
    Set True if there were no problems, False otherwise.
)""");
  m.def(
      "tao_beam_track",
      &Tao::tao_beam_track,
      py::arg("u"),
      py::arg("tao_lat"),
      py::arg("ix_branch"),
      py::arg("beam"),
      R"""(Routine to track a a beam of particles.

Parameters
----------
u : TaoUniverseStruct
    Universe to track through.
tao_lat : TaoLatticeStruct
    Structure containing the lattice.
ix_branch : int
    Branch index to track through.
beam : BeamStruct
    Initial beam distribution
    This parameter is an input/output and is modified in-place. As an output: Final beam distribution.

Returns
-------
calc_ok : bool
    Set True if there were no problems, False otherwise.
)""");
  m.def(
      "tao_too_many_particles_lost",
      &python_tao_too_many_particles_lost,
      py::arg("beam"),
      py::arg("no_beam"),
      R"""(No docstring available

Parameters
----------
beam : 
no_beam : 
)""");
  py::class_<
      PyTaoTooManyParticlesLost,
      std::unique_ptr<PyTaoTooManyParticlesLost>>(
      m,
      "TaoTooManyParticlesLost",
      "Fortran routine tao_too_many_particles_lost return value")
      .def_readonly("no_beam", &PyTaoTooManyParticlesLost::no_beam)
      .def("__len__", [](const PyTaoTooManyParticlesLost&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoTooManyParticlesLost& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.no_beam);
            return py::none();
          });
  m.def(
      "tao_inject_particle",
      &python_tao_inject_particle,
      py::arg("u"),
      py::arg("model"),
      py::arg("ix_branch"),
      R"""(No docstring available

Parameters
----------
u : 
model : 
ix_branch : 
)""");
  py::class_<PyTaoInjectParticle, std::unique_ptr<PyTaoInjectParticle>>(
      m,
      "TaoInjectParticle",
      "Fortran routine tao_inject_particle return value")
      .def_readonly("ix_branch", &PyTaoInjectParticle::ix_branch)
      .def("__len__", [](const PyTaoInjectParticle&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoInjectParticle& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_branch);
            return py::none();
          });
  m.def(
      "tao_inject_beam",
      &Tao::tao_inject_beam,
      py::arg("u"),
      py::arg("model"),
      py::arg("ix_branch"),
      R"""(This will initialize the beam for a given lattice branch.

Trying to inject a beam of one species into a branch with a different ref species
(example: electron bunch into photon branch) is problematical. To avoid problems, Tao
will set not inject (init_ok = False) if there is a mismatch.

Parameters
----------
u : TaoUniverseStruct
    Universe containing the lattice.
model : TaoLatticeStruct
    Universe parameters.
ix_branch : int
    Lattice branch index to inject into.

Return value is a dictionary containing values below.


Returns
-------
beam : BeamStruct
    Initial beam.
init_ok : bool
    Set False if there are problems. True otherwise.
)""");
  py::class_<Tao::TaoInjectBeam, std::unique_ptr<Tao::TaoInjectBeam>>(
      m, "TaoInjectBeam", "Fortran routine tao_inject_beam return value")
      .def_readonly("beam", &Tao::TaoInjectBeam::beam)
      .def_readonly("init_ok", &Tao::TaoInjectBeam::init_ok)
      .def("__len__", [](const Tao::TaoInjectBeam&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoInjectBeam& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.beam);
            if (i == 1)
              return py::cast(s.init_ok);
            return py::none();
          });
  m.def(
      "tao_beam_track_endpoint",
      &Tao::tao_beam_track_endpoint,
      py::arg("ele_id"),
      py::arg("lat"),
      py::arg("branch_str"),
      py::arg("where"),
      py::arg("u"),
      py::arg("ele"),
      R"""(No docstring available

Parameters
----------
ele_id : unknown
    Name or index of the element.
lat : LatStruct
    Lattice.
branch_str : int
    Branch where the tracking is done. '' => Branch not specified.
where : unknown
    'TRACK_END', 'TRACK_START', etc.. Used for error messages.
u : TaoUniverseStruct
    Universe beam is being tracked in.
ele : 
)""");
  m.def(
      "tao_var1_name",
      &python_tao_var1_name,
      py::arg("var"),
      py::arg("var1_name"),
      R"""(No docstring available

Parameters
----------
var : TaoVarStruct
    Variable
var1_name : 
)""");
  py::class_<PyTaoVar1Name, std::unique_ptr<PyTaoVar1Name>>(
      m, "TaoVar1Name", "Fortran routine tao_var1_name return value")
      .def_readonly("var1_name", &PyTaoVar1Name::var1_name)
      .def("__len__", [](const PyTaoVar1Name&) { return 1; })
      .def("__getitem__", [](const PyTaoVar1Name& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.var1_name);
        return py::none();
      });
  m.def(
      "tao_curve_ix_uni",
      &python_tao_curve_ix_uni,
      py::arg("curve"),
      py::arg("ix_uni"),
      R"""(No docstring available

Parameters
----------
curve : TaoCurveStruct
    Curve.
ix_uni : 
)""");
  py::class_<PyTaoCurveIxUni, std::unique_ptr<PyTaoCurveIxUni>>(
      m, "TaoCurveIxUni", "Fortran routine tao_curve_ix_uni return value")
      .def_readonly("ix_uni", &PyTaoCurveIxUni::ix_uni)
      .def("__len__", [](const PyTaoCurveIxUni&) { return 1; })
      .def("__getitem__", [](const PyTaoCurveIxUni& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ix_uni);
        return py::none();
      });
  m.def(
      "tao_open_file",
      &python_tao_open_file,
      py::arg("file"),
      py::arg("file_name"),
      py::arg("error_severity"),
      py::arg("binary") = py::none(),
      R"""(No docstring available

Parameters
----------
file : 
iunit : int
    Logical unit number. Set to 0 if file not openable.
file_name : unknown
    File name.
error_severity : int
    Severity level used in the error message. Possibilities are s_fatal$, etc. See out_io doc for more
    details. Use -1 to not print a message if file cannot be opened.
binary : bool, optional
    If present and True then open a binary file, Defaut is False.
)""");
  py::class_<PyTaoOpenFile, std::unique_ptr<PyTaoOpenFile>>(
      m, "TaoOpenFile", "Fortran routine tao_open_file return value")
      .def_readonly("iunit", &PyTaoOpenFile::iunit)
      .def_readonly("file", &PyTaoOpenFile::file)
      .def("__len__", [](const PyTaoOpenFile&) { return 2; })
      .def("__getitem__", [](const PyTaoOpenFile& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.iunit);
        if (i == 1)
          return py::cast(s.file);
        return py::none();
      });
  m.def(
      "tao_json_cmd",
      &python_tao_json_cmd,
      py::arg("input_str"),
      R"""(No docstring available

Parameters
----------
input_str : 
)""");
  py::class_<PyTaoJsonCmd, std::unique_ptr<PyTaoJsonCmd>>(
      m, "TaoJsonCmd", "Fortran routine tao_json_cmd return value")
      .def_readonly("input_str", &PyTaoJsonCmd::input_str)
      .def("__len__", [](const PyTaoJsonCmd&) { return 1; })
      .def("__getitem__", [](const PyTaoJsonCmd& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.input_str);
        return py::none();
      });
  m.def(
      "tao_datum_name",
      &python_tao_datum_name,
      py::arg("datum"),
      py::arg("show_universe") = py::none(),
      py::arg("datum_name"),
      R"""(No docstring available

Parameters
----------
datum : TaoDataStruct
    Datum
show_universe : bool, optional
    Show the datum's universe. Default is True.
datum_name : 
)""");
  py::class_<PyTaoDatumName, std::unique_ptr<PyTaoDatumName>>(
      m, "TaoDatumName", "Fortran routine tao_datum_name return value")
      .def_readonly("datum_name", &PyTaoDatumName::datum_name)
      .def("__len__", [](const PyTaoDatumName&) { return 1; })
      .def("__getitem__", [](const PyTaoDatumName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.datum_name);
        return py::none();
      });
  m.def(
      "tao_rad_int_calc_needed",
      &python_tao_rad_int_calc_needed,
      py::arg("data_type"),
      py::arg("data_source"),
      py::arg("do_rad_int"),
      R"""(No docstring available

Parameters
----------
data_type : 
data_source : 
do_rad_int : 
)""");
  py::class_<PyTaoRadIntCalcNeeded, std::unique_ptr<PyTaoRadIntCalcNeeded>>(
      m,
      "TaoRadIntCalcNeeded",
      "Fortran routine tao_rad_int_calc_needed return value")
      .def_readonly("data_type", &PyTaoRadIntCalcNeeded::data_type)
      .def_readonly("data_source", &PyTaoRadIntCalcNeeded::data_source)
      .def_readonly("do_rad_int", &PyTaoRadIntCalcNeeded::do_rad_int)
      .def("__len__", [](const PyTaoRadIntCalcNeeded&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoRadIntCalcNeeded& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data_type);
            if (i == 1)
              return py::cast(s.data_source);
            if (i == 2)
              return py::cast(s.do_rad_int);
            return py::none();
          });
  m.def(
      "tao_var_target_calc",
      &Tao::tao_var_target_calc,
      R"""(No docstring available

)""");
  m.def(
      "tao_cmd_history_record",
      &python_tao_cmd_history_record,
      py::arg("cmd"),
      R"""(Subroutine to record a cmd in the command history stack

)""");
  py::class_<PyTaoCmdHistoryRecord, std::unique_ptr<PyTaoCmdHistoryRecord>>(
      m,
      "TaoCmdHistoryRecord",
      "Fortran routine tao_cmd_history_record return value")
      .def_readonly("cmd", &PyTaoCmdHistoryRecord::cmd)
      .def("__len__", [](const PyTaoCmdHistoryRecord&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoCmdHistoryRecord& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.cmd);
            return py::none();
          });
  m.def(
      "tao_re_execute",
      &python_tao_re_execute,
      py::arg("string"),
      py::arg("err"),
      R"""(Subroutine to execute a previous command.

)""");
  py::class_<PyTaoReExecute, std::unique_ptr<PyTaoReExecute>>(
      m, "TaoReExecute", "Fortran routine tao_re_execute return value")
      .def_readonly("string", &PyTaoReExecute::string)
      .def_readonly("err", &PyTaoReExecute::err)
      .def("__len__", [](const PyTaoReExecute&) { return 2; })
      .def("__getitem__", [](const PyTaoReExecute& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.string);
        if (i == 1)
          return py::cast(s.err);
        return py::none();
      });
  m.def(
      "tao_next_word",
      &python_tao_next_word,
      py::arg("line"),
      R"""(Routine to return the next word in a line.

Words are delimited by a space character except if the space is within quotes.
Additionally, spaces within brackets "(...)", "{...}", and "[...]" are ignored.
Outer quote marks will be removed in the returned word.

Parameters
----------
line : unknown
    String to parse.
    This parameter is an input/output and is modified in-place. As an output: String with first word removed.

Returns
-------
word : unknown
    First word of line.
)""");
  py::class_<PyTaoNextWord, std::unique_ptr<PyTaoNextWord>>(
      m, "TaoNextWord", "Fortran routine tao_next_word return value")
      .def_readonly("word", &PyTaoNextWord::word)
      .def_readonly("line", &PyTaoNextWord::line)
      .def("__len__", [](const PyTaoNextWord&) { return 2; })
      .def("__getitem__", [](const PyTaoNextWord& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.word);
        if (i == 1)
          return py::cast(s.line);
        return py::none();
      });
  m.def(
      "tao_var_check",
      &Tao::tao_var_check,
      py::arg("eles"),
      py::arg("attribute"),
      py::arg("silent"),
      R"""(No docstring available

Parameters
----------
eles : ElePointerStruct
    Array of elements which have a changed attribute.
attribute : unknown
    Name of attribute changed.
silent : bool
    If True and the problem can be fixed, do not issue an error message.
)""");
  m.def(
      "tao_spin_matrices_calc_needed",
      &python_tao_spin_matrices_calc_needed,
      py::arg("data_type"),
      py::arg("data_source"),
      py::arg("do_calc"),
      R"""(No docstring available

Parameters
----------
data_type : 
data_source : 
do_calc : 
)""");
  py::class_<
      PyTaoSpinMatricesCalcNeeded,
      std::unique_ptr<PyTaoSpinMatricesCalcNeeded>>(
      m,
      "TaoSpinMatricesCalcNeeded",
      "Fortran routine tao_spin_matrices_calc_needed return value")
      .def_readonly("data_type", &PyTaoSpinMatricesCalcNeeded::data_type)
      .def_readonly("data_source", &PyTaoSpinMatricesCalcNeeded::data_source)
      .def_readonly("do_calc", &PyTaoSpinMatricesCalcNeeded::do_calc)
      .def("__len__", [](const PyTaoSpinMatricesCalcNeeded&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoSpinMatricesCalcNeeded& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data_type);
            if (i == 1)
              return py::cast(s.data_source);
            if (i == 2)
              return py::cast(s.do_calc);
            return py::none();
          });
  m.def(
      "tao_init_lattice",
      &python_tao_init_lattice,
      py::arg("lat_file"),
      py::arg("err_flag"),
      R"""(No docstring available

Parameters
----------
lat_file : 
err_flag : 
)""");
  py::class_<PyTaoInitLattice, std::unique_ptr<PyTaoInitLattice>>(
      m, "TaoInitLattice", "Fortran routine tao_init_lattice return value")
      .def_readonly("lat_file", &PyTaoInitLattice::lat_file)
      .def_readonly("err_flag", &PyTaoInitLattice::err_flag)
      .def("__len__", [](const PyTaoInitLattice&) { return 2; })
      .def(
          "__getitem__", [](const PyTaoInitLattice& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.lat_file);
            if (i == 1)
              return py::cast(s.err_flag);
            return py::none();
          });
  m.def(
      "tao_pause_cmd",
      &Tao::tao_pause_cmd,
      py::arg("time"),
      R"""(No docstring available

Parameters
----------
time : float
    Time to pause in seconds.
)""");
  m.def(
      "tao_draw_plots",
      &Tao::tao_draw_plots,
      py::arg("do_clear") = py::none(),
      R"""(Subroutine to draw the plots on the plot window.

Parameters
----------
do_clear : bool, optional
    If present and False then call qp_clear_page. This argument is used when drawing PS or GIF.
)""");
  m.def(
      "tao_plot_histogram",
      &Tao::tao_plot_histogram,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw one graph for the histogram analysis plot.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_plot_wave",
      &Tao::tao_plot_wave,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw one graph for the wave analysis plot.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_plot_key_table",
      &Tao::tao_plot_key_table,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw a key table graph.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_draw_floor_plan",
      &Tao::tao_draw_floor_plan,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw a floor plan graph.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_draw_ele_for_floor_plan",
      &python_tao_draw_ele_for_floor_plan,
      py::arg("plot"),
      py::arg("graph"),
      py::arg("tao_lat"),
      py::arg("ele"),
      py::arg("ele_shape"),
      py::arg("label_name"),
      py::arg("offset1"),
      py::arg("offset2"),
      R"""(Routine to draw one lattice element or one datum location for the floor plan graph.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
tao_lat : TaoLatticeStruct
    Lattice containing the element.
ele : EleStruct
    Element to draw.
ele_shape : TaoEleShapeStruct
    Shape to draw from s.plot_page.floor_plan.ele_shape(:) array. Will be NULL if no associated shape for this
    element.
label_name : unknown
    Shape label. offset1, offset2  -- real(rp): Transverse distances used to scale the drawing of the element
    shape.
)""");
  py::class_<
      PyTaoDrawEleForFloorPlan,
      std::unique_ptr<PyTaoDrawEleForFloorPlan>>(
      m,
      "TaoDrawEleForFloorPlan",
      "Fortran routine tao_draw_ele_for_floor_plan return value")
      .def_readonly("offset1", &PyTaoDrawEleForFloorPlan::offset1)
      .def_readonly("offset2", &PyTaoDrawEleForFloorPlan::offset2)
      .def("__len__", [](const PyTaoDrawEleForFloorPlan&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoDrawEleForFloorPlan& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.offset1);
            if (i == 1)
              return py::cast(s.offset2);
            return py::none();
          });
  m.def(
      "tao_draw_lat_layout",
      &Tao::tao_draw_lat_layout,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw a lattice layout graph.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_draw_beam_chamber_wall",
      &Tao::tao_draw_beam_chamber_wall,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw the beam chamber wall.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_plot_data",
      &Tao::tao_plot_data,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw a graph with data and/or variable curves.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_draw_curve_data",
      &python_tao_draw_curve_data,
      py::arg("plot"),
      py::arg("graph"),
      py::arg("curve"),
      py::arg("have_data"),
      R"""(Routine to draw a graph with data and/or variable curves.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph containing the curve.
curve : TaoCurveStruct
    Curve to draw.
have_data : bool
    Intitial state.
    This parameter is an input/output and is modified in-place. As an output: Is there any data to plot? Set
    True if so.
)""");
  py::class_<PyTaoDrawCurveData, std::unique_ptr<PyTaoDrawCurveData>>(
      m, "TaoDrawCurveData", "Fortran routine tao_draw_curve_data return value")
      .def_readonly("have_data", &PyTaoDrawCurveData::have_data)
      .def("__len__", [](const PyTaoDrawCurveData&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoDrawCurveData& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.have_data);
            return py::none();
          });
  m.def(
      "tao_draw_histogram_data",
      &python_tao_draw_histogram_data,
      py::arg("plot"),
      py::arg("graph"),
      py::arg("curve"),
      py::arg("have_data"),
      R"""(Routine to draw a graph with data and/or variable histograms.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph containing the histogram.
curve : TaoCurveStruct
    Histogram to draw.
have_data : bool
    Intitial state.
    This parameter is an input/output and is modified in-place. As an output: Is there any data to plot? Set
    True if so.
)""");
  py::class_<PyTaoDrawHistogramData, std::unique_ptr<PyTaoDrawHistogramData>>(
      m,
      "TaoDrawHistogramData",
      "Fortran routine tao_draw_histogram_data return value")
      .def_readonly("have_data", &PyTaoDrawHistogramData::have_data)
      .def("__len__", [](const PyTaoDrawHistogramData&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoDrawHistogramData& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.have_data);
            return py::none();
          });
  m.def(
      "tao_draw_graph_axes",
      &Tao::tao_draw_graph_axes,
      py::arg("plot"),
      py::arg("graph"),
      R"""(Routine to draw a just the graph part of a data graph.

The calling routine takes care of drawing any curves.

Parameters
----------
plot : TaoPlotStruct
    Plot containing the graph.
graph : TaoGraphStruct
    Graph to plot.
)""");
  m.def(
      "tao_open_scratch_file",
      &python_tao_open_scratch_file,
      py::arg("iu"),
      R"""(No docstring available

Parameters
----------
err : bool
    Set True if there is an error. False otherwise.
iu : 
)""");
  py::class_<PyTaoOpenScratchFile, std::unique_ptr<PyTaoOpenScratchFile>>(
      m,
      "TaoOpenScratchFile",
      "Fortran routine tao_open_scratch_file return value")
      .def_readonly("err", &PyTaoOpenScratchFile::err)
      .def_readonly("iu", &PyTaoOpenScratchFile::iu)
      .def("__len__", [](const PyTaoOpenScratchFile&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoOpenScratchFile& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err);
            if (i == 1)
              return py::cast(s.iu);
            return py::none();
          });
  m.def(
      "tao_create_plot_window",
      &Tao::tao_create_plot_window,
      R"""(Subroutine to create the plot window.

This soubroutine knows not to create a second window if one already exists.

)""");
  m.def(
      "tao_destroy_plot_window",
      &Tao::tao_destroy_plot_window,
      R"""(No docstring available

)""");
  m.def(
      "tao_var_repoint",
      &Tao::tao_var_repoint,
      R"""(No docstring available

)""");
  m.def(
      "tao_quiet_set",
      &Tao::tao_quiet_set,
      py::arg("set"),
      R"""(No docstring available

Parameters
----------
set : bool
    True is silent running is wanted.
)""");
  m.def(
      "tao_curve_rms_calc",
      &Tao::tao_curve_rms_calc,
      py::arg("curve"),
      py::arg("who"),
      R"""(No docstring available

Parameters
----------
curve : TaoCurveStruct
    Curve to analyze.
who : unknown
    "LINE" or "SYMBOL".
rms : float
    RMS. -1 => Curve has no data.
mean : float
    Mean.
)""");
  py::class_<Tao::TaoCurveRmsCalc, std::unique_ptr<Tao::TaoCurveRmsCalc>>(
      m, "TaoCurveRmsCalc", "Fortran routine tao_curve_rms_calc return value")
      .def_readonly("rms", &Tao::TaoCurveRmsCalc::rms)
      .def_readonly("mean", &Tao::TaoCurveRmsCalc::mean)
      .def("__len__", [](const Tao::TaoCurveRmsCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoCurveRmsCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.rms);
            if (i == 1)
              return py::cast(s.mean);
            return py::none();
          });
  m.def(
      "tao_mark_lattice_ele",
      &Tao::tao_mark_lattice_ele,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : LatStruct
    Input lattice
    This parameter is an input/output and is modified in-place. As an output: Lattice with elements marked.
)""");
  m.def(
      "tao_use_data",
      &Tao::tao_use_data,
      py::arg("action"),
      py::arg("data_name"),
      R"""(No docstring available

Parameters
----------
action : unknown
    veto, use or restore
data_name : unknown
    the selected data
)""");
  m.def(
      "tao_curve_name",
      &python_tao_curve_name,
      py::arg("curve"),
      py::arg("use_region") = py::none(),
      py::arg("curve_name"),
      R"""(No docstring available

Parameters
----------
curve : TaoCurveStruct
    Curve
use_region : bool
    If present and True then use the region name instead of the plot name. Region name is 'NULL_REGION' if
    there is no assocaited region.
curve_name : 
)""");
  py::class_<PyTaoCurveName, std::unique_ptr<PyTaoCurveName>>(
      m, "TaoCurveName", "Fortran routine tao_curve_name return value")
      .def_readonly("curve_name", &PyTaoCurveName::curve_name)
      .def("__len__", [](const PyTaoCurveName&) { return 1; })
      .def("__getitem__", [](const PyTaoCurveName& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.curve_name);
        return py::none();
      });
  m.def(
      "tao_locate_elements",
      &python_tao_locate_elements,
      py::arg("ele_list"),
      py::arg("ix_universe"),
      py::arg("lat_type") = py::none(),
      py::arg("ignore_blank") = py::none(),
      py::arg("err_stat_level") = py::none(),
      py::arg("above_ubound_is_err") = py::none(),
      py::arg("ix_branch") = py::none(),
      py::arg("multiple_eles_is_err") = py::none(),
      R"""(No docstring available

Parameters
----------
ele_list : unknown
    String with element names using element list format.
ix_universe : int
    Universe to search. -1 => search s.global.default_universe. -2 (all unis) => error. ix_universe is ignored
    if ele_list starts with a universe specifier "N@".
eles : unknown
    : Array of elements in the model lat.
err : bool
    Set true on error.
lat_type : int, optional
    model$ (default), design$, or base$.
ignore_blank : bool, optional
    If present and true then do nothing if ele_list is blank. otherwise treated as an error.
err_stat_level : int, optional
    Status level for error messages. If not present, print with level s_error$. Use s_nooutput$ to prevent
    printing.
above_ubound_is_err : 
ix_branch : int, optional
    If present and non-negative then use this as the branch index for elements specified using an integer
    index (EG: "43"). If -1 use the default branch, search all branches.
multiple_eles_is_err : bool, optional
    If present and True then matching to more than one element is an error. -- logical, optional: If present
    and True then matching to more than one element is an error.
)""");
  py::class_<PyTaoLocateElements, std::unique_ptr<PyTaoLocateElements>>(
      m,
      "TaoLocateElements",
      "Fortran routine tao_locate_elements return value")
      .def_readonly("eles", &PyTaoLocateElements::eles)
      .def_readonly("err", &PyTaoLocateElements::err)
      .def_readonly(
          "above_ubound_is_err", &PyTaoLocateElements::above_ubound_is_err)
      .def("__len__", [](const PyTaoLocateElements&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoLocateElements& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.eles);
            if (i == 1)
              return py::cast(s.err);
            if (i == 2)
              return py::cast(s.above_ubound_is_err);
            return py::none();
          });
  m.def(
      "tao_set_opt_vars",
      &Tao::tao_set_opt_vars,
      py::arg("var_vec"),
      py::arg("print_limit_warning") = py::none(),
      R"""(No docstring available

Parameters
----------
var_vec : float
    Vector of variables.
print_limit_warning : bool, optional
    Print a warning if the value is past the variable's limits. -- Logical, optional: Print a warning if the
    value is past the variable's limits. Default is True.
)""");
  m.def(
      "tao_control_tree_list",
      &Tao::tao_control_tree_list,
      py::arg("ele"),
      py::arg("tree"),
      R"""(No docstring available

Parameters
----------
ele : EleStruct
    Lattice element to start at. Ouput:
tree : ElePointerStruct
    Array of elements.
)""");
  m.def(
      "tao_close_command_file",
      &Tao::tao_close_command_file,
      R"""(No docstring available

)""");
  m.def(
      "tao_lattice_calc",
      &Tao::tao_lattice_calc,
      R"""(No docstring available

Parameters
----------
calc_ok : bool
    Set False if there was an error in the calculation like a particle was lost or a lat is unstable.
print_err : bool
    Default True. If False, do not print error messages if, for example, the lattice is unstable.
)""");
  py::class_<Tao::TaoLatticeCalc, std::unique_ptr<Tao::TaoLatticeCalc>>(
      m, "TaoLatticeCalc", "Fortran routine tao_lattice_calc return value")
      .def_readonly("calc_ok", &Tao::TaoLatticeCalc::calc_ok)
      .def_readonly("print_err", &Tao::TaoLatticeCalc::print_err)
      .def("__len__", [](const Tao::TaoLatticeCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoLatticeCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.calc_ok);
            if (i == 1)
              return py::cast(s.print_err);
            return py::none();
          });
  m.def(
      "tao_set_invalid",
      &Tao::tao_set_invalid,
      py::arg("datum"),
      py::arg("message"),
      py::arg("exterminate") = py::none(),
      py::arg("err_level") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
datum : TaoDataStruct
    Bad datum.
message : unknown
    Error message.
why_invalid : unknown
    Set to message if present.
exterminate : bool, optional
    Default is False. If True, set datum.exists to False so that Tao will ignore this datum from now on.
err_level : int, optional
    s_error$ (default), s_warn$, etc.
print_err : bool, optional
    Default is True. If False, do not print an error message.
)""");
  m.def(
      "tao_lat_emit_calc",
      &python_tao_lat_emit_calc,
      py::arg("plane"),
      py::arg("emit_type"),
      py::arg("ele"),
      py::arg("modes"),
      py::arg("emit"),
      R"""(No docstring available

Parameters
----------
plane : int
    x_plane$ or y_plane$.
emit_type : int
    Either projected_emit$ or apparent_emit$
ele : EleStruct
    Element holding the Twiss and coupling parameters.
modes : NormalModesStruct
    Structure holding the emittances
emit : 
)""");
  py::class_<PyTaoLatEmitCalc, std::unique_ptr<PyTaoLatEmitCalc>>(
      m, "TaoLatEmitCalc", "Fortran routine tao_lat_emit_calc return value")
      .def_readonly("emit", &PyTaoLatEmitCalc::emit)
      .def("__len__", [](const PyTaoLatEmitCalc&) { return 1; })
      .def(
          "__getitem__", [](const PyTaoLatEmitCalc& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.emit);
            return py::none();
          });
  m.def(
      "tao_is_valid_name",
      &python_tao_is_valid_name,
      py::arg("name"),
      py::arg("is_valid"),
      R"""(implicit none

character(*) single_mode_file
end subroutine

Parameters
----------
name : unknown
    Name to be checked.

Returns
-------
why_invalid : unknown
    Why invalid description.
)""");
  py::class_<PyTaoIsValidName, std::unique_ptr<PyTaoIsValidName>>(
      m, "TaoIsValidName", "Fortran routine tao_is_valid_name return value")
      .def_readonly("why_invalid", &PyTaoIsValidName::why_invalid)
      .def_readonly("is_valid", &PyTaoIsValidName::is_valid)
      .def("__len__", [](const PyTaoIsValidName&) { return 2; })
      .def(
          "__getitem__", [](const PyTaoIsValidName& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.why_invalid);
            if (i == 1)
              return py::cast(s.is_valid);
            return py::none();
          });
  m.def(
      "tao_python_cmd",
      &Tao::tao_python_cmd,
      py::arg("input_str"),
      R"""(No docstring available

Parameters
----------
input_str : unknown
    What to show.
)""");
  m.def(
      "tao_scale_ping_data",
      &Tao::tao_scale_ping_data,
      py::arg("u"),
      R"""(No docstring available

Parameters
----------
u : 
)""");
  m.def(
      "tao_plot_cmd",
      &Tao::tao_plot_cmd,
      py::arg("where"),
      py::arg("component"),
      R"""(No docstring available

Parameters
----------
where : unknown
    Region name to identify the plot to set.
component : unknown
    Who to plot. EG: 'meas - design'
)""");
  m.def(
      "tao_evaluate_a_datum",
      &Tao::tao_evaluate_a_datum,
      py::arg("datum"),
      py::arg("u"),
      py::arg("tao_lat"),
      py::arg("called_from_lat_calc") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
datum : TaoDataStruct
    What type of datum
u : TaoUniverseStruct
    Which universe to use.
tao_lat : TaoLatticeStruct
    Lattice to use.
datum_value : float
    Value of the datum.
valid_value : bool
    Set false when there is a problem. Set true otherwise.
why_invalid : unknown
    Tells why datum value is invalid.
called_from_lat_calc : bool, optional
    Default is False. If true, prevents infinite loop of this -- logical, optional: Default is False. If true,
    prevents infinite loop of this routine calling tao_lattice_calc
print_err : bool, optional
    Default is True. If False, do not print an error message.
)""");
  py::class_<Tao::TaoEvaluateADatum, std::unique_ptr<Tao::TaoEvaluateADatum>>(
      m,
      "TaoEvaluateADatum",
      "Fortran routine tao_evaluate_a_datum return value")
      .def_readonly("datum_value", &Tao::TaoEvaluateADatum::datum_value)
      .def_readonly("valid_value", &Tao::TaoEvaluateADatum::valid_value)
      .def_readonly("why_invalid", &Tao::TaoEvaluateADatum::why_invalid)
      .def("__len__", [](const Tao::TaoEvaluateADatum&) { return 3; })
      .def(
          "__getitem__",
          [](const Tao::TaoEvaluateADatum& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.datum_value);
            if (i == 1)
              return py::cast(s.valid_value);
            if (i == 2)
              return py::cast(s.why_invalid);
            return py::none();
          });
  m.def(
      "tao_srdt_calc_needed",
      &python_tao_srdt_calc_needed,
      py::arg("data_type"),
      py::arg("data_source"),
      py::arg("do_srdt"),
      R"""(No docstring available

Parameters
----------
data_type : 
data_source : 
do_srdt : 
)""");
  py::class_<PyTaoSrdtCalcNeeded, std::unique_ptr<PyTaoSrdtCalcNeeded>>(
      m,
      "TaoSrdtCalcNeeded",
      "Fortran routine tao_srdt_calc_needed return value")
      .def_readonly("data_type", &PyTaoSrdtCalcNeeded::data_type)
      .def_readonly("data_source", &PyTaoSrdtCalcNeeded::data_source)
      .def_readonly("do_srdt", &PyTaoSrdtCalcNeeded::do_srdt)
      .def("__len__", [](const PyTaoSrdtCalcNeeded&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoSrdtCalcNeeded& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data_type);
            if (i == 1)
              return py::cast(s.data_source);
            if (i == 2)
              return py::cast(s.do_srdt);
            return py::none();
          });
  m.def(
      "tao_regression_test",
      &Tao::tao_regression_test,
      R"""(No docstring available

)""");
  m.def(
      "tao_pipe_cmd",
      &Tao::tao_pipe_cmd,
      py::arg("input_str"),
      R"""(No docstring available

Parameters
----------
input_str : unknown
    What to show.
)""");
  m.def(
      "tao_optimization_status",
      &python_tao_optimization_status,
      py::arg("datum"),
      py::arg("why_str"),
      R"""(No docstring available

Parameters
----------
datum : TaoDataStruct
    Datum to evaluate.
why_str : 
)""");
  py::class_<PyTaoOptimizationStatus, std::unique_ptr<PyTaoOptimizationStatus>>(
      m,
      "TaoOptimizationStatus",
      "Fortran routine tao_optimization_status return value")
      .def_readonly("why_str", &PyTaoOptimizationStatus::why_str)
      .def("__len__", [](const PyTaoOptimizationStatus&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoOptimizationStatus& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.why_str);
            return py::none();
          });
  m.def(
      "tao_evaluate_lat_or_beam_data",
      &python_tao_evaluate_lat_or_beam_data,
      py::arg("data_name"),
      py::arg("print_err"),
      py::arg("default_source"),
      py::arg("dflt_ele_ref") = py::none(),
      py::arg("dflt_ele_start") = py::none(),
      py::arg("dflt_ele") = py::none(),
      py::arg("dflt_component") = py::none(),
      py::arg("dflt_uni") = py::none(),
      py::arg("dflt_eval_point") = py::none(),
      py::arg("dflt_s_offset") = py::none(),
      R"""(dflt_ele_ref, dflt_ele_start, dflt_ele, dflt_component, dflt_uni, dflt_eval_point, dflt_s_offset)

Routine to evaluate data with a lat or beam source of the form:
<universe>@lat::<data_type>[<ix_ele_start>&<ix_ele>]|<component>

Parameters
----------
data_name : unknown
    data name.
print_err : bool
    Print error message?
dflt_source : unknown
    If not blank: Default source: 'lat' or 'beam'.
dflt_ele_ref : EleStruct, optional
    Default reference element.
dflt_ele_start : EleStruct, optional
    Default start element.
dflt_ele : EleStruct, optional
    Default element to evaluate at.
dflt_component : unknown, optional
    Default component: 'model' (default), 'base', or 'design'.
dflt_uni : int, optional
    Default universe to use.
dflt_eval_point : int, optional
    Default eval_point. anchor_end$ (default), anchor_center$, or anchor_beginning$.
dflt_s_offset : float, optional
    Default offset of eval_point. Default = 0.

Return value is a dictionary containing values below.


Returns
-------
err : bool
    True if there is an error. False otherwise.
values : float
    Array of datum valuse.
)""");
  py::class_<
      PyTaoEvaluateLatOrBeamData,
      std::unique_ptr<PyTaoEvaluateLatOrBeamData>>(
      m,
      "TaoEvaluateLatOrBeamData",
      "Fortran routine tao_evaluate_lat_or_beam_data return value")
      .def_readonly("err", &PyTaoEvaluateLatOrBeamData::err)
      .def_readonly("values", &PyTaoEvaluateLatOrBeamData::values)
      .def_readonly(
          "default_source", &PyTaoEvaluateLatOrBeamData::default_source)
      .def("__len__", [](const PyTaoEvaluateLatOrBeamData&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoEvaluateLatOrBeamData& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err);
            if (i == 1)
              return py::cast(s.values);
            if (i == 2)
              return py::cast(s.default_source);
            return py::none();
          });
  m.def(
      "tao_to_phase_and_coupling_reading",
      &python_tao_to_phase_and_coupling_reading,
      py::arg("ele"),
      py::arg("why_invalid"),
      py::arg("datum"),
      R"""(Buffer routine for to_phase_and_coupling_reading.

Parameters
----------
ele : EleStruct
    The monitor.

Return value is a dictionary containing values below.


Returns
-------
bpm_data : BpmPhaseCouplingStruct
    Monitor values
valid_value : bool
    Valid data value?
)""");
  py::class_<
      PyTaoToPhaseAndCouplingReading,
      std::unique_ptr<PyTaoToPhaseAndCouplingReading>>(
      m,
      "TaoToPhaseAndCouplingReading",
      "Fortran routine tao_to_phase_and_coupling_reading return value")
      .def_readonly("bpm_data", &PyTaoToPhaseAndCouplingReading::bpm_data)
      .def_readonly("valid_value", &PyTaoToPhaseAndCouplingReading::valid_value)
      .def_readonly("why_invalid", &PyTaoToPhaseAndCouplingReading::why_invalid)
      .def("__len__", [](const PyTaoToPhaseAndCouplingReading&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoToPhaseAndCouplingReading& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.bpm_data);
            if (i == 1)
              return py::cast(s.valid_value);
            if (i == 2)
              return py::cast(s.why_invalid);
            return py::none();
          });
  m.def(
      "tao_get_data",
      &Tao::tao_get_data,
      R"""(Subroutine to get the values of the data used in optimization and put them

in an array. The data is ordered starting with the first universe


Return value is a dictionary containing values below.


Returns
-------
data_value : float
    Data model values.
data_weight : float
    Data weights in the merit function.
data_meas_value : float
    Data values when the data was taken.
data_ix_dModel : int
    Data ix_dModel indices
)""");
  py::class_<Tao::TaoGetData, std::unique_ptr<Tao::TaoGetData>>(
      m, "TaoGetData", "Fortran routine tao_get_data return value")
      .def_readonly("data_value", &Tao::TaoGetData::data_value)
      .def_readonly("data_weight", &Tao::TaoGetData::data_weight)
      .def_readonly("data_meas_value", &Tao::TaoGetData::data_meas_value)
      .def_readonly("data_ix_dModel", &Tao::TaoGetData::data_ix_dModel)
      .def("__len__", [](const Tao::TaoGetData&) { return 4; })
      .def("__getitem__", [](const Tao::TaoGetData& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.data_value);
        if (i == 1)
          return py::cast(s.data_weight);
        if (i == 2)
          return py::cast(s.data_meas_value);
        if (i == 3)
          return py::cast(s.data_ix_dModel);
        return py::none();
      });
  m.def(
      "tao_expression_hash_substitute",
      &Tao::tao_expression_hash_substitute,
      py::arg("expression_in"),
      py::arg("eval_ele") = py::none(),
      R"""(Routine to, in the expression, substitute the evaluation lattice element name in place

of hash ("#") characters. Care is taken to only do this where it makes sense.
For example, "Q1##3" where here "##3" means the third instance of Q1, does not qualify.
Specifically, a substitution will be done if the character before the hash and the
character after are one of:
[,]-*+/:|@<>, or a blank character, or the beginning or end of the expression

Parameters
----------
expression_in : unknown
    Expression.
eval_ele : EleStruct, optional
    Evaluation element name to substitute in. If not present, expression will not be modified.

Returns
-------
expression_out : unknown
    Expression with substitutions made.
)""");
  m.def(
      "tao_load_this_datum",
      &python_tao_load_this_datum,
      py::arg("vec"),
      py::arg("ele_ref"),
      py::arg("ele_start"),
      py::arg("ele"),
      py::arg("datum_value"),
      py::arg("valid_value"),
      py::arg("datum"),
      py::arg("branch"),
      py::arg("why_invalid") = py::none(),
      py::arg("good") = py::none(),
      R"""(No docstring available

Parameters
----------
vec : 
ele_ref : 
ele_start : 
ele : 
datum_value : 
valid_value : 
datum : 
branch : 
why_invalid : 
good : 
)""");
  py::class_<PyTaoLoadThisDatum, std::unique_ptr<PyTaoLoadThisDatum>>(
      m, "TaoLoadThisDatum", "Fortran routine tao_load_this_datum return value")
      .def_readonly("datum_value", &PyTaoLoadThisDatum::datum_value)
      .def_readonly("valid_value", &PyTaoLoadThisDatum::valid_value)
      .def_readonly("why_invalid", &PyTaoLoadThisDatum::why_invalid)
      .def("__len__", [](const PyTaoLoadThisDatum&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoLoadThisDatum& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.datum_value);
            if (i == 1)
              return py::cast(s.valid_value);
            if (i == 2)
              return py::cast(s.why_invalid);
            return py::none();
          });
  m.def(
      "tao_datum_s_position",
      &Tao::tao_datum_s_position,
      py::arg("datum"),
      py::arg("ele"),
      R"""(Routine to calculate the longitudinal position associated with a datum.

Parameters
----------
datum : TaoDataStruct
    Datum under conideration.
ele : EleStruct
    Associated lattice element. Output
s_pos : float
    Associated longitudinal position.

Returns
-------
s_pos
)""");
  m.def(
      "tao_datum_integrate",
      &Tao::tao_datum_integrate,
      py::arg("datum"),
      py::arg("branch"),
      py::arg("s_pos"),
      py::arg("values"),
      R"""(Routine to calculate the integral, rms, or average of an array of values associated with a datum.

Parameters
----------
datum : TaoDataStruct
    Datum under consideration.
branch : BranchStruct
    Associated lattice branch.
s_pos : float
    Array of s-positions of the values.
values : float
    Array of values.

Return value is a dictionary containing values below.


Returns
-------
valid_value : bool
    Set false if, for example, all s_pos(:) are the same.
why_invalid : unknown
    Information string if there is a problem.
result : float
    Integral, rms, or average depending upon datum.merit_type.
)""");
  py::class_<Tao::TaoDatumIntegrate, std::unique_ptr<Tao::TaoDatumIntegrate>>(
      m,
      "TaoDatumIntegrate",
      "Fortran routine tao_datum_integrate return value")
      .def_readonly("valid_value", &Tao::TaoDatumIntegrate::valid_value)
      .def_readonly("why_invalid", &Tao::TaoDatumIntegrate::why_invalid)
      .def_readonly("result", &Tao::TaoDatumIntegrate::result)
      .def("__len__", [](const Tao::TaoDatumIntegrate&) { return 3; })
      .def(
          "__getitem__",
          [](const Tao::TaoDatumIntegrate& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.valid_value);
            if (i == 1)
              return py::cast(s.why_invalid);
            if (i == 2)
              return py::cast(s.result);
            return py::none();
          });
  m.def(
      "tao_tracking_ele_index",
      &Tao::tao_tracking_ele_index,
      py::arg("ele"),
      py::arg("datum"),
      R"""(Routine to return the index in the tracking part of a lattice that corresponds to ele.

Parameters
----------
ele : EleStruct
    Lattice element.
datum : TaoDataStruct
    Datum

Return value is a dictionary containing values below.


Returns
-------
ix_branch : int
    Lattice branch associated with element
ix_ele : int
    Element index associated with ele.
)""");
  py::class_<
      Tao::TaoTrackingEleIndex,
      std::unique_ptr<Tao::TaoTrackingEleIndex>>(
      m,
      "TaoTrackingEleIndex",
      "Fortran routine tao_tracking_ele_index return value")
      .def_readonly("ix_branch", &Tao::TaoTrackingEleIndex::ix_branch)
      .def_readonly("ix_ele", &Tao::TaoTrackingEleIndex::ix_ele)
      .def("__len__", [](const Tao::TaoTrackingEleIndex&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoTrackingEleIndex& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_branch);
            if (i == 1)
              return py::cast(s.ix_ele);
            return py::none();
          });
  m.def(
      "integrate_min",
      &python_integrate_min,
      py::arg("ix_start"),
      py::arg("ix_ele"),
      py::arg("datum_value"),
      py::arg("ix_m"),
      py::arg("branch"),
      py::arg("vec"),
      py::arg("datum"),
      R"""(No docstring available

Parameters
----------
ix_start : 
ix_ele : 
datum_value : 
ix_m : 
branch : 
vec : 
datum : 
)""");
  py::class_<PyIntegrateMin, std::unique_ptr<PyIntegrateMin>>(
      m, "IntegrateMin", "Fortran routine integrate_min return value")
      .def_readonly("ix_start", &PyIntegrateMin::ix_start)
      .def_readonly("ix_ele", &PyIntegrateMin::ix_ele)
      .def_readonly("datum_value", &PyIntegrateMin::datum_value)
      .def_readonly("ix_m", &PyIntegrateMin::ix_m)
      .def("__len__", [](const PyIntegrateMin&) { return 4; })
      .def("__getitem__", [](const PyIntegrateMin& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ix_start);
        if (i == 1)
          return py::cast(s.ix_ele);
        if (i == 2)
          return py::cast(s.datum_value);
        if (i == 3)
          return py::cast(s.ix_m);
        return py::none();
      });
  m.def(
      "integrate_max",
      &python_integrate_max,
      py::arg("ix_start"),
      py::arg("ix_ele"),
      py::arg("datum_value"),
      py::arg("ix_m"),
      py::arg("branch"),
      py::arg("vec"),
      py::arg("datum"),
      R"""(No docstring available

Parameters
----------
ix_start : 
ix_ele : 
datum_value : 
ix_m : 
branch : 
vec : 
datum : 
)""");
  py::class_<PyIntegrateMax, std::unique_ptr<PyIntegrateMax>>(
      m, "IntegrateMax", "Fortran routine integrate_max return value")
      .def_readonly("ix_start", &PyIntegrateMax::ix_start)
      .def_readonly("ix_ele", &PyIntegrateMax::ix_ele)
      .def_readonly("datum_value", &PyIntegrateMax::datum_value)
      .def_readonly("ix_m", &PyIntegrateMax::ix_m)
      .def("__len__", [](const PyIntegrateMax&) { return 4; })
      .def("__getitem__", [](const PyIntegrateMax& s, size_t i) -> py::object {
        if (i >= 4)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.ix_start);
        if (i == 1)
          return py::cast(s.ix_ele);
        if (i == 2)
          return py::cast(s.datum_value);
        if (i == 3)
          return py::cast(s.ix_m);
        return py::none();
      });
  m.def(
      "tao_scratch_values_calc",
      &Tao::tao_scratch_values_calc,
      py::arg("ele_ref"),
      py::arg("ele_start"),
      py::arg("ele"),
      py::arg("datum"),
      py::arg("branch"),
      py::arg("orbit"),
      R"""(No docstring available

Parameters
----------
ele_ref : 
ele_start : 
ele : 
datum : 
branch : 
orbit : 
)""");
  m.def(
      "tao_do_wire_scan",
      &Tao::tao_do_wire_scan,
      py::arg("ele"),
      py::arg("theta"),
      py::arg("beam"),
      R"""(Returns the beam's second moment using the wire along the specified angle.

Keep in mind that the actual correlation axis is 90 degrees off of the
wire angle
This simulates a fast wire scanner that performs the scan over only one
bunch. Obviously, this isn't realistic. Any dynamic effects will not be
accounted for!

Parameters
----------
ele : ElementStruct
    .value(noise$) -- relative wire resolution RMS .value(tilt$)  -- wire angle error in radians rms.
theta : float
    wire angle wrt x axis (in degrees)
beam : BeamStruct
    contains the beam distribution

Returns
-------
moment : float
    second moment along axis specified by angle.
)""");
  m.def(
      "tao_pointer_to_datum_ele",
      &python_tao_pointer_to_datum_ele,
      py::arg("lat"),
      py::arg("ele_name"),
      py::arg("ix_ele"),
      py::arg("datum"),
      py::arg("print_err") = py::none(),
      R"""(Routine to see if an element index corresponds to an element with a definite

location such as an overlay or multipass element.
If the element is a super_lord then the super_slave element at the exit end
of the lord will be returned. Otherwise ix_loc will be set to ix_ele.

Parameters
----------
lat : LatStruct
    Lattice
ix_ele : int
    Index of element.
datum : TaoDataStruct
    Used for error messages and gives branch index.
print_err : bool, optional
    Default is True. If False, do not print an error message.

Return value is a dictionary containing values below.


Returns
-------
ele : EleStruct
    : Pointer to the element. Set to NULL if not valid or no associated element.
valid : bool
    Set False if element does not have a definite location. Set True otherwise
why_invalid : unknown
    Tells why datum value is invalid.
)""");
  py::class_<PyTaoPointerToDatumEle, std::unique_ptr<PyTaoPointerToDatumEle>>(
      m,
      "TaoPointerToDatumEle",
      "Fortran routine tao_pointer_to_datum_ele return value")
      .def_readonly("valid", &PyTaoPointerToDatumEle::valid)
      .def_readonly("why_invalid", &PyTaoPointerToDatumEle::why_invalid)
      .def_readonly("ele", &PyTaoPointerToDatumEle::ele)
      .def_readonly("ele_name", &PyTaoPointerToDatumEle::ele_name)
      .def("__len__", [](const PyTaoPointerToDatumEle&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTaoPointerToDatumEle& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.valid);
            if (i == 1)
              return py::cast(s.why_invalid);
            if (i == 2)
              return py::cast(s.ele);
            if (i == 3)
              return py::cast(s.ele_name);
            return py::none();
          });
  m.def(
      "tao_evaluate_datum_at_s",
      &Tao::tao_evaluate_datum_at_s,
      py::arg("datum"),
      py::arg("tao_lat"),
      py::arg("ele"),
      py::arg("ele_ref"),
      py::arg("valid_value"),
      R"""(Routine to evaluate a datum at a given s-position in the lattice

Parameters
----------
datum : TaoDataStruct
    Datum to evaluate.
tao_lat : TaoLatticeStruct
ele : EleStruct
    Evaluation element.
ele_ref : EleStruct
    Reference element.
valid_value : bool
    True if evaluation was sucessful. False if not.

Return value is a dictionary containing values below.


Returns
-------
err_str : unknown
    Error string for printing an error message.
bad_datum : bool
    True -> datum is malformed. False -> Could evaluate or evaluation problem was not due to the datum itself
    (EG: the lattice was unstable).
value : float
    Datum value.
)""");
  py::class_<
      Tao::TaoEvaluateDatumAtS,
      std::unique_ptr<Tao::TaoEvaluateDatumAtS>>(
      m,
      "TaoEvaluateDatumAtS",
      "Fortran routine tao_evaluate_datum_at_s return value")
      .def_readonly("err_str", &Tao::TaoEvaluateDatumAtS::err_str)
      .def_readonly("bad_datum", &Tao::TaoEvaluateDatumAtS::bad_datum)
      .def_readonly("value", &Tao::TaoEvaluateDatumAtS::value)
      .def("__len__", [](const Tao::TaoEvaluateDatumAtS&) { return 3; })
      .def(
          "__getitem__",
          [](const Tao::TaoEvaluateDatumAtS& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_str);
            if (i == 1)
              return py::cast(s.bad_datum);
            if (i == 2)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "tao_to_int",
      &python_tao_to_int,
      py::arg("str"),
      py::arg("i_int"),
      py::arg("err"),
      R"""(Converts a string to an integer

If the string str is blank then i_int = 0

)""");
  py::class_<PyTaoToInt, std::unique_ptr<PyTaoToInt>>(
      m, "TaoToInt", "Fortran routine tao_to_int return value")
      .def_readonly("str", &PyTaoToInt::str)
      .def_readonly("i_int", &PyTaoToInt::i_int)
      .def_readonly("err", &PyTaoToInt::err)
      .def("__len__", [](const PyTaoToInt&) { return 3; })
      .def("__getitem__", [](const PyTaoToInt& s, size_t i) -> py::object {
        if (i >= 3)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.str);
        if (i == 1)
          return py::cast(s.i_int);
        if (i == 2)
          return py::cast(s.err);
        return py::none();
      });
  m.def(
      "tao_ele_geometry_with_misalignments",
      &Tao::tao_ele_geometry_with_misalignments,
      py::arg("datum"),
      py::arg("ele"),
      R"""(Routine to evaluate a floor position with misalignments at a given element.

This routine is private and not for general use.

Parameters
----------
datum : unknown
    Datum info
ele : EleStruct
    Lattice element to evaluate at.

Return value is a dictionary containing values below.


Returns
-------
valid_value : bool
    Was able to evalute the datum?
why_invalid : unknown
    If not valid, why not.
value : float
    Datum value.
)""");
  py::class_<
      Tao::TaoEleGeometryWithMisalignments,
      std::unique_ptr<Tao::TaoEleGeometryWithMisalignments>>(
      m,
      "TaoEleGeometryWithMisalignments",
      "Fortran routine tao_ele_geometry_with_misalignments return value")
      .def_readonly(
          "valid_value", &Tao::TaoEleGeometryWithMisalignments::valid_value)
      .def_readonly(
          "why_invalid", &Tao::TaoEleGeometryWithMisalignments::why_invalid)
      .def_readonly("value", &Tao::TaoEleGeometryWithMisalignments::value)
      .def(
          "__len__",
          [](const Tao::TaoEleGeometryWithMisalignments&) { return 3; })
      .def(
          "__getitem__",
          [](const Tao::TaoEleGeometryWithMisalignments& s,
             size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.valid_value);
            if (i == 1)
              return py::cast(s.why_invalid);
            if (i == 2)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "tao_eval_floor_orbit",
      &Tao::tao_eval_floor_orbit,
      py::arg("datum"),
      py::arg("ele"),
      py::arg("orbit"),
      py::arg("bunch_params"),
      R"""(Routine to evaluate a floor_orbit datum at a given element.

This routine is private and not for general use.

Parameters
----------
datum : unknown
    Datum info
ele : EleStruct
    Lattice element to evaluate at.
orbit : CoordStruct
    Particle orbit at element.
bunch_params : BunchParamsStruct
    Bunch parameters at element.

Return value is a dictionary containing values below.


Returns
-------
valid_value : bool
    Was able to evalute the datum?
why_invalid : unknown
    If not valid, why not.
value : float
    Datum value.
)""");
  py::class_<Tao::TaoEvalFloorOrbit, std::unique_ptr<Tao::TaoEvalFloorOrbit>>(
      m,
      "TaoEvalFloorOrbit",
      "Fortran routine tao_eval_floor_orbit return value")
      .def_readonly("valid_value", &Tao::TaoEvalFloorOrbit::valid_value)
      .def_readonly("why_invalid", &Tao::TaoEvalFloorOrbit::why_invalid)
      .def_readonly("value", &Tao::TaoEvalFloorOrbit::value)
      .def("__len__", [](const Tao::TaoEvalFloorOrbit&) { return 3; })
      .def(
          "__getitem__",
          [](const Tao::TaoEvalFloorOrbit& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.valid_value);
            if (i == 1)
              return py::cast(s.why_invalid);
            if (i == 2)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "tao_use_var",
      &Tao::tao_use_var,
      py::arg("action"),
      py::arg("var_name"),
      R"""(No docstring available

Parameters
----------
action : unknown
    'use', 'veto', or 'restore'
var_name : unknown
    the selected variable name or all
)""");
  m.def(
      "tao_parse_element_param_str",
      &Tao::tao_parse_element_param_str,
      py::arg("in_str"),
      R"""(No docstring available

Parameters
----------
err : bool
    Set True if there is a parse error. False otherwise.
in_str : unknown
    String specifying a parameter of an element or elements.
uni : unknown
    Universe substring.
element : unknown
    Element name.
parameter : unknown
    Element parameter name.
where : int
    One of not_set$, anchor_beginning$, anchor_center$, or anchor_end$.
component : unknown
    One of "model", "design", or "base".
)""");
  py::class_<
      Tao::TaoParseElementParamStr,
      std::unique_ptr<Tao::TaoParseElementParamStr>>(
      m,
      "TaoParseElementParamStr",
      "Fortran routine tao_parse_element_param_str return value")
      .def_readonly("err", &Tao::TaoParseElementParamStr::err)
      .def_readonly("uni", &Tao::TaoParseElementParamStr::uni)
      .def_readonly("element", &Tao::TaoParseElementParamStr::element)
      .def_readonly("parameter", &Tao::TaoParseElementParamStr::parameter)
      .def_readonly("where", &Tao::TaoParseElementParamStr::where)
      .def_readonly("component", &Tao::TaoParseElementParamStr::component)
      .def("__len__", [](const Tao::TaoParseElementParamStr&) { return 6; })
      .def(
          "__getitem__",
          [](const Tao::TaoParseElementParamStr& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err);
            if (i == 1)
              return py::cast(s.uni);
            if (i == 2)
              return py::cast(s.element);
            if (i == 3)
              return py::cast(s.parameter);
            if (i == 4)
              return py::cast(s.where);
            if (i == 5)
              return py::cast(s.component);
            return py::none();
          });
  m.def(
      "tao_data_coupling_init",
      &Tao::tao_data_coupling_init,
      py::arg("branch"),
      R"""(No docstring available

Parameters
----------
branch : BranchStruct
    New lattice branch.
)""");
  m.def(
      "tao_write_cmd",
      &Tao::tao_write_cmd,
      py::arg("what"),
      R"""(No docstring available

Parameters
----------
what : unknown
    What to output. See the code for more details.
)""");
  m.def(
      "tao_x_axis_cmd",
      &Tao::tao_x_axis_cmd,
      py::arg("where"),
      py::arg("what"),
      R"""(No docstring available

Parameters
----------
where : unknown
    Region to axis. Eg: "top"
what : unknown
    "s" or "index"
)""");
  m.def(
      "tao_merit",
      &python_tao_merit,
      py::arg("this_merit"),
      R"""(No docstring available

Parameters
----------
calc_ok : bool
    Set False if there was an error in the calculation like a particle was lost or a lat is unstable.
this_merit : 
)""");
  py::class_<PyTaoMerit, std::unique_ptr<PyTaoMerit>>(
      m, "TaoMerit", "Fortran routine tao_merit return value")
      .def_readonly("calc_ok", &PyTaoMerit::calc_ok)
      .def_readonly("this_merit", &PyTaoMerit::this_merit)
      .def("__len__", [](const PyTaoMerit&) { return 2; })
      .def("__getitem__", [](const PyTaoMerit& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.calc_ok);
        if (i == 1)
          return py::cast(s.this_merit);
        return py::none();
      });
  m.def(
      "tao_d2_d1_name",
      &python_tao_d2_d1_name,
      py::arg("d1"),
      py::arg("show_universe") = py::none(),
      py::arg("d2_d1_name"),
      R"""(No docstring available

Parameters
----------
d1 : TaoD1DataStruct
    Data array.
show_universe : bool, optional
    Show the datum's universe. Default is True.
d2_d1_name : 
)""");
  py::class_<PyTaoD2D1Name, std::unique_ptr<PyTaoD2D1Name>>(
      m, "TaoD2D1Name", "Fortran routine tao_d2_d1_name return value")
      .def_readonly("d2_d1_name", &PyTaoD2D1Name::d2_d1_name)
      .def("__len__", [](const PyTaoD2D1Name&) { return 1; })
      .def("__getitem__", [](const PyTaoD2D1Name& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.d2_d1_name);
        return py::none();
      });
  m.def(
      "tao_param_value_at_s",
      &python_tao_param_value_at_s,
      py::arg("dat_name"),
      py::arg("ele_to_s"),
      py::arg("ele_here"),
      py::arg("orbit"),
      py::arg("value"),
      R"""(No docstring available

Parameters
----------
dat_name : 
ele_to_s : EleStruct
    Element whose exit end is at the evaluation s-position.
ele_here : EleStruct
    Lattice element that overlaps the s-position ele.s.
orbit : CoordStruct
    Orbit at the evaluation s-position.
err_flag : bool
    Set true if parameter cannot be evaluated.
why_invalid : unknown
    Set if  err_flag = True to document why is there a problem.
print_err : bool
    Print error message on error? Default is True.
bad_datum : bool
    Data_type is malformed.
value : 
)""");
  py::class_<PyTaoParamValueAtS, std::unique_ptr<PyTaoParamValueAtS>>(
      m,
      "TaoParamValueAtS",
      "Fortran routine tao_param_value_at_s return value")
      .def_readonly("err_flag", &PyTaoParamValueAtS::err_flag)
      .def_readonly("why_invalid", &PyTaoParamValueAtS::why_invalid)
      .def_readonly("print_err", &PyTaoParamValueAtS::print_err)
      .def_readonly("bad_datum", &PyTaoParamValueAtS::bad_datum)
      .def_readonly("dat_name", &PyTaoParamValueAtS::dat_name)
      .def_readonly("value", &PyTaoParamValueAtS::value)
      .def("__len__", [](const PyTaoParamValueAtS&) { return 6; })
      .def(
          "__getitem__",
          [](const PyTaoParamValueAtS& s, size_t i) -> py::object {
            if (i >= 6)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err_flag);
            if (i == 1)
              return py::cast(s.why_invalid);
            if (i == 2)
              return py::cast(s.print_err);
            if (i == 3)
              return py::cast(s.bad_datum);
            if (i == 4)
              return py::cast(s.dat_name);
            if (i == 5)
              return py::cast(s.value);
            return py::none();
          });
  m.def(
      "tao_show_cmd",
      &Tao::tao_show_cmd,
      py::arg("what"),
      R"""(No docstring available

Parameters
----------
what : unknown
    What to show.
)""");
  m.def(
      "tao_evaluate_tune",
      &python_tao_evaluate_tune,
      py::arg("q_str"),
      py::arg("q0"),
      py::arg("delta_input"),
      py::arg("q_val"),
      R"""(No docstring available

Parameters
----------
q_str : unknown
    String expression.
q0 : float
    Default to use if q_str evaluates to zero. Also used to set the integer part of the tune.
delta_input : bool
    If true then qa_str and qb_str are deltas from present tune. Outut:
q_val : 
)""");
  py::class_<PyTaoEvaluateTune, std::unique_ptr<PyTaoEvaluateTune>>(
      m, "TaoEvaluateTune", "Fortran routine tao_evaluate_tune return value")
      .def_readonly("q_val", &PyTaoEvaluateTune::q_val)
      .def("__len__", [](const PyTaoEvaluateTune&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoEvaluateTune& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.q_val);
            return py::none();
          });
  m.def(
      "re_allocate_c_double",
      &python_re_allocate_c_double,
      py::arg("re"),
      py::arg("n"),
      py::arg("exact") = py::none(),
      py::arg("init_val") = py::none(),
      R"""(Routine to reallocate an array of c_double reals.

This is modeled after the reallocate functions in Numerical Recipes.

Parameters
----------
re : float
    Real array.
    This parameter is an input/output and is modified in-place. As an output: Allocated array with size(re) >=
    n.
n : int
    Size wanted.
exact : bool, optional
    If present and False then the size of the output array is permitted to be larger than n. Default is True.
)""");
  py::class_<PyReAllocateCDouble, std::unique_ptr<PyReAllocateCDouble>>(
      m,
      "ReAllocateCDouble",
      "Fortran routine re_allocate_c_double return value")
      .def_readonly("init_val", &PyReAllocateCDouble::init_val)
      .def("__len__", [](const PyReAllocateCDouble&) { return 1; })
      .def(
          "__getitem__",
          [](const PyReAllocateCDouble& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.init_val);
            return py::none();
          });
  m.def(
      "tao_c_out_io_buffer_reset",
      &Tao::tao_c_out_io_buffer_reset,
      R"""(Routine to reset the buffer.

)""");
  m.def(
      "tao_subin_uni_number",
      &python_tao_subin_uni_number,
      py::arg("name_in"),
      py::arg("ix_uni"),
      py::arg("ok"),
      R"""(No docstring available

Parameters
----------
name_in : unknown
    Input name with "#" character
ix_uni : int
    Universe index.
name_out : unknown
    Output name.
ok : 
)""");
  py::class_<PyTaoSubinUniNumber, std::unique_ptr<PyTaoSubinUniNumber>>(
      m,
      "TaoSubinUniNumber",
      "Fortran routine tao_subin_uni_number return value")
      .def_readonly("name_out", &PyTaoSubinUniNumber::name_out)
      .def_readonly("ok", &PyTaoSubinUniNumber::ok)
      .def("__len__", [](const PyTaoSubinUniNumber&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoSubinUniNumber& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.name_out);
            if (i == 1)
              return py::cast(s.ok);
            return py::none();
          });
  m.def(
      "tao_parse_command_args",
      &python_tao_parse_command_args,
      py::arg("cmd_line") = py::none(),
      R"""(No docstring available

Parameters
----------
error : bool
    Set True if there is an error. False otherwise.
cmd_line : 
)""");
  py::class_<PyTaoParseCommandArgs, std::unique_ptr<PyTaoParseCommandArgs>>(
      m,
      "TaoParseCommandArgs",
      "Fortran routine tao_parse_command_args return value")
      .def_readonly("error", &PyTaoParseCommandArgs::error)
      .def_readonly("cmd_line", &PyTaoParseCommandArgs::cmd_line)
      .def("__len__", [](const PyTaoParseCommandArgs&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoParseCommandArgs& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.error);
            if (i == 1)
              return py::cast(s.cmd_line);
            return py::none();
          });
  m.def(
      "tao_chrom_calc_needed",
      &python_tao_chrom_calc_needed,
      py::arg("data_type"),
      py::arg("data_source"),
      py::arg("do_chrom"),
      R"""(No docstring available

Parameters
----------
data_type : 
data_source : 
do_chrom : 
)""");
  py::class_<PyTaoChromCalcNeeded, std::unique_ptr<PyTaoChromCalcNeeded>>(
      m,
      "TaoChromCalcNeeded",
      "Fortran routine tao_chrom_calc_needed return value")
      .def_readonly("data_type", &PyTaoChromCalcNeeded::data_type)
      .def_readonly("data_source", &PyTaoChromCalcNeeded::data_source)
      .def_readonly("do_chrom", &PyTaoChromCalcNeeded::do_chrom)
      .def("__len__", [](const PyTaoChromCalcNeeded&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoChromCalcNeeded& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data_type);
            if (i == 1)
              return py::cast(s.data_source);
            if (i == 2)
              return py::cast(s.do_chrom);
            return py::none();
          });
  m.def(
      "tao_lm_optimizer",
      &Tao::tao_lm_optimizer,
      R"""(Routine to minimize the merit function by varying variables until

the "data" as calculated from the model matches the measured data.
This subroutine is a wrapper for the mrqmin routine of Numerical Recipes.
See the Numerical Recipes writeup for more details.
'lm' stands for Levenburg - Marquardt. Otherwise known as LMDIF.


Returns
-------
abort : bool
    Set True if an user stop signal detected.
)""");
  m.def(
      "tao_pointer_to_universes",
      &Tao::tao_pointer_to_universes,
      py::arg("name_in"),
      py::arg("dflt_uni") = py::none(),
      R"""(No docstring available

Parameters
----------
name_in : unknown
    data name with possible universe spec.
unis : TaoUniversePointerStruct
    Array of pointers to picked universes. The array will be resized if necessary.
err : bool
    Set True if an error is detected.
name_out : unknown
    name_in without any "n@" beginning.
explicit_uni : bool
    Set True if name_in has explicit universe "n@" specification.
dflt_uni : int, optional
    Default universe to use. Set to -1 if explicit universe is required.
)""");
  py::class_<
      Tao::TaoPointerToUniverses,
      std::unique_ptr<Tao::TaoPointerToUniverses>>(
      m,
      "TaoPointerToUniverses",
      "Fortran routine tao_pointer_to_universes return value")
      .def_readonly("unis", &Tao::TaoPointerToUniverses::unis)
      .def_readonly("err", &Tao::TaoPointerToUniverses::err)
      .def_readonly("name_out", &Tao::TaoPointerToUniverses::name_out)
      .def_readonly("explicit_uni", &Tao::TaoPointerToUniverses::explicit_uni)
      .def("__len__", [](const Tao::TaoPointerToUniverses&) { return 4; })
      .def(
          "__getitem__",
          [](const Tao::TaoPointerToUniverses& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.unis);
            if (i == 1)
              return py::cast(s.err);
            if (i == 2)
              return py::cast(s.name_out);
            if (i == 3)
              return py::cast(s.explicit_uni);
            return py::none();
          });
  m.def(
      "tao_var_attrib_name",
      &python_tao_var_attrib_name,
      py::arg("var"),
      py::arg("var_attrib_name"),
      R"""(No docstring available

Parameters
----------
var : TaoVarStruct
    Variable
var_attrib_name : 
)""");
  py::class_<PyTaoVarAttribName, std::unique_ptr<PyTaoVarAttribName>>(
      m, "TaoVarAttribName", "Fortran routine tao_var_attrib_name return value")
      .def_readonly("var_attrib_name", &PyTaoVarAttribName::var_attrib_name)
      .def("__len__", [](const PyTaoVarAttribName&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoVarAttribName& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.var_attrib_name);
            return py::none();
          });
  m.def(
      "tao_floor_to_screen",
      &Tao::tao_floor_to_screen,
      py::arg("graph"),
      py::arg("r_floor"),
      R"""(No docstring available

Parameters
----------
graph : TaoGraphStruct
    Graph defining the projection plane.
r_floor : 
x_screen : float
    x-coordinate of projected point.
y_screen : float
    y-coordinate of projected point.
)""");
  py::class_<Tao::TaoFloorToScreen, std::unique_ptr<Tao::TaoFloorToScreen>>(
      m, "TaoFloorToScreen", "Fortran routine tao_floor_to_screen return value")
      .def_readonly("x_screen", &Tao::TaoFloorToScreen::x_screen)
      .def_readonly("y_screen", &Tao::TaoFloorToScreen::y_screen)
      .def("__len__", [](const Tao::TaoFloorToScreen&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoFloorToScreen& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.x_screen);
            if (i == 1)
              return py::cast(s.y_screen);
            return py::none();
          });
  m.def(
      "tao_var_useit_plot_calc",
      &Tao::tao_var_useit_plot_calc,
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
graph : 
var : TaoVarStruct
    .useit_plot -- True if good for plotting.
)""");
  m.def(
      "tao_get_user_input",
      &Tao::tao_get_user_input,
      py::arg("prompt_str") = py::none(),
      py::arg("wait_flag") = py::none(),
      py::arg("cmd_in") = py::none(),
      R"""(Subroutine to get the next Tao command. In order of precedence, input may come from:

1) s%com%cmd string (if s%com%use_cmd_here is set to True).
Used for recalling commands from the history stack.
2) A saved command string.
3) A command file.
4) The cmd_in argument (if present). Used, for example, when interfacing with Python.
5) The terminal.
For example, the following string is read from a command file or terminal or passed via cmd_in:
"show ele 1; set opti de; run"
Then cmd_out would be "show ele 1" and "set opti de; run" would be saved for the next call to this routine.

Parameters
----------
prompt_str : unknown, optional
    Primpt string to print at terminal. If not present then s.global.prompt_string will be used.
wait_flag : bool, optional
    Used for single mode: Wait state for get_a_char call.
cmd_in : unknown, optional
    Command to be used in place getting user input.

Returns
-------
cmd_out : unknown
    Command from the user.

Notes
-----
Note: A saved command string is present if a prior input string contained multiple commands.
)""");
  m.def(
      "tao_top10_merit_categories_print",
      &Tao::tao_top10_merit_categories_print,
      py::arg("iunit"),
      R"""(Routine to print the top data and variable categories that contribute to

the merit function.

Parameters
----------
iunit : int
    File unit to write to. 0 => print to the terminal.
)""");
  m.def(
      "tao_top10_derivative_print",
      &Tao::tao_top10_derivative_print,
      R"""(Routine to print out the top10 contributors to the merit function.

)""");
  m.def(
      "tao_show_constraints",
      &Tao::tao_show_constraints,
      py::arg("iunit"),
      py::arg("form"),
      R"""(Routine to show a list of datums and variables and how they contribute to the merit function.

Parameters
----------
iunit : int
    File unit to write to. 0 => print to the terminal.
form : unknown
    What to output: 'ALL'   -> All datums and variables. 'TOP10' -> Top datums and variables that contribute
    to the merit function.
)""");
  m.def(
      "tao_var_write",
      &Tao::tao_var_write,
      py::arg("out_file"),
      py::arg("show_good_opt_only") = py::none(),
      py::arg("tao_format") = py::none(),
      R"""(Routine to write the optimized variables. One file will be created for each universe.

The created file will have three sections:
1) The variable values
2) The list of constraints.
3) A list of the top 10 constraints.
If out_file = '' the information will be dumped to the terminal.
In this case, only the variable values will be printed.
When tao_format = True, the output is in the form "set variable <name> = <value>"
so the file can be used as a Tao command file. If tao_format = False, the format
is suitable for inclusion in a Bmad lattice file.

Parameters
----------
out_file : unknown
    Name of output file. If blank. Ouput to the terminal.
show_good_opt_only : bool, optional
    Write only the variables used in the optimization? Default is False.
tao_format : bool, optional
    Output format. Default False. See above.
)""");
  m.def(
      "tao_spin_tracking_turn_on",
      &Tao::tao_spin_tracking_turn_on,
      R"""(No docstring available

)""");
  m.def(
      "tao_init_data",
      &Tao::tao_init_data,
      py::arg("data_file"),
      R"""(Subroutine to initialize the tao data structures.

Parameters
----------
data_file : unknown
    Tao data initialization file. If blank, there is no file so just use the defaults.
)""");
  m.def(
      "tao_init_data_end_stuff",
      &Tao::tao_init_data_end_stuff,
      R"""(No docstring available

)""");
  m.def(
      "tao_allocate_data_array",
      &python_tao_allocate_data_array,
      py::arg("u"),
      py::arg("n_data"),
      py::arg("exact") = py::none(),
      R"""(No docstring available

Parameters
----------
u : 
n_data : 
exact : 
)""");
  py::class_<PyTaoAllocateDataArray, std::unique_ptr<PyTaoAllocateDataArray>>(
      m,
      "TaoAllocateDataArray",
      "Fortran routine tao_allocate_data_array return value")
      .def_readonly("n_data", &PyTaoAllocateDataArray::n_data)
      .def_readonly("exact", &PyTaoAllocateDataArray::exact)
      .def("__len__", [](const PyTaoAllocateDataArray&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoAllocateDataArray& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.n_data);
            if (i == 1)
              return py::cast(s.exact);
            return py::none();
          });
  m.def(
      "tao_d2_data_stuffit",
      &python_tao_d2_data_stuffit,
      py::arg("u"),
      py::arg("d2_name"),
      py::arg("n_d1_data"),
      R"""(No docstring available

Parameters
----------
u : 
d2_name : 
n_d1_data : 
)""");
  py::class_<PyTaoD2DataStuffit, std::unique_ptr<PyTaoD2DataStuffit>>(
      m, "TaoD2DataStuffit", "Fortran routine tao_d2_data_stuffit return value")
      .def_readonly("d2_name", &PyTaoD2DataStuffit::d2_name)
      .def_readonly("n_d1_data", &PyTaoD2DataStuffit::n_d1_data)
      .def("__len__", [](const PyTaoD2DataStuffit&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoD2DataStuffit& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.d2_name);
            if (i == 1)
              return py::cast(s.n_d1_data);
            return py::none();
          });
  m.def(
      "tao_init_data_in_universe",
      &python_tao_init_data_in_universe,
      py::arg("u"),
      py::arg("n_d2_add"),
      py::arg("keep_existing_data") = py::none(),
      R"""(No docstring available

Parameters
----------
u : 
n_d2_add : 
keep_existing_data : 
)""");
  py::class_<PyTaoInitDataInUniverse, std::unique_ptr<PyTaoInitDataInUniverse>>(
      m,
      "TaoInitDataInUniverse",
      "Fortran routine tao_init_data_in_universe return value")
      .def_readonly("n_d2_add", &PyTaoInitDataInUniverse::n_d2_add)
      .def_readonly(
          "keep_existing_data", &PyTaoInitDataInUniverse::keep_existing_data)
      .def("__len__", [](const PyTaoInitDataInUniverse&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoInitDataInUniverse& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.n_d2_add);
            if (i == 1)
              return py::cast(s.keep_existing_data);
            return py::none();
          });
  m.def(
      "tao_add_to_normal_mode_h_array",
      &Tao::tao_add_to_normal_mode_h_array,
      py::arg("h_str"),
      R"""(Routine to add on to the "h(:)" array holding the list of normal form

resonance driving terms to calculate.
If h_str is already in the h_array(:) list, nothing is done.

Parameters
----------
h_str : unknown
    Resonance driving term ID. EG: "110000"

Returns
-------
h_array : ResonanceHStruct
    Array of resonance driving terms.
)""");
  m.def(
      "tao_plot_setup",
      &Tao::tao_plot_setup,
      R"""(No docstring available

)""");
  m.def(
      "tao_set_var_useit_opt",
      &Tao::tao_set_var_useit_opt,
      R"""(No docstring available

)""");
  m.def(
      "tao_graph_setup",
      &Tao::tao_graph_setup,
      py::arg("plot"),
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
)""");
  m.def(
      "tao_graph_controller_setup",
      &Tao::tao_graph_controller_setup,
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
graph : 
)""");
  m.def(
      "tao_graph_data_slice_setup",
      &Tao::tao_graph_data_slice_setup,
      py::arg("plot"),
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
)""");
  m.def(
      "tao_data_type_substitute",
      &Tao::tao_data_type_substitute,
      py::arg("template_"),
      py::arg("curve"),
      py::arg("graph"),
      R"""(Routine substitute the appropriate data type string for instances of "#ref" and

"#comp" in template.
Additionally, if template does not have a "|" character,
the string "|" + component will be added at the end of str_out.

Parameters
----------
template : unknown
    String template.
curve : TaoCurveStruct
    curve.ele_ref_name is substituted for all instances of "#ref".
graph : TaoGraphStruct

Returns
-------
str_out : unknown
    String with substitutions.
)""");
  m.def(
      "tao_graph_phase_space_setup",
      &Tao::tao_graph_phase_space_setup,
      py::arg("plot"),
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
)""");
  m.def(
      "tao_graph_dynamic_aperture_setup",
      &Tao::tao_graph_dynamic_aperture_setup,
      py::arg("plot"),
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
)""");
  m.def(
      "tao_curve_beam_ellipse_setup",
      &Tao::tao_curve_beam_ellipse_setup,
      py::arg("curve"),
      R"""(No docstring available

Parameters
----------
curve : 
)""");
  m.def(
      "tao_graph_histogram_setup",
      &Tao::tao_graph_histogram_setup,
      py::arg("plot"),
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
)""");
  m.def(
      "tao_phase_space_axis_index",
      &Tao::tao_phase_space_axis_index,
      py::arg("data_type"),
      py::arg("err"),
      R"""(Routine to calculate the phase space axis index for a given data type.

Parameters
----------
data_type : unknown
    Type of data.
err : bool
    Set True if there is an error.

Returns
-------
ix_axis : int
    Axis index.
)""");
  m.def(
      "tao_particle_data_value",
      &Tao::tao_particle_data_value,
      py::arg("data_type"),
      py::arg("p"),
      py::arg("ele"),
      py::arg("ix_bunch"),
      R"""(Routine to calculate the value array of a data_type for an array of particles.

Parameters
----------
data_type : unknown
    Type of data.
p : 
    coord_struct, Array of particles containing the data.
ele : EleStruct
    Needed for "Ja" evaluation.
ix_bunch : int
    Bunch index.

Return value is a dictionary containing values below.


Returns
-------
value : float
    Array of values.
err : bool
    Set True if there is an error. False otherwise.
)""");
  py::class_<
      Tao::TaoParticleDataValue,
      std::unique_ptr<Tao::TaoParticleDataValue>>(
      m,
      "TaoParticleDataValue",
      "Fortran routine tao_particle_data_value return value")
      .def_readonly("value", &Tao::TaoParticleDataValue::value)
      .def_readonly("err", &Tao::TaoParticleDataValue::err)
      .def("__len__", [](const Tao::TaoParticleDataValue&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoParticleDataValue& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.value);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "tao_graph_data_setup",
      &Tao::tao_graph_data_setup,
      py::arg("plot"),
      py::arg("graph"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
)""");
  m.def(
      "tao_curve_data_setup",
      &Tao::tao_curve_data_setup,
      py::arg("plot"),
      py::arg("graph"),
      py::arg("curve"),
      R"""(No docstring available

Parameters
----------
plot : 
graph : 
curve : 
)""");
  m.def(
      "tao_calc_data_at_s_pts",
      &python_tao_calc_data_at_s_pts,
      py::arg("tao_lat"),
      py::arg("curve"),
      py::arg("comp_sign"),
      py::arg("good"),
      R"""(No docstring available

Parameters
----------
tao_lat : 
curve : 
comp_sign : 
good : 
)""");
  py::class_<PyTaoCalcDataAtSPts, std::unique_ptr<PyTaoCalcDataAtSPts>>(
      m,
      "TaoCalcDataAtSPts",
      "Fortran routine tao_calc_data_at_s_pts return value")
      .def_readonly("comp_sign", &PyTaoCalcDataAtSPts::comp_sign)
      .def("__len__", [](const PyTaoCalcDataAtSPts&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoCalcDataAtSPts& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.comp_sign);
            return py::none();
          });
  m.def(
      "tao_data_useit_plot_calc",
      &Tao::tao_data_useit_plot_calc,
      py::arg("curve"),
      py::arg("graph"),
      py::arg("check_s_position"),
      R"""(Routine to set the data for plotting.

Parameters
----------
graph : 
    tao_graph_struct
curve : 
    tao_curve_struct
check_s_position : bool
    If present and True then veto data that does not have an s-position.

Return value is a dictionary containing values below.


Returns
-------
data : TaoDataStruct
    .useit_plot         -- True if good for plotting.
most_invalid : unknown
    String documenting biggest invalid data problem.
)""");
  py::class_<
      Tao::TaoDataUseitPlotCalc,
      std::unique_ptr<Tao::TaoDataUseitPlotCalc>>(
      m,
      "TaoDataUseitPlotCalc",
      "Fortran routine tao_data_useit_plot_calc return value")
      .def_readonly("data", &Tao::TaoDataUseitPlotCalc::data)
      .def_readonly("most_invalid", &Tao::TaoDataUseitPlotCalc::most_invalid)
      .def("__len__", [](const Tao::TaoDataUseitPlotCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoDataUseitPlotCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data);
            if (i == 1)
              return py::cast(s.most_invalid);
            return py::none();
          });
  m.def(
      "tao_curve_datum_calc",
      &Tao::tao_curve_datum_calc,
      py::arg("eles"),
      py::arg("plot"),
      py::arg("curve"),
      py::arg("who"),
      R"""(Routine to calculate datum values.

The values are calculated at the end of each eles(:)%ele element.

Parameters
----------
eles : ElePointerStruct
    Array of elements.
plot : TaoPlotStruct
curve : TaoCurveStruct
    This parameter is an input/output and is modified in-place. As an output: Structure holding the datum
    values
who : unknown
    Where to put the data. Either: "SYMBOL" or "LINE".
)""");
  m.def(
      "tao_set_curve_invalid",
      &Tao::tao_set_curve_invalid,
      py::arg("curve"),
      py::arg("why_invalid"),
      py::arg("print_err") = py::none(),
      R"""(Routine to set curve%valid to False.

Parameters
----------
curve : TaoCurveStruct
    Curve to set.
    This parameter is an input/output and is modified in-place. As an output: Curve properly set.
why_invalid : unknown
    Invalid information.
print_err : bool, optional
    If present and True then also print an error message.
)""");
  m.def(
      "tao_curve_check_universe",
      &Tao::tao_curve_check_universe,
      py::arg("curve"),
      py::arg("uni"),
      R"""(Routine to check if the universe associated with a curve exists and is on.

Parameters
----------
curve : TaoCurveStruct
    Curve to check.
    This parameter is an input/output and is modified in-place. As an output: Curve.valid set to False if
    needed.
uni : TaoUniverseStruct
    Associated universe

Returns
-------
is_ok : bool
    Set True if associated universe exists and is on.
)""");
  m.def(
      "tao_graph_s_min_max_calc",
      &Tao::tao_graph_s_min_max_calc,
      py::arg("graph"),
      py::arg("branch"),
      R"""(Routine to calculate min and max for a graph when plot%x_axis_type is set to "s".

Parameters
----------
graph : TaoGraphStruct
    Graph to calculate for.
branch : BranchStruct
    Associated lattice branch.

Return value is a dictionary containing values below.


Returns
-------
s_min : float
    Graph min. May be negative with graph.allow_wrap_around = T.
s_max : float
    Graph max.
)""");
  py::class_<
      Tao::TaoGraphSMinMaxCalc,
      std::unique_ptr<Tao::TaoGraphSMinMaxCalc>>(
      m,
      "TaoGraphSMinMaxCalc",
      "Fortran routine tao_graph_s_min_max_calc return value")
      .def_readonly("s_min", &Tao::TaoGraphSMinMaxCalc::s_min)
      .def_readonly("s_max", &Tao::TaoGraphSMinMaxCalc::s_max)
      .def("__len__", [](const Tao::TaoGraphSMinMaxCalc&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoGraphSMinMaxCalc& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.s_min);
            if (i == 1)
              return py::cast(s.s_max);
            return py::none();
          });
  m.def(
      "tao_constraint_type_name",
      &python_tao_constraint_type_name,
      py::arg("datum"),
      py::arg("datum_name"),
      R"""(No docstring available

Parameters
----------
datum : TaoDataStruct
    Datum
datum_name : 
)""");
  py::class_<PyTaoConstraintTypeName, std::unique_ptr<PyTaoConstraintTypeName>>(
      m,
      "TaoConstraintTypeName",
      "Fortran routine tao_constraint_type_name return value")
      .def_readonly("datum_name", &PyTaoConstraintTypeName::datum_name)
      .def("__len__", [](const PyTaoConstraintTypeName&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoConstraintTypeName& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.datum_name);
            return py::none();
          });
  m.def(
      "tao_read_cmd",
      &python_tao_read_cmd,
      py::arg("which"),
      py::arg("unis"),
      py::arg("file"),
      py::arg("silent"),
      R"""(No docstring available

Parameters
----------
which : 
unis : unknown
    Universes to apply to
file : 
silent : bool
    Silent
)""");
  py::class_<PyTaoReadCmd, std::unique_ptr<PyTaoReadCmd>>(
      m, "TaoReadCmd", "Fortran routine tao_read_cmd return value")
      .def_readonly("which", &PyTaoReadCmd::which)
      .def_readonly("file", &PyTaoReadCmd::file)
      .def("__len__", [](const PyTaoReadCmd&) { return 2; })
      .def("__getitem__", [](const PyTaoReadCmd& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.which);
        if (i == 1)
          return py::cast(s.file);
        return py::none();
      });
  m.def(
      "tao_get_opt_vars",
      &Tao::tao_get_opt_vars,
      R"""(No docstring available

Parameters
----------
var_value : float
    Variable model values.
var_step : float
    Variable step sizes.
var_delta : float
    Variable Merit deltas.
var_weight : float
    Variable weights in the merit function.
var_ix : int
    Variable s.var(:) indexes
ignore_if_weight_is_zero : bool
    If present and True then ignore all variables whose merit weight is zero.
ignore_if_not_limited : bool
    If present and True then ignore all variables with limit constraint that are not limited.
)""");
  py::class_<Tao::TaoGetOptVars, std::unique_ptr<Tao::TaoGetOptVars>>(
      m, "TaoGetOptVars", "Fortran routine tao_get_opt_vars return value")
      .def_readonly("var_value", &Tao::TaoGetOptVars::var_value)
      .def_readonly("var_step", &Tao::TaoGetOptVars::var_step)
      .def_readonly("var_delta", &Tao::TaoGetOptVars::var_delta)
      .def_readonly("var_weight", &Tao::TaoGetOptVars::var_weight)
      .def_readonly("var_ix", &Tao::TaoGetOptVars::var_ix)
      .def_readonly(
          "ignore_if_weight_is_zero",
          &Tao::TaoGetOptVars::ignore_if_weight_is_zero)
      .def_readonly(
          "ignore_if_not_limited", &Tao::TaoGetOptVars::ignore_if_not_limited)
      .def("__len__", [](const Tao::TaoGetOptVars&) { return 7; })
      .def(
          "__getitem__",
          [](const Tao::TaoGetOptVars& s, size_t i) -> py::object {
            if (i >= 7)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.var_value);
            if (i == 1)
              return py::cast(s.var_step);
            if (i == 2)
              return py::cast(s.var_delta);
            if (i == 3)
              return py::cast(s.var_weight);
            if (i == 4)
              return py::cast(s.var_ix);
            if (i == 5)
              return py::cast(s.ignore_if_weight_is_zero);
            if (i == 6)
              return py::cast(s.ignore_if_not_limited);
            return py::none();
          });
  m.def(
      "tao_init_variables",
      &Tao::tao_init_variables,
      py::arg("var_file"),
      R"""(Subroutine to initialize the tao variable structures.

Parameters
----------
var_file : unknown
    Tao variable initialization file. If blank, there is no file so just use the defaults.
)""");
  m.def(
      "tao_allocate_v1_var",
      &python_tao_allocate_v1_var,
      py::arg("n_v1"),
      py::arg("save_old"),
      R"""(No docstring available

Parameters
----------
n_v1 : 
save_old : 
)""");
  py::class_<PyTaoAllocateV1Var, std::unique_ptr<PyTaoAllocateV1Var>>(
      m, "TaoAllocateV1Var", "Fortran routine tao_allocate_v1_var return value")
      .def_readonly("n_v1", &PyTaoAllocateV1Var::n_v1)
      .def_readonly("save_old", &PyTaoAllocateV1Var::save_old)
      .def("__len__", [](const PyTaoAllocateV1Var&) { return 2; })
      .def(
          "__getitem__",
          [](const PyTaoAllocateV1Var& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.n_v1);
            if (i == 1)
              return py::cast(s.save_old);
            return py::none();
          });
  m.def(
      "tao_pointer_to_var_in_lattice",
      &Tao::tao_pointer_to_var_in_lattice,
      py::arg("var"),
      py::arg("ix_uni"),
      py::arg("ele"),
      R"""(Routine to add a pointer from a given Tao variable

to the appropriate variable in a lattice.

Parameters
----------
var : TaoVarStruct
    Structure has the info of where to point.
ix_uni : int
    the universe to use
ix_ele : int
    Index of element. var.slave(ix_slave) -- Tao_var_slave_struct: New component of .slave(:) array is added.
    .model_ptr .base_ptr .ix_ele .ix_uni

Returns
-------
err : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "tao_pointer_to_var_in_lattice2",
      &Tao::tao_pointer_to_var_in_lattice2,
      py::arg("var"),
      py::arg("ix_uni"),
      R"""(Routine to add a pointer from a given Tao variable

to the appropriate variable in a lattice.

Parameters
----------
var : TaoVarStruct
    Structure has the info of where to point.
ix_uni : int
    the universe to use var.slave(ix_slave) -- Tao_var_slave_struct: New component of .slave(:) array is
    added. .model_ptr .base_ptr .ix_ele .ix_uni

Returns
-------
err : bool
    Set True if there is an error. False otherwise.
)""");
  m.def(
      "tao_allocate_var_array",
      &python_tao_allocate_var_array,
      py::arg("n_var"),
      py::arg("default_good_user"),
      R"""(Routine to increase the s%var(:) array size.

Parameters
----------
n_var : int
    Size of s.var(:) wanted.
)""");
  py::class_<PyTaoAllocateVarArray, std::unique_ptr<PyTaoAllocateVarArray>>(
      m,
      "TaoAllocateVarArray",
      "Fortran routine tao_allocate_var_array return value")
      .def_readonly(
          "default_good_user", &PyTaoAllocateVarArray::default_good_user)
      .def("__len__", [](const PyTaoAllocateVarArray&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoAllocateVarArray& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.default_good_user);
            return py::none();
          });
  m.def(
      "tao_init_plotting",
      &python_tao_init_plotting,
      py::arg("plot_file"),
      R"""(No docstring available

Parameters
----------
plot_file : 
)""");
  py::class_<PyTaoInitPlotting, std::unique_ptr<PyTaoInitPlotting>>(
      m, "TaoInitPlotting", "Fortran routine tao_init_plotting return value")
      .def_readonly("plot_file", &PyTaoInitPlotting::plot_file)
      .def("__len__", [](const PyTaoInitPlotting&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoInitPlotting& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.plot_file);
            return py::none();
          });
  m.def(
      "tao_x_scale_cmd",
      &Tao::tao_x_scale_cmd,
      py::arg("where"),
      py::arg("x_min_in"),
      py::arg("x_max_in"),
      py::arg("include_wall") = py::none(),
      py::arg("gang") = py::none(),
      py::arg("exact") = py::none(),
      py::arg("turn_autoscale_off") = py::none(),
      R"""(Routine to scale a plot. If x_min = x_max

Then the scales will be chosen to show all the data.

Parameters
----------
where : unknown
    Region to scale. Eg: "top"
x_min_in : float
    Plot x-axis min value.
x_max_in : float
    Plot x-axis max value.
include_wall : bool, optional
    Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
    include the building wall position will be included in determining the the scale.
gang : unknown, optional
    'gang', 'nogang', ''. Default = ''.
exact : bool, optional
    Exact plot y_max, y_min to correspond to y_min_in, y_max_in? Default is False. Only relavent when y_min_in
    /= y_max_in.
turn_autoscale_off : bool, optional
    If True (default) then turn off plot.autoscale_x logical for all plots that are scaled.

Returns
-------
err : bool
    Set to True if the plot cannot be found. False otherwise.
)""");
  m.def(
      "tao_x_scale_plot",
      &Tao::tao_x_scale_plot,
      py::arg("plot"),
      py::arg("x_min_in"),
      py::arg("x_max_in"),
      py::arg("include_wall") = py::none(),
      py::arg("gang") = py::none(),
      R"""(Routine to scale a plot. If x_min = x_max

Then the scales will be chosen to show all the data.

Parameters
----------
plot : TaoPlotStruct
    Plot to scale. Eg: "top"
x_min_in : float
    Plot x-axis min value.
x_max_in : float
    Plot x-axis max value.
include_wall : bool, optional
    Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
    include the building wall position will be included in determining the the scale.
gang : unknown, optional
    'gang', 'nogang', ''. Default = ''.

Returns
-------
have_scaled : bool
    Has a graph been scaled?
)""");
  m.def(
      "tao_x_scale_graph",
      &python_tao_x_scale_graph,
      py::arg("graph"),
      py::arg("x_min"),
      py::arg("x_max"),
      py::arg("include_wall") = py::none(),
      py::arg("have_scaled") = py::none(),
      R"""(No docstring available

Parameters
----------
graph : 
x_min : 
x_max : 
include_wall : 
have_scaled : 
)""");
  py::class_<PyTaoXScaleGraph, std::unique_ptr<PyTaoXScaleGraph>>(
      m, "TaoXScaleGraph", "Fortran routine tao_x_scale_graph return value")
      .def_readonly("x_min", &PyTaoXScaleGraph::x_min)
      .def_readonly("x_max", &PyTaoXScaleGraph::x_max)
      .def_readonly("include_wall", &PyTaoXScaleGraph::include_wall)
      .def_readonly("have_scaled", &PyTaoXScaleGraph::have_scaled)
      .def("__len__", [](const PyTaoXScaleGraph&) { return 4; })
      .def(
          "__getitem__", [](const PyTaoXScaleGraph& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.x_min);
            if (i == 1)
              return py::cast(s.x_max);
            if (i == 2)
              return py::cast(s.include_wall);
            if (i == 3)
              return py::cast(s.have_scaled);
            return py::none();
          });
  m.def(
      "tao_pick_universe",
      &Tao::tao_pick_universe,
      py::arg("name_in"),
      py::arg("dflt_uni") = py::none(),
      py::arg("pure_uni") = py::none(),
      R"""(No docstring available

Parameters
----------
name_in : unknown
    data name with possible universe spec.
name_out : unknown
    name_in without any "n@" beginning.
picked : bool
    Array showing picked universes. The array will be resized if necessary.
err : bool
    Set True if an error is detected.
ix_uni : int
    Set to the picked universe with the highest index.
explicit_uni : bool
    Set True if name_in has explicit universe "n@" specification.
dflt_uni : int, optional
    Default universe to use. Set to -1 if explicit universe is required.
pure_uni : bool, optional
    Default is False. See above
)""");
  py::class_<Tao::TaoPickUniverse, std::unique_ptr<Tao::TaoPickUniverse>>(
      m, "TaoPickUniverse", "Fortran routine tao_pick_universe return value")
      .def_readonly("name_out", &Tao::TaoPickUniverse::name_out)
      .def_readonly("picked", &Tao::TaoPickUniverse::picked)
      .def_readonly("err", &Tao::TaoPickUniverse::err)
      .def_readonly("ix_uni", &Tao::TaoPickUniverse::ix_uni)
      .def_readonly("explicit_uni", &Tao::TaoPickUniverse::explicit_uni)
      .def("__len__", [](const Tao::TaoPickUniverse&) { return 5; })
      .def(
          "__getitem__",
          [](const Tao::TaoPickUniverse& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.name_out);
            if (i == 1)
              return py::cast(s.picked);
            if (i == 2)
              return py::cast(s.err);
            if (i == 3)
              return py::cast(s.ix_uni);
            if (i == 4)
              return py::cast(s.explicit_uni);
            return py::none();
          });
  m.def(
      "tao_wave_cmd",
      &python_tao_wave_cmd,
      py::arg("curve_name"),
      py::arg("plot_place"),
      py::arg("err_flag"),
      R"""(Routine to do the initial setup for wave plotting.

The wave analysis is done by the routine tao_wave_analysis.

Parameters
----------
curve_name : 
    Character(*) curve for wave analysis.
plot_place : 
    Character(*) place on plot page to put the wave plot.
)""");
  py::class_<PyTaoWaveCmd, std::unique_ptr<PyTaoWaveCmd>>(
      m, "TaoWaveCmd", "Fortran routine tao_wave_cmd return value")
      .def_readonly("err_flag", &PyTaoWaveCmd::err_flag)
      .def("__len__", [](const PyTaoWaveCmd&) { return 1; })
      .def("__getitem__", [](const PyTaoWaveCmd& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        return py::none();
      });
  m.def(
      "tao_wave_analysis",
      &Tao::tao_wave_analysis,
      py::arg("plot"),
      R"""(Routine to do a wave anaysis.

Parameters
----------
plot : TaoPlotStruct
    Plot region setup by tao_wave_cmd.
    This parameter is an input/output and is modified in-place. As an output: Plot with wave analysis curves.
)""");
  m.def(
      "tao_orbit_beta_wave_anal",
      &Tao::tao_orbit_beta_wave_anal,
      py::arg("plot"),
      R"""()""");
  m.def(
      "tao_phase_wave_anal",
      &Tao::tao_phase_wave_anal,
      py::arg("plot"),
      R"""()""");
  m.def(
      "tao_cbar_wave_anal",
      &Tao::tao_cbar_wave_anal,
      py::arg("plot"),
      R"""()""");
  m.def(
      "tao_wave_fit",
      &Tao::tao_wave_fit,
      py::arg("curve"),
      py::arg("ix1"),
      py::arg("n_dat"),
      py::arg("f1"),
      py::arg("f2") = py::none(),
      py::arg("f3") = py::none(),
      py::arg("f4") = py::none(),
      R"""(Routine for fitting the curve data to up to four functions using a least squares

SVD fit.

Parameters
----------
curve : TaoCurveStruct
    Curve containing the data.
ix1 : int
    Index of first point in the data array.
n_dat : int
    Number of data points.
f1 : float
    First fit function.
f2 : float, optional
    Second fit function.
f3 : float, optional
    third fit function.
f4 : float, optional
    fourth fit function.

Return value is a dictionary containing values below.


Returns
-------
coef : float
    Fit coefficients.
rms : float
    Variances with rms(n_func+1) = sqrt(chi^2/n_dat).
)""");
  py::class_<Tao::TaoWaveFit, std::unique_ptr<Tao::TaoWaveFit>>(
      m, "TaoWaveFit", "Fortran routine tao_wave_fit return value")
      .def_readonly("coef", &Tao::TaoWaveFit::coef)
      .def_readonly("rms", &Tao::TaoWaveFit::rms)
      .def("__len__", [](const Tao::TaoWaveFit&) { return 2; })
      .def("__getitem__", [](const Tao::TaoWaveFit& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.coef);
        if (i == 1)
          return py::cast(s.rms);
        return py::none();
      });
  m.def(
      "tao_clear_cmd",
      &Tao::tao_clear_cmd,
      py::arg("cmd_line"),
      R"""(No docstring available

Parameters
----------
cmd_line : unknown
    Should be set to 'maps'.
)""");
  m.def(
      "tao_init_find_elements",
      &Tao::tao_init_find_elements,
      py::arg("u"),
      py::arg("search_string"),
      py::arg("attribute") = py::none(),
      R"""(No docstring available

Parameters
----------
u : TaoUniverseStruct
    Universe to search
search_string : unknown
    What to search for
eles : ElePointerStruct
    List of matching elements. Size is zero if no elements found.
attribute : unknown, optional
    Check that attribute of element is free to vary.
found_one : bool
    Set True if a matching element is found. However: Not set if no matching element found.
)""");
  py::class_<
      Tao::TaoInitFindElements,
      std::unique_ptr<Tao::TaoInitFindElements>>(
      m,
      "TaoInitFindElements",
      "Fortran routine tao_init_find_elements return value")
      .def_readonly("eles", &Tao::TaoInitFindElements::eles)
      .def_readonly("found_one", &Tao::TaoInitFindElements::found_one)
      .def("__len__", [](const Tao::TaoInitFindElements&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoInitFindElements& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.eles);
            if (i == 1)
              return py::cast(s.found_one);
            return py::none();
          });
  m.def(
      "tao_symbol_import_from_lat",
      &Tao::tao_symbol_import_from_lat,
      py::arg("lat"),
      R"""(No docstring available

Parameters
----------
lat : 
)""");
  m.def(
      "tao_datum_has_associated_ele",
      &python_tao_datum_has_associated_ele,
      py::arg("data_type"),
      py::arg("branch_geometry") = py::none(),
      py::arg("has_associated_ele"),
      R"""(No docstring available

Parameters
----------
data_type : unknown
    Type of data.
branch_geometry : int, optional
    Geometry of the associated lattice branch. open$ or closed$.
has_associated_ele : 
)""");
  py::class_<
      PyTaoDatumHasAssociatedEle,
      std::unique_ptr<PyTaoDatumHasAssociatedEle>>(
      m,
      "TaoDatumHasAssociatedEle",
      "Fortran routine tao_datum_has_associated_ele return value")
      .def_readonly(
          "has_associated_ele", &PyTaoDatumHasAssociatedEle::has_associated_ele)
      .def("__len__", [](const PyTaoDatumHasAssociatedEle&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoDatumHasAssociatedEle& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.has_associated_ele);
            return py::none();
          });
  m.def(
      "tao_count_strings",
      &Tao::tao_count_strings,
      py::arg("string"),
      py::arg("pattern"),
      R"""(No docstring available

Parameters
----------
string : unknown
    the string to look at
pattern : unknown
    the search pattern
num : int
    number of occurances
)""");
  m.def(
      "tao_ptc_normal_form",
      &Tao::tao_ptc_normal_form,
      py::arg("do_calc"),
      py::arg("tao_lat"),
      py::arg("ix_branch"),
      py::arg("rf_on") = py::none(),
      R"""(No docstring available

Parameters
----------
do_calc : bool
    Set True to do the calculation.
tao_lat : TaoLatticeStruct
    Lattice to work on.
ix_branch : int
    Branch of lattice to work on.
rf_on : int, optional
    RF state for calculation. yes$, no$, or maybe$ (default) maybe$ means that RF state in branch is used.
)""");
  m.def(
      "tao_curve_ele_ref",
      &python_tao_curve_ele_ref,
      py::arg("curve"),
      py::arg("point_to_ele_ref"),
      py::arg("ele_track"),
      R"""(No docstring available

Parameters
----------
curve : TaoCurveStruct
    Curve with ref ele.
point_to_ele_ref : 
ele_track : 
)""");
  py::class_<PyTaoCurveEleRef, std::unique_ptr<PyTaoCurveEleRef>>(
      m, "TaoCurveEleRef", "Fortran routine tao_curve_ele_ref return value")
      .def_readonly("point_to_ele_ref", &PyTaoCurveEleRef::point_to_ele_ref)
      .def("__len__", [](const PyTaoCurveEleRef&) { return 1; })
      .def(
          "__getitem__", [](const PyTaoCurveEleRef& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.point_to_ele_ref);
            return py::none();
          });
  m.def(
      "tao_one_turn_map_calc_needed",
      &python_tao_one_turn_map_calc_needed,
      py::arg("data_type"),
      py::arg("data_source"),
      py::arg("do_one_turn_map"),
      R"""(No docstring available

Parameters
----------
data_type : 
data_source : 
do_one_turn_map : 
)""");
  py::class_<
      PyTaoOneTurnMapCalcNeeded,
      std::unique_ptr<PyTaoOneTurnMapCalcNeeded>>(
      m,
      "TaoOneTurnMapCalcNeeded",
      "Fortran routine tao_one_turn_map_calc_needed return value")
      .def_readonly("data_type", &PyTaoOneTurnMapCalcNeeded::data_type)
      .def_readonly("data_source", &PyTaoOneTurnMapCalcNeeded::data_source)
      .def_readonly(
          "do_one_turn_map", &PyTaoOneTurnMapCalcNeeded::do_one_turn_map)
      .def("__len__", [](const PyTaoOneTurnMapCalcNeeded&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoOneTurnMapCalcNeeded& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.data_type);
            if (i == 1)
              return py::cast(s.data_source);
            if (i == 2)
              return py::cast(s.do_one_turn_map);
            return py::none();
          });
  m.def(
      "tao_lat_bookkeeper",
      &Tao::tao_lat_bookkeeper,
      py::arg("u"),
      py::arg("tao_lat"),
      R"""(No docstring available

Parameters
----------
u : TaoUniverseStruct
tao_lat : TaoLatticeStruct
err_flag : bool
    Set True if there is a problem. False otherwise.
)""");
  m.def(
      "tao_locate_all_elements",
      &Tao::tao_locate_all_elements,
      py::arg("ele_list"),
      py::arg("ignore_blank") = py::none(),
      R"""(No docstring available

Parameters
----------
ele_list : unknown
    String with element names using element list format.
eles : unknown
    : Array of elements in the model lat. .id  -- Set to universe number.
err : bool
    Set true on error.
ignore_blank : bool, optional
    If present and true then do nothing if ele_list is blank. otherwise a blank is treated as an error.
)""");
  py::class_<
      Tao::TaoLocateAllElements,
      std::unique_ptr<Tao::TaoLocateAllElements>>(
      m,
      "TaoLocateAllElements",
      "Fortran routine tao_locate_all_elements return value")
      .def_readonly("eles", &Tao::TaoLocateAllElements::eles)
      .def_readonly("err", &Tao::TaoLocateAllElements::err)
      .def("__len__", [](const Tao::TaoLocateAllElements&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoLocateAllElements& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.eles);
            if (i == 1)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "tao_setup_key_table",
      &Tao::tao_setup_key_table,
      R"""(No docstring available

)""");
  m.def(
      "tao_find_plot_region",
      &Tao::tao_find_plot_region,
      py::arg("where"),
      py::arg("print_flag") = py::none(),
      R"""(No docstring available

Parameters
----------
err : bool
    Set True on error. False otherwise.
where : unknown
    Region name.
region : TaoPlotRegionStruct
    Region found.
print_flag : bool, optional
    If present and False then surpress error messages. Default is True.
)""");
  py::class_<Tao::TaoFindPlotRegion, std::unique_ptr<Tao::TaoFindPlotRegion>>(
      m,
      "TaoFindPlotRegion",
      "Fortran routine tao_find_plot_region return value")
      .def_readonly("err", &Tao::TaoFindPlotRegion::err)
      .def_readonly("region", &Tao::TaoFindPlotRegion::region)
      .def("__len__", [](const Tao::TaoFindPlotRegion&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoFindPlotRegion& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.err);
            if (i == 1)
              return py::cast(s.region);
            return py::none();
          });
  m.def(
      "tao_ele_shape_info",
      &python_tao_ele_shape_info,
      py::arg("ix_uni"),
      py::arg("ele"),
      py::arg("ele_shapes"),
      py::arg("y1"),
      py::arg("y2"),
      py::arg("ix_shape_min") = py::none(),
      R"""(No docstring available

Parameters
----------
ix_uni : int
    Universe index.
ele : EleStruct
    Lattice element.
ele_shapes : TaoEleShapeStruct
    Array of shapes to search.
e_shape : TaoEleShapeStruct
    element shape. Will be nullified if no associated shape.
label_name : unknown
    Label name. y1, y2        -- real(rp): shape transverse sizes.
y1 : 
y2 : 
ix_shape_min : int, optional
    Index of minimum ele_shape(:) index to start search from. Default is 1.
    This parameter is an input/output and is modified in-place. As an output: Ele_shape(
)""");
  py::class_<PyTaoEleShapeInfo, std::unique_ptr<PyTaoEleShapeInfo>>(
      m, "TaoEleShapeInfo", "Fortran routine tao_ele_shape_info return value")
      .def_readonly("e_shape", &PyTaoEleShapeInfo::e_shape)
      .def_readonly("label_name", &PyTaoEleShapeInfo::label_name)
      .def_readonly("y1", &PyTaoEleShapeInfo::y1)
      .def_readonly("y2", &PyTaoEleShapeInfo::y2)
      .def_readonly("ix_shape_min", &PyTaoEleShapeInfo::ix_shape_min)
      .def("__len__", [](const PyTaoEleShapeInfo&) { return 5; })
      .def(
          "__getitem__",
          [](const PyTaoEleShapeInfo& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.e_shape);
            if (i == 1)
              return py::cast(s.label_name);
            if (i == 2)
              return py::cast(s.y1);
            if (i == 3)
              return py::cast(s.y2);
            if (i == 4)
              return py::cast(s.ix_shape_min);
            return py::none();
          });
  m.def(
      "tao_abort_command_file",
      &Tao::tao_abort_command_file,
      py::arg("force_abort") = py::none(),
      R"""(No docstring available

Parameters
----------
force_abort : bool, optional
    : If present and True, ignore s.global.cmd_file_abort_on_error and abort any open command files.
)""");
  m.def(
      "tao_data_check",
      &python_tao_data_check,
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
err : 
)""");
  py::class_<PyTaoDataCheck, std::unique_ptr<PyTaoDataCheck>>(
      m, "TaoDataCheck", "Fortran routine tao_data_check return value")
      .def_readonly("err", &PyTaoDataCheck::err)
      .def("__len__", [](const PyTaoDataCheck&) { return 1; })
      .def("__getitem__", [](const PyTaoDataCheck& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err);
        return py::none();
      });
  m.def(
      "tao_beam_emit_calc",
      &python_tao_beam_emit_calc,
      py::arg("plane"),
      py::arg("emit_type"),
      py::arg("ele"),
      py::arg("bunch_params"),
      py::arg("emit"),
      R"""(No docstring available

Parameters
----------
plane : int
    x_plane$ or y_plane$.
emit_type : int
    Either projected_emit$ or apparent_emit$
ele : EleStruct
    Element.
bunch_params : BunchParamsStruct
    Bunch sigma matrix
emit : 
)""");
  py::class_<PyTaoBeamEmitCalc, std::unique_ptr<PyTaoBeamEmitCalc>>(
      m, "TaoBeamEmitCalc", "Fortran routine tao_beam_emit_calc return value")
      .def_readonly("emit", &PyTaoBeamEmitCalc::emit)
      .def("__len__", [](const PyTaoBeamEmitCalc&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoBeamEmitCalc& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.emit);
            return py::none();
          });
  m.def(
      "tao_clip_cmd",
      &python_tao_clip_cmd,
      py::arg("gang"),
      py::arg("where"),
      py::arg("value1"),
      py::arg("value2"),
      R"""(No docstring available

Parameters
----------
gang : bool
    Gang all data d1 arrays together.
where : unknown
    Graph() to clip. Eg: 'top:x'
value1 : 
value2 : 
)""");
  py::class_<PyTaoClipCmd, std::unique_ptr<PyTaoClipCmd>>(
      m, "TaoClipCmd", "Fortran routine tao_clip_cmd return value")
      .def_readonly("value1", &PyTaoClipCmd::value1)
      .def_readonly("value2", &PyTaoClipCmd::value2)
      .def("__len__", [](const PyTaoClipCmd&) { return 2; })
      .def("__getitem__", [](const PyTaoClipCmd& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.value1);
        if (i == 1)
          return py::cast(s.value2);
        return py::none();
      });
  m.def(
      "tao_fixer",
      &Tao::tao_fixer,
      py::arg("switch_"),
      py::arg("word1"),
      py::arg("word2"),
      R"""(No docstring available

Parameters
----------
switch : unknown
    Action to take. One on : 'activate', 'save', 'write'.
word1 : unknown
    First word of command.
word2 : unknown
    Secton word of command.
)""");
  m.def(
      "tao_init",
      &Tao::tao_init,
      R"""(No docstring available

Parameters
----------
err_flag : bool
    Set Treu if there is an error. False otherwise.
)""");
  m.def(
      "tao_key_info_to_str",
      &python_tao_key_info_to_str,
      py::arg("ix_key"),
      py::arg("ix_min_key"),
      py::arg("ix_max_key"),
      py::arg("key_str"),
      py::arg("header_str"),
      R"""(No docstring available

Parameters
----------
ix_key : 
ix_min_key : 
ix_max_key : 
key_str : 
header_str : 
)""");
  py::class_<PyTaoKeyInfoToStr, std::unique_ptr<PyTaoKeyInfoToStr>>(
      m, "TaoKeyInfoToStr", "Fortran routine tao_key_info_to_str return value")
      .def_readonly("ix_key", &PyTaoKeyInfoToStr::ix_key)
      .def_readonly("ix_min_key", &PyTaoKeyInfoToStr::ix_min_key)
      .def_readonly("ix_max_key", &PyTaoKeyInfoToStr::ix_max_key)
      .def_readonly("key_str", &PyTaoKeyInfoToStr::key_str)
      .def_readonly("header_str", &PyTaoKeyInfoToStr::header_str)
      .def("__len__", [](const PyTaoKeyInfoToStr&) { return 5; })
      .def(
          "__getitem__",
          [](const PyTaoKeyInfoToStr& s, size_t i) -> py::object {
            if (i >= 5)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_key);
            if (i == 1)
              return py::cast(s.ix_min_key);
            if (i == 2)
              return py::cast(s.ix_max_key);
            if (i == 3)
              return py::cast(s.key_str);
            if (i == 4)
              return py::cast(s.header_str);
            return py::none();
          });
  m.def(
      "tao_lmdif_optimizer",
      &Tao::tao_lmdif_optimizer,
      R"""(No docstring available

Parameters
----------
abort : bool
    Set True if an user stop signal detected or there is a problem with calculating the merit function.
)""");
  m.def(
      "tao_place_cmd",
      &Tao::tao_place_cmd,
      py::arg("where"),
      py::arg("who"),
      py::arg("no_buffer") = py::none(),
      R"""(No docstring available

Parameters
----------
where : unknown
    Region where the plot goes. Eg: 'top'.
who : unknown
    Type of plot. Eg: 'orbit'.
no_buffer : bool, optional
    If present and True then prevents buffering in the case when s.global.external_plotting = T Output
    s.plot_page.plot(j) -- Plot matched to where.
)""");
  m.def(
      "tao_plot_struct_transfer",
      &Tao::tao_plot_struct_transfer,
      py::arg("plot_in"),
      R"""(No docstring available

Parameters
----------
plot_in : TaoPlotStruct
    Input structure.
plot_out : TaoPlotStruct
    Output struture.
)""");
  m.def(
      "tao_pointer_to_building_wall_shape",
      &Tao::tao_pointer_to_building_wall_shape,
      py::arg("wall_name"),
      py::arg("e_shape"),
      R"""(No docstring available

Parameters
----------
wall_name : unknown
    Name of the wall.
e_shape : 
)""");
  m.def(
      "tao_pointer_to_ele_shape",
      &python_tao_pointer_to_ele_shape,
      py::arg("ix_uni"),
      py::arg("ele"),
      py::arg("ele_shape"),
      py::arg("ix_shape_min") = py::none(),
      py::arg("e_shape"),
      R"""(No docstring available

Parameters
----------
ix_uni : int
    Universe index.
ele : EleStruct
    Lattice element.
ele_shape : TaoEleShapeStruct
    Array of shapes to search.
dat_var_name : unknown
    Name of datum or variable associated with e_shape. Will be set to "" if there is no associated datum or
    variable.
dat_var_value : float
    Value of datum or variable associated with e_shape. Will be set to zero if there is no associated datum or
    variable.
ix_shape_min : int, optional
    Index of minimum ele_shape(:) index to start search from. Default is 1.
    This parameter is an input/output and is modified in-place. As an output: Ele_shape(
e_shape : 
)""");
  py::class_<PyTaoPointerToEleShape, std::unique_ptr<PyTaoPointerToEleShape>>(
      m,
      "TaoPointerToEleShape",
      "Fortran routine tao_pointer_to_ele_shape return value")
      .def_readonly("dat_var_name", &PyTaoPointerToEleShape::dat_var_name)
      .def_readonly("dat_var_value", &PyTaoPointerToEleShape::dat_var_value)
      .def_readonly("ix_shape_min", &PyTaoPointerToEleShape::ix_shape_min)
      .def("__len__", [](const PyTaoPointerToEleShape&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoPointerToEleShape& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.dat_var_name);
            if (i == 1)
              return py::cast(s.dat_var_value);
            if (i == 2)
              return py::cast(s.ix_shape_min);
            return py::none();
          });
  m.def(
      "tao_print_command_line_info",
      &Tao::tao_print_command_line_info,
      R"""(No docstring available

)""");
  m.def(
      "tao_remove_blank_characters",
      &python_tao_remove_blank_characters,
      py::arg("str"),
      R"""(No docstring available

Parameters
----------
str : unknown
    Input string.
    This parameter is an input/output and is modified in-place. As an output: String with blank characters
    removed.
)""");
  py::class_<
      PyTaoRemoveBlankCharacters,
      std::unique_ptr<PyTaoRemoveBlankCharacters>>(
      m,
      "TaoRemoveBlankCharacters",
      "Fortran routine tao_remove_blank_characters return value")
      .def_readonly("str", &PyTaoRemoveBlankCharacters::str)
      .def("__len__", [](const PyTaoRemoveBlankCharacters&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoRemoveBlankCharacters& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.str);
            return py::none();
          });
  m.def(
      "tao_read_phase_space_index",
      &python_tao_read_phase_space_index,
      py::arg("name"),
      py::arg("ixc"),
      py::arg("print_err") = py::none(),
      py::arg("ix_ps"),
      R"""(No docstring available

Parameters
----------
name : unknown
    character array holding the index. Must be in the range 1-6.
ixc : int
    location within <name> to evaluate index.
print_err : bool, optional
    If present and False then do not print an error message
ix_ps : 
)""");
  py::class_<
      PyTaoReadPhaseSpaceIndex,
      std::unique_ptr<PyTaoReadPhaseSpaceIndex>>(
      m,
      "TaoReadPhaseSpaceIndex",
      "Fortran routine tao_read_phase_space_index return value")
      .def_readonly("ix_ps", &PyTaoReadPhaseSpaceIndex::ix_ps)
      .def("__len__", [](const PyTaoReadPhaseSpaceIndex&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoReadPhaseSpaceIndex& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.ix_ps);
            return py::none();
          });
  m.def(
      "tao_run_cmd",
      &Tao::tao_run_cmd,
      py::arg("which"),
      R"""(No docstring available

Parameters
----------
which : unknown
    which optimizer to use. ' '        -- Same as last time 'de'       -- Differential Evolution. 'lm'
    -- Levenberg - Marquardt (aka lmdif). 'custom'   -- Custom routine.
abort : bool
    Set True if the run was aborted by the user, an at minimum condition, a singular matrix condition, etc..
    False otherwise.
)""");
  m.def(
      "tao_set_data_useit_opt",
      &Tao::tao_set_data_useit_opt,
      py::arg("data") = py::none(),
      R"""(No docstring available

Parameters
----------
data : TaoDataStruct, optional
    Data to work on. Default is all data in all universes.
)""");
  m.def(
      "tao_set_var_model_value",
      &Tao::tao_set_var_model_value,
      py::arg("var"),
      py::arg("value"),
      py::arg("print_limit_warning") = py::none(),
      R"""(No docstring available

Parameters
----------
var : TaoVarStruct
    Variable to set
value : float
    Value to set to
print_limit_warning : bool, optional
    Print a warning if the value is past the variable's limits. -- Logical, optional: Print a warning if the
    value is past the variable's limits. Default is True.
)""");
  m.def(
      "tao_single_mode",
      &Tao::tao_single_mode,
      py::arg("char_"),
      R"""(No docstring available

Parameters
----------
char : unknown
    Command. If more characters are needed to complete the command then this routine will get them.
)""");
  m.def(
      "tao_shape_init",
      &Tao::tao_shape_init,
      py::arg("shape"),
      py::arg("print_err") = py::none(),
      R"""(No docstring available

Parameters
----------
shape : TaoEleShapeStruct
    Shape
err : 
    Set true if there is a problem translating the element class.
print_err : bool, optional
    If True then print an error message if there is a problem. Default is True.
)""");
  m.def(
      "tao_taper_cmd",
      &Tao::tao_taper_cmd,
      py::arg("except"),
      py::arg("uni_names"),
      R"""(No docstring available

Parameters
----------
except : unknown
    List of elements not to vary.
uni_names : unknown
    Universes to taper.
)""");
  m.def(
      "tao_user_is_terminating_optimization",
      &Tao::tao_user_is_terminating_optimization,
      R"""(No docstring available

Parameters
----------
is_terminating : 
)""");
  m.def(
      "tao_uni_atsign_index",
      &Tao::tao_uni_atsign_index,
      py::arg("string"),
      R"""(Routine to return the index of an atsign ("@") character in a string if the atsign is

being used as a separator between a universe spec and the rest of the string.
For example:
string = "[1:3]@orbit.x[5] => ix_amp = 6
string = "orbit.x[5@0.2]   => ix_amp = 0 (no universe "@" present)

Parameters
----------
string : unknown
    String to parse

Returns
-------
ix_amp : int
    Index of universe "@". Set to zero if no universe "@" found.
)""");
  m.def(
      "tao_dmodel_dvar_calc",
      &Tao::tao_dmodel_dvar_calc,
      py::arg("force_calc"),
      R"""(Subroutine to calculate the dModel_dVar derivative matrix.

Parameters
----------
s : SuperUniverseStruct
    This parameter is an input/output and is modified in-place. As an output: Super_universe_struct.
force_calc : bool
    If true then force recalculation of the matrix. If False then only calculate matrix if it doesn't exist.
veto_vars_with_zero_dmodel : bool
    Veto variables where -- Logical, optional (default False): Veto variables where all dModel_dvar for that
    var are zero. Sets the var.good_var logical to False.

Returns
-------
err_flag : bool
    Set true if there is an error. False otherwise.
)""");
  m.def(
      "tao_veto_vars_with_zero_dmodel",
      &Tao::tao_veto_vars_with_zero_dmodel,
      R"""(Routine to veto all variables with zero effect on data used in the merit function.

)""");
  m.def("tao_dmerit_calc", &Tao::tao_dmerit_calc, R"""()""");
  m.def(
      "tao_init_global",
      &Tao::tao_init_global,
      py::arg("init_file"),
      R"""(Subroutine to initialize the tao global structures.

Parameters
----------
init_file : unknown
    Tao initialization file. If blank, there is no file so just use the defaults.
)""");
  m.def(
      "tao_init_beams",
      &Tao::tao_init_beams,
      py::arg("init_file"),
      R"""(Subroutine to initialize beam stuff.

Parameters
----------
init_file : unknown
    Tao initialization file. If blank, there is no file so just use the defaults.
)""");
  m.def(
      "tao_init_beam_in_universe",
      &python_tao_init_beam_in_universe,
      py::arg("u"),
      py::arg("beam_init"),
      py::arg("track_start"),
      py::arg("track_end"),
      py::arg("comb_ds_save"),
      R"""(No docstring available

Parameters
----------
u : 
beam_init : 
track_start : 
track_end : 
comb_ds_save : 
)""");
  py::class_<PyTaoInitBeamInUniverse, std::unique_ptr<PyTaoInitBeamInUniverse>>(
      m,
      "TaoInitBeamInUniverse",
      "Fortran routine tao_init_beam_in_universe return value")
      .def_readonly("track_start", &PyTaoInitBeamInUniverse::track_start)
      .def_readonly("track_end", &PyTaoInitBeamInUniverse::track_end)
      .def_readonly("comb_ds_save", &PyTaoInitBeamInUniverse::comb_ds_save)
      .def("__len__", [](const PyTaoInitBeamInUniverse&) { return 3; })
      .def(
          "__getitem__",
          [](const PyTaoInitBeamInUniverse& s, size_t i) -> py::object {
            if (i >= 3)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.track_start);
            if (i == 1)
              return py::cast(s.track_end);
            if (i == 2)
              return py::cast(s.comb_ds_save);
            return py::none();
          });
  m.def(
      "tao_init_dynamic_aperture",
      &Tao::tao_init_dynamic_aperture,
      py::arg("init_file"),
      R"""(Routine to initalize dynamic aperture simulations.

Parameters
----------
init_file : unknown
    File setting dynamic_aperture parameters.
)""");
  m.def(
      "tao_svd_optimizer",
      &Tao::tao_svd_optimizer,
      R"""(Routine to minimize the merit function using svd.


Returns
-------
abort : bool
    Set True if svd step increases the merit function.
)""");
  m.def(
      "tao_change_tune",
      &Tao::tao_change_tune,
      py::arg("branch_str"),
      py::arg("mask_str"),
      py::arg("print_list"),
      py::arg("dqa_str"),
      py::arg("dqb_str"),
      R"""(Parameters
----------
branch_str : unknown
    List of branches to apply tune set to.
mask_str : unknown
    List of quadrupoles to veto.
print_list : bool
    If True, print a list of elements varied and coefficients.
dqa_str : unknown
    Expression for dQa tune.
dqb_str : unknown
    Expression for dQb tune.

Returns
-------
err_flag : 
    logical, Set true if there is an error, false otherwise.
)""");
  m.def(
      "tao_change_z_tune",
      &Tao::tao_change_z_tune,
      py::arg("branch_str"),
      py::arg("dq_str"),
      R"""(Parameters
----------
branch_str : unknown
    List of branches to apply tune set to.
dq_str : unknown
    Expression for dQc tune.

Returns
-------
err_flag : 
    logical, Set true if there is an error, false otherwise.
)""");
  m.def(
      "tao_change_var",
      &Tao::tao_change_var,
      py::arg("name"),
      py::arg("num_str"),
      py::arg("silent"),
      R"""(Routine to change a variable in the model lattice.

Parameters
----------
name : unknown
    Name of variable or element.
num_str : unknown
    Change in value. A '@' signifies a absolute set. A 'd' signifies a set relative design.
silent : bool
    If True then do not print any info.

Returns
-------
err_flag : 
    logical, Set true if there is an error, false otherwise. s%u(s%global%default_universe)%model -- model
    lattice where the variable lives.
)""");
  m.def(
      "tao_change_ele",
      &python_tao_change_ele,
      py::arg("ele_name"),
      py::arg("attrib_name"),
      py::arg("num_str"),
      py::arg("update"),
      R"""(Routine to change a variable in the model lattice.

Parameters
----------
ele_name : unknown
    Name of variable or element.
attrib_name : unknown
    Attribute name of element.
num_str : unknown
    Change in value. A '@' signifies a absolute set. A 'd' signifies a set relative design.

Returns
-------
err_flag : 
    logical, Set true if there is an error, false otherwise. s%u(s%global%default_universe)%model -- model
    lattice where the variable lives.
)""");
  py::class_<PyTaoChangeEle, std::unique_ptr<PyTaoChangeEle>>(
      m, "TaoChangeEle", "Fortran routine tao_change_ele return value")
      .def_readonly("err_flag", &PyTaoChangeEle::err_flag)
      .def_readonly("update", &PyTaoChangeEle::update)
      .def("__len__", [](const PyTaoChangeEle&) { return 2; })
      .def("__getitem__", [](const PyTaoChangeEle& s, size_t i) -> py::object {
        if (i >= 2)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.err_flag);
        if (i == 1)
          return py::cast(s.update);
        return py::none();
      });
  m.def(
      "tao_to_change_number",
      &python_tao_to_change_number,
      py::arg("num_str"),
      py::arg("n_size"),
      py::arg("change_number"),
      py::arg("abs_or_rel"),
      py::arg("err"),
      R"""(No docstring available

Parameters
----------
num_str : 
n_size : 
change_number : 
abs_or_rel : 
err : 
)""");
  py::class_<PyTaoToChangeNumber, std::unique_ptr<PyTaoToChangeNumber>>(
      m,
      "TaoToChangeNumber",
      "Fortran routine tao_to_change_number return value")
      .def_readonly("num_str", &PyTaoToChangeNumber::num_str)
      .def_readonly("n_size", &PyTaoToChangeNumber::n_size)
      .def_readonly("abs_or_rel", &PyTaoToChangeNumber::abs_or_rel)
      .def_readonly("err", &PyTaoToChangeNumber::err)
      .def("__len__", [](const PyTaoToChangeNumber&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTaoToChangeNumber& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.num_str);
            if (i == 1)
              return py::cast(s.n_size);
            if (i == 2)
              return py::cast(s.abs_or_rel);
            if (i == 3)
              return py::cast(s.err);
            return py::none();
          });
  m.def(
      "tao_set_tune_cmd",
      &Tao::tao_set_tune_cmd,
      py::arg("branch_str"),
      py::arg("mask_str"),
      py::arg("print_list"),
      py::arg("qa_str"),
      py::arg("qb_str"),
      py::arg("delta_input"),
      R"""(Routine to set the transverse tunes.

Parameters
----------
branch_str : unknown
    List of branches to apply tune set to.
mask_str : unknown
    List of quadrupoles to veto.
print_list : bool
    If True, print a list of elements varied and coefficients.
qa_str : unknown
    Expression for Qa tune.
qb_str : unknown
    Expression for Qb tune.
delta_input : bool
    If true then qa_str and qb_str are deltas from present tune.
)""");
  m.def(
      "tao_set_z_tune_cmd",
      &Tao::tao_set_z_tune_cmd,
      py::arg("branch_str"),
      py::arg("q_str"),
      py::arg("delta_input"),
      R"""(Routine to set the z-tune.

Parameters
----------
branch_str : unknown
    List of branches to apply tune set to.
q_str : unknown
    Expression for Qc tune.
delta_input : bool
    If true then qa_str and qb_str are deltas from present tune.
)""");
  m.def(
      "tao_set_openmp_n_threads",
      &Tao::tao_set_openmp_n_threads,
      py::arg("n_threads"),
      R"""(Routine to set OpenMP thread count.  Errors if OpenMP is not available.

Parameters
----------
n_threads : int
    Number of threads.
)""");
  m.def(
      "tao_set_calculate_cmd",
      &python_tao_set_calculate_cmd,
      py::arg("switch_") = py::none(),
      R"""(Toggles off lattice calc and plotting.

)""");
  py::class_<PyTaoSetCalculateCmd, std::unique_ptr<PyTaoSetCalculateCmd>>(
      m,
      "TaoSetCalculateCmd",
      "Fortran routine tao_set_calculate_cmd return value")
      .def_readonly("switch_", &PyTaoSetCalculateCmd::switch_)
      .def("__len__", [](const PyTaoSetCalculateCmd&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoSetCalculateCmd& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.switch_);
            return py::none();
          });
  m.def(
      "tao_set_key_cmd",
      &Tao::tao_set_key_cmd,
      py::arg("key_str"),
      py::arg("cmd_str"),
      R"""(Associates a command with a key press for single mode.

Parameters
----------
key_str : unknown
    keyboard key.
cmd_str : unknown
    Command associated with key.
)""");
  m.def(
      "tao_set_ran_state_cmd",
      &Tao::tao_set_ran_state_cmd,
      py::arg("state_string"),
      R"""(Sets the random number generator state.

Parameters
----------
state_string : unknown
    Encoded random number state.
)""");
  m.def(
      "tao_set_lattice_cmd",
      &Tao::tao_set_lattice_cmd,
      py::arg("dest_lat"),
      py::arg("source_lat"),
      R"""(Sets a lattice equal to another. This will also update the data structs

Parameters
----------
dest_lat : unknown
    Maybe: 'model', 'design', or 'base' with optional '@n' at beginning to indicate the universe
source_lat : unknown
    Maybe: 'model', 'design', or 'base' s.u(n) -- lat_struct: changes specified lattice in specified universe
)""");
  m.def(
      "tao_set_global_cmd",
      &Tao::tao_set_global_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set global variables

Parameters
----------
who : unknown
    which global variable to set
value_str : unknown
    Value to set to. s.global  -- Global variables structure.
)""");
  m.def(
      "tao_set_space_charge_com_cmd",
      &Tao::tao_set_space_charge_com_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set space_charge_com variables

Parameters
----------
who : unknown
    which space_charge_com variable to set
value_str : unknown
    Value to set to.

Returns
-------
space_charge_com : 
    space_charge_com variables structure.
)""");
  m.def(
      "tao_set_bmad_com_cmd",
      &Tao::tao_set_bmad_com_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set bmad_com variables

Parameters
----------
who : unknown
    which bmad_com variable to set
value_str : unknown
    Value to set to.
)""");
  m.def(
      "tao_set_ptc_com_cmd",
      &Tao::tao_set_ptc_com_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set ptc_com variables

Parameters
----------
who : unknown
    which ptc_com variable to set
value_str : unknown
    Value to set to.
)""");
  m.def(
      "tao_set_geodesic_lm_cmd",
      &Tao::tao_set_geodesic_lm_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set geodesic_lm variables

Parameters
----------
who : unknown
    which geodesic_lm variable to set
value_str : unknown
    Value to set to.
)""");
  m.def(
      "tao_set_opti_de_param_cmd",
      &Tao::tao_set_opti_de_param_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set opti_de_param variables

Parameters
----------
who : unknown
    which opti_de_param variable to set
value_str : unknown
    Value to set to.
)""");
  m.def(
      "tao_set_wave_cmd",
      &Tao::tao_set_wave_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set wave variables

Parameters
----------
who : unknown
    which wave variable to set
value_str : unknown
    Value to set to.

Returns
-------
err : bool
    Set True if there is an error. False otherwise. s.wave  -- Wave variables structure.
)""");
  m.def(
      "tao_set_beam_cmd",
      &Tao::tao_set_beam_cmd,
      py::arg("who"),
      py::arg("value_str"),
      py::arg("branch_str"),
      R"""(Routine to set various beam parameters.

Parameters
----------
who : unknown
    which parameter to set.
value_str : unknown
    Value to set to.
branch_str : unknown
    Branch to use. '' => branch 0.
)""");
  m.def(
      "tao_set_beam_init_cmd",
      &Tao::tao_set_beam_init_cmd,
      py::arg("who"),
      py::arg("value_str"),
      py::arg("branch_str"),
      R"""(Routine to set beam_init variables

Parameters
----------
who : unknown
    which beam_init variable to set
value_str : unknown
    Value to set to.
branch_str : unknown
    Branch to use. '' => branch 0 s.beam_init  -- Beam_init variables structure.
)""");
  m.def(
      "tao_set_particle_start_cmd",
      &Tao::tao_set_particle_start_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Routine to set particle_start variables.

Parameters
----------
who : unknown
    which particle_start variable to set
value_str : unknown
    Value to set to. s.particle_start  -- Beam_start variables structure.
)""");
  m.def(
      "tao_set_plot_page_cmd",
      &Tao::tao_set_plot_page_cmd,
      py::arg("component"),
      py::arg("value_str"),
      py::arg("value_str2") = py::none(),
      R"""(Set various aspects of the plotting window

Parameters
----------
component : unknown
    Which component to set.
value_str : unknown
    What value to set to.
value_str2 : unknown
    2nd value if component is an array. s.plot       -- tao_plotting_struct:
)""");
  m.def(
      "tao_set_curve_cmd",
      &Tao::tao_set_curve_cmd,
      py::arg("curve_name"),
      py::arg("component"),
      py::arg("value_str"),
      R"""(Routine to set var values.

Parameters
----------
curve_name : unknown
    Which curve to set.
component : unknown
    Which component to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_plot_cmd",
      &Tao::tao_set_plot_cmd,
      py::arg("plot_name"),
      py::arg("component"),
      py::arg("value_str"),
      R"""(Routine to set plot parameters.

Parameters
----------
plot_name : unknown
    Which plot to set.
component : unknown
    Which component to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_region_cmd",
      &Tao::tao_set_region_cmd,
      py::arg("region_name"),
      py::arg("component"),
      py::arg("value_str"),
      R"""(Routine to set region parameters.

Parameters
----------
region_name : unknown
    Which region to set.
component : unknown
    Which component to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_graph_cmd",
      &Tao::tao_set_graph_cmd,
      py::arg("graph_name"),
      py::arg("component"),
      py::arg("value_str"),
      R"""(Routine to set var values.

Parameters
----------
graph_name : unknown
    Which graph to set.
component : unknown
    Which component to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_var_cmd",
      &Tao::tao_set_var_cmd,
      py::arg("var_str"),
      py::arg("value_str"),
      R"""(Routine to set var values.

Parameters
----------
var_str : unknown
    Which var name to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_branch_cmd",
      &Tao::tao_set_branch_cmd,
      py::arg("branch_str"),
      py::arg("component_str"),
      py::arg("value_str"),
      R"""(Routine to set lattice branch values.

Parameters
----------
branch_str : unknown
    Which branch to set.
component_str : unknown
    Which branch parameter to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_data_cmd",
      &python_tao_set_data_cmd,
      py::arg("who_str"),
      py::arg("value_str"),
      py::arg("silent") = py::none(),
      R"""(Routine to set data values.

Parameters
----------
who_str : unknown
    Which data component(s) to set.
value_str : unknown
    What value to set it to.
)""");
  py::class_<PyTaoSetDataCmd, std::unique_ptr<PyTaoSetDataCmd>>(
      m, "TaoSetDataCmd", "Fortran routine tao_set_data_cmd return value")
      .def_readonly("silent", &PyTaoSetDataCmd::silent)
      .def("__len__", [](const PyTaoSetDataCmd&) { return 1; })
      .def("__getitem__", [](const PyTaoSetDataCmd& s, size_t i) -> py::object {
        if (i >= 1)
          throw py::index_error();
        if (i == 0)
          return py::cast(s.silent);
        return py::none();
      });
  m.def(
      "tao_set_default_cmd",
      &Tao::tao_set_default_cmd,
      py::arg("who_str"),
      py::arg("value_str"),
      R"""(Routine to set default values.

Parameters
----------
who_str : unknown
    Which default component(s) to set.
value_str : unknown
    What value to set it to.
)""");
  m.def(
      "tao_set_dynamic_aperture_cmd",
      &Tao::tao_set_dynamic_aperture_cmd,
      py::arg("who"),
      py::arg("value_str"),
      R"""(Sets dynamic aperture parameters.

Parameters
----------
who : unknown
    which parameter to set.
value_str : unknown
    Value to set to.
)""");
  m.def(
      "tao_set_universe_cmd",
      &Tao::tao_set_universe_cmd,
      py::arg("uni"),
      py::arg("who"),
      py::arg("what"),
      R"""(Sets a universe on or off, or sets the recalculate or twiss_calc logicals, etc.

Parameters
----------
uni : unknown
    which universe; 0 => current viewed universe
who : unknown
    "on", "off", "recalculate", "dynamic_aperture_calc", "one_turn_map_calc", or "twiss_calc"
what : unknown
    "on" or "off" for who = "dynamic_aperture_calc", "one_turn_map_calc" or "twiss_calc".
)""");
  m.def(
      "tao_set_elements_cmd",
      &python_tao_set_elements_cmd,
      py::arg("ele_list"),
      py::arg("attribute"),
      py::arg("value"),
      py::arg("update"),
      R"""(Sets element parameters.

Parameters
----------
ele_list : unknown
    which elements.
attribute : unknown
    Attribute to set.
value : unknown
    Value to set.
)""");
  py::class_<PyTaoSetElementsCmd, std::unique_ptr<PyTaoSetElementsCmd>>(
      m,
      "TaoSetElementsCmd",
      "Fortran routine tao_set_elements_cmd return value")
      .def_readonly("update", &PyTaoSetElementsCmd::update)
      .def("__len__", [](const PyTaoSetElementsCmd&) { return 1; })
      .def(
          "__getitem__",
          [](const PyTaoSetElementsCmd& s, size_t i) -> py::object {
            if (i >= 1)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.update);
            return py::none();
          });
  m.def(
      "tao_set_logical_value",
      &Tao::tao_set_logical_value,
      py::arg("var_str"),
      py::arg("value_str"),
      R"""(Subroutine to read and set the value of an logical varialbe.

If the value is out of the range [min_val, max_val] then an error message will
be generated and the variable will not be set.

Parameters
----------
var_str : unknown
    Used for error messages.
value_str : unknown
    String with encoded value.

Return value is a dictionary containing values below.


Returns
-------
var : bool
    Variable to set.
error : bool
    Set True on an error. False otherwise.
)""");
  py::class_<Tao::TaoSetLogicalValue, std::unique_ptr<Tao::TaoSetLogicalValue>>(
      m,
      "TaoSetLogicalValue",
      "Fortran routine tao_set_logical_value return value")
      .def_readonly("var", &Tao::TaoSetLogicalValue::var)
      .def_readonly("error", &Tao::TaoSetLogicalValue::error)
      .def("__len__", [](const Tao::TaoSetLogicalValue&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoSetLogicalValue& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.var);
            if (i == 1)
              return py::cast(s.error);
            return py::none();
          });
  m.def(
      "tao_set_integer_value",
      &Tao::tao_set_integer_value,
      py::arg("var_str"),
      py::arg("value_str"),
      py::arg("min_val") = py::none(),
      py::arg("max_val") = py::none(),
      py::arg("print_err") = py::none(),
      R"""(Subroutine to read and set the value of an integer varialbe.

If the value is out of the range [min_val, max_val] then an error message will
be generated and the variable will not be set.

Parameters
----------
var_str : unknown
    Used for error messages.
value_str : unknown
    String with encoded value.
min_val : int, optional
    Minimum value.
max_val : int, optional
    Maximum value.
print_err : bool, optional
    If True, print error message. Default is true

Return value is a dictionary containing values below.


Returns
-------
var : int
    Variable to set.
error : bool
    Set True on an error. False otherwise.
)""");
  py::class_<Tao::TaoSetIntegerValue, std::unique_ptr<Tao::TaoSetIntegerValue>>(
      m,
      "TaoSetIntegerValue",
      "Fortran routine tao_set_integer_value return value")
      .def_readonly("var", &Tao::TaoSetIntegerValue::var)
      .def_readonly("error", &Tao::TaoSetIntegerValue::error)
      .def("__len__", [](const Tao::TaoSetIntegerValue&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoSetIntegerValue& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.var);
            if (i == 1)
              return py::cast(s.error);
            return py::none();
          });
  m.def(
      "tao_set_real_value",
      &Tao::tao_set_real_value,
      py::arg("var_str"),
      py::arg("value_str"),
      py::arg("min_val") = py::none(),
      py::arg("max_val") = py::none(),
      py::arg("dflt_uni") = py::none(),
      R"""(Subroutine to read and set the value of a real variable.

If the value is out of the range [min_val, max_val] then an error message will
be generated and the variable will not be set.

Parameters
----------
var_str : unknown
    Used for error messages.
value_str : unknown
    String with encoded value.
min_val : float, optional
    Minimum value.
max_val : float, optional
    Maximum value.
dflt_uni : int, optional
    Default universe used to evaluate parameters.

Return value is a dictionary containing values below.


Returns
-------
var : float
    Variable to set.
error : bool
    Set True on an error. False otherwise.
)""");
  py::class_<Tao::TaoSetRealValue, std::unique_ptr<Tao::TaoSetRealValue>>(
      m, "TaoSetRealValue", "Fortran routine tao_set_real_value return value")
      .def_readonly("var", &Tao::TaoSetRealValue::var)
      .def_readonly("error", &Tao::TaoSetRealValue::error)
      .def("__len__", [](const Tao::TaoSetRealValue&) { return 2; })
      .def(
          "__getitem__",
          [](const Tao::TaoSetRealValue& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.var);
            if (i == 1)
              return py::cast(s.error);
            return py::none();
          });
  m.def(
      "tao_set_symbolic_number_cmd",
      &Tao::tao_set_symbolic_number_cmd,
      py::arg("sym_str"),
      py::arg("num_str") = py::none(),
      py::arg("val") = py::none(),
      R"""(Associates a given symbol with a given number.

Parameters
----------
sym_str : unknown
    Symbol.
num_str : unknown, optional
    Symbol value expression.
val : float, optional
    Value of symbol
)""");
  m.def(
      "test_integer_scalar",
      &python_test_integer_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestIntegerScalar, std::unique_ptr<PyTestIntegerScalar>>(
      m,
      "TestIntegerScalar",
      "Fortran routine test_integer_scalar return value")
      .def_readonly("val_out", &PyTestIntegerScalar::val_out)
      .def_readonly("opt_status", &PyTestIntegerScalar::opt_status)
      .def_readonly("val_inout", &PyTestIntegerScalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestIntegerScalar::val_inout_opt)
      .def("__len__", [](const PyTestIntegerScalar&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTestIntegerScalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_integer_array",
      &CppBmadTest::test_integer_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestIntegerArray,
      std::unique_ptr<CppBmadTest::TestIntegerArray>>(
      m, "TestIntegerArray", "Fortran routine test_integer_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestIntegerArray::arr_out)
      .def_readonly("opt_status", &CppBmadTest::TestIntegerArray::opt_status)
      .def("__len__", [](const CppBmadTest::TestIntegerArray&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestIntegerArray& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_integer8_scalar",
      &python_test_integer8_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestInteger8Scalar, std::unique_ptr<PyTestInteger8Scalar>>(
      m,
      "TestInteger8Scalar",
      "Fortran routine test_integer8_scalar return value")
      .def_readonly("val_out", &PyTestInteger8Scalar::val_out)
      .def_readonly("opt_status", &PyTestInteger8Scalar::opt_status)
      .def_readonly("val_inout", &PyTestInteger8Scalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestInteger8Scalar::val_inout_opt)
      .def("__len__", [](const PyTestInteger8Scalar&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTestInteger8Scalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_integer8_array",
      &CppBmadTest::test_integer8_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestInteger8Array,
      std::unique_ptr<CppBmadTest::TestInteger8Array>>(
      m,
      "TestInteger8Array",
      "Fortran routine test_integer8_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestInteger8Array::arr_out)
      .def_readonly("opt_status", &CppBmadTest::TestInteger8Array::opt_status)
      .def("__len__", [](const CppBmadTest::TestInteger8Array&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestInteger8Array& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_real_scalar",
      &python_test_real_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestRealScalar, std::unique_ptr<PyTestRealScalar>>(
      m, "TestRealScalar", "Fortran routine test_real_scalar return value")
      .def_readonly("val_out", &PyTestRealScalar::val_out)
      .def_readonly("opt_status", &PyTestRealScalar::opt_status)
      .def_readonly("val_inout", &PyTestRealScalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestRealScalar::val_inout_opt)
      .def("__len__", [](const PyTestRealScalar&) { return 4; })
      .def(
          "__getitem__", [](const PyTestRealScalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_real_array",
      &CppBmadTest::test_real_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestRealArray,
      std::unique_ptr<CppBmadTest::TestRealArray>>(
      m, "TestRealArray", "Fortran routine test_real_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestRealArray::arr_out)
      .def_readonly("opt_status", &CppBmadTest::TestRealArray::opt_status)
      .def("__len__", [](const CppBmadTest::TestRealArray&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestRealArray& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_real16_scalar",
      &python_test_real16_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestReal16Scalar, std::unique_ptr<PyTestReal16Scalar>>(
      m, "TestReal16Scalar", "Fortran routine test_real16_scalar return value")
      .def_readonly("val_out", &PyTestReal16Scalar::val_out)
      .def_readonly("opt_status", &PyTestReal16Scalar::opt_status)
      .def_readonly("val_inout", &PyTestReal16Scalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestReal16Scalar::val_inout_opt)
      .def("__len__", [](const PyTestReal16Scalar&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTestReal16Scalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_real16_array",
      &CppBmadTest::test_real16_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestReal16Array,
      std::unique_ptr<CppBmadTest::TestReal16Array>>(
      m, "TestReal16Array", "Fortran routine test_real16_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestReal16Array::arr_out)
      .def_readonly("opt_status", &CppBmadTest::TestReal16Array::opt_status)
      .def("__len__", [](const CppBmadTest::TestReal16Array&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestReal16Array& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_complex_scalar",
      &python_test_complex_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestComplexScalar, std::unique_ptr<PyTestComplexScalar>>(
      m,
      "TestComplexScalar",
      "Fortran routine test_complex_scalar return value")
      .def_readonly("val_out", &PyTestComplexScalar::val_out)
      .def_readonly("opt_status", &PyTestComplexScalar::opt_status)
      .def_readonly("val_inout", &PyTestComplexScalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestComplexScalar::val_inout_opt)
      .def("__len__", [](const PyTestComplexScalar&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTestComplexScalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_complex_array",
      &CppBmadTest::test_complex_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestComplexArray,
      std::unique_ptr<CppBmadTest::TestComplexArray>>(
      m, "TestComplexArray", "Fortran routine test_complex_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestComplexArray::arr_out)
      .def_readonly("opt_status", &CppBmadTest::TestComplexArray::opt_status)
      .def("__len__", [](const CppBmadTest::TestComplexArray&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestComplexArray& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_logical_scalar",
      &python_test_logical_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestLogicalScalar, std::unique_ptr<PyTestLogicalScalar>>(
      m,
      "TestLogicalScalar",
      "Fortran routine test_logical_scalar return value")
      .def_readonly("val_out", &PyTestLogicalScalar::val_out)
      .def_readonly("opt_status", &PyTestLogicalScalar::opt_status)
      .def_readonly("val_inout", &PyTestLogicalScalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestLogicalScalar::val_inout_opt)
      .def("__len__", [](const PyTestLogicalScalar&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTestLogicalScalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_logical_array",
      &CppBmadTest::test_logical_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestLogicalArray,
      std::unique_ptr<CppBmadTest::TestLogicalArray>>(
      m, "TestLogicalArray", "Fortran routine test_logical_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestLogicalArray::arr_out)
      .def_readonly("opt_status", &CppBmadTest::TestLogicalArray::opt_status)
      .def("__len__", [](const CppBmadTest::TestLogicalArray&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestLogicalArray& s, size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_character_scalar",
      &python_test_character_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<PyTestCharacterScalar, std::unique_ptr<PyTestCharacterScalar>>(
      m,
      "TestCharacterScalar",
      "Fortran routine test_character_scalar return value")
      .def_readonly("val_out", &PyTestCharacterScalar::val_out)
      .def_readonly("opt_status", &PyTestCharacterScalar::opt_status)
      .def_readonly("val_inout", &PyTestCharacterScalar::val_inout)
      .def_readonly("val_inout_opt", &PyTestCharacterScalar::val_inout_opt)
      .def("__len__", [](const PyTestCharacterScalar&) { return 4; })
      .def(
          "__getitem__",
          [](const PyTestCharacterScalar& s, size_t i) -> py::object {
            if (i >= 4)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            if (i == 2)
              return py::cast(s.val_inout);
            if (i == 3)
              return py::cast(s.val_inout_opt);
            return py::none();
          });
  m.def(
      "test_bunch_struct_scalar",
      &CppBmadTest::test_bunch_struct_scalar,
      py::arg("val_in"),
      py::arg("val_inout"),
      py::arg("val_in_opt") = py::none(),
      py::arg("val_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
val_in : 
val_inout : 
val_out : 
opt_status : 
val_in_opt : 
val_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestBunchStructScalar,
      std::unique_ptr<CppBmadTest::TestBunchStructScalar>>(
      m,
      "TestBunchStructScalar",
      "Fortran routine test_bunch_struct_scalar return value")
      .def_readonly("val_out", &CppBmadTest::TestBunchStructScalar::val_out)
      .def_readonly(
          "opt_status", &CppBmadTest::TestBunchStructScalar::opt_status)
      .def(
          "__len__",
          [](const CppBmadTest::TestBunchStructScalar&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestBunchStructScalar& s,
             size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.val_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
  m.def(
      "test_bunch_struct_array",
      &CppBmadTest::test_bunch_struct_array,
      py::arg("arr_in"),
      py::arg("arr_inout"),
      py::arg("arr_in_opt") = py::none(),
      py::arg("arr_inout_opt") = py::none(),
      R"""(No docstring available

Parameters
----------
arr_in : 
arr_inout : 
arr_out : 
opt_status : 
arr_in_opt : 
arr_inout_opt : 
)""");
  py::class_<
      CppBmadTest::TestBunchStructArray,
      std::unique_ptr<CppBmadTest::TestBunchStructArray>>(
      m,
      "TestBunchStructArray",
      "Fortran routine test_bunch_struct_array return value")
      .def_readonly("arr_out", &CppBmadTest::TestBunchStructArray::arr_out)
      .def_readonly(
          "opt_status", &CppBmadTest::TestBunchStructArray::opt_status)
      .def(
          "__len__", [](const CppBmadTest::TestBunchStructArray&) { return 2; })
      .def(
          "__getitem__",
          [](const CppBmadTest::TestBunchStructArray& s,
             size_t i) -> py::object {
            if (i >= 2)
              throw py::index_error();
            if (i == 0)
              return py::cast(s.arr_out);
            if (i == 1)
              return py::cast(s.opt_status);
            return py::none();
          });
}
