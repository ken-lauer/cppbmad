"""
pybmad
"""
from __future__ import annotations
import collections.abc
import enum
import typing
__all__: list[str] = ['A0', 'A0_ELEC', 'A21', 'A21_ELEC', 'ABS', 'ABSOLUTE', 'ABSOLUTE_TIME_TRACKING', 'AB_MULTIPOLE', 'ACCORDION_EDGE', 'ACOS', 'ACOSH', 'ACOTH', 'AC_KICKER', 'ALIAS', 'ALIVE', 'ALL', 'ALL_CONTROL_VAR', 'ALL_GROUPS', 'ALPHA_A', 'ALPHA_A0', 'ALPHA_A1', 'ALPHA_ANGLE', 'ALPHA_A_OUT', 'ALPHA_A_STORED', 'ALPHA_A_STRONG', 'ALPHA_B', 'ALPHA_B0', 'ALPHA_B1', 'ALPHA_B_OUT', 'ALPHA_B_STORED', 'ALPHA_B_STRONG', 'AMPERSAND', 'AMP_VS_TIME', 'ANCHOR_BEGINNING', 'ANCHOR_CENTER', 'ANCHOR_END', 'ANGLE', 'ANGLE_OUT_MAX', 'ANOMALOUS_MAG_MOMENT_DEUTERON', 'ANOMALOUS_MAG_MOMENT_ELECTRON', 'ANOMALOUS_MAG_MOMENT_HE3', 'ANOMALOUS_MAG_MOMENT_MUON', 'ANOMALOUS_MAG_MOMENT_NEUTRON', 'ANOMALOUS_MAG_MOMENT_PROTON', 'ANOMALOUS_MOMENT_OF', 'ANTIMUON', 'ANTIPARTICLE', 'ANTIPROTON', 'ANTI_ATOM', 'ANTI_DEUTERON', 'ANTI_HELION', 'ANTI_NEUTRON', 'ANTI_REF_PARTICLE', 'APERTURE', 'APERTURE_AT', 'APERTURE_TYPE', 'AREA_DENSITY', 'AREA_DENSITY_USED', 'ARG_COUNT', 'ARROW', 'ASCII', 'ASIN', 'ASINH', 'ATAN', 'ATAN2', 'ATANH', 'ATOMIC_MASS_UNIT', 'ATTRIBUTE_GROUP', 'AUTO', 'AUTOSCALE_AMPLITUDE', 'AUTOSCALE_PHASE', 'AUTO_APERTURE', 'AVERAGE', 'AbMultipoleKick', 'AbsoluteTimeTracking', 'AcKickerAmp', 'AcKickerFreqStruct', 'AcKickerFreqStructAlloc1D', 'AcKickerFreqStructArray1D', 'AcKickerStruct', 'AcKickerTimeStruct', 'AcKickerTimeStructAlloc1D', 'AcKickerTimeStructArray1D', 'ActionToXyz', 'AddSuperimpose', 'AddThisTaylorTerm', 'AdjustSuperSlaveNames', 'AllEncompassingStruct', 'AngleBetweenPolars', 'AnormalModeStruct', 'ApertureParamStruct', 'AperturePointStruct', 'AperturePointStructAlloc1D', 'AperturePointStructArray1D', 'ApertureScanStruct', 'ApertureScanStructAlloc1D', 'ApertureScanStructArray1D', 'Apfft', 'ApfftCorr', 'ApfftExt', 'ArrayReStr', 'Asinc', 'AssertEqual', 'AstraMaxFieldReference', 'AtThisEleEnd', 'AttributeFree1', 'AttributeFree2', 'AttributeFree3', 'AttributeIndex1', 'AttributeIndex2', 'AttributeName1', 'AttributeName2', 'B0', 'B0_ELEC', 'B1_GRADIENT', 'B21', 'B21_ELEC', 'B2_GRADIENT', 'B3_GRADIENT', 'BASIC_BEND', 'BBI_CONST', 'BEAMBEAM', 'BEGINNING_ELE', 'BENDS', 'BEND_TILT', 'BETA_A', 'BETA_A0', 'BETA_A1', 'BETA_A_OUT', 'BETA_A_STORED', 'BETA_A_STRONG', 'BETA_B', 'BETA_B0', 'BETA_B1', 'BETA_B_OUT', 'BETA_B_STORED', 'BETA_B_STRONG', 'BINARY', 'BLACK', 'BLANK', 'BLUE', 'BL_HKICK', 'BL_KICK', 'BL_VKICK', 'BMAD_INC_VERSION', 'BMAD_STANDARD', 'BOTH_ENDS', 'BRAGG_ANGLE', 'BRAGG_ANGLE_IN', 'BRAGG_ANGLE_OUT', 'BRAGG_DIFFRACTED', 'BS_FIELD', 'B_FIELD', 'B_FIELD_ERR', 'B_FIELD_TOT', 'B_MAX', 'B_PARAM', 'BbiKick', 'BbuBeamStruct', 'BbuHomVoltageCalc', 'BbuParamStruct', 'BbuSetup', 'BbuStageStruct', 'BbuStageStructAlloc1D', 'BbuStageStructArray1D', 'BbuTrackAStage', 'BbuTrackAll', 'BeamInitStruct', 'BeamStruct', 'BeamTilts', 'BendLengthHasBeenSet', 'BicubicCmplxCoefStruct', 'BicubicCmplxCoefStructArray3D', 'BicubicCmplxEval', 'BinXCenter', 'BitSet', 'BmadCommonStruct', 'BmadNormalFormStruct', 'BmadParser', 'BmadParser2', 'BookkeepingStateStruct', 'BoolAlloc1D', 'BoolArray1D', 'BoolArray2D', 'BoolArray3D', 'BpmPhaseCouplingStruct', 'BracketIndexForSpline', 'BranchName', 'BranchStruct', 'BranchStructAlloc1D', 'BranchStructArray1D', 'BunchParamsStruct', 'BunchParamsStructAlloc1D', 'BunchParamsStructArray1D', 'BunchStruct', 'BunchStructAlloc1D', 'BunchStructArray1D', 'BunchTrackStruct', 'BunchTrackStructAlloc1D', 'BunchTrackStructArray1D', 'C11_MAT0', 'C11_MAT1', 'C12_MAT0', 'C12_MAT1', 'C21_MAT0', 'C21_MAT1', 'C22_MAT0', 'C22_MAT1', 'CANNOT_FIND', 'CAPILLARY', 'CARTESIAN_MAP', 'CATHODE_FFT_3D', 'CAVITY_TYPE', 'CEILING', 'CENTER_PT', 'CHAMBER_WALL', 'CHARGE', 'CHARGE_OF', 'CHECK_SUM', 'CIRCLE_DOT_SYM', 'CIRCLE_FILLED_SYM', 'CIRCLE_PLUS_SYM', 'CIRCLE_SYM', 'CLASSICAL_RADIUS_FACTOR', 'CLEAR', 'CLOSED', 'CMAT_11', 'CMAT_11_STORED', 'CMAT_12', 'CMAT_12_STORED', 'CMAT_21', 'CMAT_21_STORED', 'CMAT_22', 'CMAT_22_STORED', 'COHERENT', 'COLON', 'COMMA', 'COMPOUND', 'CONSTANT', 'CONSTANT_REF_ENERGY', 'CONTINUOUS', 'CONTROL_GROUP', 'CONTROL_LORD', 'CONTROL_VAR', 'CONVERTER', 'COS', 'COSH', 'COT', 'COTH', 'COUPLER_ANGLE', 'COUPLER_AT', 'COUPLER_PHASE', 'COUPLER_STRENGTH', 'CRAB_CAVITY', 'CRAB_TILT', 'CRAB_X1', 'CRAB_X2', 'CRAB_X3', 'CRAB_X4', 'CRAB_X5', 'CREATE_JUMBO_SLAVE', 'CRITICAL_ANGLE', 'CRITICAL_ANGLE_FACTOR', 'CROSSING_TIME', 'CROSS_HATCHED', 'CRUNCH', 'CRUNCH_CALIB', 'CRYSTAL', 'CRYSTAL_TYPE', 'CSC', 'CSR_DS_STEP', 'CSR_METHOD', 'CUBIC', 'CURLY_BRACKETS', 'CURRENT', 'CURVATURE', 'CURVE', 'CUSTOM', 'CUSTOM_APERTURE', 'CUSTOM_ATTRIBUTE0', 'CUSTOM_ATTRIBUTE_NUM', 'CYAN', 'CYCLES', 'CYLINDRICAL_MAP', 'C_LIGHT', 'CalcBunchSigmaMatrixEtc', 'CalcEmittancesAndTwissFromSigmaMatrix', 'CalcFileNumber', 'CalcWallRadius', 'CartesianMapStruct', 'CartesianMapStructAlloc1D', 'CartesianMapStructArray1D', 'CartesianMapTerm1Struct', 'CartesianMapTerm1StructAlloc1D', 'CartesianMapTerm1StructArray1D', 'CartesianMapTermStruct', 'ChangeFileNumber', 'CheckForSuperimposeProblem', 'CheckIfSInBounds', 'CheckRfFreq', 'ChooseQuadsForSetTune', 'ChromCalc', 'ChromTune', 'ClassicalRadius', 'ClosedOrbitFromTracking', 'CmplxReStr', 'CoarseFrequencyEstimate', 'ComplexAlloc1D', 'ComplexArray1D', 'ComplexArray2D', 'ComplexArray3D', 'ComplexErrorFunction', 'ComplexTaylorCoef1', 'ComplexTaylorCoef2', 'ComplexTaylorStruct', 'ComplexTaylorStructAlloc1D', 'ComplexTaylorStructArray1D', 'ComplexTaylorTermStruct', 'ComplexTaylorTermStructAlloc1D', 'ComplexTaylorTermStructArray1D', 'ComplexTaylorToMat6', 'ControlRamp1Struct', 'ControlRamp1StructAlloc1D', 'ControlRamp1StructArray1D', 'ControlStruct', 'ControlStructAlloc1D', 'ControlStructArray1D', 'ControlVar1Struct', 'ControlVar1StructAlloc1D', 'ControlVar1StructArray1D', 'ControllerStruct', 'ConvertCoords', 'ConvertLocalCartesianToLocalCurvilinear', 'ConvertLocalCurvilinearToLocalCartesian', 'ConvertPcTo', 'ConvertTotalEnergyTo', 'ConverterDistributionParser', 'CoordArrayStruct', 'CoordArrayStructAlloc1D', 'CoordArrayStructArray1D', 'CoordStateName', 'CoordStruct', 'CoordStructAlloc1D', 'CoordStructArray1D', 'CoordsFloorToCurvilinear', 'CoordsFloorToLocalCurvilinear', 'CoordsRelativeToFloor', 'CosOne', 'Cosc', 'Coulombfun', 'CreateConcatenatedWall3d', 'CreateElementSlice', 'CreateGirder', 'CreatePlanarWigglerModel', 'CylindricalMapStruct', 'CylindricalMapStructAlloc1D', 'CylindricalMapStructArray1D', 'CylindricalMapTerm1Struct', 'CylindricalMapTerm1StructAlloc1D', 'CylindricalMapTerm1StructArray1D', 'CylindricalMapTermStruct', 'D1_THICKNESS', 'D2_THICKNESS', 'DALPHA_DPZ_A', 'DALPHA_DPZ_A_STORED', 'DALPHA_DPZ_B', 'DALPHA_DPZ_B_STORED', 'DARK_GREY', 'DARWIN_WIDTH_PI', 'DARWIN_WIDTH_SIGMA', 'DASHED', 'DASH_DOT', 'DASH_DOT3', 'DBETA_DPZ_A', 'DBETA_DPZ_A_STORED', 'DBETA_DPZ_B', 'DBETA_DPZ_B_STORED', 'DBRAGG_ANGLE_DE', 'DB_FIELD', 'DCMAT_DPZ_11_STORED', 'DCMAT_DPZ_12_STORED', 'DCMAT_DPZ_21_STORED', 'DCMAT_DPZ_22_STORED', 'DEFAULT_TRACKING_SPECIES', 'DEF_BMAD_COM', 'DEF_LINE', 'DEF_MAD_BEAM', 'DEF_PARAMETER', 'DEF_PARTICLE_START', 'DEF_PTC_COM', 'DEF_SPACE_CHARGE_COM', 'DEGREES', 'DELTA_E_REF', 'DELTA_REF_TIME', 'DELTA_REF_TIME_USER_SET', 'DELTA_TIME', 'DENSITY', 'DENSITY_USED', 'DESCRIP', 'DETAP_DPZ_X', 'DETAP_DPZ_X_STORED', 'DETAP_DPZ_Y', 'DETAP_DPZ_Y_STORED', 'DETA_DPZ_X', 'DETA_DPZ_X_STORED', 'DETA_DPZ_Y', 'DETA_DPZ_Y_STORED', 'DETA_DS_MASTER', 'DETECTOR', 'DEUTERON', 'DE_ETA_MEAS', 'DFLT_DRAW', 'DFLT_SET', 'DG', 'DIAMOND_SYM', 'DIFFRACTION_PLATE', 'DIRECTION', 'DISPATCH', 'DISTRIBUTION', 'DIVIDE', 'DOTTED', 'DOT_SYM', 'DOUBLE_COLON', 'DOWNSTREAM', 'DOWNSTREAM_COORD_DIR', 'DOWNSTREAM_END', 'DPHI_A', 'DPHI_B', 'DPHI_ORIGIN', 'DPSI_ORIGIN', 'DRIFT', 'DRIFT_KICK', 'DS_PHOTON_SLICE', 'DS_SLICE', 'DS_STEP', 'DTHETA_ORIGIN', 'DTHICKNESS_DX', 'DT_MAX', 'DX_ORIGIN', 'DY_ORIGIN', 'DZ_ORIGIN', 'D_SPACING', 'DampingMatrixD', 'DateAndTimeStamp', 'DefaultTrackingSpecies', 'Detab', 'DiffractionPlateOrMaskHitSpot', 'DiffusionMatrixB', 'DisplaySizeAndResolution', 'DistanceToAperture', 'DjBessel', 'DjbHash', 'DjbStrHash', 'DowncaseString', 'DpcGivenDe', 'E1', 'E1_GRADIENT', 'E2', 'E2_CENTER', 'E2_GRADIENT', 'E2_PROBABILITY', 'E3_GRADIENT', 'EAccelField', 'ECOLLIMATOR', 'ELECTRIC', 'ELECTRIC_DIPOLE_MOMENT', 'ELECTRON', 'ELEC_MULTIPOLE', 'ELE_ORIGIN', 'ELLIPTICAL', 'ELSEPARATOR', 'EMITTANCE_A', 'EMITTANCE_B', 'EMITTANCE_Z', 'EMIT_FRACTION', 'EM_FIELD', 'END_EDGE', 'END_STACK', 'ENERGY_DISTRIBUTION', 'ENERGY_PROBABILITY_CURVE', 'ENTRANCE_END', 'EPS_STEP_SCALE', 'EQUAL', 'ETAP_A', 'ETAP_B', 'ETAP_X', 'ETAP_X0', 'ETAP_X1', 'ETAP_X_OUT', 'ETAP_X_STORED', 'ETAP_Y', 'ETAP_Y0', 'ETAP_Y1', 'ETAP_Y_OUT', 'ETAP_Y_STORED', 'ETA_A', 'ETA_B', 'ETA_X', 'ETA_X0', 'ETA_X1', 'ETA_X_OUT', 'ETA_X_STORED', 'ETA_Y', 'ETA_Y0', 'ETA_Y1', 'ETA_Y_OUT', 'ETA_Y_STORED', 'ETA_Z', 'EXACT_MISALIGN', 'EXACT_MODEL', 'EXACT_MULTIPOLES', 'EXIT_END', 'EXP', 'E_CENTER', 'E_CENTER_RELATIVE_TO_REF', 'E_CHARGE', 'E_FIELD', 'E_FIELD_X', 'E_FIELD_Y', 'E_GUN', 'E_LOSS', 'E_MASS', 'E_PHOTON', 'E_TOT', 'E_TOT_OFFSET', 'E_TOT_REF_INIT', 'E_TOT_SET', 'E_TOT_START', 'E_TOT_STRONG', 'EigenDecomp6mat', 'EleAttribute', 'EleFullName', 'EleHasConstantDsDtRef', 'EleHasNonzeroKick', 'EleHasNonzeroOffset', 'EleKey', 'EleLocName', 'EleMisalignmentLSCalc', 'EleNametableIndex', 'ElePointerStruct', 'ElePointerStructAlloc1D', 'ElePointerStructArray1D', 'EleRfStepIndex', 'EleStruct', 'EleStructAlloc1D', 'EleStructArray1D', 'EleToPtcMagneticBnAn', 'EleToTaylor', 'EleUniqueName', 'EleValueHasChanged', 'ElecMultipoleField', 'ElementAtSBranch', 'ElementAtSLat', 'EllipseBeamInitStruct', 'EllipseBeamInitStructAlloc1D', 'EllipseBeamInitStructArray1D', 'EmFieldCalc', 'EmFieldDerivatives', 'EmFieldStruct', 'EmFieldStructAlloc1D', 'EmFieldStructArray1D', 'EmTaylorStruct', 'EmTaylorStructAlloc1D', 'EmTaylorStructArray1D', 'EmTaylorTermStruct', 'EmTaylorTermStructAlloc1D', 'EmTaylorTermStructArray1D', 'Emit6d', 'EnteringElement', 'EnvelopeRadintsIbs', 'EqAcKicker', 'EqAcKickerFreq', 'EqAcKickerTime', 'EqAnormalMode', 'EqApertureParam', 'EqAperturePoint', 'EqApertureScan', 'EqBeam', 'EqBeamInit', 'EqBmadCommon', 'EqBookkeepingState', 'EqBpmPhaseCoupling', 'EqBranch', 'EqBunch', 'EqBunchParams', 'EqCartesianMap', 'EqCartesianMapTerm', 'EqCartesianMapTerm1', 'EqComplexTaylor', 'EqComplexTaylorTerm', 'EqControl', 'EqControlRamp1', 'EqControlVar1', 'EqController', 'EqCoord', 'EqCoordArray', 'EqCylindricalMap', 'EqCylindricalMapTerm', 'EqCylindricalMapTerm1', 'EqEle', 'EqEllipseBeamInit', 'EqEmField', 'EqEmTaylor', 'EqEmTaylorTerm', 'EqExpressionAtom', 'EqFloorPosition', 'EqGenGrad1', 'EqGenGradMap', 'EqGridBeamInit', 'EqGridField', 'EqGridFieldPt', 'EqGridFieldPt1', 'EqHighEnergySpaceCharge', 'EqInterval1Coef', 'EqKvBeamInit', 'EqLat', 'EqLatEleLoc', 'EqLatParam', 'EqLinacNormalMode', 'EqMode3', 'EqModeInfo', 'EqNormalModes', 'EqPhotonElement', 'EqPhotonMaterial', 'EqPhotonReflectSurface', 'EqPhotonReflectTable', 'EqPhotonTarget', 'EqPixelDetec', 'EqPixelPt', 'EqPreTracker', 'EqRadInt1', 'EqRadIntAllEle', 'EqRadIntBranch', 'EqRadMap', 'EqRadMapEle', 'EqRamperLord', 'EqSpaceChargeCommon', 'EqSpinPolar', 'EqSpline', 'EqStrongBeam', 'EqSurfaceCurvature', 'EqSurfaceDisplacement', 'EqSurfaceDisplacementPt', 'EqSurfaceHMisalign', 'EqSurfaceHMisalignPt', 'EqSurfaceSegmented', 'EqSurfaceSegmentedPt', 'EqTargetPoint', 'EqTaylor', 'EqTaylorTerm', 'EqTrack', 'EqTrackPoint', 'EqTwiss', 'EqWake', 'EqWakeLr', 'EqWakeLrMode', 'EqWakeSr', 'EqWakeSrMode', 'EqWakeSrZLong', 'EqWall3d', 'EqWall3dSection', 'EqWall3dVertex', 'EqXyDisp', 'EqualSignHere', 'EquivalentTaylorAttributes', 'ErrExit', 'Etdiv', 'EvaluateArrayIndex', 'EvaluateLogical', 'ExpectOneOf', 'ExpectThis', 'ExpressionAtomStruct', 'ExpressionAtomStructAlloc1D', 'ExpressionAtomStructArray1D', 'ExpressionStackValue', 'ExpressionStringToStack', 'ExpressionStringToTree', 'ExpressionTreeStruct', 'ExpressionTreeStructAlloc1D', 'ExpressionTreeStructArray1D', 'ExpressionValue', 'FACTORIAL', 'FALSE_', 'FALSE_INT', 'FAMILY_QU', 'FAMILY_SQ', 'FAMILY_X', 'FAMILY_Y', 'FB1', 'FB2', 'FCharArray1D', 'FEEDBACK', 'FFT_3D', 'FIDUCIAL', 'FIDUCIAL_PT', 'FIELDMAP', 'FIELD_AUTOSCALE', 'FIELD_CALC', 'FIELD_LORD', 'FIELD_MASTER', 'FIELD_OVERLAPS', 'FIELD_SCALE_FACTOR', 'FIELD_X', 'FIELD_Y', 'FILLED_ARROW_HEAD', 'FINAL_CHARGE', 'FINE_STRUCTURE_CONSTANT', 'FINT', 'FINTX', 'FIRST_PASS', 'FIRST_TRACK_EDGE', 'FIXED_STEP_RUNGE_KUTTA', 'FIXED_STEP_TIME_RUNGE_KUTTA', 'FIXER', 'FLEXIBLE', 'FLOOR', 'FLOOR_POSITION_GROUP', 'FLOOR_SHIFT', 'FOCAL_STRENGTH', 'FOIL', 'FORK', 'FORWARD_DIFFRACTED', 'FOURPI', 'FQ1', 'FQ2', 'FREE', 'FREQUENCIES', 'FRINGE_AT', 'FRINGE_TYPE', 'FULL', 'FUNCTION', 'FUNC_PARENS', 'F_FACTOR', 'Factorial', 'FileDirectorizer', 'FileGet', 'FileGetOpen', 'FileSuffixer', 'FindElementEnds', 'FindLocationInt', 'FindLocationLogic', 'FindLocationReal', 'FindMatchingFieldmap', 'Fixedwindowls', 'FloorAnglesToWMat', 'FloorPositionStruct', 'FloorWMatToAngles', 'FormDigestedBmadFileName', 'FourierAmplitude', 'FringeHere', 'G', 'GANG', 'GAP', 'GAUSSIAN', 'GBendingStrengthFromEmField', 'GEN_GRAD_MAP', 'GEOMETRY', 'GIRDER', 'GIRDER_LORD', 'GKICKER', 'GOVERNOR', 'GRADIENT', 'GRADIENT_ERR', 'GRADIENT_TOT', 'GRAZE_ANGLE', 'GRAZE_ANGLE_IN', 'GRAZE_ANGLE_OUT', 'GREEN', 'GRID_FIELD', 'GROUP', 'GROUP_LORD', 'G_ERR', 'G_MAX', 'G_TOT', 'GammaRef', 'GenCompleteElliptic', 'GenGrad1Struct', 'GenGrad1StructAlloc1D', 'GenGrad1StructArray1D', 'GenGradField', 'GenGradMapStruct', 'GenGradMapStructAlloc1D', 'GenGradMapStructArray1D', 'GetCalledFile', 'GetEmitFromSigmaMat', 'GetFileNumber', 'GetFileTimeStamp', 'GetSlaveList', 'GptFieldGridScaling', 'GptMaxFieldReference', 'GptToParticleBunch', 'GradientShiftSrWake', 'GridBeamInitStruct', 'GridBeamInitStructAlloc1D', 'GridBeamInitStructArray1D', 'GridFieldPt1Struct', 'GridFieldPt1StructArray3D', 'GridFieldPtStruct', 'GridFieldStruct', 'GridFieldStructAlloc1D', 'GridFieldStructArray1D', 'H1', 'H2', 'HARD_EDGE_ONLY', 'HARMON', 'HARMON_MASTER', 'HATCHED', 'HDF5', 'HELICAL_MODEL', 'HELION', 'HGAP', 'HGAPX', 'HIGHLAND', 'HIGH_ENERGY_SPACE_CHARGE_ON', 'HKICK', 'HKICKER', 'HORIZONTALLY_PURE', 'HYBRID', 'HYPER_X', 'HYPER_XY', 'HYPER_Y', 'H_BAR_PLANCK', 'H_DISPLACE', 'H_PLANCK', 'Hanhan', 'HasAttribute', 'Hdf5WriteBeam', 'Hdf5WriteGridField', 'HighEnergySpaceChargeStruct', 'HomVoltage', 'IBessel', 'IBesselExtended', 'IDENTITY', 'IMPACTT', 'INCLUDE_KICKS', 'INCOHERENT', 'INHERIT_FROM_FORK', 'INIT_NEEDED', 'INPUT_ELE', 'INSIDE', 'INSTRUMENT', 'INT', 'INTEGRATOR_ORDER', 'INTERPOLATION', 'INT_GARBAGE', 'INVALID', 'INVALID_NAME', 'IN_BETWEEN', 'IN_STOP_BAND', 'IS_INTEGER', 'IS_LOGICAL', 'IS_MOSAIC', 'IS_ON', 'IS_REAL', 'IS_STRING', 'IS_STRUCT', 'IS_SWITCH', 'IX_BRANCH', 'IX_FIXER', 'IX_SLICE_SLAVE', 'IX_TO_BRANCH', 'IX_TO_ELEMENT', 'IbsMatrixC', 'Igfcoulombfun', 'Igfexfun', 'Igfeyfun', 'Igfezfun', 'IncrementFileNumber', 'IndexNocase', 'InitBeamDistribution', 'InitBunchDistribution', 'InitPhotonIntegProb', 'InitSurfaceSegment', 'Int8Alloc1D', 'Int8Array1D', 'IntAlloc1D', 'IntArray1D', 'IntArray2D', 'IntArray3D', 'IntStr', 'IntegrandBase', 'IntegrateMax', 'IntegrateMin', 'IntegrationTimerEle', 'InterpolatedFft', 'InterpolatedFftGsl', 'Interval1CoefStruct', 'Interval1CoefStructAlloc1D', 'Interval1CoefStructArray1D', 'IsAlphabetic', 'IsDecreasingSequence', 'IsIncreasingSequence', 'IsInteger', 'IsLogical', 'IsReal', 'JBessel', 'K0L', 'K0SL', 'K1', 'K1X', 'K1Y', 'K2', 'K21L', 'K21SL', 'K3', 'KICK', 'KICK0', 'KICKER', 'KS', 'KX', 'KeyNameToKeyIndex', 'KickVectorCalc', 'KnotInterpolate', 'KnotsToString', 'KvBeamInitStruct', 'L', 'LATTICE', 'LATTICE_TYPE', 'LB_SUBATOMIC', 'LCAVITY', 'LEADING', 'LENS', 'LIGHT_GREEN', 'LIGHT_GREY', 'LINEAR', 'LINEAR_EDGE', 'LIVE_BRANCH', 'LOG', 'LONGITUDINAL_MODE', 'LORD_DEFINED', 'LORD_PAD1', 'LORD_PAD2', 'LOST', 'LOST_NEG_X', 'LOST_NEG_X_APERTURE', 'LOST_NEG_Y', 'LOST_NEG_Y_APERTURE', 'LOST_POS_X', 'LOST_POS_X_APERTURE', 'LOST_POS_Y', 'LOST_POS_Y_APERTURE', 'LOST_PZ', 'LOST_PZ_APERTURE', 'LOST_Z', 'LOST_Z_APERTURE', 'LR_FREQ_SPREAD', 'LR_SELF_WAKE_ON', 'LR_WAKE', 'LR_WAKE_FILE', 'LYNCH_DAHL', 'L_ACTIVE', 'L_CHORD', 'L_FUNC_PARENS', 'L_PARENS', 'L_PERIOD', 'L_RECTANGLE', 'L_SAGITTA', 'L_SOFT_EDGE', 'Lafun', 'LatEleLocStruct', 'LatEleLocStructAlloc1D', 'LatEleLocStructArray1D', 'LatEleLocator', 'LatEleOrder1Struct', 'LatEleOrder1StructAlloc1D', 'LatEleOrder1StructArray1D', 'LatEleOrderArrayStruct', 'LatEleOrderArrayStructAlloc1D', 'LatEleOrderArrayStructArray1D', 'LatEleOrderStruct', 'LatParamStruct', 'LatStruct', 'LatStructAlloc1D', 'LatStructArray1D', 'LinacNormalModeStruct', 'LinearCoef', 'LinearFit', 'LoadParseLine', 'LogicStr', 'LogicalToPython', 'LordEdgeAligned', 'LowEnergyZCorrection', 'MACHINE', 'MAD', 'MAGENTA', 'MAGNETIC', 'MAGNUS', 'MARKER', 'MASK', 'MASK_PLATE', 'MASS_OF', 'MAT6_CALC_METHOD', 'MAT6_GROUP', 'MATCH', 'MATCH_ORBIT', 'MATCH_TWISS', 'MATERIAL_TYPE', 'MATRIX', 'MATRIX_KICK', 'MAX', 'MAX_FRINGE_ORDER', 'MAYBE', 'MEAN_EXCITATION_ENERGY', 'MIN', 'MINOR_SLAVE', 'MINUS', 'MIRROR', 'MIXED', 'MODE', 'MODE_FLIP', 'MODE_FLIP0', 'MODE_FLIP1', 'MODE_FLIP_STORED', 'MODULO', 'MONITOR', 'MOSAIC_ANGLE_RMS_IN_PLANE', 'MOSAIC_ANGLE_RMS_OUT_PLANE', 'MOSAIC_DIFFRACTION_NUM', 'MOSAIC_THICKNESS', 'MOVING_FORWARD', 'MULTILAYER_MIRROR', 'MULTIPASS_LORD', 'MULTIPASS_REF_ENERGY', 'MULTIPASS_SLAVE', 'MULTIPOLE', 'MULTIPOLES_ON', 'MULTIPOLE_SOURCE', 'MULTIPOLE_SYMMETRY', 'MUON', 'MU_0_VAC', 'M_DEUTERON', 'M_ELECTRON', 'M_HELION', 'M_MUON', 'M_NEUTRON', 'M_PION_0', 'M_PION_CHARGED', 'M_PROTON', 'MadEnergyStruct', 'MadMapStruct', 'MadTmfoc', 'MakeGMats', 'MakeHvbp', 'MakeLegalComment', 'MakeMadMap', 'MakeMat6', 'MakeMat6Bmad', 'MakeMat6BmadPhoton', 'MakeMat6Taylor', 'MakeMat6Tracking', 'MakeN', 'MakePbrh', 'MakeSmatFromAbc', 'MakeVMats', 'MakeupControlSlave', 'MakeupGroupLord', 'MakeupMultipassSlave', 'MakeupSuperSlave', 'MasterParameterValue', 'Mat4Multipole', 'MatSympDecouple', 'MatchEleToMat6', 'MatchReg', 'MatchWild', 'MaximizeProjection', 'Mexp', 'MilliSleep', 'Mode3Struct', 'ModeInfoStruct', 'MomentumCompaction', 'MultiTurnTrackingAnalysis', 'Multipole1AbToKt', 'Multipole1KtToAb', 'MultipoleAbToKt', 'MultipoleEleToAb', 'MultipoleEleToKt', 'MultipoleKtToAb', 'Mytan', 'NAVY_BLUE', 'NBinsAutomatic', 'NChooseK', 'NEUTRON', 'NEW_BRANCH', 'NINT', 'NO', 'NOISE', 'NONE', 'NONE_PT', 'NON_SYMPLECTIC', 'NORMAL', 'NOT_A_LORD', 'NOT_SET', 'NOWHERE', 'NO_APERTURE', 'NO_CLOSED_ORBIT', 'NO_COMPLETE_ORBIT', 'NO_DELIM', 'NO_END', 'NO_END_MARKER', 'NO_FIELD', 'NO_FILL', 'NO_MISALIGNMENT', 'NULL_ELE', 'NUMERIC', 'NUM_ELE_ATTRIB', 'NUM_ELE_ATTRIB_EXTENDED', 'NUM_STEPS', 'N_AVOGADRO', 'N_CELL', 'N_KEY', 'N_PART', 'N_PARTICLE', 'N_PERIOD', 'N_PLANE', 'N_POLE_MAXX', 'N_RF_STEPS', 'N_SAMPLE', 'N_SLICE', 'N_SLICE_SPLINE', 'N_VAR_MAX', 'Naff', 'NametableAdd', 'NametableBracketIndexx', 'NametableChange1', 'NametableInit', 'NametableRemove', 'NametableStruct', 'NormalFormComplexTaylors', 'NormalFormTaylors', 'NormalMode3Calc', 'NormalModesStruct', 'NumFieldEles', 'NumLords', 'OCTUPOLE', 'OFF', 'OFFSET_MOVES_APERTURE', 'OFF_AND_SAVE', 'OK', 'OLD_ASCII', 'OLD_CONTROL_VAR', 'OLD_CONTROL_VAR_OFFSET', 'OLD_INTEGRATOR', 'ON', 'ONE_DIM', 'ONE_FILE', 'OPAL', 'OPAQUE', 'OPEN', 'ORANGE', 'ORIGIN_ELE', 'ORIGIN_ELE_REF_PT', 'OSC_AMPLITUDE', 'OUTLINE_ARROW_HEAD', 'OUTPUT_ELE', 'OUTSIDE', 'OVERLAY', 'OVERLAY_LORD', 'OdeintBmad', 'OdeintBmadTime', 'OffsetParticle', 'OpenBinaryFile', 'OrbitAmplitudeCalc', 'OrbitTooLarge', 'OrderEvecsByNSimilarity', 'OrdinalStr', 'OscGetgrnpipe', 'OscWriteRectpipeGrn', 'P0C', 'P0C_REF_INIT', 'P0C_SET', 'P0C_START', 'P88', 'P89', 'P90', 'PARENS', 'PARTICLE', 'PATCH', 'PATCH_PROBLEM', 'PC_OUT_MAX', 'PC_OUT_MIN', 'PC_STRONG', 'PENDELLOSUNG_PERIOD_PI', 'PENDELLOSUNG_PERIOD_SIGMA', 'PHASE_TROMBONE', 'PHASE_X', 'PHASE_Y', 'PHI0', 'PHI0_AUTOSCALE', 'PHI0_ERR', 'PHI0_MAX', 'PHI0_MULTIPASS', 'PHI_A', 'PHI_A_STORED', 'PHI_B', 'PHI_B_STORED', 'PHI_POSITION', 'PHOTON', 'PHOTON_FORK', 'PHOTON_INIT', 'PHOTON_TYPE', 'PHYSICAL_SOURCE', 'PI', 'PICKUP', 'PION_0', 'PION_MINUS', 'PION_PLUS', 'PIPE', 'PIXEL', 'PLANAR_MODEL', 'PLUS', 'PLUS_SYM', 'POLARITY', 'POLARIZED', 'POSITRON', 'POWER', 'PRE_BORN', 'PRINT_PAGE_LONG_LEN', 'PRINT_PAGE_SHORT_LEN', 'PROTON', 'PROVISIONAL', 'PSI_ANGLE', 'PSI_POSITION', 'PTC_CANONICAL_COORDS', 'PTC_FIELD_GEOMETRY', 'PTC_FRINGE_GEOMETRY', 'PTC_INTEGRATION_TYPE', 'PTC_STANDARD', 'PURPLE', 'PX', 'PX0', 'PX1', 'PX_APERTURE_CENTER', 'PX_APERTURE_WIDTH2', 'PX_KICK', 'PX_REF', 'PX_STORED', 'PY', 'PY0', 'PY1', 'PY_APERTURE_CENTER', 'PY_APERTURE_WIDTH2', 'PY_KICK', 'PY_REF', 'PY_STORED', 'PZ', 'PZ0', 'PZ1', 'PZ_APERTURE_CENTER', 'PZ_APERTURE_WIDTH2', 'PZ_KICK', 'PZ_REF', 'PZ_STORED', 'P_MASS', 'ParseCartesianMap', 'ParseCylindricalMap', 'ParseFortranFormat', 'ParseGenGradMap', 'ParseGridField', 'ParseIntegerList', 'ParseIntegerList2', 'ParseRealList', 'ParseRealList2', 'ParserAddConstant', 'ParserCallCheck', 'ParserFastComplexRead', 'ParserFastIntegerRead', 'ParserFastRealRead', 'ParserFileStack', 'ParserGetInteger', 'ParserGetLogical', 'ParserPrintLine', 'ParserReadLrWake', 'ParserReadSrWake', 'ParticleIsMovingBackwards', 'ParticleIsMovingForward', 'ParticleRfTime', 'PatchFlipsPropagationDirection', 'PatchLength', 'PhotonAbsorptionAndPhaseShift', 'PhotonAddToDetectorStatistics', 'PhotonElementStruct', 'PhotonMaterialStruct', 'PhotonReflectSurfaceStruct', 'PhotonReflectTableStruct', 'PhotonReflectTableStructAlloc1D', 'PhotonReflectTableStructArray1D', 'PhotonReflection', 'PhotonReflectivity', 'PhotonTargetCornerCalc', 'PhotonTargetStruct', 'PhysicalEleEnd', 'PixelDetecStruct', 'PixelPtStruct', 'PixelPtStructArray2D', 'PointerToEle1', 'PointerToEle3', 'PointerToElementAtS', 'PointerToLord', 'PointerToMultipassLord', 'PointerToSlave', 'PointerToSuperLord', 'PointerToSurfaceDisplacementPt', 'PointerToSurfaceSegmentedPt', 'PointerToWall3d', 'PolyEval', 'PreTrackerStruct', 'ProbabilityFunct', 'Projdd', 'ProjectEmitToXyz', 'PtcEmitCalc', 'PtcNormalFormStruct', 'PtcSpinCalc', 'PtcTrackAll', 'QUADRUPOLE', 'QUAD_TILT', 'QpAxisStruct', 'QpLegendStruct', 'QpLineStruct', 'QpPointStruct', 'QpRectStruct', 'QpSymbolStruct', 'QuatToAxisAngle', 'QueryString', 'Quote', 'R0_ELEC', 'R0_MAG', 'RADIANS', 'RADIANS_OVER_2PI', 'RADIATION_LENGTH', 'RADIATION_LENGTH_USED', 'RADIUS', 'RAD_INT_GROUP', 'RAMPER', 'RAMPER_LORD', 'RAN', 'RAN_GAUSS', 'RAN_SEED', 'RBEND', 'RCOLLIMATOR', 'REAL_GARBAGE', 'RECALC', 'RECTANGULAR', 'RED', 'REDDISH_PURPLE', 'RED_CROSS_SYM', 'REFERENCE', 'REFER_TO_LORDS', 'REFLECTION', 'REFLECTIVITY_TABLE', 'REF_CAP_GAMMA', 'REF_COORDS', 'REF_ENERGY_GROUP', 'REF_ORBIT', 'REF_ORBIT_FOLLOWS', 'REF_ORIGIN', 'REF_PARTICLE', 'REF_SPECIES', 'REF_TILT', 'REF_TILT_TOT', 'REF_TIME', 'REF_TIME_START', 'REF_WAVELENGTH', 'RELATIVE', 'REPETITION_FREQUENCY', 'RESTORE_STATE', 'RFCAVITY', 'RF_BEND', 'RF_FREQUENCY', 'RF_WAVELENGTH', 'RHO', 'RIPKEN_KICK', 'RMS', 'ROLL', 'ROLL_TOT', 'ROOT', 'ROTATIONALLY_SYMMETRIC_RZ', 'RUNGE_KUTTA', 'R_E', 'R_P', 'R_PARENS', 'R_SOLENOID', 'Rad1DampAndStocMats', 'RadDampAndStocMats', 'RadGIntegrals', 'RadInt1Struct', 'RadInt1StructAlloc1D', 'RadInt1StructArray1D', 'RadIntAllEleStruct', 'RadIntBranchStruct', 'RadIntBranchStructAlloc1D', 'RadIntBranchStructArray1D', 'RadMapEleStruct', 'RadMapStruct', 'RadiationIntegrals', 'RamperLordStruct', 'RamperLordStructAlloc1D', 'RamperLordStructArray1D', 'RamperValue', 'RanGaussConverter', 'RanGaussScalar', 'RanGaussVector', 'RanUniformScalar', 'RandomStateStruct', 'Rchomp', 'ReAllocateCDouble', 'ReStrQp', 'ReStrRp', 'ReadBeamAscii', 'ReadBeamFile', 'Real16Alloc1D', 'Real16Array1D', 'RealAlloc1D', 'RealArray1D', 'RealArray2D', 'RealArray3D', 'RealNumFortranFormat', 'RealPath', 'RealStr', 'RealToString', 'ReallocateBeam', 'RelTrackingChargeToMass', 'RelativeModeFlip', 'ReleaseRadIntCache', 'RemoveConstantTaylor', 'ResonanceHStruct', 'ResonanceHStructAlloc1D', 'ResonanceHStructArray1D', 'RfEleStruct', 'RfIsOn', 'RfRefTimeOffset', 'RfStairStepStruct', 'RfStairStepStructAlloc1D', 'RfStairStepStructArray1D', 'Rfun', 'RkAdaptiveTimeStep', 'RkTimeStep1', 'RmsValue', 'Rotate3', 'RotateFieldZx', 'RunTimer', 'SAD_FULL', 'SAD_MULT', 'SAMPLE', 'SAVE_STATE', 'SBEND', 'SBodyCalc', 'SCALE_FIELD_TO_ONE', 'SCALE_MULTIPOLES', 'SCATTER_METHOD', 'SCATTER_TEST', 'SEC', 'SECOND_TRACK_EDGE', 'SECTOR', 'SEXTUPOLE', 'SHIFTED_TO_RELATIVE', 'SHORT', 'SIGN', 'SIG_E', 'SIG_E2', 'SIG_PZ', 'SIG_VX', 'SIG_VY', 'SIG_X', 'SIG_Y', 'SIG_Z', 'SIN', 'SINC', 'SINH', 'SLAVE', 'SLICE', 'SLICE_SLAVE', 'SMALL_REL_CHANGE', 'SOFT_EDGE', 'SOFT_EDGE_ONLY', 'SOLENOID', 'SOLID', 'SOLID_FILL', 'SOL_QUAD', 'SPACE_CHARGE_METHOD', 'SPATIAL_DISTRIBUTION', 'SPECIES', 'SPECIES_CONST', 'SPECIES_OUT', 'SPECIES_STRONG', 'SPHERICAL', 'SPIN_DN_DPZ_X', 'SPIN_DN_DPZ_Y', 'SPIN_DN_DPZ_Z', 'SPIN_FRINGE_ON', 'SPIN_INTEGRATION', 'SPIN_TRACKING_METHOD', 'SPIN_X', 'SPIN_X_STORED', 'SPIN_Y', 'SPIN_Y_STORED', 'SPIN_Z', 'SPIN_Z_STORED', 'SPLIT_ID', 'SPRINT', 'SQRT', 'SQRT_2', 'SQRT_3', 'SQUARE_BRACKETS', 'SQUARE_CONCAVE_SYM', 'SQUARE_FILLED_SYM', 'SQUARE_SYM', 'SR_WAKE', 'SR_WAKE_FILE', 'STALE', 'STANDARD', 'STANDING_WAVE', 'STAR5_FILLED_SYM', 'STAR5_SYM', 'START_EDGE', 'START_END', 'STAR_OF_DAVID_SYM', 'STEADY_STATE_3D', 'STRAIGHT', 'SUM', 'SUPERIMPOSE', 'SUPER_LORD', 'SUPER_OFFSET', 'SUPER_OK', 'SUPER_SLAVE', 'SURFACE', 'SYMMETRY', 'SYMPLECTIFY', 'SYMP_LIE_BMAD', 'SYMP_LIE_PTC', 'S_ABORT', 'S_AND_FLOOR_POSITION_GROUP', 'S_BLANK', 'S_DINFO', 'S_DWARN', 'S_ERROR', 'S_FATAL', 'S_IMPORTANT', 'S_INFO', 'S_LONG', 'S_NOOUTPUT', 'S_PLANE', 'S_POSITION', 'S_POSITION_GROUP', 'S_SUCCESS', 'S_TWISS_REF', 'S_WARN', 'ScAdaptiveStep', 'ScStep', 'SetEleAttribute', 'SetEleStatusStale', 'SetFlagsForChangedIntegerAttribute', 'SetFlagsForChangedLogicalAttribute', 'SetFlagsForChangedRealAttribute', 'SetFringeOnOff', 'SetParameterInt', 'SetParameterLogic', 'SetParameterReal', 'SetPtcQuiet', 'SetPtcVerbose', 'SetTune', 'SetTune3d', 'SignificantDifference', 'Sinc', 'Sincc', 'SinhxX', 'SkipEleBlender', 'SkipHeader', 'SolQuadMat6Calc', 'SolvePsiFixedSteps', 'SpaceChargeCommonStruct', 'SpinAxisStruct', 'SpinMat8ResonanceStrengths', 'SpinMatToEigen', 'SpinOmega', 'SpinOrbitMap1Struct', 'SpinOrbitMap1StructAlloc1D', 'SpinOrbitMap1StructArray1D', 'SpinPolarStruct', 'SpinQuatResonanceStrengths', 'SplineAkimaInterpolate', 'SplineEvaluate', 'SplineStruct', 'SplineStructAlloc1D', 'SplineStructArray1D', 'SplitLat', 'SqrtAlpha', 'SqrtOne', 'StrCount', 'StrFirstInSet', 'StrFirstNotInSet', 'StrLastInSet', 'StrLastNotInSet', 'StrMatchWild', 'StrSubstitute', 'StreamEleEnd', 'StringToInt', 'StringToReal', 'StringTrim', 'StringTrim2', 'StrongBeamSigmaCalc', 'StrongBeamStrength', 'StrongBeamStruct', 'SummationRdtStruct', 'SummationRdtStructAlloc1D', 'SummationRdtStructArray1D', 'SuperBicubicInterpolation', 'SuperPolint', 'SurfaceCurvatureStruct', 'SurfaceDisplacementPtStruct', 'SurfaceDisplacementPtStructArray2D', 'SurfaceDisplacementStruct', 'SurfaceGridDisplacement', 'SurfaceHMisalignPtStruct', 'SurfaceHMisalignPtStructArray2D', 'SurfaceHMisalignStruct', 'SurfaceSegmentedPtStruct', 'SurfaceSegmentedPtStructArray2D', 'SurfaceSegmentedStruct', 'SystemCommand', 'T', 'T0', 'T21', 'T6ToB123', 'TAN', 'TANH', 'TAYLOR', 'TAYLOR_MAP_INCLUDES_OFFSETS', 'TAYLOR_OFFSET', 'TAYLOR_ORDER', 'TERM', 'THETA_POSITION', 'THICKNESS', 'THICK_MULTIPOLE', 'TILT', 'TILT_CALIB', 'TILT_CORR', 'TILT_TOT', 'TIMES', 'TIMES_SYM', 'TIME_RUNGE_KUTTA', 'TO_ELEMENT', 'TO_LINE', 'TRACKING', 'TRACKING_METHOD', 'TRAILING', 'TRANSMISSION', 'TRANSPARENT', 'TRANSVERSE_KICK', 'TRANSVERSE_SIGMA_CUT', 'TRAVELING_WAVE', 'TRIANGLE_FILLED_SYM', 'TRIANGLE_SYM', 'TRUE_', 'TRUE_INT', 'TT', 'TWISS_PROPAGATE_FAILURE', 'TWOPI', 'TYPE', 'T_OFFSET', 'TaoAllocateDataArray', 'TaoAllocateV1Var', 'TaoAllocateVarArray', 'TaoBeamBranchStruct', 'TaoBeamEmitCalc', 'TaoBeamUniStruct', 'TaoBranchIndex', 'TaoBuildingWallOrientationStruct', 'TaoBuildingWallPointStruct', 'TaoBuildingWallPointStructAlloc1D', 'TaoBuildingWallPointStructArray1D', 'TaoBuildingWallSectionStruct', 'TaoBuildingWallSectionStructAlloc1D', 'TaoBuildingWallSectionStructArray1D', 'TaoBuildingWallStruct', 'TaoCalcDataAtSPts', 'TaoChangeEle', 'TaoChromCalcNeeded', 'TaoClipCmd', 'TaoCmdHistoryRecord', 'TaoCmdHistoryStruct', 'TaoCmdHistoryStructAlloc1D', 'TaoCmdHistoryStructArray1D', 'TaoCommand', 'TaoCommonStruct', 'TaoConstraintTypeName', 'TaoCurveColorStruct', 'TaoCurveEleRef', 'TaoCurveIxUni', 'TaoCurveName', 'TaoCurveOrbitStruct', 'TaoCurveRmsCalc', 'TaoCurveStruct', 'TaoCurveStructAlloc1D', 'TaoCurveStructArray1D', 'TaoD1DataStruct', 'TaoD1DataStructAlloc1D', 'TaoD1DataStructArray1D', 'TaoD2D1Name', 'TaoD2DataStruct', 'TaoD2DataStructAlloc1D', 'TaoD2DataStructArray1D', 'TaoD2DataStuffit', 'TaoDataCheck', 'TaoDataSanityCheck', 'TaoDataStruct', 'TaoDataStructAlloc1D', 'TaoDataStructArray1D', 'TaoDataUseitPlotCalc', 'TaoDataVarComponentStruct', 'TaoDataVarComponentStructAlloc1D', 'TaoDataVarComponentStructArray1D', 'TaoDatumHasAssociatedEle', 'TaoDatumIntegrate', 'TaoDatumName', 'TaoDrawCurveData', 'TaoDrawEleForFloorPlan', 'TaoDrawHistogramData', 'TaoDrawingStruct', 'TaoDynamicApertureStruct', 'TaoEleGeometryWithMisalignments', 'TaoElePointerStruct', 'TaoElePointerStructAlloc1D', 'TaoElePointerStructArray1D', 'TaoEleShapeInfo', 'TaoEleShapeStruct', 'TaoEleShapeStructAlloc1D', 'TaoEleShapeStructArray1D', 'TaoEvalFloorOrbit', 'TaoEvaluateADatum', 'TaoEvaluateDatumAtS', 'TaoEvaluateLatOrBeamData', 'TaoEvaluateTune', 'TaoFindPlotRegion', 'TaoFloorPlanStruct', 'TaoFloorToScreen', 'TaoGetData', 'TaoGetOptVars', 'TaoGlobalStruct', 'TaoGraphName', 'TaoGraphSMinMaxCalc', 'TaoGraphStruct', 'TaoGraphStructAlloc1D', 'TaoGraphStructArray1D', 'TaoHistogramStruct', 'TaoInitBeamInUniverse', 'TaoInitDataInUniverse', 'TaoInitFindElements', 'TaoInitLattice', 'TaoInitPlotting', 'TaoInitStruct', 'TaoInjectBeam', 'TaoInjectParticle', 'TaoIsValidName', 'TaoKeyInfoToStr', 'TaoLatEmitCalc', 'TaoLatSigmaCalcNeeded', 'TaoLatSigmaStruct', 'TaoLatSigmaStructAlloc1D', 'TaoLatSigmaStructArray1D', 'TaoLatticeBranchStruct', 'TaoLatticeBranchStructAlloc1D', 'TaoLatticeBranchStructArray1D', 'TaoLatticeCalc', 'TaoLatticeStruct', 'TaoLoadThisDatum', 'TaoLocateAllElements', 'TaoLocateElements', 'TaoMerit', 'TaoModelBranchStruct', 'TaoModelBranchStructAlloc1D', 'TaoModelBranchStructArray1D', 'TaoModelElementStruct', 'TaoModelElementStructAlloc1D', 'TaoModelElementStructArray1D', 'TaoNextWord', 'TaoOneTurnMapCalcNeeded', 'TaoOpenFile', 'TaoOpenScratchFile', 'TaoOptimizationStatus', 'TaoParamValueAtS', 'TaoParseCommandArgs', 'TaoParseElementParamStr', 'TaoParticleDataValue', 'TaoPickUniverse', 'TaoPingScaleStruct', 'TaoPlotCacheStruct', 'TaoPlotCacheStructAlloc1D', 'TaoPlotCacheStructArray1D', 'TaoPlotPageStruct', 'TaoPlotRegionStruct', 'TaoPlotRegionStructAlloc1D', 'TaoPlotRegionStructArray1D', 'TaoPlotStruct', 'TaoPlotStructAlloc1D', 'TaoPlotStructArray1D', 'TaoPointerToDatumEle', 'TaoPointerToEleShape', 'TaoPointerToUniverseInt', 'TaoPointerToUniverseStr', 'TaoPointerToUniverses', 'TaoRadIntCalcNeeded', 'TaoReExecute', 'TaoReadCmd', 'TaoReadPhaseSpaceIndex', 'TaoRemoveBlankCharacters', 'TaoScaleGraph', 'TaoSetCalculateCmd', 'TaoSetDataCmd', 'TaoSetElementsCmd', 'TaoSetFloorPlanAxisLabel', 'TaoSetIntegerValue', 'TaoSetLogicalValue', 'TaoSetQpAxisStruct', 'TaoSetQpPointStruct', 'TaoSetQpRectStruct', 'TaoSetRealValue', 'TaoShapePatternPointStruct', 'TaoShapePatternPointStructAlloc1D', 'TaoShapePatternPointStructArray1D', 'TaoShapePatternStruct', 'TaoShapePatternStructAlloc1D', 'TaoShapePatternStructArray1D', 'TaoSpinDnDpzStruct', 'TaoSpinEleStruct', 'TaoSpinEleStructAlloc1D', 'TaoSpinEleStructArray1D', 'TaoSpinMapStruct', 'TaoSpinMatricesCalcNeeded', 'TaoSpinPolarizationStruct', 'TaoSplitComponent', 'TaoSrdtCalcNeeded', 'TaoSubinUniNumber', 'TaoSuperUniverseStruct', 'TaoTitleStruct', 'TaoToChangeNumber', 'TaoToInt', 'TaoToPhaseAndCouplingReading', 'TaoToReal', 'TaoTooManyParticlesLost', 'TaoTrackingEleIndex', 'TaoUniverseCalcStruct', 'TaoUniverseIndex', 'TaoUniversePointerStruct', 'TaoUniversePointerStructAlloc1D', 'TaoUniversePointerStructArray1D', 'TaoUniverseStruct', 'TaoUniverseStructAlloc1D', 'TaoUniverseStructArray1D', 'TaoV1VarStruct', 'TaoV1VarStructAlloc1D', 'TaoV1VarStructArray1D', 'TaoVar1Name', 'TaoVarAttribName', 'TaoVarSlaveStruct', 'TaoVarSlaveStructAlloc1D', 'TaoVarSlaveStructArray1D', 'TaoVarStruct', 'TaoVarStructAlloc1D', 'TaoVarStructArray1D', 'TaoWaveCmd', 'TaoWaveFit', 'TaoWaveKickPtStruct', 'TaoWaveKickPtStructAlloc1D', 'TaoWaveKickPtStructArray1D', 'TaoWaveStruct', 'TaoXScaleGraph', 'TaperMagStrengths', 'TargetMinMaxCalc', 'TargetPointStruct', 'TargetPointStructAlloc1D', 'TargetPointStructArray1D', 'TargetRotMats', 'TaylorInverse', 'TaylorStruct', 'TaylorStructAlloc1D', 'TaylorStructArray1D', 'TaylorTermStruct', 'TaylorTermStructAlloc1D', 'TaylorTermStructArray1D', 'TestBunchStructArray', 'TestBunchStructScalar', 'TestCharacterScalar', 'TestComplexArray', 'TestComplexScalar', 'TestInteger8Array', 'TestInteger8Scalar', 'TestIntegerArray', 'TestIntegerScalar', 'TestLogicalArray', 'TestLogicalScalar', 'TestReal16Array', 'TestReal16Scalar', 'TestRealArray', 'TestRealScalar', 'TestSubStruct', 'TestSubStructAlloc1D', 'TestSubStructArray1D', 'TestSubStructArray2D', 'TestSubStructArray3D', 'TestSubSubStruct', 'ToEtaReading', 'ToFieldmapCoords', 'ToOrbitReading', 'ToPhaseAndCouplingReading', 'ToStr', 'TouschekRate1Zap', 'Track1', 'Track1Bmad', 'Track1RungeKutta', 'Track1Spin', 'Track1TimeRungeKutta', 'TrackABeambeam', 'TrackADrift', 'TrackAMatch', 'TrackAPatch', 'TrackAPickup', 'TrackAZeroLengthElement', 'TrackAll', 'TrackFromSToS', 'TrackPointStruct', 'TrackPointStructAlloc1D', 'TrackPointStructArray1D', 'TrackStruct', 'TrackUntilDead', 'TrackingRadMapSetup', 'TransferMapFromSToS', 'TricubicCmplxCoefStruct', 'TricubicCmplxCoefStructArray3D', 'TricubicCmplxEval', 'Twiss1Propagate', 'Twiss3AtStart', 'Twiss3Propagate1', 'TwissAndTrackAll', 'TwissAndTrackBranch', 'TwissAndTrackFromSToS', 'TwissAndTrackIntraEle', 'TwissAtElement', 'TwissFromTracking', 'TwissStruct', 'TypeThisFile', 'UB_SUBATOMIC', 'UNARY_MINUS', 'UNARY_PLUS', 'UNDIFFRACTED', 'UNDULATOR', 'UNIFORM', 'UNKNOWN', 'UNPOLARIZED', 'UNSTABLE', 'UNSTABLE_A', 'UNSTABLE_B', 'UPSTREAM', 'UPSTREAM_COORD_DIR', 'UPSTREAM_END', 'USER_SET', 'USER_SETS_LENGTH', 'USE_REFLECTIVITY_TABLE', 'UpcaseString', 'V1_UNITCELL', 'V2_UNITCELL', 'VAL1', 'VAL10', 'VAL11', 'VAL12', 'VAL2', 'VAL3', 'VAL4', 'VAL5', 'VAL6', 'VAL7', 'VAL8', 'VAL9', 'VAR', 'VARIABLE', 'VAR_OFFSET', 'VELOCITY_DISTRIBUTION', 'VERTICALLY_PURE', 'VERTICAL_BAR', 'VERTICAL_KICK', 'VKICK', 'VKICKER', 'VOLTAGE', 'VOLTAGE_ERR', 'VOLTAGE_TOT', 'V_DISPLACE', 'V_UNITCELL', 'ValidFieldCalc', 'ValidFringeType', 'ValidMat6CalcMethod', 'ValidSpinTrackingMethod', 'ValidTrackingMethod', 'ValueOfAttribute', 'ValueToLine', 'WALL', 'WALL3D', 'WALL_END', 'WALL_START', 'WALL_TRANSITION', 'WHITE', 'WIGGLER', 'WIGGLERS', 'WMatToAxisAngle', 'WRAP_SUPERIMPOSE', 'WakeLrModeStruct', 'WakeLrModeStructAlloc1D', 'WakeLrModeStructArray1D', 'WakeLrStruct', 'WakeSrModeStruct', 'WakeSrModeStructAlloc1D', 'WakeSrModeStructArray1D', 'WakeSrStruct', 'WakeSrZLongStruct', 'WakeStruct', 'Wall3DSectionStruct', 'Wall3DSectionStructAlloc1D', 'Wall3DSectionStructArray1D', 'Wall3DStruct', 'Wall3DStructAlloc1D', 'Wall3DStructArray1D', 'Wall3DVertexStruct', 'Wall3DVertexStructAlloc1D', 'Wall3DVertexStructArray1D', 'Wall3dDRadius', 'WordLen', 'WordRead', 'WordToValue', 'WriteAstraBend', 'WriteAstraFieldGridFile', 'WriteAstraFieldGridFile3d', 'WriteBlenderEle', 'WriteBlenderLatLayout', 'WriteGptFieldGridFile1d', 'WriteGptFieldGridFile2d', 'WriteGptFieldGridFile3d', 'WriteLatLine', 'WriteLatticeInSadFormat', 'WriteLatticeInScibmad', 'WriteLineElement', 'WriteOpalFieldGridFile', 'X', 'X0', 'X1', 'X1_EDGE', 'X1_LIMIT', 'X2_EDGE', 'X2_LIMIT', 'XFER_MAT_CALC_FAILURE', 'XY', 'XYZ', 'XY_AXIS', 'X_AXIS', 'X_DISPERSION_CALIB', 'X_DISPERSION_ERR', 'X_GAIN_CALIB', 'X_GAIN_ERR', 'X_INVARIANT', 'X_KICK', 'X_KNOT', 'X_LEADING', 'X_LIMIT', 'X_OFFSET', 'X_OFFSET_CALIB', 'X_OFFSET_MULT', 'X_OFFSET_TOT', 'X_PITCH', 'X_PITCH_TOT', 'X_PLANE', 'X_POLARIZATION', 'X_POSITION', 'X_QUAD', 'X_REF', 'X_STORED', 'X_SYMBOL_SYM', 'X_TRAILING', 'Xlafun', 'XyDispStruct', 'Y', 'Y0', 'Y1', 'Y1_EDGE', 'Y1_LIMIT', 'Y2_EDGE', 'Y2_LIMIT', 'YELLOW', 'YELLOW_GREEN', 'YES', 'Y_AXIS', 'Y_DISPERSION_CALIB', 'Y_DISPERSION_ERR', 'Y_GAIN_CALIB', 'Y_GAIN_ERR', 'Y_KICK', 'Y_KNOT', 'Y_LEADING', 'Y_LIMIT', 'Y_OFFSET', 'Y_OFFSET_CALIB', 'Y_OFFSET_MULT', 'Y_OFFSET_TOT', 'Y_PITCH', 'Y_PITCH_TOT', 'Y_PLANE', 'Y_POLARIZATION', 'Y_POSITION', 'Y_QUAD', 'Y_REF', 'Y_STORED', 'Y_TRAILING', 'Ylafun', 'Z', 'Z0', 'Z1', 'ZAtSurface', 'ZERO', 'Z_APERTURE_CENTER', 'Z_APERTURE_WIDTH2', 'Z_AXIS', 'Z_KICK', 'Z_OFFSET', 'Z_OFFSET_TOT', 'Z_PLANE', 'Z_POSITION', 'Z_REF', 'Z_STORED', 'Zlafun', 'ab_multipole_kick', 'ab_multipole_kicks', 'absolute_photon_position', 'absolute_time_tracking', 'ac_kicker_amp', 'action_to_xyz', 'add_lattice_control_structs', 'add_superimpose', 'add_this_multipass', 'add_this_taylor_term', 'adjust_super_slave_names', 'allocate_branch_array', 'allocate_lat_ele_array', 'allocate_thread_states', 'angle_between_polars', 'angle_to_canonical_coords', 'anomalous_moment_of', 'antiparticle', 'aperture_bookkeeper', 'apfft', 'apfft_corr', 'apfft_ext', 'apply_all_rampers', 'apply_energy_kick', 'apply_patch_to_ptc_fibre', 'apply_rampers_to_slave', 'array_re_str', 'asinc', 'assert_equal', 'astra_max_field_reference', 'at_this_ele_end', 'atomic_number', 'atomic_species_id', 'attribute_bookkeeper', 'attribute_free', 'attribute_index', 'attribute_name', 'attribute_type', 'attribute_units', 'autoscale_phase_and_amp', 'average_twiss', 'axis_angle_to_quat', 'axis_angle_to_w_mat', 'bbi_kick', 'bbi_slice_calc', 'bbu_add_a_bunch', 'bbu_hom_voltage_calc', 'bbu_remove_head_bunch', 'bbu_setup', 'bbu_track_a_stage', 'bbu_track_all', 'beam_envelope_ibs', 'beam_equal_beam', 'beam_tilts', 'bend_edge_kick', 'bend_exact_multipole_field', 'bend_length_has_been_set', 'bend_photon_e_rel_init', 'bend_photon_energy_integ_prob', 'bend_photon_energy_normalized_probability', 'bend_photon_init', 'bend_photon_polarization_init', 'bend_photon_vert_angle_init', 'bend_shift', 'bend_vert_angle_integ_prob', 'bicubic_cmplx_eval', 'bin_index', 'bin_x_center', 'bit_set', 'bl_via_vlassov', 'bmad_parser', 'bmad_parser2', 'bmad_patch_parameters_to_ptc', 'bp_set_ran_status', 'bracket_index_for_spline', 'branch_equal_branch', 'branch_name', 'branch_to_ptc_m_u', 'bunch_equal_bunch', 'c_to_cbar', 'calc_bunch_params', 'calc_bunch_params_slice', 'calc_bunch_params_z_slice', 'calc_bunch_sigma_matrix_etc', 'calc_emittances_and_twiss_from_sigma_matrix', 'calc_file_number', 'calc_spin_params', 'calc_super_slave_key', 'calc_wall_radius', 'calc_z_tune', 'canonical_to_angle_coords', 'cbar_to_c', 'change_file_number', 'charge_of', 'charge_to_mass_of', 'check_aperture_limit', 'check_controller_controls', 'check_for_superimpose_problem', 'check_if_s_in_bounds', 'check_rf_freq', 'choose_quads_for_set_tune', 'chrom_calc', 'chrom_tune', 'classical_radius', 'clear_lat_1turn_mats', 'clear_taylor_maps_from_elements', 'closed_orbit_calc', 'closed_orbit_from_tracking', 'cmplx_re_str', 'coarse_frequency_estimate', 'combine_consecutive_elements', 'complex_error_function', 'complex_taylor_clean', 'complex_taylor_coef', 'complex_taylor_equal_complex_taylor', 'complex_taylor_exponent_index', 'complex_taylor_make_unit', 'complex_taylor_to_mat6', 'complex_taylors_equal_complex_taylors', 'compute_slave_coupler', 'concat_ele_taylor', 'concat_taylor', 'concat_transfer_mat', 'control_bookkeeper', 'convert_bend_exact_multipole', 'convert_coords', 'convert_field_ele_to_lab', 'convert_local_cartesian_to_local_curvilinear', 'convert_local_curvilinear_to_local_cartesian', 'convert_particle_coordinates_s_to_t', 'convert_particle_coordinates_t_to_s', 'convert_pc_to', 'convert_total_energy_to', 'converter_distribution_parser', 'coord_equal_coord', 'coord_state_name', 'coords_body_to_local', 'coords_body_to_rel_exit', 'coords_curvilinear_to_floor', 'coords_floor_to_curvilinear', 'coords_floor_to_local_curvilinear', 'coords_floor_to_relative', 'coords_local_curvilinear_to_body', 'coords_local_curvilinear_to_floor', 'coords_relative_to_floor', 'cos_one', 'cosc', 'coulombfun', 'count_lines_in_file', 'create_a_spline', 'create_concatenated_wall3d', 'create_element_slice', 'create_field_overlap', 'create_girder', 'create_group', 'create_lat_ele_nametable', 'create_overlay', 'create_planar_wiggler_model', 'create_ramper', 'create_sol_quad_model', 'create_unique_ele_names', 'create_wiggler_cartesian_map', 'cross_product', 'crystal_attribute_bookkeeper', 'crystal_h_misalign', 'crystal_type_to_crystal_params', 'custom_attribute_ubound_index', 'damping_matrix_d', 'date_and_time_stamp', 'deallocate_ele_pointers', 'deallocate_expression_tree', 'deallocate_lat_pointers', 'default_tracking_species', 'destfixedwindowls', 'detab', 'detector_pixel_pt', 'diffraction_plate_or_mask_hit_spot', 'diffusion_matrix_b', 'display_size_and_resolution', 'distance_to_aperture', 'dj_bessel', 'djb_hash', 'djb_str_hash', 'do_mode_flip', 'downcase_string', 'dpc_given_de', 'drift_and_pipe_track_methods_adjustment', 'drift_multipass_name_correction', 'drift_orbit_time', 'drift_particle_to_s', 'drift_particle_to_t', 'dspline_len', 'dynamic_aperture_point', 'dynamic_aperture_scan', 'e_accel_field', 'e_crit_photon', 'eigen_decomp_6mat', 'ele_compute_ref_energy_and_time', 'ele_equal_ele', 'ele_equals_ele', 'ele_finalizer', 'ele_full_name', 'ele_geometry', 'ele_geometry_with_misalignments', 'ele_has_constant_ds_dt_ref', 'ele_has_nonzero_kick', 'ele_has_nonzero_offset', 'ele_is_monitor', 'ele_loc', 'ele_loc_name', 'ele_misalignment_l_s_calc', 'ele_nametable_index', 'ele_order_calc', 'ele_reference_energy_correction', 'ele_rf_step_index', 'ele_to_ptc_magnetic_bn_an', 'ele_to_spin_taylor', 'ele_to_taylor', 'ele_unique_name', 'ele_value_has_changed', 'ele_vec_equal_ele_vec', 'elec_multipole_field', 'element_at_s', 'element_slice_iterator', 'ellipinc_test', 'em_field_calc', 'em_field_derivatives', 'em_field_kick_vector_time', 'em_field_plus_em_field', 'em_taylor_equal_em_taylor', 'em_taylors_equal_em_taylors', 'emit_6d', 'end_akima_spline_calc', 'entering_element', 'envelope_radints', 'envelope_radints_ibs', 'eq_ac_kicker', 'eq_ac_kicker_freq', 'eq_ac_kicker_time', 'eq_anormal_mode', 'eq_aperture_param', 'eq_aperture_point', 'eq_aperture_scan', 'eq_beam', 'eq_beam_init', 'eq_bmad_common', 'eq_bookkeeping_state', 'eq_bpm_phase_coupling', 'eq_branch', 'eq_bunch', 'eq_bunch_params', 'eq_cartesian_map', 'eq_cartesian_map_term', 'eq_cartesian_map_term1', 'eq_complex_taylor', 'eq_complex_taylor_term', 'eq_control', 'eq_control_ramp1', 'eq_control_var1', 'eq_controller', 'eq_coord', 'eq_coord_array', 'eq_cylindrical_map', 'eq_cylindrical_map_term', 'eq_cylindrical_map_term1', 'eq_ele', 'eq_ellipse_beam_init', 'eq_em_field', 'eq_em_taylor', 'eq_em_taylor_term', 'eq_expression_atom', 'eq_floor_position', 'eq_gen_grad1', 'eq_gen_grad_map', 'eq_grid_beam_init', 'eq_grid_field', 'eq_grid_field_pt', 'eq_grid_field_pt1', 'eq_high_energy_space_charge', 'eq_interval1_coef', 'eq_kv_beam_init', 'eq_lat', 'eq_lat_ele_loc', 'eq_lat_param', 'eq_linac_normal_mode', 'eq_mode3', 'eq_mode_info', 'eq_normal_modes', 'eq_photon_element', 'eq_photon_material', 'eq_photon_reflect_surface', 'eq_photon_reflect_table', 'eq_photon_target', 'eq_pixel_detec', 'eq_pixel_pt', 'eq_pre_tracker', 'eq_rad_int1', 'eq_rad_int_all_ele', 'eq_rad_int_branch', 'eq_rad_map', 'eq_rad_map_ele', 'eq_ramper_lord', 'eq_space_charge_common', 'eq_spin_polar', 'eq_spline', 'eq_strong_beam', 'eq_surface_curvature', 'eq_surface_displacement', 'eq_surface_displacement_pt', 'eq_surface_h_misalign', 'eq_surface_h_misalign_pt', 'eq_surface_segmented', 'eq_surface_segmented_pt', 'eq_target_point', 'eq_taylor', 'eq_taylor_term', 'eq_track', 'eq_track_point', 'eq_twiss', 'eq_wake', 'eq_wake_lr', 'eq_wake_lr_mode', 'eq_wake_sr', 'eq_wake_sr_mode', 'eq_wake_sr_z_long', 'eq_wall3d', 'eq_wall3d_section', 'eq_wall3d_vertex', 'eq_xy_disp', 'equal_sign_here', 'equivalent_taylor_attributes', 'err_exit', 'etdiv', 'evaluate_array_index', 'evaluate_logical', 'exact_bend_edge_kick', 'exp_bessi0', 'expect_one_of', 'expect_this', 'expression_stack_to_string', 'expression_stack_value', 'expression_string_to_stack', 'expression_string_to_tree', 'expression_tree_to_string', 'expression_value', 'factorial', 'faddeeva_function', 'fft1', 'fft_1d', 'field_attribute_free', 'file_directorizer', 'file_get', 'file_get_open', 'file_suffixer', 'finalize_reflectivity_table', 'find_element_ends', 'find_fwhm', 'find_location', 'find_matching_fieldmap', 'find_normalization', 'fine_frequency_estimate', 'fixedwindowls', 'floor_angles_to_w_mat', 'floor_w_mat_to_angles', 'form_complex_taylor', 'form_digested_bmad_file_name', 'fourier_amplitude', 'fringe_here', 'g_bend_from_em_field', 'g_bending_strength_from_em_field', 'g_integrals_calc', 'gamma_ref', 'gen_complete_elliptic', 'gen_grad1_to_em_taylor', 'gen_grad_at_s_to_em_taylor', 'gen_grad_field', 'get_bl_from_fwhm', 'get_bmad_com', 'get_called_file', 'get_emit_from_sigma_mat', 'get_file_number', 'get_file_time_stamp', 'get_next_word', 'get_slave_list', 'get_space_charge_com', 'get_super_universe', 'gpt_field_grid_scaling', 'gpt_max_field_reference', 'gpt_to_particle_bunch', 'gradient_shift_sr_wake', 'grid_field_interpolate', 'hanhan', 'hard_multipole_edge_kick', 'has_attribute', 'has_curvature', 'has_orientation_attributes', 'hdf5_write_beam', 'hdf5_write_grid_field', 'hom_voltage', 'hwang_bend_edge_kick', 'i_bessel', 'i_bessel_extended', 'ibs_matrix_c', 'igfcoulombfun', 'igfexfun', 'igfeyfun', 'igfezfun', 'increment_file_number', 'index_nocase', 'init_attribute_name1', 'init_attribute_name_array', 'init_beam_distribution', 'init_bmad', 'init_bmad_parser_common', 'init_bunch_distribution', 'init_complex_taylor_series', 'init_coord', 'init_custom', 'init_ele', 'init_em_taylor_series', 'init_lat', 'init_multipole_cache', 'init_photon_from_a_photon_init_ele', 'init_photon_integ_prob', 'init_spin_distribution', 'init_surface_segment', 'init_taylor_series', 'init_wake', 'initfixedwindowls', 'insert_element', 'insert_phase_trombone', 'int_str', 'integrand_base', 'integrate_max', 'integrate_min', 'integrate_psi', 'integrated_mats', 'integration_timer', 'interpolated_fft', 'interpolated_fft_gsl', 'ion_kick', 'is_alphabetic', 'is_attribute', 'is_decreasing_sequence', 'is_false', 'is_increasing_sequence', 'is_integer', 'is_logical', 'is_real', 'is_subatomic_species', 'is_true', 'j_bessel', 'key_name_to_key_index', 'kick_vector_calc', 'kill_complex_taylor', 'kill_ptc_layouts', 'kill_taylor', 'kind_name', 'knot_interpolate', 'knots_to_string', 'lafun', 'lat_compute_ref_energy_and_time', 'lat_ele_locator', 'lat_equal_lat', 'lat_geometry', 'lat_make_mat6', 'lat_sanity_check', 'lat_to_ptc_layout', 'lat_vec_equal_lat_vec', 'lattice_bookkeeper', 'lcavity_rf_step_setup', 'linear_bend_edge_kick', 'linear_coef', 'linear_fit', 'linear_fit_2d', 'linear_to_spin_taylor', 'load_parse_line', 'logic_str', 'logical_to_python', 'lord_edge_aligned', 'low_energy_z_correction', 'lunget', 'mad_add_offsets_and_multipoles', 'mad_concat_map2', 'mad_drift', 'mad_elsep', 'mad_map_to_taylor', 'mad_quadrupole', 'mad_rfcavity', 'mad_sbend', 'mad_sbend_body', 'mad_sbend_fringe', 'mad_sextupole', 'mad_solenoid', 'mad_tmfoc', 'mad_tmsymm', 'mad_tmtilt', 'mad_track1', 'make_g2_mats', 'make_g_mats', 'make_hvbp', 'make_hybrid_lat', 'make_legal_comment', 'make_mad_map', 'make_mat6', 'make_mat6_bmad', 'make_mat6_bmad_photon', 'make_mat6_high_energy_space_charge', 'make_mat6_mad', 'make_mat6_symp_lie_ptc', 'make_mat6_taylor', 'make_mat6_tracking', 'make_n', 'make_pbrh', 'make_smat_from_abc', 'make_unit_mad_map', 'make_v', 'make_v_mats', 'makeup_control_slave', 'makeup_group_lord', 'makeup_multipass_slave', 'makeup_super_slave', 'makeup_super_slave1', 'map1_inverse', 'map1_make_unit', 'map1_times_map1', 'map_to_angle_coords', 'mark_patch_regions', 'mass_of', 'master_parameter_value', 'mat4_multipole', 'mat6_add_offsets', 'mat6_add_pitch', 'mat6_to_complex_taylor', 'mat_symp_decouple', 'match_ele_to_mat6', 'match_reg', 'match_wild', 'maximize_projection', 'mexp', 'mfft1', 'milli_sleep', 'momentum_compaction', 'multi_turn_tracking_analysis', 'multilayer_type_to_multilayer_params', 'multipass_chain', 'multipole1_ab_to_kt', 'multipole1_kt_to_ab', 'multipole_ab_to_kt', 'multipole_ele_to_ab', 'multipole_ele_to_kt', 'multipole_init', 'multipole_kick', 'multipole_kick_mat', 'multipole_kicks', 'multipole_kt_to_ab', 'multipole_spin_tracking', 'mytan', 'n_attrib_string_max_len', 'n_bins_automatic', 'n_choose_k', 'n_spline_create', 'naff', 'nametable_add', 'nametable_bracket_indexx', 'nametable_change1', 'nametable_init', 'nametable_remove', 'new_control', 'nint_chk', 'normal_form_complex_taylors', 'normal_form_taylors', 'normal_mode3_calc', 'normal_mode_dispersion', 'normalize_evecs', 'num_field_eles', 'num_lords', 'odeint_bmad', 'odeint_bmad_time', 'offset_particle', 'offset_photon', 'omega_to_quat', 'one_turn_mat_at_ele', 'open_binary_file', 'openpmd_species_name', 'orbit_amplitude_calc', 'orbit_reference_energy_correction', 'orbit_to_floor_phase_space', 'orbit_to_local_curvilinear', 'orbit_too_large', 'order_evecs_by_n_similarity', 'order_evecs_by_plane_dominance', 'order_evecs_by_tune', 'order_particles_in_z', 'order_super_lord_slaves', 'ordinal_str', 'osc_alloc_freespace_array', 'osc_alloc_image_array', 'osc_alloc_rectpipe_arrays', 'osc_getgrnpipe', 'osc_read_rectpipe_grn', 'osc_write_rectpipe_grn', 'parse_cartesian_map', 'parse_cylindrical_map', 'parse_fortran_format', 'parse_gen_grad_map', 'parse_grid_field', 'parse_integer_list', 'parse_integer_list2', 'parse_real_list', 'parse_real_list2', 'parser_add_constant', 'parser_call_check', 'parser_fast_complex_read', 'parser_fast_integer_read', 'parser_fast_real_read', 'parser_file_stack', 'parser_get_integer', 'parser_get_logical', 'parser_identify_fork_to_element', 'parser_init_custom_elements', 'parser_print_line', 'parser_read_lr_wake', 'parser_read_old_format_lr_wake', 'parser_read_old_format_sr_wake', 'parser_read_sr_wake', 'parser_transfer_control_struct', 'particle_in_global_frame', 'particle_is_moving_backwards', 'particle_is_moving_forward', 'particle_rf_time', 'patch_flips_propagation_direction', 'patch_length', 'photon_absorption_and_phase_shift', 'photon_add_to_detector_statistics', 'photon_reflection', 'photon_reflection_std_surface_init', 'photon_reflectivity', 'photon_target_corner_calc', 'photon_target_setup', 'photon_type', 'physical_ele_end', 'point_photon_emission', 'pointer_to_branch', 'pointer_to_ele', 'pointer_to_element_at_s', 'pointer_to_field_ele', 'pointer_to_girder', 'pointer_to_lord', 'pointer_to_multipass_lord', 'pointer_to_next_ele', 'pointer_to_ran_state', 'pointer_to_slave', 'pointer_to_super_lord', 'pointer_to_surface_displacement_pt', 'pointer_to_surface_segmented_pt', 'pointer_to_wake_ele', 'pointer_to_wall3d', 'polar_to_spinor', 'polar_to_vec', 'poly_eval', 'probability_funct', 'projdd', 'project_emit_to_xyz', 'psi_prime_sca', 'ptc_bookkeeper', 'ptc_closed_orbit_calc', 'ptc_emit_calc', 'ptc_layouts_resplit', 'ptc_one_turn_mat_and_closed_orbit_calc', 'ptc_ran_seed_put', 'ptc_set_rf_state_for_c_normal', 'ptc_set_taylor_order_if_needed', 'ptc_spin_calc', 'ptc_track_all', 'ptc_transfer_map_with_spin', 'pwd_mat', 'quadratic_roots', 'quat_conj', 'quat_inverse', 'quat_mul', 'quat_rotate', 'quat_to_axis_angle', 'quat_to_omega', 'quat_to_w_mat', 'query_string', 'quote', 'rad1_damp_and_stoc_mats', 'rad_damp_and_stoc_mats', 'rad_g_integrals', 'radiation_integrals', 'radiation_map_setup', 'ramper_slave_setup', 'ramper_value', 'ran_default_state', 'ran_engine', 'ran_gauss_converter', 'ran_gauss_scalar', 'ran_gauss_vector', 'ran_seed_get', 'ran_seed_put', 'ran_uniform', 'randomize_lr_wake_frequencies', 'rchomp', 're_allocate', 're_allocate_c_double', 're_allocate_eles', 're_associate_node_array', 're_str', 'read_beam_ascii', 'read_beam_file', 'read_binary_cartesian_map', 'read_binary_cylindrical_map', 'read_binary_grid_field', 'read_surface_reflection_file', 'real_num_fortran_format', 'real_path', 'real_str', 'real_to_string', 'reallocate_beam', 'reallocate_bp_com_const', 'reallocate_bunch', 'reallocate_control', 'reallocate_coord', 'reallocate_expression_stack', 'reallocate_spline', 'rel_tracking_charge_to_mass', 'relative_mode_flip', 'release_rad_int_cache', 'remove_constant_taylor', 'remove_dead_from_bunch', 'remove_eles_from_lat', 'remove_lord_slave_link', 'reverse_lat', 'rf_cav_names', 'rf_coupler_kick', 'rf_is_on', 'rf_ref_time_offset', 'rfun', 'rk_adaptive_time_step', 'rk_time_step1', 'rms_value', 'rot_2d', 'rotate3', 'rotate_em_field', 'rotate_field_zx', 'rotate_for_curved_surface', 'rotate_spin', 'rotate_spin_a_step', 'rotate_spin_given_field', 'rotate_vec', 'rotate_vec_given_axis_angle', 'rp8', 'run_timer', 's_body_calc', 's_calc', 'sad_mult_hard_bend_edge_kick', 'sad_soft_bend_edge_kick', 'save_a_beam_step', 'save_a_bunch_step', 'save_a_step', 'sbend_body_with_k1_map', 'sc_adaptive_step', 'sc_step', 'set_active_fixer', 'set_custom_attribute_name', 'set_ele_attribute', 'set_ele_defaults', 'set_ele_name', 'set_ele_real_attribute', 'set_ele_status_stale', 'set_emit_from_beam_init', 'set_flags_for_changed_attribute', 'set_fringe_on_off', 'set_lords_status_stale', 'set_on_off', 'set_orbit_to_zero', 'set_parameter', 'set_ptc', 'set_ptc_base_state', 'set_ptc_com_pointers', 'set_ptc_quiet', 'set_ptc_verbose', 'set_pwd_ele', 'set_species_charge', 'set_status_flags', 'set_tune', 'set_tune_3d', 'set_twiss', 'set_z_tune', 'settable_dep_var_bookkeeping', 'setup_high_energy_space_charge_calc', 'sigma_mat_ptc_to_bmad', 'significant_difference', 'sinc', 'sincc', 'sinhx_x', 'skip_ele_blender', 'skip_header', 'slice_lattice', 'soft_quadrupole_edge_kick', 'sol_quad_mat6_calc', 'solve_psi_adaptive', 'solve_psi_fixed_steps', 'sort_complex_taylor_terms', 'species_id', 'species_id_from_openpmd', 'species_name', 'species_of', 'spin_dn_dpz_from_mat8', 'spin_dn_dpz_from_qmap', 'spin_map1_normalize', 'spin_mat8_resonance_strengths', 'spin_mat_to_eigen', 'spin_of', 'spin_omega', 'spin_quat_resonance_strengths', 'spin_taylor_to_linear', 'spinor_to_polar', 'spinor_to_vec', 'spline1', 'spline_akima', 'spline_akima_interpolate', 'spline_evaluate', 'spline_fit_orbit', 'split_lat', 'sprint_spin_taylor_map', 'sqrt_alpha', 'sqrt_one', 'sr_longitudinal_wake_particle', 'sr_transverse_wake_particle', 'sr_z_long_wake', 'srdt_calc', 'srdt_lsq_solution', 'start_branch_at', 'str_count', 'str_downcase', 'str_first_in_set', 'str_first_not_in_set', 'str_last_in_set', 'str_last_not_in_set', 'str_match_wild', 'str_substitute', 'str_upcase', 'stream_ele_end', 'string_attrib', 'string_to_int', 'string_to_real', 'string_trim', 'string_trim2', 'strong_beam_sigma_calc', 'strong_beam_strength', 'super_bicubic_coef', 'super_bicubic_interpolation', 'super_polint', 'super_poly', 'super_sobseq', 'super_sort', 'surface_grid_displacement', 'symp_lie_bmad', 'system_command', 't6_to_b123', 'tao_abort_command_file', 'tao_add_to_normal_mode_h_array', 'tao_alias_cmd', 'tao_allocate_data_array', 'tao_allocate_v1_var', 'tao_allocate_var_array', 'tao_beam_emit_calc', 'tao_beam_track', 'tao_beam_track_endpoint', 'tao_branch_index', 'tao_c_out_io_buffer_reset', 'tao_calc_data_at_s_pts', 'tao_cbar_wave_anal', 'tao_change_ele', 'tao_change_tune', 'tao_change_var', 'tao_change_z_tune', 'tao_chrom_calc_needed', 'tao_clear_cmd', 'tao_clip_cmd', 'tao_close_command_file', 'tao_cmd_history_record', 'tao_command', 'tao_constraint_type_name', 'tao_control_tree_list', 'tao_count_strings', 'tao_create_plot_window', 'tao_curve_beam_ellipse_setup', 'tao_curve_check_universe', 'tao_curve_data_setup', 'tao_curve_datum_calc', 'tao_curve_ele_ref', 'tao_curve_ix_uni', 'tao_curve_name', 'tao_curve_rms_calc', 'tao_d2_d1_name', 'tao_d2_data_stuffit', 'tao_data_check', 'tao_data_coupling_init', 'tao_data_sanity_check', 'tao_data_type_substitute', 'tao_data_useit_plot_calc', 'tao_datum_has_associated_ele', 'tao_datum_integrate', 'tao_datum_name', 'tao_datum_s_position', 'tao_de_optimizer', 'tao_deallocate_plot_cache', 'tao_destroy_plot_window', 'tao_dmerit_calc', 'tao_dmodel_dvar_calc', 'tao_do_wire_scan', 'tao_draw_beam_chamber_wall', 'tao_draw_curve_data', 'tao_draw_ele_for_floor_plan', 'tao_draw_floor_plan', 'tao_draw_graph_axes', 'tao_draw_histogram_data', 'tao_draw_lat_layout', 'tao_draw_plots', 'tao_ele_geometry_with_misalignments', 'tao_ele_shape_info', 'tao_eval_floor_orbit', 'tao_evaluate_a_datum', 'tao_evaluate_datum_at_s', 'tao_evaluate_lat_or_beam_data', 'tao_evaluate_tune', 'tao_expression_hash_substitute', 'tao_find_plot_region', 'tao_fixer', 'tao_floor_to_screen', 'tao_floor_to_screen_coords', 'tao_geodesic_lm_optimizer', 'tao_get_data', 'tao_get_opt_vars', 'tao_get_user_input', 'tao_graph_controller_setup', 'tao_graph_data_setup', 'tao_graph_data_slice_setup', 'tao_graph_dynamic_aperture_setup', 'tao_graph_histogram_setup', 'tao_graph_name', 'tao_graph_phase_space_setup', 'tao_graph_s_min_max_calc', 'tao_graph_setup', 'tao_init', 'tao_init_beam_in_universe', 'tao_init_beams', 'tao_init_data', 'tao_init_data_end_stuff', 'tao_init_data_in_universe', 'tao_init_dynamic_aperture', 'tao_init_find_elements', 'tao_init_global', 'tao_init_lattice', 'tao_init_plotting', 'tao_init_variables', 'tao_inject_beam', 'tao_inject_particle', 'tao_is_valid_name', 'tao_json_cmd', 'tao_key_info_to_str', 'tao_lat_bookkeeper', 'tao_lat_emit_calc', 'tao_lat_sigma_calc_needed', 'tao_lat_sigma_track', 'tao_lattice_branches_equal_tao_lattice_branches', 'tao_lattice_calc', 'tao_lattice_equal_tao_lattice', 'tao_limit_calc', 'tao_lm_optimizer', 'tao_lmdif_optimizer', 'tao_load_this_datum', 'tao_locate_all_elements', 'tao_locate_elements', 'tao_mark_lattice_ele', 'tao_merit', 'tao_next_word', 'tao_one_turn_map_calc_needed', 'tao_open_file', 'tao_open_scratch_file', 'tao_optimization_status', 'tao_orbit_beta_wave_anal', 'tao_oreint_building_wall_pt', 'tao_param_value_at_s', 'tao_parse_command_args', 'tao_parse_element_param_str', 'tao_particle_data_value', 'tao_pause_cmd', 'tao_phase_space_axis_index', 'tao_phase_wave_anal', 'tao_pick_universe', 'tao_pipe_cmd', 'tao_place_cmd', 'tao_plot_cmd', 'tao_plot_data', 'tao_plot_histogram', 'tao_plot_key_table', 'tao_plot_setup', 'tao_plot_struct_transfer', 'tao_plot_wave', 'tao_pointer_to_building_wall_shape', 'tao_pointer_to_datum', 'tao_pointer_to_datum_ele', 'tao_pointer_to_ele_shape', 'tao_pointer_to_tao_lat', 'tao_pointer_to_universe', 'tao_pointer_to_universes', 'tao_pointer_to_var_in_lattice', 'tao_pointer_to_var_in_lattice2', 'tao_print_command_line_info', 'tao_ptc_normal_form', 'tao_python_cmd', 'tao_quiet_set', 'tao_rad_int_calc_needed', 'tao_re_execute', 'tao_read_cmd', 'tao_read_phase_space_index', 'tao_regression_test', 'tao_remove_blank_characters', 'tao_run_cmd', 'tao_scale_cmd', 'tao_scale_graph', 'tao_scale_ping_data', 'tao_scale_plot', 'tao_scratch_values_calc', 'tao_set_beam_cmd', 'tao_set_beam_init_cmd', 'tao_set_bmad_com_cmd', 'tao_set_branch_cmd', 'tao_set_calculate_cmd', 'tao_set_curve_cmd', 'tao_set_curve_invalid', 'tao_set_data_cmd', 'tao_set_data_useit_opt', 'tao_set_default_cmd', 'tao_set_drawing_cmd', 'tao_set_dynamic_aperture_cmd', 'tao_set_elements_cmd', 'tao_set_floor_plan_axis_label', 'tao_set_geodesic_lm_cmd', 'tao_set_global_cmd', 'tao_set_graph_cmd', 'tao_set_integer_value', 'tao_set_invalid', 'tao_set_key_cmd', 'tao_set_lattice_cmd', 'tao_set_logical_value', 'tao_set_openmp_n_threads', 'tao_set_opt_vars', 'tao_set_opti_de_param_cmd', 'tao_set_particle_start_cmd', 'tao_set_plot_cmd', 'tao_set_plot_page_cmd', 'tao_set_ptc_com_cmd', 'tao_set_qp_axis_struct', 'tao_set_qp_point_struct', 'tao_set_qp_rect_struct', 'tao_set_ran_state_cmd', 'tao_set_real_value', 'tao_set_region_cmd', 'tao_set_space_charge_com_cmd', 'tao_set_symbolic_number_cmd', 'tao_set_tune_cmd', 'tao_set_universe_cmd', 'tao_set_var_cmd', 'tao_set_var_model_value', 'tao_set_var_useit_opt', 'tao_set_wave_cmd', 'tao_set_z_tune_cmd', 'tao_setup_key_table', 'tao_shape_init', 'tao_show_cmd', 'tao_show_constraints', 'tao_single_mode', 'tao_single_track', 'tao_spin_matrices_calc_needed', 'tao_spin_tracking_turn_on', 'tao_split_component', 'tao_srdt_calc_needed', 'tao_subin_uni_number', 'tao_svd_optimizer', 'tao_symbol_import_from_lat', 'tao_taper_cmd', 'tao_to_change_number', 'tao_to_int', 'tao_to_phase_and_coupling_reading', 'tao_to_real', 'tao_too_many_particles_lost', 'tao_top10_derivative_print', 'tao_top10_merit_categories_print', 'tao_top_level', 'tao_tracking_ele_index', 'tao_turn_on_special_calcs_if_needed_for_plotting', 'tao_uni_atsign_index', 'tao_universe_index', 'tao_use_data', 'tao_use_var', 'tao_user_is_terminating_optimization', 'tao_var1_name', 'tao_var_attrib_name', 'tao_var_check', 'tao_var_repoint', 'tao_var_target_calc', 'tao_var_useit_plot_calc', 'tao_var_write', 'tao_veto_vars_with_zero_dmodel', 'tao_wave_analysis', 'tao_wave_cmd', 'tao_wave_fit', 'tao_write_cmd', 'tao_x_axis_cmd', 'tao_x_scale_cmd', 'tao_x_scale_graph', 'tao_x_scale_plot', 'taper_mag_strengths', 'target_min_max_calc', 'target_rot_mats', 'taylor_equal_taylor', 'taylor_inverse', 'taylor_propagate1', 'taylor_to_mad_map', 'taylors_equal_taylors', 'test_bunch_struct_array', 'test_bunch_struct_scalar', 'test_character_scalar', 'test_complex_array', 'test_complex_scalar', 'test_integer8_array', 'test_integer8_scalar', 'test_integer_array', 'test_integer_scalar', 'test_logical_array', 'test_logical_scalar', 'test_real16_array', 'test_real16_scalar', 'test_real_array', 'test_real_scalar', 'tilt_coords', 'tilt_coords_photon', 'tilt_mat6', 'to_eta_reading', 'to_fieldmap_coords', 'to_orbit_reading', 'to_phase_and_coupling_reading', 'to_photon_angle_coords', 'to_str', 'to_surface_coords', 'touschek_lifetime', 'touschek_rate1', 'touschek_rate1_zap', 'track1', 'track1_beam', 'track1_bmad', 'track1_bmad_photon', 'track1_bunch', 'track1_bunch_csr', 'track1_bunch_csr3d', 'track1_bunch_hom', 'track1_bunch_space_charge', 'track1_crystal', 'track1_diffraction_plate_or_mask', 'track1_high_energy_space_charge', 'track1_lens', 'track1_linear', 'track1_lr_wake', 'track1_mad', 'track1_mirror', 'track1_mosaic_crystal', 'track1_multilayer_mirror', 'track1_radiation', 'track1_radiation_center', 'track1_runge_kutta', 'track1_sample', 'track1_spin', 'track1_spin_integration', 'track1_spin_taylor', 'track1_sr_wake', 'track1_symp_lie_ptc', 'track1_taylor', 'track1_time_runge_kutta', 'track_a_beambeam', 'track_a_bend', 'track_a_bend_photon', 'track_a_capillary', 'track_a_converter', 'track_a_crab_cavity', 'track_a_drift', 'track_a_drift_photon', 'track_a_foil', 'track_a_gkicker', 'track_a_lcavity', 'track_a_lcavity_old', 'track_a_mask', 'track_a_match', 'track_a_patch', 'track_a_patch_photon', 'track_a_pickup', 'track_a_quadrupole', 'track_a_rfcavity', 'track_a_sad_mult', 'track_a_sol_quad', 'track_a_thick_multipole', 'track_a_wiggler', 'track_a_zero_length_element', 'track_all', 'track_beam', 'track_bunch', 'track_bunch_time', 'track_bunch_to_s', 'track_bunch_to_t', 'track_complex_taylor', 'track_from_s_to_s', 'track_many', 'track_to_surface', 'track_until_dead', 'tracking_rad_map_setup', 'transfer_ac_kick', 'transfer_branch', 'transfer_branch_parameters', 'transfer_branches', 'transfer_ele', 'transfer_ele_taylor', 'transfer_eles', 'transfer_fieldmap', 'transfer_fixer_params', 'transfer_lat', 'transfer_lat_parameters', 'transfer_map_calc', 'transfer_map_from_s_to_s', 'transfer_mat2_from_twiss', 'transfer_mat_from_twiss', 'transfer_matrix_calc', 'transfer_twiss', 'transfer_wake', 'tricubic_cmplx_eval', 'truncate_complex_taylor_to_order', 'twiss1_propagate', 'twiss3_at_start', 'twiss3_from_twiss2', 'twiss3_propagate1', 'twiss3_propagate_all', 'twiss_and_track', 'twiss_and_track_at_s', 'twiss_and_track_from_s_to_s', 'twiss_and_track_intra_ele', 'twiss_at_element', 'twiss_at_start', 'twiss_from_tracking', 'twiss_propagate1', 'twiss_propagate_all', 'twiss_to_1_turn_mat', 'type_coord', 'type_expression_tree', 'type_this_file', 'upcase_string', 'update_ele_from_fibre', 'update_fibre_from_ele', 'update_floor_angles', 'valid_field_calc', 'valid_fringe_type', 'valid_mat6_calc_method', 'valid_spin_tracking_method', 'valid_tracking_method', 'value_of_attribute', 'value_to_line', 'vec_to_polar', 'vec_to_spinor', 'verify_valid_name', 'virtual_memory_usage', 'w_mat_for_bend_angle', 'w_mat_for_tilt', 'w_mat_for_x_pitch', 'w_mat_for_y_pitch', 'w_mat_to_axis_angle', 'w_mat_to_quat', 'wall3d_d_radius', 'wall3d_initializer', 'wall3d_section_initializer', 'wall3d_to_position', 'word_len', 'word_read', 'word_to_value', 'write_ascii_beam_file', 'write_astra_bend', 'write_astra_field_grid_file', 'write_astra_field_grid_file_3d', 'write_beam_file', 'write_beam_floor_positions', 'write_binary_cartesian_map', 'write_binary_cylindrical_map', 'write_binary_grid_field', 'write_blender_ele', 'write_blender_lat_layout', 'write_bmad_lattice_file', 'write_bunch_by_bunch_info', 'write_gpt_field_grid_file_1d', 'write_gpt_field_grid_file_2d', 'write_gpt_field_grid_file_3d', 'write_lat_line', 'write_lattice_in_elegant_format', 'write_lattice_in_foreign_format', 'write_lattice_in_mad_format', 'write_lattice_in_sad_format', 'write_lattice_in_scibmad', 'write_line_element', 'write_opal_field_grid_file', 'write_opal_lattice_file', 'write_time_particle_distribution', 'x0_radiation_length', 'xlafun', 'xraylib_nist_compound', 'ylafun', 'z_at_surface', 'zero_ele_kicks', 'zero_ele_offsets', 'zero_lr_wakes_in_lat', 'zlafun']
class AbMultipoleKick:
    """
    Fortran routine ab_multipole_kick return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dk(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"] | None:
        ...
    @property
    def kx(self) -> float:
        ...
    @property
    def ky(self) -> float:
        ...
class AbsoluteTimeTracking:
    """
    Fortran routine absolute_time_tracking return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_abs_time(self) -> bool:
        ...
class AcKickerAmp:
    """
    Fortran routine ac_kicker_amp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ac_amp(self) -> float:
        ...
class AcKickerFreqStruct:
    """
    Fortran struct: ac_kicker_freq_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp(self) -> float:
        ...
    @amp.setter
    def amp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def f(self) -> float:
        ...
    @f.setter
    def f(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
class AcKickerFreqStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> AcKickerFreqStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[AcKickerFreqStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> AcKickerFreqStructArray1D:
        ...
class AcKickerFreqStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> AcKickerFreqStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[AcKickerFreqStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class AcKickerStruct:
    """
    Fortran struct: ac_kicker_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp_vs_time(self) -> AcKickerTimeStructArray1D:
        ...
    @property
    def frequency(self) -> AcKickerFreqStructArray1D:
        ...
class AcKickerTimeStruct:
    """
    Fortran struct: ac_kicker_time_struct
    """
    spline: SplineStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp(self) -> float:
        ...
    @amp.setter
    def amp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def time(self) -> float:
        ...
    @time.setter
    def time(self, arg1: typing.SupportsFloat) -> None:
        ...
class AcKickerTimeStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> AcKickerTimeStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[AcKickerTimeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> AcKickerTimeStructArray1D:
        ...
class AcKickerTimeStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> AcKickerTimeStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[AcKickerTimeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ActionToXyz:
    """
    Fortran routine action_to_xyz return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def X(self) -> typing.Annotated[list[float], "FixedSize(6)"]:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class AddSuperimpose:
    """
    Fortran routine add_superimpose return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def super_ele_out(self) -> EleStruct:
        ...
class AddThisTaylorTerm:
    """
    Fortran routine add_this_taylor_term return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def coef(self) -> float:
        ...
    @property
    def i_out(self) -> int:
        ...
class AdjustSuperSlaveNames:
    """
    Fortran routine adjust_super_slave_names return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def first_time(self) -> bool | None:
        ...
    @property
    def ix1_lord(self) -> int:
        ...
    @property
    def ix2_lord(self) -> int:
        ...
class AllEncompassingStruct:
    """
    Fortran struct: all_encompassing_struct
    """
    complex_dp_0d: complex
    logical_0d: bool
    logical_0d_ptr: bool
    type_0d: TestSubStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def complex_dp_1d(self) -> ...:
        ...
    @property
    def complex_dp_1d_alloc(self) -> ...:
        ...
    @property
    def complex_dp_1d_ptr(self) -> ...:
        ...
    @property
    def complex_dp_2d(self) -> ...:
        ...
    @property
    def complex_dp_2d_alloc(self) -> ...:
        ...
    @property
    def complex_dp_2d_ptr(self) -> ...:
        ...
    @property
    def complex_dp_3d(self) -> ...:
        ...
    @property
    def complex_dp_3d_alloc(self) -> ...:
        ...
    @property
    def complex_dp_3d_ptr(self) -> ...:
        ...
    @property
    def int8_0d(self) -> int:
        ...
    @int8_0d.setter
    def int8_0d(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def int8_0d_ptr(self) -> int:
        ...
    @int8_0d_ptr.setter
    def int8_0d_ptr(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def int_0d(self) -> int:
        ...
    @int_0d.setter
    def int_0d(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def int_0d_ptr(self) -> int:
        ...
    @int_0d_ptr.setter
    def int_0d_ptr(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def int_1d(self) -> ...:
        ...
    @property
    def int_1d_alloc(self) -> ...:
        ...
    @property
    def int_1d_ptr(self) -> ...:
        ...
    @property
    def int_2d(self) -> ...:
        ...
    @property
    def int_2d_alloc(self) -> ...:
        ...
    @property
    def int_2d_ptr(self) -> ...:
        ...
    @property
    def int_3d(self) -> ...:
        ...
    @property
    def int_3d_alloc(self) -> ...:
        ...
    @property
    def int_3d_ptr(self) -> ...:
        ...
    @property
    def real_dp_0d(self) -> float:
        ...
    @real_dp_0d.setter
    def real_dp_0d(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def real_dp_0d_ptr(self) -> float:
        ...
    @real_dp_0d_ptr.setter
    def real_dp_0d_ptr(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def real_dp_1d(self) -> ...:
        ...
    @property
    def real_dp_1d_alloc(self) -> ...:
        ...
    @property
    def real_dp_1d_ptr(self) -> ...:
        ...
    @property
    def real_dp_2d(self) -> ...:
        ...
    @property
    def real_dp_2d_alloc(self) -> ...:
        ...
    @property
    def real_dp_2d_ptr(self) -> ...:
        ...
    @property
    def real_dp_3d(self) -> ...:
        ...
    @property
    def real_dp_3d_alloc(self) -> ...:
        ...
    @property
    def real_dp_3d_ptr(self) -> ...:
        ...
    @property
    def real_rp_0d(self) -> float:
        ...
    @real_rp_0d.setter
    def real_rp_0d(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def real_rp_0d_ptr(self) -> float:
        ...
    @real_rp_0d_ptr.setter
    def real_rp_0d_ptr(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def real_rp_1d(self) -> ...:
        ...
    @property
    def real_rp_1d_alloc(self) -> ...:
        ...
    @property
    def real_rp_1d_ptr(self) -> ...:
        ...
    @property
    def real_rp_2d(self) -> ...:
        ...
    @property
    def real_rp_2d_alloc(self) -> ...:
        ...
    @property
    def real_rp_2d_ptr(self) -> ...:
        ...
    @property
    def real_rp_3d(self) -> ...:
        ...
    @property
    def real_rp_3d_alloc(self) -> ...:
        ...
    @property
    def real_rp_3d_ptr(self) -> ...:
        ...
    @property
    def type_0d_ptr(self) -> _pybmad.TestSubStruct | None:
        ...
    @type_0d_ptr.setter
    def type_0d_ptr(self, arg1: TestSubStruct) -> None:
        ...
    @property
    def type_1d(self) -> ...:
        ...
    @property
    def type_1d_alloc(self) -> ...:
        ...
    @property
    def type_1d_ptr(self) -> ...:
        ...
    @property
    def type_2d(self) -> ...:
        ...
    @property
    def type_2d_alloc(self) -> ...:
        ...
    @property
    def type_2d_ptr(self) -> ...:
        ...
    @property
    def type_3d(self) -> ...:
        ...
    @property
    def type_3d_alloc(self) -> ...:
        ...
    @property
    def type_3d_ptr(self) -> ...:
        ...
class AngleBetweenPolars:
    """
    Fortran routine angle_between_polars return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def angle(self) -> float:
        ...
class AnormalModeStruct:
    """
    Fortran struct: anormal_mode_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def alpha_damp(self) -> float:
        ...
    @alpha_damp.setter
    def alpha_damp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def chrom(self) -> float:
        ...
    @chrom.setter
    def chrom(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def emittance(self) -> float:
        ...
    @emittance.setter
    def emittance(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def emittance_no_vert(self) -> float:
        ...
    @emittance_no_vert.setter
    def emittance_no_vert(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def j_damp(self) -> float:
        ...
    @j_damp.setter
    def j_damp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def synch_int(self) -> ...:
        ...
    @property
    def tune(self) -> float:
        ...
    @tune.setter
    def tune(self, arg1: typing.SupportsFloat) -> None:
        ...
class ApertureParamStruct:
    """
    Fortran struct: aperture_param_struct
    """
    start_ele: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def abs_accuracy(self) -> float:
        ...
    @abs_accuracy.setter
    def abs_accuracy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def max_angle(self) -> float:
        ...
    @max_angle.setter
    def max_angle(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def min_angle(self) -> float:
        ...
    @min_angle.setter
    def min_angle(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_angle(self) -> int:
        ...
    @n_angle.setter
    def n_angle(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_turn(self) -> int:
        ...
    @n_turn.setter
    def n_turn(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def rel_accuracy(self) -> float:
        ...
    @rel_accuracy.setter
    def rel_accuracy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x_init(self) -> float:
        ...
    @x_init.setter
    def x_init(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y_init(self) -> float:
        ...
    @y_init.setter
    def y_init(self, arg1: typing.SupportsFloat) -> None:
        ...
class AperturePointStruct:
    """
    Fortran struct: aperture_point_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def i_turn(self) -> int:
        ...
    @i_turn.setter
    def i_turn(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def plane(self) -> int:
        ...
    @plane.setter
    def plane(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg1: typing.SupportsFloat) -> None:
        ...
class AperturePointStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> AperturePointStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[AperturePointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> AperturePointStructArray1D:
        ...
class AperturePointStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> AperturePointStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[AperturePointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ApertureScanStruct:
    """
    Fortran struct: aperture_scan_struct
    """
    ref_orb: CoordStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def point(self) -> AperturePointStructArray1D:
        ...
    @property
    def pz_start(self) -> float:
        ...
    @pz_start.setter
    def pz_start(self, arg1: typing.SupportsFloat) -> None:
        ...
class ApertureScanStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ApertureScanStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ApertureScanStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ApertureScanStructArray1D:
        ...
class ApertureScanStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ApertureScanStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ApertureScanStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Apfft:
    """
    Fortran routine apfft return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def diag(self) -> int | None:
        ...
    @property
    def phase(self) -> float:
        ...
    @property
    def window(self) -> str:
        ...
class ApfftCorr:
    """
    Fortran routine apfft_corr return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def amp(self) -> float:
        ...
    @property
    def freq(self) -> float:
        ...
    @property
    def phase(self) -> float:
        ...
class ApfftExt:
    """
    Fortran routine apfft_ext return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def amp(self) -> float:
        ...
    @property
    def diag(self) -> int | None:
        ...
    @property
    def freq(self) -> float:
        ...
    @property
    def phase(self) -> float:
        ...
    @property
    def window(self) -> str:
        ...
class ArrayReStr:
    """
    Fortran routine array_re_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def parens_in(self) -> str | None:
        ...
    @property
    def str_out(self) -> str:
        ...
class Asinc:
    """
    Fortran routine asinc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class AssertEqual:
    """
    Fortran routine assert_equal return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def ival(self) -> int:
        ...
class AstraMaxFieldReference:
    """
    Fortran routine astra_max_field_reference return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def field_value(self) -> float:
        ...
class AtThisEleEnd:
    """
    Fortran routine at_this_ele_end return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_at_this_end(self) -> bool:
        ...
class AttributeFree1:
    """
    Fortran routine attribute_free1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_name(self) -> str:
        ...
    @property
    def dependent_attribs_free(self) -> bool | None:
        ...
    @property
    def err_print_flag(self) -> bool | None:
        ...
    @property
    def except_overlay(self) -> bool | None:
        ...
    @property
    def free(self) -> bool:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @property
    def why_not_free(self) -> int | None:
        ...
class AttributeFree2:
    """
    Fortran routine attribute_free2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_name(self) -> str:
        ...
    @property
    def dependent_attribs_free(self) -> bool | None:
        ...
    @property
    def err_print_flag(self) -> bool | None:
        ...
    @property
    def except_overlay(self) -> bool | None:
        ...
    @property
    def free(self) -> bool:
        ...
    @property
    def why_not_free(self) -> int | None:
        ...
class AttributeFree3:
    """
    Fortran routine attribute_free3 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_name(self) -> str:
        ...
    @property
    def dependent_attribs_free(self) -> bool | None:
        ...
    @property
    def err_print_flag(self) -> bool | None:
        ...
    @property
    def except_overlay(self) -> bool | None:
        ...
    @property
    def free(self) -> bool:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @property
    def why_not_free(self) -> int | None:
        ...
class AttributeIndex1:
    """
    Fortran routine attribute_index1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_index(self) -> int:
        ...
    @property
    def can_abbreviate(self) -> bool | None:
        ...
    @property
    def full_name(self) -> str | None:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def print_error(self) -> bool | None:
        ...
class AttributeIndex2:
    """
    Fortran routine attribute_index2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_index(self) -> int:
        ...
    @property
    def can_abbreviate(self) -> bool | None:
        ...
    @property
    def full_name(self) -> str | None:
        ...
    @property
    def key(self) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def print_error(self) -> bool | None:
        ...
class AttributeName1:
    """
    Fortran routine attribute_name1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_name(self) -> str:
        ...
    @property
    def ix_att(self) -> int:
        ...
    @property
    def key(self) -> int:
        ...
    @property
    def show_private(self) -> bool | None:
        ...
class AttributeName2:
    """
    Fortran routine attribute_name2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_name(self) -> str:
        ...
    @property
    def ix_att(self) -> int:
        ...
    @property
    def show_private(self) -> bool | None:
        ...
class BbiKick:
    """
    Fortran routine bbi_kick return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dnk(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"]:
        ...
    @property
    def nk(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
class BbuBeamStruct:
    """
    Fortran struct: bbu_beam_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def bunch(self) -> BunchStructArray1D:
        ...
    @property
    def hom_voltage_max(self) -> float:
        ...
    @hom_voltage_max.setter
    def hom_voltage_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_bunch_end(self) -> int:
        ...
    @ix_bunch_end.setter
    def ix_bunch_end(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_bunch_head(self) -> int:
        ...
    @ix_bunch_head.setter
    def ix_bunch_head(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele_bunch(self) -> ...:
        ...
    @property
    def ix_stage_voltage_max(self) -> int:
        ...
    @ix_stage_voltage_max.setter
    def ix_stage_voltage_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_bunch_in_lat(self) -> int:
        ...
    @n_bunch_in_lat.setter
    def n_bunch_in_lat(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def one_turn_time(self) -> float:
        ...
    @one_turn_time.setter
    def one_turn_time(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rf_wavelength_max(self) -> float:
        ...
    @rf_wavelength_max.setter
    def rf_wavelength_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def stage(self) -> BbuStageStructArray1D:
        ...
    @property
    def time_now(self) -> float:
        ...
    @time_now.setter
    def time_now(self, arg1: typing.SupportsFloat) -> None:
        ...
class BbuHomVoltageCalc:
    """
    Fortran routine bbu_hom_voltage_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_stage_last_tracked(self) -> int:
        ...
    @property
    def n_period(self) -> int:
        ...
class BbuParamStruct:
    """
    Fortran struct: bbu_param_struct
    """
    bunch_by_bunch_info_file: str
    drscan: bool
    ele_track_end: str
    elname: str
    hybridize: bool
    keep_all_lcavities: bool
    keep_overlays_and_groups: bool
    lat2_filename: str
    lat_filename: str
    normalize_z_to_rf: bool
    ramp_on: bool
    regression: bool
    stable_orbit_anal: bool
    use_interpolated_threshold: bool
    use_taylor_for_hybrids: bool
    write_digested_hybrid_lat: bool
    write_hom_info: bool
    write_voltage_vs_time_dat: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def begdr(self) -> float:
        ...
    @begdr.setter
    def begdr(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def bunch_freq(self) -> float:
        ...
    @bunch_freq.setter
    def bunch_freq(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def current(self) -> float:
        ...
    @current.setter
    def current(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def elindex(self) -> int:
        ...
    @elindex.setter
    def elindex(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def enddr(self) -> float:
        ...
    @enddr.setter
    def enddr(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def hom_order_cutoff(self) -> int:
        ...
    @hom_order_cutoff.setter
    def hom_order_cutoff(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def init_particle_offset(self) -> float:
        ...
    @init_particle_offset.setter
    def init_particle_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_ele_track_end(self) -> int:
        ...
    @ix_ele_track_end.setter
    def ix_ele_track_end(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def limit_factor(self) -> float:
        ...
    @limit_factor.setter
    def limit_factor(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_ramp_pattern(self) -> int:
        ...
    @n_ramp_pattern.setter
    def n_ramp_pattern(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def nrep(self) -> int:
        ...
    @nrep.setter
    def nrep(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def nstep(self) -> int:
        ...
    @nstep.setter
    def nstep(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ramp_n_start(self) -> int:
        ...
    @ramp_n_start.setter
    def ramp_n_start(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ramp_pattern(self) -> ...:
        ...
    @property
    def ran_gauss_sigma_cut(self) -> float:
        ...
    @ran_gauss_sigma_cut.setter
    def ran_gauss_sigma_cut(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ran_seed(self) -> int:
        ...
    @ran_seed.setter
    def ran_seed(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def rel_tol(self) -> float:
        ...
    @rel_tol.setter
    def rel_tol(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def simulation_turns_max(self) -> float:
        ...
    @simulation_turns_max.setter
    def simulation_turns_max(self, arg1: typing.SupportsFloat) -> None:
        ...
class BbuSetup:
    """
    Fortran routine bbu_setup return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dt_bunch(self) -> float:
        ...
class BbuStageStruct:
    """
    Fortran struct: bbu_stage_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ave_orb(self) -> ...:
        ...
    @property
    def hom_voltage_max(self) -> float:
        ...
    @hom_voltage_max.setter
    def hom_voltage_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_ele_lr_wake(self) -> int:
        ...
    @ix_ele_lr_wake.setter
    def ix_ele_lr_wake(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele_stage_end(self) -> int:
        ...
    @ix_ele_stage_end.setter
    def ix_ele_stage_end(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_head_bunch(self) -> int:
        ...
    @ix_head_bunch.setter
    def ix_head_bunch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_hom_max(self) -> int:
        ...
    @ix_hom_max.setter
    def ix_hom_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_pass(self) -> int:
        ...
    @ix_pass.setter
    def ix_pass(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_stage_pass1(self) -> int:
        ...
    @ix_stage_pass1.setter
    def ix_stage_pass1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def max_orb(self) -> ...:
        ...
    @property
    def min_orb(self) -> ...:
        ...
    @property
    def n_orb(self) -> int:
        ...
    @n_orb.setter
    def n_orb(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def rms_orb(self) -> ...:
        ...
    @property
    def time_at_wake_ele(self) -> float:
        ...
    @time_at_wake_ele.setter
    def time_at_wake_ele(self, arg1: typing.SupportsFloat) -> None:
        ...
class BbuStageStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BbuStageStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BbuStageStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> BbuStageStructArray1D:
        ...
class BbuStageStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BbuStageStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BbuStageStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class BbuTrackAStage:
    """
    Fortran routine bbu_track_a_stage return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_stage_tracked(self) -> int:
        ...
    @property
    def lost(self) -> bool:
        ...
class BbuTrackAll:
    """
    Fortran routine bbu_track_all return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def growth_rate(self) -> float:
        ...
    @property
    def hom_voltage_normalized(self) -> float:
        ...
    @property
    def irep(self) -> int:
        ...
    @property
    def lost(self) -> bool:
        ...
class BeamInitStruct:
    """
    Fortran struct: beam_init_struct
    """
    KV: KvBeamInitStruct
    file_name: str
    full_6D_coupling_calc: bool
    position_file: str
    random_engine: str
    random_gauss_converter: str
    renorm_center: bool
    renorm_sigma: bool
    species: str
    use_particle_start: bool
    use_t_coords: bool
    use_z_as_t: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a_emit(self) -> float:
        ...
    @a_emit.setter
    def a_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def a_norm_emit(self) -> float:
        ...
    @a_norm_emit.setter
    def a_norm_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_emit(self) -> float:
        ...
    @b_emit.setter
    def b_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_norm_emit(self) -> float:
        ...
    @b_norm_emit.setter
    def b_norm_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def bunch_charge(self) -> float:
        ...
    @bunch_charge.setter
    def bunch_charge(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def center(self) -> ...:
        ...
    @property
    def center_jitter(self) -> ...:
        ...
    @property
    def dPz_dz(self) -> float:
        ...
    @dPz_dz.setter
    def dPz_dz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def distribution_type(self) -> ...:
        ...
    @property
    def dt_bunch(self) -> float:
        ...
    @dt_bunch.setter
    def dt_bunch(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ellipse(self) -> EllipseBeamInitStructArray1D:
        ...
    @property
    def emit_jitter(self) -> ...:
        ...
    @property
    def grid(self) -> GridBeamInitStructArray1D:
        ...
    @property
    def ix_turn(self) -> int:
        ...
    @ix_turn.setter
    def ix_turn(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_bunch(self) -> int:
        ...
    @n_bunch.setter
    def n_bunch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_particle(self) -> int:
        ...
    @n_particle.setter
    def n_particle(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def random_sigma_cutoff(self) -> float:
        ...
    @random_sigma_cutoff.setter
    def random_sigma_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_pz(self) -> float:
        ...
    @sig_pz.setter
    def sig_pz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_pz_jitter(self) -> float:
        ...
    @sig_pz_jitter.setter
    def sig_pz_jitter(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_z(self) -> float:
        ...
    @sig_z.setter
    def sig_z(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_z_jitter(self) -> float:
        ...
    @sig_z_jitter.setter
    def sig_z_jitter(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def spin(self) -> ...:
        ...
    @property
    def t_offset(self) -> float:
        ...
    @t_offset.setter
    def t_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
class BeamStruct:
    """
    Fortran struct: beam_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def bunch(self) -> BunchStructArray1D:
        ...
class BeamTilts:
    """
    Fortran routine beam_tilts return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def angle_xpz(self) -> float:
        ...
    @property
    def angle_xy(self) -> float:
        ...
    @property
    def angle_xz(self) -> float:
        ...
    @property
    def angle_ypz(self) -> float:
        ...
    @property
    def angle_yz(self) -> float:
        ...
class BendLengthHasBeenSet:
    """
    Fortran routine bend_length_has_been_set return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_set(self) -> bool:
        ...
class BicubicCmplxCoefStruct:
    """
    Fortran struct: bicubic_cmplx_coef_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def coef(self) -> ...:
        ...
    @property
    def i_box(self) -> ...:
        ...
class BicubicCmplxCoefStructArray3D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BicubicCmplxCoefStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BicubicCmplxCoefStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class BicubicCmplxEval:
    """
    Fortran routine bicubic_cmplx_eval return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def df_dx(self) -> complex:
        ...
    @property
    def df_dy(self) -> complex:
        ...
    @property
    def f_val(self) -> complex:
        ...
class BinXCenter:
    """
    Fortran routine bin_x_center return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_bin(self) -> int:
        ...
    @property
    def x_center(self) -> float:
        ...
class BitSet:
    """
    Fortran routine bit_set return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def word(self) -> int:
        ...
class BmadCommonStruct:
    """
    Fortran struct: bmad_common_struct
    """
    absolute_time_ref_shift: bool
    absolute_time_tracking: bool
    aperture_limit_on: bool
    auto_bookkeeper: bool
    conserve_taylor_maps: bool
    convert_to_kinetic_momentum: bool
    csr_and_space_charge_on: bool
    debug: bool
    high_energy_space_charge_on: bool
    lr_wakes_on: bool
    normalize_twiss: bool
    radiation_damping_on: bool
    radiation_fluctuations_on: bool
    radiation_zero_average: bool
    rf_phase_below_transition_ref: bool
    spin_n0_direction_user_set: bool
    spin_sokolov_ternov_flipping_on: bool
    spin_tracking_on: bool
    sr_wakes_on: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def abs_tol_adaptive_tracking(self) -> float:
        ...
    @abs_tol_adaptive_tracking.setter
    def abs_tol_adaptive_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def abs_tol_tracking(self) -> float:
        ...
    @abs_tol_tracking.setter
    def abs_tol_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def autoscale_amp_abs_tol(self) -> float:
        ...
    @autoscale_amp_abs_tol.setter
    def autoscale_amp_abs_tol(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def autoscale_amp_rel_tol(self) -> float:
        ...
    @autoscale_amp_rel_tol.setter
    def autoscale_amp_rel_tol(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def autoscale_phase_tol(self) -> float:
        ...
    @autoscale_phase_tol.setter
    def autoscale_phase_tol(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def d_orb(self) -> ...:
        ...
    @property
    def default_ds_step(self) -> float:
        ...
    @default_ds_step.setter
    def default_ds_step(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def default_integ_order(self) -> int:
        ...
    @default_integ_order.setter
    def default_integ_order(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def electric_dipole_moment(self) -> float:
        ...
    @electric_dipole_moment.setter
    def electric_dipole_moment(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def fatal_ds_adaptive_tracking(self) -> float:
        ...
    @fatal_ds_adaptive_tracking.setter
    def fatal_ds_adaptive_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def init_ds_adaptive_tracking(self) -> float:
        ...
    @init_ds_adaptive_tracking.setter
    def init_ds_adaptive_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def max_aperture_limit(self) -> float:
        ...
    @max_aperture_limit.setter
    def max_aperture_limit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def max_num_runge_kutta_step(self) -> int:
        ...
    @max_num_runge_kutta_step.setter
    def max_num_runge_kutta_step(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def min_ds_adaptive_tracking(self) -> float:
        ...
    @min_ds_adaptive_tracking.setter
    def min_ds_adaptive_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rel_tol_adaptive_tracking(self) -> float:
        ...
    @rel_tol_adaptive_tracking.setter
    def rel_tol_adaptive_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rel_tol_tracking(self) -> float:
        ...
    @rel_tol_tracking.setter
    def rel_tol_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def runge_kutta_order(self) -> int:
        ...
    @runge_kutta_order.setter
    def runge_kutta_order(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def sad_amp_max(self) -> float:
        ...
    @sad_amp_max.setter
    def sad_amp_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sad_eps_scale(self) -> float:
        ...
    @sad_eps_scale.setter
    def sad_eps_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sad_n_div_max(self) -> int:
        ...
    @sad_n_div_max.setter
    def sad_n_div_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def significant_length(self) -> float:
        ...
    @significant_length.setter
    def significant_length(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def synch_rad_scale(self) -> float:
        ...
    @synch_rad_scale.setter
    def synch_rad_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def taylor_order(self) -> int:
        ...
    @taylor_order.setter
    def taylor_order(self, arg1: typing.SupportsInt) -> None:
        ...
class BmadNormalFormStruct:
    """
    Fortran struct: bmad_normal_form_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def A(self) -> TaylorStructArray1D:
        ...
    @property
    def A_inv(self) -> TaylorStructArray1D:
        ...
    @property
    def F(self) -> ComplexTaylorStructArray1D:
        ...
    @property
    def L(self) -> ComplexTaylorStructArray1D:
        ...
    @property
    def M(self) -> TaylorStructArray1D:
        ...
    @property
    def dhdj(self) -> TaylorStructArray1D:
        ...
    @property
    def ele_origin(self) -> _pybmad.EleStruct | None:
        ...
    @ele_origin.setter
    def ele_origin(self, arg1: EleStruct) -> None:
        ...
    @property
    def h(self) -> ResonanceHStructArray1D:
        ...
class BmadParser:
    """
    Fortran routine bmad_parser return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def digested_read_ok(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def lat(self) -> LatStruct:
        ...
    @property
    def parse_lat(self) -> LatStruct:
        ...
class BmadParser2:
    """
    Fortran routine bmad_parser2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
class BookkeepingStateStruct:
    """
    Fortran struct: bookkeeping_state_struct
    """
    has_misalign: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def attributes(self) -> int:
        ...
    @attributes.setter
    def attributes(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def control(self) -> int:
        ...
    @control.setter
    def control(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def floor_position(self) -> int:
        ...
    @floor_position.setter
    def floor_position(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def mat6(self) -> int:
        ...
    @mat6.setter
    def mat6(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ptc(self) -> int:
        ...
    @ptc.setter
    def ptc(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def rad_int(self) -> int:
        ...
    @rad_int.setter
    def rad_int(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ref_energy(self) -> int:
        ...
    @ref_energy.setter
    def ref_energy(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def s_position(self) -> int:
        ...
    @s_position.setter
    def s_position(self, arg1: typing.SupportsInt) -> None:
        ...
class BoolAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[bool]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: bool) -> None:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> BoolArray1D:
        ...
class BoolArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: bool) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[bool]:
        ...
    @property
    def lower_bound(self) -> int:
        ...
    @property
    def upper_bound(self) -> int:
        ...
class BoolArray2D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: bool) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[bool]:
        ...
    @property
    def total_size(self) -> int:
        ...
class BoolArray3D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: bool) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[bool]:
        ...
    @property
    def total_size(self) -> int:
        ...
class BpmPhaseCouplingStruct:
    """
    Fortran struct: bpm_phase_coupling_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def Cbar11_b(self) -> float:
        ...
    @Cbar11_b.setter
    def Cbar11_b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def Cbar12_a(self) -> float:
        ...
    @Cbar12_a.setter
    def Cbar12_a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def Cbar12_b(self) -> float:
        ...
    @Cbar12_b.setter
    def Cbar12_b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def Cbar22_a(self) -> float:
        ...
    @Cbar22_a.setter
    def Cbar22_a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def K_11b(self) -> float:
        ...
    @K_11b.setter
    def K_11b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def K_12a(self) -> float:
        ...
    @K_12a.setter
    def K_12a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def K_12b(self) -> float:
        ...
    @K_12b.setter
    def K_12b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def K_22a(self) -> float:
        ...
    @K_22a.setter
    def K_22a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi_a(self) -> float:
        ...
    @phi_a.setter
    def phi_a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi_b(self) -> float:
        ...
    @phi_b.setter
    def phi_b(self, arg1: typing.SupportsFloat) -> None:
        ...
class BracketIndexForSpline:
    """
    Fortran routine bracket_index_for_spline return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix0(self) -> int:
        ...
    @property
    def ok(self) -> bool:
        ...
class BranchName:
    """
    Fortran routine branch_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def name(self) -> str:
        ...
class BranchStruct:
    """
    Fortran struct: branch_struct
    """
    a: ModeInfoStruct
    b: ModeInfoStruct
    name: str
    param: LatParamStruct
    particle_start: CoordStruct
    z: ModeInfoStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele(self) -> EleStructArray1D:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_fixer(self) -> int:
        ...
    @ix_fixer.setter
    def ix_fixer(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_from_branch(self) -> int:
        ...
    @ix_from_branch.setter
    def ix_from_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_from_ele(self) -> int:
        ...
    @ix_from_ele.setter
    def ix_from_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_to_ele(self) -> int:
        ...
    @ix_to_ele.setter
    def ix_to_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def lat(self) -> _pybmad.LatStruct | None:
        ...
    @lat.setter
    def lat(self, arg1: LatStruct) -> None:
        ...
    @property
    def n_ele_max(self) -> int:
        ...
    @n_ele_max.setter
    def n_ele_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_ele_track(self) -> int:
        ...
    @n_ele_track.setter
    def n_ele_track(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def wall3d(self) -> Wall3DStructArray1D:
        ...
class BranchStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BranchStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> BranchStructArray1D:
        ...
class BranchStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BranchStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class BunchParamsStruct:
    """
    Fortran struct: bunch_params_struct
    """
    a: TwissStruct
    b: TwissStruct
    c: TwissStruct
    centroid: CoordStruct
    twiss_valid: bool
    x: TwissStruct
    y: TwissStruct
    z: TwissStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def charge_live(self) -> float:
        ...
    @charge_live.setter
    def charge_live(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def charge_tot(self) -> float:
        ...
    @charge_tot.setter
    def charge_tot(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def location(self) -> int:
        ...
    @location.setter
    def location(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_bad_steps(self) -> int:
        ...
    @n_bad_steps.setter
    def n_bad_steps(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_good_steps(self) -> int:
        ...
    @n_good_steps.setter
    def n_good_steps(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_particle_live(self) -> int:
        ...
    @n_particle_live.setter
    def n_particle_live(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_particle_lost_in_ele(self) -> int:
        ...
    @n_particle_lost_in_ele.setter
    def n_particle_lost_in_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_particle_tot(self) -> int:
        ...
    @n_particle_tot.setter
    def n_particle_tot(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def rel_max(self) -> ...:
        ...
    @property
    def rel_min(self) -> ...:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigma(self) -> ...:
        ...
    @property
    def sigma_t(self) -> float:
        ...
    @sigma_t.setter
    def sigma_t(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def t(self) -> float:
        ...
    @t.setter
    def t(self, arg1: typing.SupportsFloat) -> None:
        ...
class BunchParamsStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BunchParamsStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BunchParamsStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> BunchParamsStructArray1D:
        ...
class BunchParamsStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BunchParamsStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BunchParamsStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class BunchStruct:
    """
    Fortran struct: bunch_struct
    """
    drift_between_t_and_s: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def charge_live(self) -> float:
        ...
    @charge_live.setter
    def charge_live(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def charge_tot(self) -> float:
        ...
    @charge_tot.setter
    def charge_tot(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_bunch(self) -> int:
        ...
    @ix_bunch.setter
    def ix_bunch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_turn(self) -> int:
        ...
    @ix_turn.setter
    def ix_turn(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_z(self) -> ...:
        ...
    @property
    def n_bad(self) -> int:
        ...
    @n_bad.setter
    def n_bad(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_good(self) -> int:
        ...
    @n_good.setter
    def n_good(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_live(self) -> int:
        ...
    @n_live.setter
    def n_live(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def particle(self) -> CoordStructArray1D:
        ...
    @property
    def t0(self) -> float:
        ...
    @t0.setter
    def t0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def t_center(self) -> float:
        ...
    @t_center.setter
    def t_center(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z_center(self) -> float:
        ...
    @z_center.setter
    def z_center(self, arg1: typing.SupportsFloat) -> None:
        ...
class BunchStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BunchStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BunchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> BunchStructArray1D:
        ...
class BunchStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BunchStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BunchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class BunchTrackStruct:
    """
    Fortran struct: bunch_track_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ds_save(self) -> float:
        ...
    @ds_save.setter
    def ds_save(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_pt(self) -> int:
        ...
    @n_pt.setter
    def n_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def pt(self) -> BunchParamsStructArray1D:
        ...
class BunchTrackStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BunchTrackStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BunchTrackStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> BunchTrackStructArray1D:
        ...
class BunchTrackStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> BunchTrackStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[BunchTrackStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CalcBunchSigmaMatrixEtc:
    """
    Fortran routine calc_bunch_sigma_matrix_etc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bunch_params(self) -> BunchParamsStruct:
        ...
    @property
    def is_time_coords(self) -> bool | None:
        ...
class CalcEmittancesAndTwissFromSigmaMatrix:
    """
    Fortran routine calc_emittances_and_twiss_from_sigma_matrix return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bunch_params(self) -> BunchParamsStruct:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def n_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
class CalcFileNumber:
    """
    Fortran routine calc_file_number return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def file_name(self) -> str:
        ...
    @property
    def num_in(self) -> int:
        ...
    @property
    def num_out(self) -> int:
        ...
class CalcWallRadius:
    """
    Fortran routine calc_wall_radius return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dr_dtheta(self) -> float:
        ...
    @property
    def ix_vertex(self) -> int:
        ...
    @property
    def r_wall(self) -> float:
        ...
class CartesianMapStruct:
    """
    Fortran struct: cartesian_map_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele_anchor_pt(self) -> int:
        ...
    @ele_anchor_pt.setter
    def ele_anchor_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def field_scale(self) -> float:
        ...
    @field_scale.setter
    def field_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def field_type(self) -> int:
        ...
    @field_type.setter
    def field_type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def master_parameter(self) -> int:
        ...
    @master_parameter.setter
    def master_parameter(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ptr(self) -> _pybmad.CartesianMapTermStruct | None:
        ...
    @ptr.setter
    def ptr(self, arg1: CartesianMapTermStruct) -> None:
        ...
    @property
    def r0(self) -> ...:
        ...
class CartesianMapStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CartesianMapStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CartesianMapStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> CartesianMapStructArray1D:
        ...
class CartesianMapStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CartesianMapStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CartesianMapStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CartesianMapTerm1Struct:
    """
    Fortran struct: cartesian_map_term1_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def coef(self) -> float:
        ...
    @coef.setter
    def coef(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def family(self) -> int:
        ...
    @family.setter
    def family(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def form(self) -> int:
        ...
    @form.setter
    def form(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def kx(self) -> float:
        ...
    @kx.setter
    def kx(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ky(self) -> float:
        ...
    @ky.setter
    def ky(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def kz(self) -> float:
        ...
    @kz.setter
    def kz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi_z(self) -> float:
        ...
    @phi_z.setter
    def phi_z(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x0(self) -> float:
        ...
    @x0.setter
    def x0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y0(self) -> float:
        ...
    @y0.setter
    def y0(self, arg1: typing.SupportsFloat) -> None:
        ...
class CartesianMapTerm1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CartesianMapTerm1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CartesianMapTerm1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> CartesianMapTerm1StructArray1D:
        ...
class CartesianMapTerm1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CartesianMapTerm1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CartesianMapTerm1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CartesianMapTermStruct:
    """
    Fortran struct: cartesian_map_term_struct
    """
    file: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def n_link(self) -> int:
        ...
    @n_link.setter
    def n_link(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def term(self) -> CartesianMapTerm1StructArray1D:
        ...
class ChangeFileNumber:
    """
    Fortran routine change_file_number return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def change(self) -> int:
        ...
    @property
    def file_name(self) -> str:
        ...
class CheckForSuperimposeProblem:
    """
    Fortran routine check_for_superimpose_problem return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def wrap(self) -> bool:
        ...
class CheckIfSInBounds:
    """
    Fortran routine check_if_s_in_bounds return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def translated_s(self) -> float:
        ...
class CheckRfFreq:
    """
    Fortran routine check_rf_freq return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def fb(self) -> float:
        ...
class ChooseQuadsForSetTune:
    """
    Fortran routine choose_quads_for_set_tune return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dk1(self) -> RealAlloc1D:
        ...
    @property
    def eles(self) -> ElePointerStructAlloc1D:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ChromCalc:
    """
    Fortran routine chrom_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def chrom_a(self) -> float:
        ...
    @property
    def chrom_b(self) -> float:
        ...
    @property
    def delta_e(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def high_E_lat(self) -> LatStruct:
        ...
    @property
    def high_E_orb(self) -> CoordStructAlloc1D:
        ...
    @property
    def low_E_lat(self) -> LatStruct:
        ...
    @property
    def low_E_orb(self) -> CoordStructAlloc1D:
        ...
class ChromTune:
    """
    Fortran routine chrom_tune return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delta_e(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ClassicalRadius:
    """
    Fortran routine classical_radius return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def radius(self) -> float:
        ...
class ClosedOrbitFromTracking:
    """
    Fortran routine closed_orbit_from_tracking return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def closed_orb(self) -> CoordStructAlloc1D:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class CmplxReStr:
    """
    Fortran routine cmplx_re_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cmp(self) -> complex:
        ...
    @property
    def str_out(self) -> str:
        ...
class CoarseFrequencyEstimate:
    """
    Fortran routine coarse_frequency_estimate return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool | None:
        ...
    @property
    def frequency(self) -> float:
        ...
class ComplexAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> complex:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[complex]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: complex) -> None:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ComplexArray1D:
        ...
class ComplexArray1D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.SupportsInt) -> complex:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: complex) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[complex]:
        ...
    @property
    def lower_bound(self) -> int:
        ...
    @property
    def upper_bound(self) -> int:
        ...
class ComplexArray2D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> complex:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: complex) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[complex]:
        ...
    @property
    def total_size(self) -> int:
        ...
class ComplexArray3D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> complex:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: complex) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[complex]:
        ...
    @property
    def total_size(self) -> int:
        ...
class ComplexErrorFunction:
    """
    Fortran routine complex_error_function return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def wi(self) -> float:
        ...
    @property
    def wr(self) -> float:
        ...
    @property
    def zi(self) -> float:
        ...
    @property
    def zr(self) -> float:
        ...
class ComplexTaylorCoef1:
    """
    Fortran routine complex_taylor_coef1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def coef(self) -> complex:
        ...
class ComplexTaylorCoef2:
    """
    Fortran routine complex_taylor_coef2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def coef(self) -> complex:
        ...
class ComplexTaylorStruct:
    """
    Fortran struct: complex_taylor_struct
    """
    ref: complex
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def term(self) -> ComplexTaylorTermStructArray1D:
        ...
class ComplexTaylorStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ComplexTaylorStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ComplexTaylorStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ComplexTaylorStructArray1D:
        ...
class ComplexTaylorStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ComplexTaylorStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ComplexTaylorStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ComplexTaylorTermStruct:
    """
    Fortran struct: complex_taylor_term_struct
    """
    coef: complex
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def expn(self) -> ...:
        ...
class ComplexTaylorTermStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ComplexTaylorTermStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ComplexTaylorTermStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ComplexTaylorTermStructArray1D:
        ...
class ComplexTaylorTermStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ComplexTaylorTermStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ComplexTaylorTermStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ComplexTaylorToMat6:
    """
    Fortran routine complex_taylor_to_mat6 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def mat6(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def r_out(self) -> ComplexAlloc1D:
        ...
    @property
    def vec0(self) -> typing.Annotated[list[complex], "FixedSize(6)"]:
        ...
class ControlRamp1Struct:
    """
    Fortran struct: control_ramp1_struct
    """
    attribute: str
    is_controller: bool
    slave_name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def stack(self) -> ExpressionAtomStructArray1D:
        ...
    @property
    def y_knot(self) -> ...:
        ...
class ControlRamp1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ControlRamp1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ControlRamp1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ControlRamp1StructArray1D:
        ...
class ControlRamp1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ControlRamp1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ControlRamp1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ControlStruct:
    """
    Fortran struct: control_struct
    """
    attribute: str
    lord: LatEleLocStruct
    slave: LatEleLocStruct
    slave_name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_attrib(self) -> int:
        ...
    @ix_attrib.setter
    def ix_attrib(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def stack(self) -> ExpressionAtomStructArray1D:
        ...
    @property
    def value(self) -> float:
        ...
    @value.setter
    def value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y_knot(self) -> ...:
        ...
class ControlStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ControlStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ControlStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ControlStructArray1D:
        ...
class ControlStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ControlStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ControlStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ControlVar1Struct:
    """
    Fortran struct: control_var1_struct
    """
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def old_value(self) -> float:
        ...
    @old_value.setter
    def old_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def value(self) -> float:
        ...
    @value.setter
    def value(self, arg1: typing.SupportsFloat) -> None:
        ...
class ControlVar1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ControlVar1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ControlVar1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ControlVar1StructArray1D:
        ...
class ControlVar1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ControlVar1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ControlVar1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ControllerStruct:
    """
    Fortran struct: controller_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ramp(self) -> ControlRamp1StructArray1D:
        ...
    @property
    def ramper_lord(self) -> RamperLordStructArray1D:
        ...
    @property
    def var(self) -> ControlVar1StructArray1D:
        ...
    @property
    def x_knot(self) -> ...:
        ...
class ConvertCoords:
    """
    Fortran routine convert_coords return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def coord_out(self) -> CoordStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def out_type_str(self) -> str:
        ...
class ConvertLocalCartesianToLocalCurvilinear:
    """
    Fortran routine convert_local_cartesian_to_local_curvilinear return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def g(self) -> float:
        ...
    @property
    def sout(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def xout(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
class ConvertLocalCurvilinearToLocalCartesian:
    """
    Fortran routine convert_local_curvilinear_to_local_cartesian return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def g(self) -> float:
        ...
    @property
    def s(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def xout(self) -> float:
        ...
    @property
    def zout(self) -> float:
        ...
class ConvertPcTo:
    """
    Fortran routine convert_pc_to return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def E_tot(self) -> float:
        ...
    @property
    def beta(self) -> float:
        ...
    @property
    def beta1(self) -> float:
        ...
    @property
    def brho(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def gamma(self) -> float:
        ...
    @property
    def kinetic(self) -> float:
        ...
class ConvertTotalEnergyTo:
    """
    Fortran routine convert_total_energy_to return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def beta(self) -> float:
        ...
    @property
    def beta1(self) -> float:
        ...
    @property
    def brho(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def gamma(self) -> float:
        ...
    @property
    def kinetic(self) -> float:
        ...
    @property
    def pc(self) -> float:
        ...
class ConverterDistributionParser:
    """
    Fortran routine converter_distribution_parser return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class CoordArrayStruct:
    """
    Fortran struct: coord_array_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def orbit(self) -> CoordStructArray1D:
        ...
class CoordArrayStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CoordArrayStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CoordArrayStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> CoordArrayStructArray1D:
        ...
class CoordArrayStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CoordArrayStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CoordArrayStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CoordStateName:
    """
    Fortran routine coord_state_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def one_word(self) -> bool | None:
        ...
    @property
    def state_str(self) -> str:
        ...
class CoordStruct:
    """
    Fortran struct: coord_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def E_potential(self) -> float:
        ...
    @E_potential.setter
    def E_potential(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def beta(self) -> float:
        ...
    @beta.setter
    def beta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def charge(self) -> float:
        ...
    @charge.setter
    def charge(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def direction(self) -> int:
        ...
    @direction.setter
    def direction(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def dt_ref(self) -> float:
        ...
    @dt_ref.setter
    def dt_ref(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def field(self) -> ...:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_turn(self) -> int:
        ...
    @ix_turn.setter
    def ix_turn(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_user(self) -> int:
        ...
    @ix_user.setter
    def ix_user(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def location(self) -> int:
        ...
    @location.setter
    def location(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def p0c(self) -> float:
        ...
    @p0c.setter
    def p0c(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phase(self) -> ...:
        ...
    @property
    def r(self) -> float:
        ...
    @r.setter
    def r(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def species(self) -> int:
        ...
    @species.setter
    def species(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def spin(self) -> ...:
        ...
    @property
    def state(self) -> int:
        ...
    @state.setter
    def state(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def t(self) -> float:
        ...
    @t.setter
    def t(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def time_dir(self) -> int:
        ...
    @time_dir.setter
    def time_dir(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def vec(self) -> ...:
        ...
class CoordStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CoordStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CoordStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> CoordStructArray1D:
        ...
class CoordStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CoordStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CoordStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CoordsFloorToCurvilinear:
    """
    Fortran routine coords_floor_to_curvilinear return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele1(self) -> EleStruct:
        ...
    @property
    def status(self) -> int:
        ...
    @property
    def w_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"] | None:
        ...
class CoordsFloorToLocalCurvilinear:
    """
    Fortran routine coords_floor_to_local_curvilinear return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def status(self) -> int:
        ...
    @property
    def w_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"] | None:
        ...
class CoordsRelativeToFloor:
    """
    Fortran routine coords_relative_to_floor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def phi(self) -> float | None:
        ...
    @property
    def psi(self) -> float | None:
        ...
    @property
    def theta(self) -> float | None:
        ...
class CosOne:
    """
    Fortran routine cos_one return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cos1(self) -> float:
        ...
class Cosc:
    """
    Fortran routine cosc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class Coulombfun:
    """
    Fortran routine coulombfun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def gam(self) -> float:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def u(self) -> float:
        ...
    @property
    def v(self) -> float:
        ...
    @property
    def w(self) -> float:
        ...
class CreateConcatenatedWall3d:
    """
    Fortran routine create_concatenated_wall3d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
class CreateElementSlice:
    """
    Fortran routine create_element_slice return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def sliced_ele(self) -> EleStruct:
        ...
class CreateGirder:
    """
    Fortran routine create_girder return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class CreatePlanarWigglerModel:
    """
    Fortran routine create_planar_wiggler_model return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def lat(self) -> LatStruct:
        ...
class CylindricalMapStruct:
    """
    Fortran struct: cylindrical_map_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dz(self) -> float:
        ...
    @dz.setter
    def dz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ele_anchor_pt(self) -> int:
        ...
    @ele_anchor_pt.setter
    def ele_anchor_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def field_scale(self) -> float:
        ...
    @field_scale.setter
    def field_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def harmonic(self) -> int:
        ...
    @harmonic.setter
    def harmonic(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def m(self) -> int:
        ...
    @m.setter
    def m(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def master_parameter(self) -> int:
        ...
    @master_parameter.setter
    def master_parameter(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def phi0_fieldmap(self) -> float:
        ...
    @phi0_fieldmap.setter
    def phi0_fieldmap(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ptr(self) -> _pybmad.CylindricalMapTermStruct | None:
        ...
    @ptr.setter
    def ptr(self, arg1: CylindricalMapTermStruct) -> None:
        ...
    @property
    def r0(self) -> ...:
        ...
    @property
    def theta0_azimuth(self) -> float:
        ...
    @theta0_azimuth.setter
    def theta0_azimuth(self, arg1: typing.SupportsFloat) -> None:
        ...
class CylindricalMapStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CylindricalMapStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CylindricalMapStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> CylindricalMapStructArray1D:
        ...
class CylindricalMapStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CylindricalMapStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CylindricalMapStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CylindricalMapTerm1Struct:
    """
    Fortran struct: cylindrical_map_term1_struct
    """
    b_coef: complex
    e_coef: complex
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class CylindricalMapTerm1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CylindricalMapTerm1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CylindricalMapTerm1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> CylindricalMapTerm1StructArray1D:
        ...
class CylindricalMapTerm1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> CylindricalMapTerm1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[CylindricalMapTerm1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class CylindricalMapTermStruct:
    """
    Fortran struct: cylindrical_map_term_struct
    """
    file: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def n_link(self) -> int:
        ...
    @n_link.setter
    def n_link(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def term(self) -> CylindricalMapTerm1StructArray1D:
        ...
class DampingMatrixD:
    """
    Fortran routine damping_matrix_d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def B0(self) -> float:
        ...
    @property
    def B1(self) -> float:
        ...
    @property
    def delta(self) -> float:
        ...
    @property
    def g_tot(self) -> float:
        ...
    @property
    def gamma(self) -> float:
        ...
    @property
    def species(self) -> int:
        ...
class DateAndTimeStamp:
    """
    Fortran routine date_and_time_stamp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def include_zone(self) -> bool | None:
        ...
    @property
    def numeric_month(self) -> bool | None:
        ...
    @property
    def string(self) -> str:
        ...
class DefaultTrackingSpecies:
    """
    Fortran routine default_tracking_species return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def species(self) -> int:
        ...
class Detab:
    """
    Fortran routine detab return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class DiffractionPlateOrMaskHitSpot:
    """
    Fortran routine diffraction_plate_or_mask_hit_spot return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_section(self) -> int:
        ...
class DiffusionMatrixB:
    """
    Fortran routine diffusion_matrix_b return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def g_tot(self) -> float:
        ...
    @property
    def gamma(self) -> float:
        ...
    @property
    def species(self) -> int:
        ...
class DisplaySizeAndResolution:
    """
    Fortran routine display_size_and_resolution return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_screen(self) -> int:
        ...
    @property
    def x_res(self) -> float:
        ...
    @property
    def x_size(self) -> float:
        ...
    @property
    def y_res(self) -> float:
        ...
    @property
    def y_size(self) -> float:
        ...
class DistanceToAperture:
    """
    Fortran routine distance_to_aperture return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dist(self) -> float:
        ...
    @property
    def no_aperture_here(self) -> bool:
        ...
class DjBessel:
    """
    Fortran routine dj_bessel return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arg(self) -> float:
        ...
    @property
    def dj_bes(self) -> float:
        ...
    @property
    def m(self) -> int:
        ...
class DjbHash:
    """
    Fortran routine djb_hash return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def hash(self) -> int:
        ...
    @property
    def old_hash(self) -> int | None:
        ...
    @property
    def str(self) -> str:
        ...
class DjbStrHash:
    """
    Fortran routine djb_str_hash return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def hash_str(self) -> str:
        ...
    @property
    def in_str(self) -> str:
        ...
class DowncaseString:
    """
    Fortran routine downcase_string return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def string(self) -> str:
        ...
class DpcGivenDe:
    """
    Fortran routine dpc_given_de return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dE(self) -> float:
        ...
    @property
    def dpc(self) -> float:
        ...
    @property
    def mass(self) -> float:
        ...
    @property
    def pc_old(self) -> float:
        ...
class EAccelField:
    """
    Fortran routine e_accel_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def field(self) -> float:
        ...
class EigenDecomp6mat:
    """
    Fortran routine eigen_decomp_6mat return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def eval(self) -> typing.Annotated[list[complex], "FixedSize(6)"]:
        ...
    @property
    def evec(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def tunes(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class EleAttribute(enum.IntEnum):
    ANGLE: typing.ClassVar[EleAttribute]  # value = <EleAttribute.ANGLE: 33>
    B3_GRADIENT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.B3_GRADIENT: 48>
    BL_HKICK: typing.ClassVar[EleAttribute]  # value = <EleAttribute.BL_HKICK: 41>
    BL_KICK: typing.ClassVar[EleAttribute]  # value = <EleAttribute.BL_KICK: 43>
    BL_VKICK: typing.ClassVar[EleAttribute]  # value = <EleAttribute.BL_VKICK: 42>
    BS_FIELD: typing.ClassVar[EleAttribute]  # value = <EleAttribute.BS_FIELD: 49>
    CHECK_SUM: typing.ClassVar[EleAttribute]  # value = <EleAttribute.CHECK_SUM: 75>
    CMAT_12: typing.ClassVar[EleAttribute]  # value = <EleAttribute.CMAT_12: 30>
    CMAT_21: typing.ClassVar[EleAttribute]  # value = <EleAttribute.CMAT_21: 31>
    CMAT_22: typing.ClassVar[EleAttribute]  # value = <EleAttribute.CMAT_22: 32>
    CSR_DS_STEP: typing.ClassVar[EleAttribute]  # value = <EleAttribute.CSR_DS_STEP: 68>
    D1_THICKNESS: typing.ClassVar[EleAttribute]  # value = <EleAttribute.D1_THICKNESS: 20>
    DARWIN_WIDTH_PI: typing.ClassVar[EleAttribute]  # value = <EleAttribute.DARWIN_WIDTH_PI: 12>
    DELTA_E_REF: typing.ClassVar[EleAttribute]  # value = <EleAttribute.DELTA_E_REF: 8>
    DELTA_REF_TIME: typing.ClassVar[EleAttribute]  # value = <EleAttribute.DELTA_REF_TIME: 50>
    DG: typing.ClassVar[EleAttribute]  # value = <EleAttribute.DG: 7>
    DISPATCH: typing.ClassVar[EleAttribute]  # value = <EleAttribute.DISPATCH: 63>
    DS_STEP: typing.ClassVar[EleAttribute]  # value = <EleAttribute.DS_STEP: 67>
    ETAP_X_OUT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.ETAP_X_OUT: 27>
    ETAP_Y_OUT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.ETAP_Y_OUT: 28>
    ETA_Y_OUT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.ETA_Y_OUT: 26>
    E_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.E_TOT: 54>
    E_TOT_START: typing.ClassVar[EleAttribute]  # value = <EleAttribute.E_TOT_START: 52>
    FB1: typing.ClassVar[EleAttribute]  # value = <EleAttribute.FB1: 21>
    FB2: typing.ClassVar[EleAttribute]  # value = <EleAttribute.FB2: 22>
    FQ2: typing.ClassVar[EleAttribute]  # value = <EleAttribute.FQ2: 24>
    FRINGE_AT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.FRINGE_AT: 11>
    FRINGE_TYPE: typing.ClassVar[EleAttribute]  # value = <EleAttribute.FRINGE_TYPE: 10>
    GEOMETRY: typing.ClassVar[EleAttribute]  # value = <EleAttribute.GEOMETRY: 47>
    GRADIENT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.GRADIENT: 6>
    GRAZE_ANGLE: typing.ClassVar[EleAttribute]  # value = <EleAttribute.GRAZE_ANGLE: 5>
    HKICK: typing.ClassVar[EleAttribute]  # value = <EleAttribute.HKICK: 39>
    K1: typing.ClassVar[EleAttribute]  # value = <EleAttribute.K1: 4>
    L: typing.ClassVar[EleAttribute]  # value = <EleAttribute.L: 1>
    LATTICE_TYPE: typing.ClassVar[EleAttribute]  # value = <EleAttribute.LATTICE_TYPE: 45>
    LIVE_BRANCH: typing.ClassVar[EleAttribute]  # value = <EleAttribute.LIVE_BRANCH: 46>
    LORD_PAD1: typing.ClassVar[EleAttribute]  # value = <EleAttribute.LORD_PAD1: 69>
    LORD_PAD2: typing.ClassVar[EleAttribute]  # value = <EleAttribute.LORD_PAD2: 70>
    MULTIPASS_REF_ENERGY: typing.ClassVar[EleAttribute]  # value = <EleAttribute.MULTIPASS_REF_ENERGY: 62>
    NUM_STEPS: typing.ClassVar[EleAttribute]  # value = <EleAttribute.NUM_STEPS: 66>
    P0C: typing.ClassVar[EleAttribute]  # value = <EleAttribute.P0C: 53>
    P0C_START: typing.ClassVar[EleAttribute]  # value = <EleAttribute.P0C_START: 51>
    PHI0_ERR: typing.ClassVar[EleAttribute]  # value = <EleAttribute.PHI0_ERR: 25>
    PHOTON_TYPE: typing.ClassVar[EleAttribute]  # value = <EleAttribute.PHOTON_TYPE: 44>
    REF_TILT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.REF_TILT: 3>
    REF_TILT_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.REF_TILT_TOT: 61>
    REF_TIME_START: typing.ClassVar[EleAttribute]  # value = <EleAttribute.REF_TIME_START: 64>
    RHO: typing.ClassVar[EleAttribute]  # value = <EleAttribute.RHO: 9>
    SIG_E: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SIG_E: 19>
    SIG_VX: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SIG_VX: 17>
    SIG_VY: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SIG_VY: 18>
    SIG_X: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SIG_X: 14>
    SIG_Y: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SIG_Y: 15>
    SIG_Z: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SIG_Z: 16>
    SPIN_FRINGE_ON: typing.ClassVar[EleAttribute]  # value = <EleAttribute.SPIN_FRINGE_ON: 13>
    THICKNESS: typing.ClassVar[EleAttribute]  # value = <EleAttribute.THICKNESS: 65>
    TILT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.TILT: 2>
    TILT_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.TILT_TOT: 60>
    UPSTREAM_COORD_DIR: typing.ClassVar[EleAttribute]  # value = <EleAttribute.UPSTREAM_COORD_DIR: 29>
    VKICK: typing.ClassVar[EleAttribute]  # value = <EleAttribute.VKICK: 40>
    X1_LIMIT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.X1_LIMIT: 71>
    X2_LIMIT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.X2_LIMIT: 72>
    X_OFFSET: typing.ClassVar[EleAttribute]  # value = <EleAttribute.X_OFFSET: 36>
    X_OFFSET_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.X_OFFSET_TOT: 57>
    X_PITCH: typing.ClassVar[EleAttribute]  # value = <EleAttribute.X_PITCH: 34>
    X_PITCH_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.X_PITCH_TOT: 55>
    Y1_LIMIT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y1_LIMIT: 73>
    Y2_LIMIT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y2_LIMIT: 74>
    Y_OFFSET: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y_OFFSET: 37>
    Y_OFFSET_CALIB: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y_OFFSET_CALIB: 23>
    Y_OFFSET_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y_OFFSET_TOT: 58>
    Y_PITCH: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y_PITCH: 35>
    Y_PITCH_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Y_PITCH_TOT: 56>
    Z_OFFSET: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Z_OFFSET: 38>
    Z_OFFSET_TOT: typing.ClassVar[EleAttribute]  # value = <EleAttribute.Z_OFFSET_TOT: 59>
    @classmethod
    def __new__(cls, value):
        ...
    def __format__(self, format_spec):
        """
        Convert to a string according to format_spec.
        """
class EleFullName:
    """
    Fortran routine ele_full_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class EleHasConstantDsDtRef:
    """
    Fortran routine ele_has_constant_ds_dt_ref return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_const(self) -> bool:
        ...
class EleHasNonzeroKick:
    """
    Fortran routine ele_has_nonzero_kick return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele(self) -> EleStruct:
        ...
    @property
    def has_kick(self) -> bool:
        ...
class EleHasNonzeroOffset:
    """
    Fortran routine ele_has_nonzero_offset return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def has_offset(self) -> bool:
        ...
class EleKey(enum.IntEnum):
    AB_MULTIPOLE: typing.ClassVar[EleKey]  # value = <EleKey.AB_MULTIPOLE: 22>
    AC_KICKER: typing.ClassVar[EleKey]  # value = <EleKey.AC_KICKER: 58>
    BEAMBEAM: typing.ClassVar[EleKey]  # value = <EleKey.BEAMBEAM: 11>
    BEGINNING_ELE: typing.ClassVar[EleKey]  # value = <EleKey.BEGINNING_ELE: 28>
    CAPILLARY: typing.ClassVar[EleKey]  # value = <EleKey.CAPILLARY: 45>
    CONVERTER: typing.ClassVar[EleKey]  # value = <EleKey.CONVERTER: 38>
    CRAB_CAVITY: typing.ClassVar[EleKey]  # value = <EleKey.CRAB_CAVITY: 61>
    CRYSTAL: typing.ClassVar[EleKey]  # value = <EleKey.CRYSTAL: 43>
    CUSTOM: typing.ClassVar[EleKey]  # value = <EleKey.CUSTOM: 7>
    DEF_BMAD_COM: typing.ClassVar[EleKey]  # value = <EleKey.DEF_BMAD_COM: 20>
    DEF_LINE: typing.ClassVar[EleKey]  # value = <EleKey.DEF_LINE: 29>
    DEF_MAD_BEAM: typing.ClassVar[EleKey]  # value = <EleKey.DEF_MAD_BEAM: 21>
    DEF_PARAMETER: typing.ClassVar[EleKey]  # value = <EleKey.DEF_PARAMETER: 26>
    DEF_PARTICLE_START: typing.ClassVar[EleKey]  # value = <EleKey.DEF_PARTICLE_START: 39>
    DEF_PTC_COM: typing.ClassVar[EleKey]  # value = <EleKey.DEF_PTC_COM: 63>
    DEF_SPACE_CHARGE_COM: typing.ClassVar[EleKey]  # value = <EleKey.DEF_SPACE_CHARGE_COM: 60>
    DETECTOR: typing.ClassVar[EleKey]  # value = <EleKey.DETECTOR: 55>
    DIFFRACTION_PLATE: typing.ClassVar[EleKey]  # value = <EleKey.DIFFRACTION_PLATE: 52>
    DRIFT: typing.ClassVar[EleKey]  # value = <EleKey.DRIFT: 1>
    ECOLLIMATOR: typing.ClassVar[EleKey]  # value = <EleKey.ECOLLIMATOR: 36>
    ELSEPARATOR: typing.ClassVar[EleKey]  # value = <EleKey.ELSEPARATOR: 10>
    EM_FIELD: typing.ClassVar[EleKey]  # value = <EleKey.EM_FIELD: 48>
    E_GUN: typing.ClassVar[EleKey]  # value = <EleKey.E_GUN: 47>
    FEEDBACK: typing.ClassVar[EleKey]  # value = <EleKey.FEEDBACK: 69>
    FIDUCIAL: typing.ClassVar[EleKey]  # value = <EleKey.FIDUCIAL: 50>
    FIXER: typing.ClassVar[EleKey]  # value = <EleKey.FIXER: 70>
    FLOOR_SHIFT: typing.ClassVar[EleKey]  # value = <EleKey.FLOOR_SHIFT: 49>
    FOIL: typing.ClassVar[EleKey]  # value = <EleKey.FOIL: 66>
    FORK: typing.ClassVar[EleKey]  # value = <EleKey.FORK: 41>
    GIRDER: typing.ClassVar[EleKey]  # value = <EleKey.GIRDER: 37>
    GKICKER: typing.ClassVar[EleKey]  # value = <EleKey.GKICKER: 65>
    GROUP: typing.ClassVar[EleKey]  # value = <EleKey.GROUP: 4>
    HKICKER: typing.ClassVar[EleKey]  # value = <EleKey.HKICKER: 33>
    HYBRID: typing.ClassVar[EleKey]  # value = <EleKey.HYBRID: 16>
    INSTRUMENT: typing.ClassVar[EleKey]  # value = <EleKey.INSTRUMENT: 32>
    KICKER: typing.ClassVar[EleKey]  # value = <EleKey.KICKER: 15>
    LCAVITY: typing.ClassVar[EleKey]  # value = <EleKey.LCAVITY: 25>
    LENS: typing.ClassVar[EleKey]  # value = <EleKey.LENS: 59>
    MARKER: typing.ClassVar[EleKey]  # value = <EleKey.MARKER: 14>
    MASK: typing.ClassVar[EleKey]  # value = <EleKey.MASK: 57>
    MATCH: typing.ClassVar[EleKey]  # value = <EleKey.MATCH: 30>
    MIRROR: typing.ClassVar[EleKey]  # value = <EleKey.MIRROR: 42>
    MONITOR: typing.ClassVar[EleKey]  # value = <EleKey.MONITOR: 31>
    MULTILAYER_MIRROR: typing.ClassVar[EleKey]  # value = <EleKey.MULTILAYER_MIRROR: 46>
    MULTIPOLE: typing.ClassVar[EleKey]  # value = <EleKey.MULTIPOLE: 19>
    NULL_ELE: typing.ClassVar[EleKey]  # value = <EleKey.NULL_ELE: 27>
    OCTUPOLE: typing.ClassVar[EleKey]  # value = <EleKey.OCTUPOLE: 17>
    OVERLAY: typing.ClassVar[EleKey]  # value = <EleKey.OVERLAY: 6>
    PATCH: typing.ClassVar[EleKey]  # value = <EleKey.PATCH: 24>
    PHOTON_FORK: typing.ClassVar[EleKey]  # value = <EleKey.PHOTON_FORK: 40>
    PHOTON_INIT: typing.ClassVar[EleKey]  # value = <EleKey.PHOTON_INIT: 53>
    PICKUP: typing.ClassVar[EleKey]  # value = <EleKey.PICKUP: 68>
    PIPE: typing.ClassVar[EleKey]  # value = <EleKey.PIPE: 44>
    QUADRUPOLE: typing.ClassVar[EleKey]  # value = <EleKey.QUADRUPOLE: 3>
    RAMPER: typing.ClassVar[EleKey]  # value = <EleKey.RAMPER: 62>
    RBEND: typing.ClassVar[EleKey]  # value = <EleKey.RBEND: 18>
    RCOLLIMATOR: typing.ClassVar[EleKey]  # value = <EleKey.RCOLLIMATOR: 35>
    RFCAVITY: typing.ClassVar[EleKey]  # value = <EleKey.RFCAVITY: 9>
    RF_BEND: typing.ClassVar[EleKey]  # value = <EleKey.RF_BEND: 64>
    SAD_MULT: typing.ClassVar[EleKey]  # value = <EleKey.SAD_MULT: 56>
    SAMPLE: typing.ClassVar[EleKey]  # value = <EleKey.SAMPLE: 54>
    SBEND: typing.ClassVar[EleKey]  # value = <EleKey.SBEND: 2>
    SEXTUPOLE: typing.ClassVar[EleKey]  # value = <EleKey.SEXTUPOLE: 5>
    SOLENOID: typing.ClassVar[EleKey]  # value = <EleKey.SOLENOID: 23>
    SOL_QUAD: typing.ClassVar[EleKey]  # value = <EleKey.SOL_QUAD: 13>
    TAYLOR: typing.ClassVar[EleKey]  # value = <EleKey.TAYLOR: 8>
    THICK_MULTIPOLE: typing.ClassVar[EleKey]  # value = <EleKey.THICK_MULTIPOLE: 67>
    UNDULATOR: typing.ClassVar[EleKey]  # value = <EleKey.UNDULATOR: 51>
    VKICKER: typing.ClassVar[EleKey]  # value = <EleKey.VKICKER: 34>
    WIGGLER: typing.ClassVar[EleKey]  # value = <EleKey.WIGGLER: 12>
    @classmethod
    def __new__(cls, value):
        ...
    def __format__(self, format_spec):
        """
        Convert to a string according to format_spec.
        """
class EleLocName:
    """
    Fortran routine ele_loc_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class EleMisalignmentLSCalc:
    """
    Fortran routine ele_misalignment_l_s_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def L_mis(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
    @property
    def S_mis(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
        ...
class EleNametableIndex:
    """
    Fortran routine ele_nametable_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_nt(self) -> int:
        ...
class ElePointerStruct:
    """
    Fortran struct: ele_pointer_struct
    """
    loc: LatEleLocStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele(self) -> _pybmad.EleStruct | None:
        ...
    @ele.setter
    def ele(self, arg1: EleStruct) -> None:
        ...
    @property
    def id(self) -> int:
        ...
    @id.setter
    def id(self, arg1: typing.SupportsInt) -> None:
        ...
class ElePointerStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ElePointerStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ElePointerStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ElePointerStructArray1D:
        ...
class ElePointerStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ElePointerStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ElePointerStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class EleRfStepIndex:
    """
    Fortran routine ele_rf_step_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_step(self) -> int:
        ...
class EleStruct:
    """
    Fortran struct: ele_struct
    """
    a: TwissStruct
    alias: str
    b: TwissStruct
    bmad_logic: bool
    bookkeeping_state: BookkeepingStateStruct
    component_name: str
    descrip: str
    field_master: bool
    floor: FloorPositionStruct
    is_on: bool
    logic: bool
    map_ref_orb_in: CoordStruct
    map_ref_orb_out: CoordStruct
    mode_flip: bool
    multipoles_on: bool
    name: str
    offset_moves_aperture: bool
    scale_multipoles: bool
    select: bool
    symplectify: bool
    taylor_map_includes_offsets: bool
    time_ref_orb_in: CoordStruct
    time_ref_orb_out: CoordStruct
    type: str
    x: XyDispStruct
    y: XyDispStruct
    z: TwissStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a_pole(self) -> ...:
        ...
    @property
    def a_pole_elec(self) -> ...:
        ...
    @property
    def ac_kick(self) -> _pybmad.AcKickerStruct | None:
        ...
    @ac_kick.setter
    def ac_kick(self, arg1: AcKickerStruct) -> None:
        ...
    @property
    def aperture_at(self) -> int:
        ...
    @aperture_at.setter
    def aperture_at(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def aperture_type(self) -> int:
        ...
    @aperture_type.setter
    def aperture_type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def b_pole(self) -> ...:
        ...
    @property
    def b_pole_elec(self) -> ...:
        ...
    @property
    def branch(self) -> _pybmad.BranchStruct | None:
        ...
    @branch.setter
    def branch(self, arg1: BranchStruct) -> None:
        ...
    @property
    def c_mat(self) -> ...:
        ...
    @property
    def cartesian_map(self) -> CartesianMapStructArray1D:
        ...
    @property
    def control(self) -> _pybmad.ControllerStruct | None:
        ...
    @control.setter
    def control(self, arg1: ControllerStruct) -> None:
        ...
    @property
    def csr_method(self) -> int:
        ...
    @csr_method.setter
    def csr_method(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def custom(self) -> ...:
        ...
    @property
    def cylindrical_map(self) -> CylindricalMapStructArray1D:
        ...
    @property
    def dc_mat_dpz(self) -> ...:
        ...
    @property
    def field_calc(self) -> int:
        ...
    @field_calc.setter
    def field_calc(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def gamma_c(self) -> float:
        ...
    @gamma_c.setter
    def gamma_c(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def gen_grad_map(self) -> GenGradMapStructArray1D:
        ...
    @property
    def grid_field(self) -> GridFieldStructArray1D:
        ...
    @property
    def high_energy_space_charge(self) -> _pybmad.HighEnergySpaceChargeStruct | None:
        ...
    @high_energy_space_charge.setter
    def high_energy_space_charge(self, arg1: HighEnergySpaceChargeStruct) -> None:
        ...
    @property
    def ic1_lord(self) -> int:
        ...
    @ic1_lord.setter
    def ic1_lord(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix1_slave(self) -> int:
        ...
    @ix1_slave.setter
    def ix1_slave(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_pointer(self) -> int:
        ...
    @ix_pointer.setter
    def ix_pointer(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ixx(self) -> int:
        ...
    @ixx.setter
    def ixx(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def iyy(self) -> int:
        ...
    @iyy.setter
    def iyy(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def izz(self) -> int:
        ...
    @izz.setter
    def izz(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def key(self) -> int:
        ...
    @key.setter
    def key(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def lord(self) -> _pybmad.EleStruct | None:
        ...
    @lord.setter
    def lord(self, arg1: EleStruct) -> None:
        ...
    @property
    def lord_status(self) -> int:
        ...
    @lord_status.setter
    def lord_status(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def mat6(self) -> ...:
        ...
    @property
    def mat6_calc_method(self) -> int:
        ...
    @mat6_calc_method.setter
    def mat6_calc_method(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def mode3(self) -> _pybmad.Mode3Struct | None:
        ...
    @mode3.setter
    def mode3(self, arg1: Mode3Struct) -> None:
        ...
    @property
    def n_lord(self) -> int:
        ...
    @n_lord.setter
    def n_lord(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_lord_field(self) -> int:
        ...
    @n_lord_field.setter
    def n_lord_field(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_lord_ramper(self) -> int:
        ...
    @n_lord_ramper.setter
    def n_lord_ramper(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_slave(self) -> int:
        ...
    @n_slave.setter
    def n_slave(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_slave_field(self) -> int:
        ...
    @n_slave_field.setter
    def n_slave_field(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def old_value(self) -> ...:
        ...
    @property
    def orientation(self) -> int:
        ...
    @orientation.setter
    def orientation(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def photon(self) -> _pybmad.PhotonElementStruct | None:
        ...
    @photon.setter
    def photon(self, arg1: PhotonElementStruct) -> None:
        ...
    @property
    def ptc_integration_type(self) -> int:
        ...
    @ptc_integration_type.setter
    def ptc_integration_type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def r(self) -> ...:
        ...
    @property
    def rad_map(self) -> _pybmad.RadMapEleStruct | None:
        ...
    @rad_map.setter
    def rad_map(self, arg1: RadMapEleStruct) -> None:
        ...
    @property
    def ref_species(self) -> int:
        ...
    @ref_species.setter
    def ref_species(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ref_time(self) -> float:
        ...
    @ref_time.setter
    def ref_time(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rf(self) -> _pybmad.RfEleStruct | None:
        ...
    @rf.setter
    def rf(self, arg1: RfEleStruct) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s_start(self) -> float:
        ...
    @s_start.setter
    def s_start(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def slave_status(self) -> int:
        ...
    @slave_status.setter
    def slave_status(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def space_charge_method(self) -> int:
        ...
    @space_charge_method.setter
    def space_charge_method(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def spin_q(self) -> ...:
        ...
    @property
    def spin_taylor(self) -> TaylorStructArray1D:
        ...
    @property
    def spin_taylor_ref_orb_in(self) -> ...:
        ...
    @property
    def spin_tracking_method(self) -> int:
        ...
    @spin_tracking_method.setter
    def spin_tracking_method(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def sub_key(self) -> int:
        ...
    @sub_key.setter
    def sub_key(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def taylor(self) -> TaylorStructArray1D:
        ...
    @property
    def tracking_method(self) -> int:
        ...
    @tracking_method.setter
    def tracking_method(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def value(self) -> ...:
        ...
    @property
    def vec0(self) -> ...:
        ...
    @property
    def wake(self) -> _pybmad.WakeStruct | None:
        ...
    @wake.setter
    def wake(self, arg1: WakeStruct) -> None:
        ...
    @property
    def wall3d(self) -> Wall3DStructArray1D:
        ...
class EleStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EleStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EleStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> EleStructArray1D:
        ...
class EleStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EleStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EleStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class EleToPtcMagneticBnAn:
    """
    Fortran routine ele_to_ptc_magnetic_bn_an return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def an(self) -> RealAlloc1D:
        ...
    @property
    def bn(self) -> RealAlloc1D:
        ...
    @property
    def n_max(self) -> int:
        ...
class EleToTaylor:
    """
    Fortran routine ele_to_taylor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def orbital_taylor(self) -> TaylorStructArray1D:
        ...
    @property
    def spin_taylor(self) -> TaylorStructArray1D:
        ...
class EleUniqueName:
    """
    Fortran routine ele_unique_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def unique_name(self) -> str:
        ...
class EleValueHasChanged:
    """
    Fortran routine ele_value_has_changed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def has_changed(self) -> bool:
        ...
class ElecMultipoleField:
    """
    Fortran routine elec_multipole_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def Ex(self) -> float:
        ...
    @property
    def Ey(self) -> float:
        ...
    @property
    def compute_dE(self) -> bool:
        ...
    @property
    def dE(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"] | None:
        ...
class ElementAtSBranch:
    """
    Fortran routine element_at_s_branch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def choose_max(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @property
    def print_err(self) -> bool | None:
        ...
    @property
    def s(self) -> float:
        ...
    @property
    def s_eff(self) -> float | None:
        ...
class ElementAtSLat:
    """
    Fortran routine element_at_s_lat return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def choose_max(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
    @property
    def ix_branch(self) -> int | None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @property
    def print_err(self) -> bool | None:
        ...
    @property
    def s(self) -> float:
        ...
    @property
    def s_eff(self) -> float | None:
        ...
class EllipseBeamInitStruct:
    """
    Fortran struct: ellipse_beam_init_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def n_ellipse(self) -> int:
        ...
    @n_ellipse.setter
    def n_ellipse(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def part_per_ellipse(self) -> int:
        ...
    @part_per_ellipse.setter
    def part_per_ellipse(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def sigma_cutoff(self) -> float:
        ...
    @sigma_cutoff.setter
    def sigma_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
class EllipseBeamInitStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EllipseBeamInitStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EllipseBeamInitStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> EllipseBeamInitStructArray1D:
        ...
class EllipseBeamInitStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EllipseBeamInitStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EllipseBeamInitStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class EmFieldCalc:
    """
    Fortran routine em_field_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def field(self) -> EmFieldStruct:
        ...
class EmFieldDerivatives:
    """
    Fortran routine em_field_derivatives return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dfield(self) -> EmFieldStruct:
        ...
    @property
    def grid_allow_s_out_of_bounds(self) -> bool | None:
        ...
    @property
    def local_ref_frame(self) -> bool:
        ...
    @property
    def rf_time(self) -> float | None:
        ...
    @property
    def s_pos(self) -> float:
        ...
class EmFieldStruct:
    """
    Fortran struct: em_field_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def A(self) -> ...:
        ...
    @property
    def B(self) -> ...:
        ...
    @property
    def E(self) -> ...:
        ...
    @property
    def dB(self) -> ...:
        ...
    @property
    def dE(self) -> ...:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi_B(self) -> float:
        ...
    @phi_B.setter
    def phi_B(self, arg1: typing.SupportsFloat) -> None:
        ...
class EmFieldStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EmFieldStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EmFieldStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> EmFieldStructArray1D:
        ...
class EmFieldStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EmFieldStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EmFieldStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class EmTaylorStruct:
    """
    Fortran struct: em_taylor_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ref(self) -> float:
        ...
    @ref.setter
    def ref(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def term(self) -> EmTaylorTermStructArray1D:
        ...
class EmTaylorStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EmTaylorStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EmTaylorStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> EmTaylorStructArray1D:
        ...
class EmTaylorStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EmTaylorStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EmTaylorStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class EmTaylorTermStruct:
    """
    Fortran struct: em_taylor_term_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def coef(self) -> float:
        ...
    @coef.setter
    def coef(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def expn(self) -> ...:
        ...
class EmTaylorTermStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EmTaylorTermStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EmTaylorTermStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> EmTaylorTermStructArray1D:
        ...
class EmTaylorTermStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> EmTaylorTermStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[EmTaylorTermStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Emit6d:
    """
    Fortran routine emit_6d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def mode(self) -> NormalModesStruct:
        ...
    @property
    def rad_int_by_ele(self) -> RadIntAllEleStruct:
        ...
    @property
    def sigma_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
class EnteringElement:
    """
    Fortran routine entering_element return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_entering(self) -> bool:
        ...
class EnvelopeRadintsIbs:
    """
    Fortran routine envelope_radints_ibs return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def alpha(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
    @property
    def emit(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class EqAcKicker:
    """
    Fortran routine eq_ac_kicker return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqAcKickerFreq:
    """
    Fortran routine eq_ac_kicker_freq return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqAcKickerTime:
    """
    Fortran routine eq_ac_kicker_time return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqAnormalMode:
    """
    Fortran routine eq_anormal_mode return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqApertureParam:
    """
    Fortran routine eq_aperture_param return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqAperturePoint:
    """
    Fortran routine eq_aperture_point return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqApertureScan:
    """
    Fortran routine eq_aperture_scan return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBeam:
    """
    Fortran routine eq_beam return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBeamInit:
    """
    Fortran routine eq_beam_init return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBmadCommon:
    """
    Fortran routine eq_bmad_common return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBookkeepingState:
    """
    Fortran routine eq_bookkeeping_state return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBpmPhaseCoupling:
    """
    Fortran routine eq_bpm_phase_coupling return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBranch:
    """
    Fortran routine eq_branch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBunch:
    """
    Fortran routine eq_bunch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqBunchParams:
    """
    Fortran routine eq_bunch_params return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCartesianMap:
    """
    Fortran routine eq_cartesian_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCartesianMapTerm:
    """
    Fortran routine eq_cartesian_map_term return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCartesianMapTerm1:
    """
    Fortran routine eq_cartesian_map_term1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqComplexTaylor:
    """
    Fortran routine eq_complex_taylor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqComplexTaylorTerm:
    """
    Fortran routine eq_complex_taylor_term return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqControl:
    """
    Fortran routine eq_control return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqControlRamp1:
    """
    Fortran routine eq_control_ramp1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqControlVar1:
    """
    Fortran routine eq_control_var1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqController:
    """
    Fortran routine eq_controller return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCoord:
    """
    Fortran routine eq_coord return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCoordArray:
    """
    Fortran routine eq_coord_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCylindricalMap:
    """
    Fortran routine eq_cylindrical_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCylindricalMapTerm:
    """
    Fortran routine eq_cylindrical_map_term return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqCylindricalMapTerm1:
    """
    Fortran routine eq_cylindrical_map_term1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqEle:
    """
    Fortran routine eq_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqEllipseBeamInit:
    """
    Fortran routine eq_ellipse_beam_init return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqEmField:
    """
    Fortran routine eq_em_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqEmTaylor:
    """
    Fortran routine eq_em_taylor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqEmTaylorTerm:
    """
    Fortran routine eq_em_taylor_term return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqExpressionAtom:
    """
    Fortran routine eq_expression_atom return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqFloorPosition:
    """
    Fortran routine eq_floor_position return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqGenGrad1:
    """
    Fortran routine eq_gen_grad1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqGenGradMap:
    """
    Fortran routine eq_gen_grad_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqGridBeamInit:
    """
    Fortran routine eq_grid_beam_init return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqGridField:
    """
    Fortran routine eq_grid_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqGridFieldPt:
    """
    Fortran routine eq_grid_field_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqGridFieldPt1:
    """
    Fortran routine eq_grid_field_pt1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqHighEnergySpaceCharge:
    """
    Fortran routine eq_high_energy_space_charge return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqInterval1Coef:
    """
    Fortran routine eq_interval1_coef return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqKvBeamInit:
    """
    Fortran routine eq_kv_beam_init return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqLat:
    """
    Fortran routine eq_lat return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqLatEleLoc:
    """
    Fortran routine eq_lat_ele_loc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqLatParam:
    """
    Fortran routine eq_lat_param return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqLinacNormalMode:
    """
    Fortran routine eq_linac_normal_mode return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqMode3:
    """
    Fortran routine eq_mode3 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqModeInfo:
    """
    Fortran routine eq_mode_info return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqNormalModes:
    """
    Fortran routine eq_normal_modes return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPhotonElement:
    """
    Fortran routine eq_photon_element return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPhotonMaterial:
    """
    Fortran routine eq_photon_material return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPhotonReflectSurface:
    """
    Fortran routine eq_photon_reflect_surface return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPhotonReflectTable:
    """
    Fortran routine eq_photon_reflect_table return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPhotonTarget:
    """
    Fortran routine eq_photon_target return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPixelDetec:
    """
    Fortran routine eq_pixel_detec return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPixelPt:
    """
    Fortran routine eq_pixel_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqPreTracker:
    """
    Fortran routine eq_pre_tracker return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqRadInt1:
    """
    Fortran routine eq_rad_int1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqRadIntAllEle:
    """
    Fortran routine eq_rad_int_all_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqRadIntBranch:
    """
    Fortran routine eq_rad_int_branch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqRadMap:
    """
    Fortran routine eq_rad_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqRadMapEle:
    """
    Fortran routine eq_rad_map_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqRamperLord:
    """
    Fortran routine eq_ramper_lord return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSpaceChargeCommon:
    """
    Fortran routine eq_space_charge_common return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSpinPolar:
    """
    Fortran routine eq_spin_polar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSpline:
    """
    Fortran routine eq_spline return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqStrongBeam:
    """
    Fortran routine eq_strong_beam return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceCurvature:
    """
    Fortran routine eq_surface_curvature return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceDisplacement:
    """
    Fortran routine eq_surface_displacement return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceDisplacementPt:
    """
    Fortran routine eq_surface_displacement_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceHMisalign:
    """
    Fortran routine eq_surface_h_misalign return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceHMisalignPt:
    """
    Fortran routine eq_surface_h_misalign_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceSegmented:
    """
    Fortran routine eq_surface_segmented return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqSurfaceSegmentedPt:
    """
    Fortran routine eq_surface_segmented_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqTargetPoint:
    """
    Fortran routine eq_target_point return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqTaylor:
    """
    Fortran routine eq_taylor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqTaylorTerm:
    """
    Fortran routine eq_taylor_term return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqTrack:
    """
    Fortran routine eq_track return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqTrackPoint:
    """
    Fortran routine eq_track_point return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqTwiss:
    """
    Fortran routine eq_twiss return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWake:
    """
    Fortran routine eq_wake return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWakeLr:
    """
    Fortran routine eq_wake_lr return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWakeLrMode:
    """
    Fortran routine eq_wake_lr_mode return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWakeSr:
    """
    Fortran routine eq_wake_sr return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWakeSrMode:
    """
    Fortran routine eq_wake_sr_mode return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWakeSrZLong:
    """
    Fortran routine eq_wake_sr_z_long return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWall3d:
    """
    Fortran routine eq_wall3d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWall3dSection:
    """
    Fortran routine eq_wall3d_section return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqWall3dVertex:
    """
    Fortran routine eq_wall3d_vertex return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqXyDisp:
    """
    Fortran routine eq_xy_disp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_eq(self) -> bool:
        ...
class EqualSignHere:
    """
    Fortran routine equal_sign_here return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def is_here(self) -> bool:
        ...
class EquivalentTaylorAttributes:
    """
    Fortran routine equivalent_taylor_attributes return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def equiv(self) -> bool:
        ...
class ErrExit:
    """
    Fortran routine err_exit return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_str(self) -> str | None:
        ...
class Etdiv:
    """
    Fortran routine etdiv return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def A(self) -> float:
        ...
    @property
    def B(self) -> float:
        ...
    @property
    def C(self) -> float:
        ...
    @property
    def D(self) -> float:
        ...
    @property
    def E(self) -> float:
        ...
    @property
    def F(self) -> float:
        ...
class EvaluateArrayIndex:
    """
    Fortran routine evaluate_array_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim2(self) -> str:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def this_index(self) -> int:
        ...
    @property
    def word2(self) -> str:
        ...
class EvaluateLogical:
    """
    Fortran routine evaluate_logical return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def iostat(self) -> int:
        ...
    @property
    def this_logic(self) -> bool:
        ...
class ExpectOneOf:
    """
    Fortran routine expect_one_of return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def is_ok(self) -> bool:
        ...
class ExpectThis:
    """
    Fortran routine expect_this return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def is_ok(self) -> bool:
        ...
class ExpressionAtomStruct:
    """
    Fortran struct: expression_atom_struct
    """
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def type(self) -> int:
        ...
    @type.setter
    def type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def value(self) -> float:
        ...
    @value.setter
    def value(self, arg1: typing.SupportsFloat) -> None:
        ...
class ExpressionAtomStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ExpressionAtomStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ExpressionAtomStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ExpressionAtomStructArray1D:
        ...
class ExpressionAtomStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ExpressionAtomStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ExpressionAtomStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ExpressionStackValue:
    """
    Fortran routine expression_stack_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def value(self) -> float:
        ...
class ExpressionStringToStack:
    """
    Fortran routine expression_string_to_stack return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def n_stack(self) -> int:
        ...
    @property
    def stack(self) -> ExpressionAtomStructAlloc1D:
        ...
class ExpressionStringToTree:
    """
    Fortran routine expression_string_to_tree return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_str(self) -> str:
        ...
class ExpressionTreeStruct:
    """
    Fortran struct: expression_tree_struct
    """
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def node(self) -> ...:
        ...
    @property
    def type(self) -> int:
        ...
    @type.setter
    def type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def value(self) -> float:
        ...
    @value.setter
    def value(self, arg1: typing.SupportsFloat) -> None:
        ...
class ExpressionTreeStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ExpressionTreeStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ExpressionTreeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ExpressionTreeStructArray1D:
        ...
class ExpressionTreeStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ExpressionTreeStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ExpressionTreeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class ExpressionValue:
    """
    Fortran routine expression_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def value(self) -> float:
        ...
class FCharArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[...]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: str) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[str]:
        ...
class Factorial:
    """
    Fortran routine factorial return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def fact(self) -> float:
        ...
    @property
    def n(self) -> int:
        ...
class FileDirectorizer:
    """
    Fortran routine file_directorizer return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def add_switch(self) -> bool:
        ...
    @property
    def directory(self) -> str:
        ...
    @property
    def in_file(self) -> str:
        ...
    @property
    def out_file(self) -> str:
        ...
class FileGet:
    """
    Fortran routine file_get return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dflt_file_name(self) -> str:
        ...
    @property
    def file_name(self) -> str:
        ...
    @property
    def string(self) -> str:
        ...
class FileGetOpen:
    """
    Fortran routine file_get_open return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dflt_file_name(self) -> str:
        ...
    @property
    def file_name(self) -> str:
        ...
    @property
    def file_unit(self) -> int:
        ...
    @property
    def readonly(self) -> bool:
        ...
    @property
    def string(self) -> str:
        ...
class FileSuffixer:
    """
    Fortran routine file_suffixer return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def add_switch(self) -> bool:
        ...
    @property
    def in_file_name(self) -> str:
        ...
    @property
    def out_file_name(self) -> str:
        ...
    @property
    def suffix(self) -> str:
        ...
class FindElementEnds:
    """
    Fortran routine find_element_ends return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele1(self) -> EleStruct:
        ...
    @property
    def ele2(self) -> EleStruct:
        ...
class FindLocationInt:
    """
    Fortran routine find_location_int return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_match(self) -> int:
        ...
    @property
    def value(self) -> int:
        ...
class FindLocationLogic:
    """
    Fortran routine find_location_logic return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_match(self) -> int:
        ...
    @property
    def value(self) -> bool:
        ...
class FindLocationReal:
    """
    Fortran routine find_location_real return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_match(self) -> int:
        ...
class FindMatchingFieldmap:
    """
    Fortran routine find_matching_fieldmap return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_field(self) -> int:
        ...
    @property
    def match_ele(self) -> EleStruct:
        ...
class Fixedwindowls:
    """
    Fortran routine fixedwindowls return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def z(self) -> float:
        ...
class FloorAnglesToWMat:
    """
    Fortran routine floor_angles_to_w_mat return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def w_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"] | None:
        ...
    @property
    def w_mat_inv(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"] | None:
        ...
class FloorPositionStruct:
    """
    Fortran struct: floor_position_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def psi(self) -> float:
        ...
    @psi.setter
    def psi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def r(self) -> ...:
        ...
    @property
    def theta(self) -> float:
        ...
    @theta.setter
    def theta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def w(self) -> ...:
        ...
class FloorWMatToAngles:
    """
    Fortran routine floor_w_mat_to_angles return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def phi(self) -> float:
        ...
    @property
    def psi(self) -> float:
        ...
    @property
    def theta(self) -> float:
        ...
class FormDigestedBmadFileName:
    """
    Fortran routine form_digested_bmad_file_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def digested_file(self) -> str:
        ...
    @property
    def full_lat_file(self) -> str:
        ...
class FourierAmplitude:
    """
    Fortran routine fourier_amplitude return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cos_amp(self) -> float:
        ...
    @property
    def dcos_amp(self) -> float:
        ...
    @property
    def dsin_amp(self) -> float:
        ...
    @property
    def sin_amp(self) -> float:
        ...
class FringeHere:
    """
    Fortran routine fringe_here return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_here(self) -> bool:
        ...
class GBendingStrengthFromEmField:
    """
    Fortran routine g_bending_strength_from_em_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dg(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"] | None:
        ...
    @property
    def g(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class GammaRef:
    """
    Fortran routine gamma_ref return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def gamma(self) -> float:
        ...
class GenCompleteElliptic:
    """
    Fortran routine gen_complete_elliptic return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def c(self) -> float:
        ...
    @property
    def err_tol(self) -> float | None:
        ...
    @property
    def kc(self) -> float:
        ...
    @property
    def p(self) -> float:
        ...
    @property
    def s(self) -> float:
        ...
    @property
    def value(self) -> float:
        ...
class GenGrad1Struct:
    """
    Fortran struct: gen_grad1_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def deriv(self) -> ...:
        ...
    @property
    def m(self) -> int:
        ...
    @m.setter
    def m(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_deriv_max(self) -> int:
        ...
    @n_deriv_max.setter
    def n_deriv_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def sincos(self) -> int:
        ...
    @sincos.setter
    def sincos(self, arg1: typing.SupportsInt) -> None:
        ...
class GenGrad1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GenGrad1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GenGrad1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> GenGrad1StructArray1D:
        ...
class GenGrad1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GenGrad1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GenGrad1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class GenGradField:
    """
    Fortran routine gen_grad_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def rho(self) -> float:
        ...
    @property
    def theta(self) -> float:
        ...
class GenGradMapStruct:
    """
    Fortran struct: gen_grad_map_struct
    """
    curved_ref_frame: bool
    file: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dz(self) -> float:
        ...
    @dz.setter
    def dz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ele_anchor_pt(self) -> int:
        ...
    @ele_anchor_pt.setter
    def ele_anchor_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def field_scale(self) -> float:
        ...
    @field_scale.setter
    def field_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def field_type(self) -> int:
        ...
    @field_type.setter
    def field_type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def gg(self) -> GenGrad1StructArray1D:
        ...
    @property
    def iz0(self) -> int:
        ...
    @iz0.setter
    def iz0(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def iz1(self) -> int:
        ...
    @iz1.setter
    def iz1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def master_parameter(self) -> int:
        ...
    @master_parameter.setter
    def master_parameter(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def r0(self) -> ...:
        ...
class GenGradMapStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GenGradMapStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GenGradMapStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> GenGradMapStructArray1D:
        ...
class GenGradMapStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GenGradMapStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GenGradMapStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class GetCalledFile:
    """
    Fortran routine get_called_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def call_file(self) -> str:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def err(self) -> bool:
        ...
class GetEmitFromSigmaMat:
    """
    Fortran routine get_emit_from_sigma_mat return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def normal(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class GetFileNumber:
    """
    Fortran routine get_file_number return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cnum_in(self) -> str:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def file_name(self) -> str:
        ...
    @property
    def num_out(self) -> int:
        ...
class GetFileTimeStamp:
    """
    Fortran routine get_file_time_stamp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def file(self) -> str:
        ...
    @property
    def time_stamp(self) -> str:
        ...
class GetSlaveList:
    """
    Fortran routine get_slave_list return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n_slave(self) -> int:
        ...
    @property
    def slaves(self) -> ElePointerStructAlloc1D:
        ...
class GptFieldGridScaling:
    """
    Fortran routine gpt_field_grid_scaling return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dimensions(self) -> int:
        ...
    @property
    def field_scale(self) -> float:
        ...
    @property
    def ref_time(self) -> float:
        ...
class GptMaxFieldReference:
    """
    Fortran routine gpt_max_field_reference return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def field_value(self) -> float:
        ...
class GptToParticleBunch:
    """
    Fortran routine gpt_to_particle_bunch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bunch(self) -> BunchStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class GradientShiftSrWake:
    """
    Fortran routine gradient_shift_sr_wake return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def grad_shift(self) -> float:
        ...
class GridBeamInitStruct:
    """
    Fortran struct: grid_beam_init_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def n_px(self) -> int:
        ...
    @n_px.setter
    def n_px(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_x(self) -> int:
        ...
    @n_x.setter
    def n_x(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def px_max(self) -> float:
        ...
    @px_max.setter
    def px_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def px_min(self) -> float:
        ...
    @px_min.setter
    def px_min(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x_max(self) -> float:
        ...
    @x_max.setter
    def x_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x_min(self) -> float:
        ...
    @x_min.setter
    def x_min(self, arg1: typing.SupportsFloat) -> None:
        ...
class GridBeamInitStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GridBeamInitStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GridBeamInitStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> GridBeamInitStructArray1D:
        ...
class GridBeamInitStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GridBeamInitStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GridBeamInitStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class GridFieldPt1Struct:
    """
    Fortran struct: grid_field_pt1_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def B(self) -> ...:
        ...
    @property
    def E(self) -> ...:
        ...
class GridFieldPt1StructArray3D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GridFieldPt1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GridFieldPt1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class GridFieldPtStruct:
    """
    Fortran struct: grid_field_pt_struct
    """
    file: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def n_link(self) -> int:
        ...
    @n_link.setter
    def n_link(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def pt(self) -> GridFieldPt1StructArray3D:
        ...
class GridFieldStruct:
    """
    Fortran struct: grid_field_struct
    """
    curved_ref_frame: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def bi_coef(self) -> BicubicCmplxCoefStructArray3D:
        ...
    @property
    def dr(self) -> ...:
        ...
    @property
    def ele_anchor_pt(self) -> int:
        ...
    @ele_anchor_pt.setter
    def ele_anchor_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def field_scale(self) -> float:
        ...
    @field_scale.setter
    def field_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def field_type(self) -> int:
        ...
    @field_type.setter
    def field_type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def geometry(self) -> int:
        ...
    @geometry.setter
    def geometry(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def harmonic(self) -> int:
        ...
    @harmonic.setter
    def harmonic(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def interpolation_order(self) -> int:
        ...
    @interpolation_order.setter
    def interpolation_order(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def master_parameter(self) -> int:
        ...
    @master_parameter.setter
    def master_parameter(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def phi0_fieldmap(self) -> float:
        ...
    @phi0_fieldmap.setter
    def phi0_fieldmap(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ptr(self) -> _pybmad.GridFieldPtStruct | None:
        ...
    @ptr.setter
    def ptr(self, arg1: GridFieldPtStruct) -> None:
        ...
    @property
    def r0(self) -> ...:
        ...
    @property
    def tri_coef(self) -> TricubicCmplxCoefStructArray3D:
        ...
class GridFieldStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GridFieldStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GridFieldStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> GridFieldStructArray1D:
        ...
class GridFieldStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> GridFieldStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[GridFieldStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Hanhan:
    """
    Fortran routine hanhan return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def N(self) -> int:
        ...
class HasAttribute:
    """
    Fortran routine has_attribute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib(self) -> str:
        ...
    @property
    def has_it(self) -> bool:
        ...
class Hdf5WriteBeam:
    """
    Fortran routine hdf5_write_beam return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def alive_only(self) -> bool | None:
        ...
    @property
    def append(self) -> bool:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def file_name(self) -> str:
        ...
class Hdf5WriteGridField:
    """
    Fortran routine hdf5_write_grid_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def file_name(self) -> str:
        ...
class HighEnergySpaceChargeStruct:
    """
    Fortran struct: high_energy_space_charge_struct
    """
    closed_orb: CoordStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def cos_phi(self) -> float:
        ...
    @cos_phi.setter
    def cos_phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def kick_const(self) -> float:
        ...
    @kick_const.setter
    def kick_const(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_x(self) -> float:
        ...
    @sig_x.setter
    def sig_x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_y(self) -> float:
        ...
    @sig_y.setter
    def sig_y(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_z(self) -> float:
        ...
    @sig_z.setter
    def sig_z(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sin_phi(self) -> float:
        ...
    @sin_phi.setter
    def sin_phi(self, arg1: typing.SupportsFloat) -> None:
        ...
class HomVoltage:
    """
    Fortran routine hom_voltage return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def voltage(self) -> float:
        ...
class IBessel:
    """
    Fortran routine i_bessel return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arg(self) -> float:
        ...
    @property
    def i_bes(self) -> float:
        ...
    @property
    def m(self) -> int:
        ...
class IBesselExtended:
    """
    Fortran routine i_bessel_extended return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arg(self) -> float:
        ...
    @property
    def i_bes(self) -> complex:
        ...
    @property
    def m(self) -> int:
        ...
class IbsMatrixC:
    """
    Fortran routine ibs_matrix_c return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def energy(self) -> float:
        ...
    @property
    def n_part(self) -> float:
        ...
    @property
    def species(self) -> int:
        ...
    @property
    def tail_cut(self) -> bool:
        ...
    @property
    def tau(self) -> float:
        ...
class Igfcoulombfun:
    """
    Fortran routine igfcoulombfun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dx(self) -> float:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def dz(self) -> float:
        ...
    @property
    def gam(self) -> float:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def u(self) -> float:
        ...
    @property
    def v(self) -> float:
        ...
    @property
    def w(self) -> float:
        ...
class Igfexfun:
    """
    Fortran routine igfexfun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dx(self) -> float:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def dz(self) -> float:
        ...
    @property
    def gam(self) -> float:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def u(self) -> float:
        ...
    @property
    def v(self) -> float:
        ...
    @property
    def w(self) -> float:
        ...
class Igfeyfun:
    """
    Fortran routine igfeyfun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dx(self) -> float:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def dz(self) -> float:
        ...
    @property
    def gam(self) -> float:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def u(self) -> float:
        ...
    @property
    def v(self) -> float:
        ...
    @property
    def w(self) -> float:
        ...
class Igfezfun:
    """
    Fortran routine igfezfun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dx(self) -> float:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def dz(self) -> float:
        ...
    @property
    def gam(self) -> float:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def u(self) -> float:
        ...
    @property
    def v(self) -> float:
        ...
    @property
    def w(self) -> float:
        ...
class IncrementFileNumber:
    """
    Fortran routine increment_file_number return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cnumber(self) -> str:
        ...
    @property
    def digits(self) -> int:
        ...
    @property
    def file_name(self) -> str:
        ...
    @property
    def number(self) -> int:
        ...
class IndexNocase:
    """
    Fortran routine index_nocase return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def indx(self) -> int:
        ...
    @property
    def string1(self) -> str:
        ...
    @property
    def string2(self) -> str:
        ...
class InitBeamDistribution:
    """
    Fortran routine init_beam_distribution return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def beam(self) -> BeamStruct:
        ...
    @property
    def beam_init_set(self) -> BeamInitStruct:
        ...
    @property
    def conserve_momentum(self) -> bool | None:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class InitBunchDistribution:
    """
    Fortran routine init_bunch_distribution return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def beam_init_used(self) -> BeamInitStruct:
        ...
    @property
    def bunch(self) -> BunchStruct:
        ...
    @property
    def conserve_momentum(self) -> bool | None:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class InitPhotonIntegProb:
    """
    Fortran routine init_photon_integ_prob return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def E_photon(self) -> float:
        ...
    @property
    def integ_prob(self) -> float:
        ...
class InitSurfaceSegment:
    """
    Fortran routine init_surface_segment return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix(self) -> int:
        ...
    @property
    def iy(self) -> int:
        ...
class Int8Alloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[int]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> Int8Array1D:
        ...
class Int8Array1D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[int]:
        ...
    @property
    def lower_bound(self) -> int:
        ...
    @property
    def upper_bound(self) -> int:
        ...
class IntAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[int]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> IntArray1D:
        ...
class IntArray1D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[int]:
        ...
    @property
    def lower_bound(self) -> int:
        ...
    @property
    def upper_bound(self) -> int:
        ...
class IntArray2D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> int:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[int]:
        ...
    @property
    def total_size(self) -> int:
        ...
class IntArray3D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> int:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[int]:
        ...
    @property
    def total_size(self) -> int:
        ...
class IntStr:
    """
    Fortran routine int_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def int_(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
    @property
    def width(self) -> int | None:
        ...
class IntegrandBase:
    """
    Fortran routine integrand_base return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def func_retval__(self) -> float:
        ...
class IntegrateMax:
    """
    Fortran routine integrate_max return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def datum_value(self) -> float:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @property
    def ix_m(self) -> int:
        ...
    @property
    def ix_start(self) -> int:
        ...
class IntegrateMin:
    """
    Fortran routine integrate_min return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def datum_value(self) -> float:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @property
    def ix_m(self) -> int:
        ...
    @property
    def ix_start(self) -> int:
        ...
class IntegrationTimerEle:
    """
    Fortran routine integration_timer_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def tol(self) -> float:
        ...
class InterpolatedFft:
    """
    Fortran routine interpolated_fft return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def calc_ok(self) -> bool:
        ...
    @property
    def opt_dump_index(self) -> int | None:
        ...
    @property
    def opt_dump_spectrum(self) -> int | None:
        ...
    @property
    def this_fft(self) -> float:
        ...
class InterpolatedFftGsl:
    """
    Fortran routine interpolated_fft_gsl return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def calc_ok(self) -> bool:
        ...
    @property
    def opt_dump_index(self) -> int | None:
        ...
    @property
    def opt_dump_spectrum(self) -> int | None:
        ...
    @property
    def this_fft(self) -> float:
        ...
class Interval1CoefStruct:
    """
    Fortran struct: interval1_coef_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def c0(self) -> float:
        ...
    @c0.setter
    def c0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def c1(self) -> float:
        ...
    @c1.setter
    def c1(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_exp(self) -> float:
        ...
    @n_exp.setter
    def n_exp(self, arg1: typing.SupportsFloat) -> None:
        ...
class Interval1CoefStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Interval1CoefStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Interval1CoefStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> Interval1CoefStructArray1D:
        ...
class Interval1CoefStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Interval1CoefStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Interval1CoefStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class IsAlphabetic:
    """
    Fortran routine is_alphabetic return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_alpha(self) -> bool:
        ...
    @property
    def string(self) -> str:
        ...
    @property
    def valid_chars(self) -> str | None:
        ...
class IsDecreasingSequence:
    """
    Fortran routine is_decreasing_sequence return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_decreasing(self) -> bool:
        ...
class IsIncreasingSequence:
    """
    Fortran routine is_increasing_sequence return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_increasing(self) -> bool:
        ...
class IsInteger:
    """
    Fortran routine is_integer return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delims(self) -> str | None:
        ...
    @property
    def int_(self) -> int | None:
        ...
    @property
    def ix_word(self) -> int | None:
        ...
    @property
    def string(self) -> str:
        ...
    @property
    def valid(self) -> bool:
        ...
class IsLogical:
    """
    Fortran routine is_logical return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ignore(self) -> bool | None:
        ...
    @property
    def string(self) -> str:
        ...
    @property
    def valid(self) -> bool:
        ...
class IsReal:
    """
    Fortran routine is_real return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ignore(self) -> bool | None:
        ...
    @property
    def real_num(self) -> float | None:
        ...
    @property
    def string(self) -> str:
        ...
    @property
    def valid(self) -> bool:
        ...
class JBessel:
    """
    Fortran routine j_bessel return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arg(self) -> float:
        ...
    @property
    def j_bes(self) -> float:
        ...
    @property
    def m(self) -> int:
        ...
class KeyNameToKeyIndex:
    """
    Fortran routine key_name_to_key_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def key_index(self) -> int:
        ...
class KickVectorCalc:
    """
    Fortran routine kick_vector_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dr_ds(self) -> typing.Annotated[list[float], "FixedSize(11)"]:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def print_err(self) -> bool | None:
        ...
class KnotInterpolate:
    """
    Fortran routine knot_interpolate return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def y_pt(self) -> float:
        ...
class KnotsToString:
    """
    Fortran routine knots_to_string return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class KvBeamInitStruct:
    """
    Fortran struct: kv_beam_init_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def A(self) -> float:
        ...
    @A.setter
    def A(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_I2(self) -> int:
        ...
    @n_I2.setter
    def n_I2(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def part_per_phi(self) -> ...:
        ...
class Lafun:
    """
    Fortran routine lafun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
class LatEleLocStruct:
    """
    Fortran struct: lat_ele_loc_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
class LatEleLocStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatEleLocStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatEleLocStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> LatEleLocStructArray1D:
        ...
class LatEleLocStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatEleLocStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatEleLocStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class LatEleLocator:
    """
    Fortran routine lat_ele_locator return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def n_loc(self) -> int:
        ...
class LatEleOrder1Struct:
    """
    Fortran struct: lat_ele_order1_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_order(self) -> int:
        ...
    @ix_order.setter
    def ix_order(self, arg1: typing.SupportsInt) -> None:
        ...
class LatEleOrder1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatEleOrder1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatEleOrder1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> LatEleOrder1StructArray1D:
        ...
class LatEleOrder1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatEleOrder1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatEleOrder1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class LatEleOrderArrayStruct:
    """
    Fortran struct: lat_ele_order_array_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele(self) -> LatEleOrder1StructArray1D:
        ...
class LatEleOrderArrayStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatEleOrderArrayStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatEleOrderArrayStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> LatEleOrderArrayStructArray1D:
        ...
class LatEleOrderArrayStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatEleOrderArrayStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatEleOrderArrayStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class LatEleOrderStruct:
    """
    Fortran struct: lat_ele_order_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def branch(self) -> LatEleOrderArrayStructArray1D:
        ...
class LatParamStruct:
    """
    Fortran struct: lat_param_struct
    """
    beam_init: BeamInitStruct
    bookkeeping_state: BookkeepingStateStruct
    live_branch: bool
    stable: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def default_tracking_species(self) -> int:
        ...
    @default_tracking_species.setter
    def default_tracking_species(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def g1_integral(self) -> float:
        ...
    @g1_integral.setter
    def g1_integral(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def g2_integral(self) -> float:
        ...
    @g2_integral.setter
    def g2_integral(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def g3_integral(self) -> float:
        ...
    @g3_integral.setter
    def g3_integral(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def geometry(self) -> int:
        ...
    @geometry.setter
    def geometry(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ixx(self) -> int:
        ...
    @ixx.setter
    def ixx(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_part(self) -> float:
        ...
    @n_part.setter
    def n_part(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def particle(self) -> int:
        ...
    @particle.setter
    def particle(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def spin_tune(self) -> float:
        ...
    @spin_tune.setter
    def spin_tune(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def t1_no_RF(self) -> ...:
        ...
    @property
    def t1_with_RF(self) -> ...:
        ...
    @property
    def total_length(self) -> float:
        ...
    @total_length.setter
    def total_length(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def unstable_factor(self) -> float:
        ...
    @unstable_factor.setter
    def unstable_factor(self, arg1: typing.SupportsFloat) -> None:
        ...
class LatStruct:
    """
    Fortran struct: lat_struct
    """
    beam_init: BeamInitStruct
    ele_init: EleStruct
    input_file_name: str
    lattice: str
    lord_state: BookkeepingStateStruct
    machine: str
    pre_tracker: PreTrackerStruct
    title: str
    use_name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a(self) -> _pybmad.ModeInfoStruct | None:
        ...
    @a.setter
    def a(self, arg1: ModeInfoStruct) -> None:
        ...
    @property
    def b(self) -> _pybmad.ModeInfoStruct | None:
        ...
    @b.setter
    def b(self, arg1: ModeInfoStruct) -> None:
        ...
    @property
    def branch(self) -> BranchStructArray1D:
        ...
    @property
    def constant(self) -> ExpressionAtomStructArray1D:
        ...
    @property
    def control(self) -> ControlStructArray1D:
        ...
    @property
    def creation_hash(self) -> int:
        ...
    @creation_hash.setter
    def creation_hash(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def custom(self) -> ...:
        ...
    @property
    def ele(self) -> EleStructArray1D:
        ...
    @property
    def ic(self) -> ...:
        ...
    @property
    def input_taylor_order(self) -> int:
        ...
    @input_taylor_order.setter
    def input_taylor_order(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_control_max(self) -> int:
        ...
    @n_control_max.setter
    def n_control_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_ele_max(self) -> int:
        ...
    @n_ele_max.setter
    def n_ele_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_ele_track(self) -> int:
        ...
    @n_ele_track.setter
    def n_ele_track(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_ic_max(self) -> int:
        ...
    @n_ic_max.setter
    def n_ic_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def param(self) -> _pybmad.LatParamStruct | None:
        ...
    @param.setter
    def param(self, arg1: LatParamStruct) -> None:
        ...
    @property
    def particle_start(self) -> _pybmad.CoordStruct | None:
        ...
    @particle_start.setter
    def particle_start(self, arg1: CoordStruct) -> None:
        ...
    @property
    def photon_type(self) -> int:
        ...
    @photon_type.setter
    def photon_type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def print_str(self) -> ...:
        ...
    @property
    def ramper_slave_bookkeeping(self) -> int:
        ...
    @ramper_slave_bookkeeping.setter
    def ramper_slave_bookkeeping(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def version(self) -> int:
        ...
    @version.setter
    def version(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def z(self) -> _pybmad.ModeInfoStruct | None:
        ...
    @z.setter
    def z(self, arg1: ModeInfoStruct) -> None:
        ...
class LatStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> LatStructArray1D:
        ...
class LatStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> LatStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[LatStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class LinacNormalModeStruct:
    """
    Fortran struct: linac_normal_mode_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a_emittance_end(self) -> float:
        ...
    @a_emittance_end.setter
    def a_emittance_end(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_emittance_end(self) -> float:
        ...
    @b_emittance_end.setter
    def b_emittance_end(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i2_E4(self) -> float:
        ...
    @i2_E4.setter
    def i2_E4(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i3_E7(self) -> float:
        ...
    @i3_E7.setter
    def i3_E7(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i5a_E6(self) -> float:
        ...
    @i5a_E6.setter
    def i5a_E6(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i5b_E6(self) -> float:
        ...
    @i5b_E6.setter
    def i5b_E6(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_E1(self) -> float:
        ...
    @sig_E1.setter
    def sig_E1(self, arg1: typing.SupportsFloat) -> None:
        ...
class LinearCoef:
    """
    Fortran routine linear_coef return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def coef(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class LinearFit:
    """
    Fortran routine linear_fit return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def a(self) -> float:
        ...
    @property
    def b(self) -> float:
        ...
    @property
    def n_data(self) -> int:
        ...
    @property
    def sig_a(self) -> float:
        ...
    @property
    def sig_b(self) -> float:
        ...
class LoadParseLine:
    """
    Fortran routine load_parse_line return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_of_file(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class LogicStr:
    """
    Fortran routine logic_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def logic(self) -> bool:
        ...
    @property
    def str(self) -> str:
        ...
class LogicalToPython:
    """
    Fortran routine logical_to_python return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def logic(self) -> bool:
        ...
    @property
    def string(self) -> str:
        ...
class LordEdgeAligned:
    """
    Fortran routine lord_edge_aligned return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_aligned(self) -> bool:
        ...
class LowEnergyZCorrection:
    """
    Fortran routine low_energy_z_correction return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dz(self) -> float:
        ...
class MadEnergyStruct:
    """
    Fortran struct: mad_energy_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def beta(self) -> float:
        ...
    @beta.setter
    def beta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def gamma(self) -> float:
        ...
    @gamma.setter
    def gamma(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def kinetic(self) -> float:
        ...
    @kinetic.setter
    def kinetic(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def p0c(self) -> float:
        ...
    @p0c.setter
    def p0c(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def particle(self) -> int:
        ...
    @particle.setter
    def particle(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def total(self) -> float:
        ...
    @total.setter
    def total(self, arg1: typing.SupportsFloat) -> None:
        ...
class MadMapStruct:
    """
    Fortran struct: mad_map_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def k(self) -> ...:
        ...
    @property
    def r(self) -> ...:
        ...
    @property
    def t(self) -> ...:
        ...
class MadTmfoc:
    """
    Fortran routine mad_tmfoc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def c(self) -> float:
        ...
    @property
    def d(self) -> float:
        ...
    @property
    def f(self) -> float:
        ...
    @property
    def s(self) -> float:
        ...
class MakeGMats:
    """
    Fortran routine make_g_mats return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def g_inv_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"]:
        ...
    @property
    def g_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"]:
        ...
class MakeHvbp:
    """
    Fortran routine make_hvbp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def B(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def H(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def Hbar(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
    @property
    def V(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def Vbar(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
class MakeLegalComment:
    """
    Fortran routine make_legal_comment return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def comment_in(self) -> str:
        ...
    @property
    def comment_out(self) -> str:
        ...
class MakeMadMap:
    """
    Fortran routine make_mad_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def energy(self) -> MadEnergyStruct:
        ...
    @property
    def map(self) -> MadMapStruct:
        ...
class MakeMat6:
    """
    Fortran routine make_mat6 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class MakeMat6Bmad:
    """
    Fortran routine make_mat6_bmad return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def err(self) -> bool:
        ...
class MakeMat6BmadPhoton:
    """
    Fortran routine make_mat6_bmad_photon return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def err(self) -> bool:
        ...
class MakeMat6Taylor:
    """
    Fortran routine make_mat6_taylor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
class MakeMat6Tracking:
    """
    Fortran routine make_mat6_tracking return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class MakeN:
    """
    Fortran routine make_n return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def N(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def U(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def tunes_out(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class MakePbrh:
    """
    Fortran routine make_pbrh return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def Bp(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def H(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def P(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def R(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
class MakeSmatFromAbc:
    """
    Fortran routine make_smat_from_abc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def Nout(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def sigma_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
class MakeVMats:
    """
    Fortran routine make_v_mats return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def v_inv_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"] | None:
        ...
    @property
    def v_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"] | None:
        ...
class MakeupControlSlave:
    """
    Fortran routine makeup_control_slave return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class MakeupGroupLord:
    """
    Fortran routine makeup_group_lord return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class MakeupMultipassSlave:
    """
    Fortran routine makeup_multipass_slave return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class MakeupSuperSlave:
    """
    Fortran routine makeup_super_slave return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class MasterParameterValue:
    """
    Fortran routine master_parameter_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def value(self) -> float:
        ...
class Mat4Multipole:
    """
    Fortran routine mat4_multipole return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def kick_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"]:
        ...
    @property
    def n(self) -> int:
        ...
class MatSympDecouple:
    """
    Fortran routine mat_symp_decouple return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def gamma(self) -> float:
        ...
    @property
    def stat(self) -> int:
        ...
    @property
    def twiss1(self) -> TwissStruct:
        ...
    @property
    def twiss2(self) -> TwissStruct:
        ...
class MatchEleToMat6:
    """
    Fortran routine match_ele_to_mat6 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def mat6(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def vec0(self) -> typing.Annotated[list[float], "FixedSize(6)"]:
        ...
class MatchReg:
    """
    Fortran routine match_reg return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_match(self) -> bool:
        ...
    @property
    def pat(self) -> str:
        ...
    @property
    def str(self) -> str:
        ...
class MatchWild:
    """
    Fortran routine match_wild return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_match(self) -> bool:
        ...
    @property
    def string(self) -> str:
        ...
    @property
    def template_(self) -> str:
        ...
class MaximizeProjection:
    """
    Fortran routine maximize_projection return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def func_retval__(self) -> float:
        ...
    @property
    def seed(self) -> float:
        ...
class Mexp:
    """
    Fortran routine mexp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def this_exp(self) -> float:
        ...
class MilliSleep:
    """
    Fortran routine milli_sleep return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def milli_sec(self) -> int:
        ...
class Mode3Struct:
    """
    Fortran struct: mode3_struct
    """
    a: TwissStruct
    b: TwissStruct
    c: TwissStruct
    x: TwissStruct
    y: TwissStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def v(self) -> ...:
        ...
class ModeInfoStruct:
    """
    Fortran struct: mode_info_struct
    """
    stable: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def chrom(self) -> float:
        ...
    @chrom.setter
    def chrom(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def emit(self) -> float:
        ...
    @emit.setter
    def emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigma(self) -> float:
        ...
    @sigma.setter
    def sigma(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigmap(self) -> float:
        ...
    @sigmap.setter
    def sigmap(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def tune(self) -> float:
        ...
    @tune.setter
    def tune(self, arg1: typing.SupportsFloat) -> None:
        ...
class MomentumCompaction:
    """
    Fortran routine momentum_compaction return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def mom_comp(self) -> float:
        ...
class MultiTurnTrackingAnalysis:
    """
    Fortran routine multi_turn_tracking_analysis return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def chi(self) -> float:
        ...
    @property
    def ele(self) -> EleStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def growth_rate(self) -> float:
        ...
    @property
    def stable(self) -> bool:
        ...
    @property
    def track0(self) -> CoordStruct:
        ...
class Multipole1AbToKt:
    """
    Fortran routine multipole1_ab_to_kt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def knl(self) -> float:
        ...
    @property
    def tn(self) -> float:
        ...
class Multipole1KtToAb:
    """
    Fortran routine multipole1_kt_to_ab return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def an(self) -> float:
        ...
    @property
    def bn(self) -> float:
        ...
class MultipoleAbToKt:
    """
    Fortran routine multipole_ab_to_kt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def knl(self) -> RealAlloc1D:
        ...
    @property
    def tn(self) -> RealAlloc1D:
        ...
class MultipoleEleToAb:
    """
    Fortran routine multipole_ele_to_ab return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def a(self) -> typing.Annotated[list[float], "FixedSize(21)"]:
        ...
    @property
    def b(self) -> typing.Annotated[list[float], "FixedSize(21)"]:
        ...
    @property
    def b1(self) -> float:
        ...
    @property
    def ix_pole_max(self) -> int:
        ...
class MultipoleEleToKt:
    """
    Fortran routine multipole_ele_to_kt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_pole_max(self) -> int:
        ...
    @property
    def knl(self) -> RealAlloc1D:
        ...
    @property
    def tilt(self) -> RealAlloc1D:
        ...
class MultipoleKtToAb:
    """
    Fortran routine multipole_kt_to_ab return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def an(self) -> RealAlloc1D:
        ...
    @property
    def bn(self) -> RealAlloc1D:
        ...
class Mytan:
    """
    Fortran routine mytan return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arg(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
class NBinsAutomatic:
    """
    Fortran routine n_bins_automatic return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n(self) -> int:
        ...
    @property
    def n_data(self) -> int:
        ...
class NChooseK:
    """
    Fortran routine n_choose_k return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def k(self) -> int:
        ...
    @property
    def n(self) -> int:
        ...
    @property
    def nck(self) -> float:
        ...
class Naff:
    """
    Fortran routine naff return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_dump_spectra(self) -> int | None:
        ...
    @property
    def opt_zero_first(self) -> bool | None:
        ...
class NametableAdd:
    """
    Fortran routine nametable_add return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_name(self) -> int:
        ...
    @property
    def name(self) -> str:
        ...
class NametableBracketIndexx:
    """
    Fortran routine nametable_bracket_indexx return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_max(self) -> int:
        ...
    @property
    def n_match(self) -> int | None:
        ...
    @property
    def name(self) -> str:
        ...
class NametableChange1:
    """
    Fortran routine nametable_change1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_name(self) -> int:
        ...
    @property
    def name(self) -> str:
        ...
class NametableInit:
    """
    Fortran routine nametable_init return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n_max(self) -> int | None:
        ...
    @property
    def n_min(self) -> int | None:
        ...
class NametableRemove:
    """
    Fortran routine nametable_remove return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_name(self) -> int:
        ...
class NametableStruct:
    """
    Fortran struct: nametable_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def index(self) -> ...:
        ...
    @property
    def n_max(self) -> int:
        ...
    @n_max.setter
    def n_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_min(self) -> int:
        ...
    @n_min.setter
    def n_min(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def name(self) -> ...:
        ...
class NormalFormComplexTaylors:
    """
    Fortran routine normal_form_complex_taylors return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def order(self) -> int | None:
        ...
    @property
    def rf_on(self) -> bool:
        ...
class NormalFormTaylors:
    """
    Fortran routine normal_form_taylors return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def A(self) -> TaylorStructArray1D:
        ...
    @property
    def A_inverse(self) -> TaylorStructArray1D:
        ...
    @property
    def dhdj(self) -> TaylorStructArray1D:
        ...
class NormalMode3Calc:
    """
    Fortran routine normal_mode3_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def B(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def HV(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def tune(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class NormalModesStruct:
    """
    Fortran struct: normal_modes_struct
    """
    a: AnormalModeStruct
    b: AnormalModeStruct
    lin: LinacNormalModeStruct
    z: AnormalModeStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dpz_damp(self) -> float:
        ...
    @dpz_damp.setter
    def dpz_damp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def e_loss(self) -> float:
        ...
    @e_loss.setter
    def e_loss(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def momentum_compaction(self) -> float:
        ...
    @momentum_compaction.setter
    def momentum_compaction(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def pz_aperture(self) -> float:
        ...
    @pz_aperture.setter
    def pz_aperture(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def pz_average(self) -> float:
        ...
    @pz_average.setter
    def pz_average(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rf_voltage(self) -> float:
        ...
    @rf_voltage.setter
    def rf_voltage(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigE_E(self) -> float:
        ...
    @sigE_E.setter
    def sigE_E(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sig_z(self) -> float:
        ...
    @sig_z.setter
    def sig_z(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def synch_int(self) -> ...:
        ...
class NumFieldEles:
    """
    Fortran routine num_field_eles return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n_field_ele(self) -> int:
        ...
class NumLords:
    """
    Fortran routine num_lords return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def num(self) -> int:
        ...
class OdeintBmad:
    """
    Fortran routine odeint_bmad return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class OdeintBmadTime:
    """
    Fortran routine odeint_bmad_time return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dt_step(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def rf_time(self) -> float:
        ...
class OffsetParticle:
    """
    Fortran routine offset_particle return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def s_out(self) -> float:
        ...
    @property
    def spin_qrot(self) -> typing.Annotated[list[float], "FixedSize(4)"]:
        ...
    @property
    def time(self) -> float | None:
        ...
class OpenBinaryFile:
    """
    Fortran routine open_binary_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def iu(self) -> int:
        ...
    @property
    def iver(self) -> int:
        ...
class OrbitAmplitudeCalc:
    """
    Fortran routine orbit_amplitude_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def amp_a(self) -> float:
        ...
    @property
    def amp_b(self) -> float:
        ...
    @property
    def amp_na(self) -> float:
        ...
    @property
    def amp_nb(self) -> float:
        ...
class OrbitTooLarge:
    """
    Fortran routine orbit_too_large return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_too_large(self) -> bool:
        ...
    @property
    def param(self) -> LatParamStruct:
        ...
class OrderEvecsByNSimilarity:
    """
    Fortran routine order_evecs_by_n_similarity return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def evec(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
class OrdinalStr:
    """
    Fortran routine ordinal_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class OscGetgrnpipe:
    """
    Fortran routine osc_getgrnpipe return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def a(self) -> float:
        ...
    @property
    def b(self) -> float:
        ...
    @property
    def gam(self) -> float:
        ...
class OscWriteRectpipeGrn:
    """
    Fortran routine osc_write_rectpipe_grn return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def apipe(self) -> float:
        ...
    @property
    def bpipe(self) -> float:
        ...
    @property
    def gamma(self) -> float:
        ...
class ParseCartesianMap:
    """
    Fortran routine parse_cartesian_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ParseCylindricalMap:
    """
    Fortran routine parse_cylindrical_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ParseFortranFormat:
    """
    Fortran routine parse_fortran_format return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def descrip(self) -> str:
        ...
    @property
    def digits(self) -> int:
        ...
    @property
    def format_str(self) -> str:
        ...
    @property
    def n_repeat(self) -> int:
        ...
    @property
    def power(self) -> int:
        ...
    @property
    def width(self) -> int:
        ...
class ParseGenGradMap:
    """
    Fortran routine parse_gen_grad_map return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ParseGridField:
    """
    Fortran routine parse_grid_field return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ParseIntegerList:
    """
    Fortran routine parse_integer_list return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def close_delim(self) -> str | None:
        ...
    @property
    def default_value(self) -> int | None:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def exact_size(self) -> bool:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def open_delim(self) -> str | None:
        ...
    @property
    def separator(self) -> str | None:
        ...
class ParseIntegerList2:
    """
    Fortran routine parse_integer_list2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def close_delim(self) -> str | None:
        ...
    @property
    def default_value(self) -> int | None:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def num_expected(self) -> int | None:
        ...
    @property
    def num_found(self) -> int:
        ...
    @property
    def open_delim(self) -> str | None:
        ...
    @property
    def separator(self) -> str | None:
        ...
class ParseRealList:
    """
    Fortran routine parse_real_list return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def num_found(self) -> int:
        ...
    @property
    def real_array(self) -> RealAlloc1D:
        ...
class ParseRealList2:
    """
    Fortran routine parse_real_list2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def close_brace(self) -> str | None:
        ...
    @property
    def default_value(self) -> float | None:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def num_expected(self) -> int | None:
        ...
    @property
    def num_found(self) -> int:
        ...
    @property
    def open_brace(self) -> str | None:
        ...
    @property
    def separator(self) -> str | None:
        ...
    @property
    def single_value(self) -> bool | None:
        ...
class ParserAddConstant:
    """
    Fortran routine parser_add_constant return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def redef_is_error(self) -> bool:
        ...
    @property
    def word(self) -> str:
        ...
class ParserCallCheck:
    """
    Fortran routine parser_call_check return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def call_found(self) -> bool:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
    @property
    def ix_word(self) -> int:
        ...
    @property
    def word(self) -> str:
        ...
class ParserFastComplexRead:
    """
    Fortran routine parser_fast_complex_read return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cmplx_vec(self) -> ComplexAlloc1D:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def is_ok(self) -> bool:
        ...
class ParserFastIntegerRead:
    """
    Fortran routine parser_fast_integer_read return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim_wanted(self) -> str:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def is_ok(self) -> bool:
        ...
class ParserFastRealRead:
    """
    Fortran routine parser_fast_real_read return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def n_real(self) -> int:
        ...
    @property
    def real_vec(self) -> RealAlloc1D:
        ...
class ParserFileStack:
    """
    Fortran routine parser_file_stack return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def abort_on_open_error(self) -> bool | None:
        ...
    @property
    def err(self) -> bool | None:
        ...
    @property
    def file_name_in(self) -> str | None:
        ...
    @property
    def finished(self) -> bool | None:
        ...
    @property
    def how(self) -> str:
        ...
    @property
    def open_file(self) -> bool | None:
        ...
class ParserGetInteger:
    """
    Fortran routine parser_get_integer return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def int_val(self) -> int:
        ...
    @property
    def ix_word(self) -> int:
        ...
    @property
    def str1(self) -> str | None:
        ...
    @property
    def str2(self) -> str | None:
        ...
    @property
    def word(self) -> str:
        ...
class ParserGetLogical:
    """
    Fortran routine parser_get_logical return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib_name(self) -> str:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def ele_name(self) -> str:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def this_logic(self) -> bool:
        ...
class ParserPrintLine:
    """
    Fortran routine parser_print_line return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_of_file(self) -> bool:
        ...
class ParserReadLrWake:
    """
    Fortran routine parser_read_lr_wake return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ParserReadSrWake:
    """
    Fortran routine parser_read_sr_wake return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ParticleIsMovingBackwards:
    """
    Fortran routine particle_is_moving_backwards return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_moving_backwards(self) -> bool:
        ...
class ParticleIsMovingForward:
    """
    Fortran routine particle_is_moving_forward return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_moving_forward(self) -> bool:
        ...
class ParticleRfTime:
    """
    Fortran routine particle_rf_time return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def time(self) -> float:
        ...
class PatchFlipsPropagationDirection:
    """
    Fortran routine patch_flips_propagation_direction return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_flip(self) -> bool:
        ...
class PatchLength:
    """
    Fortran routine patch_length return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def length(self) -> float:
        ...
class PhotonAbsorptionAndPhaseShift:
    """
    Fortran routine photon_absorption_and_phase_shift return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def absorption(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def phase_shift(self) -> float:
        ...
class PhotonAddToDetectorStatistics:
    """
    Fortran routine photon_add_to_detector_statistics return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_pt(self) -> int | None:
        ...
    @property
    def iy_pt(self) -> int | None:
        ...
class PhotonElementStruct:
    """
    Fortran struct: photon_element_struct
    """
    curvature: SurfaceCurvatureStruct
    displacement: SurfaceDisplacementStruct
    h_misalign: SurfaceHMisalignStruct
    material: PhotonMaterialStruct
    pixel: PixelDetecStruct
    reflectivity_table_pi: PhotonReflectTableStruct
    reflectivity_table_sigma: PhotonReflectTableStruct
    segmented: SurfaceSegmentedStruct
    target: PhotonTargetStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def init_energy_prob(self) -> SplineStructArray1D:
        ...
    @property
    def integrated_init_energy_prob(self) -> ...:
        ...
    @property
    def reflectivity_table_type(self) -> int:
        ...
    @reflectivity_table_type.setter
    def reflectivity_table_type(self, arg1: typing.SupportsInt) -> None:
        ...
class PhotonMaterialStruct:
    """
    Fortran struct: photon_material_struct
    """
    f0_m1: complex
    f0_m2: complex
    f_0: complex
    f_h: complex
    f_hbar: complex
    f_hkl: complex
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def h_norm(self) -> ...:
        ...
    @property
    def l_ref(self) -> ...:
        ...
class PhotonReflectSurfaceStruct:
    """
    Fortran struct: photon_reflect_surface_struct
    """
    description: str
    name: str
    reflectivity_file: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_surface(self) -> int:
        ...
    @ix_surface.setter
    def ix_surface(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def roughness_correlation_len(self) -> float:
        ...
    @roughness_correlation_len.setter
    def roughness_correlation_len(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def surface_roughness_rms(self) -> float:
        ...
    @surface_roughness_rms.setter
    def surface_roughness_rms(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def table(self) -> PhotonReflectTableStructArray1D:
        ...
class PhotonReflectTableStruct:
    """
    Fortran struct: photon_reflect_table_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def angle(self) -> ...:
        ...
    @property
    def bragg_angle(self) -> ...:
        ...
    @property
    def energy(self) -> ...:
        ...
    @property
    def int1(self) -> Interval1CoefStructArray1D:
        ...
    @property
    def max_energy(self) -> float:
        ...
    @max_energy.setter
    def max_energy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def p_reflect(self) -> ...:
        ...
    @property
    def p_reflect_scratch(self) -> ...:
        ...
class PhotonReflectTableStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> PhotonReflectTableStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[PhotonReflectTableStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> PhotonReflectTableStructArray1D:
        ...
class PhotonReflectTableStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> PhotonReflectTableStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[PhotonReflectTableStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class PhotonReflection:
    """
    Fortran routine photon_reflection return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def graze_angle_out(self) -> float:
        ...
    @property
    def phi_out(self) -> float:
        ...
class PhotonReflectivity:
    """
    Fortran routine photon_reflectivity return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def p_reflect(self) -> float:
        ...
    @property
    def rel_p_specular(self) -> float:
        ...
class PhotonTargetCornerCalc:
    """
    Fortran routine photon_target_corner_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def corner(self) -> TargetPointStruct:
        ...
    @property
    def x_lim(self) -> float:
        ...
    @property
    def y_lim(self) -> float:
        ...
    @property
    def z_lim(self) -> float:
        ...
class PhotonTargetStruct:
    """
    Fortran struct: photon_target_struct
    """
    center: TargetPointStruct
    ele_loc: LatEleLocStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def corner(self) -> TargetPointStructArray1D:
        ...
    @property
    def n_corner(self) -> int:
        ...
    @n_corner.setter
    def n_corner(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def type(self) -> int:
        ...
    @type.setter
    def type(self, arg1: typing.SupportsInt) -> None:
        ...
class PhysicalEleEnd:
    """
    Fortran routine physical_ele_end return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def physical_end(self) -> int:
        ...
class PixelDetecStruct:
    """
    Fortran struct: pixel_detec_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dr(self) -> ...:
        ...
    @property
    def n_hit_detec(self) -> int:
        ...
    @n_hit_detec.setter
    def n_hit_detec(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_hit_pixel(self) -> int:
        ...
    @n_hit_pixel.setter
    def n_hit_pixel(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_track_tot(self) -> int:
        ...
    @n_track_tot.setter
    def n_track_tot(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def pt(self) -> PixelPtStructArray2D:
        ...
    @property
    def r0(self) -> ...:
        ...
class PixelPtStruct:
    """
    Fortran struct: pixel_pt_struct
    """
    E_x: complex
    E_y: complex
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def init_orbit(self) -> ...:
        ...
    @property
    def init_orbit_rms(self) -> ...:
        ...
    @property
    def intensity(self) -> float:
        ...
    @intensity.setter
    def intensity(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def intensity_x(self) -> float:
        ...
    @intensity_x.setter
    def intensity_x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def intensity_y(self) -> float:
        ...
    @intensity_y.setter
    def intensity_y(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_photon(self) -> int:
        ...
    @n_photon.setter
    def n_photon(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def orbit(self) -> ...:
        ...
    @property
    def orbit_rms(self) -> ...:
        ...
class PixelPtStructArray2D:
    def __getitem__(self, arg0: typing.SupportsInt) -> PixelPtStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[PixelPtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class PointerToEle1:
    """
    Fortran routine pointer_to_ele1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_branch(self) -> int | None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
class PointerToEle3:
    """
    Fortran routine pointer_to_ele3 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele_name(self) -> str:
        ...
class PointerToElementAtS:
    """
    Fortran routine pointer_to_element_at_s return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele(self) -> EleStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def position(self) -> CoordStruct:
        ...
    @property
    def s_eff(self) -> float:
        ...
class PointerToLord:
    """
    Fortran routine pointer_to_lord return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def control(self) -> ControlStruct:
        ...
    @property
    def ix_control(self) -> int:
        ...
    @property
    def ix_ic(self) -> int:
        ...
    @property
    def ix_slave_back(self) -> int:
        ...
class PointerToMultipassLord:
    """
    Fortran routine pointer_to_multipass_lord return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_pass(self) -> int:
        ...
    @property
    def super_lord(self) -> EleStruct:
        ...
class PointerToSlave:
    """
    Fortran routine pointer_to_slave return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def control(self) -> ControlStruct:
        ...
    @property
    def ix_control(self) -> int:
        ...
    @property
    def ix_ic(self) -> int:
        ...
    @property
    def ix_lord_back(self) -> int:
        ...
    @property
    def slave_ptr(self) -> EleStruct:
        ...
class PointerToSuperLord:
    """
    Fortran routine pointer_to_super_lord return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def control(self) -> ControlStruct:
        ...
    @property
    def ix_control(self) -> int:
        ...
    @property
    def ix_ic(self) -> int:
        ...
    @property
    def ix_slave_back(self) -> int:
        ...
class PointerToSurfaceDisplacementPt:
    """
    Fortran routine pointer_to_surface_displacement_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix(self) -> int | None:
        ...
    @property
    def iy(self) -> int | None:
        ...
    @property
    def pt(self) -> SurfaceDisplacementPtStruct:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def xx(self) -> float | None:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def yy(self) -> float | None:
        ...
class PointerToSurfaceSegmentedPt:
    """
    Fortran routine pointer_to_surface_segmented_pt return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix(self) -> int | None:
        ...
    @property
    def iy(self) -> int | None:
        ...
    @property
    def pt(self) -> SurfaceSegmentedPtStruct:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def xx(self) -> float | None:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def yy(self) -> float | None:
        ...
class PointerToWall3d:
    """
    Fortran routine pointer_to_wall3d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ds_offset(self) -> float:
        ...
    @property
    def is_branch_wall(self) -> bool:
        ...
    @property
    def wall3d(self) -> Wall3DStruct:
        ...
class PolyEval:
    """
    Fortran routine poly_eval return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class PreTrackerStruct:
    """
    Fortran struct: pre_tracker_struct
    """
    input_file: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_ele_end(self) -> int:
        ...
    @ix_ele_end.setter
    def ix_ele_end(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele_start(self) -> int:
        ...
    @ix_ele_start.setter
    def ix_ele_start(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def who(self) -> int:
        ...
    @who.setter
    def who(self, arg1: typing.SupportsInt) -> None:
        ...
class ProbabilityFunct:
    """
    Fortran routine probability_funct return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def prob(self) -> float:
        ...
class Projdd:
    """
    Fortran routine projdd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def func_retval__(self) -> complex:
        ...
class ProjectEmitToXyz:
    """
    Fortran routine project_emit_to_xyz return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def sigma_x(self) -> float:
        ...
    @property
    def sigma_y(self) -> float:
        ...
    @property
    def sigma_z(self) -> float:
        ...
class PtcEmitCalc:
    """
    Fortran routine ptc_emit_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def closed_orb(self) -> CoordStruct:
        ...
    @property
    def norm_mode(self) -> NormalModesStruct:
        ...
class PtcNormalFormStruct:
    """
    Fortran struct: ptc_normal_form_struct
    """
    valid_map: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele_origin(self) -> _pybmad.EleStruct | None:
        ...
    @ele_origin.setter
    def ele_origin(self, arg1: EleStruct) -> None:
        ...
    @property
    def orb0(self) -> ...:
        ...
class PtcSpinCalc:
    """
    Fortran routine ptc_spin_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def closed_orb(self) -> CoordStruct:
        ...
    @property
    def norm_mode(self) -> NormalModesStruct:
        ...
class PtcTrackAll:
    """
    Fortran routine ptc_track_all return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def track_state(self) -> int:
        ...
class QpAxisStruct:
    """
    Fortran struct: qp_axis_struct
    """
    bounds: str
    draw_label: bool
    draw_numbers: bool
    label: str
    label_color: str
    type: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dtick(self) -> float:
        ...
    @dtick.setter
    def dtick(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def eval_max(self) -> float:
        ...
    @eval_max.setter
    def eval_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def eval_min(self) -> float:
        ...
    @eval_min.setter
    def eval_min(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def label_offset(self) -> float:
        ...
    @label_offset.setter
    def label_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def major_div(self) -> int:
        ...
    @major_div.setter
    def major_div(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def major_div_nominal(self) -> int:
        ...
    @major_div_nominal.setter
    def major_div_nominal(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def major_tick_len(self) -> float:
        ...
    @major_tick_len.setter
    def major_tick_len(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def max(self) -> float:
        ...
    @max.setter
    def max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def min(self) -> float:
        ...
    @min.setter
    def min(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def minor_div(self) -> int:
        ...
    @minor_div.setter
    def minor_div(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def minor_div_max(self) -> int:
        ...
    @minor_div_max.setter
    def minor_div_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def minor_tick_len(self) -> float:
        ...
    @minor_tick_len.setter
    def minor_tick_len(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def number_offset(self) -> float:
        ...
    @number_offset.setter
    def number_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def number_side(self) -> int:
        ...
    @number_side.setter
    def number_side(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def places(self) -> int:
        ...
    @places.setter
    def places(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def tick_max(self) -> float:
        ...
    @tick_max.setter
    def tick_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def tick_min(self) -> float:
        ...
    @tick_min.setter
    def tick_min(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def tick_side(self) -> int:
        ...
    @tick_side.setter
    def tick_side(self, arg1: typing.SupportsInt) -> None:
        ...
class QpLegendStruct:
    """
    Fortran struct: qp_legend_struct
    """
    draw_line: bool
    draw_symbol: bool
    draw_text: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def line_length(self) -> float:
        ...
    @line_length.setter
    def line_length(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def row_spacing(self) -> float:
        ...
    @row_spacing.setter
    def row_spacing(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def text_offset(self) -> float:
        ...
    @text_offset.setter
    def text_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
class QpLineStruct:
    """
    Fortran struct: qp_line_struct
    """
    color: str
    pattern: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def width(self) -> int:
        ...
    @width.setter
    def width(self, arg1: typing.SupportsInt) -> None:
        ...
class QpPointStruct:
    """
    Fortran struct: qp_point_struct
    """
    units: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg1: typing.SupportsFloat) -> None:
        ...
class QpRectStruct:
    """
    Fortran struct: qp_rect_struct
    """
    units: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def x1(self) -> float:
        ...
    @x1.setter
    def x1(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x2(self) -> float:
        ...
    @x2.setter
    def x2(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y1(self) -> float:
        ...
    @y1.setter
    def y1(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y2(self) -> float:
        ...
    @y2.setter
    def y2(self, arg1: typing.SupportsFloat) -> None:
        ...
class QpSymbolStruct:
    """
    Fortran struct: qp_symbol_struct
    """
    color: str
    fill_pattern: str
    type: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def height(self) -> float:
        ...
    @height.setter
    def height(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def line_width(self) -> int:
        ...
    @line_width.setter
    def line_width(self, arg1: typing.SupportsInt) -> None:
        ...
class QuatToAxisAngle:
    """
    Fortran routine quat_to_axis_angle return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def angle(self) -> float:
        ...
    @property
    def axis(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class QueryString:
    """
    Fortran routine query_string return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ios(self) -> int:
        ...
    @property
    def ix(self) -> int:
        ...
    @property
    def query_str(self) -> str:
        ...
    @property
    def return_str(self) -> str:
        ...
    @property
    def upcase(self) -> bool:
        ...
class Quote:
    """
    Fortran routine quote return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def q_str(self) -> str:
        ...
    @property
    def str(self) -> str:
        ...
class Rad1DampAndStocMats:
    """
    Fortran routine rad1_damp_and_stoc_mats return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def rad_int1(self) -> RadInt1Struct:
        ...
    @property
    def rad_map(self) -> RadMapStruct:
        ...
class RadDampAndStocMats:
    """
    Fortran routine rad_damp_and_stoc_mats return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def mode(self) -> NormalModesStruct:
        ...
    @property
    def rad_int_branch(self) -> RadIntBranchStruct:
        ...
    @property
    def rmap(self) -> RadMapStruct:
        ...
    @property
    def xfer_nodamp_mat(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
class RadGIntegrals:
    """
    Fortran routine rad_g_integrals return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def int_g(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
    @property
    def int_g2(self) -> float:
        ...
    @property
    def int_g3(self) -> float:
        ...
class RadInt1Struct:
    """
    Fortran struct: rad_int1_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def i0(self) -> float:
        ...
    @i0.setter
    def i0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i1(self) -> float:
        ...
    @i1.setter
    def i1(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i2(self) -> float:
        ...
    @i2.setter
    def i2(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i3(self) -> float:
        ...
    @i3.setter
    def i3(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i4a(self) -> float:
        ...
    @i4a.setter
    def i4a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i4b(self) -> float:
        ...
    @i4b.setter
    def i4b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i4z(self) -> float:
        ...
    @i4z.setter
    def i4z(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i5a(self) -> float:
        ...
    @i5a.setter
    def i5a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i5b(self) -> float:
        ...
    @i5b.setter
    def i5b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def i6b(self) -> float:
        ...
    @i6b.setter
    def i6b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_i2_E4(self) -> float:
        ...
    @lin_i2_E4.setter
    def lin_i2_E4(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_i3_E7(self) -> float:
        ...
    @lin_i3_E7.setter
    def lin_i3_E7(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_i5a_E6(self) -> float:
        ...
    @lin_i5a_E6.setter
    def lin_i5a_E6(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_i5b_E6(self) -> float:
        ...
    @lin_i5b_E6.setter
    def lin_i5b_E6(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_norm_emit_a(self) -> float:
        ...
    @lin_norm_emit_a.setter
    def lin_norm_emit_a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_norm_emit_b(self) -> float:
        ...
    @lin_norm_emit_b.setter
    def lin_norm_emit_b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lin_sig_E(self) -> float:
        ...
    @lin_sig_E.setter
    def lin_sig_E(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_steps(self) -> float:
        ...
    @n_steps.setter
    def n_steps(self, arg1: typing.SupportsFloat) -> None:
        ...
class RadInt1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RadInt1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RadInt1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> RadInt1StructArray1D:
        ...
class RadInt1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RadInt1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RadInt1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class RadIntAllEleStruct:
    """
    Fortran struct: rad_int_all_ele_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def branch(self) -> RadIntBranchStructArray1D:
        ...
class RadIntBranchStruct:
    """
    Fortran struct: rad_int_branch_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele(self) -> RadInt1StructArray1D:
        ...
class RadIntBranchStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RadIntBranchStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RadIntBranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> RadIntBranchStructArray1D:
        ...
class RadIntBranchStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RadIntBranchStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RadIntBranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class RadMapEleStruct:
    """
    Fortran struct: rad_map_ele_struct
    """
    rm0: RadMapStruct
    rm1: RadMapStruct
    stale: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class RadMapStruct:
    """
    Fortran struct: rad_map_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def damp_dmat(self) -> ...:
        ...
    @property
    def ref_orb(self) -> ...:
        ...
    @property
    def stoc_mat(self) -> ...:
        ...
    @property
    def xfer_damp_mat(self) -> ...:
        ...
    @property
    def xfer_damp_vec(self) -> ...:
        ...
class RadiationIntegrals:
    """
    Fortran routine radiation_integrals return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_cache(self) -> int | None:
        ...
    @property
    def mode(self) -> NormalModesStruct:
        ...
    @property
    def rad_int_by_ele(self) -> RadIntAllEleStruct:
        ...
class RamperLordStruct:
    """
    Fortran struct: ramper_lord_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def attrib_ptr(self) -> float:
        ...
    @attrib_ptr.setter
    def attrib_ptr(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_con(self) -> int:
        ...
    @ix_con.setter
    def ix_con(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
class RamperLordStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RamperLordStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RamperLordStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> RamperLordStructArray1D:
        ...
class RamperLordStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RamperLordStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RamperLordStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class RamperValue:
    """
    Fortran routine ramper_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
class RanGaussConverter:
    """
    Fortran routine ran_gauss_converter return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def get(self) -> str:
        ...
    @property
    def get_sigma_cut(self) -> float:
        ...
class RanGaussScalar:
    """
    Fortran routine ran_gauss_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def harvest(self) -> float:
        ...
    @property
    def index_quasi(self) -> int | None:
        ...
    @property
    def sigma_cut(self) -> float | None:
        ...
class RanGaussVector:
    """
    Fortran routine ran_gauss_vector return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def harvest(self) -> RealAlloc1D:
        ...
    @property
    def sigma_cut(self) -> float | None:
        ...
class RanUniformScalar:
    """
    Fortran routine ran_uniform_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def harvest(self) -> float:
        ...
    @property
    def index_quasi(self) -> int | None:
        ...
class RandomStateStruct:
    """
    Fortran struct: random_state_struct
    """
    number_stored: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def am(self) -> float:
        ...
    @am.setter
    def am(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def engine(self) -> int:
        ...
    @engine.setter
    def engine(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def gauss_converter(self) -> int:
        ...
    @gauss_converter.setter
    def gauss_converter(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def gauss_sigma_cut(self) -> float:
        ...
    @gauss_sigma_cut.setter
    def gauss_sigma_cut(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def h_saved(self) -> float:
        ...
    @h_saved.setter
    def h_saved(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def in_sobseq(self) -> int:
        ...
    @in_sobseq.setter
    def in_sobseq(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix(self) -> int:
        ...
    @ix.setter
    def ix(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def iy(self) -> int:
        ...
    @iy.setter
    def iy(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def seed(self) -> int:
        ...
    @seed.setter
    def seed(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def x_sobseq(self) -> ...:
        ...
class Rchomp:
    """
    Fortran routine rchomp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def out(self) -> str:
        ...
    @property
    def plc(self) -> int:
        ...
    @property
    def rel(self) -> float:
        ...
class ReAllocateCDouble:
    """
    Fortran routine re_allocate_c_double return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def init_val(self) -> float | None:
        ...
class ReStrQp:
    """
    Fortran routine re_str_qp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def rel(self) -> float:
        ...
    @property
    def str_out(self) -> str:
        ...
class ReStrRp:
    """
    Fortran routine re_str_rp return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def rel(self) -> float:
        ...
    @property
    def str_out(self) -> str:
        ...
class ReadBeamAscii:
    """
    Fortran routine read_beam_ascii return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def beam(self) -> BeamStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class ReadBeamFile:
    """
    Fortran routine read_beam_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def beam(self) -> BeamStruct:
        ...
    @property
    def conserve_momentum(self) -> bool | None:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class Real16Alloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[float]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> Real16Array1D:
        ...
class Real16Array1D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[float]:
        ...
    @property
    def lower_bound(self) -> int:
        ...
    @property
    def upper_bound(self) -> int:
        ...
class RealAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[float]:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> RealArray1D:
        ...
class RealArray1D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[float]:
        ...
    @property
    def lower_bound(self) -> int:
        ...
    @property
    def upper_bound(self) -> int:
        ...
class RealArray2D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> float:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[float]:
        ...
    @property
    def total_size(self) -> int:
        ...
class RealArray3D:
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: tuple) -> float:
        ...
    def __init__(self) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
    def to_list(self) -> list[float]:
        ...
    @property
    def total_size(self) -> int:
        ...
class RealNumFortranFormat:
    """
    Fortran routine real_num_fortran_format return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def fmt_str(self) -> str:
        ...
    @property
    def n_blanks(self) -> int | None:
        ...
    @property
    def number(self) -> float:
        ...
    @property
    def width(self) -> int:
        ...
class RealPath:
    """
    Fortran routine real_path return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_ok(self) -> bool:
        ...
    @property
    def path_in(self) -> str:
        ...
    @property
    def path_out(self) -> str:
        ...
class RealStr:
    """
    Fortran routine real_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n_decimal(self) -> int | None:
        ...
    @property
    def n_signif(self) -> int | None:
        ...
    @property
    def r_num(self) -> float:
        ...
    @property
    def str(self) -> str:
        ...
class RealToString:
    """
    Fortran routine real_to_string return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n_decimal(self) -> int | None:
        ...
    @property
    def n_signif(self) -> int | None:
        ...
    @property
    def real_num(self) -> float:
        ...
    @property
    def str(self) -> str:
        ...
    @property
    def width(self) -> int:
        ...
class ReallocateBeam:
    """
    Fortran routine reallocate_beam return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def extend(self) -> bool | None:
        ...
class RelTrackingChargeToMass:
    """
    Fortran routine rel_tracking_charge_to_mass return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def rel_charge(self) -> float:
        ...
class RelativeModeFlip:
    """
    Fortran routine relative_mode_flip return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def func_retval__(self) -> bool:
        ...
class ReleaseRadIntCache:
    """
    Fortran routine release_rad_int_cache return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_cache(self) -> int:
        ...
class RemoveConstantTaylor:
    """
    Fortran routine remove_constant_taylor return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def c0(self) -> RealAlloc1D:
        ...
    @property
    def taylor_out(self) -> TaylorStructAlloc1D:
        ...
class ResonanceHStruct:
    """
    Fortran struct: resonance_h_struct
    """
    c_val: complex
    id: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class ResonanceHStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ResonanceHStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ResonanceHStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> ResonanceHStructArray1D:
        ...
class ResonanceHStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> ResonanceHStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[ResonanceHStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class RfEleStruct:
    """
    Fortran struct: rf_ele_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ds_step(self) -> float:
        ...
    @ds_step.setter
    def ds_step(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def steps(self) -> RfStairStepStructArray1D:
        ...
class RfIsOn:
    """
    Fortran routine rf_is_on return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_on(self) -> bool:
        ...
class RfRefTimeOffset:
    """
    Fortran routine rf_ref_time_offset return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def time(self) -> float:
        ...
class RfStairStepStruct:
    """
    Fortran struct: rf_stair_step_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def E_tot0(self) -> float:
        ...
    @E_tot0.setter
    def E_tot0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def E_tot1(self) -> float:
        ...
    @E_tot1.setter
    def E_tot1(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_step(self) -> int:
        ...
    @ix_step.setter
    def ix_step(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def p0c(self) -> float:
        ...
    @p0c.setter
    def p0c(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def p1c(self) -> float:
        ...
    @p1c.setter
    def p1c(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s0(self) -> float:
        ...
    @s0.setter
    def s0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def scale(self) -> float:
        ...
    @scale.setter
    def scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def time(self) -> float:
        ...
    @time.setter
    def time(self, arg1: typing.SupportsFloat) -> None:
        ...
class RfStairStepStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RfStairStepStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RfStairStepStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> RfStairStepStructArray1D:
        ...
class RfStairStepStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> RfStairStepStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[RfStairStepStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Rfun:
    """
    Fortran routine rfun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def a(self) -> float:
        ...
    @property
    def b(self) -> float:
        ...
    @property
    def gam(self) -> float:
        ...
    @property
    def hz(self) -> float:
        ...
    @property
    def i(self) -> int:
        ...
    @property
    def j(self) -> int:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def u(self) -> float:
        ...
    @property
    def v(self) -> float:
        ...
    @property
    def w(self) -> float:
        ...
class RkAdaptiveTimeStep:
    """
    Fortran routine rk_adaptive_time_step return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dt_did(self) -> float:
        ...
    @property
    def dt_next(self) -> float:
        ...
    @property
    def dt_try(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def rf_time(self) -> float:
        ...
    @property
    def t_dir(self) -> int:
        ...
class RkTimeStep1:
    """
    Fortran routine rk_time_step1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def print_err(self) -> bool | None:
        ...
    @property
    def r_err(self) -> typing.Annotated[list[float], "FixedSize(10)"]:
        ...
class RmsValue:
    """
    Fortran routine rms_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ave_val(self) -> float:
        ...
    @property
    def rms_val(self) -> float:
        ...
class Rotate3:
    """
    Fortran routine rotate3 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def angle(self) -> float:
        ...
class RotateFieldZx:
    """
    Fortran routine rotate_field_zx return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def theta(self) -> float:
        ...
class RunTimer:
    """
    Fortran routine run_timer return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def command(self) -> str:
        ...
    @property
    def time(self) -> float | None:
        ...
    @property
    def time0(self) -> float | None:
        ...
class SBodyCalc:
    """
    Fortran routine s_body_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def s_body(self) -> float:
        ...
class ScAdaptiveStep:
    """
    Fortran routine sc_adaptive_step return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dt_next(self) -> float:
        ...
    @property
    def dt_step(self) -> float:
        ...
    @property
    def include_image(self) -> bool:
        ...
class ScStep:
    """
    Fortran routine sc_step return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def include_image(self) -> bool:
        ...
    @property
    def n_emit(self) -> int:
        ...
class SetEleAttribute:
    """
    Fortran routine set_ele_attribute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_id(self) -> int:
        ...
class SetEleStatusStale:
    """
    Fortran routine set_ele_status_stale return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele(self) -> EleStruct:
        ...
    @property
    def set_slaves(self) -> bool:
        ...
    @property
    def status_group(self) -> int:
        ...
class SetFlagsForChangedIntegerAttribute:
    """
    Fortran routine set_flags_for_changed_integer_attribute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib(self) -> int:
        ...
class SetFlagsForChangedLogicalAttribute:
    """
    Fortran routine set_flags_for_changed_logical_attribute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib(self) -> bool:
        ...
class SetFlagsForChangedRealAttribute:
    """
    Fortran routine set_flags_for_changed_real_attribute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def attrib(self) -> float | None:
        ...
class SetFringeOnOff:
    """
    Fortran routine set_fringe_on_off return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def fringe_at(self) -> float:
        ...
class SetParameterInt:
    """
    Fortran routine set_parameter_int return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def param_val(self) -> int:
        ...
    @property
    def save_val(self) -> int:
        ...
    @property
    def set_val(self) -> int:
        ...
class SetParameterLogic:
    """
    Fortran routine set_parameter_logic return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def param_val(self) -> bool:
        ...
    @property
    def save_val(self) -> bool:
        ...
    @property
    def set_val(self) -> bool:
        ...
class SetParameterReal:
    """
    Fortran routine set_parameter_real return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def param_val(self) -> float:
        ...
    @property
    def save_val(self) -> float:
        ...
    @property
    def set_val(self) -> float:
        ...
class SetPtcQuiet:
    """
    Fortran routine set_ptc_quiet return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def old_val(self) -> int:
        ...
class SetPtcVerbose:
    """
    Fortran routine set_ptc_verbose return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def on(self) -> bool:
        ...
class SetTune:
    """
    Fortran routine set_tune return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ok(self) -> bool:
        ...
class SetTune3d:
    """
    Fortran routine set_tune_3d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def everything_ok(self) -> bool:
        ...
    @property
    def mask(self) -> str | None:
        ...
class SignificantDifference:
    """
    Fortran routine significant_difference return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_different(self) -> bool:
        ...
class Sinc:
    """
    Fortran routine sinc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class Sincc:
    """
    Fortran routine sincc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class SinhxX:
    """
    Fortran routine sinhx_x return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class SkipEleBlender:
    """
    Fortran routine skip_ele_blender return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def skip(self) -> bool:
        ...
class SkipHeader:
    """
    Fortran routine skip_header return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error_flag(self) -> bool:
        ...
    @property
    def ix_unit(self) -> int:
        ...
class SolQuadMat6Calc:
    """
    Fortran routine sol_quad_mat6_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def k1_in(self) -> float:
        ...
    @property
    def ks_in(self) -> float:
        ...
class SolvePsiFixedSteps:
    """
    Fortran routine solve_psi_fixed_steps return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def p(self) -> RealAlloc1D:
        ...
    @property
    def t(self) -> RealAlloc1D:
        ...
class SpaceChargeCommonStruct:
    """
    Fortran struct: space_charge_common_struct
    """
    debug: bool
    diagnostic_output_file: str
    lsc_kick_transverse_dependence: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def abs_tol_tracking(self) -> float:
        ...
    @abs_tol_tracking.setter
    def abs_tol_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def beam_chamber_height(self) -> float:
        ...
    @beam_chamber_height.setter
    def beam_chamber_height(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def cathode_strength_cutoff(self) -> float:
        ...
    @cathode_strength_cutoff.setter
    def cathode_strength_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def csr3d_mesh_size(self) -> ...:
        ...
    @property
    def ds_track_step(self) -> float:
        ...
    @ds_track_step.setter
    def ds_track_step(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dt_track_step(self) -> float:
        ...
    @dt_track_step.setter
    def dt_track_step(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lsc_sigma_cutoff(self) -> float:
        ...
    @lsc_sigma_cutoff.setter
    def lsc_sigma_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_bin(self) -> int:
        ...
    @n_bin.setter
    def n_bin(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_shield_images(self) -> int:
        ...
    @n_shield_images.setter
    def n_shield_images(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def particle_bin_span(self) -> int:
        ...
    @particle_bin_span.setter
    def particle_bin_span(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def particle_sigma_cutoff(self) -> float:
        ...
    @particle_sigma_cutoff.setter
    def particle_sigma_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rel_tol_tracking(self) -> float:
        ...
    @rel_tol_tracking.setter
    def rel_tol_tracking(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sc_min_in_bin(self) -> int:
        ...
    @sc_min_in_bin.setter
    def sc_min_in_bin(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def space_charge_mesh_size(self) -> ...:
        ...
class SpinAxisStruct:
    """
    Fortran struct: spin_axis_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def l(self) -> ...:
        ...
    @property
    def m(self) -> ...:
        ...
    @property
    def n0(self) -> ...:
        ...
class SpinMat8ResonanceStrengths:
    """
    Fortran routine spin_mat8_resonance_strengths return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def xi_diff(self) -> float:
        ...
    @property
    def xi_sum(self) -> float:
        ...
class SpinMatToEigen:
    """
    Fortran routine spin_mat_to_eigen return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def n0(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
    @property
    def orb_eval(self) -> typing.Annotated[list[complex], "FixedSize(6)"]:
        ...
    @property
    def orb_evec(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def spin_evec(self) -> typing.Annotated[list[typing.Annotated[list[complex], "FixedSize(3)"]], "FixedSize(6)"]:
        ...
class SpinOmega:
    """
    Fortran routine spin_omega return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def phase_space_coords(self) -> bool | None:
        ...
    @property
    def sign_z_vel(self) -> int:
        ...
class SpinOrbitMap1Struct:
    """
    Fortran struct: spin_orbit_map1_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def orb_mat(self) -> ...:
        ...
    @property
    def spin_q(self) -> ...:
        ...
    @property
    def vec0(self) -> ...:
        ...
class SpinOrbitMap1StructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SpinOrbitMap1Struct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SpinOrbitMap1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> SpinOrbitMap1StructArray1D:
        ...
class SpinOrbitMap1StructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SpinOrbitMap1Struct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SpinOrbitMap1Struct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class SpinPolarStruct:
    """
    Fortran struct: spin_polar_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def polarization(self) -> float:
        ...
    @polarization.setter
    def polarization(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def theta(self) -> float:
        ...
    @theta.setter
    def theta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def xi(self) -> float:
        ...
    @xi.setter
    def xi(self, arg1: typing.SupportsFloat) -> None:
        ...
class SpinQuatResonanceStrengths:
    """
    Fortran routine spin_quat_resonance_strengths return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def xi_diff(self) -> float:
        ...
    @property
    def xi_sum(self) -> float:
        ...
class SplineAkimaInterpolate:
    """
    Fortran routine spline_akima_interpolate return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def ok(self) -> bool:
        ...
    @property
    def y(self) -> float:
        ...
class SplineEvaluate:
    """
    Fortran routine spline_evaluate return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def ok(self) -> bool:
        ...
    @property
    def y(self) -> float:
        ...
class SplineStruct:
    """
    Fortran struct: spline_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def coef(self) -> ...:
        ...
    @property
    def x0(self) -> float:
        ...
    @x0.setter
    def x0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x1(self) -> float:
        ...
    @x1.setter
    def x1(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y0(self) -> float:
        ...
    @y0.setter
    def y0(self, arg1: typing.SupportsFloat) -> None:
        ...
class SplineStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SplineStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SplineStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> SplineStructArray1D:
        ...
class SplineStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SplineStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SplineStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class SplitLat:
    """
    Fortran routine split_lat return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def ix_split(self) -> int:
        ...
    @property
    def split_done(self) -> bool:
        ...
class SqrtAlpha:
    """
    Fortran routine sqrt_alpha return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y(self) -> float:
        ...
class SqrtOne:
    """
    Fortran routine sqrt_one return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ds1(self) -> float:
        ...
class StrCount:
    """
    Fortran routine str_count return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def match(self) -> str:
        ...
    @property
    def num(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class StrFirstInSet:
    """
    Fortran routine str_first_in_set return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ignore_clauses(self) -> bool | None:
        ...
    @property
    def ix_match(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def set(self) -> str:
        ...
class StrFirstNotInSet:
    """
    Fortran routine str_first_not_in_set return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_match(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def set(self) -> str:
        ...
class StrLastInSet:
    """
    Fortran routine str_last_in_set return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_match(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def set(self) -> str:
        ...
class StrLastNotInSet:
    """
    Fortran routine str_last_not_in_set return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_match(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def set(self) -> str:
        ...
class StrMatchWild:
    """
    Fortran routine str_match_wild return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def a_match(self) -> bool:
        ...
    @property
    def pat(self) -> str:
        ...
    @property
    def str(self) -> str:
        ...
class StrSubstitute:
    """
    Fortran routine str_substitute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def do_trim(self) -> bool | None:
        ...
    @property
    def ignore_escaped(self) -> bool | None:
        ...
    @property
    def str_match(self) -> str | None:
        ...
    @property
    def str_replace(self) -> str | None:
        ...
    @property
    def string(self) -> str:
        ...
class StreamEleEnd:
    """
    Fortran routine stream_ele_end return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def stream_end(self) -> int:
        ...
class StringToInt:
    """
    Fortran routine string_to_int return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def default_(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_print_flag(self) -> bool | None:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class StringToReal:
    """
    Fortran routine string_to_real return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def default_(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def err_print_flag(self) -> bool | None:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def value(self) -> float:
        ...
class StringTrim:
    """
    Fortran routine string_trim return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def in_string(self) -> str:
        ...
    @property
    def out_string(self) -> str:
        ...
    @property
    def word_len(self) -> int:
        ...
class StringTrim2:
    """
    Fortran routine string_trim2 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delimitors(self) -> str:
        ...
    @property
    def in_str(self) -> str:
        ...
    @property
    def ix_next(self) -> int:
        ...
    @property
    def ix_word(self) -> int:
        ...
    @property
    def out_str(self) -> str:
        ...
class StrongBeamSigmaCalc:
    """
    Fortran routine strong_beam_sigma_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bbi_const(self) -> float:
        ...
    @property
    def dsigma_ds(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
    @property
    def sigma(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
class StrongBeamStrength:
    """
    Fortran routine strong_beam_strength return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def strength(self) -> float:
        ...
class StrongBeamStruct:
    """
    Fortran struct: strong_beam_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dx(self) -> float:
        ...
    @dx.setter
    def dx(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dy(self) -> float:
        ...
    @dy.setter
    def dy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_slice(self) -> int:
        ...
    @ix_slice.setter
    def ix_slice(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def x_center(self) -> float:
        ...
    @x_center.setter
    def x_center(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x_sigma(self) -> float:
        ...
    @x_sigma.setter
    def x_sigma(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y_center(self) -> float:
        ...
    @y_center.setter
    def y_center(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y_sigma(self) -> float:
        ...
    @y_sigma.setter
    def y_sigma(self, arg1: typing.SupportsFloat) -> None:
        ...
class SummationRdtStruct:
    """
    Fortran struct: summation_rdt_struct
    """
    h00111: complex
    h00201: complex
    h00220: complex
    h00310: complex
    h00400: complex
    h10002: complex
    h10020: complex
    h10110: complex
    h10200: complex
    h11001: complex
    h11110: complex
    h11200: complex
    h20001: complex
    h20020: complex
    h20110: complex
    h20200: complex
    h21000: complex
    h22000: complex
    h30000: complex
    h31000: complex
    h40000: complex
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class SummationRdtStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SummationRdtStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SummationRdtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> SummationRdtStructArray1D:
        ...
class SummationRdtStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SummationRdtStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SummationRdtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class SuperBicubicInterpolation:
    """
    Fortran routine super_bicubic_interpolation return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ansy(self) -> float:
        ...
    @property
    def ansy1(self) -> float:
        ...
    @property
    def ansy2(self) -> float:
        ...
class SuperPolint:
    """
    Fortran routine super_polint return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dy(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
class SurfaceCurvatureStruct:
    """
    Fortran struct: surface_curvature_struct
    """
    has_curvature: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def elliptical(self) -> ...:
        ...
    @property
    def spherical(self) -> float:
        ...
    @spherical.setter
    def spherical(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def xy(self) -> ...:
        ...
class SurfaceDisplacementPtStruct:
    """
    Fortran struct: surface_displacement_pt_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def d2z_dxdy(self) -> float:
        ...
    @d2z_dxdy.setter
    def d2z_dxdy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dz_dx(self) -> float:
        ...
    @dz_dx.setter
    def dz_dx(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dz_dy(self) -> float:
        ...
    @dz_dy.setter
    def dz_dy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x0(self) -> float:
        ...
    @x0.setter
    def x0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y0(self) -> float:
        ...
    @y0.setter
    def y0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z0(self) -> float:
        ...
    @z0.setter
    def z0(self, arg1: typing.SupportsFloat) -> None:
        ...
class SurfaceDisplacementPtStructArray2D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SurfaceDisplacementPtStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SurfaceDisplacementPtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class SurfaceDisplacementStruct:
    """
    Fortran struct: surface_displacement_struct
    """
    active: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dr(self) -> ...:
        ...
    @property
    def pt(self) -> SurfaceDisplacementPtStructArray2D:
        ...
    @property
    def r0(self) -> ...:
        ...
class SurfaceGridDisplacement:
    """
    Fortran routine surface_grid_displacement return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
class SurfaceHMisalignPtStruct:
    """
    Fortran struct: surface_h_misalign_pt_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def rot_t(self) -> float:
        ...
    @rot_t.setter
    def rot_t(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rot_t_rms(self) -> float:
        ...
    @rot_t_rms.setter
    def rot_t_rms(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rot_y(self) -> float:
        ...
    @rot_y.setter
    def rot_y(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rot_y_rms(self) -> float:
        ...
    @rot_y_rms.setter
    def rot_y_rms(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x0(self) -> float:
        ...
    @x0.setter
    def x0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y0(self) -> float:
        ...
    @y0.setter
    def y0(self, arg1: typing.SupportsFloat) -> None:
        ...
class SurfaceHMisalignPtStructArray2D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SurfaceHMisalignPtStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SurfaceHMisalignPtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class SurfaceHMisalignStruct:
    """
    Fortran struct: surface_h_misalign_struct
    """
    active: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dr(self) -> ...:
        ...
    @property
    def pt(self) -> SurfaceHMisalignPtStructArray2D:
        ...
    @property
    def r0(self) -> ...:
        ...
class SurfaceSegmentedPtStruct:
    """
    Fortran struct: surface_segmented_pt_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dz_dx(self) -> float:
        ...
    @dz_dx.setter
    def dz_dx(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dz_dy(self) -> float:
        ...
    @dz_dy.setter
    def dz_dy(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x0(self) -> float:
        ...
    @x0.setter
    def x0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y0(self) -> float:
        ...
    @y0.setter
    def y0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z0(self) -> float:
        ...
    @z0.setter
    def z0(self, arg1: typing.SupportsFloat) -> None:
        ...
class SurfaceSegmentedPtStructArray2D:
    def __getitem__(self, arg0: typing.SupportsInt) -> SurfaceSegmentedPtStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[SurfaceSegmentedPtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class SurfaceSegmentedStruct:
    """
    Fortran struct: surface_segmented_struct
    """
    active: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dr(self) -> ...:
        ...
    @property
    def pt(self) -> SurfaceSegmentedPtStructArray2D:
        ...
    @property
    def r0(self) -> ...:
        ...
class SystemCommand:
    """
    Fortran routine system_command return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
    @property
    def line(self) -> str:
        ...
class T6ToB123:
    """
    Fortran routine t6_to_b123 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def B1(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def B2(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def B3(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class TaoAllocateDataArray:
    """
    Fortran routine tao_allocate_data_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def exact(self) -> bool | None:
        ...
    @property
    def n_data(self) -> int:
        ...
class TaoAllocateV1Var:
    """
    Fortran routine tao_allocate_v1_var return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def n_v1(self) -> int:
        ...
    @property
    def save_old(self) -> bool:
        ...
class TaoAllocateVarArray:
    """
    Fortran routine tao_allocate_var_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def default_good_user(self) -> bool:
        ...
class TaoBeamBranchStruct:
    """
    Fortran struct: tao_beam_branch_struct
    """
    beam_at_start: BeamStruct
    beam_init: BeamInitStruct
    beam_init_used: BeamInitStruct
    init_starting_distribution: bool
    track_end: str
    track_start: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_track_end(self) -> int:
        ...
    @ix_track_end.setter
    def ix_track_end(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_track_start(self) -> int:
        ...
    @ix_track_start.setter
    def ix_track_start(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoBeamEmitCalc:
    """
    Fortran routine tao_beam_emit_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def emit(self) -> float:
        ...
class TaoBeamUniStruct:
    """
    Fortran struct: tao_beam_uni_struct
    """
    always_reinit: bool
    dump_at: str
    dump_file: str
    saved_at: str
    track_beam_in_universe: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class TaoBranchIndex:
    """
    Fortran routine tao_branch_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_this(self) -> int:
        ...
class TaoBuildingWallOrientationStruct:
    """
    Fortran struct: tao_building_wall_orientation_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def theta(self) -> float:
        ...
    @theta.setter
    def theta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x_offset(self) -> float:
        ...
    @x_offset.setter
    def x_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z_offset(self) -> float:
        ...
    @z_offset.setter
    def z_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoBuildingWallPointStruct:
    """
    Fortran struct: tao_building_wall_point_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def radius(self) -> float:
        ...
    @radius.setter
    def radius(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x_center(self) -> float:
        ...
    @x_center.setter
    def x_center(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z(self) -> float:
        ...
    @z.setter
    def z(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z_center(self) -> float:
        ...
    @z_center.setter
    def z_center(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoBuildingWallPointStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoBuildingWallPointStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoBuildingWallPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoBuildingWallPointStructArray1D:
        ...
class TaoBuildingWallPointStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoBuildingWallPointStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoBuildingWallPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoBuildingWallSectionStruct:
    """
    Fortran struct: tao_building_wall_section_struct
    """
    constraint: str
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def point(self) -> ...:
        ...
class TaoBuildingWallSectionStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoBuildingWallSectionStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoBuildingWallSectionStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoBuildingWallSectionStructArray1D:
        ...
class TaoBuildingWallSectionStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoBuildingWallSectionStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoBuildingWallSectionStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoBuildingWallStruct:
    """
    Fortran struct: tao_building_wall_struct
    """
    orientation: TaoBuildingWallOrientationStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def section(self) -> ...:
        ...
class TaoCalcDataAtSPts:
    """
    Fortran routine tao_calc_data_at_s_pts return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def comp_sign(self) -> float:
        ...
class TaoChangeEle:
    """
    Fortran routine tao_change_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def update(self) -> bool:
        ...
class TaoChromCalcNeeded:
    """
    Fortran routine tao_chrom_calc_needed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_source(self) -> str:
        ...
    @property
    def data_type(self) -> str:
        ...
    @property
    def do_chrom(self) -> bool:
        ...
class TaoClipCmd:
    """
    Fortran routine tao_clip_cmd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def value1(self) -> float:
        ...
    @property
    def value2(self) -> float:
        ...
class TaoCmdHistoryRecord:
    """
    Fortran routine tao_cmd_history_record return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cmd(self) -> str:
        ...
class TaoCmdHistoryStruct:
    """
    Fortran struct: tao_cmd_history_struct
    """
    cmd: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix(self) -> int:
        ...
    @ix.setter
    def ix(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoCmdHistoryStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoCmdHistoryStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoCmdHistoryStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoCmdHistoryStructArray1D:
        ...
class TaoCmdHistoryStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoCmdHistoryStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoCmdHistoryStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoCommand:
    """
    Fortran routine tao_command return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def err_is_fatal(self) -> bool:
        ...
class TaoCommonStruct:
    """
    Fortran struct: tao_common_struct
    """
    add_measurement_noise: bool
    all_merit_weights_positive: bool
    cmd: str
    cmd_file_paused: bool
    cmd_from_cmd_file: bool
    combine_consecutive_elements_of_like_name: bool
    command_arg_has_been_executed: bool
    force_chrom_calc: bool
    force_rad_int_calc: bool
    have_datums_using_expressions: bool
    have_tracked_beam: bool
    init_beam: bool
    init_plot_needed: bool
    init_read_lat_info: bool
    init_var: bool
    lattice_calc_done: bool
    multi_turn_orbit_is_plotted: bool
    optimizer_running: bool
    print_to_terminal: bool
    rad_int_6d_calc_on: bool
    rad_int_ri_calc_on: bool
    saved_cmd_line: str
    single_mode: bool
    single_mode_buffer: str
    use_cmd_here: bool
    use_saved_beam_in_tracking: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def alpha(self) -> ...:
        ...
    @property
    def cmd_file_level(self) -> int:
        ...
    @cmd_file_level.setter
    def cmd_file_level(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def covar(self) -> ...:
        ...
    @property
    def dummy_target(self) -> float:
        ...
    @dummy_target.setter
    def dummy_target(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_beam_track_active_element(self) -> int:
        ...
    @ix_beam_track_active_element.setter
    def ix_beam_track_active_element(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_history(self) -> int:
        ...
    @ix_history.setter
    def ix_history(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_key_bank(self) -> int:
        ...
    @ix_key_bank.setter
    def ix_key_bank(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def lev_loop(self) -> int:
        ...
    @lev_loop.setter
    def lev_loop(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_alias(self) -> int:
        ...
    @n_alias.setter
    def n_alias(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_err_messages_printed(self) -> int:
        ...
    @n_err_messages_printed.setter
    def n_err_messages_printed(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_history(self) -> int:
        ...
    @n_history.setter
    def n_history(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_universes(self) -> int:
        ...
    @n_universes.setter
    def n_universes(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def plot_place_buffer(self) -> TaoPlotRegionStructArray1D:
        ...
    @property
    def valid_plot_who(self) -> ...:
        ...
class TaoConstraintTypeName:
    """
    Fortran routine tao_constraint_type_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def datum_name(self) -> str:
        ...
class TaoCurveColorStruct:
    """
    Fortran struct: tao_curve_color_struct
    """
    autoscale: bool
    data_type: str
    is_on: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def max(self) -> float:
        ...
    @max.setter
    def max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def min(self) -> float:
        ...
    @min.setter
    def min(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoCurveEleRef:
    """
    Fortran routine tao_curve_ele_ref return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def point_to_ele_ref(self) -> bool:
        ...
class TaoCurveIxUni:
    """
    Fortran routine tao_curve_ix_uni return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_uni(self) -> int:
        ...
class TaoCurveName:
    """
    Fortran routine tao_curve_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def curve_name(self) -> str:
        ...
class TaoCurveOrbitStruct:
    """
    Fortran struct: tao_curve_orbit_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def t(self) -> float:
        ...
    @t.setter
    def t(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoCurveRmsCalc:
    """
    Fortran routine tao_curve_rms_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def mean(self) -> float:
        ...
    @property
    def rms(self) -> float:
        ...
class TaoCurveStruct:
    """
    Fortran struct: tao_curve_struct
    """
    component: str
    data_index: str
    data_source: str
    data_type: str
    data_type_x: str
    draw_error_bars: bool
    draw_line: bool
    draw_symbol_index: bool
    draw_symbols: bool
    ele_ref_name: str
    hist: TaoHistogramStruct
    legend_text: str
    line: QpLineStruct
    message_text: str
    name: str
    orbit: TaoCurveOrbitStruct
    smooth_line_calc: bool
    symbol: QpSymbolStruct
    use_y2: bool
    valid: bool
    why_invalid: str
    z_color: TaoCurveColorStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def err_symb(self) -> ...:
        ...
    @property
    def g(self) -> _pybmad.TaoGraphStruct | None:
        ...
    @g.setter
    def g(self, arg1: TaoGraphStruct) -> None:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_bunch(self) -> int:
        ...
    @ix_bunch.setter
    def ix_bunch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_line(self) -> ...:
        ...
    @property
    def ix_symb(self) -> ...:
        ...
    @property
    def ix_universe(self) -> int:
        ...
    @ix_universe.setter
    def ix_universe(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_turn(self) -> int:
        ...
    @n_turn.setter
    def n_turn(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def symb_size(self) -> ...:
        ...
    @property
    def symbol_every(self) -> int:
        ...
    @symbol_every.setter
    def symbol_every(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def x_line(self) -> ...:
        ...
    @property
    def x_symb(self) -> ...:
        ...
    @property
    def y2_line(self) -> ...:
        ...
    @property
    def y_axis_scale_factor(self) -> float:
        ...
    @y_axis_scale_factor.setter
    def y_axis_scale_factor(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y_line(self) -> ...:
        ...
    @property
    def y_symb(self) -> ...:
        ...
    @property
    def z_symb(self) -> ...:
        ...
class TaoCurveStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoCurveStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoCurveStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoCurveStructArray1D:
        ...
class TaoCurveStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoCurveStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoCurveStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoD1DataStruct:
    """
    Fortran struct: tao_d1_data_struct
    """
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def d(self) -> ...:
        ...
    @property
    def d2(self) -> _pybmad.TaoD2DataStruct | None:
        ...
    @d2.setter
    def d2(self, arg1: TaoD2DataStruct) -> None:
        ...
class TaoD1DataStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoD1DataStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoD1DataStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoD1DataStructArray1D:
        ...
class TaoD1DataStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoD1DataStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoD1DataStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoD2D1Name:
    """
    Fortran routine tao_d2_d1_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def d2_d1_name(self) -> str:
        ...
class TaoD2DataStruct:
    """
    Fortran struct: tao_d2_data_struct
    """
    data_date: str
    data_file_name: str
    data_read_in: bool
    name: str
    ref_date: str
    ref_file_name: str
    ref_read_in: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def d1(self) -> TaoD1DataStructArray1D:
        ...
    @property
    def descrip(self) -> ...:
        ...
    @property
    def ix_d2_data(self) -> int:
        ...
    @ix_d2_data.setter
    def ix_d2_data(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ref(self) -> int:
        ...
    @ix_ref.setter
    def ix_ref(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_universe(self) -> int:
        ...
    @ix_universe.setter
    def ix_universe(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoD2DataStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoD2DataStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoD2DataStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoD2DataStructArray1D:
        ...
class TaoD2DataStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoD2DataStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoD2DataStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoD2DataStuffit:
    """
    Fortran routine tao_d2_data_stuffit return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def d2_name(self) -> str:
        ...
    @property
    def n_d1_data(self) -> int:
        ...
class TaoDataCheck:
    """
    Fortran routine tao_data_check return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
class TaoDataSanityCheck:
    """
    Fortran routine tao_data_sanity_check return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
class TaoDataStruct:
    """
    Fortran struct: tao_data_struct
    """
    data_source: str
    data_type: str
    ele_name: str
    ele_ref_name: str
    ele_start_name: str
    err_message_printed: bool
    exists: bool
    good_base: bool
    good_design: bool
    good_meas: bool
    good_model: bool
    good_opt: bool
    good_plot: bool
    good_ref: bool
    good_user: bool
    id: str
    merit_type: str
    spin_map: TaoSpinMapStruct
    useit_opt: bool
    useit_plot: bool
    why_invalid: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def base_value(self) -> float:
        ...
    @base_value.setter
    def base_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def d1(self) -> _pybmad.TaoD1DataStruct | None:
        ...
    @d1.setter
    def d1(self, arg1: TaoD1DataStruct) -> None:
        ...
    @property
    def delta_merit(self) -> float:
        ...
    @delta_merit.setter
    def delta_merit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def design_value(self) -> float:
        ...
    @design_value.setter
    def design_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def error_rms(self) -> float:
        ...
    @error_rms.setter
    def error_rms(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def eval_point(self) -> int:
        ...
    @eval_point.setter
    def eval_point(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def invalid_value(self) -> float:
        ...
    @invalid_value.setter
    def invalid_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_bunch(self) -> int:
        ...
    @ix_bunch.setter
    def ix_bunch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_d1(self) -> int:
        ...
    @ix_d1.setter
    def ix_d1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_dModel(self) -> int:
        ...
    @ix_dModel.setter
    def ix_dModel(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_data(self) -> int:
        ...
    @ix_data.setter
    def ix_data(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele_merit(self) -> int:
        ...
    @ix_ele_merit.setter
    def ix_ele_merit(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele_ref(self) -> int:
        ...
    @ix_ele_ref.setter
    def ix_ele_ref(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele_start(self) -> int:
        ...
    @ix_ele_start.setter
    def ix_ele_start(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_uni(self) -> int:
        ...
    @ix_uni.setter
    def ix_uni(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def meas_value(self) -> float:
        ...
    @meas_value.setter
    def meas_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def merit(self) -> float:
        ...
    @merit.setter
    def merit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def model_value(self) -> float:
        ...
    @model_value.setter
    def model_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def old_value(self) -> float:
        ...
    @old_value.setter
    def old_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ref_s_offset(self) -> float:
        ...
    @ref_s_offset.setter
    def ref_s_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ref_value(self) -> float:
        ...
    @ref_value.setter
    def ref_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s_offset(self) -> float:
        ...
    @s_offset.setter
    def s_offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def weight(self) -> float:
        ...
    @weight.setter
    def weight(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoDataStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoDataStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoDataStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoDataStructArray1D:
        ...
class TaoDataStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoDataStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoDataStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoDataUseitPlotCalc:
    """
    Fortran routine tao_data_useit_plot_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data(self) -> TaoDataStructAlloc1D:
        ...
    @property
    def most_invalid(self) -> str:
        ...
class TaoDataVarComponentStruct:
    """
    Fortran struct: tao_data_var_component_struct
    """
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def sign(self) -> float:
        ...
    @sign.setter
    def sign(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoDataVarComponentStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoDataVarComponentStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoDataVarComponentStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoDataVarComponentStructArray1D:
        ...
class TaoDataVarComponentStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoDataVarComponentStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoDataVarComponentStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoDatumHasAssociatedEle:
    """
    Fortran routine tao_datum_has_associated_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def has_associated_ele(self) -> int:
        ...
class TaoDatumIntegrate:
    """
    Fortran routine tao_datum_integrate return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def result(self) -> float:
        ...
    @property
    def valid_value(self) -> bool:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoDatumName:
    """
    Fortran routine tao_datum_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def datum_name(self) -> str:
        ...
class TaoDrawCurveData:
    """
    Fortran routine tao_draw_curve_data return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def have_data(self) -> bool:
        ...
class TaoDrawEleForFloorPlan:
    """
    Fortran routine tao_draw_ele_for_floor_plan return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def offset1(self) -> float:
        ...
    @property
    def offset2(self) -> float:
        ...
class TaoDrawHistogramData:
    """
    Fortran routine tao_draw_histogram_data return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def have_data(self) -> bool:
        ...
class TaoDrawingStruct:
    """
    Fortran struct: tao_drawing_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele_shape(self) -> TaoEleShapeStructArray1D:
        ...
class TaoDynamicApertureStruct:
    """
    Fortran struct: tao_dynamic_aperture_struct
    """
    param: ApertureParamStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a_emit(self) -> float:
        ...
    @a_emit.setter
    def a_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_emit(self) -> float:
        ...
    @b_emit.setter
    def b_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ellipse_scale(self) -> float:
        ...
    @ellipse_scale.setter
    def ellipse_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def pz(self) -> ...:
        ...
    @property
    def scan(self) -> ApertureScanStructArray1D:
        ...
class TaoEleGeometryWithMisalignments:
    """
    Fortran routine tao_ele_geometry_with_misalignments return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def valid_value(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoElePointerStruct:
    """
    Fortran struct: tao_ele_pointer_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def eles(self) -> ElePointerStructArray1D:
        ...
    @property
    def n_loc(self) -> int:
        ...
    @n_loc.setter
    def n_loc(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoElePointerStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoElePointerStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoElePointerStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoElePointerStructArray1D:
        ...
class TaoElePointerStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoElePointerStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoElePointerStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoEleShapeInfo:
    """
    Fortran routine tao_ele_shape_info return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def e_shape(self) -> TaoEleShapeStruct:
        ...
    @property
    def ix_shape_min(self) -> int | None:
        ...
    @property
    def label_name(self) -> str:
        ...
    @property
    def y1(self) -> float:
        ...
    @property
    def y2(self) -> float:
        ...
class TaoEleShapeStruct:
    """
    Fortran struct: tao_ele_shape_struct
    """
    color: str
    draw: bool
    ele_id: str
    label: str
    multi: bool
    name_ele: str
    shape: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_key(self) -> int:
        ...
    @ix_key.setter
    def ix_key(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def line_width(self) -> int:
        ...
    @line_width.setter
    def line_width(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def offset(self) -> float:
        ...
    @offset.setter
    def offset(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def size(self) -> float:
        ...
    @size.setter
    def size(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def uni(self) -> ...:
        ...
class TaoEleShapeStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoEleShapeStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoEleShapeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoEleShapeStructArray1D:
        ...
class TaoEleShapeStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoEleShapeStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoEleShapeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoEvalFloorOrbit:
    """
    Fortran routine tao_eval_floor_orbit return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def valid_value(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoEvaluateADatum:
    """
    Fortran routine tao_evaluate_a_datum return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def datum_value(self) -> float:
        ...
    @property
    def valid_value(self) -> bool:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoEvaluateDatumAtS:
    """
    Fortran routine tao_evaluate_datum_at_s return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bad_datum(self) -> bool:
        ...
    @property
    def err_str(self) -> str:
        ...
    @property
    def value(self) -> float:
        ...
class TaoEvaluateLatOrBeamData:
    """
    Fortran routine tao_evaluate_lat_or_beam_data return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def default_source(self) -> str:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def values(self) -> RealAlloc1D:
        ...
class TaoEvaluateTune:
    """
    Fortran routine tao_evaluate_tune return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def q_val(self) -> float:
        ...
class TaoFindPlotRegion:
    """
    Fortran routine tao_find_plot_region return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def region(self) -> TaoPlotRegionStruct:
        ...
class TaoFloorPlanStruct:
    """
    Fortran struct: tao_floor_plan_struct
    """
    correct_distortion: bool
    draw_building_wall: bool
    draw_only_first_pass: bool
    flip_label_side: bool
    orbit_color: str
    orbit_lattice: str
    orbit_pattern: str
    size_is_absolute: bool
    view: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def orbit_scale(self) -> float:
        ...
    @orbit_scale.setter
    def orbit_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def orbit_width(self) -> int:
        ...
    @orbit_width.setter
    def orbit_width(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def rotation(self) -> float:
        ...
    @rotation.setter
    def rotation(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoFloorToScreen:
    """
    Fortran routine tao_floor_to_screen return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def x_screen(self) -> float:
        ...
    @property
    def y_screen(self) -> float:
        ...
class TaoGetData:
    """
    Fortran routine tao_get_data return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_ix_dModel(self) -> IntAlloc1D:
        ...
    @property
    def data_meas_value(self) -> RealAlloc1D:
        ...
    @property
    def data_value(self) -> RealAlloc1D:
        ...
    @property
    def data_weight(self) -> RealAlloc1D:
        ...
class TaoGetOptVars:
    """
    Fortran routine tao_get_opt_vars return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ignore_if_not_limited(self) -> bool:
        ...
    @property
    def ignore_if_weight_is_zero(self) -> bool:
        ...
    @property
    def var_delta(self) -> RealAlloc1D:
        ...
    @property
    def var_ix(self) -> IntAlloc1D:
        ...
    @property
    def var_step(self) -> RealAlloc1D:
        ...
    @property
    def var_value(self) -> RealAlloc1D:
        ...
    @property
    def var_weight(self) -> RealAlloc1D:
        ...
class TaoGlobalStruct:
    """
    Fortran struct: tao_global_struct
    """
    beam_timer_on: bool
    blank_line_between_commands: bool
    box_plots: bool
    cmd_file_abort_on_error: bool
    concatenate_maps: bool
    debug_on: bool
    derivative_recalc: bool
    derivative_uses_design: bool
    disable_smooth_line_calc: bool
    draw_curve_off_scale_warn: bool
    expression_tree_on: bool
    external_plotting: bool
    history_file: str
    label_keys: bool
    label_lattice_elements: bool
    lat_sigma_calc_uses_emit_from: str
    lattice_calc_on: bool
    only_limit_opt_vars: bool
    opt_match_auto_recalc: bool
    opt_with_base: bool
    opt_with_ref: bool
    opti_write_var_file: bool
    optimizer: str
    optimizer_allow_user_abort: bool
    optimizer_var_limit_warn: bool
    plot_on: bool
    print_command: str
    prompt_color: str
    prompt_string: str
    quiet: str
    rad_int_user_calc_on: bool
    random_engine: str
    random_gauss_converter: str
    rf_on: bool
    single_step: bool
    srdt_use_cache: bool
    stop_on_error: bool
    svd_retreat_on_merit_increase: bool
    symbol_import: bool
    track_type: str
    var_limits_on: bool
    var_out_file: str
    verbose_on: bool
    wait_for_CR_in_single_mode: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def beam_dead_cutoff(self) -> float:
        ...
    @beam_dead_cutoff.setter
    def beam_dead_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def bunch_to_plot(self) -> int:
        ...
    @bunch_to_plot.setter
    def bunch_to_plot(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def datum_err_messages_max(self) -> int:
        ...
    @datum_err_messages_max.setter
    def datum_err_messages_max(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def de_lm_step_ratio(self) -> float:
        ...
    @de_lm_step_ratio.setter
    def de_lm_step_ratio(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def de_var_to_population_factor(self) -> float:
        ...
    @de_var_to_population_factor.setter
    def de_var_to_population_factor(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def default_branch(self) -> int:
        ...
    @default_branch.setter
    def default_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def default_universe(self) -> int:
        ...
    @default_universe.setter
    def default_universe(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def delta_e_chrom(self) -> float:
        ...
    @delta_e_chrom.setter
    def delta_e_chrom(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dmerit_stop_value(self) -> float:
        ...
    @dmerit_stop_value.setter
    def dmerit_stop_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lm_opt_deriv_reinit(self) -> float:
        ...
    @lm_opt_deriv_reinit.setter
    def lm_opt_deriv_reinit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lmdif_eps(self) -> float:
        ...
    @lmdif_eps.setter
    def lmdif_eps(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lmdif_negligible_merit(self) -> float:
        ...
    @lmdif_negligible_merit.setter
    def lmdif_negligible_merit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def max_plot_time(self) -> float:
        ...
    @max_plot_time.setter
    def max_plot_time(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def merit_stop_value(self) -> float:
        ...
    @merit_stop_value.setter
    def merit_stop_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_opti_cycles(self) -> int:
        ...
    @n_opti_cycles.setter
    def n_opti_cycles(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_opti_loops(self) -> int:
        ...
    @n_opti_loops.setter
    def n_opti_loops(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_threads(self) -> int:
        ...
    @n_threads.setter
    def n_threads(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_top10_merit(self) -> int:
        ...
    @n_top10_merit.setter
    def n_top10_merit(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def phase_units(self) -> int:
        ...
    @phase_units.setter
    def phase_units(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def random_seed(self) -> int:
        ...
    @random_seed.setter
    def random_seed(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def random_sigma_cutoff(self) -> float:
        ...
    @random_sigma_cutoff.setter
    def random_sigma_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def srdt_gen_n_slices(self) -> int:
        ...
    @srdt_gen_n_slices.setter
    def srdt_gen_n_slices(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def srdt_sxt_n_slices(self) -> int:
        ...
    @srdt_sxt_n_slices.setter
    def srdt_sxt_n_slices(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def svd_cutoff(self) -> float:
        ...
    @svd_cutoff.setter
    def svd_cutoff(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def unstable_penalty(self) -> float:
        ...
    @unstable_penalty.setter
    def unstable_penalty(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoGraphName:
    """
    Fortran routine tao_graph_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def graph_name(self) -> str:
        ...
class TaoGraphSMinMaxCalc:
    """
    Fortran routine tao_graph_s_min_max_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def s_max(self) -> float:
        ...
    @property
    def s_min(self) -> float:
        ...
class TaoGraphStruct:
    """
    Fortran struct: tao_graph_struct
    """
    allow_wrap_around: bool
    clip: bool
    curve_legend: QpLegendStruct
    curve_legend_origin: QpPointStruct
    draw_axes: bool
    draw_curve_legend: bool
    draw_grid: bool
    draw_only_good_user_data_or_vars: bool
    draw_title: bool
    floor_plan: TaoFloorPlanStruct
    is_valid: bool
    limited: bool
    margin: QpRectStruct
    name: str
    scale_margin: QpRectStruct
    text_legend_origin: QpPointStruct
    title: str
    title_suffix: str
    type: str
    why_invalid: str
    x: QpAxisStruct
    x2: QpAxisStruct
    y: QpAxisStruct
    y2: QpAxisStruct
    y2_mirrors_y: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def box(self) -> ...:
        ...
    @property
    def curve(self) -> TaoCurveStructArray1D:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_universe(self) -> int:
        ...
    @ix_universe.setter
    def ix_universe(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def p(self) -> _pybmad.TaoPlotStruct | None:
        ...
    @p.setter
    def p(self, arg1: TaoPlotStruct) -> None:
        ...
    @property
    def symbol_size_scale(self) -> float:
        ...
    @symbol_size_scale.setter
    def symbol_size_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def text_legend(self) -> ...:
        ...
    @property
    def text_legend_out(self) -> ...:
        ...
    @property
    def x_axis_scale_factor(self) -> float:
        ...
    @x_axis_scale_factor.setter
    def x_axis_scale_factor(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoGraphStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoGraphStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoGraphStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoGraphStructArray1D:
        ...
class TaoGraphStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoGraphStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoGraphStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoHistogramStruct:
    """
    Fortran struct: tao_histogram_struct
    """
    density_normalized: bool
    weight_by_charge: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def center(self) -> float:
        ...
    @center.setter
    def center(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def maximum(self) -> float:
        ...
    @maximum.setter
    def maximum(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def minimum(self) -> float:
        ...
    @minimum.setter
    def minimum(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def number(self) -> int:
        ...
    @number.setter
    def number(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def width(self) -> float:
        ...
    @width.setter
    def width(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoInitBeamInUniverse:
    """
    Fortran routine tao_init_beam_in_universe return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def comb_ds_save(self) -> float:
        ...
    @property
    def track_end(self) -> str:
        ...
    @property
    def track_start(self) -> str:
        ...
class TaoInitDataInUniverse:
    """
    Fortran routine tao_init_data_in_universe return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def keep_existing_data(self) -> bool | None:
        ...
    @property
    def n_d2_add(self) -> int:
        ...
class TaoInitFindElements:
    """
    Fortran routine tao_init_find_elements return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def eles(self) -> ElePointerStructAlloc1D:
        ...
    @property
    def found_one(self) -> bool:
        ...
class TaoInitLattice:
    """
    Fortran routine tao_init_lattice return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def lat_file(self) -> str:
        ...
class TaoInitPlotting:
    """
    Fortran routine tao_init_plotting return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def plot_file(self) -> str:
        ...
class TaoInitStruct:
    """
    Fortran struct: tao_init_struct
    """
    beam_file_arg: str
    beam_init_position_file_arg: str
    building_wall_file_arg: str
    command_arg: str
    data_file_arg: str
    debug_arg: str
    debug_switch: bool
    disable_smooth_line_calc_arg: str
    external_plotting_switch: bool
    geometry_arg: str
    hook_beam_file: str
    hook_building_wall_file: str
    hook_data_file: str
    hook_init_file: str
    hook_init_file_arg: str
    hook_lat_file: str
    hook_plot_file: str
    hook_startup_file: str
    hook_var_file: str
    init_file_arg: str
    init_file_arg_path: str
    init_name: str
    lattice_file_arg: str
    log_startup_arg: str
    no_rad_int_arg: str
    no_stopping_arg: str
    noinit_arg: str
    noplot_arg: str
    nostartup_arg: str
    parse_cmd_args: bool
    plot_file_arg: str
    prompt_color_arg: str
    quiet_arg: str
    reverse_arg: str
    rf_on_arg: str
    slice_lattice_arg: str
    start_branch_at_arg: str
    startup_file_arg: str
    symbol_import_arg: str
    unique_name_suffix: str
    var_file_arg: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class TaoInjectBeam:
    """
    Fortran routine tao_inject_beam return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def beam(self) -> BeamStruct:
        ...
    @property
    def init_ok(self) -> bool:
        ...
class TaoInjectParticle:
    """
    Fortran routine tao_inject_particle return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_branch(self) -> int:
        ...
class TaoIsValidName:
    """
    Fortran routine tao_is_valid_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoKeyInfoToStr:
    """
    Fortran routine tao_key_info_to_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def header_str(self) -> str:
        ...
    @property
    def ix_key(self) -> int:
        ...
    @property
    def ix_max_key(self) -> int:
        ...
    @property
    def ix_min_key(self) -> int:
        ...
    @property
    def key_str(self) -> str:
        ...
class TaoLatEmitCalc:
    """
    Fortran routine tao_lat_emit_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def emit(self) -> float:
        ...
class TaoLatSigmaCalcNeeded:
    """
    Fortran routine tao_lat_sigma_calc_needed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_source(self) -> str:
        ...
    @property
    def data_type(self) -> str:
        ...
    @property
    def do_lat_sigma(self) -> bool:
        ...
class TaoLatSigmaStruct:
    """
    Fortran struct: tao_lat_sigma_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def mat(self) -> ...:
        ...
class TaoLatSigmaStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoLatSigmaStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoLatSigmaStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoLatSigmaStructArray1D:
        ...
class TaoLatSigmaStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoLatSigmaStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoLatSigmaStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoLatticeBranchStruct:
    """
    Fortran struct: tao_lattice_branch_struct
    """
    bmad_normal_form: BmadNormalFormStruct
    chrom_calc_ok: bool
    emit_6d_calc_ok: bool
    has_open_match_element: bool
    mode_flip_here: bool
    modes_6d: NormalModesStruct
    modes_ri: NormalModesStruct
    orb0: CoordStruct
    plot_cache_valid: bool
    ptc_normal_form: PtcNormalFormStruct
    rad_int_calc_ok: bool
    sigma_track_ok: bool
    spin: TaoSpinPolarizationStruct
    spin_map_valid: bool
    srdt: SummationRdtStruct
    twiss_valid: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def bunch_params(self) -> BunchParamsStructArray1D:
        ...
    @property
    def bunch_params_comb(self) -> BunchTrackStructArray1D:
        ...
    @property
    def cache_n_pts(self) -> int:
        ...
    @cache_n_pts.setter
    def cache_n_pts(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def cache_x_max(self) -> float:
        ...
    @cache_x_max.setter
    def cache_x_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def cache_x_min(self) -> float:
        ...
    @cache_x_min.setter
    def cache_x_min(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def comb_ds_save(self) -> float:
        ...
    @comb_ds_save.setter
    def comb_ds_save(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def high_E_orb(self) -> CoordStructArray1D:
        ...
    @property
    def ix_ele_taylor(self) -> int:
        ...
    @ix_ele_taylor.setter
    def ix_ele_taylor(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_rad_int_cache(self) -> int:
        ...
    @ix_rad_int_cache.setter
    def ix_rad_int_cache(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ref_taylor(self) -> int:
        ...
    @ix_ref_taylor.setter
    def ix_ref_taylor(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def lat_sigma(self) -> TaoLatSigmaStructArray1D:
        ...
    @property
    def low_E_orb(self) -> CoordStructArray1D:
        ...
    @property
    def orbit(self) -> CoordStructArray1D:
        ...
    @property
    def plot_cache(self) -> TaoPlotCacheStructArray1D:
        ...
    @property
    def spin_ele(self) -> TaoSpinEleStructArray1D:
        ...
    @property
    def tao_lat(self) -> _pybmad.TaoLatticeStruct | None:
        ...
    @tao_lat.setter
    def tao_lat(self, arg1: TaoLatticeStruct) -> None:
        ...
    @property
    def taylor_save(self) -> TaylorStructArray1D:
        ...
    @property
    def track_state(self) -> int:
        ...
    @track_state.setter
    def track_state(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoLatticeBranchStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoLatticeBranchStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoLatticeBranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoLatticeBranchStructArray1D:
        ...
class TaoLatticeBranchStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoLatticeBranchStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoLatticeBranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoLatticeCalc:
    """
    Fortran routine tao_lattice_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def calc_ok(self) -> bool:
        ...
    @property
    def print_err(self) -> bool:
        ...
class TaoLatticeStruct:
    """
    Fortran struct: tao_lattice_struct
    """
    high_E_lat: LatStruct
    lat: LatStruct
    low_E_lat: LatStruct
    name: str
    rad_int_by_ele_6d: RadIntAllEleStruct
    rad_int_by_ele_ri: RadIntAllEleStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def tao_branch(self) -> TaoLatticeBranchStructArray1D:
        ...
class TaoLoadThisDatum:
    """
    Fortran routine tao_load_this_datum return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def datum_value(self) -> float:
        ...
    @property
    def valid_value(self) -> bool:
        ...
    @property
    def why_invalid(self) -> str | None:
        ...
class TaoLocateAllElements:
    """
    Fortran routine tao_locate_all_elements return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def eles(self) -> ElePointerStructAlloc1D:
        ...
    @property
    def err(self) -> bool:
        ...
class TaoLocateElements:
    """
    Fortran routine tao_locate_elements return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def above_ubound_is_err(self) -> bool | None:
        ...
    @property
    def eles(self) -> ElePointerStructAlloc1D:
        ...
    @property
    def err(self) -> bool:
        ...
class TaoMerit:
    """
    Fortran routine tao_merit return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def calc_ok(self) -> bool:
        ...
    @property
    def this_merit(self) -> float:
        ...
class TaoModelBranchStruct:
    """
    Fortran struct: tao_model_branch_struct
    """
    beam: TaoBeamBranchStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele(self) -> TaoModelElementStructArray1D:
        ...
class TaoModelBranchStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoModelBranchStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoModelBranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoModelBranchStructArray1D:
        ...
class TaoModelBranchStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoModelBranchStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoModelBranchStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoModelElementStruct:
    """
    Fortran struct: tao_model_element_struct
    """
    beam: BeamStruct
    save_beam_internally: bool
    save_beam_to_file: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class TaoModelElementStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoModelElementStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoModelElementStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoModelElementStructArray1D:
        ...
class TaoModelElementStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoModelElementStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoModelElementStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoNextWord:
    """
    Fortran routine tao_next_word return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def word(self) -> str:
        ...
class TaoOneTurnMapCalcNeeded:
    """
    Fortran routine tao_one_turn_map_calc_needed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_source(self) -> str:
        ...
    @property
    def data_type(self) -> str:
        ...
    @property
    def do_one_turn_map(self) -> bool:
        ...
class TaoOpenFile:
    """
    Fortran routine tao_open_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def file(self) -> str:
        ...
    @property
    def iunit(self) -> int:
        ...
class TaoOpenScratchFile:
    """
    Fortran routine tao_open_scratch_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def iu(self) -> int:
        ...
class TaoOptimizationStatus:
    """
    Fortran routine tao_optimization_status return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def why_str(self) -> str:
        ...
class TaoParamValueAtS:
    """
    Fortran routine tao_param_value_at_s return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bad_datum(self) -> bool:
        ...
    @property
    def dat_name(self) -> str:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def print_err(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoParseCommandArgs:
    """
    Fortran routine tao_parse_command_args return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cmd_line(self) -> str | None:
        ...
    @property
    def error(self) -> bool:
        ...
class TaoParseElementParamStr:
    """
    Fortran routine tao_parse_element_param_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def component(self) -> str:
        ...
    @property
    def element(self) -> str:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def parameter(self) -> str:
        ...
    @property
    def uni(self) -> str:
        ...
    @property
    def where(self) -> int:
        ...
class TaoParticleDataValue:
    """
    Fortran routine tao_particle_data_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def value(self) -> RealAlloc1D:
        ...
class TaoPickUniverse:
    """
    Fortran routine tao_pick_universe return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def explicit_uni(self) -> bool:
        ...
    @property
    def ix_uni(self) -> int:
        ...
    @property
    def name_out(self) -> str:
        ...
    @property
    def picked(self) -> BoolAlloc1D:
        ...
class TaoPingScaleStruct:
    """
    Fortran struct: tao_ping_scale_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a_mode_meas(self) -> float:
        ...
    @a_mode_meas.setter
    def a_mode_meas(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def a_mode_ref(self) -> float:
        ...
    @a_mode_ref.setter
    def a_mode_ref(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_mode_meas(self) -> float:
        ...
    @b_mode_meas.setter
    def b_mode_meas(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_mode_ref(self) -> float:
        ...
    @b_mode_ref.setter
    def b_mode_ref(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoPlotCacheStruct:
    """
    Fortran struct: tao_plot_cache_struct
    """
    ele_to_s: EleStruct
    err: bool
    orbit: CoordStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class TaoPlotCacheStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoPlotCacheStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoPlotCacheStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoPlotCacheStructArray1D:
        ...
class TaoPlotCacheStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoPlotCacheStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoPlotCacheStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoPlotPageStruct:
    """
    Fortran struct: tao_plot_page_struct
    """
    border: QpRectStruct
    delete_overlapping_plots: bool
    draw_graph_title_suffix: bool
    floor_plan: TaoDrawingStruct
    lat_layout: TaoDrawingStruct
    plot_display_type: str
    subtitle: TaoTitleStruct
    title: TaoTitleStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def axis_label_text_scale(self) -> float:
        ...
    @axis_label_text_scale.setter
    def axis_label_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def axis_number_text_scale(self) -> float:
        ...
    @axis_number_text_scale.setter
    def axis_number_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def floor_plan_shape_scale(self) -> float:
        ...
    @floor_plan_shape_scale.setter
    def floor_plan_shape_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def floor_plan_text_scale(self) -> float:
        ...
    @floor_plan_text_scale.setter
    def floor_plan_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def graph_title_text_scale(self) -> float:
        ...
    @graph_title_text_scale.setter
    def graph_title_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def id_window(self) -> int:
        ...
    @id_window.setter
    def id_window(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def key_table_text_scale(self) -> float:
        ...
    @key_table_text_scale.setter
    def key_table_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lat_layout_shape_scale(self) -> float:
        ...
    @lat_layout_shape_scale.setter
    def lat_layout_shape_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def lat_layout_text_scale(self) -> float:
        ...
    @lat_layout_text_scale.setter
    def lat_layout_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def legend_text_scale(self) -> float:
        ...
    @legend_text_scale.setter
    def legend_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def main_title_text_scale(self) -> float:
        ...
    @main_title_text_scale.setter
    def main_title_text_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_curve_pts(self) -> int:
        ...
    @n_curve_pts.setter
    def n_curve_pts(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def pattern(self) -> TaoShapePatternStructArray1D:
        ...
    @property
    def region(self) -> TaoPlotRegionStructArray1D:
        ...
    @property
    def size(self) -> ...:
        ...
    @property
    def template_(self) -> TaoPlotStructArray1D:
        ...
    @property
    def text_height(self) -> float:
        ...
    @text_height.setter
    def text_height(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoPlotRegionStruct:
    """
    Fortran struct: tao_plot_region_struct
    """
    list_with_show_plot_command: bool
    name: str
    plot: TaoPlotStruct
    setup_done: bool
    visible: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def location(self) -> ...:
        ...
class TaoPlotRegionStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoPlotRegionStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoPlotRegionStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoPlotRegionStructArray1D:
        ...
class TaoPlotRegionStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoPlotRegionStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoPlotRegionStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoPlotStruct:
    """
    Fortran struct: tao_plot_struct
    """
    autoscale_gang_x: bool
    autoscale_gang_y: bool
    autoscale_x: bool
    autoscale_y: bool
    default_plot: bool
    description: str
    list_with_show_plot_command: bool
    name: str
    phantom: bool
    type: str
    x_axis_type: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def graph(self) -> TaoGraphStructArray1D:
        ...
    @property
    def ix_plot(self) -> int:
        ...
    @ix_plot.setter
    def ix_plot(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_curve_pts(self) -> int:
        ...
    @n_curve_pts.setter
    def n_curve_pts(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def r(self) -> _pybmad.TaoPlotRegionStruct | None:
        ...
    @r.setter
    def r(self, arg1: TaoPlotRegionStruct) -> None:
        ...
class TaoPlotStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoPlotStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoPlotStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoPlotStructArray1D:
        ...
class TaoPlotStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoPlotStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoPlotStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoPointerToDatumEle:
    """
    Fortran routine tao_pointer_to_datum_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele(self) -> EleStruct:
        ...
    @property
    def ele_name(self) -> str:
        ...
    @property
    def valid(self) -> bool:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoPointerToEleShape:
    """
    Fortran routine tao_pointer_to_ele_shape return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dat_var_name(self) -> str:
        ...
    @property
    def dat_var_value(self) -> float:
        ...
    @property
    def ix_shape_min(self) -> int | None:
        ...
class TaoPointerToUniverseInt:
    """
    Fortran routine tao_pointer_to_universe_int return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_uni(self) -> int:
        ...
    @property
    def neg2_to_default(self) -> bool | None:
        ...
class TaoPointerToUniverseStr:
    """
    Fortran routine tao_pointer_to_universe_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def neg2_to_default(self) -> bool | None:
        ...
    @property
    def string(self) -> str:
        ...
class TaoPointerToUniverses:
    """
    Fortran routine tao_pointer_to_universes return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def explicit_uni(self) -> bool:
        ...
    @property
    def name_out(self) -> str:
        ...
    @property
    def unis(self) -> TaoUniversePointerStructAlloc1D:
        ...
class TaoRadIntCalcNeeded:
    """
    Fortran routine tao_rad_int_calc_needed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_source(self) -> str:
        ...
    @property
    def data_type(self) -> str:
        ...
    @property
    def do_rad_int(self) -> bool:
        ...
class TaoReExecute:
    """
    Fortran routine tao_re_execute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def string(self) -> str:
        ...
class TaoReadCmd:
    """
    Fortran routine tao_read_cmd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def file(self) -> str:
        ...
    @property
    def which(self) -> str:
        ...
class TaoReadPhaseSpaceIndex:
    """
    Fortran routine tao_read_phase_space_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_ps(self) -> int:
        ...
class TaoRemoveBlankCharacters:
    """
    Fortran routine tao_remove_blank_characters return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class TaoScaleGraph:
    """
    Fortran routine tao_scale_graph return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def y2_range(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
    @property
    def y_range(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
class TaoSetCalculateCmd:
    """
    Fortran routine tao_set_calculate_cmd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def switch_(self) -> str | None:
        ...
class TaoSetDataCmd:
    """
    Fortran routine tao_set_data_cmd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def silent(self) -> bool | None:
        ...
class TaoSetElementsCmd:
    """
    Fortran routine tao_set_elements_cmd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def update(self) -> bool:
        ...
class TaoSetFloorPlanAxisLabel:
    """
    Fortran routine tao_set_floor_plan_axis_label return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def which(self) -> str:
        ...
class TaoSetIntegerValue:
    """
    Fortran routine tao_set_integer_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def var(self) -> int:
        ...
class TaoSetLogicalValue:
    """
    Fortran routine tao_set_logical_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def var(self) -> bool:
        ...
class TaoSetQpAxisStruct:
    """
    Fortran routine tao_set_qp_axis_struct return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def ix_uni(self) -> int:
        ...
class TaoSetQpPointStruct:
    """
    Fortran routine tao_set_qp_point_struct return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def ix_uni(self) -> int:
        ...
class TaoSetQpRectStruct:
    """
    Fortran routine tao_set_qp_rect_struct return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def ix_uni(self) -> int:
        ...
class TaoSetRealValue:
    """
    Fortran routine tao_set_real_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def error(self) -> bool:
        ...
    @property
    def var(self) -> float:
        ...
class TaoShapePatternPointStruct:
    """
    Fortran struct: tao_shape_pattern_point_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def radius(self) -> float:
        ...
    @radius.setter
    def radius(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoShapePatternPointStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoShapePatternPointStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoShapePatternPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoShapePatternPointStructArray1D:
        ...
class TaoShapePatternPointStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoShapePatternPointStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoShapePatternPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoShapePatternStruct:
    """
    Fortran struct: tao_shape_pattern_struct
    """
    line: QpLineStruct
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def pt(self) -> ...:
        ...
class TaoShapePatternStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoShapePatternStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoShapePatternStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoShapePatternStructArray1D:
        ...
class TaoShapePatternStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoShapePatternStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoShapePatternStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoSpinDnDpzStruct:
    """
    Fortran struct: tao_spin_dn_dpz_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def partial(self) -> ...:
        ...
    @property
    def partial2(self) -> ...:
        ...
    @property
    def vec(self) -> ...:
        ...
class TaoSpinEleStruct:
    """
    Fortran struct: tao_spin_ele_struct
    """
    dn_dpz: TaoSpinDnDpzStruct
    valid: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def orb_eigen_val(self) -> ...:
        ...
    @property
    def orb_eigen_vec(self) -> ...:
        ...
    @property
    def spin_eigen_vec(self) -> ...:
        ...
class TaoSpinEleStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoSpinEleStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoSpinEleStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoSpinEleStructArray1D:
        ...
class TaoSpinEleStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoSpinEleStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoSpinEleStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoSpinMapStruct:
    """
    Fortran struct: tao_spin_map_struct
    """
    axis0: SpinAxisStruct
    axis1: SpinAxisStruct
    axis_input: SpinAxisStruct
    map1: SpinOrbitMap1Struct
    valid: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ref(self) -> int:
        ...
    @ix_ref.setter
    def ix_ref(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_uni(self) -> int:
        ...
    @ix_uni.setter
    def ix_uni(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def mat8(self) -> ...:
        ...
class TaoSpinMatricesCalcNeeded:
    """
    Fortran routine tao_spin_matrices_calc_needed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_source(self) -> str:
        ...
    @property
    def data_type(self) -> str:
        ...
    @property
    def do_calc(self) -> bool:
        ...
class TaoSpinPolarizationStruct:
    """
    Fortran struct: tao_spin_polarization_struct
    """
    q_1turn: SpinOrbitMap1Struct
    valid: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def depol_rate(self) -> float:
        ...
    @depol_rate.setter
    def depol_rate(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def depol_rate_partial(self) -> ...:
        ...
    @property
    def depol_rate_partial2(self) -> ...:
        ...
    @property
    def integral_1ns(self) -> float:
        ...
    @integral_1ns.setter
    def integral_1ns(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def integral_bdn(self) -> float:
        ...
    @integral_bdn.setter
    def integral_bdn(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def integral_bn(self) -> float:
        ...
    @integral_bn.setter
    def integral_bn(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def integral_dn2(self) -> float:
        ...
    @integral_dn2.setter
    def integral_dn2(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def pol_limit_dk(self) -> float:
        ...
    @pol_limit_dk.setter
    def pol_limit_dk(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def pol_limit_dk_partial(self) -> ...:
        ...
    @property
    def pol_limit_dk_partial2(self) -> ...:
        ...
    @property
    def pol_limit_st(self) -> float:
        ...
    @pol_limit_st.setter
    def pol_limit_st(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def pol_rate_bks(self) -> float:
        ...
    @pol_rate_bks.setter
    def pol_rate_bks(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def q_ele(self) -> SpinOrbitMap1StructArray1D:
        ...
    @property
    def tune(self) -> float:
        ...
    @tune.setter
    def tune(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoSplitComponent:
    """
    Fortran routine tao_split_component return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def comp(self) -> TaoDataVarComponentStructAlloc1D:
        ...
    @property
    def err(self) -> bool:
        ...
class TaoSrdtCalcNeeded:
    """
    Fortran routine tao_srdt_calc_needed return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def data_source(self) -> str:
        ...
    @property
    def data_type(self) -> str:
        ...
    @property
    def do_srdt(self) -> int:
        ...
class TaoSubinUniNumber:
    """
    Fortran routine tao_subin_uni_number return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def name_out(self) -> str:
        ...
    @property
    def ok(self) -> bool:
        ...
class TaoSuperUniverseStruct:
    """
    Fortran struct: tao_super_universe_struct
    """
    building_wall: TaoBuildingWallStruct
    com: TaoCommonStruct
    global_: TaoGlobalStruct
    init: TaoInitStruct
    initialized: bool
    plot_page: TaoPlotPageStruct
    wave: TaoWaveStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def history(self) -> ...:
        ...
    @property
    def key(self) -> ...:
        ...
    @property
    def n_v1_var_used(self) -> int:
        ...
    @n_v1_var_used.setter
    def n_v1_var_used(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_var_used(self) -> int:
        ...
    @n_var_used.setter
    def n_var_used(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def u(self) -> ...:
        ...
    @property
    def v1_var(self) -> ...:
        ...
    @property
    def var(self) -> ...:
        ...
class TaoTitleStruct:
    """
    Fortran struct: tao_title_struct
    """
    draw_it: bool
    justify: str
    string: str
    units: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoToChangeNumber:
    """
    Fortran routine tao_to_change_number return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def abs_or_rel(self) -> str:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def n_size(self) -> int:
        ...
    @property
    def num_str(self) -> str:
        ...
class TaoToInt:
    """
    Fortran routine tao_to_int return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def i_int(self) -> int:
        ...
    @property
    def str(self) -> str:
        ...
class TaoToPhaseAndCouplingReading:
    """
    Fortran routine tao_to_phase_and_coupling_reading return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def bpm_data(self) -> BpmPhaseCouplingStruct:
        ...
    @property
    def valid_value(self) -> bool:
        ...
    @property
    def why_invalid(self) -> str:
        ...
class TaoToReal:
    """
    Fortran routine tao_to_real return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
class TaoTooManyParticlesLost:
    """
    Fortran routine tao_too_many_particles_lost return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def no_beam(self) -> bool:
        ...
class TaoTrackingEleIndex:
    """
    Fortran routine tao_tracking_ele_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @property
    def ix_ele(self) -> int:
        ...
class TaoUniverseCalcStruct:
    """
    Fortran struct: tao_universe_calc_struct
    """
    chrom_for_data: bool
    chrom_for_plotting: bool
    dynamic_aperture: bool
    lat_sigma_for_data: bool
    lat_sigma_for_plotting: bool
    lattice: bool
    one_turn_map: bool
    rad_int_for_data: bool
    rad_int_for_plotting: bool
    spin_matrices: bool
    track: bool
    twiss: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def srdt_for_data(self) -> int:
        ...
    @srdt_for_data.setter
    def srdt_for_data(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoUniverseIndex:
    """
    Fortran routine tao_universe_index return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def i_this_uni(self) -> int:
        ...
class TaoUniversePointerStruct:
    """
    Fortran struct: tao_universe_pointer_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def u(self) -> _pybmad.TaoUniverseStruct | None:
        ...
    @u.setter
    def u(self, arg1: TaoUniverseStruct) -> None:
        ...
class TaoUniversePointerStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoUniversePointerStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoUniversePointerStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoUniversePointerStructArray1D:
        ...
class TaoUniversePointerStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoUniversePointerStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoUniversePointerStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoUniverseStruct:
    """
    Fortran struct: tao_universe_struct
    """
    beam: TaoBeamUniStruct
    calc: TaoUniverseCalcStruct
    design_same_as_previous: bool
    dynamic_aperture: TaoDynamicApertureStruct
    ele_order: LatEleOrderStruct
    is_on: bool
    picked_uni: bool
    ping_scale: TaoPingScaleStruct
    scratch_lat: LatStruct
    spin_map: TaoSpinMapStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def base(self) -> _pybmad.TaoLatticeStruct | None:
        ...
    @base.setter
    def base(self, arg1: TaoLatticeStruct) -> None:
        ...
    @property
    def d2_data(self) -> TaoD2DataStructArray1D:
        ...
    @property
    def dModel_dVar(self) -> ...:
        ...
    @property
    def data(self) -> TaoDataStructArray1D:
        ...
    @property
    def design(self) -> _pybmad.TaoLatticeStruct | None:
        ...
    @design.setter
    def design(self, arg1: TaoLatticeStruct) -> None:
        ...
    @property
    def ix_uni(self) -> int:
        ...
    @ix_uni.setter
    def ix_uni(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def model(self) -> _pybmad.TaoLatticeStruct | None:
        ...
    @model.setter
    def model(self, arg1: TaoLatticeStruct) -> None:
        ...
    @property
    def model_branch(self) -> TaoModelBranchStructArray1D:
        ...
    @property
    def n_d2_data_used(self) -> int:
        ...
    @n_d2_data_used.setter
    def n_d2_data_used(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_data_used(self) -> int:
        ...
    @n_data_used.setter
    def n_data_used(self, arg1: typing.SupportsInt) -> None:
        ...
class TaoUniverseStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoUniverseStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoUniverseStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoUniverseStructArray1D:
        ...
class TaoUniverseStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoUniverseStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoUniverseStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoV1VarStruct:
    """
    Fortran struct: tao_v1_var_struct
    """
    name: str
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ix_v1_var(self) -> int:
        ...
    @ix_v1_var.setter
    def ix_v1_var(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def v(self) -> TaoVarStructArray1D:
        ...
class TaoV1VarStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoV1VarStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoV1VarStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoV1VarStructArray1D:
        ...
class TaoV1VarStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoV1VarStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoV1VarStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoVar1Name:
    """
    Fortran routine tao_var1_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def var1_name(self) -> str:
        ...
class TaoVarAttribName:
    """
    Fortran routine tao_var_attrib_name return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def var_attrib_name(self) -> str:
        ...
class TaoVarSlaveStruct:
    """
    Fortran struct: tao_var_slave_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def base_value(self) -> float:
        ...
    @base_value.setter
    def base_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_uni(self) -> int:
        ...
    @ix_uni.setter
    def ix_uni(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def model_value(self) -> float:
        ...
    @model_value.setter
    def model_value(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoVarSlaveStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoVarSlaveStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoVarSlaveStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoVarSlaveStructArray1D:
        ...
class TaoVarSlaveStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoVarSlaveStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoVarSlaveStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoVarStruct:
    """
    Fortran struct: tao_var_struct
    """
    attrib_name: str
    ele_name: str
    exists: bool
    good_opt: bool
    good_plot: bool
    good_user: bool
    good_var: bool
    id: str
    key_bound: bool
    merit_type: str
    useit_opt: bool
    useit_plot: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def base_value(self) -> float:
        ...
    @base_value.setter
    def base_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def correction_value(self) -> float:
        ...
    @correction_value.setter
    def correction_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dMerit_dVar(self) -> float:
        ...
    @dMerit_dVar.setter
    def dMerit_dVar(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def delta_merit(self) -> float:
        ...
    @delta_merit.setter
    def delta_merit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def design_value(self) -> float:
        ...
    @design_value.setter
    def design_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def extend_val(self) -> float:
        ...
    @extend_val.setter
    def extend_val(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def high_lim(self) -> float:
        ...
    @high_lim.setter
    def high_lim(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_attrib(self) -> int:
        ...
    @ix_attrib.setter
    def ix_attrib(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_dvar(self) -> int:
        ...
    @ix_dvar.setter
    def ix_dvar(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_key_table(self) -> int:
        ...
    @ix_key_table.setter
    def ix_key_table(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_v1(self) -> int:
        ...
    @ix_v1.setter
    def ix_v1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_var(self) -> int:
        ...
    @ix_var.setter
    def ix_var(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def key_delta(self) -> float:
        ...
    @key_delta.setter
    def key_delta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def key_val0(self) -> float:
        ...
    @key_val0.setter
    def key_val0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def low_lim(self) -> float:
        ...
    @low_lim.setter
    def low_lim(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def meas_value(self) -> float:
        ...
    @meas_value.setter
    def meas_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def merit(self) -> float:
        ...
    @merit.setter
    def merit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def model_value(self) -> float:
        ...
    @model_value.setter
    def model_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def old_value(self) -> float:
        ...
    @old_value.setter
    def old_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ref_value(self) -> float:
        ...
    @ref_value.setter
    def ref_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def scratch_value(self) -> float:
        ...
    @scratch_value.setter
    def scratch_value(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def slave(self) -> ...:
        ...
    @property
    def step(self) -> float:
        ...
    @step.setter
    def step(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def v1(self) -> _pybmad.TaoV1VarStruct | None:
        ...
    @v1.setter
    def v1(self, arg1: TaoV1VarStruct) -> None:
        ...
    @property
    def weight(self) -> float:
        ...
    @weight.setter
    def weight(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoVarStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoVarStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoVarStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoVarStructArray1D:
        ...
class TaoVarStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoVarStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoVarStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoWaveCmd:
    """
    Fortran routine tao_wave_cmd return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class TaoWaveFit:
    """
    Fortran routine tao_wave_fit return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def coef(self) -> RealAlloc1D:
        ...
    @property
    def rms(self) -> RealAlloc1D:
        ...
class TaoWaveKickPtStruct:
    """
    Fortran struct: tao_wave_kick_pt_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp(self) -> float:
        ...
    @amp.setter
    def amp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ele(self) -> _pybmad.EleStruct | None:
        ...
    @ele.setter
    def ele(self, arg1: EleStruct) -> None:
        ...
    @property
    def ix_dat_before_kick(self) -> int:
        ...
    @ix_dat_before_kick.setter
    def ix_dat_before_kick(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi_r(self) -> float:
        ...
    @phi_r.setter
    def phi_r(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi_s(self) -> float:
        ...
    @phi_s.setter
    def phi_s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoWaveKickPtStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoWaveKickPtStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoWaveKickPtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaoWaveKickPtStructArray1D:
        ...
class TaoWaveKickPtStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaoWaveKickPtStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaoWaveKickPtStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaoWaveStruct:
    """
    Fortran struct: tao_wave_struct
    """
    base_graph: TaoGraphStruct
    data_type: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp_a(self) -> ...:
        ...
    @property
    def amp_b(self) -> ...:
        ...
    @property
    def amp_ba(self) -> ...:
        ...
    @property
    def amp_ba_r(self) -> float:
        ...
    @amp_ba_r.setter
    def amp_ba_r(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def amp_ba_s(self) -> float:
        ...
    @amp_ba_s.setter
    def amp_ba_s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def chi_a(self) -> float:
        ...
    @chi_a.setter
    def chi_a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def chi_ba(self) -> float:
        ...
    @chi_ba.setter
    def chi_ba(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def chi_c(self) -> float:
        ...
    @chi_c.setter
    def chi_c(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def coef_a(self) -> ...:
        ...
    @property
    def coef_b(self) -> ...:
        ...
    @property
    def coef_ba(self) -> ...:
        ...
    @property
    def d1_dat(self) -> _pybmad.TaoD1DataStruct | None:
        ...
    @d1_dat.setter
    def d1_dat(self, arg1: TaoD1DataStruct) -> None:
        ...
    @property
    def i_a1(self) -> int:
        ...
    @i_a1.setter
    def i_a1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def i_a2(self) -> int:
        ...
    @i_a2.setter
    def i_a2(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def i_b1(self) -> int:
        ...
    @i_b1.setter
    def i_b1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def i_b2(self) -> int:
        ...
    @i_b2.setter
    def i_b2(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def i_curve_wrap_pt(self) -> int:
        ...
    @i_curve_wrap_pt.setter
    def i_curve_wrap_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_a1(self) -> int:
        ...
    @ix_a1.setter
    def ix_a1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_a2(self) -> int:
        ...
    @ix_a2.setter
    def ix_a2(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_b1(self) -> int:
        ...
    @ix_b1.setter
    def ix_b1(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_b2(self) -> int:
        ...
    @ix_b2.setter
    def ix_b2(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_data(self) -> ...:
        ...
    @property
    def kick(self) -> ...:
        ...
    @property
    def n_a(self) -> int:
        ...
    @n_a.setter
    def n_a(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_b(self) -> int:
        ...
    @n_b.setter
    def n_b(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_func(self) -> int:
        ...
    @n_func.setter
    def n_func(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_kick(self) -> int:
        ...
    @n_kick.setter
    def n_kick(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def region(self) -> _pybmad.TaoPlotRegionStruct | None:
        ...
    @region.setter
    def region(self, arg1: TaoPlotRegionStruct) -> None:
        ...
    @property
    def rms_phi(self) -> float:
        ...
    @rms_phi.setter
    def rms_phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_phi_r(self) -> float:
        ...
    @rms_phi_r.setter
    def rms_phi_r(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_phi_s(self) -> float:
        ...
    @rms_phi_s.setter
    def rms_phi_s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_a(self) -> float:
        ...
    @rms_rel_a.setter
    def rms_rel_a(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_ar(self) -> float:
        ...
    @rms_rel_ar.setter
    def rms_rel_ar(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_as(self) -> float:
        ...
    @rms_rel_as.setter
    def rms_rel_as(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_b(self) -> float:
        ...
    @rms_rel_b.setter
    def rms_rel_b(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_br(self) -> float:
        ...
    @rms_rel_br.setter
    def rms_rel_br(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_bs(self) -> float:
        ...
    @rms_rel_bs.setter
    def rms_rel_bs(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_k(self) -> float:
        ...
    @rms_rel_k.setter
    def rms_rel_k(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_kr(self) -> float:
        ...
    @rms_rel_kr.setter
    def rms_rel_kr(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def rms_rel_ks(self) -> float:
        ...
    @rms_rel_ks.setter
    def rms_rel_ks(self, arg1: typing.SupportsFloat) -> None:
        ...
class TaoXScaleGraph:
    """
    Fortran routine tao_x_scale_graph return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def have_scaled(self) -> bool | None:
        ...
    @property
    def include_wall(self) -> bool | None:
        ...
    @property
    def x_max(self) -> float:
        ...
    @property
    def x_min(self) -> float:
        ...
class TaperMagStrengths:
    """
    Fortran routine taper_mag_strengths return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
class TargetMinMaxCalc:
    """
    Fortran routine target_min_max_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def phi_max(self) -> float:
        ...
    @property
    def phi_min(self) -> float:
        ...
    @property
    def y_max(self) -> float:
        ...
    @property
    def y_min(self) -> float:
        ...
class TargetPointStruct:
    """
    Fortran struct: target_point_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def r(self) -> ...:
        ...
class TargetPointStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TargetPointStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TargetPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TargetPointStructArray1D:
        ...
class TargetPointStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TargetPointStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TargetPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TargetRotMats:
    """
    Fortran routine target_rot_mats return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def w_to_ele(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
        ...
    @property
    def w_to_target(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
        ...
class TaylorInverse:
    """
    Fortran routine taylor_inverse return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def taylor_inv(self) -> TaylorStructAlloc1D:
        ...
class TaylorStruct:
    """
    Fortran struct: taylor_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ref(self) -> float:
        ...
    @ref.setter
    def ref(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def term(self) -> TaylorTermStructArray1D:
        ...
class TaylorStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaylorStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaylorStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaylorStructArray1D:
        ...
class TaylorStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaylorStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaylorStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TaylorTermStruct:
    """
    Fortran struct: taylor_term_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def coef(self) -> float:
        ...
    @coef.setter
    def coef(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def expn(self) -> ...:
        ...
class TaylorTermStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaylorTermStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaylorTermStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TaylorTermStructArray1D:
        ...
class TaylorTermStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TaylorTermStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TaylorTermStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TestBunchStructArray:
    """
    Fortran routine test_bunch_struct_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> BunchStructAlloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestBunchStructScalar:
    """
    Fortran routine test_bunch_struct_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_out(self) -> BunchStruct:
        ...
class TestCharacterScalar:
    """
    Fortran routine test_character_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> str:
        ...
    @property
    def val_inout_opt(self) -> str | None:
        ...
    @property
    def val_out(self) -> str:
        ...
class TestComplexArray:
    """
    Fortran routine test_complex_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> ComplexAlloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestComplexScalar:
    """
    Fortran routine test_complex_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> complex:
        ...
    @property
    def val_inout_opt(self) -> complex | None:
        ...
    @property
    def val_out(self) -> complex:
        ...
class TestInteger8Array:
    """
    Fortran routine test_integer8_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> Int8Alloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestInteger8Scalar:
    """
    Fortran routine test_integer8_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> int:
        ...
    @property
    def val_inout_opt(self) -> int | None:
        ...
    @property
    def val_out(self) -> int:
        ...
class TestIntegerArray:
    """
    Fortran routine test_integer_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> IntAlloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestIntegerScalar:
    """
    Fortran routine test_integer_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> int:
        ...
    @property
    def val_inout_opt(self) -> int | None:
        ...
    @property
    def val_out(self) -> int:
        ...
class TestLogicalArray:
    """
    Fortran routine test_logical_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> BoolAlloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestLogicalScalar:
    """
    Fortran routine test_logical_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> bool:
        ...
    @property
    def val_inout_opt(self) -> bool | None:
        ...
    @property
    def val_out(self) -> bool:
        ...
class TestReal16Array:
    """
    Fortran routine test_real16_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> Real16Alloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestReal16Scalar:
    """
    Fortran routine test_real16_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> float:
        ...
    @property
    def val_inout_opt(self) -> float | None:
        ...
    @property
    def val_out(self) -> float:
        ...
class TestRealArray:
    """
    Fortran routine test_real_array return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def arr_out(self) -> RealAlloc1D:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
class TestRealScalar:
    """
    Fortran routine test_real_scalar return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def opt_status(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    @property
    def val_inout(self) -> float:
        ...
    @property
    def val_inout_opt(self) -> float | None:
        ...
    @property
    def val_out(self) -> float:
        ...
class TestSubStruct:
    """
    Fortran struct: test_sub_struct
    """
    sr: TestSubSubStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class TestSubStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TestSubStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TestSubStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TestSubStructArray1D:
        ...
class TestSubStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TestSubStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TestSubStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TestSubStructArray2D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TestSubStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TestSubStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TestSubStructArray3D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TestSubStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TestSubStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TestSubSubStruct:
    """
    Fortran struct: test_sub_sub_struct
    """
    file: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def aaa(self) -> int:
        ...
    @aaa.setter
    def aaa(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def bbb(self) -> int:
        ...
    @bbb.setter
    def bbb(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def freq_spread(self) -> float:
        ...
    @freq_spread.setter
    def freq_spread(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def t_ref(self) -> float:
        ...
    @t_ref.setter
    def t_ref(self, arg1: typing.SupportsFloat) -> None:
        ...
class ToEtaReading:
    """
    Fortran routine to_eta_reading return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def reading(self) -> float:
        ...
class ToFieldmapCoords:
    """
    Fortran routine to_fieldmap_coords return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def cos_ang(self) -> float:
        ...
    @property
    def sin_ang(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
class ToOrbitReading:
    """
    Fortran routine to_orbit_reading return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def reading(self) -> float:
        ...
class ToPhaseAndCouplingReading:
    """
    Fortran routine to_phase_and_coupling_reading return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def reading(self) -> BpmPhaseCouplingStruct:
        ...
class ToStr:
    """
    Fortran routine to_str return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def max_signif(self) -> int | None:
        ...
    @property
    def num(self) -> float:
        ...
    @property
    def string(self) -> str:
        ...
class TouschekRate1Zap:
    """
    Fortran routine touschek_rate1_zap return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ix(self) -> int | None:
        ...
    @property
    def rate(self) -> float:
        ...
    @property
    def s(self) -> float | None:
        ...
class Track1:
    """
    Fortran routine track1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class Track1Bmad:
    """
    Fortran routine track1_bmad return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class Track1RungeKutta:
    """
    Fortran routine track1_runge_kutta return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class Track1Spin:
    """
    Fortran routine track1_spin return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele(self) -> EleStruct:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def make_quaternion(self) -> bool | None:
        ...
class Track1TimeRungeKutta:
    """
    Fortran routine track1_time_runge_kutta return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dt_step(self) -> float | None:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class TrackABeambeam:
    """
    Fortran routine track_a_beambeam return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def mat6(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class TrackADrift:
    """
    Fortran routine track_a_drift return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def time(self) -> float | None:
        ...
class TrackAMatch:
    """
    Fortran routine track_a_match return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
    @property
    def mat6(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
class TrackAPatch:
    """
    Fortran routine track_a_patch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ds_ref(self) -> float:
        ...
    @property
    def mat6(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
    @property
    def s_ent(self) -> float:
        ...
class TrackAPickup:
    """
    Fortran routine track_a_pickup return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool | None:
        ...
    @property
    def mat6(self) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"] | None:
        ...
class TrackAZeroLengthElement:
    """
    Fortran routine track_a_zero_length_element return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class TrackAll:
    """
    Fortran routine track_all return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def orbit0(self) -> CoordStructAlloc1D:
        ...
    @property
    def track_state(self) -> int:
        ...
class TrackFromSToS:
    """
    Fortran routine track_from_s_to_s return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def all_orb(self) -> CoordStructAlloc1D:
        ...
    @property
    def orbit_end(self) -> CoordStruct:
        ...
    @property
    def track_state(self) -> int:
        ...
class TrackPointStruct:
    """
    Fortran struct: track_point_struct
    """
    field: EmFieldStruct
    orb: CoordStruct
    strong_beam: StrongBeamStruct
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def mat6(self) -> ...:
        ...
    @property
    def s_body(self) -> float:
        ...
    @s_body.setter
    def s_body(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def s_lab(self) -> float:
        ...
    @s_lab.setter
    def s_lab(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def vec0(self) -> ...:
        ...
class TrackPointStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TrackPointStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TrackPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> TrackPointStructArray1D:
        ...
class TrackPointStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TrackPointStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TrackPointStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TrackStruct:
    """
    Fortran struct: track_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ds_save(self) -> float:
        ...
    @ds_save.setter
    def ds_save(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def n_bad(self) -> int:
        ...
    @n_bad.setter
    def n_bad(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_ok(self) -> int:
        ...
    @n_ok.setter
    def n_ok(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_pt(self) -> int:
        ...
    @n_pt.setter
    def n_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def pt(self) -> TrackPointStructArray1D:
        ...
class TrackUntilDead:
    """
    Fortran routine track_until_dead return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def end_orb(self) -> CoordStruct:
        ...
    @property
    def track(self) -> TrackStruct:
        ...
class TrackingRadMapSetup:
    """
    Fortran routine tracking_rad_map_setup return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def rad_map(self) -> RadMapStruct:
        ...
class TransferMapFromSToS:
    """
    Fortran routine transfer_map_from_s_to_s return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def ref_orb_out(self) -> CoordStruct:
        ...
class TricubicCmplxCoefStruct:
    """
    Fortran struct: tricubic_cmplx_coef_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def coef(self) -> ...:
        ...
    @property
    def i_box(self) -> ...:
        ...
class TricubicCmplxCoefStructArray3D:
    def __getitem__(self, arg0: typing.SupportsInt) -> TricubicCmplxCoefStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[TricubicCmplxCoefStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class TricubicCmplxEval:
    """
    Fortran routine tricubic_cmplx_eval return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def df_dx(self) -> complex:
        ...
    @property
    def df_dy(self) -> complex:
        ...
    @property
    def df_dz(self) -> complex:
        ...
    @property
    def f_val(self) -> complex:
        ...
class Twiss1Propagate:
    """
    Fortran routine twiss1_propagate return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def twiss2(self) -> TwissStruct:
        ...
class Twiss3AtStart:
    """
    Fortran routine twiss3_at_start return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def tune3(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class Twiss3Propagate1:
    """
    Fortran routine twiss3_propagate1 return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
class TwissAndTrackAll:
    """
    Fortran routine twiss_and_track_all return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def calc_chrom(self) -> bool | None:
        ...
    @property
    def print_err(self) -> bool | None:
        ...
    @property
    def status(self) -> int | None:
        ...
class TwissAndTrackBranch:
    """
    Fortran routine twiss_and_track_branch return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def calc_chrom(self) -> bool | None:
        ...
    @property
    def ix_branch(self) -> int | None:
        ...
    @property
    def print_err(self) -> bool | None:
        ...
    @property
    def status(self) -> int | None:
        ...
class TwissAndTrackFromSToS:
    """
    Fortran routine twiss_and_track_from_s_to_s return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ele_end(self) -> EleStruct:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def orbit_end(self) -> CoordStruct:
        ...
class TwissAndTrackIntraEle:
    """
    Fortran routine twiss_and_track_intra_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def orbit_end(self) -> CoordStruct:
        ...
class TwissAtElement:
    """
    Fortran routine twiss_at_element return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def average(self) -> EleStruct:
        ...
    @property
    def end(self) -> EleStruct:
        ...
    @property
    def start(self) -> EleStruct:
        ...
class TwissFromTracking:
    """
    Fortran routine twiss_from_tracking return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def symp_err(self) -> float:
        ...
class TwissStruct:
    """
    Fortran struct: twiss_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def alpha(self) -> float:
        ...
    @alpha.setter
    def alpha(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def beta(self) -> float:
        ...
    @beta.setter
    def beta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def chrom(self) -> float:
        ...
    @chrom.setter
    def chrom(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dalpha_dpz(self) -> float:
        ...
    @dalpha_dpz.setter
    def dalpha_dpz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dbeta_dpz(self) -> float:
        ...
    @dbeta_dpz.setter
    def dbeta_dpz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def deta_dpz(self) -> float:
        ...
    @deta_dpz.setter
    def deta_dpz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def deta_ds(self) -> float:
        ...
    @deta_ds.setter
    def deta_ds(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def detap_dpz(self) -> float:
        ...
    @detap_dpz.setter
    def detap_dpz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def emit(self) -> float:
        ...
    @emit.setter
    def emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def eta(self) -> float:
        ...
    @eta.setter
    def eta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def etap(self) -> float:
        ...
    @etap.setter
    def etap(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def gamma(self) -> float:
        ...
    @gamma.setter
    def gamma(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def norm_emit(self) -> float:
        ...
    @norm_emit.setter
    def norm_emit(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigma(self) -> float:
        ...
    @sigma.setter
    def sigma(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigma_p(self) -> float:
        ...
    @sigma_p.setter
    def sigma_p(self, arg1: typing.SupportsFloat) -> None:
        ...
class TypeThisFile:
    """
    Fortran routine type_this_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def filename(self) -> str:
        ...
class UpcaseString:
    """
    Fortran routine upcase_string return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def string(self) -> str:
        ...
class ValidFieldCalc:
    """
    Fortran routine valid_field_calc return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
class ValidFringeType:
    """
    Fortran routine valid_fringe_type return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
class ValidMat6CalcMethod:
    """
    Fortran routine valid_mat6_calc_method return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
class ValidSpinTrackingMethod:
    """
    Fortran routine valid_spin_tracking_method return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
class ValidTrackingMethod:
    """
    Fortran routine valid_tracking_method return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def is_valid(self) -> bool:
        ...
class ValueOfAttribute:
    """
    Fortran routine value_of_attribute return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
class ValueToLine:
    """
    Fortran routine value_to_line return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def ignore_if_zero(self) -> bool | None:
        ...
    @property
    def line(self) -> str:
        ...
    @property
    def str(self) -> str:
        ...
    @property
    def typ(self) -> str:
        ...
    @property
    def use_comma(self) -> bool | None:
        ...
    @property
    def value(self) -> float:
        ...
class WMatToAxisAngle:
    """
    Fortran routine w_mat_to_axis_angle return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def angle(self) -> float:
        ...
    @property
    def axis(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
class WakeLrModeStruct:
    """
    Fortran struct: wake_lr_mode_struct
    """
    polarized: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def Q(self) -> float:
        ...
    @Q.setter
    def Q(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def R_over_Q(self) -> float:
        ...
    @R_over_Q.setter
    def R_over_Q(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def a_cos(self) -> float:
        ...
    @a_cos.setter
    def a_cos(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def a_sin(self) -> float:
        ...
    @a_sin.setter
    def a_sin(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def angle(self) -> float:
        ...
    @angle.setter
    def angle(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_cos(self) -> float:
        ...
    @b_cos.setter
    def b_cos(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_sin(self) -> float:
        ...
    @b_sin.setter
    def b_sin(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def damp(self) -> float:
        ...
    @damp.setter
    def damp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def freq(self) -> float:
        ...
    @freq.setter
    def freq(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def freq_in(self) -> float:
        ...
    @freq_in.setter
    def freq_in(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def m(self) -> int:
        ...
    @m.setter
    def m(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
class WakeLrModeStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> WakeLrModeStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[WakeLrModeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> WakeLrModeStructArray1D:
        ...
class WakeLrModeStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> WakeLrModeStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[WakeLrModeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class WakeLrStruct:
    """
    Fortran struct: wake_lr_struct
    """
    file: str
    self_wake_on: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp_scale(self) -> float:
        ...
    @amp_scale.setter
    def amp_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def freq_spread(self) -> float:
        ...
    @freq_spread.setter
    def freq_spread(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def mode(self) -> WakeLrModeStructArray1D:
        ...
    @property
    def t_ref(self) -> float:
        ...
    @t_ref.setter
    def t_ref(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def time_scale(self) -> float:
        ...
    @time_scale.setter
    def time_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
class WakeSrModeStruct:
    """
    Fortran struct: wake_sr_mode_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def a_cos(self) -> float:
        ...
    @a_cos.setter
    def a_cos(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def a_sin(self) -> float:
        ...
    @a_sin.setter
    def a_sin(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def amp(self) -> float:
        ...
    @amp.setter
    def amp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_cos(self) -> float:
        ...
    @b_cos.setter
    def b_cos(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def b_sin(self) -> float:
        ...
    @b_sin.setter
    def b_sin(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def damp(self) -> float:
        ...
    @damp.setter
    def damp(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def k(self) -> float:
        ...
    @k.setter
    def k(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def phi(self) -> float:
        ...
    @phi.setter
    def phi(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def polarization(self) -> int:
        ...
    @polarization.setter
    def polarization(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def position_dependence(self) -> int:
        ...
    @position_dependence.setter
    def position_dependence(self, arg1: typing.SupportsInt) -> None:
        ...
class WakeSrModeStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> WakeSrModeStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[WakeSrModeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> WakeSrModeStructArray1D:
        ...
class WakeSrModeStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> WakeSrModeStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[WakeSrModeStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class WakeSrStruct:
    """
    Fortran struct: wake_sr_struct
    """
    file: str
    scale_with_length: bool
    z_long: WakeSrZLongStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def amp_scale(self) -> float:
        ...
    @amp_scale.setter
    def amp_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def long_wake(self) -> WakeSrModeStructArray1D:
        ...
    @property
    def trans_wake(self) -> WakeSrModeStructArray1D:
        ...
    @property
    def z_max(self) -> float:
        ...
    @z_max.setter
    def z_max(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z_ref_long(self) -> float:
        ...
    @z_ref_long.setter
    def z_ref_long(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z_ref_trans(self) -> float:
        ...
    @z_ref_trans.setter
    def z_ref_trans(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def z_scale(self) -> float:
        ...
    @z_scale.setter
    def z_scale(self, arg1: typing.SupportsFloat) -> None:
        ...
class WakeSrZLongStruct:
    """
    Fortran struct: wake_sr_z_long_struct
    """
    time_based: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dz(self) -> float:
        ...
    @dz.setter
    def dz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def fbunch(self) -> ...:
        ...
    @property
    def fw(self) -> ...:
        ...
    @property
    def position_dependence(self) -> int:
        ...
    @position_dependence.setter
    def position_dependence(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def smoothing_sigma(self) -> float:
        ...
    @smoothing_sigma.setter
    def smoothing_sigma(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def w(self) -> ...:
        ...
    @property
    def w_out(self) -> ...:
        ...
    @property
    def z0(self) -> float:
        ...
    @z0.setter
    def z0(self, arg1: typing.SupportsFloat) -> None:
        ...
class WakeStruct:
    """
    Fortran struct: wake_struct
    """
    lr: WakeLrStruct
    sr: WakeSrStruct
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class Wall3DSectionStruct:
    """
    Fortran struct: wall3d_section_struct
    """
    material: str
    name: str
    patch_in_region: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def dr_ds(self) -> float:
        ...
    @dr_ds.setter
    def dr_ds(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dx0_ds(self) -> float:
        ...
    @dx0_ds.setter
    def dx0_ds(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def dy0_ds(self) -> float:
        ...
    @dy0_ds.setter
    def dy0_ds(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def ix_branch(self) -> int:
        ...
    @ix_branch.setter
    def ix_branch(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_ele(self) -> int:
        ...
    @ix_ele.setter
    def ix_ele(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_vertex_input(self) -> int:
        ...
    @n_vertex_input.setter
    def n_vertex_input(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def p1_coef(self) -> ...:
        ...
    @property
    def p2_coef(self) -> ...:
        ...
    @property
    def r0(self) -> ...:
        ...
    @property
    def s(self) -> float:
        ...
    @s.setter
    def s(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def surface(self) -> _pybmad.PhotonReflectSurfaceStruct | None:
        ...
    @surface.setter
    def surface(self, arg1: PhotonReflectSurfaceStruct) -> None:
        ...
    @property
    def thickness(self) -> float:
        ...
    @thickness.setter
    def thickness(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def type(self) -> int:
        ...
    @type.setter
    def type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def v(self) -> Wall3DVertexStructArray1D:
        ...
    @property
    def vertices_state(self) -> int:
        ...
    @vertices_state.setter
    def vertices_state(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def x0_coef(self) -> ...:
        ...
    @property
    def y0_coef(self) -> ...:
        ...
class Wall3DSectionStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Wall3DSectionStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Wall3DSectionStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> Wall3DSectionStructArray1D:
        ...
class Wall3DSectionStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Wall3DSectionStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Wall3DSectionStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Wall3DStruct:
    """
    Fortran struct: wall3d_struct
    """
    clear_material: str
    name: str
    opaque_material: str
    superimpose: bool
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def ele_anchor_pt(self) -> int:
        ...
    @ele_anchor_pt.setter
    def ele_anchor_pt(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def ix_wall3d(self) -> int:
        ...
    @ix_wall3d.setter
    def ix_wall3d(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def n_link(self) -> int:
        ...
    @n_link.setter
    def n_link(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def section(self) -> Wall3DSectionStructArray1D:
        ...
    @property
    def thickness(self) -> float:
        ...
    @thickness.setter
    def thickness(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def type(self) -> int:
        ...
    @type.setter
    def type(self, arg1: typing.SupportsInt) -> None:
        ...
class Wall3DStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Wall3DStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Wall3DStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> Wall3DStructArray1D:
        ...
class Wall3DStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Wall3DStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Wall3DStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Wall3DVertexStruct:
    """
    Fortran struct: wall3d_vertex_struct
    """
    @staticmethod
    def new_array1d(sz: typing.SupportsInt, lbound: typing.SupportsInt = 1) -> ...:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def angle(self) -> float:
        ...
    @angle.setter
    def angle(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def radius_x(self) -> float:
        ...
    @radius_x.setter
    def radius_x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def radius_y(self) -> float:
        ...
    @radius_y.setter
    def radius_y(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def tilt(self) -> float:
        ...
    @tilt.setter
    def tilt(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def type(self) -> int:
        ...
    @type.setter
    def type(self, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def x0(self) -> float:
        ...
    @x0.setter
    def x0(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def y0(self) -> float:
        ...
    @y0.setter
    def y0(self, arg1: typing.SupportsFloat) -> None:
        ...
class Wall3DVertexStructAlloc1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Wall3DVertexStruct:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Wall3DVertexStruct]:
        ...
    def __len__(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def resize(self, lbound: typing.SupportsInt, n: typing.SupportsInt) -> None:
        ...
    def view(self) -> Wall3DVertexStructArray1D:
        ...
class Wall3DVertexStructArray1D:
    def __getitem__(self, arg0: typing.SupportsInt) -> Wall3DVertexStruct:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> collections.abc.Iterator[Wall3DVertexStruct]:
        ...
    def __len__(self) -> int:
        ...
    def __str__(self) -> str:
        ...
    def is_valid(self) -> bool:
        ...
class Wall3dDRadius:
    """
    Fortran routine wall3d_d_radius return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def d_radius(self) -> float:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def ix_section(self) -> int:
        ...
    @property
    def no_wall_here(self) -> bool:
        ...
    @property
    def origin(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
    @property
    def perp(self) -> typing.Annotated[list[float], "FixedSize(3)"]:
        ...
    @property
    def radius_wall(self) -> float:
        ...
class WordLen:
    """
    Fortran routine word_len return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def wlen(self) -> int:
        ...
    @property
    def wording(self) -> str:
        ...
class WordRead:
    """
    Fortran routine word_read return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def delim(self) -> str:
        ...
    @property
    def delim_found(self) -> bool:
        ...
    @property
    def delim_list(self) -> str:
        ...
    @property
    def ignore_interior(self) -> bool | None:
        ...
    @property
    def in_str(self) -> str:
        ...
    @property
    def ix_word(self) -> int:
        ...
    @property
    def out_str(self) -> str:
        ...
    @property
    def word(self) -> str:
        ...
class WordToValue:
    """
    Fortran routine word_to_value return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def value(self) -> float:
        ...
    @property
    def word(self) -> str:
        ...
class WriteAstraBend:
    """
    Fortran routine write_astra_bend return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def id(self) -> int:
        ...
    @property
    def iu(self) -> int:
        ...
    @property
    def strength(self) -> float:
        ...
class WriteAstraFieldGridFile:
    """
    Fortran routine write_astra_field_grid_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def maxfield(self) -> float:
        ...
class WriteAstraFieldGridFile3d:
    """
    Fortran routine write_astra_field_grid_file_3d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def maxfield(self) -> float:
        ...
class WriteBlenderEle:
    """
    Fortran routine write_blender_ele return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def iu(self) -> int:
        ...
    @property
    def old_format(self) -> bool | None:
        ...
class WriteBlenderLatLayout:
    """
    Fortran routine write_blender_lat_layout return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def file_name(self) -> str:
        ...
class WriteGptFieldGridFile1d:
    """
    Fortran routine write_gpt_field_grid_file_1d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def maxfield(self) -> float:
        ...
    @property
    def ref_time(self) -> float:
        ...
class WriteGptFieldGridFile2d:
    """
    Fortran routine write_gpt_field_grid_file_2d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def maxfield(self) -> float:
        ...
    @property
    def ref_time(self) -> float:
        ...
class WriteGptFieldGridFile3d:
    """
    Fortran routine write_gpt_field_grid_file_3d return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def maxfield(self) -> float:
        ...
    @property
    def ref_time(self) -> float:
        ...
class WriteLatLine:
    """
    Fortran routine write_lat_line return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
class WriteLatticeInSadFormat:
    """
    Fortran routine write_lattice_in_sad_format return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool | None:
        ...
    @property
    def include_apertures(self) -> bool | None:
        ...
    @property
    def ix_branch(self) -> int | None:
        ...
    @property
    def out_file_name(self) -> str:
        ...
class WriteLatticeInScibmad:
    """
    Fortran routine write_lattice_in_scibmad return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def scibmad_file(self) -> str:
        ...
class WriteLineElement:
    """
    Fortran routine write_line_element return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def iu(self) -> int:
        ...
    @property
    def line(self) -> str:
        ...
class WriteOpalFieldGridFile:
    """
    Fortran routine write_opal_field_grid_file return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def err(self) -> bool:
        ...
    @property
    def maxfield(self) -> float:
        ...
class Xlafun:
    """
    Fortran routine xlafun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
class XyDispStruct:
    """
    Fortran struct: xy_disp_struct
    """
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def deta_dpz(self) -> float:
        ...
    @deta_dpz.setter
    def deta_dpz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def deta_ds(self) -> float:
        ...
    @deta_ds.setter
    def deta_ds(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def detap_dpz(self) -> float:
        ...
    @detap_dpz.setter
    def detap_dpz(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def eta(self) -> float:
        ...
    @eta.setter
    def eta(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def etap(self) -> float:
        ...
    @etap.setter
    def etap(self, arg1: typing.SupportsFloat) -> None:
        ...
    @property
    def sigma(self) -> float:
        ...
    @sigma.setter
    def sigma(self, arg1: typing.SupportsFloat) -> None:
        ...
class Ylafun:
    """
    Fortran routine ylafun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
class ZAtSurface:
    """
    Fortran routine z_at_surface return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def dz_dxy(self) -> typing.Annotated[list[float], "FixedSize(2)"]:
        ...
    @property
    def err_flag(self) -> bool:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
class Zlafun:
    """
    Fortran routine zlafun return value
    """
    def __getitem__(self, arg0: typing.SupportsInt) -> typing.Any:
        ...
    def __len__(self) -> int:
        ...
    @property
    def res(self) -> float:
        ...
    @property
    def x(self) -> float:
        ...
    @property
    def y(self) -> float:
        ...
    @property
    def z(self) -> float:
        ...
def ab_multipole_kick(a: typing.SupportsFloat, b: typing.SupportsFloat, n: typing.SupportsInt, ref_species: typing.SupportsInt, ele_orientation: typing.SupportsInt, coord: CoordStruct, pole_type: typing.SupportsInt | None = None, scale: typing.SupportsFloat | None = None) -> ...:
    """
    Subroutine to put in the kick due to an ab_multipole.
    
    Parameters
    ----------
    a : float
        Multipole skew component.
    b : float
        Multipole normal component.
    n : float
        Multipole order.
    ref_species : int
        Reference species.
    ele_orientation : int
        Element orientation +1 = normal, -1 = reversed, 0 = Ignore orientation and tracking species (used with
        pole_type = magnetic$).
    coord : CoordStruct
        Particle position and direction of travel.
    pole_type : int, optional
        Type of multipole. magnetic$ (default) or electric$.
    scale : float, optional
        Factor to scale the kicks. Default is 1. For pole_type = electric$, set scale to the longitudinal length
        of the field region.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    kx : float
        X kick.
    ky : float
        Y kick.
    dk : float
        Kick derivative: dkick(x,y)/d(x,y).
    """
def ab_multipole_kicks(an: RealAlloc1D, bn: RealAlloc1D, ix_pole_max: typing.SupportsInt, ele: EleStruct, orbit: CoordStruct, pole_type: typing.SupportsInt | None = None, scale: typing.SupportsFloat | None = None, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Routine to put in the kick due to ab_multipole components in an element.
    
    The kick will be corrected for the orientation of the element and the particle direction of travel.
    Any difference between element p0c and orbit%p0c will be taken into account.
    Also see the multipole_kicks routine.
    
    Parameters
    ----------
    an : float
        Skew multipole strengths.
    bn : float
        Normal multipole strengths.
    ix_pole_max : int
        Maximum pole index.
    ele : EleStruct
        Lattice element containing the multipoles.
    orbit : CoordStruct
        Particle position.
        This parameter is an input/output and is modified in-place. As an output: Kicked particle.
    pole_type : int, optional
        Type of multipole. magnetic$ (default) or electric$.
    scale : float, optional
        Factor to scale the kicks. Default is 1. For pole_type = electric$, set scale to the longitudinal length
        of the field region
    mat6 : float, optional
        Transfer matrix before the multipole.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        including multipole.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def absolute_photon_position(e_orb: CoordStruct, photon_orb: CoordStruct) -> None:
    """
    Routine to calculate the photon phase space coordinates given:
    
    1) The phase space coords of the emitting charged particle and
    2) The photon phase space coords relative to the emitting particle.
    The photon (x, y, z) position is ignored (it is assumed the photon is emitted at
    the charged particle position) and only the photon's (vx, vy, vz) velocity matters.
    
    Parameters
    ----------
    e_orb : CoordStruct
        charged particle position.
    photon_orb : CoordStruct
        Photon position relative to e_orb.
        This parameter is an input/output and is modified in-place. As an output: Absolute photon position.
    """
def absolute_time_tracking(ele: EleStruct, is_abs_time: bool) -> PyAbsoluteTimeTracking:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through.
    is_abs_time : 
    """
def ac_kicker_amp(ele: EleStruct, orbit: CoordStruct, true_time: typing.SupportsFloat | None = None, ac_amp: typing.SupportsFloat) -> PyAcKickerAmp:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        ac_kicker element.
    orbit : CoordStruct
        Contains the time to evaluate the amplitude at.
    true_time : float, optional
        The actual time. Normally this time is calculated using orbit.t or orbit.vec(5) but sometimes it is
        convenient to be able to override this. For example, time_runge_kutta uses this.
    ac_amp : 
    """
def action_to_xyz(ring: LatStruct, ix: typing.SupportsInt, J: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]) -> ...:
    """
    Given the normal mode invariants and phases J of a particle, returns the canonical coordinates.
    
    The J vector looks like:
    J = (sqrt(2Ja)cos(phia), -sqrt(2Ja)sin(phia), sqrt(2Jb)cos(phib), -sqrt(2Jb)sin(phib), sqrt(2Jc)cos(phic), -sqrt(2Jc)sin(phic))
    X is obtained from:
    X = N . J
    Where N is from the Eigen decomposition of the 1-turn transfer matrix.
    
    Parameters
    ----------
    ring : LatStruct
        lattice .a.tune   -- a-mode tune (horizontal-like) .b.tune   -- b-mode tune (vertical-like) .z.tune   --
        c-mode tune (synchrotron-like)
    ix : int
        element index at which to calculate J
    J : float
        Vector containing normal mode invariants and phases
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    X : float
        canonical phase space coordinates of the particle
    err_flag : bool
        Set to true on error.  Often means Eigen decomposition failed.
    """
def add_lattice_control_structs(ele: EleStruct, n_add_slave: typing.SupportsInt | None = None, n_add_lord: typing.SupportsInt | None = None, n_add_slave_field: typing.SupportsInt | None = None, n_add_lord_field: typing.SupportsInt | None = None, add_at_end: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lord or slave element that needs extra control elements.
    n_add_slave : int, optional
        Number of field slaves to add to lord. Default is zero.
    n_add_lord : int, optional
        Number of field lords to add to slave. Default is zero.
    n_add_slave_field : int, optional
        Number of field slaves to add to lord. Default is zero.
    n_add_lord_field : int, optional
        Number of field lords to add to slave. Default is zero.
    add_at_end : bool, optional
        Used when n_add_slave or n_add_slave_field is non-zero. If True then new space is added at the end of the
        array. If False then new space is added at the front of the array. Default is True.
    """
def add_superimpose(lat: LatStruct, super_ele_in: EleStruct, ix_branch: typing.SupportsInt, save_null_drift: bool | None = None, create_jumbo_slave: bool | None = None, ix_insert: typing.SupportsInt | None = None, mangle_slave_names: bool | None = None, wrap: bool | None = None) -> ...:
    """
    save_null_drift, create_jumbo_slave, ix_insert, mangle_slave_names, wrap)
    
    Routine to superimpose an element. If the element can be inserted
    into the lat without making a super_lord element then this will be done.
    
    Parameters
    ----------
    lat : LatStruct
        Lat to modify.
        This parameter is an input/output and is modified in-place. As an output: Modified lat.
    super_ele_in : EleStruct
        Element to superimpose. .s               -- Position of end of element. Negative distances mean distance
        from the end.
    ix_branch : int
        Branch index to put element.
    save_null_drift : bool, optional
        Save a copy of a drift to be split as a null_ele? This is useful if further superpositions might use this
        drift as a reference element. After all superpositions are done, remove_eles_from_lat can be called to
        remove all null_eles. Default is False.
    create_jumbo_slave : bool, optional
        Default is False. If True then super_slaves that are created that have super_ele_in as their super_lord
        are em_field elements.
    ix_insert : int, optional
        If present and positive, and super_ele_in has zero length, use ix_insert as the index to insert
        super_ele_in at. ix_insert is useful when superposing next to another element that has zero or negative
        length (EG a patch) and you want to make sure that the superimposed element is on the correct side of the
        element.
    mangle_slave_names : bool, optional
        If True (default), adjust slave names appropriately. Name mangeling can take time so bmad_parser will do
        this all at once at the end.
    wrap : bool, optional
        If True (default), and if the superimposed element has an end that extends beyond the starting or ending
        edge of the lattice, wrap the element around the lattice so that the beginning portion of the element is
        at the lattice ending edge and the rest of the element is at the lattice start edge. If wrap = False, and
        the superimposed element has an end that extends beyound a lattice edge, extend the lattice to
        accommodate.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error. False otherwise
    super_ele_out : EleStruct
        Pointer to the super element in the lattice.
    """
def add_this_multipass(lat: LatStruct, m_slaves: LatEleLocStructAlloc1D, lord_in: _pybmad.EleStruct | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    m_slaves : 
    lord_in : 
    """
def add_this_taylor_term(ele: EleStruct, i_out: typing.SupportsInt, coef: typing.SupportsFloat, expn: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(6)"]) -> PyAddThisTaylorTerm:
    """
    Subroutine used by bmad_parser and bmad_parser2 to parse the input file.
    
    This subroutine is not intended for general use.
    """
def adjust_super_slave_names(lat: LatStruct, ix1_lord: typing.SupportsInt, ix2_lord: typing.SupportsInt, first_time: bool | None = None) -> PyAdjustSuperSlaveNames:
    """
    Routine to adjust the names of the slaves.
    
    This routine is used by add_superimpose and is not meant for general use.
    """
def allocate_branch_array(lat: LatStruct, upper_bound: typing.SupportsInt) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        .branch(:)  -- Branch array to be allocated.
    upper_bound : int
        Desired upper bound.
    """
def allocate_lat_ele_array(lat: LatStruct, upper_bound: typing.SupportsInt | None = None, ix_branch: typing.SupportsInt | None = None, do_ramper_slave_setup: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice with element array. .branch(ix_branch).ele(:)  -- Element array to reallocate.
    upper_bound : int, optional
        Optional desired upper bound. Default: 1.3*ubound(ele(:)) or 10 if ele is not allocated.
    ix_branch : int, optional
        Branch index. Default is 0.
    do_ramper_slave_setup : bool, optional
        Default False. If true, setup ramper slaves. Generally this needs to be done if reallocating with a fully
        formed lattice.
    """
def allocate_thread_states() -> None:
    """
    Routine to allocate random number state structures when openMP is used.
    """
def angle_between_polars(polar1: SpinPolarStruct, polar2: SpinPolarStruct, angle: typing.SupportsFloat) -> PyAngleBetweenPolars:
    """
    No docstring available
    
    Parameters
    ----------
    polar1 : 
        (spin_polar_struct)
    polar2 : 
        (spin_polar_struct)
    angle : 
    """
def angle_to_canonical_coords(orbit: CoordStruct, coord_type: str | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Orbit in angular coordinates.
        This parameter is an input/output and is modified in-place. As an output: Orbit in canonical coordinates.
    coord_type : unknown, optional
        Angular coordinates type '' (default): (x, x' = dx/ds, y, y' = dy/ds, z, pz) 'ZGOUBI':     (x, x' = dx/ds,
        y, y' = dy/ds, dt = -z / (beta * c), pz)
    """
def anomalous_moment_of(species: typing.SupportsInt) -> float:
    """
    Routine to return the anomolous moment for subatomic species type. Otherwise returns 0.
    
    Parameters
    ----------
    species : int
        Species ID.
    
    Returns
    -------
    moment : float
        Anomalous moment.
    """
def antiparticle(species: typing.SupportsInt) -> int:
    """
    Routine to return the antiparticle ID given the particle ID.
    
    For a molecule the anti-species is just the molecude with the charge reversed.
    
    Parameters
    ----------
    species : int
        Particle ID.
    
    Returns
    -------
    anti_species : int
        Antiparticle ID.
    """
def aperture_bookkeeper(ele: EleStruct) -> None:
    """
    Routine to calculate aperture limits when ele%attribute_type is set to auto_aperture$
    
    Parameters
    ----------
    ele : EleStruct
        Element with aperture.
        This parameter is an input/output and is modified in-place. As an output: Element with apertures set.
    """
def apfft(rdata_in: RealAlloc1D, bounds: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], window: str, phase: typing.SupportsFloat, diag: typing.SupportsInt | None = None) -> PyApfft:
    """
    Implements the All Phase FFT method for obtaining accurate phase from signal data.
    
    The signal data is truncated to an odd length, and the phase is relative to the central point.
    """
def apfft_corr(rdata_in: RealAlloc1D, bounds: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"] | None = None, window: str, diag: typing.SupportsInt | None = None) -> ...:
    """
    For real signal rdata_in, computes phase, frequency, and amplitude
    
    of peak found within bounds.  Algorithm is corrected all-phase FFT and should.
    This routine finds only one peak:  the largest amplitude within the bound.  Signals with multiple
    components can be investigated by varying bounds appropriately.
    
    Parameters
    ----------
    rdata_in : float
        signal data.
    bounds : float
        range within which to search for peak.
    window : unknown
        'rec' or 'han' for rectangular or Hann window.
    diag : int, optional
        causes low-level routine apfft_ext to produce a fort.X file where X=9000+fid containing diag information.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    phase : float
        phase of peak found in signal.
    freq : float
        frequency of peak
    amp : float
        amplitude of peak
    """
def apfft_ext(rdata: RealAlloc1D, bounds: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], window: str, phase: typing.SupportsFloat, amp: typing.SupportsFloat, freq: typing.SupportsFloat, diag: typing.SupportsInt | None = None) -> PyApfftExt:
    """
    Implements the All Phase FFT method for obtaining accurate phase from signal data.
    
    This "extended" apfft subroutine returns the amplitudes and frequency as well, for use
    by the corrected apfft subroutine in this module.
    """
def apply_all_rampers(lat: LatStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice.
        This parameter is an input/output and is modified in-place. As an output: Lattice with rampers applied.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def apply_energy_kick(dE: typing.SupportsFloat, orbit: CoordStruct, ddE_dr: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    dE : float
        Energy change
    orbit : CoordStruct
        Beginning coordinates
        This parameter is an input/output and is modified in-place. As an output: coordinates with added dE energy
        kick.
    ddE_dr : 
        real(rp), Derivatives of dE [ddE_dx, ddE_dy].
    mat6 : float, optional
        Transfer matrix before fringe.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        including energy kick.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def apply_patch_to_ptc_fibre(ele: EleStruct) -> None:
    """
    Routine to take the patch parameters from a Bmad patch element and
    
    transfer them to the associated PTC fibre.
    
    Parameters
    ----------
    ele : EleStruct
        Patch element. ele.ptc_fibre -- PTC Fibre which should be a marker.
    """
def apply_rampers_to_slave(slave: EleStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    slave : EleStruct
        Element to apply ramper elements to.
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def array_re_str(arr: RealAlloc1D, parens_in: str | None = None, str_out: str) -> PyArrayReStr:
    """
    No docstring available
    
    Parameters
    ----------
    arr : 
    parens_in : 
    str_out : 
    """
def asinc(x: typing.SupportsFloat, nd: typing.SupportsInt | None = None, y: typing.SupportsFloat) -> PyAsinc:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    nd : 
    y : 
    """
def assert_equal(int_arr: IntAlloc1D, err_str: str, ival: typing.SupportsInt) -> PyAssertEqual:
    """
    No docstring available
    
    Parameters
    ----------
    int_arr : 
    err_str : 
    ival : 
    """
def astra_max_field_reference(pt0: GridFieldPt1Struct, ele: EleStruct, field_value: typing.SupportsFloat) -> PyAstraMaxFieldReference:
    """
    No docstring available
    
    Parameters
    ----------
    pt0 : 
    ele : 
    field_value : 
    """
def at_this_ele_end(now_at: typing.SupportsInt, where_at: typing.SupportsInt, is_at_this_end: bool) -> PyAtThisEleEnd:
    """
    No docstring available
    
    Parameters
    ----------
    now_at : int
        Which end is under consideration: entrance_end$, exit_end$, surface$, or in_between$.
    where_at : int
        Which ends have the aperture or fringe field: entrance_end$, exit_end$, continuous$, both_ends$,
        no_aperture$, surface$, wall_transition$.
    is_at_this_end : 
    """
def atomic_number(species: typing.SupportsInt) -> int:
    """
    Routine to return the atomic number Z if species argument corresponds to an atomic particle  or is a proton.
    
    Set to the charge for atomic particles.
    Set to zero for molecules.
    
    Parameters
    ----------
    species : int
        Spicies ID.
    
    Returns
    -------
    atomic_num : int
        Atomic index. Set to zero if a molecule
    """
def atomic_species_id(charge: typing.SupportsInt, is_anti: bool, atomic_num: typing.SupportsInt, n_nuc: typing.SupportsInt) -> int:
    """
    Routine to return the species ID for an atom
    
    Parameters
    ----------
    charge : int
        Charge of the atom.
    is_anti : bool
        Is an anti-atom.
    atomic_num : int
        Atomic number.
    n_nuc : int
        Number of nucleons.
    
    Returns
    -------
    species_id : int
        Species ID number.
    """
def attribute_bookkeeper(ele: EleStruct, force_bookkeeping: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with attributes
        This parameter is an input/output and is modified in-place. As an output: Element with self-consistant
        attributes.
    force_bookkeeping : bool, optional
        If present and True then force -- Logical, optional: If present and True then force attribute bookkeeping
        to be done independent of the state of ele.bookkeeping_stat.attributes. This will also cause
        attribute_bookkeeper to assume intelligent bookkeeping.
    """
@typing.overload
def attribute_free(ix_ele: typing.SupportsInt, attrib_name: str, lat: LatStruct, err_print_flag: bool | None = None, except_overlay: bool | None = None, dependent_attribs_free: bool | None = None, why_not_free: typing.SupportsInt | None = None, free: bool) -> PyAttributeFree1:
    """
    This function overloaded by attribute_free. See attribute_free for more details.
    
    
    Returns
    -------
    free
    """
@typing.overload
def attribute_free(ele: EleStruct, attrib_name: str, err_print_flag: bool | None = None, except_overlay: bool | None = None, dependent_attribs_free: bool | None = None, why_not_free: typing.SupportsInt | None = None, free: bool) -> PyAttributeFree2:
    """
    This function overloaded by attribute_free. See attribute_free for more details.
    
    
    Returns
    -------
    free
    """
@typing.overload
def attribute_free(ix_ele: typing.SupportsInt, ix_branch: typing.SupportsInt, attrib_name: str, lat: LatStruct, err_print_flag: bool | None = None, except_overlay: bool | None = None, dependent_attribs_free: bool | None = None, why_not_free: typing.SupportsInt | None = None, free: bool) -> PyAttributeFree3:
    """
    err_print_flag, except_overlay, dependent_attribs_free, why_not_free) result (free)
    
    This function overloaded by attribute_free. See attribute_free for more details.
    """
@typing.overload
def attribute_index(ele: EleStruct, name: str, full_name: str | None = None, can_abbreviate: bool | None = None, print_error: bool | None = None, attrib_index: typing.SupportsInt) -> PyAttributeIndex1:
    """
    Overloaded by attribute_index. See attribute_index for more details.
    
    
    Returns
    -------
    attrib_index
    """
@typing.overload
def attribute_index(key: typing.SupportsInt, name: str, full_name: str | None = None, can_abbreviate: bool | None = None, print_error: bool | None = None, attrib_index: typing.SupportsInt) -> PyAttributeIndex2:
    """
    Overloaded by attribute_index. See attribute_index for more details.
    
    
    Returns
    -------
    attrib_index
    """
@typing.overload
def attribute_name(key: typing.SupportsInt, ix_att: typing.SupportsInt, show_private: bool | None = None, attrib_name: str) -> PyAttributeName1:
    """
    Overloaded by attribute_name. See attribute_name for more details.
    
    
    Returns
    -------
    attrib_name
    """
@typing.overload
def attribute_name(ele: EleStruct, ix_att: typing.SupportsInt, show_private: bool | None = None, attrib_name: str) -> PyAttributeName2:
    """
    Overloaded by attribute_name. See attribute_name for more details.
    
    
    Returns
    -------
    attrib_name
    """
def attribute_type(attrib_name: str, ele: _pybmad.EleStruct | None = None) -> int:
    """
    Routine to return the logical type of an attribute.
    
    A "switch" attribute is an attribute whose value corresponds to some string.
    For example, the "COUPLER_AT" attirbute with value 1 corresponds to "ENTRANCE_END", etc.
    A "struct" attribute is an attribute that is the name for a "structure". For example,
    CARTESIAN_MAP is the name of the structure hoding a Cartesian map.
    If attrib_name corresponds to a switch attribute, The routine switch_attrib_value_name can
    be used to print the name corresponding to the attribute's value.
    
    Parameters
    ----------
    attrib_name : unknown
        Name of the attribute. Must be upper case.
    ele : EleStruct, optional
        Element associated with the attribute. Needed if attrib_name can correspond to an overlay or group
        variable.
    
    Returns
    -------
    attrib_type : int
        Attribute type: is_string$, is_logical$, is_integer$, is_real$, is_switch$, is_struct$ or invalid_name$
        Note: An overlay or group variable will be marked invalid_name$ if ele is missing.
    """
def attribute_units(attrib_name: str, unrecognized_units: str | None = None) -> str:
    """
    Routine to return the units associated with an attribute.
    
    Example: attrib_units('P0C') -> 'eV'
    
    Parameters
    ----------
    attrib_name : unknown
        Name of the attribute. Must be upper case.
    unrecognized_units : unknown, optional
        String to use if the attribute name is unrecognized. Note: Non-real attributes (EG: 'TRACKING_METHOD') are
        not recognized. Default is ""
    
    Returns
    -------
    attrib_units : unknown
        Units associated with the attribute.
    """
def autoscale_phase_and_amp(ele: EleStruct, param: LatParamStruct, scale_phase: bool | None = None, scale_amp: bool | None = None, call_bookkeeper: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        RF element or e_gun.
        This parameter is an input/output and is modified in-place. As an output: element with phase and amplitude
        adjusted.
    param : LatParamStruct
        lattice parameters
    err_flag : 
        Logical, Set true if there is an error. False otherwise.
    scale_phase : bool, optional
        Scale the phase? See above.
    scale_amp : bool, optional
        Scale the amplitude? See above.
    call_bookkeeper : bool, optional
        Call lattice_bookkeeper at end? Default is True.
    """
def average_twiss(frac1: typing.SupportsFloat, twiss1: TwissStruct, twiss2: TwissStruct, ave_twiss: TwissStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    frac1 : float
        Fraction of twiss1 to use in the average.
    twiss1 : TwissStruct
        Twiss parameters to average.
    twiss2 : 
    ave_twiss : 
    """
def axis_angle_to_quat(axis: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], angle: typing.SupportsFloat) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    Routine to convert from axis + angle representation to a quaternion.
    
    Parameters
    ----------
    axis : float
        Axis of rotation.
    angle : float
        angle of rotation.
    
    Returns
    -------
    quat : float
        Rotation quaternion.
    """
def axis_angle_to_w_mat(axis: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], angle: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
    """
    Routine to construct the 3D rotation matrix w_mat given an axis of rotation
    
    and a rotation angle.
    
    Parameters
    ----------
    axis : float
        Rotation axis. Does not have to be normalized.
    angle : float
        Rotation angle in the range [-pi, pi].
    
    Returns
    -------
    w_mat : float
        Rotation matrix
    """
def bbi_kick(x: typing.SupportsFloat, y: typing.SupportsFloat, sigma: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    x : float
        X coordinate.
    y : float
        Y coordinate.
    sigma : float
        Beam (x,y) sigmas.
    nk : float
        Normalized, dimensionless kick component. In terms of the the actual kick: nk = [kick_x / (xi_x * sigma_x
        / beta_x), kick_y / (xi_y * sigma_y / beta_y) nk = -4 * pi * [x/sigma_x, y/sigma_y] in the linear region
    dnk : float
        derivatives of nk. EG: dnk(2,1) = dnk(2)/dy Note: xi_x = beta_x * bbi_const / sig_x     ! Horizontal tune
        shift parameter xi_y = beta_y * bbi_const / sig_y     ! Vertical   tune shift parameter where bbi_const =
        N_particles_bunch * r_e / (2 * pi * gamma * (sig_x + sig_y)) And the tune shifts are: dQ_x = xi_x = beta_x
        * bbi_const / sig_x dQ_y = xi_y = beta_y * bbi_const / sig_y In the calling routine, the formulas for
        computing the actual kicks, kick_x and kick_y, should be: kick_x = bbi_const * nk(1) ~ -4 * pi * bbi_const
        * x / sigma_x                        [linear region] ~ -2 * N_p * r_e * x / (gamma * sig_x * (sig_x +
        sig_y))   [linear region] ~ -2 * N_p * r_e * x / (gamma * (x^2 + y^2))               [far from beam]
        kick_y = bbi_const * nk(2) ~ -4 * pi * bbi_const * y / sigma_y                        [linear region] ~ -2
        * N_p * r_e * y / (gamma * sig_y * (sig_x + sig_y))   [linear region] ~ -2 * N_p * r_e * y / (gamma * (x^2
        + y^2))               [far from beam] For the beam-ion kick, assuming the ion velocity is neglegeble, the
        formulas are: kick_x = ion_const * nk(1) ~ -4 * pi * ion_const * x / sigma_x
        [linear region] ~ -2 * N_p * r_p * c_light * x / (sig_x * (sig_x + sig_y) * A)  [linear region] ~ -2 * N_p
        * r_p * c_light * x / ((x^2 + y^2) * A)              [far from beam] kick_y = ion_const * nk(2) ~ -4 * pi
        * ion_const * y / sigma_y                             [linear region] ~ -2 * N_p * r_p * c_light * y /
        (sig_y * (sig_x + sig_y) * A)  [linear region] ~ -2 * N_p * r_p * c_light * y / ((x^2 + y^2) * A)
        [far from beam] ion_const = N_particles_bunch * r_p * c_light / (2 * pi * (sig_x + sig_y) * A) A = Mass of
        ion in AMU.
    """
def bbi_slice_calc(ele: EleStruct, n_slice: typing.SupportsInt) -> RealAlloc1D:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        beambeam element
    n_slice : int
        Number of slices
    z_slice : float
        Array of slice positions 1:n_slice. zero padded for indexes greater than n_slice
    """
def bbu_add_a_bunch(lat: LatStruct, bbu_beam: BbuBeamStruct, bbu_param: BbuParamStruct, beam_init: BeamInitStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    bbu_beam : 
    bbu_param : 
    beam_init : 
    """
def bbu_hom_voltage_calc(lat: LatStruct, bbu_beam: BbuBeamStruct, n_period: typing.SupportsInt, ix_stage_last_tracked: typing.SupportsInt) -> PyBbuHomVoltageCalc:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    bbu_beam : 
    n_period : 
    ix_stage_last_tracked : 
    """
def bbu_remove_head_bunch(bbu_beam: BbuBeamStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    bbu_beam : 
    """
def bbu_setup(lat: LatStruct, dt_bunch: typing.SupportsFloat, bbu_param: BbuParamStruct, bbu_beam: BbuBeamStruct) -> PyBbuSetup:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    dt_bunch : 
    bbu_param : 
    bbu_beam : 
    """
def bbu_track_a_stage(lat: LatStruct, bbu_beam: BbuBeamStruct, bbu_param: BbuParamStruct, lost: bool, ix_stage_tracked: typing.SupportsInt) -> PyBbuTrackAStage:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    bbu_beam : 
    bbu_param : 
    lost : 
    ix_stage_tracked : 
    """
def bbu_track_all(lat: LatStruct, bbu_beam: BbuBeamStruct, bbu_param: BbuParamStruct, beam_init: BeamInitStruct, hom_voltage_normalized: typing.SupportsFloat, growth_rate: typing.SupportsFloat, lost: bool, irep: typing.SupportsInt) -> PyBbuTrackAll:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    bbu_beam : 
    bbu_param : 
    beam_init : 
    hom_voltage_normalized : 
    growth_rate : 
    lost : 
    irep : 
    """
def beam_envelope_ibs(sigma_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], tail_cut: bool, tau: typing.SupportsFloat, energy: typing.SupportsFloat, n_part: typing.SupportsFloat, species: typing.SupportsInt) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    This is a sigma matrix based IBS calculation.
    
    It takes the beam sigma matrix and returns a matrix with changes to the 2nd order
    moments due to IBS.
    Use ibs_mat to change the sigma matrix like this:
    sigma_matrix_updated = sigma_matrix + ibs_mat*element_length
    See subroutine transport_with_sr_and_ibs in this module.
    
    Parameters
    ----------
    sigma_mat : float
        beam sigma_matrix at element entrance
    tail_cut : bool
        If true, then apply tail cut to coulomb logarithm.
    tau : float
        horizontal betatron damping rate.  Needed if tail_cut is true.
    energy : float
        beam energy in eV
    n_part : float
        number of particles in the bunch
    species : int
        Partical species.
    
    Returns
    -------
    ibs_mat : float
        changes in 2nd order moments due to IBS are ibs_mat*element_length
    """
def beam_equal_beam(beam1: BeamStruct, beam2: BeamStruct) -> None:
    """
    Subroutine to set one particle beam equal to another taking care of
    
    pointers so that they don't all point to the same place.
    
    Parameters
    ----------
    beam2 : BeamStruct
        Input beam Output
    beam1 : BeamStruct
        Output beam
    """
def beam_tilts(S: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    Given a 6x6 matrix of second-order moments, this routine returns
    
    the beam tilts.
    angle_xy is obtained from the projection of the beam envelop into the
    xy plane.  The angle is that between the major axis of the projected
    beam envelope and the +x axis.  Positive angles are measured towards the
    +y axis.
    angle_xz is obtained from the projection of the beam envelop into the
    xy plane.  The angle is that between the major axis of the projected beam envelope
    and the +z axis.  Positive angles are measured towards the +x axis.
    angle_yz is obtained from the projection of the beam envelop into the
    yz plane.  The angle is that between the major axis of the projected beam envelope
    and the +z axis.  Positive angles are measured towards the +y axis.
    
    Parameters
    ----------
    S : float
        matrix of second order moments of beam envelope
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    angle_xy : float
        transverse tilt of beam envelope
    angle_xz : float
        horizontal crabbing of beam envelope
    angle_yz : float
        vertical crabbing of beam envelope
    angle_xpz : float
        x-pz coupling
    angle_ypz : float
        y-pz coupling
    """
def bend_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orb: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None, track_spin: bool | None = None) -> None:
    """
    Subroutine to track through the edge field of an sbend.
    
    This routine is called by apply_element_edge_kick only.
    
    Parameters
    ----------
    ele : EleStruct
        SBend element.
    param : LatParamStruct
        Rel charge.
    particle_at : int
        first_track_edge$, or second_track_edge$.
    orb : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
    mat6 : float, optional
        Transfer matrix before fringe.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        including fringe.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    track_spin : bool, optional
        If True then track the spin through the edge fields. Default: False.
    """
def bend_exact_multipole_field(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct, local_ref_frame: bool, calc_dfield: bool | None = None, calc_potential: bool | None = None) -> EmFieldStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : unknown
        Bend element.
    param : LatParamStruct
        Lattice branch parameters.
    orbit : CoordStruct
        particle position.
    local_ref_frame : bool
        Is the particle position in the local element ref frame (as opposed to the lab frame)?
    field : EmFieldStruct
        Field
    calc_dfield : bool, optional
        If present and True then calculate the field derivatives.
    calc_potential : bool, optional
        Calc electric and magnetic potentials? Default is false.
    """
def bend_length_has_been_set(ele: EleStruct, is_set: bool) -> PyBendLengthHasBeenSet:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to be checked. Ouput:
    is_set : 
    """
def bend_photon_e_rel_init(r_in: typing.SupportsFloat | None = None) -> float:
    """
    Routine to convert a random number in the interval [0,1] to a photon energy.
    
    The photon probability spectrum is:
    P(E_rel) = (3 / (5 * Pi)) * Integral_{E_rel}^{Infty} K_{5/3}(x) dx
    Where
    P(E_rel)) = Probability of finding a photon at relative energy E_rel.
    E_rel     = Relative photon energy: E / E_crit, E_crit = Critical energy.
    K_{5/3}   = Modified Bessel function.
    Notice that the P(E) is not the same as the distribution radiation energy since
    the photons must be energy weighted.
    There is a cut-off built into the calculation so that E_rel will be in the
    range [0, 31.4]. The error in neglecting photons with E_rel > 31.4 translates
    to neglecting one photon for every 10^15 generated.
    If r_in is present:
    r_in = 0 => E_rel = 0
    r_in = 1 => E_rel = 31.4
    
    Parameters
    ----------
    r_in : float, optional
        Integrated probability in the range [0,1]. If not present, a random number will be used.
    
    Returns
    -------
    E_rel : float
        Relative photon energy E/E_crit.
    """
def bend_photon_energy_integ_prob(E_photon: typing.SupportsFloat, g_bend: typing.SupportsFloat, gamma: typing.SupportsFloat) -> float:
    """
    Routine to find the integrated probability corresponding to emitting a photon
    
    from a bend in the range [0, E_photon].
    
    Parameters
    ----------
    E_photon : float
        Photon energy.
    g_bend : float
        1/rho bending strength.
    gamma : float
        Relativistic gamma factor of generating charged particle.
    
    Returns
    -------
    integ_prob : float
        Integrated probability. Will be in the range [0, 1].
    """
def bend_photon_energy_normalized_probability(E_rel: typing.SupportsFloat) -> float:
    """
    Routine to return the normalized probability that a photon will be emitted in a bend with energy
    
    E_rel relative to the critical energy. The probability is normalized such that
    Integral[0,Infinity] dE_rel P(E_rel) = 1
    
    Parameters
    ----------
    E_rel : float
        Photon energy relative to the critical energy.
    
    Returns
    -------
    prob : float
        Normalized probability.
    """
def bend_photon_init(g_bend_x: typing.SupportsFloat, g_bend_y: typing.SupportsFloat, gamma: typing.SupportsFloat, E_min: typing.SupportsFloat | None = None, E_max: typing.SupportsFloat | None = None, E_integ_prob: typing.SupportsFloat | None = None, vert_angle_min: typing.SupportsFloat | None = None, vert_angle_max: typing.SupportsFloat | None = None, vert_angle_symmetric: bool | None = None, emit_probability: typing.SupportsFloat | None = None) -> CoordStruct:
    """
    vert_angle_min, vert_angle_max, vert_angle_symmetric, emit_probability)
    
    Routine to initalize a photon for dipole bends and wigglers (but not undulators).
    The photon is initialized using the standard formulas for bending radiation.
    The energy of the photon is calculated in one of two ways:
    1) If E_integ_prob is present and non-negative, the photon energy E will be such that the integrated
    probability  [E_min, E] relative to the integrated probability in the range [E_min, E_max] is E_integ_prob.
    That is, E_integ_prob can be used to to give a set of photon energies equally spaced in terms of the
    integrated probability distribution.
    2) If E_integ_prob is not present, or is negative, the photon energy is chosen at random in
    the range [E_min, E_max].
    An E_integ_prob of zero means that the generated photon will have energy E_min.
    An E_integ_prob of one means that the generated photon will have energy E_max.
    The photon's polarization, will have unit amplitude.
    This routine assumes that the emitting charged particle is on-axis and moving in
    the forward direction. To correct for the actual charged particle postion use the routine
    absolute_photon_position
    
    Parameters
    ----------
    g_bend_x : float
        Bending 1/rho component in horizontal plane.
    g_bend_y : float
        Bending 1/rho component in vertical plane.
    gamma : float
        Relativistic gamma factor of generating charged particle.
    E_min : float, optional
        Minimum photon energy. Default is zero. Ignored if negative.
    E_max : float, optional
        Maximum photon energy.  Default is Infinity. Ignored if negative. If non-positive then E_max will be taken
        to be Infinity.
    E_integ_prob : float
        , optional :: integrated energy probability. See above. If E_integ_prob is non-negative, it must be in the
        range [0, 1].
    vert_angle_min : float, optional
        Minimum vertical angle to emit a photon. -pi/2 is used if argument not present or if argument is less than
        -pi/2.
    vert_angle_max : float, optional
        Maximum vertical angle to emit a photon. pi/2 is used if argument not present or if argument is greater
        than pi/2.
    vert_angle_symmetric : bool, optional
        Default is False. If True, photons will be emitted in the range [-vert_angle_max, -vert_angle_min] as well
        as the range [vert_angle_min, vert_angle_max]. In this case vert_angle_min/max must be positive.
    emit_probability : float, optional
        Probability of emitting a photon in the range [E_min, E_max] or in the vertical angular range given. The
        probability is normalized so that the probability of emitting if no ranges are given is 1.
    
    Returns
    -------
    orbit : CoordStruct
        Initialized photon.
    """
def bend_photon_polarization_init(g_bend_x: typing.SupportsFloat, g_bend_y: typing.SupportsFloat, E_rel: typing.SupportsFloat, gamma_phi: typing.SupportsFloat) -> CoordStruct:
    """
    Routine to set a photon's polarization.
    
    The photon's polarization will be either in the plane of the bend or out of the plane and
    the magnitude will be 1.
    
    Parameters
    ----------
    g_bend_x : float
        Bending 1/rho component in horizontal plane.
    g_bend_y : float
        Bending 1/rho component in vertical plane.
    E_rel : float
        Relative photon energy E/E_crit.
    gamma_phi : float
        gamma * phi where gamma is the beam relativistic factor and phi is the vertical photon angle (in radians).
    
    Returns
    -------
    orbit : CoordStruct
        Photon coords .field(2)     -- (x,y) polaraization. Will have unit magnitude .phase(2)     -- (x,y)
        phases. Will be [0, pi/2].
    """
def bend_photon_vert_angle_init(E_rel: typing.SupportsFloat, gamma: typing.SupportsFloat, r_in: typing.SupportsFloat | None = None, invert: bool | None = None) -> float:
    """
    Routine to convert an integrated probability to a vertical angle for emitting a photon from a bend.
    
    The integrated probability is in the range [0,1] with 0 corresponding to a phi = -pi/2 and
    integrated probability of 1 corresponding to phi = pi/2.
    
    Parameters
    ----------
    E_rel : float
        Relative photon energy E/E_crit.
    gamma : float
        beam relativistic factor
    r_in : float, optional
        Integrated probability in the range [0,1]. If not present, a random number will be used.
    invert : float, optional
        If True then take r_in as the inverse integrated probability with inverted probability = 1 - probability.
        This is useful to avoid round-off errors when for looking at the tail of the distribution where the
        integrated prob is very close to 1 and small deviations can have large effects. Default is False.
    
    Returns
    -------
    phi : float
        The photon vertical emission angle (in radians). Note: phi is an increasing monotonic function of r_in.
    """
def bend_shift(position1: FloorPositionStruct, g: typing.SupportsFloat, delta_s: typing.SupportsFloat, ref_tilt: typing.SupportsFloat | None = None, position2: FloorPositionStruct) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
    """
    No docstring available
    
    Parameters
    ----------
    position1 : FloorPositionStruct
        Position of particle in inital coordinate frame.
    g : float
        Curvature (1/rho)
    delta_s : float
        S-position of final frame relative to the initial frame.
    w_mat : float
        W matrix used in the transformation
    ref_tilt : float, optional
        ref_tilt. Default: 0
    position2 : 
    """
def bend_vert_angle_integ_prob(vert_angle: typing.SupportsFloat, E_rel: typing.SupportsFloat, gamma: typing.SupportsFloat) -> float:
    """
    Routine to find the integrated probability corresponding to emitting a photon
    
    from a bend and with relative energy E_rel in the vertical angle range [-pi/2, vert_angle/2].
    
    Parameters
    ----------
    vert_angle : float
        Vertical angle.
    E_rel : float
        Relative photon energy E/E_crit.
    gamma : float
        Relativistic gamma factor of generating charged particle.
    
    Returns
    -------
    integ_prob : float
        Integrated probability. Will be in the range [0, 1].
    """
def bicubic_cmplx_eval(x_norm: typing.SupportsFloat, y_norm: typing.SupportsFloat, bi_coef: BicubicCmplxCoefStruct) -> ...:
    """
    Routine to evaluate a bicubic interpolating complex function.
    
    Use the routine bicubic_interpolation_cmplx_coefs to generate bi_coef.
    
    Parameters
    ----------
    x_norm : float
        x_norm = (x - x0) / dx
    y_norm : float
        y_norm = (y - y0) / dy
    bi_coef : BicubicCmplxCoefStruct
        Coefficients.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    f_val : complex
        Value of f.
    df_dx : complex
        Normalized first derivative: True df/dx = df_dx * dx
    df_dy : complex
        Normalized first derivative: True df/dy = df_dy * dy
    """
def bin_index(x: typing.SupportsFloat, bin1_x_min: typing.SupportsFloat, bin_delta: typing.SupportsFloat) -> int:
    """
    Helper function to locate the appropriate histogram bin index.
    
    Parameters
    ----------
    x : float
        Input value to bin.
    bin1_x_min : float
        Minimum value of bin with index 1.
    bin_delta : float
        Bin width.
    
    Returns
    -------
    ix_bin : int
        Index of bin x is in.
    """
def bin_x_center(ix_bin: typing.SupportsInt, bin1_x_min: typing.SupportsFloat, bin_delta: typing.SupportsFloat) -> PyBinXCenter:
    """
    Helper function to locate the center of a histogram bin.
    
    Parameters
    ----------
    ix_bin : int
        Index of bin under question.
    bin1_x_min : float
        Minimum value of bin with index 1.
    bin_delta : float
        Bin width.
    
    Returns
    -------
    x_center
    """
def bit_set(word: typing.SupportsInt, pos: typing.SupportsInt, set_to_1: bool) -> PyBitSet:
    """
    Routine to set a bit in a word.
    
    Parameters
    ----------
    word : int
        Input word
        This parameter is an input/output and is modified in-place. As an output: Word with bit set.
    pos : int
        position to set.
    set_to_1 : bool
        If True then bit is set to 1. If False bit is set to 0.
    """
def bl_via_vlassov(current: typing.SupportsFloat, alpha: typing.SupportsFloat, Energy: typing.SupportsFloat, sigma_p: typing.SupportsFloat, Vrf: typing.SupportsFloat, omega: typing.SupportsFloat, U0: typing.SupportsFloat, circ: typing.SupportsFloat, R: typing.SupportsFloat, L: typing.SupportsFloat) -> float:
    """
    This is a frontend for get_bl_from_fwhm from longitudinal_profile_mod.
    
    See longitudinal_profile_mod for details.  In short, this implements a model of potential well distortion
    based on the Vlassov equation which uses an effective Resistive, Inductive, and Capacitive impedance.
    
    Parameters
    ----------
    current : float
        Beam current in amps
    alpha : float
        Momentum compaction
    Energy : float
        beam energy
    sigma_p : float
        energy spread
    Vrf : float
        total RF voltage in Volts
    omega : float
        rf frequency in radians/s
    U0 : float
        energy loss per turn (eV)
    circ : float
        circumpherence
    R : float
        Resistive part of effective impedance
    L : float
        Inductive part of effective impedance
    
    Returns
    -------
    sigma_z : float
        Bunch length. FWHM/TwoRootTwoLogTwo from bunch profile
    """
def bmad_parser(lat_file: str, make_mats6: bool | None = None, use_line: str | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lat_file : unknown
        Name of the input file.
    lat : LatStruct
        Lat structure. See bmad_struct.f90 for more details. .ele(:).mat6      -- This is computed assuming an on-
        axis orbit if make_mats6 = T.
    make_mats6 : bool, optional
        Compute the 6x6 transport matrices for the Elements? Default is True. Do not set False unless you know
        what you are doing.
    digested_read_ok : bool
        Set True if the digested file was successfully read. False otherwise.
    use_line : unknown, optional
        If present and not blank, override the use statement in the lattice file and use use_line instead.
    err_flag : bool
        Set true if there is an error, false otherwise. Note: err_flag does *not* include errors in lat_make_mat6
        since if there is a match element, there is an error raised since the Twiss parameters have not been set
        but this is expected.
    parse_lat : LatStruct
        List of elements used to construct the lattice. Useful if bmad_parser2 will be called. See bmad_parser2
        documentation.
    """
def bmad_parser2(lat_file: str, lat: LatStruct, orbit: _pybmad.CoordStructAlloc1D | None = None, make_mats6: bool | None = None, err_flag: bool | None = None, parse_lat: _pybmad.LatStruct | None = None) -> PyBmadParser2:
    """
    No docstring available
    
    Parameters
    ----------
    lat_file : unknown
        Input file name.
    lat : LatStruct
        lattice with existing layout.
        This parameter is an input/output and is modified in-place. As an output: lattice with modifications.
    orbit : CoordStruct, optional
        closed orbit for when bmad_parser2 calls lat_make_mat6
    make_mats6 : bool, optional
        Make the 6x6 transport matrices for then Elements? Default is True.
    err_flag : 
    parse_lat : LatStruct, optional
        Used by bmad_parser to pass to bmad_parser2 a list of elements that were defined in the lattice file but
        not used. This is useful in preventing errors being generated if group/overlay elements definded by
        lat_file refer to unused slaves in parse_lat.
    """
def bmad_patch_parameters_to_ptc(ang: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], exi: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ang : 
    exi : 
    """
def bp_set_ran_status() -> None:
    """
    No docstring available
    """
def bracket_index_for_spline(x_knot: RealAlloc1D, x: typing.SupportsFloat, strict: bool | None = None, print_err: bool | None = None) -> ...:
    """
    Routine to find which interval to use for evaluating a spline.
    
    If strict = False (default), x is in range if
    x_knot(1) - (x_knot(2) - x_knot(1)) < x < x_knot(n) + (x_knot(n) - x_knot(n-1))
    If stric = True, x is in range if
    x_knot(1) <= x <= x_knot(n)
    where n = size(x_knot)
    
    Parameters
    ----------
    x_knot : float
        Array of x values.
    x : float
        Evaluation point.
    strict : bool, optional
        Default is False. Determines acceptible range.
    print_err : bool, optional
        Default is True. Print error message if out of range?
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ix0 : int
        If ok = True, x is in the interval [x_knot(ix0), x_knot(ix0+1)]
    ok : bool
        True if x is in range. False otherwise.
    """
def branch_equal_branch(branch2: BranchStruct) -> BranchStruct:
    """
    Subroutine that is used to set one branch equal to another.
    
    Parameters
    ----------
    branch2 : BranchStruct
        Input branch.
    
    Returns
    -------
    branch1 : BranchStruct
        Output branch.
    """
def branch_name(branch: BranchStruct, name: str) -> PyBranchName:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch
    name : 
    """
def branch_to_ptc_m_u(branch: BranchStruct) -> None:
    """
    Subroutine to create a PTC layout from a Bmad lattice branch.
    
    will be three corresponding PTC fibre elements: (drift, RF. drift) for example.
    In this case, ele%ptc_fibre will be set to point to the last PTC fibre. That is the
    exit end of ele will correspond to the exit end of ele%ptc_fibre.
    
    Parameters
    ----------
    branch : BranchStruct
        Input branch. branch(:).ptc              -- Pointers to generated layouts. branch(:).ele(:).ptc_fibre --
        Pointer to PTC fibres
    
    Notes
    -----
    Note: If a Bmad element is using a hard edge model (EG: RFcavity element), there
    """
def bunch_equal_bunch(bunch1: BunchStruct, bunch2: BunchStruct) -> None:
    """
    Subroutine to set one particle bunch equal to another.
    
    Parameters
    ----------
    bunch2 : BunchStruct
        Input bunch Output
    bunch1 : BunchStruct
        Output bunch
    """
def c_to_cbar(ele: EleStruct) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"]:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with C matrix and Twiss parameters. .c_mat(2,2) -- C matrix. .a          -- a-mode Twiss
        parameters .b          -- b-mode Twiss parameters
    cbar_mat : float
        Cbar matrix.
    """
def calc_bunch_params(bunch: BunchStruct, bunch_params: BunchParamsStruct, error: bool, print_err: bool | None = None, n_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, is_time_coords: bool | None = None, ele: _pybmad.EleStruct | None = None) -> None:
    """
    Finds all bunch parameters defined in bunch_params_struct, both normal-mode
    
    and projected. Projected parameters are found purely from the geometrical
    distribution of the beam. Normal-Mode parameters are found using the method
    developed in:
    "Alternate approach to general coupled linear optics"
    A. Wolski, PRST AB 9, 024001 (2006)
    
    Parameters
    ----------
    bunch : 
        Bunch_struct
    print_err : bool, optional
        If present and False then suppress "no eigen-system found" messages.
    is_time_coords : bool, optional
        Are particle coords using time coords. Default is False.
    ele : EleStruct, optional
        Element being tracked through. Must be present if is_time_coords = True. Output
    bunch_params : BunchParamsStruct
    error : bool
        Set True if there is an error.
    n_mat : float, optional
        N matrix defined in Wolski Eq 44 and used to convert from action-angle coords to lab coords (Wolski Eq
        51.).
    """
def calc_bunch_params_slice(bunch: BunchStruct, bunch_params: BunchParamsStruct, plane: typing.SupportsInt, slice_center: typing.SupportsFloat, slice_spread: typing.SupportsFloat, err: bool, print_err: bool | None = None, is_time_coords: bool | None = None, ele: _pybmad.EleStruct | None = None) -> None:
    """
    Finds bunch parameters for a slice of the beam.
    
    Parameters
    ----------
    bunch : 
        bunch_struct
    plane : int
        plane to slice through (x$, px$, & etc...)
    slice_center : float
        Center to take slice about
    slice_spread : float
        +/- spread in slice about center.
    print_err : bool, optional
        If present and False then suppress "no eigen-system found" messages.
    is_time_coords : bool, optional
        Default is False. If True, input bunch is using time coordinates in which case there will be a conversion
        to s-coords before bunch_params are computed.
    ele : EleStruct, optional
        Element being tracked through. Must be present if is_time_coords = True. Output
    params : BunchParamsStruct
    err : bool
        Set True if there is an error.
    """
def calc_bunch_params_z_slice(bunch: BunchStruct, bunch_params: BunchParamsStruct, slice_bounds: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], err: bool, print_err: bool | None = None, is_time_coords: bool | None = None, ele: _pybmad.EleStruct | None = None) -> None:
    """
    Finds bunch parameters for a slice of the beam.
    
    The slice is specified in terms of percentage of particles ordered by z-position.
    For example, slice_bounds = [0.0, 0.5] specifies the trailing half of the bunch
    
    Parameters
    ----------
    bunch : 
        bunch_struct
    slice_bounds : float
        Slice bounds in percentage of particles ordered by z-position. 0.0 is the back of the bunch and 1.0 is the
        front of the bunch.
    print_err : bool, optional
        If present and False then suppress "no eigen-system found" messages.
    is_time_coords : bool, optional
        Default is False. If True, input bunch is using time coordinates in which case there will be a conversion
        to s-coords before bunch_params are computed.
    ele : EleStruct, optional
        Element being tracked through. Must be present if is_time_coords = True. Output
    params : BunchParamsStruct
    err : bool
        Set True if there is an error.
    """
def calc_bunch_sigma_matrix_etc(particle: CoordStructAlloc1D, charge: RealAlloc1D, is_time_coords: bool | None = None, ele: _pybmad.EleStruct | None = None) -> PyCalcBunchSigmaMatrixEtc:
    """
    Routine to find the sigma matrix elements of a particle distribution.
    
    Parameters
    ----------
    particle : CoordStruct
        Array of particles.
    charge : float
        Particle charge or photon intensity.
    
    Returns
    -------
    bunch_params : BunchParamsStruct
        Bunch parameters. .sigma(6,6) .centroid.vec(6) .centroid.p0c .rel_max(6) .rel_min(6)
    """
def calc_emittances_and_twiss_from_sigma_matrix(sigma_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], print_err: bool | None = None) -> ...:
    """
    Routine to calc emittances and Twiss function from a beam sigma matrix.
    
    See: Andy Wolski "Alternative approach to general coupled linear optics".
    
    Parameters
    ----------
    sigma_mat : float
        Sigma matrix.
    print_err : bool, optional
        If present and False then suppress "no eigen-system found" messages.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    bunch_params : BunchParamsStruct
        Holds Twiss and emittance info.
    error : bool
        Set True if there is an error. Can happen if the emittance of a mode is zero.
    n_mat : float
        N matrix defined in Wolski Eq 44 and used to convert from action-angle coords to lab coords (Wolski Eq
        51.).
    """
def calc_file_number(file_name: str, num_in: typing.SupportsInt, num_out: typing.SupportsInt, err_flag: bool) -> PyCalcFileNumber:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    num_in : 
    num_out : 
    err_flag : 
    """
def calc_spin_params(bunch: BunchStruct) -> BunchParamsStruct:
    """
    Rotine to calculate spin averages
    
    Parameters
    ----------
    bunch : BunchStruct
        Bunch of spins
    
    Returns
    -------
    bunch_params : BunchParamStruct
        Structure holding average centroid.spin(3) -- (x,y,z) polarization.
    """
def calc_super_slave_key(lord1: EleStruct, lord2: EleStruct, create_jumbo_slave: bool | None = None) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lord1 : EleStruct
        First slave. .key .sub_key
    lord2 : EleStruct
        Second slave. .key .sub_key
    slave : EleStruct
        Super_slave element. .key        -- Set to -1 if there is an error. .sub_key
    create_jumbo_slave : bool, optional
        If True then slave.key will be set to em_field. -- Logical, optional: If True then slave.key will be set
        to em_field. Default is False.
    """
def calc_wall_radius(v: Wall3DVertexStructAlloc1D, cos_ang: typing.SupportsFloat, sin_ang: typing.SupportsFloat) -> ...:
    """
    Routine to calculate the wall radius at a given angle for a given cross-section
    
    Additionally, the transverse directional derivative is calculated.
    Module needed:
    use wall3d_mod
    
    Parameters
    ----------
    v : Wall3DVertexStruct
        Array of vertices that make up the cross-section.
    cos_ang : float
        cosine of the transverse photon position.
    sin_ang : float
        sine of the transverse photon position.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    r_wall : float
        Wall radius at given angle.
    dr_dtheta : float
        derivative of r_wall.
    ix_vertex : int
        Wall at given angle is between v(ix_vertex-1) and v(ix_vertex). If ix_vertex = 1 then Wall at given angle
        is between v(N) and v(1) where N = size(v).
    """
def calc_z_tune(branch: BranchStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch
    """
def canonical_to_angle_coords(orbit: CoordStruct, coord_type: str | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Orbit in canonical coordinates.
        This parameter is an input/output and is modified in-place. As an output: Orbit in angular coordinates.
    coord_type : unknown, optional
        Angular coordinates type '' (default): (x, x' = dx/ds, y, y' = dy/ds, z, pz) 'ZGOUBI':     (x, x' = dx/ds,
        y, y' = dy/ds, dt = -z / (beta * c), pz)
    """
def cbar_to_c(cbar_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]], "FixedSize(2)"], a: TwissStruct, b: TwissStruct) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"]:
    """
    No docstring available
    
    Parameters
    ----------
    cbar_mat : float
        Cbar matrix.
    a : TwissStruct
        a-mode Twiss parameters
    b : TwissStruct
        b-mode Twiss parameters
    c_mat : float
        C matrix.
    """
def change_file_number(file_name: str, change: typing.SupportsInt) -> PyChangeFileNumber:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    change : 
    """
def charge_of(species: typing.SupportsInt, default_: typing.SupportsInt | None = None) -> int:
    """
    Routine to return the charge, in units of e+, of a particle.
    
    Parameters
    ----------
    species : int
        Species ID.
    default : int, optional
        If present then use default value if species = not_set$.
    
    Returns
    -------
    charge : int
        particle charge.
    """
def charge_to_mass_of(species: typing.SupportsInt) -> float:
    """
    Routine to return the charge (in units of e+) to mass (in units of eV) ratio of a particle.
    
    Parameters
    ----------
    species : int
        Species ID.
    
    Returns
    -------
    charge_mass_ratio : float
        particle charge to mass ratio. (1/eV)
    """
def check_aperture_limit(orb: CoordStruct, ele: EleStruct, particle_at: typing.SupportsInt, param: LatParamStruct, old_orb: _pybmad.CoordStruct | None = None, check_momentum: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orb : CoordStruct
        coordinates of a particle.
    ele : EleStruct
        Element holding the aperture
    particle_at : int
        first_track_edge$, second_track_edge$, surface$, in_between$
    param : LatParamStruct
        Lattice global parameter structure.
    old_orb : CoordStruct, optional
        Old coordinates at last check. Needed if ele.aperture_at = wall_transition$. If not present then wall
        transitions will be ignored.
    check_momentum : bool, optional
        If present and false then checking of p_x and p_y will be disabled.
    """
def check_controller_controls(ele_key: typing.SupportsInt, contrl: ControlStructAlloc1D, name: str) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    ele_key : int
        Element type. overlay$, etc.
    contrl : ControlStruct
        control info. 1 element for each slave.
    name : unknown
        Lord name. Used for error reporting.
    err : bool
        Set true if there is a problem. False otherwise.
    """
def check_for_superimpose_problem(branch: BranchStruct, super_ele: EleStruct, err_flag: bool, ref_ele: _pybmad.EleStruct | None = None, wrap: bool) -> PyCheckForSuperimposeProblem:
    """
    Subroutine to check if there is a problem superimposing an element when there is multipass.
    
    In particular will check that:
    1) If the ref_ele is part of a multipass region then super_ele must be superimposed
    within the region.
    Or:
    2) If the ref_ele is not part of a multipass region then super_ele must also not
    be part of a multipass region.
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    """
def check_if_s_in_bounds(branch: BranchStruct, s: typing.SupportsFloat, print_err: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Branch
    s : float
        longitudinal position in the given branch.
    err_flag : bool
        Set True if s position is out-of-bounds. False otherwise.
    translated_s : float
        position translated to the range [0, branch_length]
    print_err : bool, optional
        Print error message if there is an error? Default is True.
    """
def check_rf_freq(lat: LatStruct, fb: typing.SupportsFloat) -> PyCheckRfFreq:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    fb : 
    """
def choose_quads_for_set_tune(branch: BranchStruct, mask: str | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch.
    dk1 : float
        Weights for the quadrupoles. All values will be +1 or -1.
    eles : ElePointerStruct
        eles(i).ele points to element with dk1(i) weight.
    mask : unknown, optional
        If present, assign weight of zero for all quads that do not match. That is, no variation for matching
        quads.
    err_flag : bool
        Set True if there is not one quad with positive dk1 and one quad with negative dk1.
    """
def chrom_calc(lat: LatStruct, delta_e: typing.SupportsFloat, pz: typing.SupportsFloat | None = None, ix_branch: typing.SupportsInt | None = None, orb0: _pybmad.CoordStruct | None = None) -> PyChromCalc:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat
    delta_e : float
        +/- Delta energy used for the calculation. Notice that the energy difference between high and low is 2 *
        delta_e. If 0 then default of 1.0d-4 is used.
        This parameter is an input/output and is modified in-place. As an output: Set to 1.0d-4 if on input
        DELTA_E =< 0.
    chrom_a : float
        a-mode chromaticity.
    chrom_b : float
        b-mode chromaticity.
    err_flag : bool
        Set true if there is an error. False otherwise.
    pz : float, optional
        reference momentum about which to calculate. Default is 0.
    low_E_lat : LatStruct
        Lattice with RF off and matrices computed at E_lat +pz - delta_e
    high_E_lat : LatStruct
        Lattice with RF off and matrices computed at E_lat +pz + delta_e
    low_E_orb : CoordStruct
        Orbit computed at E_lat + pz - delta_e.
    high_E_orb : CoordStruct
        Orbit computed at E_lat + pz + delta_e.
    ix_branch : int, optional
        Index of the lattice branch to use. Default is 0.
    orb0 : CoordStruct, optional
        On-energy orbit at start (fixer point). Default is the branch.particle_start. Only needed if lattice
        branch has an open geometry.
    """
def chrom_tune(lat: LatStruct, delta_e: typing.SupportsFloat, target_x: typing.SupportsFloat, target_y: typing.SupportsFloat, err_tol: typing.SupportsFloat) -> PyChromTune:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to use,
        This parameter is an input/output and is modified in-place. As an output: Lat with sextupole set
    delta_e : float
        Delta energy used for the calculation. If 0 then default of 1.0d-4 is used.
        This parameter is an input/output and is modified in-place. As an output: Set to 1.0d-4 if on input
        DELTA_E =< 0.
    target_x : float
        Target X Chromaticity
    target_y : float
        Target Y Chromaticity
    err_tol : float
        Max allowable Error: Error = | X_Target - X_Actual | + | Y_Target -Y_Actual | A good number is: err_tol =
        0.05_rp
    err_flag : bool
        .false. if match successful, .true. if failed Fails if takes longer than 100 iterations. If it fails the
        sextupoles are set to the last value calculated. Note: This subroutine assumes the Twiss parameters have
        been computed.
    """
def classical_radius(species: typing.SupportsInt, radius: typing.SupportsFloat) -> PyClassicalRadius:
    """
    No docstring available
    
    Parameters
    ----------
    species : int
        Species of particle.
    radius : 
    """
def clear_lat_1turn_mats() -> LatStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat with 1-turn matrices cleared.
    """
def clear_taylor_maps_from_elements(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
        This parameter is an input/output and is modified in-place. As an output: Lattice with all maps cleared
    """
def closed_orbit_calc(lat: LatStruct, closed_orb: CoordStructAlloc1D, i_dim: typing.SupportsInt | None = None, direction: typing.SupportsInt | None = None, ix_branch: typing.SupportsInt | None = None, print_err: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to track through.
    closed_orb : CoordStruct
        closed_orb(nt) is the initial guess where nt = 0 for direction = 1 and nt = lat.n_ele_track for direction
        = -1. Additionally, if i_dim = 4, then closed_orb(nt).vec(6) is used as the energy around which the closed
        orbit is calculated.
        This parameter is an input/output and is modified in-place. As an output: Closed orbit. closed_orb(i)
    i_dim : int, optional
        Phase space dimensions to use: = 4  Transverse closed orbit at constant energy (RF off). (dE/E =
        closed_orb(0).vec(6)) = 5 Transverse closed orbit at constant energy (RF off) with the energy adjusted so
        that vec(5) is the same at the beginning and at the end. = 6 True closed orbit. Default: 4 if RF is off, 6
        if RF is on.
    direction : int, optional
        Direction of tracking. +1 --> forwad (default), -1 --> backward. The closed orbit will be dependent on
        direction only in the case that radiation damping is turned on.
    ix_branch : int, optional
        Lattice branch to find the closed orbit of. Default is 0 (main branch).
    err_flag : bool
        Set true if there is an error. False otherwise.
    print_err : bool, optional
        Print error message if calc does not converge? Default is True. Note: Condition messages like no RF
        voltage with i_dim = 6 will always be printed.
    """
def closed_orbit_from_tracking(lat: LatStruct, i_dim: typing.SupportsInt, eps_rel: _pybmad.RealAlloc1D | None = None, eps_abs: _pybmad.RealAlloc1D | None = None, init_guess: _pybmad.CoordStruct | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to track through.
    closed_orb : CoordStruct
        closed orbit. This routine will allocate this array for you.
    i_dim : int
        = 2,4  Transverse closed orbit at constant energy. = 6    Full closed orbit using the entire transfer 6x6
        matrix.
    eps_rel : float, optional
        Relative allowed error. Default is bmad_com.rel_tol_tracking
    eps_abs : float, optional
        Absolute allowed error. Default is bmad_com.abs_tol_tracking
    init_guess : CoordStruct, optional
        Starting guess for the closed orbit at the start of the lattice. Set init_guess.vec(6) to the appropriate
        value of pz when calculating off-energy orbits. If not present then the origin will be used.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def cmplx_re_str(cmp: complex, str_out: str) -> PyCmplxReStr:
    """
    No docstring available
    
    Parameters
    ----------
    cmp : 
    str_out : 
    """
def coarse_frequency_estimate(data: RealAlloc1D, error: bool | None = None) -> PyCoarseFrequencyEstimate:
    """
    Simple function to take periodic data and estimate
    
    the most dominant frequency by FFT.
    
    Parameters
    ----------
    data : float
        data to analyze. Preferably size(data) is a power of 2 Otherwise the data is padded with zeros.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    frequency : float
        Frequency corresponding to the largest FFT amplitude
    err : bool
        Error: not enough data. Frequency is near 0 or 0.5
    """
def combine_consecutive_elements(lat: LatStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice.
        This parameter is an input/output and is modified in-place. As an output: Lattice with elements combined.
    error : bool
        Set True if there is an error. False otherwise.
    """
def complex_error_function(wr: typing.SupportsFloat, wi: typing.SupportsFloat, zr: typing.SupportsFloat, zi: typing.SupportsFloat) -> PyComplexErrorFunction:
    """
    No docstring available
    
    Parameters
    ----------
    wr : 
    wi : 
    zr : 
    zi : 
    """
def complex_taylor_clean(complex_taylor: ComplexTaylorStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    complex_taylor : 
    """
@typing.overload
def complex_taylor_coef(complex_taylor: ComplexTaylorStruct, exp: IntAlloc1D, coef: complex) -> PyComplexTaylorCoef1:
    """
    Function to return the coefficient for a particular complex_taylor term
    
    from a complex_taylor Series. This routine is used by the overloaded function
    complex_taylor_coef. See complex_taylor_coef for more details.
    """
@typing.overload
def complex_taylor_coef(complex_taylor: ComplexTaylorStruct, i1: typing.SupportsInt | None = None, i2: typing.SupportsInt | None = None, i3: typing.SupportsInt | None = None, i4: typing.SupportsInt | None = None, i5: typing.SupportsInt | None = None, i6: typing.SupportsInt | None = None, i7: typing.SupportsInt | None = None, i8: typing.SupportsInt | None = None, i9: typing.SupportsInt | None = None, coef: complex) -> PyComplexTaylorCoef2:
    """
    Function to return the coefficient for a particular complex_taylor term
    
    from a complex_taylor Series. This routine is used by the overloaded function
    complex_taylor_coef. See complex_taylor_coef for more details.
    """
def complex_taylor_equal_complex_taylor(complex_taylor2: ComplexTaylorStruct) -> ComplexTaylorStruct:
    """
    Subroutine that is used to set one complex_taylor equal to another.
    
    This routine takes care of the pointers in complex_taylor1.
    
    Parameters
    ----------
    complex_taylor2 : ComplexTaylorStruct
        Input complex_taylor.
    
    Returns
    -------
    complex_taylor1 : ComplexTaylorStruct
        Output complex_taylor.
    """
def complex_taylor_exponent_index(expn: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(6)"]) -> int:
    """
    Function to associate a unique number with a complex_taylor exponent.
    
    The number associated with a complex_taylor_term that is used for the sort is:
    number = sum(exp(i))*10^6 + exp(6)*10^5 + ... + exp(1)*10^0
    where exp(1) is the exponent for x, exp(2) is the exponent for P_x, etc.
    
    Parameters
    ----------
    expn : int
        complex_taylor exponent
    
    Returns
    -------
    index : int
        Sorted complex_taylor series.
    """
def complex_taylor_make_unit() -> ComplexTaylorStructAlloc1D:
    """
    Subroutine to make the unit complex_taylor map:
    
    r(out) = Map * r(in) = r(in)
    
    
    Returns
    -------
    complex_taylor : ComplexTaylorStruct
        Unit complex_taylor map .
    """
def complex_taylor_to_mat6(a_complex_taylor: typing.Annotated[collections.abc.Sequence[ComplexTaylorStruct], "FixedSize(6)"], r_in: ComplexAlloc1D) -> ...:
    """
    Subroutine to calculate, from a complex_taylor map and about some trajectory:
    
    The 1st order (Jacobian) transfer matrix.
    
    Parameters
    ----------
    a_complex_taylor : ComplexTaylorStruct
        complex_taylor map.
    r_in : complex
        Coordinates at the input.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    vec0 : complex
        0th order tranfsfer map
    mat6 : complex
        1st order transfer map (6x6 matrix).
    r_out : complex
        Coordinates at output.
    """
def complex_taylors_equal_complex_taylors(complex_taylor2: ComplexTaylorStructAlloc1D) -> ComplexTaylorStructAlloc1D:
    """
    Subroutine to transfer the values from one complex_taylor map to another:
    
    complex_taylor1 <= complex_taylor2
    
    Parameters
    ----------
    complex_taylor2 : ComplexTaylorStruct
        complex_taylor map.
    
    Returns
    -------
    complex_taylor1 : ComplexTaylorStruct
        complex_taylor map.
    """
def compute_slave_coupler(slave: EleStruct) -> None:
    """
    This routine is not meant for general use.
    """
def concat_ele_taylor(orb_taylor: TaylorStructAlloc1D, ele: EleStruct, err_flag: bool, spin_taylor: _pybmad.TaylorStructAlloc1D | None = None) -> None:
    """
    Routine to concatinate an orbital taylor map and, optionally if present and
    
    bmad_com%spin_tracking_on = T, a spin taylor map.
    Transform:
    orb_taylor[x] -> ele_taylor(orb_taylor[x])
    If ele%taylor_map_includes_offsets = True:  ele_taylor == ele%taylor
    If ele%taylor_map_includes_offsets = False: ele_taylor == ele%taylor + offset corrections.
    
    Parameters
    ----------
    orb_taylor : TaylorStruct
        Orbital Taylor map.
    ele : EleStruct
        Element containing a Taylor map.
    spin_taylor : TaylorStruct, optional
        Spin map to propagate Output
    orb_taylor : TaylorStruct
        Concatinated orbital map
    err_flag : bool
        Set True if there is an error. False otherwise.
    spin_taylor : TaylorStruct, optional
        Concatinated spin map.
    
    Notes
    -----
    Related routines:
    concat_taylor
    """
def concat_taylor(taylor1: TaylorStructAlloc1D, taylor2: TaylorStructAlloc1D, taylor3: TaylorStructAlloc1D) -> None:
    """
    Subroutine to concatinate two taylor maps:
    
    taylor3[x] = taylor2(taylor1[x])
    
    Parameters
    ----------
    taylor1 : TaylorStruct
        Taylor map.
    taylor2 : TaylorStruct
        Taylor map. Output
    taylor3 : TaylorStruct
        Concatinated map
    """
def concat_transfer_mat(mat_1: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], vec_1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"], mat_0: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], vec_0: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"], vec_out: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    Routine to concatinate two linear maps:
    
    mat_out = matmul(mat_1, mat_0)
    vec_out = matmul(mat_1, vec_0) + vec_1
    
    Parameters
    ----------
    mat_1 : float
        Map from s1 to s2
    mat_0 : float
        Map from s0 to s1
    
    Returns
    -------
    mat_out : float
        Map from s0 to s2
    """
def control_bookkeeper(lat: LatStruct, ele: _pybmad.EleStruct | None = None, err_flag: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        lattice to be used
    ele : EleStruct, optional
        Element whose attribute values have been changed. If not present bookkeeping will be done for all
        elements.
    err_flag : bool, optional
        Set True if there is an error. False otherwise.
    """
def convert_bend_exact_multipole(g: typing.SupportsFloat, out_type: typing.SupportsInt, an: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(21)"], bn: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(21)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    g : float
        1/rho bending strength.
    out_type : int
        Output type: horizontally_pure$ or vertically_pure$.
    an : float
        Skew multipoles.
        This parameter is an input/output and is modified in-place. As an output: Converted skew multipoles.
    bn : float
        Non-skew multipoles.
        This parameter is an input/output and is modified in-place. As an output: Converted Non-skew multipoles.
    """
def convert_coords(in_type_str: str, coord_in: CoordStruct, ele: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    in_type_str : unknown
        type of the input coords.
    coord_in : CoordStruct
        Input coordinates.
    ele : EleStruct
        Provides the Twiss parameters.
    out_type_str : unknown
        type of the output coords.
    coord_out : CoordStruct
        Output coordinates.
    err_flag : bool
        Set True if there is an error. False otherwise. in_type_str and out_type_str can be: 'LAB'
        {x, x', y, y', z, z'} 'MODE'               {a, a', b, b', z, z'} 'NORMALIZED'         {a_bar, a'_bar,
        b_bar, b'_bar, z_bar, z'_bar} 'ACTION-ANGLE'       {j_a, phi_a, j_b, phi_b, j_z,  phi_z} x_vec = V_mat *
        (a_vec + eta_vec * z') a_bar  =  sqrt(2*j_a) * cos(phi_a) a'_bar = -sqrt(2*j_a) * sin(phi_a) Note: 1) If
        ELE.Z.BETA = 0 then ELE.Z.BETA is set to 1. 2) phases are in radians
    """
def convert_field_ele_to_lab(ele: EleStruct, s_here: typing.SupportsFloat, forward_transform: bool, calc_dfield: bool | None = None, calc_potential: bool | None = None) -> EmFieldStruct:
    """
    Convert fields: ele to lab coords
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    s_here : 
        real(rp) S-position.
    forward_transform : 
        Transform foward (to lab) or reverse.
    calc_dfield : bool, optional
        If present and True then calculate the field derivatives.
    calc_potential : bool, optional
        Calc electric and magnetic potentials? Default is false. This is experimental and only implemented for
        wigglers at present.
    
    Returns
    -------
    field : EmFieldStruct
        EM field.
    """
def convert_local_cartesian_to_local_curvilinear(x: typing.SupportsFloat, z: typing.SupportsFloat, g: typing.SupportsFloat, xout: typing.SupportsFloat, sout: typing.SupportsFloat) -> PyConvertLocalCartesianToLocalCurvilinear:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    z : 
    g : 
    xout : 
    sout : 
    """
def convert_local_curvilinear_to_local_cartesian(x: typing.SupportsFloat, s: typing.SupportsFloat, g: typing.SupportsFloat, xout: typing.SupportsFloat, zout: typing.SupportsFloat) -> PyConvertLocalCurvilinearToLocalCartesian:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    s : 
    g : 
    xout : 
    zout : 
    """
def convert_particle_coordinates_s_to_t(particle: CoordStruct, s_body: typing.SupportsFloat, orientation: typing.SupportsInt) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    particle : CoordStruct
        Particle with .vec(:) in s-coords.
    s_body : float
        s-position in element body coords.
    orientation : int
        ele.orientation for vec(6).
    """
def convert_particle_coordinates_t_to_s(particle: CoordStruct, ele: EleStruct, use_downstream_p0c: bool | None = None) -> float:
    """
    No docstring available
    
    Parameters
    ----------
    particle : CoordStruct
        Particle with .vec(:) in t-coords.
    ele : EleStruct
        Element particle is going through.
    s_body : float
        s-position in element body coords.
    use_downstream_p0c : bool, optional
        If True (the default), use ele.value(p0c$) as the reference momentum. If False, use ele.value(p0c_start$)
        as the reference.
    """
def convert_pc_to(pc: typing.SupportsFloat, particle: typing.SupportsInt) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    pc : float
        Particle momentum
    particle : int
        Type of particle. positron$, etc.
    E_tot : float
        Total energy of the particle.
    gamma : float
        Gamma factor.
    kinetic : float
        Kinetic energy
    beta : float
        velocity / c_light
    brho : float
        Nominal B_field*rho_bend
    beta1 : float
        1 - beta. Equal to 1/(2*gamma^2) in ultra-rel limit.
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def convert_total_energy_to(E_tot: typing.SupportsFloat, particle: typing.SupportsInt, print_err: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    E_tot : float
        Total energy of the particle.
    particle : int
        Type of particle. positron$, etc.
    gamma : float
        Gamma factor. Set to -1 for photons.
    kinetic : float
        Kinetic energy
    beta : float
        velocity / c_light
    pc : float
        Particle momentum
    brho : float
        Nominal B_field*rho_bend
    beta1 : float
        1 - beta. Equal to 1/(2*gamma^2) in ultra-rel limit.
    err_flag : bool
        Set true if there is an error. False otherwise.
    print_err : bool, optional
        Print error message if E_tot < particle mass? Default is True.
    """
def converter_distribution_parser(ele: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Converter element.
        This parameter is an input/output and is modified in-place. As an output: Converter element with
        .converter field set.
    delim : unknown
        Ending delimitor.
    delim_found : bool
        Has a delimitor been found?
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def coord_equal_coord(coord2: CoordStruct) -> CoordStruct:
    """
    Subroutine that is used to set one coord equal to another.
    
    Parameters
    ----------
    coord2 : CoordStruct
        Input coord.
    
    Returns
    -------
    coord1 : CoordStruct
        Output coord.
    """
def coord_state_name(coord_state: typing.SupportsInt, one_word: bool | None = None) -> PyCoordStateName:
    """
    Routine to return the string representation of a coord%state state.
    
    Parameters
    ----------
    coord_state : int
        coord.state value
    
    Returns
    -------
    state_str : unknown
        String representation.
    """
def coords_body_to_local(body_position: FloorPositionStruct, ele: EleStruct, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None, calculate_angles: bool | None = None, local_position: FloorPositionStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    body_position : FloorPositionStruct
        Element body frame coordinates. .r(3)               [x, y, s] position with s = Position from entrance end
        of element.
    ele : EleStruct
        element that local_position coordinates are relative to.
    w_mat : float, optional
        W matrix at to transform vectors. v_local  = w_mat . v_body v_body   = transpose(w_mat) . v_local
    calculate_angles : bool, optional
        calculate angles for local_position Default: True. False returns local_position angles (.theta, .phi,
        .psi) = 0. Output
    local_position : 
    """
def coords_body_to_rel_exit(body_position: FloorPositionStruct, ele: EleStruct, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None, calculate_angles: bool | None = None, rel_exit: FloorPositionStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    body_position : FloorPositionStruct
        Element body frame coordinates. .r                  [x, y, s] position with s = Position from entrance end
        of element .
    ele : EleStruct
        element that rel_exit coordinates are relative to.
    w_mat : float, optional
        W matrix at to transform vectors. v_rel_exit = w_mat . v_body v_body     = transpose(w_mat) . v_rel_exit
    calculate_angles : bool, optional
        calculate angles for rel_exit Default: True. False returns rel_exit angles (.theta, .phi, .psi) = 0.
        Output
    rel_exit : 
    """
def coords_curvilinear_to_floor(xys: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], branch: BranchStruct, global: FloorPositionStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    xys : float
        (x, y, s) lab frame position vector.
    branch : BranchStruct
        Lattice branch that defines the local reference coordinates.
    err_flag : bool
        Set True if global floor position cannot be computed.
    global : 
    """
def coords_floor_to_curvilinear(floor_coords: FloorPositionStruct, ele0: EleStruct, local_coords: FloorPositionStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    floor_coords : FloorPositionStruct
        .r = [X, Y, Z] position in global coordinates
    ele0 : EleStruct
        Element to start the search at.
    ele1 : EleStruct
        Element that local_coords is with respect to.
    status : bool
        ok$             -> Local_coords found. patch_problem$  -> No solution due to a patch element. outside$
        -> Outside of lattice ends (for open lattices).
    w_mat : float
        W matrix at s, to transform vectors from floor to local. w_mat will only be well defined if status = ok$
    local_coords : 
    """
def coords_floor_to_local_curvilinear(global_position: FloorPositionStruct, ele: EleStruct, relative_to: typing.SupportsInt | None = None, local_position: FloorPositionStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    global_position : FloorPositionStruct
        .r = [X, Y, Z] position in global coordinates
    ele : EleStruct
        element to find local coordinates of.
    status : bool
        longitudinal position: inside$: Inside the element. upstream_end$: At upstream end of element or beyound.
        downstream_end$: At downstream end of element or beyound.
    w_mat : float
        W matrix at s, to transform vectors. v_global = w_mat.v_local v_local = transpose(w_mat).v_global
    relative_to : int, optional
        not_set$ (default), upstream_end$, or downstream_end$. Force which end is used for z = 0. If
        upstream_end$, local_position.r(3) is relative to the upstream end which will not be the entrance end if
        ele.orientation = -1.
    local_position : 
    """
def coords_floor_to_relative(floor0: FloorPositionStruct, global_position: FloorPositionStruct, calculate_angles: bool | None = None, is_delta_position: bool | None = None, local_position: FloorPositionStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    floor0 : FloorPositionStruct
        reference position
    global_position : FloorPositionStruct
        global position
    calculate_angles : bool, optional
        calculate angles for local_position Default: True. False returns local_position angles (.theta, .phi,
        .psi) = 0.
    is_delta_position : bool, optional
        If True then treat global_position.r as a difference position in global space and only rotate the position
        but not shift it. Default: False.
    local_position : 
    """
def coords_local_curvilinear_to_body(local_position: FloorPositionStruct, ele: EleStruct, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None, calculate_angles: bool | None = None, body_position: FloorPositionStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    local_position : FloorPositionStruct
        local coordinates. .r(3)               [x, y, s] position with s = Position from entrance end of element.
    ele : EleStruct
        element that coordinates are relative to.
    w_mat : float, optional
        W matrix at to transform vectors. v_local  = w_mat . v_body v_body   = transpose(w_mat) . v_local
    calculate_angles : bool, optional
        calculate angles for body_position Default: True. False returns body_position angles (.theta, .phi, .psi)
        = 0. Output
    body_position : 
    """
def coords_local_curvilinear_to_floor(local_position: FloorPositionStruct, ele: EleStruct, in_body_frame: bool | None = None, calculate_angles: bool | None = None, relative_to: typing.SupportsInt | None = None, global_position: FloorPositionStruct) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
    """
    No docstring available
    
    Parameters
    ----------
    local_position : FloorPositionStruct
        Floor position in local curvilinear coordinates, with .r = [x, y, z_local] where z_local is wrt the
        entrance end of the element except if relative_to = downstream_end$. In this case, z_local is a distance
        -ele.value(l$) from the exit end (important for patch elements).
    ele : EleStruct
        element that local_position coordinates are relative to.
    in_body_frame : bool, optional
        True => local_position is in ele body frame and includes misalignments. Ignored if element is a patch.
        Default: False.
    w_mat : float
        W matrix at z, to transform vectors. v_global     = w_mat . v_local/body v_local/body = transpose(w_mat) .
        v_global
    calculate_angles : bool, optional
        calculate angles for global_position Default: True. False returns local_position angles (.theta, .phi,
        .psi) = 0.
    relative_to : int, optional
        not_set$ (default), upstream_end$, or downstream_end$. Force which end is used for z = 0. If
        upstream_end$, local_position.r(3) is relative to the upstream end which will not be the entrance end if
        ele.orientation = -1.
    global_position : 
    """
def coords_relative_to_floor(floor0: FloorPositionStruct, dr: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], theta: typing.SupportsFloat | None = None, phi: typing.SupportsFloat | None = None, psi: typing.SupportsFloat | None = None, floor1: FloorPositionStruct) -> PyCoordsRelativeToFloor:
    """
    No docstring available
    
    Parameters
    ----------
    floor0 : FloorPositionStruct
        Initial reference frame.
    dr : float
        (x, y, z) positional shift of the reference frame. theta, phi, psi -- real(rp), optional: Angular shift of
        the reference frame. See the Bmad manual on the Global Coordinate system for more details. All angles must
        either be absent or present.
    theta : 
    phi : 
    psi : 
    floor1 : 
    """
def cos_one(angle: typing.SupportsFloat, cos1: typing.SupportsFloat) -> PyCosOne:
    """
    No docstring available
    
    Parameters
    ----------
    angle : 
    cos1 : 
    """
def cosc(x: typing.SupportsFloat, nd: typing.SupportsInt | None = None, y: typing.SupportsFloat) -> PyCosc:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    nd : 
    y : 
    """
def coulombfun(u: typing.SupportsFloat, v: typing.SupportsFloat, w: typing.SupportsFloat, gam: typing.SupportsFloat, res: typing.SupportsFloat) -> PyCoulombfun:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    v : 
    w : 
    gam : 
    res : 
    """
def count_lines_in_file(file_name: str) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    lines : 
    """
def create_a_spline(r0: RealAlloc1D, r1: RealAlloc1D, slope0: typing.SupportsFloat, slope1: typing.SupportsFloat) -> SplineStruct:
    """
    Routine to create a single spline given end point positions and slopes.
    
    The spline will pass through the data points and have the given slopes
    at these points.
    Modules used:
    use spline_mod
    
    Parameters
    ----------
    r0 : float
        Start (x, y) point.
    r1 : float
        End (x, y) point.
    slope0 : float
        Starting slope.
    slope1 : float
        End slope.
    
    Returns
    -------
    spline : SplineStruct
        Spline.
    """
def create_concatenated_wall3d(lat: LatStruct, err: bool) -> PyCreateConcatenatedWall3d:
    """
    Routine to concatinate lat%branch(i)ele(:)%wall3d%section(:) arrays into
    
    one lat%branch(i)%wall3d%section(:) array.
    Exceptions: capillary and aperture elements do not have their walls included.
    Module needed:
    use wall3d_mod
    
    Parameters
    ----------
    lat : LatStruct
        lattice
        This parameter is an input/output and is modified in-place. As an output: Lattice
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error, false otherwise.
    """
def create_element_slice(ele_in: EleStruct, l_slice: typing.SupportsFloat, offset: typing.SupportsFloat, param: LatParamStruct, include_upstream_end: bool, include_downstream_end: bool, old_slice: _pybmad.EleStruct | None = None, orb_in: _pybmad.CoordStruct | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    sliced_ele : EleStruct
        Sliced_ele element with appropriate values set.
    ele_in : EleStruct
        Original element to slice
    l_slice : float
        Length of the slice
    offset : float
        Offset of entrance end of sliced_ele from entrance end of ele_in.
    param : LatParamStruct
        lattice paramters.
    include_upstream_end : bool
        Sliced_ele contains the ele's entrance end?
    include_downstream_end : bool
        Sliced_ele contains the ele's exit end?
    err_flag : bool
        Set True if there is an error. False otherwise.
    old_slice : EleStruct, optional
        Previous slice or, if offset = 0, the previous element. If present this saves computation time of the
        reference energy and time at the start of the present slice. Also makes the ref energy continuous (there
        can be some small differences when using, say, runge_kutta tracking due to tracking tolerances).
    orb_in : CoordStruct, optional
        Incoming orbit if calling routine is doing tracking through the slice. This is used when old_slice is not
        present and there may be an adjustment needed to the orbit ref energy (EG space charge tracking does not
        keep track of ref energy through an lcavity).
    """
def create_field_overlap(lat: LatStruct, lord_name: str, slave_name: str) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
    lord_name : unknown
        Name of the element with a field extending beyound it's bounds.
    slave_name : unknown
        Name of the element the lord's field overlaps.
    err_flag : bool
        Set true if there is a problem (like no elements found).
    """
def create_girder(lat: LatStruct, ix_girder: typing.SupportsInt, contrl: ControlStructAlloc1D, girder_info: EleStruct, err_flag: bool) -> PyCreateGirder:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to modify.
        This parameter is an input/output and is modified in-place. As an output: Modified lattice.
    ix_girder : int
        Index of girder element.
    contrl : ControlStruct
        Array of elements that are supported by the girder. slave.ix_ele       -- Integer: Index in
        lat.branch().ele() of element controlled. .ix_branch      -- Integer: Branch index.
    girder_info : EleStruct
        Element containing attributes to be transfered to the Girder element: girder_info.name girder_info.alias
        girder_info.descrip girder_info.value(:)
    err_flag : 
    """
def create_group(lord: EleStruct, contrl: ControlStructAlloc1D, err: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lord : EleStruct
        Group element. .control.type
        This parameter is an input/output and is modified in-place. As an output: Modified group elment
    contrl : ControlStruct
        control info. 1 element for each slave. .stack         -- Arithmetic expression stack for evaluating the
        controlled parameter value. .y_knot(:)     -- Knot points for spline interpolation. .slave         --
        Integer: Index to lat.branch().ele() of element controlled. .attribute     -- character(40): Attribute
        name.
    err : bool
        Set True if an attribute is not free to be controlled.
    """
def create_lat_ele_nametable(lat: LatStruct, nametable: NametableStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice. Ouput:
    nametable : NametableStruct
        Nametable of the elment names
    """
def create_overlay(lord: EleStruct, contrl: ControlStructAlloc1D, err: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lord : EleStruct
        Overlay element. .control.type
        This parameter is an input/output and is modified in-place. As an output: Modified overlay elment
    contrl : ControlStruct
        control info. 1 element for each slave. .stack(:)      -- Arithmetic expression stack for evaluating the
        controlled parameter value. .y_knot(:)     -- Knot points for spline interpolation. slave.ix_ele   --
        Index of element to control .ix_branch     -- Index of branch element belongs to. .attribute     -- name
        of attribute to be controlled
    err : bool
        Set True if an attribute is not free to be controlled.
    """
def create_planar_wiggler_model(wiggler_in: EleStruct, print_err: bool | None = None) -> ...:
    """
    Routine to create series of bend and drift elements to serve as a replacement
    
    model for a planar wiggler.
    This routine is helpful for translating bmad lattices to a language that does not
    implement the Bmad wiggler model.
    This routine uses the mrqmin nonlinear optimizer to vary the parameters in the wiggler
    model to match:
    Integral g^2 (I_2 radiation integral)
    Integral g^3 (I_3 radiation integral)
    Transfer matrix.
    Also the endding horizontal transverse offset of the reference orbit (floor%r(1)) is
    matched to zero.
    
    Parameters
    ----------
    wiggler : EleStruct
        Planar model wiggler to match to.
    wig_model_com : WigglerModelingCommonStruct
        Global variable that can be used to set weights and step sizes for the optimization.
    print_err : bool, optional
        If True (default) print an error message if there is an error.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    lat : LatStruct
        Lattice containing the wiggler model .ele(:)      -- Array of bends and drifts. .n_ele_track -- Number of
        elements in the model.
    err_flag : bool
        Set True if there is an error.
    """
def create_ramper(lord: EleStruct, contrl: ControlStructAlloc1D, err: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lord : EleStruct
        Ramper element. .control.type
        This parameter is an input/output and is modified in-place. As an output: Modified ramper elment
    contrl : ControlStruct
        control info. 1 element for each slave. .stack(:)         -- Arithmetic expression stack for evaluating
        the controlled parameter value. .y_knot(:)        -- Knot points for spline or linear interpolation.
        .attribute        -- name of attribute to be controlled.
    err : bool
        Set True if an attribute is not free to be controlled.
    """
def create_sol_quad_model(sol_quad: EleStruct, lat: LatStruct) -> None:
    """
    Routine to create series of solenoid and quadrupole elements to serve as a replacement
    
    model for a sol_quad element.
    This routine is helpful for translating bmad lattices to a language that does not
    implement a combination solenoid/quadrupole.
    Not yet implemented!
    """
def create_unique_ele_names(lat: LatStruct, key: typing.SupportsInt, suffix: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice holding the elements.
        This parameter is an input/output and is modified in-place. As an output: Lattice with names made unique.
    key : int
        Class key of elements to consider.
    suffix : unknown
        Suffix string. Must have a single "?" character.
    """
def create_wiggler_cartesian_map(ele: EleStruct) -> CartesianMapStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Wiggler or undulator element.
    cart_map : CartesianMapStruct
        Cartesian map.
    """
def cross_product(a: RealAlloc1D, b: RealAlloc1D, c: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    a : float
        Input vectors.
    b : 
    c : 
    """
def crystal_attribute_bookkeeper(ele: EleStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Crystal element. .value(bragg_angle_in$) .value(bragg_angle_out$) .value(tilt_corr$) ... etc.
    """
def crystal_h_misalign(ele: EleStruct, orbit: CoordStruct, h_vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
    """
    Routine reorient the crystal H vector due to local imperfections in the crystal lattice.
    
    Parameters
    ----------
    ele : EleStruct
        Crystal element
    orbit : CoordStruct
        Photon position at crystal surface.
    h_vec : float
        H vector before misalignment.
        This parameter is an input/output and is modified in-place. As an output: H vector after misalignment.
    """
def crystal_type_to_crystal_params(ele: EleStruct) -> bool:
    """
    Routine to set the crystal parameters based upon the crystal type.
    
    Crystal types are of the form:
    "ZZZ(ijk)"
    Where "ZZZ" is the atomic formula of the crystal material and "ijk" is the reciprical lattice
    vetor specifying the diffraction plans.
    
    Parameters
    ----------
    ele : EleStruct
        Crystal element. .component_name -- Character: Crystal type name. Assumed upper case. A blank name is not
        an error and results in nothing set. .value(e_tot$)  -- Photon energy in eV.
        This parameter is an input/output and is modified in-place. As an output: Crystal element with computed
        parameter..
    
    Returns
    -------
    err_flag : bool
        Set True if crystal type is unrecognized. False otherwise.
    """
def custom_attribute_ubound_index(ele_class: typing.SupportsInt) -> int:
    """
    Routine to return, for a given element class, the upper bound index for the ele%custom(:)
    
    array which is needed to accomodate the registered custom attributes for that class.
    
    Parameters
    ----------
    ele_class : int
        Element class (key). EG: quadrupole$, etc.
    
    Returns
    -------
    ix_ubound : int
        Maximum index needed.
    """
def damping_matrix_d(gamma: typing.SupportsFloat, g_tot: typing.SupportsFloat, B0: typing.SupportsFloat, B1: typing.SupportsFloat, delta: typing.SupportsFloat, species: typing.SupportsInt, mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> PyDampingMatrixD:
    """
    No docstring available
    
    Parameters
    ----------
    gamma : 
    g_tot : 
    B0 : 
    B1 : 
    delta : 
    species : 
    mat : 
    """
def date_and_time_stamp(string: str, numeric_month: bool | None = None, include_zone: bool | None = None) -> PyDateAndTimeStamp:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    numeric_month : 
    include_zone : 
    """
def deallocate_ele_pointers(ele: EleStruct, nullify_only: bool | None = None, nullify_branch: bool | None = None, dealloc_poles: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with pointers.
        This parameter is an input/output and is modified in-place. As an output: Element with deallocated
        pointers.
    nullify_only : bool, optional
        If present and True: Nullify & do not deallocate.
    nullify_branch : bool, optional
        Nullify ele.branch? Default is True.
    dealloc_poles : bool, optional
        Dealloc ele.a/b_pole, ele.a/b_pole_elec? Default is True.
    """
def deallocate_expression_tree(tree: ExpressionTreeStruct) -> None:
    """
    Routine to deallocate an expression tree.
    
    Parameters
    ----------
    tree : ExpressionTreeStruct
        Tree to deallocate.
        This parameter is an input/output and is modified in-place. As an output: Deallocated tree.
    """
def deallocate_lat_pointers(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat with pointers.
        This parameter is an input/output and is modified in-place. As an output: Lat with deallocated pointers.
    """
def default_tracking_species(param: LatParamStruct, species: typing.SupportsInt) -> PyDefaultTrackingSpecies:
    """
    No docstring available
    
    Parameters
    ----------
    param : LatParamStruct
        Parameters for a lattice branch.
    species : 
    """
def destfixedwindowls(id: typing.SupportsInt) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    id : 
    """
def detab(str: str) -> PyDetab:
    """
    No docstring available
    
    Parameters
    ----------
    str : 
    """
def detector_pixel_pt(orbit: CoordStruct, ele: EleStruct) -> typing.Annotated[list[int], "FixedSize(2)"]:
    """
    Routine to return the pixel a particle is hitting.
    
    Parameters
    ----------
    orbit : CoordStruct
        Orbit at surface.
    ele : EleStruct
        Detector element.
    
    Returns
    -------
    ix_pix : int
        index of ele.photon.pixel.pt(:,:) the particle is in.
    """
def diffraction_plate_or_mask_hit_spot(ele: EleStruct, orbit: CoordStruct, ix_section: typing.SupportsInt) -> PyDiffractionPlateOrMaskHitSpot:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        diffraction_plate or mask element.
    orbit : CoordStruct
        particle position.
    ix_section : 
    """
def diffusion_matrix_b(gamma: typing.SupportsFloat, g_tot: typing.SupportsFloat, species: typing.SupportsInt, mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> PyDiffusionMatrixB:
    """
    No docstring available
    
    Parameters
    ----------
    gamma : 
    g_tot : 
    species : 
    mat : 
    """
def display_size_and_resolution(ix_screen: typing.SupportsInt, x_size: typing.SupportsFloat, y_size: typing.SupportsFloat, x_res: typing.SupportsFloat, y_res: typing.SupportsFloat) -> PyDisplaySizeAndResolution:
    """
    No docstring available
    
    Parameters
    ----------
    ix_screen : 
    x_size : 
    y_size : 
    x_res : 
    y_res : 
    """
def distance_to_aperture(orbit: CoordStruct, particle_at: typing.SupportsInt, ele: EleStruct, dist: typing.SupportsFloat) -> PyDistanceToAperture:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle position.
    particle_at : int
        first_track_edge$, second_track_edge$, or in_between$
    ele : EleStruct
        Element containing aperture.
    no_aperture_here : bool
        True if aperture does not exist at the longitudinal location of the particle.
    dist : 
    """
def dj_bessel(m: typing.SupportsInt, arg: typing.SupportsFloat, dj_bes: typing.SupportsFloat) -> PyDjBessel:
    """
    No docstring available
    
    Parameters
    ----------
    m : 
    arg : 
    dj_bes : 
    """
def djb_hash(str: str, old_hash: typing.SupportsInt | None = None, hash: typing.SupportsInt) -> PyDjbHash:
    """
    No docstring available
    
    Parameters
    ----------
    str : 
    old_hash : 
    hash : 
    """
def djb_str_hash(in_str: str, hash_str: str) -> PyDjbStrHash:
    """
    No docstring available
    
    Parameters
    ----------
    in_str : 
    hash_str : 
    """
def do_mode_flip(ele: EleStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Starting Element
        This parameter is an input/output and is modified in-place. As an output: Flipped element
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def downcase_string(string: str) -> PyDowncaseString:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    """
def dpc_given_de(pc_old: typing.SupportsFloat, mass: typing.SupportsFloat, dE: typing.SupportsFloat, dpc: typing.SupportsFloat) -> PyDpcGivenDe:
    """
    No docstring available
    
    Parameters
    ----------
    pc_old : 
    mass : 
    dE : 
    dpc : 
    """
def drift_and_pipe_track_methods_adjustment(lat: LatStruct) -> None:
    """
    Drift and pipe elements can be used in both photon and non-photon lines.
    
    A problem occures if, for example, a lattice file with both photon and
    non-photon lines contains a line like:
    drift::*[tracking_method] = taylor
    So this routine resets drift and pipe tracking_method and mat6_calc_method
    parameters in photon lines to bmad_standard if needed.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
        This parameter is an input/output and is modified in-place. As an output: Lattice with tracking methods
        adjusted if needed.
    """
def drift_multipass_name_correction(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    """
def drift_orbit_time(orbit: CoordStruct, beta0: typing.SupportsFloat, delta_s: typing.SupportsFloat | None = None, delta_t: typing.SupportsFloat | None = None) -> None:
    """
    Simple routine to drift a particle orbit in time-based coordinates by a distance delta_s
    
    or a time delta_t
    If the particle has zero longitudinal velocity, then the particle is not drifted
    and a warning is printed.
    
    Parameters
    ----------
    orbit : CoordStruct
        particle orbit in time-based coordinates.
    beta0 : float
        reference velocity v/c.
    delta_s : float, optional
        s-coordinate distance to drift particle.
    delta_t : float, optional
        -coordinate distancet to drift particle.
    """
def drift_particle_to_s(p: CoordStruct, s: typing.SupportsFloat, branch: BranchStruct) -> None:
    """
    Drift a particle to a given s-coordinate
    
    Parameters
    ----------
    p : CoordStruct
        Init particle position.
        This parameter is an input/output and is modified in-place. As an output: Final particle position.
    s : float
        Target s coordinate.
    branch : BranchStruct
        Branch being tracked through.
    """
def drift_particle_to_t(p: CoordStruct, t: typing.SupportsFloat, branch: BranchStruct) -> None:
    """
    Drift a particle to a given t-coordinate
    
    Parameters
    ----------
    p : CoordStruct
        Init particle position.
        This parameter is an input/output and is modified in-place. As an output: Final particle position.
    t : float
        Target t coordinate.
    branch : BranchStruct
        Lattice branch being tracked through.
    """
def dspline_len(s_chord0: typing.SupportsFloat, s_chord1: typing.SupportsFloat, spline: SplineStruct, dtheta_ref: typing.SupportsFloat | None = None) -> float:
    """
    Routine to calculate the difference in length between the spline curve length and a referece line.
    
    Referece line is centroid chord (referece system of the spline) rotated by dtheta_ref.
    
    Parameters
    ----------
    s_chord0 : float
        Start position along centroid chord.
    s_chord1 : float
        Stop position along central_chord.
    spline : SplineStruct
        Spline of x-position as a function of s.
    dtheta_ref : float, optional
        angle to rotate the reference line from the centroid chord. Default is 0.
    
    Returns
    -------
    dlen : float
        L_spline - L_chord
    """
def dynamic_aperture_point(branch: BranchStruct, ele0: EleStruct, orb0: CoordStruct, theta_xy: typing.SupportsFloat, ap_param: ApertureParamStruct, check_xy_init: bool | None = None) -> AperturePointStruct:
    """
    Subroutine to determine one dynamic aperture point by tracking.
    
    This routine works by determining where on a radial line y = const * x the aperture is.
    Here x and y are deviations from the reference orbit.
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch to track through.
    ele0 : EleStruct
        Lattice element at start of tracking
    orb0 : CoordStruct
        reference orbit at the start of tracking.
    theta_xy : float
        Angle of radial line (in radians) in x-y space. Angle is "normalized" by .x_init, .y_init.
    ap_param : ApertureParamStruct
        Structure holding the input data:
    check_xy_init : bool, optional
        If True, do not check that aperture_param.x_init and .y_init are non-zero. Default is True.
    
    Returns
    -------
    ap_point : AperturePointStruct
    """
def dynamic_aperture_scan(aperture_param: ApertureParamStruct, pz_start: RealAlloc1D, lat: LatStruct, print_timing: bool | None = None) -> ApertureScanStructAlloc1D:
    """
    Routine to do a set of dynamic aperture scans.
    
    Parameters
    ----------
    aperture_param : ApertureParamStruct
        Scan parameters
    lat : LatStruct
        Lattice.
    pz_start : float
        Starting phase space pz values.
    print_timing : bool, optional
        If True print info on calculation time. Default is True.
    
    Returns
    -------
    aperture_scan : ApertureScanStruct
        Set of scans. One for each pz_start(:).
    """
def e_accel_field(ele: EleStruct, voltage_or_gradient: typing.SupportsInt, bmad_standard_tracking: bool | None = None, field: typing.SupportsFloat) -> PyEAccelField:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lcavity or rfcavity element.
    voltage_or_gradient : int
        voltage$ or gradient$
    bmad_standard_tracking : bool, optional
        Using bmad_standard tracking? Default is False.
    field : 
    """
def e_crit_photon(gamma: typing.SupportsFloat, g_bend: typing.SupportsFloat) -> float:
    """
    Routine to calculate the photon critical energy in a bend.
    
    Parameters
    ----------
    gamma : float
        Gamma factor of charged particle emitting photon.
    g_bend : float
        1/radius bending strength.
    
    Returns
    -------
    E_crit : float
        Critical photon energy.
    """
def eigen_decomp_6mat(mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    Compute eigenvalues and eigenvectors of a real 6x6 matrix.
    
    The evals and evecs are in general complex.
    
    Parameters
    ----------
    mat : float
        6x6 real matrix.  Usually a transfer matrix or sigma matrix.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    eval : complex
        complex eigenvalues.
    evec : complex
        complex eigenvectors arranged down columns.
    err_flag : bool
        set to true if an error has occured.
    tunes : float
        Mode tunes, in radians.
    """
def ele_compute_ref_energy_and_time(ele0: EleStruct, ele: EleStruct, param: LatParamStruct, err_flag: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele0 : EleStruct
        Previous element in lattice with starting energy and time values.
    ele : EleStruct
        Lattice element .time_ref_orb_in  -- Starting orbit for ref time calc.
        This parameter is an input/output and is modified in-place. As an output: Lattice element with reference
        energy and time.
    param : LatParamStruct
        Lattice parameters.
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def ele_equal_ele(ele_in: EleStruct) -> EleStruct:
    """
    Subroutine that is used to set one element equal to another.
    
    This routine takes care of the pointers in ele_out.
    
    Parameters
    ----------
    ele_in : EleStruct
        Input element.
    
    Returns
    -------
    ele_out : EleStruct
        Output element.
    """
def ele_equals_ele(ele_in: EleStruct, update_nametable: bool) -> EleStruct:
    """
    Subroutine that is used to set an element equal to another.
    
    Parameters
    ----------
    ele_in : EleStruct
        Input element.
    update_nametable : bool
        If true, update the nametable. If false, do not. Note: nametable updates can take time if this routine is
        called a many times. See remove_eles_from_lat as an example.
    
    Returns
    -------
    ele_out : EleStruct
        Output element.
    """
def ele_finalizer(ele: EleStruct) -> None:
    """
    Finalizer routine for ele_struct instances.
    
    Parameters
    ----------
    ele : EleStruct
        Element to cleanup.
        This parameter is an input/output and is modified in-place. As an output: Element with pointers
        deallocated as needed.
    """
def ele_full_name(ele: EleStruct, template_: str | None = None, str: str) -> PyEleFullName:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element in a lattice
    template : unknown, optional
        Encoding template. Default is "@N (&#)".
    str : 
    """
def ele_geometry(floor_start: FloorPositionStruct, ele: EleStruct, len_scale: typing.SupportsFloat | None = None, ignore_patch_err: bool | None = None) -> FloorPositionStruct:
    """
    No docstring available
    
    Parameters
    ----------
    floor_start : 
        Starting floor coordinates at upstream end. Not used for fiducial and girder elements.
    ele : EleStruct
        Element to propagate the geometry through.
    floor_end : FloorPositionStruct
        Output floor position. If not present then ele.floor will be used and ele.bookkeeping_state.floor_position
        will be set to ok$. .r(3)              -- X, Y, Z Floor position at end of element .w(3,3)            -- W
        matrix corresponding to orientation angles .theta, phi, .psi  -- Orientation angles
    len_scale : float, optional
        factor to scale the length of the element. 1.0_rp => Output is geometry at end of element (default).
        0.5_rp => Output is geometry at center of element. -1.0_rp => Used to propagate geometry in reverse.
    ignore_patch_err : bool, optional
        If present and True, ignore flexible patch errors. This is used by ele_compute_ref_energy_and_time to
        suppress unnecessary messages.
    """
def ele_geometry_with_misalignments(ele: EleStruct, len_scale: typing.SupportsFloat | None = None, floor: FloorPositionStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element under consideration.
    len_scale : float, optional
        factor to scale the length of the element. 1.0_rp => Output is geometry at end of element (default).
        0.5_rp => Output is geometry at center of element. -1.0_rp => Used to propagate geometry in reverse.
    floor : 
    """
def ele_has_constant_ds_dt_ref(ele: EleStruct, is_const: bool) -> PyEleHasConstantDsDtRef:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element.
    is_const : 
    """
def ele_has_nonzero_kick(has_kick: bool) -> PyEleHasNonzeroKick:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with no kicks.
    has_kick : 
    """
def ele_has_nonzero_offset(ele: EleStruct, has_offset: bool) -> PyEleHasNonzeroOffset:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    has_offset : 
    """
def ele_is_monitor(ele: EleStruct, print_warning: bool | None = None) -> bool:
    """
    Routine to check that an element is either a detector, instrument, monitor, or marker.
    
    These are the elements where measurement errors can be defined.
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    print_warning : bool, optional
        If True print a warning message if the element not a monitor like element. Default is True.
    
    Returns
    -------
    is_monitor : bool
        Set True if the element is a monitor like element.
    """
def ele_loc(ele: EleStruct, loc: LatEleLocStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to be identified
    loc : 
    """
def ele_loc_name(ele: EleStruct, show_branch0: bool | None = None, parens: str | None = None, str: str) -> PyEleLocName:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element in a lattice
    show_branch0 : bool, optional
        Explicitly show branch for main lattice elements? Default is False.
    parens : unknown, optional
        If present, enclose location string using the two characters supplied. Typically parens will be set to
        "()" or "[]".
    str : 
    """
def ele_misalignment_l_s_calc(ele: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : float
        Element
    L_mis : float
        Misalignment vector relative to center of element
    S_mis : float
        Misalignment matrix relative to center of element
    """
def ele_nametable_index(ele: EleStruct, ix_nt: typing.SupportsInt) -> PyEleNametableIndex:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element in a lattice.
    ix_nt : 
    """
def ele_order_calc(lat: LatStruct) -> LatEleOrderStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to analyze.
    order : LatEleOrderStruct
        Structure holding the element order information.
    """
def ele_reference_energy_correction(ele: EleStruct, orbit: CoordStruct, particle_at: typing.SupportsInt, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    import
    
    implicit none
    type (ele_struct) ele
    end subroutine
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through.
    orbit : CoordStruct
        Coordinates to correct.
    particle_at : int
        first_track_edge$ (that is, entering the element), or second_track_edge$ (that is, leaving the element),
        or upstream_end$ (inherit ele.value(p0c_start$) ref), or downstream_end$ (inherit ele.value(p0c$)).
        inside$ (or anything else) -> Do nothing.
    mat6 : float, optional
        Transfer matrix before correction.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        including correction.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def ele_rf_step_index(E_ref: typing.SupportsFloat, s_rel: typing.SupportsFloat, ele: EleStruct, ix_step: typing.SupportsInt) -> PyEleRfStepIndex:
    """
    No docstring available
    
    Parameters
    ----------
    E_ref : float
        Reference energy of step. If negative, ignore and use s_rel.
    s_rel : float
        S-position relative to the beginning of the element
    ele : float
        RF cavity.
    ix_step : 
    """
def ele_to_ptc_magnetic_bn_an(ele: EleStruct) -> ...:
    """
    Routine to compute the a(n) and b(n) magnetic multipole components of a magnet.
    
    This is used to interface between eles and PTC fibres
    
    Parameters
    ----------
    ele : EleStruct
        Bmad Element.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    bn : float
        Normal multipole component.
    an : float
        Skew multipole component.
    n_max : int
        Maximum non-zero multipole component. Set to zero if there are no multipoles.
    """
def ele_to_spin_taylor(ele: EleStruct, param: LatParamStruct, orb0: CoordStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
        This parameter is an input/output and is modified in-place. As an output: Element with spin map.
    param : unknown
        Branch parameters.
    orb0 : CoordStruct
        Starting ref coords.
    """
def ele_to_taylor(ele: EleStruct, orb0: _pybmad.CoordStruct | None = None, taylor_map_includes_offsets: bool | None = None, include_damping: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : ElementStruct
        Element to construct map for.
    orb0 : CoordStruct, optional
        Starting coords around which the Taylor map is evaluated. Default is the zero orbit.
    taylor_map_includes_offsets : bool, optional
        If present then value overrides ele.taylor_map_includes_offsets. -- Logical, optional: If present then
        value overrides ele.taylor_map_includes_offsets.
    include_damping : bool, optional
        Sets if radiation damping is included. Default is what is set in ptc_private.base_state.
    orbital_taylor : TaylorStruct
        Orbital taylor map. If not present then the map is put in ele.taylor.
    spin_taylor : TaylorStruct
        Spin taylor map. If not present then the map is put in ele.spin_taylor.
    """
def ele_unique_name(ele: EleStruct, order: LatEleOrderStruct, unique_name: str) -> PyEleUniqueName:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to construct a unique name for.
    order : LatEleOrderStruct
        Information on element ordering. Before calling this routine, use the routine ele_order_calc to compute
        this argument.
    unique_name : 
    """
def ele_value_has_changed(ele: EleStruct, list: IntAlloc1D, abs_tol: RealAlloc1D, set_old: bool, has_changed: bool) -> PyEleValueHasChanged:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element under consideration.
        This parameter is an input/output and is modified in-place. As an output: ele.old_value may be set
        depending upon setting of set_old
    list : int
        List of indexes of ele.value(:) array to check.
    abs_tol : float
        List of values such that if the change in parameter value is less than this it is not considered to have
        changed significantly.
    set_old : bool
        If True then set ele.old_value(j) = ele.value(j) for j in list
    has_changed : 
    """
def ele_vec_equal_ele_vec(ele2: EleStructAlloc1D) -> EleStructAlloc1D:
    """
    Subroutine that is used to set one ele vector equal to another.
    
    This routine takes care of the pointers in ele1.
    ele1(:) = ele2(:)
    
    Parameters
    ----------
    ele2 : EleStruct
        Input ele vector.
    
    Returns
    -------
    ele1 : EleStruct
        Output ele vector.
    
    Notes
    -----
    Note: This subroutine is called by the overloaded equal sign:
    """
def elec_multipole_field(a: typing.SupportsFloat, b: typing.SupportsFloat, n: typing.SupportsInt, coord: CoordStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    a : float
        Multipole skew component.
    b : float
        Multipole normal component.
    n : float
        Multipole order.
    coord : CoordStruct
    Ex : float
        X field component
    Ey : float
        Y field component.
    dE : float
        Field derivatives: dfield(x,y)/d(x,y).
    compute_dE : bool
        If False, do not compute the field derivatives even if dE is present. Default is True.
    """
@typing.overload
def element_at_s(branch: BranchStruct, s: typing.SupportsFloat, choose_max: bool, err_flag: bool | None = None, s_eff: typing.SupportsFloat | None = None, position: _pybmad.CoordStruct | None = None, print_err: bool | None = None, ix_ele: typing.SupportsInt) -> PyElementAtSBranch:
    """
    Overloaded routine. See element_at_s for more details.
    
    
    Returns
    -------
    ix_ele
    """
@typing.overload
def element_at_s(lat: LatStruct, s: typing.SupportsFloat, choose_max: bool, ix_branch: typing.SupportsInt | None = None, err_flag: bool | None = None, s_eff: typing.SupportsFloat | None = None, position: _pybmad.CoordStruct | None = None, print_err: bool | None = None, ix_ele: typing.SupportsInt) -> PyElementAtSLat:
    """
    Overloaded routine. See element_at_s for more details.
    
    
    Returns
    -------
    ix_ele
    """
def element_slice_iterator(ele: EleStruct, param: LatParamStruct, i_slice: typing.SupportsInt, n_slice_tot: typing.SupportsInt, sliced_ele: EleStruct, s_start: typing.SupportsFloat | None = None, s_end: typing.SupportsFloat | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to slice and dice.
    param : LatParamStruct
        Lattice parameters
    i_slice : int
        Slice index
    n_slice_tot : int
        Total number of slices.
    sliced_ele : 
    s_start : float, optional
        Starting edge of slice relative to beginning of element.
    s_end : float, optional
        Ending edge of slice relative to beginning of element.
    """
def ellipinc_test() -> None:
    """
    No docstring available
    """
def em_field_calc(ele: EleStruct, param: LatParamStruct, s_pos: typing.SupportsFloat, orbit: CoordStruct, local_ref_frame: bool, calc_dfield: bool | None = None, calc_potential: bool | None = None, use_overlap: bool | None = None, grid_allow_s_out_of_bounds: bool | None = None, rf_time: typing.SupportsFloat | None = None, used_eles: _pybmad.ElePointerStructAlloc1D | None = None, print_err: bool | None = None, original_ele: _pybmad.EleStruct | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    param : LatParamStruct
        Lattice parameters.
    s_pos : float
        Longitudinal position. If local_ref_frame = T: In Body coords relative to the entrance edge of the
        element. If local_ref_frame = F: In Lab coords relative to the upstream edge of the element.
    orbit : CoordStruct
        Transverse coordinates. .vec(1), .vec(3)    -- Transverse coords. .t                  -- Used with
        absolute time tracking. .vec(5)             -- Used with relative time tracking (except with time Runge-
        Kutta).
    local_ref_frame : 
        Logical, If True then take the input coordinates and output fields as being with respect to the frame of
        referene of the element (ignore misalignments).
    field : EmFieldStruct
        E and B fields and derivatives.
    calc_dfield : bool, optional
        If present and True then calculate the field derivatives.
    err_flag : bool
        Set True if there is an error. False otherwise.
    calc_potential : bool, optional
        Calc electric and magnetic potentials? Default is false. This is experimental and only implemented for
        wigglers at present.
    use_overlap : bool, optional
        Add in overlap fields from other elements? Default is True.
    grid_allow_s_out_of_bounds : bool, optional
        For grids, allow s-coordinate to be grossly out of bounds -- logical, optional: For grids, allow
        s-coordinate to be grossly out of bounds and return zero instead of an error? Default: False. Used
        internally for overlapping fields.
    rf_time : float, optional
        Set the time relative to the RF clock. Normally this time is calculated using orbit.t or orbit.vec(5) but
        sometimes it is convenient to be able to override this. For example, time_runge_kutta uses this.
    used_eles : ElePointerStruct, optional
        For internal use only when this routine is called recursively. Used to prevent double counting when there
        is field overlap.
    print_err : bool, optional
        Print an error message? Default is True. For example, if the particle is out of bounds when the field is
        defined on a grid.
    original_ele : EleStruct, optional
        Used with recursive calls that pass the lord as the ele argument. In this case original_ele is the
        original ele argument.
    """
def em_field_derivatives(ele: EleStruct, param: LatParamStruct, s_pos: typing.SupportsFloat, orbit: CoordStruct, local_ref_frame: bool, grid_allow_s_out_of_bounds: bool | None = None, rf_time: typing.SupportsFloat | None = None) -> PyEmFieldDerivatives:
    """
    Routine to calculate field derivatives.
    
    In theory this should be handled by em_filed_calc. In practice, em_field_calc is currently incomplete.
    Input
    ele             -- Ele_struct: Element
    param           -- lat_param_struct: Lattice parameters.
    s_pos           -- Real(rp): Longitudinal position relative to the upstream edge of the element.
    time            -- Real(rp): Particle time.
    For absolute time tracking this is the absolute time.
    For relative time tracking this is relative to the reference particle entering the element.
    orbit           -- Coord_struct: Transverse coordinates.
    %vec(1), %vec(3)  -- Transverse coords. These are the only components used in the calculation.
    local_ref_frame     -- Logical, If True then take the input coordinates and output fields
    as being with respect to the frame of referene of the element (ignore misalignments).
    grid_allow_s_out_of_bounds
    -- logical, optional: For grids, allow s-coordinate to be grossly out of bounds
    and return zero instead of an error? Default: False. Used internally for overlapping fields.
    rf_time          -- real(rp), optional: RF clock time. If not present then the time will be calculated using the standard algorithm.
    
    
    Returns
    -------
    dfield : EmFieldStruct
        E and B field derivatives. dfield.E and dfield.B are not touched.
    """
def em_field_kick_vector_time(ele: EleStruct, param: LatParamStruct, rf_time: typing.SupportsFloat, orbit: CoordStruct, err_flag: bool, print_err: bool | None = None, extra_field: _pybmad.EmFieldStruct | None = None) -> typing.Annotated[list[float], "FixedSize(10)"]:
    """
    Subroutine to convert particle coordinates from t-based to s-based system.
    
    Parameters
    ----------
    ele : CoordStruct
        input particle
    param : float
        Reference momentum. The sign indicates direction of p_s.
    rf_time : float
        RF time.
    orbit : CoordStruct
        in t-based system
    err_flag : bool
        Set True if there is an error. False otherwise.
    print_err : bool, optional
        Passed to em_field_calc
    extra_field : EmFieldStruct, optional
        Static field to be added to the element field. Eg used with space charge.
    
    Returns
    -------
    dvec_dt : float
        Derivatives.
    """
def em_field_plus_em_field(field1: EmFieldStruct, field2: EmFieldStruct) -> EmFieldStruct:
    """
    Routine to add fields.
    
    Parameters
    ----------
    field1 : EmFieldStruct
        Input field
    field2 : EmFieldStruct
        Input field
    
    Returns
    -------
    field_tot : EmFieldStruct
        Combined field.
    """
def em_taylor_equal_em_taylor(em_taylor2: EmTaylorStruct) -> EmTaylorStruct:
    """
    Subroutine that is used to set one em_taylor equal to another.
    
    Parameters
    ----------
    em_taylor2 : EmTaylorStruct
        Input em_taylor.
    
    Returns
    -------
    em_taylor1 : EmTaylorStruct
        Output em_taylor.
    """
def em_taylors_equal_em_taylors(em_taylor2: EmTaylorStructAlloc1D) -> EmTaylorStructAlloc1D:
    """
    Subroutine to transfer the values from one em_taylor map to another:
    
    Em_taylor1 <= Em_taylor2
    
    Parameters
    ----------
    em_taylor2 : EmTaylorStruct
        Em_taylor map.
    
    Returns
    -------
    em_taylor1 : EmTaylorStruct
        Em_taylor map.
    """
def emit_6d(ele_ref: EleStruct, include_opening_angle: bool, closed_orbit: _pybmad.CoordStructAlloc1D | None = None) -> ...:
    """
    Routine to calculate the three normal mode emittances, damping partition numbers, radiation integrals, etc.
    
    Since the emattances, etc. are only an invariant in the limit of zero damping, the calculated
    values will vary depending upon the reference element.
    If the lattice geometry is open, only the radiation integrals is computed.
    
    Parameters
    ----------
    ele_ref : EleStruct
        Origin of the 1-turn maps used to evaluate the emittances.
    include_opening_angle : bool
        If True include the effect of the vertical opening angle of emitted radiation. Generally use True unless
        comparing against other codes.
    closed_orbit : CoordStruct, optional
        Closed orbit. If not present this routine will calculate it.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    mode : NormalModesStruct
        Emittance and other info.
    sigma_mat : float
        Sigma matrix.
    rad_int_by_ele : RadIntAllEleStruct
        Radiation integrals element-by-element.
    """
def end_akima_spline_calc(spline: SplineStructAlloc1D, which_end: typing.SupportsInt) -> None:
    """
    Routine to calculate the slopes at the ends of a spline array
    
    Parameters
    ----------
    spline : SplineStruct
        Array of splines.
        This parameter is an input/output and is modified in-place. As an output: Array with slopes at end
        calculated.
    which_end : int
        0 => calculate slopes for the start end of the array. 1 => calculate slopes for the end end of the array.
    """
def entering_element(orbit: CoordStruct, particle_at: typing.SupportsInt, is_entering: bool) -> PyEnteringElement:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle orbit.
    particle_at : int
        First_track_edge$ or second_track_edge$
    is_entering : 
    """
def envelope_radints(Lambda: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], Theta: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], Iota: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], alpha: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], emit: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
    """
    Calculates damping decrement and emittance of the three
    
    normal modes from the integrate diffusion, damping, and vertical
    excitation matrices names Lambda, Theta, and Iota, respectively.
    These three matrices are obtained from the subroutine integrated_mats.
    The damping times can obtained from alpha using:
    tau = lattice_length/c_light/alpha
    """
def envelope_radints_ibs(Lambda: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], Theta: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], Iota: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], eles: EleStructAlloc1D, mode: NormalModesStruct, tail_cut: bool, npart: typing.SupportsFloat, species: typing.SupportsInt) -> ...:
    """
    Calculates damping decrement and emittance of the three
    
    normal modes by integrating the IBS, SR diffusion, and SR damping matrices.
    The IBS depends on the envelope, and so this routine iterates to
    locate the equilibrium beam envelope. This iterative process can fail to converge.
    The damping times can obtained from alpha using:
    tau = lattice_length/c_light/alpha
    alpha and emit are quantities for the three normal modes.
    alpha and emit are ordered by plane dominance.
    Only radiation from sbends and rbends is taken into account.
    The one-turn transfer matrix at each element (slice) is obtained
    by concatenating the individual element transfer matrices.
    
    Parameters
    ----------
    Lambda : float
        Integrated damping matrix.
    Theta : float
        Integrated diffusion matrix.
    Iota : float
        Integrated vertical excitation matrix.
    eles : EleStruct
        array of element structures representing ring. .mat6(6,6)            -- real(rp): element transfer matrix.
        .value(l$)            -- real(rp): element (slice) length. .value(E_TOT$)        -- real(rp): Beam energy
        in element.
    mode : unknown
        tune of a-mode. .b.tune                  -- real(rp): tune of b-mode. .z.tune                  --
        real(rp): tune of z-mode.
    tail_cut : bool
        apply tail cut.
    npart : float
        number of particles in bunch.
    species : int
        Particle species.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    alpha : float
        Normal mode damping decrements.
    emit : float
        Normal mode emittances.
    """
def eq_ac_kicker(f1: AcKickerStruct, f2: AcKickerStruct, is_eq: bool) -> PyEqAcKicker:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_ac_kicker_freq(f1: AcKickerFreqStruct, f2: AcKickerFreqStruct, is_eq: bool) -> PyEqAcKickerFreq:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_ac_kicker_time(f1: AcKickerTimeStruct, f2: AcKickerTimeStruct, is_eq: bool) -> PyEqAcKickerTime:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_anormal_mode(f1: AnormalModeStruct, f2: AnormalModeStruct, is_eq: bool) -> PyEqAnormalMode:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_aperture_param(f1: ApertureParamStruct, f2: ApertureParamStruct, is_eq: bool) -> PyEqApertureParam:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_aperture_point(f1: AperturePointStruct, f2: AperturePointStruct, is_eq: bool) -> PyEqAperturePoint:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_aperture_scan(f1: ApertureScanStruct, f2: ApertureScanStruct, is_eq: bool) -> PyEqApertureScan:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_beam(f1: BeamStruct, f2: BeamStruct, is_eq: bool) -> PyEqBeam:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_beam_init(f1: BeamInitStruct, f2: BeamInitStruct, is_eq: bool) -> PyEqBeamInit:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_bmad_common(f1: BmadCommonStruct, f2: BmadCommonStruct, is_eq: bool) -> PyEqBmadCommon:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_bookkeeping_state(f1: BookkeepingStateStruct, f2: BookkeepingStateStruct, is_eq: bool) -> PyEqBookkeepingState:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_bpm_phase_coupling(f1: BpmPhaseCouplingStruct, f2: BpmPhaseCouplingStruct, is_eq: bool) -> PyEqBpmPhaseCoupling:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_branch(f1: BranchStruct, f2: BranchStruct, is_eq: bool) -> PyEqBranch:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_bunch(f1: BunchStruct, f2: BunchStruct, is_eq: bool) -> PyEqBunch:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_bunch_params(f1: BunchParamsStruct, f2: BunchParamsStruct, is_eq: bool) -> PyEqBunchParams:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_cartesian_map(f1: CartesianMapStruct, f2: CartesianMapStruct, is_eq: bool) -> PyEqCartesianMap:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_cartesian_map_term(f1: CartesianMapTermStruct, f2: CartesianMapTermStruct, is_eq: bool) -> PyEqCartesianMapTerm:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_cartesian_map_term1(f1: CartesianMapTerm1Struct, f2: CartesianMapTerm1Struct, is_eq: bool) -> PyEqCartesianMapTerm1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_complex_taylor(f1: ComplexTaylorStruct, f2: ComplexTaylorStruct, is_eq: bool) -> PyEqComplexTaylor:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_complex_taylor_term(f1: ComplexTaylorTermStruct, f2: ComplexTaylorTermStruct, is_eq: bool) -> PyEqComplexTaylorTerm:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_control(f1: ControlStruct, f2: ControlStruct, is_eq: bool) -> PyEqControl:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_control_ramp1(f1: ControlRamp1Struct, f2: ControlRamp1Struct, is_eq: bool) -> PyEqControlRamp1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_control_var1(f1: ControlVar1Struct, f2: ControlVar1Struct, is_eq: bool) -> PyEqControlVar1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_controller(f1: ControllerStruct, f2: ControllerStruct, is_eq: bool) -> PyEqController:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_coord(f1: CoordStruct, f2: CoordStruct, is_eq: bool) -> PyEqCoord:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_coord_array(f1: CoordArrayStruct, f2: CoordArrayStruct, is_eq: bool) -> PyEqCoordArray:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_cylindrical_map(f1: CylindricalMapStruct, f2: CylindricalMapStruct, is_eq: bool) -> PyEqCylindricalMap:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_cylindrical_map_term(f1: CylindricalMapTermStruct, f2: CylindricalMapTermStruct, is_eq: bool) -> PyEqCylindricalMapTerm:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_cylindrical_map_term1(f1: CylindricalMapTerm1Struct, f2: CylindricalMapTerm1Struct, is_eq: bool) -> PyEqCylindricalMapTerm1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_ele(f1: EleStruct, f2: EleStruct, is_eq: bool) -> PyEqEle:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_ellipse_beam_init(f1: EllipseBeamInitStruct, f2: EllipseBeamInitStruct, is_eq: bool) -> PyEqEllipseBeamInit:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_em_field(f1: EmFieldStruct, f2: EmFieldStruct, is_eq: bool) -> PyEqEmField:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_em_taylor(f1: EmTaylorStruct, f2: EmTaylorStruct, is_eq: bool) -> PyEqEmTaylor:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_em_taylor_term(f1: EmTaylorTermStruct, f2: EmTaylorTermStruct, is_eq: bool) -> PyEqEmTaylorTerm:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_expression_atom(f1: ExpressionAtomStruct, f2: ExpressionAtomStruct, is_eq: bool) -> PyEqExpressionAtom:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_floor_position(f1: FloorPositionStruct, f2: FloorPositionStruct, is_eq: bool) -> PyEqFloorPosition:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_gen_grad1(f1: GenGrad1Struct, f2: GenGrad1Struct, is_eq: bool) -> PyEqGenGrad1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_gen_grad_map(f1: GenGradMapStruct, f2: GenGradMapStruct, is_eq: bool) -> PyEqGenGradMap:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_grid_beam_init(f1: GridBeamInitStruct, f2: GridBeamInitStruct, is_eq: bool) -> PyEqGridBeamInit:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_grid_field(f1: GridFieldStruct, f2: GridFieldStruct, is_eq: bool) -> PyEqGridField:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_grid_field_pt(f1: GridFieldPtStruct, f2: GridFieldPtStruct, is_eq: bool) -> PyEqGridFieldPt:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_grid_field_pt1(f1: GridFieldPt1Struct, f2: GridFieldPt1Struct, is_eq: bool) -> PyEqGridFieldPt1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_high_energy_space_charge(f1: HighEnergySpaceChargeStruct, f2: HighEnergySpaceChargeStruct, is_eq: bool) -> PyEqHighEnergySpaceCharge:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_interval1_coef(f1: Interval1CoefStruct, f2: Interval1CoefStruct, is_eq: bool) -> PyEqInterval1Coef:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_kv_beam_init(f1: KvBeamInitStruct, f2: KvBeamInitStruct, is_eq: bool) -> PyEqKvBeamInit:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_lat(f1: LatStruct, f2: LatStruct, is_eq: bool) -> PyEqLat:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_lat_ele_loc(f1: LatEleLocStruct, f2: LatEleLocStruct, is_eq: bool) -> PyEqLatEleLoc:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_lat_param(f1: LatParamStruct, f2: LatParamStruct, is_eq: bool) -> PyEqLatParam:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_linac_normal_mode(f1: LinacNormalModeStruct, f2: LinacNormalModeStruct, is_eq: bool) -> PyEqLinacNormalMode:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_mode3(f1: Mode3Struct, f2: Mode3Struct, is_eq: bool) -> PyEqMode3:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_mode_info(f1: ModeInfoStruct, f2: ModeInfoStruct, is_eq: bool) -> PyEqModeInfo:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_normal_modes(f1: NormalModesStruct, f2: NormalModesStruct, is_eq: bool) -> PyEqNormalModes:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_photon_element(f1: PhotonElementStruct, f2: PhotonElementStruct, is_eq: bool) -> PyEqPhotonElement:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_photon_material(f1: PhotonMaterialStruct, f2: PhotonMaterialStruct, is_eq: bool) -> PyEqPhotonMaterial:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_photon_reflect_surface(f1: PhotonReflectSurfaceStruct, f2: PhotonReflectSurfaceStruct, is_eq: bool) -> PyEqPhotonReflectSurface:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_photon_reflect_table(f1: PhotonReflectTableStruct, f2: PhotonReflectTableStruct, is_eq: bool) -> PyEqPhotonReflectTable:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_photon_target(f1: PhotonTargetStruct, f2: PhotonTargetStruct, is_eq: bool) -> PyEqPhotonTarget:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_pixel_detec(f1: PixelDetecStruct, f2: PixelDetecStruct, is_eq: bool) -> PyEqPixelDetec:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_pixel_pt(f1: PixelPtStruct, f2: PixelPtStruct, is_eq: bool) -> PyEqPixelPt:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_pre_tracker(f1: PreTrackerStruct, f2: PreTrackerStruct, is_eq: bool) -> PyEqPreTracker:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_rad_int1(f1: RadInt1Struct, f2: RadInt1Struct, is_eq: bool) -> PyEqRadInt1:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_rad_int_all_ele(f1: RadIntAllEleStruct, f2: RadIntAllEleStruct, is_eq: bool) -> PyEqRadIntAllEle:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_rad_int_branch(f1: RadIntBranchStruct, f2: RadIntBranchStruct, is_eq: bool) -> PyEqRadIntBranch:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_rad_map(f1: RadMapStruct, f2: RadMapStruct, is_eq: bool) -> PyEqRadMap:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_rad_map_ele(f1: RadMapEleStruct, f2: RadMapEleStruct, is_eq: bool) -> PyEqRadMapEle:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_ramper_lord(f1: RamperLordStruct, f2: RamperLordStruct, is_eq: bool) -> PyEqRamperLord:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_space_charge_common(f1: SpaceChargeCommonStruct, f2: SpaceChargeCommonStruct, is_eq: bool) -> PyEqSpaceChargeCommon:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_spin_polar(f1: SpinPolarStruct, f2: SpinPolarStruct, is_eq: bool) -> PyEqSpinPolar:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_spline(f1: SplineStruct, f2: SplineStruct, is_eq: bool) -> PyEqSpline:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_strong_beam(f1: StrongBeamStruct, f2: StrongBeamStruct, is_eq: bool) -> PyEqStrongBeam:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_curvature(f1: SurfaceCurvatureStruct, f2: SurfaceCurvatureStruct, is_eq: bool) -> PyEqSurfaceCurvature:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_displacement(f1: SurfaceDisplacementStruct, f2: SurfaceDisplacementStruct, is_eq: bool) -> PyEqSurfaceDisplacement:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_displacement_pt(f1: SurfaceDisplacementPtStruct, f2: SurfaceDisplacementPtStruct, is_eq: bool) -> PyEqSurfaceDisplacementPt:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_h_misalign(f1: SurfaceHMisalignStruct, f2: SurfaceHMisalignStruct, is_eq: bool) -> PyEqSurfaceHMisalign:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_h_misalign_pt(f1: SurfaceHMisalignPtStruct, f2: SurfaceHMisalignPtStruct, is_eq: bool) -> PyEqSurfaceHMisalignPt:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_segmented(f1: SurfaceSegmentedStruct, f2: SurfaceSegmentedStruct, is_eq: bool) -> PyEqSurfaceSegmented:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_surface_segmented_pt(f1: SurfaceSegmentedPtStruct, f2: SurfaceSegmentedPtStruct, is_eq: bool) -> PyEqSurfaceSegmentedPt:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_target_point(f1: TargetPointStruct, f2: TargetPointStruct, is_eq: bool) -> PyEqTargetPoint:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_taylor(f1: TaylorStruct, f2: TaylorStruct, is_eq: bool) -> PyEqTaylor:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_taylor_term(f1: TaylorTermStruct, f2: TaylorTermStruct, is_eq: bool) -> PyEqTaylorTerm:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_track(f1: TrackStruct, f2: TrackStruct, is_eq: bool) -> PyEqTrack:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_track_point(f1: TrackPointStruct, f2: TrackPointStruct, is_eq: bool) -> PyEqTrackPoint:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_twiss(f1: TwissStruct, f2: TwissStruct, is_eq: bool) -> PyEqTwiss:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wake(f1: WakeStruct, f2: WakeStruct, is_eq: bool) -> PyEqWake:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wake_lr(f1: WakeLrStruct, f2: WakeLrStruct, is_eq: bool) -> PyEqWakeLr:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wake_lr_mode(f1: WakeLrModeStruct, f2: WakeLrModeStruct, is_eq: bool) -> PyEqWakeLrMode:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wake_sr(f1: WakeSrStruct, f2: WakeSrStruct, is_eq: bool) -> PyEqWakeSr:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wake_sr_mode(f1: WakeSrModeStruct, f2: WakeSrModeStruct, is_eq: bool) -> PyEqWakeSrMode:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wake_sr_z_long(f1: WakeSrZLongStruct, f2: WakeSrZLongStruct, is_eq: bool) -> PyEqWakeSrZLong:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wall3d(f1: Wall3DStruct, f2: Wall3DStruct, is_eq: bool) -> PyEqWall3d:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wall3d_section(f1: Wall3DSectionStruct, f2: Wall3DSectionStruct, is_eq: bool) -> PyEqWall3dSection:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_wall3d_vertex(f1: Wall3DVertexStruct, f2: Wall3DVertexStruct, is_eq: bool) -> PyEqWall3dVertex:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def eq_xy_disp(f1: XyDispStruct, f2: XyDispStruct, is_eq: bool) -> PyEqXyDisp:
    """
    No docstring available
    
    Parameters
    ----------
    f1 : 
    f2 : 
    is_eq : 
    """
def equal_sign_here(ele: EleStruct, delim: str, is_here: bool) -> PyEqualSignHere:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    delim : 
    is_here : 
    """
def equivalent_taylor_attributes(ele_taylor: EleStruct, ele2: EleStruct, equiv: bool) -> PyEquivalentTaylorAttributes:
    """
    No docstring available
    
    Parameters
    ----------
    ele_taylor : EleStruct
        Element with a Taylor map
    ele2 : EleStruct
        Element that might receive the Taylor map from ele_taylor.
    equiv : 
    """
def err_exit(err_str: str | None = None) -> PyErrExit:
    """
    No docstring available
    
    Parameters
    ----------
    err_str : 
    """
def etdiv(A: typing.SupportsFloat, B: typing.SupportsFloat, C: typing.SupportsFloat, D: typing.SupportsFloat, E: typing.SupportsFloat, F: typing.SupportsFloat) -> PyEtdiv:
    """
    No docstring available
    
    Parameters
    ----------
    A : 
    B : 
    C : 
    D : 
    E : 
    F : 
    """
def evaluate_array_index(delim_list1: str, delim_list2: str) -> ...:
    """
    Function of evaluate the index of an array. Typically the text being parsed looks like:
    
    "5) = ..."         or
    "6).COMP = ..."
    
    Parameters
    ----------
    delim_list1 : unknown
        Delimitor after the integer. Normally ')'.
    delim_list2 : unknown
        Delimitor list to mark the end of word2. Normally '='.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error. False otherwise.
    word2 : unknown
        Word found after delim1. Normally this should be blank.
    delim2 : unknown
        Actual delimitor found after word2.
    this_index : int
        Integer value
    """
def evaluate_logical(word: str) -> ...:
    """
    Function of convert a string into a logical value.
    
    Accepted possibilities are:
    .TRUE.  .FALSE.
    TRUE    FALSE
    T       F
    
    Parameters
    ----------
    word : unknown
        Input string.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    this_logic : bool
        Result.
    iostat : int
        Status: Returns 0 if conversion successful.
    """
def exact_bend_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orb: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Subroutine to track through the edge field of an sbend.
    
    Uses routines adapted from PTC
    
    Parameters
    ----------
    ele : EleStruct
        SBend element.
    param : LatParamStruct
    particle_at : int
        first_track_edge$, or second_track_edge$.
    orb : CoordStruct
        Coords after tracking.
    mat6 : float, optional
        Transfer matrix up to the edge.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
        edge.
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    """
def exp_bessi0(t: typing.SupportsFloat, B1: typing.SupportsFloat, B2: typing.SupportsFloat) -> float:
    """
    This is essentially the Numercal Recipes bessi0 function multiplied by exp(-B1*t).
    
    This overcomes an issue where exp(B2*t) may be huge and exp(-B1*t) may be small.
    Evaluating exp(B2*t) may result in overflow, but exp((B2-B1)*t) has a moderate value.
    Simplifying the algebra of B2-B1 suggests that is should always have a moderate magnitude.
    
    Parameters
    ----------
    t : float
        Scalar agrument to evaluate function at.
    B1 : float
        Scalar value.  Eq. 33 from Piwinski's paper.
    B2 : float
        Scalar value.  Eq. 34 from Piwinski's paper. <return value> -- Real(rp): Scalar return value.
    """
def expect_one_of(delim_list: str, check_input_delim: bool, ele_name: str, delim: str, delim_found: bool, is_ok: bool) -> PyExpectOneOf:
    """
    Routine to check either that the current delimitor or the next character in the parse stream is the
    
    expected delimitor.
    This routine is used for Bmad lattice file parsing and is not meant for general use.
    
    Parameters
    ----------
    delim_list : unknown
        List of expected (valid) delimitors. If list contains a space character then no delimitor (indicating the
        end of the command) is a valid possibility.
    check_input_delim : bool
        If True, then check if delim argument is in the delim_list. -- logical: If True, then check if delim
        argument is in the delim_list. If False, check that the next character in the parse stream is an expected
        delimitor.
    ele_name : unknown
        Lattice element under construction. Used for error messages.
    delim : unknown
        Current delimitor that will be checked if check_input_delim = .true.
        This parameter is an input/output and is modified in-place. As an output: Next delim if check_input_delim
        = False.
    
    Returns
    -------
    is_ok
    
    Notes
    -----
    Related routines:
    expect_this
    """
def expect_this(expecting: str, check_delim: bool, call_check: bool, err_str: str, ele: EleStruct) -> ...:
    """
    Checks that the next character or characters in the parse stream corresponds to the
    
    characters in the expecting argument. For example, if expecting is ')={' these three characters
    should be the next non-blank characters in the parse stream.
    
    Parameters
    ----------
    expecting : unknown
        list of characters that are expected to be next in the parse stream.
    check_delim : bool
        If True then use delim argument as first token to check. A blank character indicates end of command is
        expected.
    call_check : bool
        If True then check for 'call::<filename>' construct.
    err_str : unknown
        String used for error messages.
    ele : EleStruct
        Element parameters being parsed.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    delim : unknown
        Final delim
    delim_found : bool
        Is there a final delim (as opposed to end of command).
    
    Notes
    -----
    Related routines:
    expect_one_of
    """
def expression_stack_to_string(stack: ExpressionAtomStructAlloc1D, polish: bool | None = None) -> str:
    """
    Routine to convert an expression stack to a string
    
    Parameters
    ----------
    stack : ExpressionAtomStruct
        arithmetic expression
    polish : , optional
        logical, optional, Construct expression in reverse polish? Default is False.
    
    Returns
    -------
    str : unknown
        : Expression in string form.
    """
def expression_stack_value(stack: ExpressionAtomStructAlloc1D, var: _pybmad.ControlVar1StructAlloc1D | None = None, use_old: bool | None = None) -> ...:
    """
    Routine to evaluate a mathematical expression represented by an "expression stack".
    
    Expression stacks are created by expression_string_to_stack.
    
    Parameters
    ----------
    stack : ExpressionAtomStruct
        Expression to evaluate.
    var : ControlVar1Struct, optional
        Array of control variables. Used with Bmad controller elements.
    use_old : bool, optional
        Use var.old_value? Must be present if var(:) is present.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    value : float
        Value of the expression.
    err_flag : bool
        True if there is an evaluation problem. False otherwise.
    err_str : unknown
        Error string explaining error if there is one.
    
    Notes
    -----
    Related routines:
    expression_value expression_string_to_stack
    """
def expression_string_to_stack(string: str) -> ...:
    """
    This routine creates an expression stack array which can be used
    
    to evaluate an arithmethic expression.
    Stack end elements not used are marked stack(i)%type = end_stack$
    Stack elements with stack(i)%type = variable$ are elements that need
    to be evaluated before calling expression_stack_value.
    
    Parameters
    ----------
    string : unknown
        Expression to be converted.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    stack : ExpressionAtomStruct
        Expression evaluation stack.
    n_stack : int
        number of "atoms" used by the expression
    err_flag : bool
        Set True if there is an error (EG divide by 0).
    err_str : unknown
        String describing the error.
    
    Notes
    -----
    Related routines:
    expression_value expression_stack_value
    """
def expression_string_to_tree(string: str, root_tree: ExpressionTreeStruct) -> ...:
    """
    Routine to create an expression tree array which can be used
    
    to evaluate an arithmethic expression.
    
    Parameters
    ----------
    root_tree : ExpressionTreeStruct
        Only used when recursively called.
    string : unknown
        Expression to be converted.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    tree : ExpressionTreeStruct
        Expression evaluation tree.
    err_flag : bool
        Set True if there is an error (EG divide by 0).
    err_str : unknown
        String describing the error. Make length large to hold the expression.
    
    Notes
    -----
    Related routines:
    expression_value expression_tree_value deallocate_expression_tree Important! trees use pointers as opposed to
    allocatable arrays due to the ifort compiler not being able to ) being an allocatable array. Thus
    deallocate_expression_tree must be called before any tree instance goes out of scope. plus$ minus$ times$
    divide$ power$ unary_minus$ unary_plus$ constant$ numeric$ variable$ function$ root$ parens$ func_parens$
    square_brackets$ curly_brackets$ arrow$ equal$ colon$ double_colon$ vertical_bar$ compound$ "->" "::" + - * /
    ^ = : & [] () {} Root node name is "root" is of type root$ Brackets in the expression string must be matched.
    "[]" / square_brackets$ "()" / parens$ func_parens$ "{}" / curley_brackets$ The root node equal nodes all
    bracket nodes will have an array of child nodes all of which will be comma nodes. "[A B]" will translate to a
    "[]" node with two comma children the first comma child will have a single child "A" the second comma child
    will have a single child "B". "(A)" will translate to a "()" node with one comma child this comma child will
    have a single child "A". If the string is an equation. For example "A B = C D Z". In this case the root node
    will have two equal node children (and not comma children) The first equal node represents the left hand side
    of the equation this node will have two comma children. The second equal node child will have three comma
    children. :orxit.x" (this is a Tao construct) which get :" "orbit.x" functions line "atan()" are considered
    compound vars with children "atan" "()" The funciton argument of a species related function like "He++" in the
    construct "mass_of(He++)" will not get split will get marked as a species_const$.
    """
def expression_tree_to_string(tree: ExpressionTreeStruct, include_root: bool | None = None, n_node: typing.SupportsInt | None = None, parent: _pybmad.ExpressionTreeStruct | None = None) -> str:
    """
    Routine to convert an expression tree to a expression string.
    
    Parameters
    ----------
    tree : ExpressionTreeStruct
        Root of tree to print.
    include_root : bool, optional
        Default is True. If True, do not inculde in the output string the root node. Note: If the root node is of
        type root$, this node is always ignored.
    n_node : int, optional
        Node index. parent.node(n_node) === tree. Internal use only. Used with recursive calls.
    parent : ExpressionTreeStruct, optional
        Internal use only. Used with recusive calls.
    
    Returns
    -------
    str_out : unknown
        Expression string.
    """
def expression_value(expression: str, var: _pybmad.ControlVar1StructAlloc1D | None = None, use_old: bool | None = None) -> ...:
    """
    Routine to evaluate a mathematical expression encoded in a string.
    
    Parameters
    ----------
    expression : unknown
        Expression string.
    var : ControlVar1Struct, optional
        Array of control variables. Used with Bmad controller elements.
    use_old : bool, optional
        Use var.old_value? Must be present if var(:) is present.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    value : float
        Value of the expression.
    err_flag : bool
        True if there is an evaluation problem. False otherwise.
    err_str : unknown
        Error string explaining error if there is one.
    
    Notes
    -----
    Related routines:
    expression_string_to_stack expression_stack_value
    """
def factorial(n: typing.SupportsInt, fact: typing.SupportsFloat) -> PyFactorial:
    """
    No docstring available
    
    Parameters
    ----------
    n : 
    fact : 
    """
def faddeeva_function(z: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], w: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], dw: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]], "FixedSize(2)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    z : 
    w : 
    dw : 
    """
def fft1(a: RealAlloc1D, b: RealAlloc1D, n: typing.SupportsInt, isn: typing.SupportsInt) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    a : 
    b : 
    n : 
    isn : 
    ierr : 
    """
def fft_1d(arr: ComplexAlloc1D, isign: typing.SupportsInt) -> None:
    """
    implicit none
    
    character(*) line
    logical error
    end subroutine
    
    Parameters
    ----------
    arr : complex
        Input array.
        This parameter is an input/output and is modified in-place. As an output: FFT of array.
    isign : int
        -1 => "Forward" transform, +1 => "Backwards" transform.
    """
def field_attribute_free(ele: EleStruct, attrib_name: str) -> bool:
    """
    Routine to check if a field attribute is free to vary.
    
    Field attributes are either normalized (EG K2 of a sextupole) or unnormalized (EG B2_GRADIENT of a sextupole).
    Whether normalized or unnormalized attributes are free to vary will depend on the setting  of ele%field_master.
    Generally, this routine should not be called directly. Use the routine attribute_free instead.
    
    Parameters
    ----------
    ele : EleStruct
        Element containing the attribute
    attrib_name : unknown
        Name of the field attribute. Assumed upper case.
    
    Returns
    -------
    free : bool
        Is the attribute free to vary? If the attribute is not recognized, free = True will be returned.
    """
def file_directorizer(in_file: str, out_file: str, directory: str, add_switch: bool) -> PyFileDirectorizer:
    """
    No docstring available
    
    Parameters
    ----------
    in_file : 
    out_file : 
    directory : 
    add_switch : 
    """
def file_get(string: str, dflt_file_name: str, file_name: str) -> PyFileGet:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    dflt_file_name : 
    file_name : 
    """
def file_get_open(string: str, dflt_file_name: str, file_name: str, file_unit: typing.SupportsInt, readonly: bool) -> PyFileGetOpen:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    dflt_file_name : 
    file_name : 
    file_unit : 
    readonly : 
    """
def file_suffixer(in_file_name: str, out_file_name: str, suffix: str, add_switch: bool) -> PyFileSuffixer:
    """
    No docstring available
    
    Parameters
    ----------
    in_file_name : 
    out_file_name : 
    suffix : 
    add_switch : 
    """
def finalize_reflectivity_table(table: PhotonReflectTableStruct, in_degrees: bool) -> None:
    """
    Routine to finalize the construction of the reflectivity tables for a surface.
    
    Parameters
    ----------
    table : PhotonReflectTableStruct
        Surface tables to be finalized.
        This parameter is an input/output and is modified in-place. As an output: Finalized surface tables.
    in_degrees : bool
        Table angles in degrees?
    """
def find_element_ends(ele: EleStruct, ix_multipass: typing.SupportsInt | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to find the ends for.
    ele1 : EleStruct
        Pointer to element just before ele.
    ele2 : EleStruct
        Pointer to ele itself or the last sub-element within ele. Note: ele1 and ele2 will be nullified if ele is
        in the lord part of the lattice and does not have any slaves. Note: For an element in the tracking part of
        the lattice: ele1.ix_ele = ele.ix_ele - 1 ele2        => ele Exception: For Beginning element (index 0),
        ele1 => ele
    ix_multipass : int, optional
        Which multipass pass to follow. Default is 1. This is ignored if there is no multipass elements.
    """
def find_fwhm(bound: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> float:
    """
    Finds the full width at half max of psi(t).  fwhm * c_light / TwoRtTwoLnTwo is taken as the bunch length.
    
    Steps followed:
    Find value for p(0) that normalizes the solution to dpsi/dt.
    Find max value of p(t) for the value of p(0) found in the previous step.
    Find find tlower, tlower < 0, such that p(tlower) = pmax/2.
    Find find tupper, tupper > 0, such that p(tupper) = pmax/2.
    fwhm is tupper-tlower
    
    Parameters
    ----------
    bound : float
        -bound and +bound is integration bound.
    args : float
        Parameters and constants of dpsi/dt.  See comments of psi_prime for details.
    
    Returns
    -------
    fwhm : float
        Full width at half max of psi(t)
    """
@typing.overload
def find_location(arr: IntAlloc1D, value: typing.SupportsInt, ix_match: typing.SupportsInt) -> PyFindLocationInt:
    """
    No docstring available
    
    Parameters
    ----------
    arr : 
    value : 
    ix_match : 
    """
@typing.overload
def find_location(arr: BoolAlloc1D, value: bool, ix_match: typing.SupportsInt) -> PyFindLocationLogic:
    """
    No docstring available
    
    Parameters
    ----------
    arr : 
    value : 
    ix_match : 
    """
@typing.overload
def find_location(arr: RealAlloc1D, value: typing.SupportsFloat, ix_match: typing.SupportsInt) -> PyFindLocationReal:
    """
    No docstring available
    
    Parameters
    ----------
    arr : 
        real(rp), logical, or integer
    value : unknown
        :).
    ix_match : 
    """
def find_matching_fieldmap(file_name: str, ele: EleStruct, fm_type: typing.SupportsInt, ignore_slaves: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : unknown
        File name associated with field to match to.
    ele : EleStruct
        Element holding the field to be matched.
    fm_type : int
        Type of fieldmap: cartesian_map$, cylindircal_map$, or gen_grad_map$, grid_field$
    match_ele : EleStruct
        Pointer to element with matched field. Nullified if no match found.
    ix_field : int
        index of field. For example: matching field => match_ele.cartesian_map(ix_field) Set to -1 if no match
        found.
    ignore_slaves : bool, optional
        If True, ignore any multipass slaves. Default is False.
    """
def find_normalization(bound: typing.SupportsFloat, p0: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> float:
    """
    Finds value for boundary condition psi(0) that results in integral
    
    of psi(t) from -bound to +bound to be 1.0.  This is done with the secant method.
    Repeadedly calls integrate_psi with different values for psi(0).
    
    Parameters
    ----------
    bound : float
        -bound and +bound are integration boundaries
    p0 : float
        Boundary condition psi(0)
    args : float
        Parameters and constants of DEQ.  See psi_prime comments for details.
    
    Returns
    -------
    pnrml : float
        Value for psi(0) that results in integral of psi(t) from -bound to +bound being equal to 1.0
    """
def fine_frequency_estimate(data: RealAlloc1D) -> float:
    """
    Uses Laskar's method to accurately find the most dominant frequency
    
    A coarse estimate is first made by FFT.
    
    Parameters
    ----------
    data : float
        data to analyze
    
    Returns
    -------
    frequency : float
        Frequency corresponding to the largest FFT amplitude
    """
def fixedwindowls(ynew: typing.SupportsFloat, id: typing.SupportsInt, z: typing.SupportsFloat) -> PyFixedwindowls:
    """
    Main function of the windowLS modult.  Each call to this function adds a data point to the fit
    
    and returns the derivative evaluated at the end of the window.  It is assumed that all data points
    are separeted by the same interval.
    This module is initialized with zeros for all data points, and so the results are unreliable until
    a number of data points equal to N has been entered.
    initFixedWindowLS must be called prior to calling this function.  destFixedWindowLS should be
    called when the instance is no longer needed.
    """
def floor_angles_to_w_mat(theta: typing.SupportsFloat, phi: typing.SupportsFloat, psi: typing.SupportsFloat) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    theta : float
        Azimuth angle.
    phi : float
        Pitch angle.
    psi : float
        Roll angle.
    w_mat : float
        Orientation matrix.
    w_mat_inv : float
        Inverse Orientation matrix.
    """
def floor_w_mat_to_angles(w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"], floor0: _pybmad.FloorPositionStruct | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    w_mat : float
        Orientation matrix.
    theta : float
        Azimuth angle.
    phi : float
        Pitch angle.
    psi : float
        Roll angle.
    floor0 : FloorPositionStruct, optional
        There are two solutions related by: [theta, phi, psi] & [pi+theta, pi-phi, pi+psi] If floor0 is present,
        choose the solution "nearest" the angles in floor0.
    """
def form_complex_taylor(re_taylor: TaylorStruct, im_taylor: TaylorStruct) -> ComplexTaylorStruct:
    """
    Subroutine to form a complex taylor from two taylor series representing
    
    the real and imaginary parts
    
    Parameters
    ----------
    re_taylor : TaylorStruct
        Real part
    im_taylor : TaylorStruct
        Imaginary part
    
    Returns
    -------
    complex_taylor : ComplexTaylorStruct
        combined complex taylor
    """
def form_digested_bmad_file_name(lat_file: str, use_line: str | None = None) -> ...:
    """
    Subroutine to form the standard name of the Bmad digested file.
    
    The standard digested file name has the suffix added to the file name:
    suffix = '.digested' + bmad_inc_version$
    Exception: If the use_line argument is present and not blank, the suffix will be:
    suffix = '.' + use_line + '.digested' + bmad_inc_version$
    
    Parameters
    ----------
    lat_file : unknown
        Input lattice file name.
    use_line : unknown, optional
        Line used for lattice expansion. If not present or blank, the line used is the one that was specified in
        the lattice file.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    digested_file : unknown
        Name of the digested file.
    full_lat_file : unknown
        Input lattice file name with full directory. Can be used for error messages.
    """
def fourier_amplitude(data: RealAlloc1D, frequency: typing.SupportsFloat) -> ...:
    """
    Computes cos_amp = (1/N) * sum_n=0^{N-1} data(n-1) cos(twopi*frequency*n)
    
    and  sin_amp = (1/N) * sum_n=0^{N-1} data(n-1) sin(twopi*frequency*n)
    and optionally dcos_amp = d/dfrequency cos_amp
    dsin_amp = d/dfrequency sin_amp
    
    Parameters
    ----------
    data : float
        data to analyze
    frequency : float
        frequency
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    cos_amp : float
        cosine amplitude
    sin_amp : float
        sine amplitude
    dcos_amp : float
        cosine amplitude derivative
    dsin_amp : float
        sine amplitude derivative
    """
def fringe_here(ele: EleStruct, orbit: CoordStruct, particle_at: typing.SupportsInt, is_here: bool) -> PyFringeHere:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    orbit : CoordStruct
        Particle position.
    particle_at : int
        Either first_track_edge$ or second_track_edge$.
    is_here : 
    """
def g_bend_from_em_field(b: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], e: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], orbit: CoordStruct) -> typing.Annotated[list[float], "FixedSize(3)"]:
    """
    Routine to calculate the bending strength (1/bending_radius) for a given particle for a given field.
    
    This will include the dipole bending field of an sbend.
    
    Parameters
    ----------
    B : float
        Magnetic field.
    E : float
        Electric field
    orbit : CoordStruct
        particle orbit
    
    Returns
    -------
    g_bend : float
        bending strength vector.
    """
def g_bending_strength_from_em_field(ele: EleStruct, param: LatParamStruct, s_rel: typing.SupportsFloat, orbit: CoordStruct, local_ref_frame: bool) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked thorugh.
    param : LatParamStruct
        Lattice parameters.
    s_rel : float
        Distance from the start of the element to the particle.
    orbit : CoordStruct
        Particle position in lab (not element) frame.
    local_ref_frame : 
        Logical, If True then take the input coordinates and output g as being with respect to the frame of
        referene of the element (ignore misalignments).
    g : float
        g = (g_x, g_y, g_s) bending strength vector (|g| = 1/bend_radius).
    dg : float
        dg(:)/dr gradient. Takes into account dg_x/dx in a bend due to curvilinear coords.
    """
def g_integrals_calc(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to integrate through.
    """
def gamma_ref(ele: EleStruct, gamma: typing.SupportsFloat) -> PyGammaRef:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to evaluate at.
    gamma : 
    """
def gen_complete_elliptic(kc: typing.SupportsFloat, p: typing.SupportsFloat, c: typing.SupportsFloat, s: typing.SupportsFloat, err_tol: typing.SupportsFloat | None = None, value: typing.SupportsFloat) -> PyGenCompleteElliptic:
    """
    No docstring available
    
    Parameters
    ----------
    kc : 
    p : 
    c : 
    s : 
    err_tol : 
    value : 
    """
def gen_grad1_to_em_taylor(ele: EleStruct, gen_grad: GenGradMapStruct, iz: typing.SupportsInt) -> EmTaylorStructArray1D:
    """
    No docstring available
    
    Parameters
    ----------
    ele : unknown
        Element containing the map.
    gen_grad : GenGradMapStruct
        Gen_grad map.
    iz : int
        z-plane index to evaluate.
    em_taylor : EmTaylorStruct
        Map for (Bx, By, Bz) or (Ex, Ey, Ez) fields.
    """
def gen_grad_at_s_to_em_taylor(ele: EleStruct, gen_grad: GenGradMapStruct, s_pos: typing.SupportsFloat) -> EmTaylorStructArray1D:
    """
    No docstring available
    
    Parameters
    ----------
    ele : unknown
        Element containing the map.
    gen_grad : GenGradMapStruct
        Gen_grad map.
    s_pos : float
        Position to evaluate em_taylor at.
    em_taylor : EmTaylorStruct
        Map for (Bx, By, Bz) or (Ex, Ey, Ez) fields.
    """
def gen_grad_field(deriv: RealAlloc1D, gg: GenGrad1Struct, rho: typing.SupportsFloat, theta: typing.SupportsFloat, field: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> PyGenGradField:
    """
    No docstring available
    
    Parameters
    ----------
    deriv : 
    gg : 
    rho : 
    theta : 
    field : 
    """
def get_bl_from_fwhm(bound: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> float:
    """
    Calculate bunch length as fwhm * c_light / TwoRtTwoLnTwo.
    
    Where fwhm is full width at half max of solution to dpsi/dt.
    
    Parameters
    ----------
    bound : float
        -bound and +bound are lower and upper integration bound.
    args : float
        Parameters and constants of dpsi/dt.  See comments of psi_prime for details.
    
    Returns
    -------
    sigma : float
        Bunch length
    """
def get_bmad_com() -> BmadCommonStruct:
    """
    Get the shared BmadCommon structure
    """
def get_called_file(delim: str, call_file: str, err: bool) -> PyGetCalledFile:
    """
    No docstring available
    
    Parameters
    ----------
    delim : 
    call_file : 
    err : 
    """
def get_emit_from_sigma_mat(sigma_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], Nmat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None) -> ...:
    """
    Given a beam envelop sigma matrix sigma_mat, this returns the 3 normal mode
    
    emittances.
    The normal mode emittance of the sigma matrix are the eigenvalues of
    sigma_mat . S
    If Nmat is present, then the modes are ordered such that the eigensystem most
    closely resembles Nmat.  If Nmat is not present, then the modes are ordered
    according to which plane they dominate.
    / 0  1  0  0  0  0 \\
    |-1  0  0  0  0  0 |
    S = | 0  0  0  1  0  0 |
    | 0  0 -1  0  0  0 |
    | 0  0  0  0  0  1 |
    \\ 0  0  0  0 -1  0 /
    
    Parameters
    ----------
    sigma_mat : float
        beam envelop sigma matrix
    Nmat : float, optional
        If present, then the emittanced will be ordered such that the eigensystem most closely resembles Nmat.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    normal : float
        normal mode emittances
    err_flag : bool
        Set to true if something went wrong.  Otherwise set to false.
    """
def get_file_number(file_name: str, cnum_in: str, num_out: typing.SupportsInt, err_flag: bool) -> PyGetFileNumber:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    cnum_in : 
    num_out : 
    err_flag : 
    """
def get_file_time_stamp(file: str, time_stamp: str) -> PyGetFileTimeStamp:
    """
    implicit none
    
    character(*) filein
    character(*) cnum
    integer digits
    end subroutine
    """
def get_next_word(word: str, ix_word: typing.SupportsInt, delim_list: str, delim: str, delim_found: bool, upper_case_word: bool | None = None, call_check: bool | None = None, err_flag: bool | None = None) -> None:
    """
    Subroutine to get the next word from the input stream.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    
    Parameters
    ----------
    word : unknown
        Word returned
    delim_list : unknown
        List of valid delimiters
    upper_case_word : bool, optional
        if True then convert word to upper case. Default is True.
    call_check : bool, optional
        If present and True then check for 'call::<filename>' construct. Default is False. Output
    ix_word : int
        length of word argument
    delim : unknown
        Actual delimiter found
    delim_found : bool
        Set true if a delimiter found. A delimiter may not be found if the end of the line is reached first.
    err_flag : bool, optional
        Set True if there is an error. False otherwise.
    """
def get_slave_list(lord: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lord : EleStruct
        The lord element.
    slaves : ElePointerStruct
        : Array of slaves.
    n_slave : int
        Number of slaves.
    """
def get_space_charge_com() -> SpaceChargeCommonStruct:
    """
    Get the shared SpaceChargeCommon structure
    """
def get_super_universe() -> TaoSuperUniverseStruct:
    """
    Get the shared TaoSuperUniverse structure
    """
def gpt_field_grid_scaling(ele: EleStruct, dimensions: typing.SupportsInt, field_scale: typing.SupportsFloat, ref_time: typing.SupportsFloat) -> PyGptFieldGridScaling:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    dimensions : 
    field_scale : 
    ref_time : 
    """
def gpt_max_field_reference(pt0: GridFieldPt1Struct, ele: EleStruct, field_value: typing.SupportsFloat) -> PyGptMaxFieldReference:
    """
    No docstring available
    
    Parameters
    ----------
    pt0 : 
    ele : 
    field_value : 
    """
def gpt_to_particle_bunch(gpt_file: str, ele: EleStruct) -> ...:
    """
    Routine to initialize a bunch of particles from a GPT screen file.
    
    Parameters
    ----------
    gpt_file : unknown
        Name of GPT data file.
    ele : EleStruct
        Lattice element whose downstream end coincident with the GPT screen.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    bunch : BunchStruct
        Particle bunch
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def gradient_shift_sr_wake(ele: EleStruct, param: LatParamStruct, grad_shift: typing.SupportsFloat) -> PyGradientShiftSrWake:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lcavity element.
    param : LatParamStruct
        Lattice parameters .n_part        -- Number of particles in a bunch .particle      -- Type of particle
    grad_shift : 
    """
def grid_field_interpolate(ele: EleStruct, orbit: CoordStruct, grid: GridFieldStruct, err_flag: bool, x1: typing.SupportsFloat, x2: typing.SupportsFloat | None = None, x3: typing.SupportsFloat | None = None, allow_s_out_of_bounds: bool | None = None, print_err: bool | None = None) -> GridFieldPt1Struct:
    """
    allow_s_out_of_bounds, print_err)
    
    Subroutine to interpolate the E and B fields on a rectilinear grid.
    
    Parameters
    ----------
    ele : EleStruct
        Element containing the grid.
    orbit : CoordStruct
        Used for constructing an error message if the particle is out of bounds.
    grid : GridFieldStruct
        Grid to interpolate.
    err_flag : bool
        Set to true if there is an error. False otherwise.
    x1 : float
        dimension 1 interpolation point.
    x2 : float, optional
        dimension 2 interpolation point.
    x3 : float, optional
        dimension 3 interpolation point.
    allow_s_out_of_bounds : bool, optional
        allow s-coordinate grossly out of bounds to return zero field without an error. This is used when the
        field of one element overlaps the field of another. Default is False.
    print_err : bool, optional
        print an error message if the particle is out of bounds? Default is True.
    
    Returns
    -------
    field : GridFieldPtStruct
        Interpolated field (complex)
    """
def hanhan(N: typing.SupportsInt, hh: RealAlloc1D) -> PyHanhan:
    """
    No docstring available
    
    Parameters
    ----------
    N : 
    hh : 
    """
def hard_multipole_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Routine to track through the hard edge field of a multipole.
    
    The dipole component is ignored and only quadrupole and higher multipoles are included.
    This routine handles elements of type:
    sad_mult, sbend, quadrupole, sextupole
    For sad_mult elements, ele%a_pole and ele%b_pole ae used for the multipole values.
    For the other elements, k1 or k2 is used and it is assumed that we are in the element
    frame of reference so tilt = 0.
    
    Parameters
    ----------
    ele : EleStruct
        Element with fringe.
    param : LatParamStruct
        Tracking parameters.
    particle_at : int
        Either first_track_edge$ or second_track_edge$.
    orbit : CoordStruct
        Starting coordinates.
        This parameter is an input/output and is modified in-place. As an output: Ending coordinates.
    mat6 : float, optional
        Transfer matrix up to the fringe.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
        fringe.
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    """
def has_attribute(ele: EleStruct, attrib: str, has_it: bool) -> PyHasAttribute:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    attrib : 
    has_it : 
    """
def has_curvature(phot_ele: PhotonElementStruct) -> bool:
    """
    Routine to determine if a surface is potentially curved or is flat.
    
    Parameters
    ----------
    phot_ele : PhotonElementStruct
        From ele.photon
    
    Returns
    -------
    curved : bool
        Set True if phot_eleace is curved.
    """
def has_orientation_attributes(ele: EleStruct) -> bool:
    """
    Routine to determine whether an element has orientation attributes like x_offset, etc.
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    
    Returns
    -------
    has_attribs : bool
        True if ele has orientation attributes. False otherwise.
    
    Notes
    -----
    Related routines:
    has_attribute function.
    """
def hdf5_write_beam(file_name: str, bunches: BunchStructAlloc1D, append: bool, error: bool, lat: _pybmad.LatStruct | None = None, alive_only: bool | None = None) -> PyHdf5WriteBeam:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    bunches : 
    append : 
    error : 
    lat : 
    alive_only : 
    """
def hdf5_write_grid_field(file_name: str, ele: EleStruct, g_field: GridFieldStructAlloc1D, err_flag: bool) -> PyHdf5WriteGridField:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    ele : 
    g_field : 
    err_flag : 
    """
def hom_voltage(lr_wake: WakeLrModeStruct, voltage: typing.SupportsFloat) -> PyHomVoltage:
    """
    No docstring available
    
    Parameters
    ----------
    lr_wake : 
    voltage : 
    """
def hwang_bend_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orb: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Subroutine to track through the edge field of an sbend using a 2nd order map.
    
    Adapted from:
    Hwang and S. Y. Lee,
    "Dipole Fringe Field Thin Map for Compact Synchrotrons",
    Phys. Rev. ST Accel. Beams, 12, 122401, (2015).
    See the Bmad manual for details.
    
    Parameters
    ----------
    orb : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
    ele : EleStruct
        SBend element.
    param : LatParamStruct
        Rel charge.
    particle_at : int
        first_track_edge$, or second_track_edge$
    mat6 : float, optional
        Transfer matrix up to the edge.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
        edge.
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    """
def i_bessel(m: typing.SupportsInt, arg: typing.SupportsFloat, i_bes: typing.SupportsFloat) -> PyIBessel:
    """
    No docstring available
    
    Parameters
    ----------
    m : 
    arg : 
    i_bes : 
    """
def i_bessel_extended(m: typing.SupportsInt, arg: typing.SupportsFloat, i_bes: complex) -> PyIBesselExtended:
    """
    No docstring available
    
    Parameters
    ----------
    m : 
    arg : 
    i_bes : 
    """
def ibs_matrix_c(sigma_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], tail_cut: bool, tau: typing.SupportsFloat, energy: typing.SupportsFloat, n_part: typing.SupportsFloat, species: typing.SupportsInt, ibs_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> PyIbsMatrixC:
    """
    No docstring available
    
    Parameters
    ----------
    sigma_mat : 
    tail_cut : 
    tau : 
    energy : 
    n_part : 
    species : 
    ibs_mat : 
    """
def igfcoulombfun(u: typing.SupportsFloat, v: typing.SupportsFloat, w: typing.SupportsFloat, gam: typing.SupportsFloat, dx: typing.SupportsFloat, dy: typing.SupportsFloat, dz: typing.SupportsFloat, res: typing.SupportsFloat) -> PyIgfcoulombfun:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    v : 
    w : 
    gam : 
    dx : 
    dy : 
    dz : 
    res : 
    """
def igfexfun(u: typing.SupportsFloat, v: typing.SupportsFloat, w: typing.SupportsFloat, gam: typing.SupportsFloat, dx: typing.SupportsFloat, dy: typing.SupportsFloat, dz: typing.SupportsFloat, res: typing.SupportsFloat) -> PyIgfexfun:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    v : 
    w : 
    gam : 
    dx : 
    dy : 
    dz : 
    res : 
    """
def igfeyfun(u: typing.SupportsFloat, v: typing.SupportsFloat, w: typing.SupportsFloat, gam: typing.SupportsFloat, dx: typing.SupportsFloat, dy: typing.SupportsFloat, dz: typing.SupportsFloat, res: typing.SupportsFloat) -> PyIgfeyfun:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    v : 
    w : 
    gam : 
    dx : 
    dy : 
    dz : 
    res : 
    """
def igfezfun(u: typing.SupportsFloat, v: typing.SupportsFloat, w: typing.SupportsFloat, gam: typing.SupportsFloat, dx: typing.SupportsFloat, dy: typing.SupportsFloat, dz: typing.SupportsFloat, res: typing.SupportsFloat) -> PyIgfezfun:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    v : 
    w : 
    gam : 
    dx : 
    dy : 
    dz : 
    res : 
    """
def increment_file_number(file_name: str, digits: typing.SupportsInt, number: typing.SupportsInt, cnumber: str) -> PyIncrementFileNumber:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    digits : 
    number : 
    cnumber : 
    """
def index_nocase(string1: str, string2: str, indx: typing.SupportsInt) -> PyIndexNocase:
    """
    No docstring available
    
    Parameters
    ----------
    string1 : 
    string2 : 
    indx : 
    """
def init_attribute_name1(ix_key: typing.SupportsInt, ix_attrib: typing.SupportsInt, name: str, attrib_state: typing.SupportsInt | None = None, override: bool | None = None) -> None:
    """
    Routine to initialize a single name in the element attribute name table.
    
    Parameters
    ----------
    ix_key : int
        Key index.
    ix_attrib : int
        Attribute index.
    name : unknown
        Attribute name. Should be uppercase if attrib_state = is_free$. Should contain non-uppercase characters if
        attrib_state = private$.
    attrib_state : int, optional
        Class of attribute: does_not_exist$, is_free$, etc. Defaults to is_free$.
    override : bool, optional
        Normally this routine throws an error if the [ix_key, ix_attrib] has been set previously. If override =
        True then the set is done and no error is generated.
    """
def init_attribute_name_array() -> None:
    """
    Private routine to initialize the attribute name array used by routines
    
    in attribute_mod. Not meant for general use.
    """
def init_beam_distribution(ele: EleStruct, param: LatParamStruct, beam_init: BeamInitStruct, modes: _pybmad.NormalModesStruct | None = None, print_p0c_shift_warning: bool | None = None, conserve_momentum: bool | None = None) -> PyInitBeamDistribution:
    """
    print_p0c_shift_warning, conserve_momentum)
    
    Subroutine to initialize a beam of particles.
    Initialization uses the downstream parameters of ele.
    
    Parameters
    ----------
    ele : EleStruct
        element to initialize distribution at (downstream end).
    param : LatParamStruct
        Lattice parameters .particle              -- Type of particle.
    beam_init : BeamInitStruct
        Use "getf beam_init_struct" for more details.
    modes : NormalModesStruct, optional
        Normal mode parameters. See above.
    print_p0c_shift_warning : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    shift_momentum : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    beam : BeamStruct
        Structure with initialized particles.
    err_flag : bool
        Set true if there is an error, false otherwise.
    beam_init_set : BeamInitStruct
        Set to input beam_init with components like .a_emit set what is used in constructing the beam (which is
        different from beam_init.a_emit if this is set negative).
    """
def init_bmad() -> None:
    """
    No docstring available
    """
def init_bmad_parser_common(lat: _pybmad.LatStruct | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    """
def init_bunch_distribution(ele: EleStruct, param: LatParamStruct, beam_init: BeamInitStruct, ix_bunch: typing.SupportsInt, modes: _pybmad.NormalModesStruct | None = None, print_p0c_shift_warning: bool | None = None, conserve_momentum: bool | None = None) -> PyInitBunchDistribution:
    """
    print_p0c_shift_warning, conserve_momentum)
    
    Subroutine to initialize a distribution of particles of a bunch.
    Initialization uses the downstream parameters of ele.
    There are four distributions available:
    '', or 'ran_gauss' -- Random gaussian distribution.
    'ellipse'  -- concentric ellipses representing a Gaussian distribution
    'grid'     -- uniform rectangular grid
    'KV'       -- Kapchinsky-Vladimirsky distribution
    See the Bmad manual for more information.
    The distribution is matched to the Twiss parameters, centroid position, and Energy - z
    correlation as specified. Coupling in the element ele is incorporated into the distribution.
    
    Parameters
    ----------
    ele : EleStruct
        element to initialize distribution at (downstream end).
    param : LatParamStruct
        Lattice parameters
    beam_init : BeamInitStruct
        Use "getf beam_init_struct" for more details.
    ix_bunch : int
        Bunch index. 0 = bunch generated at time = 0.
    modes : NormalModesStruct, optional
        Normal mode parameters. See above.
    print_p0c_shift_warning : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    shift_momentum : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    bunch : BunchStruct
        Structure with initialized particles.
    err_flag : bool
        Set True if there is an error. False otherwise.
    beam_init_used : BeamInitStruct
        Set to input beam_init with components like .a_emit set what is used in constructing the beam (which can
        be different from beam_init.a_emit if this is set negative). If reading from a file, beam_init_used will
        equal beam_init.
    """
def init_complex_taylor_series(complex_taylor: ComplexTaylorStruct, n_term: typing.SupportsInt, save: bool | None = None) -> None:
    """
    Subroutine to initialize a Bmad complex_taylor series (6 of these series make
    
    a complex_taylor map). Note: This routine does not zero the structure. The calling
    routine is responsible for setting all values.
    
    Parameters
    ----------
    complex_taylor : ComplexTaylorStruct
        Old structure.
        This parameter is an input/output and is modified in-place. As an output: Initalized structure.
    n_term : int
        Number of terms to allocate. n_term < 1 => complex_taylor.term pointer will be disassociated.
    save : bool, optional
        If True then save any old terms when complex_taylor is resized. Default is False.
    """
@typing.overload
def init_coord(orb: CoordStruct, vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"], ele: _pybmad.EleStruct | None = None, element_end: typing.SupportsInt | None = None, particle: typing.SupportsInt | None = None, direction: typing.SupportsInt | None = None, E_photon: typing.SupportsFloat | None = None, t_offset: typing.SupportsFloat | None = None, shift_vec6: bool | None = None, spin: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None, s_pos: typing.SupportsFloat | None = None, random_on: bool | None = None) -> None:
    """
    Routine to initialize a coord_struct.
    
    Subroutine init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    Subroutine init_coord2 (orb, orb_in, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    Subroutine init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    
    Parameters
    ----------
    orb_in : CoordStruct
        Input orbit.
    vec : float
        Coordinate vector. If not present then taken to be zero.
    ele : EleStruct, optional
        Particle is initialized to start at element_end of this ele.
    element_end : int, optional
        upstream_end$, downstream_end$, inside$, or start_end$. Must be present if ele argument is present.
        start_end$ -> upstream_end$ if dir = 1 and start_end$ -> downstream_end$ if dir = -1. Default is
        upstream_end$. Note: If ele is the beginning element (index zero), the setting of element_end will not
        matter.
    particle : int, optional
        Particle type (electron$, etc.). If particle = not_set$ and orb_in is present, use orb_in.species instead.
    direction : int, optional
        +1 -> moving downstream +s direciton, -1 -> moving upstream. 0 -> Ignore. Default is to not change
        orb.direction except for photons which get set according to orb.vec(6).
    E_photon : float, optional
        Photon energy if particle is a photon. Ignored otherwise.
    t_offset : float, optional
        Offset of the reference time. This is non-zero when there are multiple bunches and the reference time for
        a particular particle is pegged to the time of the center of the bunch.
    shift_vec6 : bool, optional
        If present and False, prevent the shift of orb.vec(6).
    spin : float, optional
        Particle spin. Taken to be zero if not present.
    s_pos : float, optional
        Particle s-position. Only relavent if element_end = inside$.
    random_on : bool, optional
        Default is True. Used only for photons being initalized with a photon_init element. If True, vary the
        photon coords using a random number generator. If False, the photon coords will be centered within the
        distribution specified in the photon_init ele.
    
    Returns
    -------
    orb : coord_struct
        Input orbit
    
    Notes
    -----
    Overloaded versions:
    """
@typing.overload
def init_coord(orb_in: CoordStruct, ele: _pybmad.EleStruct | None = None, element_end: typing.SupportsInt | None = None, particle: typing.SupportsInt | None = None, direction: typing.SupportsInt | None = None, E_photon: typing.SupportsFloat | None = None, t_offset: typing.SupportsFloat | None = None, shift_vec6: bool | None = None, spin: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None, s_pos: typing.SupportsFloat | None = None, random_on: bool | None = None) -> CoordStruct:
    """
    Routine to initialize a coord_struct.
    
    Subroutine init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    Subroutine init_coord2 (orb, orb_in, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    Subroutine init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    
    Parameters
    ----------
    orb_in : coord_struct
        Input orbit
    vec : float
        Coordinate vector. If not present then taken to be zero.
    ele : EleStruct, optional
        Particle is initialized to start at element_end of this ele.
    element_end : int, optional
        upstream_end$, downstream_end$, inside$, or start_end$. Must be present if ele argument is present.
        start_end$ -> upstream_end$ if dir = 1 and start_end$ -> downstream_end$ if dir = -1. Default is
        upstream_end$. Note: If ele is the beginning element (index zero), the setting of element_end will not
        matter.
    particle : int, optional
        Particle type (electron$, etc.). If particle = not_set$ and orb_in is present, use orb_in.species instead.
    direction : int, optional
        +1 -> moving downstream +s direciton, -1 -> moving upstream. 0 -> Ignore. Default is to not change
        orb.direction except for photons which get set according to orb.vec(6).
    E_photon : float, optional
        Photon energy if particle is a photon. Ignored otherwise.
    t_offset : float, optional
        Offset of the reference time. This is non-zero when there are multiple bunches and the reference time for
        a particular particle is pegged to the time of the center of the bunch.
    shift_vec6 : bool, optional
        If present and False, prevent the shift of orb.vec(6).
    spin : float, optional
        Particle spin. Taken to be zero if not present.
    s_pos : float, optional
        Particle s-position. Only relavent if element_end = inside$.
    random_on : bool, optional
        Default is True. Used only for photons being initalized with a photon_init element. If True, vary the
        photon coords using a random number generator. If False, the photon coords will be centered within the
        distribution specified in the photon_init ele.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    orb : CoordStruct
        Initialized coordinate. Note: For photons, orb.vec(6) is computed as sqrt(1 - vec(2)^2 - vec(4)^2) if
        needed.
    orb_out : coord_struct
        Initialized coordinate
    
    Notes
    -----
    Overloaded versions:
    """
@typing.overload
def init_coord(orb: CoordStruct, ele: _pybmad.EleStruct | None = None, element_end: typing.SupportsInt | None = None, particle: typing.SupportsInt | None = None, direction: typing.SupportsInt | None = None, E_photon: typing.SupportsFloat | None = None, t_offset: typing.SupportsFloat | None = None, shift_vec6: bool | None = None, spin: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None) -> None:
    """
    Routine to initialize a coord_struct.
    
    Subroutine init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    Subroutine init_coord2 (orb, orb_in, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    Subroutine init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, shift_vec6, spin, s_pos, random_on)
    
    Parameters
    ----------
    orb_in : CoordStruct
        Input orbit.
    vec : float
        Coordinate vector. If not present then taken to be zero.
    ele : EleStruct, optional
        Particle is initialized to start at element_end of this ele.
    element_end : int, optional
        upstream_end$, downstream_end$, inside$, or start_end$. Must be present if ele argument is present.
        start_end$ -> upstream_end$ if dir = 1 and start_end$ -> downstream_end$ if dir = -1. Default is
        upstream_end$. Note: If ele is the beginning element (index zero), the setting of element_end will not
        matter.
    particle : int, optional
        Particle type (electron$, etc.). If particle = not_set$ and orb_in is present, use orb_in.species instead.
    direction : int, optional
        +1 -> moving downstream +s direciton, -1 -> moving upstream. 0 -> Ignore. Default is to not change
        orb.direction except for photons which get set according to orb.vec(6).
    E_photon : float, optional
        Photon energy if particle is a photon. Ignored otherwise.
    t_offset : float, optional
        Offset of the reference time. This is non-zero when there are multiple bunches and the reference time for
        a particular particle is pegged to the time of the center of the bunch.
    shift_vec6 : bool, optional
        If present and False, prevent the shift of orb.vec(6).
    spin : float, optional
        Particle spin. Taken to be zero if not present.
    s_pos : float, optional
        Particle s-position. Only relavent if element_end = inside$.
    random_on : bool, optional
        Default is True. Used only for photons being initalized with a photon_init element. If True, vary the
        photon coords using a random number generator. If False, the photon coords will be centered within the
        distribution specified in the photon_init ele.
    
    Returns
    -------
    orb : coord_struct
        Input orbit
    
    Notes
    -----
    Overloaded versions:
    """
def init_custom(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    """
def init_ele(key: typing.SupportsInt | None = None, sub_key: typing.SupportsInt | None = None, ix_ele: typing.SupportsInt | None = None, branch: _pybmad.BranchStruct | None = None) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Initialized element.
    key : int, optional
        Key to initialize to. EG: quadrupole$, etc.
    sub_key : int, optional
        Sub-key to initialize to.
    ix_ele : int, optional
        ix_ele index to initalize to. Default = -1.
    branch : BranchStruct, optional
        Branch to point ele.branch and ele.ix_branch to. Otherwise ele.branch is nullified and ele.ix_branch = 0.
    """
def init_em_taylor_series(em_taylor: EmTaylorStruct, n_term: typing.SupportsInt, save_old: bool | None = None) -> None:
    """
    Subroutine to initialize a Bmad Em_taylor series (6 of these series make
    
    a Em_taylor map). Note: This routine does not zero the structure. The calling
    routine is responsible for setting all values.
    
    Parameters
    ----------
    em_taylor : EmTaylorStruct
        Old structure.
        This parameter is an input/output and is modified in-place. As an output: Initalized structure.
    n_term : int
        Number of terms to allocate. n_term < 0 => em_taylor.term pointer will be disassociated.
    save_old : bool, optional
        If True then save any old terms when em_taylor is resized. Default is False.
    """
def init_lat(n: typing.SupportsInt | None = None, init_beginning_ele: bool | None = None) -> LatStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Initialized lat.
    n : int, optional
        Upper bound lat.ele(0:) array is initialized to. Default is 10.
    init_beginning_ele : bool, optional
        Init lat.ele(0)? Default is False.
    """
def init_multipole_cache(ele: EleStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to init
        This parameter is an input/output and is modified in-place. As an output: Initalized element.
    """
def init_photon_from_a_photon_init_ele(ele: EleStruct, param: LatParamStruct, random_on: bool | None = None) -> CoordStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        patch element.
    param : 
        lat_param_struct.
    orbit : CoordStruct
        Output photon coords.
    random_on : bool, optional
        : Default is True. If False then use zero for all random numbers needed in the calc.
    """
def init_photon_integ_prob(gamma: typing.SupportsFloat, g: typing.SupportsFloat, E_min: typing.SupportsFloat, E_max: typing.SupportsFloat, vert_angle_min: typing.SupportsFloat | None = None, vert_angle_max: typing.SupportsFloat | None = None, vert_angle_symmetric: bool | None = None, energy_integ_prob: typing.SupportsFloat | None = None) -> ...:
    """
    vert_angle_max, vert_angle_symmetric, energy_integ_prob, E_photon) result (integ_prob)
    
    Routine to calcuate the integrated probability of emitting a photon in a given vertical angle range
    and in a given energy range
    
    Parameters
    ----------
    gamma : float
        Gamma factor of charged particle emitting photon.
    g : float
        1/rho bending strength.
    E_min : float
        Minimum photon energy.
    E_max : float
        Maximum photon energy.
    vert_angle_min : float, optional
        Lower bound of vertical angle range.
    vert_angle_max : float, optional
        Upper bound of vertical angle range.
    vert_angle_symmetric : float, optional
        Use two symmetric ranges [-vert_angle_max, -vert_angle_min] and [vert_angle_min, vert_angle_max] instead
        of just [vert_angle_min, vert_angle_max]?
    energy_integ_prob : float, optional
        If present, E_photon will be set to the photon energy such that the integrated probability of generating a
        photon in the given angle and energy range in the interval [E_min, E_photon] is energy_integ_prob. That
        is, energy_integ_prob = 0 => E_photon = E_min and energy_integ_prob = 1 => E_photon = E_max.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    E_photon : float
        See energy_integ_prob. E_photon must be present if energy_integ_prob is.
    integ_prob : float
        Integrated probablility of emitting a photon in given angle and energy range.
    """
def init_spin_distribution(beam_init: BeamInitStruct, ele: EleStruct) -> BunchStruct:
    """
    Initializes a spin distribution according to beam_init%spin.
    
    Parameters
    ----------
    beam_init : BeamInitStruct
        Initialization parameters .spin(3)  -- (x, y, z) spin coordinates ele
    
    Returns
    -------
    bunch : BunchStruct
        Bunch of particles. .particle(:).spin
    """
def init_surface_segment(phot: PhotonElementStruct, ix: typing.SupportsInt, iy: typing.SupportsInt) -> PyInitSurfaceSegment:
    """
    Routine to init the componentes in ele%photon%segmented%pt(ix,iy) for use with segmented surface calculations.
    
    Parameters
    ----------
    phot : unknown
        index of grid point to init.
    """
def init_taylor_series(bmad_taylor: TaylorStruct, n_term: typing.SupportsInt, save_old: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    bmad_taylor : TaylorStruct
        Old structure.
        This parameter is an input/output and is modified in-place. As an output: Initalized structure.
    n_term : int
        Number of terms to allocate. n_term < 0 => bmad_taylor.term pointer will be disassociated.
    save_old : bool, optional
        If True then save any old terms and ref orbit when bmad_taylor is resized. If False zero the ref orbit.
        Default is False.
    """
def init_wake(n_sr_long: typing.SupportsInt, n_sr_trans: typing.SupportsInt, n_sr_z: typing.SupportsInt, n_lr_mode: typing.SupportsInt, always_allocate: bool | None = None) -> WakeStruct:
    """
    No docstring available
    
    Parameters
    ----------
    wake : WakeStruct
        Initialized structure.
    n_sr_long : int
        Number of terms: wake.sr.long.
    n_sr_trans : int
        Number of terms: wake.sr.trans.
    n_sr_z : int
        Number of terms: wake.sr.z.
    n_lr_mode : int
        Number of terms: wake.lr.mode.
    always_allocate : bool, optional
        If present and True then allways allocate wake even if n_lr_mode, etc. are all 0. Default is False.
    """
def initfixedwindowls(N: typing.SupportsInt, dt: typing.SupportsFloat, order: typing.SupportsInt, der: typing.SupportsInt) -> int:
    """
    Initializes an instance of the fixed window least squares module.
    
    See module documentation (getf windowLS_mod) for use details.
    Any instance of windowLS created with this module should be destroyed with destFixedWindowLS.
    
    Parameters
    ----------
    N : int
        Number of data points to fit over. aka window size.
    dt : float
        Time interval between data points. It is assumed that the data is separated by fixed time intervals.
    order : int
        Order of fit polynomial.  Must be greater than or equal to der.
    der : int
        Order of derivative to be returned. Set der=0 to obtain the fit. <return value>  -- INTEGER: id of
        windowLS instance created.
    """
def insert_element(lat: LatStruct, insert_ele: EleStruct, ix_ele: typing.SupportsInt, ix_branch: typing.SupportsInt | None = None, orbit: _pybmad.CoordStructAlloc1D | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        lattice that will be modified
        This parameter is an input/output and is modified in-place. As an output: lattice with new element
        inserted
    insert_ele : EleStruct
        element to insert into the lat
    ix_ele : int
        branch.ele(:) index where the new element is inserted.
    ix_branch : int, optional
        : branch index for the insertion. Default = 0.
    orbit : CoordStruct, optional
        orbit array to enlarge.
        This parameter is an input/output and is modified in-place. As an output: Enlarged orbit array.
    """
def insert_phase_trombone(branch: BranchStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch.
        This parameter is an input/output and is modified in-place. As an output: Lattice branch with trumbone at
        branch.ele(1).
    """
def int_str(int_: typing.SupportsInt, width: typing.SupportsInt | None = None, str: str) -> PyIntStr:
    """
    No docstring available
    
    Parameters
    ----------
    int : 
    width : 
    str : 
    """
def integrand_base(t: typing.SupportsFloat, args: RealAlloc1D, func_retval__: typing.SupportsFloat) -> PyIntegrandBase:
    """
    This vectorized private function is the integrand in equation 31 of Piwinski's paper.
    
    This intetegrand has a sharp exponential decay, and so a change of variables from t to y where t=exp(y)
    is applied.  This COV makes the integrand more evenly distributed over the domain of integration,
    which makes it easier for qtrap to integrate.
    The change of variables is done using integrand_base_cov, which is then integrated
    using qtrap.
    
    Parameters
    ----------
    t : float
        Array of reals over which to evaluate the integrand. <return value> -- REAL(rp): Array of reals containing
        values of integrand at t(:).
    """
def integrate_max(ix_start: typing.SupportsInt, ix_ele: typing.SupportsInt, datum_value: typing.SupportsFloat, ix_m: typing.SupportsInt, branch: BranchStruct, vec: RealAlloc1D, datum: TaoDataStruct) -> PyIntegrateMax:
    """
    No docstring available
    
    Parameters
    ----------
    ix_start : 
    ix_ele : 
    datum_value : 
    ix_m : 
    branch : 
    vec : 
    datum : 
    """
def integrate_min(ix_start: typing.SupportsInt, ix_ele: typing.SupportsInt, datum_value: typing.SupportsFloat, ix_m: typing.SupportsInt, branch: BranchStruct, vec: RealAlloc1D, datum: TaoDataStruct) -> PyIntegrateMin:
    """
    No docstring available
    
    Parameters
    ----------
    ix_start : 
    ix_ele : 
    datum_value : 
    ix_m : 
    branch : 
    vec : 
    datum : 
    """
def integrate_psi(bound: typing.SupportsFloat, p0: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> float:
    """
    Integrate psi(t) from -bound to +bound.  The integration is done in two parts.  First from 0 to -bound, then from
    
    0 to +bound.
    
    Parameters
    ----------
    bound : float
        integration bound
    p0 : float
        psi(0).  Boundary condition.
    args : float
        Parameters and constants of DEQ.  See psi_prime comments for details.
    
    Returns
    -------
    result : float
        Integral of psi from -bound to +bound.
    """
def integrated_mats(eles: EleStructAlloc1D, coos: CoordStructAlloc1D, Lambda: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], Theta: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], Iota: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], mode: NormalModesStruct) -> None:
    ...
def integration_timer(ele: EleStruct, param: LatParamStruct, start: CoordStruct, orb_max: CoordStruct, tol: typing.SupportsFloat) -> PyIntegrationTimerEle:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    param : 
    start : 
    orb_max : 
    tol : 
    """
def interpolated_fft(cdata: ComplexAlloc1D, calc_ok: bool, opt_dump_spectrum: typing.SupportsInt | None = None, opt_dump_index: typing.SupportsInt | None = None, this_fft: typing.SupportsFloat) -> PyInterpolatedFft:
    """
    Windows the complex data and used Numerical Recipes four1 to find the peak in the spectrum.
    
    The result is interpolated to improve the accuracy.  Hanning and Gaussian windowing are
    available.
    
    
    Returns
    -------
    this_fft
    """
def interpolated_fft_gsl(cdata: ComplexAlloc1D, calc_ok: bool, opt_dump_spectrum: typing.SupportsInt | None = None, opt_dump_index: typing.SupportsInt | None = None, this_fft: typing.SupportsFloat) -> PyInterpolatedFftGsl:
    """
    Windows the complex data and uses a mixed-radix GSL routine to find the peak in the spectrum.
    
    The result is interpolated to improve the accuracy.  Hanning and Gaussian windowing are
    available.
    """
def ion_kick(orbit: CoordStruct, r_beam: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], n_beam_part: typing.SupportsFloat, a_twiss: TwissStruct, b_twiss: TwissStruct, sig_ee: typing.SupportsFloat) -> typing.Annotated[list[float], "FixedSize(3)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Ion position.
    r_beam : float
        Beam (x, y) position.
    n_beam_part : float
        Number of beam particles.
    a_twiss : TwissStruct
        Horizontal like beam twiss parameters.
    b_twiss : TwissStruct
        vertical like beam twiss parameters.
    sig_ee : float
        Sigma_E/E beam energy spread.
    kick : float
        (x, y, s) kick in m/sec.
    """
def is_alphabetic(string: str, valid_chars: str | None = None, is_alpha: bool) -> PyIsAlphabetic:
    """
    import
    
    implicit none
    real(rp) prob
    real(rp) val
    end function
    
    
    Returns
    -------
    prob
    """
def is_attribute(ix_attrib: typing.SupportsInt, which: typing.SupportsInt) -> bool:
    """
    Routine to determine if an attribute index corresponds to a control variable for overlys/groups.
    
    Parameters
    ----------
    ix_attrib : int
        Attribute index.
    which : int
        control_var$, old_control_var$, all_control_var$, multipole$, elec_multipole$
    
    Returns
    -------
    is_attrib : bool
        True if a control variable
    """
def is_decreasing_sequence(array: RealAlloc1D, strict: bool | None = None, is_decreasing: bool) -> PyIsDecreasingSequence:
    """
    No docstring available
    
    Parameters
    ----------
    array : float
        Sequence.
    strict : bool, optional
        If True (default) sequence must be strictly decreasing.
    is_decreasing : 
    """
def is_false(param: typing.SupportsFloat) -> bool:
    """
    Routine to translate from a real number to a boolian True or False.
    
    Translation: 0 = False, nonzero = True
    
    Parameters
    ----------
    param : float
        Real number to be translated
    
    Returns
    -------
    this_false : bool
        Set True if param is zero. False otherwise.
    
    Notes
    -----
    Related routines:
    is_true int_logic ) which is a real array. Some of the elements in the %value array are used to specify
    boolian attributes. For example quadrupoles use ele%value(scale_multipoles$).
    """
def is_increasing_sequence(array: RealAlloc1D, strict: bool | None = None, is_increasing: bool) -> PyIsIncreasingSequence:
    """
    No docstring available
    
    Parameters
    ----------
    array : float
        Sequence.
    strict : bool, optional
        If True (default) sequence must be strictly increasing.
    is_increasing : 
    """
def is_integer(string: str, int_: typing.SupportsInt | None = None, delims: str | None = None, ix_word: typing.SupportsInt | None = None, valid: bool) -> PyIsInteger:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    int : 
    delims : 
    ix_word : 
    valid : 
    """
def is_logical(string: str, ignore: bool | None = None, valid: bool) -> PyIsLogical:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    ignore : 
    valid : 
    """
def is_real(string: str, ignore: bool | None = None, real_num: typing.SupportsFloat | None = None, valid: bool) -> PyIsReal:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    ignore : 
    real_num : 
    valid : 
    """
def is_subatomic_species(species: typing.SupportsInt) -> bool:
    """
    Routine to return True if species argument corresponds to a subatomic particle.
    
    Parameters
    ----------
    species : int
        Spicies ID.
    
    Returns
    -------
    is_subatomic : bool
        Set True if species corresponds to a subatomic particle.
    """
def is_true(param: typing.SupportsFloat) -> bool:
    """
    Routine to translate from a real number to a boolian True or False.
    
    Translation: 0 = False, nonzero = True
    
    Parameters
    ----------
    param : float
        Real number to be translated
    
    Returns
    -------
    this_true : bool
        Set False if param is zero. True otherwise.
    
    Notes
    -----
    Related routines:
    is_false int_logic ) which is a real array. Some of the elements in the %value array are used to specify
    boolian attributes. For example quadrupoles use ele%value(scale_multipoles$).
    """
def j_bessel(m: typing.SupportsInt, arg: typing.SupportsFloat, j_bes: typing.SupportsFloat) -> PyJBessel:
    """
    No docstring available
    
    Parameters
    ----------
    m : 
    arg : 
    j_bes : 
    """
def key_name_to_key_index(key_str: str, abbrev_allowed: bool | None = None, key_index: typing.SupportsInt) -> PyKeyNameToKeyIndex:
    """
    No docstring available
    
    Parameters
    ----------
    key_str : unknown
        Name of the key. Result is case insensitive.
    abbrev_allowed : bool, optional
        Abbreviations (eg: "quad") allowed? Default is False. At least 3 characters are needed (except for
        rfcavity elements) if True.
    key_index : 
    """
def kick_vector_calc(ele: EleStruct, param: LatParamStruct, s_body: typing.SupportsFloat, orbit: CoordStruct, print_err: bool | None = None) -> PyKickVectorCalc:
    """
    Subroutine to calculate the dr/ds "kick vector" where
    
    r = [x, p_x, y, p_y, z, p_z, t, spin_x,y,z]
    the P0 at the exit end of the element.
    dr(1)/ds = dx/ds = dx/dt * dt/ds
    where:
    dx/dt = v_x = p_x / (1 + p_z)
    dt/ds = (1 + g*x) / v_s
    g = 1/rho, rho = bending radius (nonzero only in a dipole)
    dr(2)/ds = dp_x/ds = dP_x/dt * dt/ds / P0 + g_x * P_z
    where:
    dP_x/dt = EM_Force_x
    g_x = bending in x-plane.
    dr(3)/ds = dy/ds = dy/dt * dt/ds
    where:
    dy/dt = v_x
    dr(4)/ds = dp_y/ds = dP_y/dt * ds/dt / P0 + g_y * P_z
    where:
    dP_y/dt = EM_Force_y
    g_y = bending in y-plane.
    where:
    dt/ds(ref) = 1 / beta(ref)
    dr(6)/ds = dp_z/ds = d(EM_Force dot v_hat) * dt/ds / P0
    where:
    v_hat = velocity normalized to 1.
    dr(7)/ds = dt/ds
    dr(8:10)/ds = Spin omega vector
    dr(11)/ds = dt_ref/ds
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked thorugh.
    param : LatParamStruct
        Lattice parameters.
    s_rel : float
        Distance from the start of the element to the particle.
    orbit : CoordStruct
        Position of particle.
    local_ref_frame : !
        Logical, If True then take the input coordinates -- Logical, If True then take the input coordinates as
        being with respect to the frame of referene of the element.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    dr_ds : float
        Kick vector.
    field : EmFieldStruct
        Local field.
    err : bool
        Set True if there is an error.
    
    Notes
    -----
    Remember: In order to simplify the calculation, in the body of any element, P0 is taken to be
    NOTE: dr(5)/ds IS IGNORED WHEN CALCULATING Z. SEE TRANSFER_THIS_ORBIT ABOVE. dr(5)/ds = dz/ds = beta * c_light
    * [dt/ds(ref) - dt/ds] + dbeta/ds * c_light * [t(ref) - t] = beta * c_light * [dt/ds(ref) - dt/ds] + dbeta/ds
    * vec(5) / beta
    """
def kill_complex_taylor(complex_taylor: ComplexTaylorStructAlloc1D) -> None:
    """
    Subroutine to deallocate a Bmad complex_taylor map.
    
    Parameters
    ----------
    complex_taylor : ComplexTaylorStruct
        complex_taylor to be deallocated. It is OK if complex_taylor has already been deallocated.
        This parameter is an input/output and is modified in-place. As an output: deallocated complex_taylor
        structure.
    """
def kill_ptc_layouts(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Bmad lattice with associated layouts.
    """
def kill_taylor(bmad_taylor: TaylorStructAlloc1D) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    bmad_taylor : TaylorStruct
        Taylor to be deallocated.
        This parameter is an input/output and is modified in-place. As an output: deallocated Taylor structure.
    """
def kind_name(this_kind: typing.SupportsInt) -> str:
    """
    function to return the name of a PTC kind.
    
    Parameters
    ----------
    this_kind : int
        PTC kind
    
    Returns
    -------
    kind_str : unknown
        String representation
    """
def knot_interpolate(x_knot: RealAlloc1D, y_knot: RealAlloc1D, x_pt: typing.SupportsFloat, interpolation: typing.SupportsInt, y_pt: typing.SupportsFloat) -> PyKnotInterpolate:
    """
    No docstring available
    
    Parameters
    ----------
    x_knot : float
        Knot x-values.
    y_knot : float
        Knot y-values.
    x_pt : float
        Point to evaluate at.
    interpolation : int
        Interpolation type. cubic$ or linear$.
    err_flag : bool
        Set True if there is an error. False otherwise.
    y_pt : 
    """
def knots_to_string(x_knot: RealAlloc1D, y_knot: RealAlloc1D, str: str) -> PyKnotsToString:
    """
    No docstring available
    
    Parameters
    ----------
    x_knot : 
    y_knot : 
    str : 
    """
def lafun(x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat, res: typing.SupportsFloat) -> PyLafun:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    y : 
    z : 
    res : 
    """
def lat_compute_ref_energy_and_time(lat: LatStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Input lattice. .ele(0).value(E_tot$) -- Energy at the start of the lattice.
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def lat_ele_locator(loc_str: str, lat: LatStruct, eles: ElePointerStructAlloc1D, n_loc: typing.SupportsInt, above_ubound_is_err: bool | None = None, ix_dflt_branch: typing.SupportsInt | None = None, order_by_index: bool | None = None, append_eles: bool | None = None) -> PyLatEleLocator:
    """
    No docstring available
    
    Parameters
    ----------
    loc_str : unknown
        Element names or indexes. May be lower case.
    lat : LatStruct
        Lattice to search through.
    eles : ElePointerStruct
        If append_eles is True, save existing elements.
        This parameter is an input/output and is modified in-place. As an output: Array of matching elements.
    n_loc : int
        Number of existing elements. Used if append_eles is True.
        This parameter is an input/output and is modified in-place. As an output: Number of locations found.
    err : bool
        Set True if there is a decode error. Note: Not finding any matching element is not an error.
    above_ubound_is_err : bool, optional
        Default is True. If the upper bound "e2" on an "e1:e2" range construct -- logical, optional: Default is
        True. If the upper bound "e2" on an "e1:e2" range construct is an integer and above the maximum element
        index then treat this as an error? If False, treat e2 as the maximum element index.
    ix_dflt_branch : int, optional
        If present and not -1 then restrict search to specified branch. If not present or -1: Search all branches.
        Exception: For elements specified using an integer index (EG: "43"), if ix_dflt_branch is not present or
        -1 use branch 0.
    order_by_index : bool, optional
        False is default. If True, order a component of loc_str like "quad::*" by element index instead of
        longitudinal s-position. Index ordering and s-position ordering are different when there are super lords
        and super slaves.
    append_eles : bool, optional
        Default is False. If True, found elements are appended to eles(:) array.
    """
def lat_equal_lat(lat_in: LatStruct) -> LatStruct:
    """
    Subroutine that is used to set one lat equal to another.
    
    This routine takes care of the pointers in lat_in.
    
    Parameters
    ----------
    lat_in : LatStruct
        Input lat.
    
    Returns
    -------
    lat_out : LatStruct
        Output lat.
    """
def lat_geometry(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        The lattice. .ele(0).floor  -- Floor_position_struct: The starting point for the calculations.
    """
def lat_make_mat6(lat: LatStruct, ix_ele: typing.SupportsInt | None = None, ref_orb: _pybmad.CoordStructAlloc1D | None = None, ix_branch: typing.SupportsInt | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat containing the elements.
    ix_ele : int, optional
        Index of the element. If not present or negative, the matrices for all elements will be calculated.
    ref_orb : CoordStruct, optional
        Coordinates of the reference orbit around which the matrix is calculated. If not present then the
        referemce is taken to be the origin.
    ix_branch : int, optional
        Branch index. Default is 0 (main lattice). -1 => All branches/all elements (ref_orb & ix_ele will be
        ignored).
    err_flag : bool
        True if there is an error. False otherwise.
    """
def lat_sanity_check(lat: LatStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to check
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def lat_to_ptc_layout(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Input lattice lat.branch(:).ptc              -- Pointers to generated layouts.
        lat.branch(:).ele(:).ptc_fibre -- Pointer to PTC fibres
    """
def lat_vec_equal_lat_vec(lat2: LatStructAlloc1D) -> LatStructAlloc1D:
    """
    Subroutine that is used to set one lat vector equal to another.
    
    This routine takes care of the pointers in lat1.
    lat1(:) = lat2(:)
    
    Parameters
    ----------
    lat2 : LatStruct
        Input lat vector.
    
    Returns
    -------
    lat1 : LatStruct
        Output lat vector.
    
    Notes
    -----
    Note: This subroutine is called by the overloaded equal sign:
    """
def lattice_bookkeeper(lat: LatStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice needing bookkeeping.
        This parameter is an input/output and is modified in-place. As an output: Lattice with bookkeeping done.
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def lcavity_rf_step_setup(ele: EleStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lcavity element.
        This parameter is an input/output and is modified in-place. As an output: Element with ele.rf properly
        setup.
    """
def linear_bend_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orb: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Subroutine to track through the edge field of an sbend.
    
    Apply only the first order kick, which is edge focusing.
    
    Parameters
    ----------
    ele : EleStruct
        SBend element.
    param : LatParamStruct
        Rel charge.
    particle_at : int
        first_track_edge$, or second_track_edge$,
    orb : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
    mat6 : float, optional
        Transfer matrix up to the edge.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
        edge.
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    """
def linear_coef(stack: ExpressionAtomStructAlloc1D) -> ...:
    """
    Routine to return the linear coefficient of a linear expression.
    
    Parameters
    ----------
    stack : ExpressionAtomStruct
        Expression stack.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err_flag : bool
        Set True if the expression is not linear
    coef : float
        Linear coefficient.
    """
def linear_fit(x: RealAlloc1D, y: RealAlloc1D, n_data: typing.SupportsInt, a: typing.SupportsFloat, b: typing.SupportsFloat, sig_a: typing.SupportsFloat, sig_b: typing.SupportsFloat) -> PyLinearFit:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    y : 
    n_data : 
    a : 
    b : 
    sig_a : 
    sig_b : 
    """
def linear_fit_2d(x: RealAlloc1D, y: RealAlloc1D, z: RealAlloc1D) -> typing.Annotated[list[float], "FixedSize(3)"]:
    """
    No docstring available
    
    Parameters
    ----------
    x : float
        Array of x-values.
    y : float
        Array of y-values.
    z : float
        Array of z-values
    coef : float
        Coefficients of the linear fit
    """
def linear_to_spin_taylor(q_map: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(7)"]], "FixedSize(4)"]) -> TaylorStructArray1D:
    """
    No docstring available
    
    Parameters
    ----------
    q_map : float
        Linear quaternion map.
    spin_taylor : TaylorStruct
        Taylor map
    """
def load_parse_line(action: str, ix_start: typing.SupportsInt) -> ...:
    """
    Subroutine to load characters from the input file.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    
    Parameters
    ----------
    action : unknown
        'continue', 'new_command', or 'init'
    ix_start : int
        Index in bp_com.parse_line string where to append stuff.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    end_of_file : bool
        End of file reached?
    err_flag : bool
        Set True if there is an error. False otherwise bp_com.parse_line -- string to append to.
    """
def logic_str(logic: bool, str: str) -> PyLogicStr:
    """
    No docstring available
    
    Parameters
    ----------
    logic : 
    str : 
    """
def logical_to_python(logic: bool, string: str) -> PyLogicalToPython:
    """
    No docstring available
    
    Parameters
    ----------
    logic : 
    string : 
    """
def lord_edge_aligned(slave: EleStruct, slave_edge: typing.SupportsInt, lord: EleStruct, is_aligned: bool) -> PyLordEdgeAligned:
    """
    No docstring available
    
    Parameters
    ----------
    slave : EleStruct
        Slave element.
    slave_edge : int
        End under consideration: entrance_end$, exit_end$, in_between$, etc.
    lord : EleStruct
        Lord element.
    is_aligned : 
    """
def low_energy_z_correction(orbit: CoordStruct, ele: EleStruct, ds: typing.SupportsFloat, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None, dz: typing.SupportsFloat) -> PyLowEnergyZCorrection:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Position before correction
    ele : unknown
        Element being tracked through.
    ds : float
        Longitudinal distance traveled by reference particle.
    mat6 : float, optional
        Transfer matrix before the multipole.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        including multipole.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    dz : 
    """
def lunget() -> int:
    """
    No docstring available
    
    Parameters
    ----------
    lunget : 
    """
def mad_add_offsets_and_multipoles(ele: EleStruct) -> MadMapStruct:
    """
    Subroutine to add in the effect of element offsets and/or multipoles
    
    on the 2nd order transport map for the element.
    
    Parameters
    ----------
    ele : EleStruct
        Drift element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_concat_map2(map1: MadMapStruct, map2: MadMapStruct) -> MadMapStruct:
    """
    Subroutine to concatinate two 2nd order transport maps.
    
    map3 = map2(map1)
    The equivalent MAD-8 routine is: TMCAT1
    
    Parameters
    ----------
    map1 : MadMapStruct
        First map in the beam line.
    map2 : MadMapStruct
        Second map in the beam line.
    
    Returns
    -------
    map3 : MadMapStruct
        Concatinated map.
    """
def mad_drift(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for a drift space.
    
    The equivalent MAD-8 routine is: TMDRF
    
    Parameters
    ----------
    ele : EleStruct
        Drift element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_elsep(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for an electric separator.
    
    The equivalent MAD-8 routine is: TMSEP
    
    Parameters
    ----------
    ele : EleStruct
        Electric seperator element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_map_to_taylor(map: MadMapStruct, energy: MadEnergyStruct) -> TaylorStructAlloc1D:
    """
    Subroutine to convert a MAD order 2 map to a Bmad taylor map.
    
    The conversion will also convert between MAD's (t, dE) and Bmad's (beta*t, dP) coords.
    
    Parameters
    ----------
    map : MadMapStruct
        Order 2 map.
    energy : MadEnergyStruct
        Energy numbers.
    
    Returns
    -------
    taylor : TaylorStruct
        Taylor map.
    """
def mad_quadrupole(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for an quadrupole element.
    
    The equivalent MAD-8 routine is: TMSEXT
    
    Parameters
    ----------
    ele : EleStruct
        Quadrupole element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_rfcavity(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for an rfcavity element.
    
    The equivalent MAD-8 routine is: TMRF
    
    Parameters
    ----------
    ele : EleStruct
        Rfcavity element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_sbend(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for a sector bend element.
    
    The equivalent MAD-8 routine is: TMBEND
    
    Parameters
    ----------
    ele : EleStruct
        Sbend element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_sbend_body(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for the body of a sector dipole.
    
    The equivalent MAD-8 routine is: TMSECT
    
    Parameters
    ----------
    ele : EleStruct
        Solenoid element.
    energy : MadEnergyStruct
        particle energy structure.
    into : bool
        If True then map is for particle entering a dipole
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_sbend_fringe(ele: EleStruct, energy: MadEnergyStruct, into: bool) -> MadMapStruct:
    """
    Subroutine to make a transport map for the fringe field of a dipole.
    
    The equivalent MAD-8 routine is: TMFRNG
    
    Parameters
    ----------
    ele : EleStruct
        Solenoid element.
    energy : MadEnergyStruct
        particle energy structure.
    into : bool
        If True then map is for particle entering a dipole
    
    Returns
    -------
    map : MadMapStruct
        Fringe dipole map. .k(6)     -- 0th order map. .r(6,6)   -- 1st order map. .t(6,6,6) -- 2nd order map.
    """
def mad_sextupole(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for an sextupole.
    
    The equivalent MAD-8 routine is: TMSEXT
    
    Parameters
    ----------
    ele : EleStruct
        Sextupole element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_solenoid(ele: EleStruct, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to make a transport map for an solenoid.
    
    The equivalent MAD-8 routine is: TMSEXT
    
    Parameters
    ----------
    ele : EleStruct
        Solenoid element.
    energy : MadEnergyStruct
        particle energy structure.
    
    Returns
    -------
    map : MadMapStruct
        Structure holding the transfer map.
    """
def mad_tmfoc(el: typing.SupportsFloat, sk1: typing.SupportsFloat) -> ...:
    """
    Subroutine to compute the linear focussing functions.
    
    The equivalent MAD-8 routine is: TMFOC
    
    Parameters
    ----------
    el : float
        Length.
    sk1 : float
        Quadrupole strength.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    c : float
        Cosine-like function.             c(k,l)
    s : float
        Sine-like function.               s(k,l)
    d : float
        Dispersion function.              d(k,l)
    f : float
        Integral of dispersion function.  f(k,l)
    """
def mad_tmsymm(te: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]], "FixedSize(6)"]) -> None:
    """
    subroutine to symmertrize the 2nd order map t.
    
    The equivalent MAD-8 routine is: tmsymm
    
    Parameters
    ----------
    te : float
        array to be symmertrized.
        This parameter is an input/output and is modified in-place. As an output: symmetrized array.
    """
def mad_tmtilt(map: MadMapStruct, tilt: typing.SupportsFloat) -> None:
    """
    Subroutine to apply a tilt to a transport map.
    
    The equivalent MAD-8 routine is: TMTILT
    
    Parameters
    ----------
    map : MadMapStruct
        Unrotated transport map. .k(6)     -- 0th order map. .r(6,6)   -- 1st order map. .t(6,6,6) -- 2nd order
        map.
        This parameter is an input/output and is modified in-place. As an output: Rotated transport map.
    tilt : float
        Tilt
    """
def mad_track1(c0: CoordStruct, map: MadMapStruct) -> CoordStruct:
    """
    Subroutine to track through a 2nd order transfer map.
    
    The equivalent MAD-8 routine is: TMTRAK
    
    Parameters
    ----------
    c0 : CoordStruct
        Starting coords.
    map : MadMapStruct
        2nd order map.
    
    Returns
    -------
    c1 : CoordStruct
        Ending coords.
    """
def make_g2_mats(twiss: TwissStruct, g2_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]], "FixedSize(2)"], g2_inv_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]], "FixedSize(2)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    twiss : TwissStruct
        Twiss parameters.
    g2_mat : 
    g2_inv_mat : 
    """
def make_g_mats(ele: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    g_mat : float
        Normal mode to betaless coords
    g_inv_mat : float
        The inverse of G_MAT
    """
def make_hvbp(N: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    Parameterizes the eigen-decomposition of the 6x6 transfer matrix into HVBP as defined in:
    
    "From the beam-envelop matrix to synchrotron-radiation integrals" by Ohmi, Hirata, and Oide.
    This routine takes N, which is usually made from make_N (also in this module), and decomposes
    it into H, V, B, and P.
    N is defined by:
    M = N.U.Inverse[N] where U is block diagonal and the blocks are 2x2 rotation matrices.
    and it is decomposed by this subroutine as,
    N = H.V.B.P
    P has the same free parameters as B
    B "Twiss matrix" has 6 free parameters (Twiss alphas and betas)
    B blocks have the form /     sqrt(beta)         0       \\
    \\ -alpha/sqrt(beta) 1/sqrt(beta) /
    V "Teng matrix" has 4 free parameters (xy, xpy, ypx, and pxpy coupling)
    H "Dispersion matrix" has 8 free parameters (xz, xpz, pxz, pxpz, yz, ypz, pyz, pypz coupling)
    
    Parameters
    ----------
    N : float
        Matrix of eigenvectors prepared by make_N
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    B : float
        Block diagonal matrix of Twiss parameters
    V : float
        horizontal-vertical coupling information
    H : float
        horizontal-longitudinal and vertical-longitudinal coupling information
    Vbar : float
        mat_symp_conj(B).V.B
    Hbar : float
        mat_symp_conj(B).H.B
    """
def make_hybrid_lat(lat_in: LatStruct, use_taylor: bool | None = None, orb0_arr: _pybmad.CoordArrayStructAlloc1D | None = None) -> LatStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat_in : LatStruct
        Input lattice. .branch(:).ele(:).select  -- Roughly: Set True to keep and False to hybridize. See above.
    lat_out : LatStruct
        Lattice with hybrid elements. Note: Lat_out must not be the same actual argument as lat_in.
    use_taylor : bool, optional
        If present and True then the hybrid elements will have a taylor series instead of a simple linear matrix.
        If an element to be concatenated has a taylor series then this taylor series will be concatenated with the
        other elements in the hybrid element.
    orb0_arr : CoordArrayStruct, optional
        Central orbit for taylor stuff. Each orb0_arr(i).orbit(:) holds the orbit for the i^th lattice branch
    """
def make_legal_comment(comment_in: str, comment_out: str) -> PyMakeLegalComment:
    """
    No docstring available
    
    Parameters
    ----------
    comment_in : 
    comment_out : 
    """
def make_mad_map(ele: EleStruct, param: LatParamStruct) -> ...:
    """
    Subroutine to make a 2nd order transport map a la MAD.
    
    Parameters
    ----------
    ele : EleStruct
        Element
    param : LatParamStruct
        particle id
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    energy : MadEnergyStruct
        Energy of the particle
    map : MadMapStruct
        Structure holding the transfer map.
    """
def make_mat6(ele: EleStruct, param: LatParamStruct, start_orb: _pybmad.CoordStruct | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element holding the transfer matrix.
    param : LatParamStruct
        Lattice global parameters.
    start_orb : CoordStruct, optional
        Reference coordinates at the beginning of element. If not present, default is to use the zero orbit.
    end_orb : CoordStruct
        Reference coordinates at the end of element.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def make_mat6_bmad(ele: EleStruct, param: LatParamStruct, start_orb: CoordStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to track through.
        This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
    param : LatParamStruct
        Parameters are needed for some elements.
    start_orb : CoordStruct
        Starting coords.
    end_orb : CoordStruct
        Coordinates at the end of element.
    err : bool
        Set True if there is an error. False otherwise.
    """
def make_mat6_bmad_photon(ele: EleStruct, param: LatParamStruct, start_orb: CoordStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with transfer matrix
        This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
    param : LatParamStruct
        Parameters are needed for some elements.
    start_orb : CoordStruct
        Coordinates at the beginning of element.
    end_orb : CoordStruct
        Coordinates at the end of element.
    err : bool
        Set True if there is an error. False otherwise.
    """
def make_mat6_high_energy_space_charge(ele: EleStruct, param: LatParamStruct) -> None:
    """
    Routine to add the ultra relativistic space charge kick to the element transfer matrix.
    
    The routine setup_space_charge_calc must be called
    initially before any tracking is done. This routine assumes a Gaussian
    bunch and is only valid with relativistic particles where the effect
    of the space charge is small.
    
    Parameters
    ----------
    ele : EleStruct
        Element tracked through.
    param : LatParamStruct
    
    Returns
    -------
    end : CoordStruct
        End position
    """
def make_mat6_mad(ele: EleStruct, param: LatParamStruct, c0: CoordStruct) -> CoordStruct:
    """
    Subroutine to make the 6x6 transfer matrix for an element from the
    
    2nd order MAD transport map. The map is stored in ele%taylor.
    If the map exists then it is simply used to calculate ele%mat6.
    If ele%taylor doesn't exist then calculate it.
    
    Parameters
    ----------
    ele : EleStruct
        Element with transfer matrix.
    param : LatParamStruct
        Lattice parameters.
    map : MadMapStruct
        2nd order map.
    c0 : CoordStruct
        Coordinates at the beginning of element.
    
    Returns
    -------
    c1 : CoordStruct
        Coordinates at the end of element.
    """
def make_mat6_symp_lie_ptc(ele: EleStruct, start_orb: CoordStruct) -> CoordStruct:
    """
    import
    
    implicit none
    type (ele_struct), target :: ele
    type (coord_struct) :: start_orb, end_orb
    type (lat_param_struct) param
    end subroutine
    
    Parameters
    ----------
    ele : EleStruct
        Element with transfer matrix
        This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
    start_orb : CoordStruct
        Coordinates at the beginning of element.
    
    Returns
    -------
    end_orb : CoordStruct
        Coordinates at end of element.
    """
def make_mat6_taylor(ele: EleStruct, start_orb: CoordStruct, err_flag: bool | None = None) -> PyMakeMat6Taylor:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to track through.
        This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
    start_orb : CoordStruct
        Starting coords.
    end_orb : CoordStruct
        Coordinates at the end of element.
    err_flag : 
    """
def make_mat6_tracking(ele: EleStruct, param: LatParamStruct, start_orb: CoordStruct, spin_only: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with transfer matrix
        This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
    param : LatParamStruct
        Parameters are needed for some elements.
    start_orb : CoordStruct
        Coordinates at the beginning of element.
    end_orb : CoordStruct
        Coordinates at the end of element.
    err_flag : bool
        Set True if there is an error. False otherwise.
    spin_only : bool, optional
        Default False. If True, only calculate ele.spin_taylor.
    """
def make_n(t6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], abz_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None) -> ...:
    """
    Given a 1-turn transfer matrix, this returns the matrix N.
    
    N converts between normal invarients and phases and canonical coordinates:
    X = N.J
    N is obtained from the Eigen decomposition of the 1-turn transfer matrix.
    It is obtained by applying certain normalizations to the matrix of Eigen vectors, then making
    the result real using Q.
    If abz_tunes is present, then the eigensystem is ordered by matching the tunes.
    If abz_tunes is not present, then the eigensystem is ordered by plane dominance.
    It is assumed that the synchrotron tune is less than pi.
    
    Parameters
    ----------
    t6 : float
        1-turn transfer matrix
    abz_tunes : float, optional
        a-mode is abz_tunes(1), b-mode is abz_tunes(2), synch tune is abz_tunes(3)
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    N : float
        X = N.J
    err_flag : bool
        Set to true on error.  Often means Eigen decomposition failed.
    tunes_out : float
        Fractional tune (in radians) of the 3 normal modes of t6.
    U : float
        U = Inverse(N).t6.N.  Block diagonal matrix of 2x2 rotation matrices.
    """
def make_pbrh(M: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], abz_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> ...:
    """
    Decomposes the 1-turn transfer matrix into normal mode twiss-like parameters,
    
    according to Sec. IIIB of Ohmi, Hirata, and Oide paper.
    
    Parameters
    ----------
    M : float
        1-turn transfer matrix
    abz_tunes : float
        tunes for a,b, and c modes.  Used to identify which eigenvector is associated with which mode.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    P : complex
        Eqn. 97.  Phase advances.
    Bp : complex
        Eqns. 89 & 101.  Beta functions.
    R : complex
        Eqn. 99.  Transverse coupling.
    H : complex
        Eqn. 100.  Longitudinal coupling.
    """
def make_smat_from_abc(t6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], mode: NormalModesStruct) -> ...:
    """
    Given the 1-turn transfer matrix and a normal_modes_struct containing the normal mode
    
    emittances, this routine returns the beam envelop sigma matrix.
    sigma_mat = N.D.transpose(N)
    equivalent to: sigma_mat.S = N.D.mat_symp_conj(N)
    One way to populate mode%a%tune and mode%b%tune:
    mode%a%tune = mod(lat%ele(lat%n_ele_track)%a%phi, twopi)
    mode%b%tune = mod(lat%ele(lat%n_ele_track)%b%phi, twopi)
    
    Parameters
    ----------
    t6 : float
        1-turn transfer matrix
    mode : NormalModesStruct
        normal mode emittances .a.emittance -- real(rp): a-mode emittance .b.emittance -- real(rp): b-mode
        emittance .z.emittance -- real(rp): z-mode emittance .a.tune      -- real(rp): a-mode tune.  Used to
        associate emittances with the proper mode. .b.tune      -- real(rp): b-mode tune.  Used to associate
        emittances with the proper mode. .z.tune      -- real(rp): z-mode tune.  Used to associate emittances with
        the proper mode.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    sigma_mat : float
        beam envelop sigma matrix
    err_flag : bool
        set to true if something goes wrong.  Usually means Eigen decomposition of the 1-turn matrix failed.
    Nout : float
        Contains the normalized eigenvectors that were used to make the sigma matrix.
    """
def make_unit_mad_map(map: MadMapStruct) -> None:
    """
    Subroutine to initialize a 2nd order transport map to unity.
    
    Parameters
    ----------
    map : MadMapStruct
        2nd order transport map.
        This parameter is an input/output and is modified in-place. As an output: Unity 2nd order map.
    """
def make_v(M: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], V: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], abz_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
    """
    For a one-turn transfer matrix M, this routine find the eigen matrix V.
    
    V is ordered such that the per turn phase advance of its column pairs agree with abz_tunes.
    It is normalized to be symplectic.
    """
def make_v_mats(ele: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    v_mat : float
        Normal mode to X-Y coords transformation
    v_inv_mat : float
        X-Y coords to Normal mode transformation
    """
def makeup_control_slave(lat: LatStruct, slave: EleStruct, err_flag: bool) -> PyMakeupControlSlave:
    """
    This routine is not meant for general use.
    """
def makeup_group_lord(lat: LatStruct, lord: EleStruct, err_flag: bool) -> PyMakeupGroupLord:
    """
    Subroutine to calculate the attributes of group slave elements.
    
    This routine is private to bookkeeper_mod.
    """
def makeup_multipass_slave(lat: LatStruct, slave: EleStruct, err_flag: bool) -> PyMakeupMultipassSlave:
    """
    Subroutine to calcualte the attributes of multipass slave elements.
    
    This routine is not meant for guse.
    """
def makeup_super_slave(lat: LatStruct, slave: EleStruct, err_flag: bool) -> PyMakeupSuperSlave:
    """
    Subroutine to calcualte the attributes of superposition slave elements.
    
    This routine is not meant for general use.
    """
def makeup_super_slave1(slave: EleStruct, lord: EleStruct, offset: typing.SupportsFloat, param: LatParamStruct, include_upstream_end: bool, include_downstream_end: bool) -> bool:
    """
    Routine to construct a super_slave from a super_lord when the slave has only one lord.
    
    Parameters
    ----------
    slave : EleStruct
        Slave element.
        This parameter is an input/output and is modified in-place. As an output: Slave element with appropriate
        values set.
    lord : EleStruct
        Lord element.
    offset : float
        offset of entrance end of slave from entrance end of the lord.
    param : LatParamStruct
        lattice paramters.
    include_upstream_end : bool
        Slave contains the lord's entrance end?
    include_downstream_end : bool
        Slave contains the lord's exit end?
    
    Returns
    -------
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def map1_inverse(map1: SpinOrbitMap1Struct, inv_map1: SpinOrbitMap1Struct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    map1 : SpinOrbitMap1Struct
        Input map.
    inv_map1 : 
    """
def map1_make_unit() -> SpinOrbitMap1Struct:
    """
    No docstring available
    
    Parameters
    ----------
    map1 : SpinOrbitMap1Struct
        Unit map.
    """
def map1_times_map1(map2: SpinOrbitMap1Struct, map1: SpinOrbitMap1Struct) -> SpinOrbitMap1Struct:
    """
    Routine to concatenate two spin orbital linear maps.
    
    map_out = map2(map1)
    Order is like applying matrices. map1 is before map2.
    
    Parameters
    ----------
    map2 : SpinOrbitMap1Struct
        Second map.
    map1 : SpinOrbitMap1Struct
        First map.
    
    Returns
    -------
    map_out : SpinOrbitMap1Struct
        Concatenated map.
    """
def map_to_angle_coords(t_canon: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"]) -> TaylorStructArray1D:
    """
    No docstring available
    
    Parameters
    ----------
    t_canon : TaylorStruct
        Taylor map in canonical coords.
    t_angle : TaylorStruct
        Taylor map in angle coords.
    """
def mark_patch_regions(branch: BranchStruct) -> None:
    """
    Routine to mark which regions in a wall3d structure contain patch elements.
    
    This routine should be called by any routine that creates a beam chamber wall.
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch with .wall3d beam chamber wall.
        This parameter is an input/output and is modified in-place. As an output: Lattice branch with
        .wall3d.section(i).patch_in_region marked.
    """
def mass_of(species: typing.SupportsInt) -> float:
    """
    Routine to return the mass, in units of eV/c^2, of a particle.
    
    To convert to AMU divide mass_of value by the constant atomic_mass_unit.
    binding energy effects. Exception: For #1H+ (proton) and #2H+ (deuteron) the exact mass is used since it is known.
    
    Parameters
    ----------
    species : int
        Species ID.
    
    Returns
    -------
    mass : float
        particle mass. Set to real_garbage$ if species value is invalid.
    
    Notes
    -----
    Note: For atoms where the isotopic number is given, the mass is calculated using the neutral atomic mass
    adjusted by the weight of any added or missing electrons. The calculated mass is off very slightly due to
    """
def master_parameter_value(master_parameter: typing.SupportsInt, ele: EleStruct, value: typing.SupportsFloat) -> PyMasterParameterValue:
    """
    No docstring available
    
    Parameters
    ----------
    master_parameter : int
        Index of the master parameter.
    ele : EleStruct
        Element containing the fieldmap.
    value : 
    """
def mat4_multipole(knl: typing.SupportsFloat, tilt: typing.SupportsFloat, n: typing.SupportsInt, orbit: CoordStruct) -> PyMat4Multipole:
    """
    No docstring available
    
    Parameters
    ----------
    knl : float
        Strength of multipole
    tilt : float
        Tilt of multipole
    n : 
    orbit : CoordStruct
        coordinates of particle
    kick_mat : float
        Kick matrix (Jacobian) at orbit.
    """
def mat6_add_offsets(ele: EleStruct, param: LatParamStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with given orientation. .vec0(6)         -- 0th order part of the transfer map. .mat6(6,6)
        -- 1st order part of the transfer map (Jacobian). .map_ref_orb_in  -- Reference orbit at entrance end.
        .map_ref_orb_out -- Reference orbit at exit end. .value(x_offset$), .value(x_pitch$), .value(tilt$), etc.
        -- Offsets, tilts, and pitches
    param : LatParamStruct
    """
def mat6_add_pitch(x_pitch_tot: typing.SupportsFloat, y_pitch_tot: typing.SupportsFloat, orientation: typing.SupportsInt, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    x_pitch_tot : float
        Horizontal pitch
    y_pitch_tot : float
        Vertical pitch
    orientation : int
        Element longitudinal orientation. +1 or -1.
    mat6 : float
        1st order part of the transfer map (Jacobian).
        This parameter is an input/output and is modified in-place. As an output: 1st order xfer map with pitches.
    """
def mat6_to_complex_taylor(vec0: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"], mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"]) -> ComplexTaylorStructArray1D:
    """
    Subroutine to form a first order complex_taylor map from the 6x6 transfer
    
    matrix and the 0th order transfer vector.
    
    Parameters
    ----------
    vec0 : 
        0th order transfer vector.
    mat6 : 
        6x6 transfer matrix.
    
    Returns
    -------
    complex_taylor : ComplexTaylorStruct
        first order complex_taylor map.
    """
def mat_symp_decouple(t0: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]], "FixedSize(4)"], U: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]], "FixedSize(4)"], V: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]], "FixedSize(4)"], Ubar: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]], "FixedSize(4)"], Vbar: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]], "FixedSize(4)"], G: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]], "FixedSize(4)"], type_out: bool) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    t0 : float
        Input matrix
    stat : int
        status of results: ok$, in_stop_band$, or unstable$
    U : 
    V : 
    Ubar : 
    Vbar : 
    G : 
    twiss1 : TwissStruct
        Twiss params for the "upper left" mode. .phi     -- Rotation angle in radians, 0 < .PHI < twopi
    twiss2 : TwissStruct
        Twiss params for the "lower right" mode. u(4,4), v(4,4), ubar(4,4), vbar(4,4), g(4,4) -- Real(rp): See MGB
        CBN 85-2 and PPB/DLR PAC89 papers for more info.
    gamma : float
        gamma_c factor.
    type_out : bool
        If .true. then an error message is typed out for a non ok$ STAT
    """
def match_ele_to_mat6(ele: EleStruct, start_orb: CoordStruct, include_delta_time: bool | None = None, set_trombone: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Match element.
    start_orb : CoordStruct
        Starting orbit.
    mat6 : float
        Transfer matrix (1st order part of xfer map).
    vec0 : float
        0th order part of the transfer map.
    err_flag : bool
        Set true if there is an error. False otherwise.
    include_delta_time : bool, optional
        If False, ignore any finite ele.value(delta_time$). Default is True.
    set_trombone : bool, optional
        Default is False. If True, set the beginning and ending Twiss values in the element to create a phase
        trombone.
    """
def match_reg(str: str, pat: str, is_match: bool) -> PyMatchReg:
    """
    No docstring available
    
    Parameters
    ----------
    str : 
    pat : 
    is_match : 
    """
def match_wild(string: str, template_: str, is_match: bool) -> PyMatchWild:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    template : 
    is_match : 
    """
def maximize_projection(seed: typing.SupportsFloat, cdata: ComplexAlloc1D, func_retval__: typing.SupportsFloat) -> PyMaximizeProjection:
    """
    Optimizer that uses Numerical Recipes brent to find a local maximum,
    
    which is the frequency that maximizes the projection.
    """
def mexp(x: typing.SupportsFloat, m: typing.SupportsInt, this_exp: typing.SupportsFloat) -> PyMexp:
    """
    No docstring available
    
    Parameters
    ----------
    x : float
        Number.
    m : int
        Exponent.
    this_exp : 
    """
def mfft1(a: RealAlloc1D, b: RealAlloc1D, n: IntAlloc1D, ndim: typing.SupportsInt, isn: typing.SupportsInt) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    a : 
    b : 
    n : 
    ndim : 
    isn : 
    ierr : 
    """
def milli_sleep(milli_sec: typing.SupportsInt) -> PyMilliSleep:
    """
    No docstring available
    
    Parameters
    ----------
    milli_sec : 
    """
def momentum_compaction(branch: BranchStruct, mom_comp: typing.SupportsFloat) -> PyMomentumCompaction:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch to calculate on.
    mom_comp : 
    """
def multi_turn_tracking_analysis(track: CoordStructAlloc1D, i_dim: typing.SupportsInt) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    track : CooordStruct
        multi-turn tracking data to analyze. track(i) is the particle position at a given point in the lat on the
        i^th turn.
    i_dim : int
        number of dimensions used in the tracking: 2, or 4.
    track0 : CoordStruct
        Closed orbit.
    ele : EleStruct
        structure holding the 1-turn matrix and Twiss parameters. .mat6        -- Symplectified 1-turn matrix. If
        you want the true non-symplectified 1-turn matrix use the routine multi_turn_tracking_to_mat. .a.beta, etc
        -- a-mode beta,  etc. .a.phi       -- a-mode fractional tune in radians. .a.sigma     -- a-mode amplitude
        = sqrt(ele.a.beta * ele.a.sigma) .c_mat       -- c coupling matrix (only with i_dim = 4)
    stable : bool
        Is motion stable?
    growth_rate : float
        Unstable growth rate (= 0 if stable).
    chi : float
        How symplectic the computed 1-turn matrix is. See mat_symp_check for more details.
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def multilayer_type_to_multilayer_params(ele: EleStruct) -> bool:
    """
    Routine to set the multilayer parameters based upon the multilayer type.
    
    Multilayer types are of the form:
    "AAA:BBB"
    Where "AAA" is the atomic formula for the top layer crystal and "BBB" is the second layer atomic formula.
    
    Parameters
    ----------
    ele : EleStruct
        Multilayer element. .component_name -- Character: Multilayer type name. Assumed upper case. A blank name
        is not an error and results in nothing set. .value(e_tot$)  -- Photon energy in eV.
    
    Returns
    -------
    err_flag : bool
        Set True if multilayer type is unrecognized. False otherwise.
    """
def multipass_chain(ele: EleStruct, ix_pass: typing.SupportsInt, n_links: typing.SupportsInt, chain_ele: _pybmad.ElePointerStructAlloc1D | None = None, use_super_lord: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : ElePointerStruct
        Element in a multipass chain.
    ix_pass : int
        Multipass pass number of the input element. Set to -1 if input element is not in a multipass section.
    n_links : int
        Number of times the physical element is passed through.
    chain_ele : ElePointerStruct, optional
        pointers to the elements of the chain. Note: chain_ele(ix_pass).ele => ele
    use_super_lord : bool, optional
        If present and True and if ele is a super_slave, construct the chain_ele(:) array using the corresponding
        super_lords. Output
    """
def multipole1_ab_to_kt(an: typing.SupportsFloat, bn: typing.SupportsFloat, n: typing.SupportsInt) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    an : float
        Skew multipole component.
    bn : float
        Normal multipole component.
    n : int
        Order of multipole.
    knl : float
        Multitude magnatude.
    tn : float
        Multipole angle.
    """
def multipole1_kt_to_ab(knl: typing.SupportsFloat, knsl: typing.SupportsFloat, tn: typing.SupportsFloat, n: typing.SupportsInt) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    knl : float
        Normal multitude component.
    knsl : float
        Skew multitude component.
    tn : float
        Multipole angle.
    n : int
        Multipole order.
    an : float
        Skew multipole component.
    bn : float
        Normal multipole component.
    """
def multipole_ab_to_kt(an: RealAlloc1D, bn: RealAlloc1D) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    an : float
        Skew multipole component.
    bn : float
        Normal multipole component.
    knl : float
        Multitude magnatude.
    tn : float
        Multipole angle.
    """
def multipole_ele_to_ab(ele: EleStruct, use_ele_tilt: bool, pole_type: typing.SupportsInt | None = None, include_kicks: typing.SupportsInt | None = None, original: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element. .value()      -- ab_multipole values.
    use_ele_tilt : bool
        If True then include ele.value(tilt_tot$) in calculations. use_ele_tilt is ignored in the case of
        multipole$ elements.
    ix_pole_max : int
        Index of largest nonzero a(:) or b(:) pole. Set to -1 if all multipoles are zero. ix_pole_max is set
        independent of a nonzero b1 (if present).
    a : float
        Array of multipole values.
    b : float
        Array of multipole values.
    pole_type : int, optional
        Type of multipole. magnetic$ (default) or electric$.
    include_kicks : int, optional
        Ignored for for pole_type == electric$ for non-elseparator elements. Possibilities are: no$
        -- Default. Do not include any kick components in a and b multipoles. include_kicks$           -- Include
        hkick/vkick/dg in the n = 0 components. Also included are quad k1, sextupole k2 and octupole k3
        components.
    b1 : float
        If present, b1 is set to the value of the b(1) component of the b(:) array and b(1) is set to zero. Also
        ix_pole_max is ajusted as needed. This is used by routines that want to handle b(1) in a special way in
        tracking.
    original : bool, optional
        Default is false. If True, no scaling is applied.
    """
def multipole_ele_to_kt(ele: EleStruct, use_ele_tilt: bool, pole_type: typing.SupportsInt | None = None, include_kicks: typing.SupportsInt | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    use_ele_tilt : bool
        If True then include ele.value(tilt_tot$) in calculations. use_ele_tilt is ignored in the case of
        multipole$ elements.
    ix_pole_max : int
        Index of largest nonzero pole.
    knl : float
        Vector of strengths, MAD units.
    tilt : float
        Vector of tilts.
    pole_type : int, optional
        Type of multipole. magnetic$ (default) or electric$.
    include_kicks : int, optional
        Possibilities are: no$                      -- Default. Do not include any kick components in a and b
        multipoles. include_kicks$           -- Include hkick/vkick/dg in the n = 0 components. Also included are
        quad k1, sextupole k2 and octupole k3 components.
    """
def multipole_init(who: typing.SupportsInt, zero: bool | None = None) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element holding the multipoles. .a_pole(0:n_pole_maxx) -- Multipole An array .b_pole(0:n_pole_maxx) --
        Multipole Bn array
    who : int
        electric$, magnetic$, or all$
    zero : bool, optional
        If present and True then zero the arrays even if they already exist when this routine is called. Default
        is False which means that if the arrays already exist then this routine will do nothing.
    """
def multipole_kick(knl: typing.SupportsFloat, tilt: typing.SupportsFloat, n: typing.SupportsInt, ref_species: typing.SupportsInt, ele_orientation: typing.SupportsInt, coord: CoordStruct, pole_type: typing.SupportsInt | None = None, ref_orb_offset: bool | None = None) -> None:
    """
    Subroutine to put in the kick due to a multipole.
    
    Parameters
    ----------
    knl : float
        Multipole integrated strength.
    tilt : float
        Multipole tilt.
    n : float
        Multipole order.
    ref_species : int
        Reference species.
    ele_orientation : int
        Element orientation +1 = normal, -1 = reversed.
    coord : CoordStruct
        Particle position and direction of travel.
    pole_type : int, optional
        Type of multipole. magnetic$ (default) or electric$.
    ref_orb_offset : bool, optional
        If True and n = 0 then use the MAD convention and model the multipole as a zero length bend with bending
        angle knl. Default is False.
    """
def multipole_kick_mat(knl: RealAlloc1D, tilt: RealAlloc1D, ref_species: typing.SupportsInt, ele: EleStruct, orbit: CoordStruct, factor: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    knl : float
        Strength of multipoles
    tilt : float
        Tilt of multipoles
    ref_species : int
        Reference species.
    ele : EleStruct
        Lattice element containing multipoles.
    orbit : CoordStruct
        coordinates of particle around which the multipole kick matrix is computed.
    factor : float
        Factor to scale knl by.
    mat6 : float
        matrix with kick values at mat6(2:4:2, 1:3:2). The rest of the matrix is untouched.
    """
def multipole_kicks(knl: RealAlloc1D, tilt: RealAlloc1D, ele: EleStruct, orbit: CoordStruct, pole_type: typing.SupportsInt | None = None, ref_orb_offset: bool | None = None) -> None:
    """
    Subroutine to put in the kick due to a multipole element.
    
    Also see the ab_multipole_kicks routine.
    
    Parameters
    ----------
    knl : float
        Multipole strengths.
    tilt : float
        Multipole tilts.
    ele : EleStruct
        Lattice element containing the multipoles.
    orbit : CoordStruct
        Particle position.
        This parameter is an input/output and is modified in-place. As an output: Kicked particle.
    pole_type : int, optional
        Type of multipole. magnetic$ (default) or electric$.
    ref_orb_offset : bool, optional
        If present and n = 0 then the multipole simulates a zero length bend with bending angle knl.
    """
def multipole_kt_to_ab(knl: RealAlloc1D, knsl: RealAlloc1D, tn: RealAlloc1D) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    knl : float
        Normal multitude component.
    knsl : float
        Skew multitude component.
    tn : float
        Multipole angle.
    an : float
        Skew multipole component.
    bn : float
        Normal multipole component.
    """
def multipole_spin_tracking(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    param : 
        Lat_param_struct
    orbit : CoordStruct
        Particle coordinates.
    """
def mytan(y: typing.SupportsFloat, x: typing.SupportsFloat, arg: typing.SupportsFloat) -> PyMytan:
    """
    No docstring available
    
    Parameters
    ----------
    y : 
    x : 
    arg : 
    """
def n_attrib_string_max_len() -> int:
    """
    Routine to return the the maximum number of characters in any attribute
    
    name known to bmad.
    
    
    Returns
    -------
    max_len : int
        Maximum number of characters in any attribute name.
    """
def n_bins_automatic(n_data: typing.SupportsInt, n: typing.SupportsInt) -> PyNBinsAutomatic:
    ...
def n_choose_k(n: typing.SupportsInt, k: typing.SupportsInt, nck: typing.SupportsFloat) -> PyNChooseK:
    """
    No docstring available
    
    Parameters
    ----------
    n : 
    k : 
    nck : 
    """
def n_spline_create(deriv0: RealAlloc1D, deriv1: RealAlloc1D, x1: typing.SupportsFloat) -> RealAlloc1D:
    """
    No docstring available
    
    Parameters
    ----------
    deriv0 : float
        Derivative vector from order 0 to some order n at x = 0.
    deriv1 : float
        Derivative vector from order 0 to some order n at x = x1.
    x1 : float
        Location where deriv1 derivatives have been evaluated.
    n_spline : 
        real(rp), Derivative vector from order 0 to order 2*n+1 of the interpolation spline.
    """
def naff(cdata: ComplexAlloc1D, freqs: RealAlloc1D, amps: ComplexAlloc1D, opt_dump_spectra: typing.SupportsInt | None = None, opt_zero_first: bool | None = None) -> PyNaff:
    """
    This subroutine implements the NAFF algorithm for calculating the spectra
    
    of periodic data.
    See naff_mod documentation for details.
    Frequencies returned are in units of 2pi. That is, freqs ranges from 0 to 1.
    freqs and amps must be allocated before hand.  This subroutine will repeat the
    decomposition loop until all elements of freqs and amps are populated.
    """
def nametable_add(nametable: NametableStruct, name: str, ix_name: typing.SupportsInt) -> PyNametableAdd:
    """
    No docstring available
    
    Parameters
    ----------
    nametable : 
    name : 
    ix_name : 
    """
def nametable_bracket_indexx(nametable: NametableStruct, name: str, n_match: typing.SupportsInt | None = None, ix_max: typing.SupportsInt) -> PyNametableBracketIndexx:
    """
    No docstring available
    
    Parameters
    ----------
    nametable : 
    name : 
    n_match : 
    ix_max : 
    """
def nametable_change1(nametable: NametableStruct, name: str, ix_name: typing.SupportsInt) -> PyNametableChange1:
    """
    No docstring available
    
    Parameters
    ----------
    nametable : 
    name : 
    ix_name : 
    """
def nametable_init(nametable: NametableStruct, n_min: typing.SupportsInt | None = None, n_max: typing.SupportsInt | None = None) -> PyNametableInit:
    """
    No docstring available
    
    Parameters
    ----------
    nametable : 
    n_min : 
    n_max : 
    """
def nametable_remove(nametable: NametableStruct, ix_name: typing.SupportsInt) -> PyNametableRemove:
    """
    No docstring available
    
    Parameters
    ----------
    nametable : 
    ix_name : 
    """
def new_control(lat: LatStruct, ix_ele: typing.SupportsInt, ele_name: str | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat used
    ix_ele : int
        Index of the new control element
    ele_name : unknown, optional
        Name of the new element. Output
    """
def nint_chk(re_val: typing.SupportsFloat) -> int:
    """
    Returns the nearest integer to re_val.
    
    Also does out-of-bounds error checking.
    Used with bmad parsing.
    
    Parameters
    ----------
    re_val : float
        Input real number.
    
    Returns
    -------
    int_val : int
        Output nearest integer.
    """
def normal_form_complex_taylors(one_turn_taylor: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"], rf_on: bool, F: typing.Annotated[collections.abc.Sequence[ComplexTaylorStruct], "FixedSize(6)"] | None = None, L: typing.Annotated[collections.abc.Sequence[ComplexTaylorStruct], "FixedSize(6)"] | None = None, A: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"] | None = None, A_inverse: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"] | None = None, order: typing.SupportsInt | None = None) -> PyNormalFormComplexTaylors:
    """
    No docstring available
    
    Parameters
    ----------
    one_turn_taylor : 
    rf_on : 
    F : 
    L : 
    A : 
    A_inverse : 
    order : 
    """
def normal_form_taylors(one_turn_taylor: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"], rf_on: bool) -> ...:
    """
    Do a normal form decomposition on a one-turn taylor map M:
    
    M = A o R o A_inverse
    where A maps Floquet (fully normalized) coordinates to lab coordinates.
    In Floquet coordinates, the amplitudes are defined as J_i = (1/2) (x_i^2 + p_i^2).
    The map R = exp(:h:) is a pure rotation with h = h(J) is a function of the amplitudes only.
    The angles (phase advances) are given by phi_i = 2pi*dh/dJ_i.
    The taylor terms of dhdj are therefore the tunes, chromaticities, amplitude dependent tune shifts, etc.
    The mapping procedure for one turn is:
    z_Floquet_in = A_inverse o z_Lab_in
    [phi_a, phi_b, phi_c] = 2 pi * dhdj o z_Floquet_in
    z_Floquet_out = RotationMatrix(phi_a, phi_b, phi_c) . z_Floquet_in
    z_Lab_out = A o z_Floquet_out
    
    Parameters
    ----------
    one_turn_taylor : TaylorStruct
        one turn taylor map
    rf_on : bool
        Was the map calculated with RF on?
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    A : TaylorStruct
        Map from Floquet coordinates to Lab coordinates
    A_inverse : TaylorStruct
        Map from Lab coordinates to Floquet coordinates
    dhdj : TaylorStruct
        Map from Floquet coordinates to phase advances
    """
def normal_mode3_calc(t6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], above_transition: bool | None = None, abz_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None) -> ...:
    """
    Does an Eigen decomposition of the 1-turn transfer matrix (mat) and generates
    
    B, V, H.
    If the above_transition argument is present and false, then the 3rd (z) mode is assumed
    to have a positive slip factor (z-mode rotates counter clockwise in phase space).
    Default is True ==> z-mode has a negative slip factor so the mode rotates clock-wise in phase space.
    
    Parameters
    ----------
    mat : float
        1-turn transfer matrix
    above_transition : bool, optional
        If present and false, then z-mode assumes positive slip factor. Else negative slip factor assumed.
    abz_tunes : float, optional
        Tunes to order eigensystem by.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    tune : float
        Tunes of the 3 normal modes (radians)
    B : float
        B is block diagonal and related to the normal mode Twiss parameters.
    HV : float
        Transforms from normal mode coordinates to canonical coordinates: x = H.V.a
    """
def normal_mode_dispersion(ele: EleStruct, reverse: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element whose dispersions are to be adjusted.
        This parameter is an input/output and is modified in-place. As an output: Element with adjusted
        dispersions.
    reverse : bool, optional
        Default is False. If True, calculate the x,y dispersions from the normal mode ones.
    """
def normalize_evecs(evec: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"]) -> bool:
    """
    Normalizes eigenvectors such that transpose(E).S.E = iS, where E = evec_r + i evec_i
    
    Parameters
    ----------
    evec : float
        complex eigenvectors arranged down columns.
        This parameter is an input/output and is modified in-place. As an output: Eigensystem normalized to be
        symplectic.
    
    Returns
    -------
    err_flag : bool
        Set true of normalization is not possible due to amplitude is zero.
    """
def num_field_eles(ele: EleStruct, n_field_ele: typing.SupportsInt) -> PyNumFieldEles:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with sum number of associated field elements.
    n_field_ele : 
    """
def num_lords(slave: EleStruct, lord_type: typing.SupportsInt, num: typing.SupportsInt) -> PyNumLords:
    """
    No docstring available
    
    Parameters
    ----------
    slave : EleStruct
        Slave element.
    lord_type : int
        Type of lord. super_lord$, multipass_lord$, girder_lord$, group_lord$, overlay_lord$, and governor$ (=
        group + overlay + control + girder)
    num : 
    """
def odeint_bmad(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, s1_body: typing.SupportsFloat, s2_body: typing.SupportsFloat, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> ...:
    """
    Subroutine to do Runge Kutta tracking. This routine is adapted from Numerical
    
    Recipes.  See the NR book for more details.
    Notice that this routine has an two tolerances:
    bmad_com%rel_tol_adaptive_tracking
    bmad_com%abs_tol_adaptive_tracking
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting coords: (x, px, y, py, z, delta) in element body coords.
        This parameter is an input/output and is modified in-place. As an output: Ending coords
    ele : EleStruct
        Element to track through.
    param : LatParamStruct
        Lattice parameters.
    s1_body : float
        Starting point relative to physical entrance.
    s2_body : float
        Ending point relative physical entrance.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
        through the element.
    make_matrix : bool, optional
        If True then make the 6x6 transfer matrix.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error. False otherwise. Note: a particle getting lost, for example hitting an
        aperture, is *not* an error.
    track : TrackStruct
        Structure holding the track information.
    """
def odeint_bmad_time(orb: CoordStruct, ele: EleStruct, param: LatParamStruct, t_dir: typing.SupportsInt, rf_time: typing.SupportsFloat, track: _pybmad.TrackStruct | None = None, t_end: typing.SupportsFloat | None = None, extra_field: _pybmad.EmFieldStruct | None = None) -> PyOdeintBmadTime:
    """
    Subroutine to do Runge Kutta tracking in time. This routine is adapted from Numerical
    
    Recipes.  See the NR book for more details.
    Tracking is done until the particle is lost or exits the element.
    
    Parameters
    ----------
    orb : CoordStruct
        Starting coords: (x, px, y, py, s, ps) [t-based]
        This parameter is an input/output and is modified in-place. As an output: Ending coords
    ele : EleStruct
        Element to track through. .tracking_method -- Determines which subroutine to use to calculate the field.
        Note: BMAD does no supply em_field_custom. == custom$ then use em_field_custom /= custom$ then use
        em_field_standard
    param : LatParamStruct
        Beam parameters.
    t_dir : float
        Direction of time travel = +/-1. Can be negative for patches. Will be -1 if element has a negative length.
    rf_time : float
        Time relative to RF clock.
        This parameter is an input/output and is modified in-place. As an output: Updated time.
    track : TrackStruct, optional
        Structure holding the track information. .save_track   -- Logical: Set True if track is to be saved.
    t_end : float, optional
        If present, maximum time to which the particle will be tracked. Used for tracking with given time steps.
        The time orb.t at which tracking stops may be less than this if the particle gets to the end of the
        element
    extra_field : EmFieldStruct, optional
        Static field to be added to the element field. Eg used with space charge.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error. False otherwise.
    dt_step : float
        Next RK time step that this tracker would take based on the error tolerance. Used by track_bunch_time.
    """
def offset_particle(ele: EleStruct, set: bool, orbit: CoordStruct, set_tilt: bool | None = None, set_hvkicks: bool | None = None, drift_to_edge: typing.SupportsInt | None = None, s_pos: typing.SupportsFloat | None = None, set_spin: bool | None = None, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None, time: typing.SupportsFloat | None = None) -> PyOffsetParticle:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    set : bool
        T (= set$)   -> Translate from lab coords to the local element coords. F (= unset$) -> Translate back from
        element to lab coords.
    orbit : CoordStruct
        Coordinates of the particle.
        This parameter is an input/output and is modified in-place. As an output: Coordinates of particle.
    set_tilt : bool, optional
        Default is True. T -> Rotate using ele.value(tilt$) and ele.value(roll$) for sbends. F -> Do not rotate
    set_hvkicks : bool, optional
        Default is True. T -> Apply 1/2 any hkick or vkick.
    drift_to_edge : int, optional
        no$             -> Do not propagate (drift) particle. no$ is default if s_pos is present. upstream_end$
        -> Propagate to upsteam edge. This is default if set = set$ and s_pos is not present. downstream_end$ ->
        Propagate to downsteam edge. This is default if set = unset$ and s_pos is not present. Note: "edge" is
        body edge if set = set$ and is laboratory (nominal non-misaligned) edge if set = unset$
    s_pos : float, optional
        Longitudinal particle position: If set = set$: Relative to upstream end (in lab coords). If set = unset$:
        Relative to entrance end (in body coords).
    s_out : float
        Longitudinal particle position. If set = set$: Relative to entrance end (in body coords). If set = unset$:
        Relative to upstream end (in lab coords).
    set_spin : bool, optional
        Default if False. Rotate spin coordinates? Also bmad_com.spin_tracking_on must be T to rotate.
    mat6 : float, optional
        Transfer matrix before off setting.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        after offsets applied.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    spin_qrot : float
        Spin rotation quaternion
    time : float, optional
        Particle time before drifting. Typically this is an RF clock time which may not be equal to orb.t
        This parameter is an input/output and is modified in-place. As an output: Updated time.
    """
def offset_photon(ele: EleStruct, orbit: CoordStruct, set: bool, offset_position_only: bool | None = None, rot_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    orbit : CoordStruct
        Coordinates of the particle.
        This parameter is an input/output and is modified in-place. As an output: Coordinates of particle.
    set : bool
        T (= set$)   -> Translate from lab coords to element coords. F (= unset$) -> Translate from element coords
        to lab coords.
    offset_position_only : bool, optional
        If present and True, only offset the position coordinates. -- Logical, optional: If present and True, only
        offset the position coordinates.
    rot_mat : float, optional
        Rotation matrix from starting coords to ending coords.
    """
def omega_to_quat(omega: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    Routine to convert from omega + angle representation to a quaternion.
    
    Parameters
    ----------
    omega : float
        Axis of rotation + magnitude = rotation angle.
    
    Returns
    -------
    quat : float
        Rotation quaternion.
    """
def one_turn_mat_at_ele(ele: EleStruct, phi_a: typing.SupportsFloat, phi_b: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"]:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Reference element. .a       -- "a" mode Twiss parameter structure. .b       -- "b" mode Twiss parameter
        structure. .c_mat   -- 2x2 C matrix. .gamma_c -- gamma associated with C matrix.
    phi_a : float
        "a" mode tune in radians.
    phi_b : float
        "b" mode tune in radians.
    mat4 : float
        1-Turn coupled matrix.
    """
def open_binary_file(file_name: str, action: str, r_name: str) -> ...:
    """
    Routine to open a binary file for reading or writing.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    action : unknown
        'READ' or 'WRITE'
    r_name : unknown
        Calling routine name for error messages.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    iu : int
        Unit number of opened file.
    iver : int
        Version number if action = 'READ'
    is_ok : bool
        Open OK?
    """
def openpmd_species_name(species: typing.SupportsInt) -> str:
    """
    Routine to return the openPMD name of a particle species given the Bmad species ID.
    
    Parameters
    ----------
    species : int
        Bmad species ID number.
    
    Returns
    -------
    pmd_name : unknown
        Name of the species. Will return 'INVALID!' (= invalid_name) if index is not valid.
    """
def orbit_amplitude_calc(ele: EleStruct, orb: CoordStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element holding the Twiss parameters, dispersion and coupling info.
    orb : CoordStruct
        Orbit coordinates at the exit end of ele.
    amp_a : float
        a-mode amplitude
    amp_b : float
        b-mode amplitude
    amp_na : float
        a-mode, energy normalized, amplitude.
    amp_nb : float
        b-mode, energy normalized, amplitude.
    """
def orbit_reference_energy_correction(orbit: CoordStruct, p0c_new: typing.SupportsFloat, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Coordinates to correct.
    p0c_new : float
        New reference momentum.
    mat6 : float, optional
        Transfer matrix before correction.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        including correction.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def orbit_to_floor_phase_space(orbit: CoordStruct, ele: EleStruct, floor_phase_space: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle orbit in local (not element) coordinates.
    ele : EleStruct
        Lattice element particle is in.
    floor_phase_space : 
    """
def orbit_to_local_curvilinear(orbit: CoordStruct, ele: EleStruct, z_direction: typing.SupportsInt | None = None, relative_to: typing.SupportsInt | None = None, local_position: FloorPositionStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle orbit in laboratory (not body) coordinates.
    ele : EleStruct
        Lattice element particle is in.
    z_direction : int, optional
        Set to +1 or -1.  Z-direction of particle velocity relative to element z-axis. Default is ele.orientation
        * orbit.direction.
    relative_to : int, optional
        not_set$ (default), upstream_end$, downstream_end$. If not_set$ then origin is at the entrance end.
    local_position : 
    """
def orbit_too_large(orbit: CoordStruct, check_momentum: bool | None = None, is_too_large: bool) -> PyOrbitTooLarge:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle orbit.
    param : LatParamStruct
        .unstable_factor  -- Set if orbit is too large. Otherwise not set
    check_momentum : bool, optional
        If True (default) check the momentum.
    is_too_large : 
    """
def order_evecs_by_n_similarity(eval: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"], mat_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], Nmat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    This subroutine orderes the eigensystem such that Nmat.mat_symp_conj(N) is closest
    
    to the identity.  Nmat is supplied externally.
    
    Parameters
    ----------
    eval : complex
        complex eigenvalues.
    evecr : complex
        complex eigenvectors arranged down columns.
    mat_tunes : float
        Three normal mode tunes, in radians.
        This parameter is an input/output and is modified in-place. As an output: Ordered normal mode tunes, in
        radians.
    Nmat : float
        Normalized, real eigen matrix from make_N.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    evec : complex
        complex eigenvectors arranged down columns.
    err_flag : bool
        Set True if there is an error. False otherwise
    """
def order_evecs_by_plane_dominance(evec: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], eval: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"], mat_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None) -> None:
    """
    This subroutine orderes the eigensystem according to which modes dominate the horizontal,
    
    vertical, and longitudinal planes.  This subroutine works well in machines
    that are not strongly coupled.  In machines with strong coupling, where the relation
    between the three eigenmodes a, b, c and the three lab coordinates x, y, z can change
    through the machine, this subroutine will not provide consistent ordering.
    
    Parameters
    ----------
    eval : complex
        complex eigenvalues.
        This parameter is an input/output and is modified in-place. As an output: Ordered complex eigenvalues.
    evec : complex
        complex eigenvectors arranged down columns.
        This parameter is an input/output and is modified in-place. As an output: Ordered complex eigenvectors.
    mat_tunes : float, optional
        Three normal mode tunes, in radians.
        This parameter is an input/output and is modified in-place. As an output: Reordered same as evecs.
    """
def order_evecs_by_tune(evec: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"]], "FixedSize(6)"], eval: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"], mat_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], abz_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> bool:
    """
    This subroutine orders the eigensystem by matching the tunes of the eigensystem to
    
    externally supplied tunes abz_tunes.  abz_tunes is in radians.
    
    Parameters
    ----------
    eval : complex
        complex eigenvalues.
        This parameter is an input/output and is modified in-place. As an output: Ordered eigenvalues.
    evec : complex
        complex eigenvectors arranged down columns.
        This parameter is an input/output and is modified in-place. As an output: Ordered eigenvectors.
    mat_tunes : float
        Three normal mode tunes, in radians.
    abz_tunes : float
        Tunes to order eigensystem by.
    
    Returns
    -------
    err_flag : bool
        Set to true if an error occured.
    """
def order_particles_in_z(bunch: BunchStruct) -> None:
    """
    Routine to order the particles longitudinally in terms of decreasing %vec(5).
    
    That is from large z (head of bunch) to small z.
    Only live particles are ordered.
    
    Parameters
    ----------
    bunch : BunchStruct
        collection of particles. .particle(j).vec(5) -- Longitudinal position of j^th particle.
    """
def order_super_lord_slaves(lat: LatStruct, ix_lord: typing.SupportsInt) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat with fixed controls.
    ix_lord : int
        Index of lord element. Output
    """
def ordinal_str(n: typing.SupportsInt, str: str) -> PyOrdinalStr:
    """
    No docstring available
    
    Parameters
    ----------
    n : 
    str : 
    """
def osc_alloc_freespace_array(nlo: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], nhi: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], npad: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    nlo : 
    nhi : 
    npad : 
    """
def osc_alloc_image_array(nlo: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], nhi: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], npad: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    nlo : 
    nhi : 
    npad : 
    """
def osc_alloc_rectpipe_arrays(nlo: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], nhi: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], npad: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    nlo : 
    nhi : 
    npad : 
    """
def osc_getgrnpipe(gam: typing.SupportsFloat, a: typing.SupportsFloat, b: typing.SupportsFloat, delta: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], umin: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], npad: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"]) -> PyOscGetgrnpipe:
    """
    No docstring available
    
    Parameters
    ----------
    gam : 
    a : 
    b : 
    delta : 
    umin : 
    npad : 
    """
def osc_read_rectpipe_grn() -> None:
    """
    No docstring available
    """
def osc_write_rectpipe_grn(apipe: typing.SupportsFloat, bpipe: typing.SupportsFloat, delta: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], umin: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], umax: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], nlo: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], nhi: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], gamma: typing.SupportsFloat) -> PyOscWriteRectpipeGrn:
    """
    No docstring available
    
    Parameters
    ----------
    apipe : 
    bpipe : 
    delta : 
    umin : 
    umax : 
    nlo : 
    nhi : 
    gamma : 
    """
def parse_cartesian_map(ct_map: CartesianMapStruct, ele: EleStruct, lat: LatStruct, delim: str, delim_found: bool, err_flag: bool) -> PyParseCartesianMap:
    """
    Subroutine to parse a "cartesian_map = {}" construct
    
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is private to bmad_parser_mod.
    This must read in:
    {type = ,
    dr = ,
    r0 = ,
    pt(i,j,k) = ( (ex_re, ex_im), .... (bz_re, bz_im) )
    .
    .
    . ) },
    """
def parse_cylindrical_map(cl_map: CylindricalMapStruct, ele: EleStruct, lat: LatStruct, delim: str, delim_found: bool, err_flag: bool) -> PyParseCylindricalMap:
    """
    No docstring available
    
    Parameters
    ----------
    cl_map : 
    ele : 
    lat : 
    delim : 
    delim_found : 
    err_flag : 
    """
def parse_fortran_format(format_str: str, n_repeat: typing.SupportsInt, power: typing.SupportsInt, descrip: str, width: typing.SupportsInt, digits: typing.SupportsInt) -> PyParseFortranFormat:
    """
    No docstring available
    
    Parameters
    ----------
    format_str : 
    n_repeat : 
    power : 
    descrip : 
    width : 
    digits : 
    """
def parse_gen_grad_map(gg_map: GenGradMapStruct, ele: EleStruct, lat: LatStruct, delim: str, delim_found: bool, err_flag: bool) -> PyParseGenGradMap:
    """
    Subroutine to parse a "gen_grad_map = {}" construct
    """
def parse_grid_field(g_field: GridFieldStruct, ele: EleStruct, lat: LatStruct, delim: str, delim_found: bool, err_flag: bool) -> PyParseGridField:
    """
    No docstring available
    
    Parameters
    ----------
    g_field : 
    ele : 
    lat : 
    delim : 
    delim_found : 
    err_flag : 
    """
def parse_integer_list(err_str: str, lat: LatStruct, int_array: IntAlloc1D, exact_size: bool, delim: str, delim_found: bool, open_delim: str | None = None, separator: str | None = None, close_delim: str | None = None, default_value: typing.SupportsInt | None = None, is_ok: bool) -> PyParseIntegerList:
    """
    separator, close_delim, default_value) result (is_ok)
    
    Routine to parse a list of integers of the form:
    open_delim integer_1 separator integer_2 . . . close_delim
    Example:   "(1.2, 2.3, 4.4, 8.5)"
    Similar to parse_integer_list2 except does not use allocatable array.
    See parse_integer_list2 for more details
    """
def parse_integer_list2(err_str: str, lat: LatStruct, int_array: IntAlloc1D, num_expected: typing.SupportsInt | None = None, open_delim: str | None = None, separator: str | None = None, close_delim: str | None = None, default_value: typing.SupportsInt | None = None) -> PyParseIntegerList2:
    """
    open_delim, separator, close_delim, default_value) result (is_ok)
    
    Routine to parse a list of integers of the form
    open_delim integer_1 separator integer_2 . . . close_delim
    Example:   (1, 2, 4, 8)
    
    Parameters
    ----------
    err_str : unknown
        Error string to print if there is an error.
    lat : LatStruct
        lattice
    int_array : int
        the array to be read in Optional: num_expected = 1     -- integer: number of expected arguments. Used to
        initialize int_array. open_delim   = '('   -- character(1): opening delimeter. separator    = ','   --
        character(1): separating character. close_delim  = ')'   -- character(1): closing delimeter. default_value
        = 0    -- real(rp): inital assignment of int_array elements.
        This parameter is an input/output and is modified in-place. As an output: Array of values.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    is_ok : bool
        Set True if everything is ok.
    num_found : int
        number of elements.
    delim : unknown
        Delimiter found where the parsing of the input line stops.
    delim_found : bool
        Delimiter found? False if end of input command.
    """
def parse_real_list(lat: LatStruct, err_str: str, exact_size: bool, open_delim: str | None = None, separator: str | None = None, close_delim: str | None = None, default_value: typing.SupportsFloat | None = None) -> ...:
    """
    separator, close_delim, default_value, num_found) result (is_ok)
    
    Routine to parse a list of reals of the form:
    open_delim real_1 separator real_2 . . . close_delim
    Example:   "(1.2, 2.3, 4.4, 8.5)"
    Similar to parse_real_list2 except does not use allocatable array.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
    err_str : unknown
        Error string to print if there is an error.
    exact_size : 
    open_delim : 
    separator : 
    close_delim : 
    default_value : 
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    real_array : 
    delim : 
    delim_found : 
    num_found : 
    
    Notes
    -----
    Related routines:
    parse_real_matrix.
    """
def parse_real_list2(lat: LatStruct, err_str: str, real_array: RealAlloc1D, num_expected: typing.SupportsInt | None = None, open_brace: str | None = None, separator: str | None = None, close_brace: str | None = None, default_value: typing.SupportsFloat | None = None, single_value: bool | None = None) -> PyParseRealList2:
    """
    open_delim, separator, close_delim, default_value, single_value) result (is_ok)
    
    Routine to parse a list of reals of the form:
    open_brace real_1 separator real_2 . . . close_brace
    Example:   "(1.2, 2.3, 4.4, 8.5)"
    
    Parameters
    ----------
    lat : LatStruct
        lattice
    err_str : unknown
        Error string to print if there is an error.
    real_array : float
        the array to be read in num_expected = 10       -- integer, optional: number of expected arguments Used to
        initialize real_array open_brace   = '('      -- character(1), optional: opening delimeter. separator    =
        ','      -- character(1), optional: separating character close_brace  = ')'      -- character(1),
        optional: closing delimeter default_value = 0.0_rp  -- real(rp), optional: inital assignment of real_array
        elements. single_value = False    -- logical, optional: If true then an array with a single value and no
        braces is accepted.
        This parameter is an input/output and is modified in-place. As an output: Array of values
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    is_ok : bool
        Set True if everything is ok
    num_found : int
        number of elements
    delim : unknown
        Delimiter found where the parsing of the input line stops.
    delim_found : bool
        Stopping delimiter found? False if end of input command.
    
    Notes
    -----
    Related routines:
    pase_real_list parse_real_matrix.
    """
def parser_add_constant(word: str, lat: LatStruct, redef_is_error: bool) -> PyParserAddConstant:
    """
    No docstring available
    
    Parameters
    ----------
    word : 
    lat : 
    redef_is_error : 
    """
def parser_call_check(word: str, ix_word: typing.SupportsInt, delim: str, delim_found: bool, call_found: bool, err_flag: bool | None = None) -> PyParserCallCheck:
    """
    Routine to check if there is a "call::XXX" construct in the input stream.
    """
def parser_fast_complex_read(ele: EleStruct, err_str: str) -> ...:
    """
    Routine to read an array of complex numbers.
    
    This routine assumes that the array values are pure numbers in the form "<re>" or "(<re> <im>)"
    where <re> and <im> are real numbers (not expressions) and there are no commas except possibly
    at the end of the array.
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element associated with the array. Used for error messages.
    err_str : unknown
        String used when printing error messages identifying where in the lattice file the error is occuring.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    cmplx_vec : complex
        Complex vector.
    delim : unknown
        Delimitor at end of array. Must be "," or "}"
    is_ok : bool
        True if everything OK. False otherwise.
    """
def parser_fast_integer_read(int_vec: IntAlloc1D, ele: EleStruct, delim_wanted: str, err_str: str, is_ok: bool) -> PyParserFastIntegerRead:
    """
    Returns
    -------
    is_ok
    """
def parser_fast_real_read(ele: EleStruct, end_delims: str, err_str: str, exact_size: bool | None = None) -> ...:
    """
    Routine to read an array of real numbers.
    
    This routine assumes that the array values are pure numbers in the form "<re1> <re2> ...,"
    where <re1>, <re2>, etc. are real numbers (not expressions) and there are no commas except possibly,
    at the end of the array.
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element associated with the array. Used for error messages.
    end_delims : unknown
        List of possible ending delimitors.
    err_str : unknown
        String used when printing error messages identifying where in the lattice file the error is occuring.
    exact_size : bool, optional
        If True (default), number of values must match real_vec size.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    real_vec : complex
        Real vector.
    delim : unknown
        Delimitor at end of array.
    is_ok : bool
        True if everything OK. False otherwise.
    n_real : int
        Number of elements found.
    """
def parser_file_stack(how: str, file_name_in: str | None = None, finished: bool | None = None, err: bool | None = None, open_file: bool | None = None, abort_on_open_error: bool | None = None) -> PyParserFileStack:
    """
    Subroutine to keep track of the files that are opened for reading.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    """
def parser_get_integer(int_val: typing.SupportsInt, word: str, ix_word: typing.SupportsInt, delim: str, delim_found: bool, err: bool, str1: str | None = None, str2: str | None = None) -> PyParserGetInteger:
    """
    No docstring available
    
    Parameters
    ----------
    int_val : 
    word : 
    ix_word : 
    delim : 
    delim_found : 
    err : 
    str1 : 
    str2 : 
    """
def parser_get_logical(attrib_name: str, this_logic: bool, ele_name: str, delim: str, delim_found: bool, err: bool) -> PyParserGetLogical:
    """
    No docstring available
    
    Parameters
    ----------
    attrib_name : 
    this_logic : 
    ele_name : 
    delim : 
    delim_found : 
    err : 
    """
def parser_identify_fork_to_element(lat: LatStruct) -> None:
    """
    Routine to identify the elements the forks in a lattice are branching to.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    """
def parser_init_custom_elements(lat: LatStruct) -> None:
    ...
def parser_print_line(lat: LatStruct, end_of_file: bool) -> PyParserPrintLine:
    """
    This routine is called when a print statement is found in the lattice file.
    """
def parser_read_lr_wake(ele: EleStruct, delim: str, delim_found: bool, err_flag: bool) -> PyParserReadLrWake:
    """
    Subroutine to read in a long-range wake field from an external file.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    
    Parameters
    ----------
    ele : EleStruct
        Element containing wake structure.
        This parameter is an input/output and is modified in-place. As an output: Element with wake information.
    """
def parser_read_old_format_lr_wake(ele: EleStruct, lr_file_name: str) -> None:
    """
    Subroutine to read in a long-range wake field from an external file.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    
    Parameters
    ----------
    ele : EleStruct
        Element containing wake structure.
        This parameter is an input/output and is modified in-place. As an output: Element with wake information.
    lr_file_name : unknown
        Name of long-range wake field file.
    """
def parser_read_old_format_sr_wake(ele: EleStruct, sr_file_name: str) -> None:
    """
    Subroutine to read in a short-range wake field from an external file.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    
    Parameters
    ----------
    ele : EleStruct
        Element containing wake structure.
        This parameter is an input/output and is modified in-place. As an output: Element with wake information.
    sr_file_name : unknown
        Name of short-range wake field file.
    """
def parser_read_sr_wake(ele: EleStruct, delim: str, delim_found: bool, err_flag: bool) -> PyParserReadSrWake:
    """
    Subroutine to read in a short-range wake field.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    
    Parameters
    ----------
    ele : EleStruct
        Element containing wake structure.
        This parameter is an input/output and is modified in-place. As an output: Element with wake information.
    """
def parser_transfer_control_struct(con_in: ControlStruct, lord: EleStruct, ix_var: typing.SupportsInt) -> ControlStruct:
    """
    Routine to transfer the information from an input control_struct (which stores
    
    the user input parameters) to a control_struct that will be stored in the lat%control
    or lord%control%ramp for a ramper.
    
    Parameters
    ----------
    con_in : ControlStruct
        Input control structure.
    lord : EleStruct
        Lord element associated with the control_struct.
    ix_var : int
        If an expression stack evaluates to a constant, this routine will modify the expression stack to evaluate
        to the value of: lord.control.var(ix_var) * constant
    
    Returns
    -------
    con_out : ControlStruct
        Output control structure.
    """
def particle_in_global_frame(orb: CoordStruct, branch: BranchStruct, in_time_coordinates: bool | None = None, in_body_frame: bool | None = None, w_mat_out: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None, particle: CoordStruct) -> None:
    """
    Returns the particle in global time coordinates given is coordinates orb in lattice lat.
    
    Parameters
    ----------
    orb : CoordStruct
        particle in s-coordinates
    branch : BranchStruct
        branch that contains branch.ele(orb.ix_ele)
    in_time_coordinates : bool
        Default is false. If true, orb will taken as in time coordinates.
    in_body_frame : bool
        Default is true. If false, ele offsets will be ignored. Result:
    particle : CoordStruct
        particle in global time coordinates
    
    Returns
    -------
    particle
    """
def particle_is_moving_backwards(orbit: CoordStruct, is_moving_backwards: bool) -> PyParticleIsMovingBackwards:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle coordinates
    is_moving_backwards : 
    """
def particle_is_moving_forward(orbit: CoordStruct, dir: typing.SupportsInt | None = None, is_moving_forward: bool) -> PyParticleIsMovingForward:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle coordinates
    dir : int, optional
        +1 if tracking forward(default) or -1 to return True if tracking backwards.
    is_moving_forward : 
    """
def particle_rf_time(orbit: CoordStruct, ele: EleStruct, reference_active_edge: bool | None = None, s_rel: typing.SupportsFloat | None = None, time_coords: bool | None = None, rf_freq: typing.SupportsFloat | None = None, abs_time: bool | None = None, time: typing.SupportsFloat) -> PyParticleRfTime:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle coordinates
    ele : EleStruct
        Element being tracked through.
    reference_active_edge : bool
        If True, and ele is a rfcavity or lcavity, use the active edge (edge of the -- logical: If True, and ele
        is a rfcavity or lcavity, use the active edge (edge of the region with non-zero field) as the reference
        point.
    s_rel : float, optional
        Longitudinal position relative to the upstream edge of the element. Needed for relative time tracking when
        the particle is inside the element. Default is 0.
    time_coords : bool, optional
        Default False. If True then orbit is using time based phase space coordinates.
    rf_freq : float, optional
        If present, the returned time shifted by an integer multiple of 1/rf_freq to be in the range
        [-1/2*rf_freq, 1/2*rf_freq]. This is useful to avoid round-off errors.
    abs_time : float, optional
        If False (default) use setting of bmad_com.absolute_time_tracking. If True, use absolute time instead of
        relative time. Ouput:
    time : 
    """
def patch_flips_propagation_direction(x_pitch: typing.SupportsFloat, y_pitch: typing.SupportsFloat, is_flip: bool) -> PyPatchFlipsPropagationDirection:
    """
    No docstring available
    
    Parameters
    ----------
    x_pitch : float
        Rotaion around y-axis
    y_pitch : float
        Rotation around x-axis.
    is_flip : 
    """
def patch_length(patch: EleStruct, ref_coords: typing.SupportsInt | None = None, length: typing.SupportsFloat) -> PyPatchLength:
    """
    No docstring available
    
    Parameters
    ----------
    patch : EleStruct
        Patch element.
    ref_coords : int, optional
        Reference coords to use. entrance_end$, exit_end$ Default is nint(patch.value(ref_coords$)).
    length : 
    """
def photon_absorption_and_phase_shift(material: str, Energy: typing.SupportsFloat) -> ...:
    """
    Routine to calcualte the absorption and phase shift values for a photon with a given
    
    energy going through a particular material.
    
    Parameters
    ----------
    material : unknown
        Material name.
    Energy : float
        Photon energy (eV).
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    absorption : float
        E_field ~ Exp(-absorption * length)
    phase_shift : float
        E_field Phase shift (radians) per unit length relative to vacuum.
    err_flag : bool
        Set true if material not recognized.
    """
def photon_add_to_detector_statistics(orbit0: CoordStruct, orbit: CoordStruct, ele: EleStruct, ix_pt: typing.SupportsInt | None = None, iy_pt: typing.SupportsInt | None = None, pixel_pt: _pybmad.PixelPtStruct | None = None) -> PyPhotonAddToDetectorStatistics:
    """
    Routine to add photon statistics to the appropriate pixel of a "detector" grid.
    
    It is assumed that track_to_surface has been called so that the photon is at the
    detector surface and that orbit%vec(1) and %vec(3) are in surface coords (needed for curved detectors).
    
    Parameters
    ----------
    orbit0 : CoordStruct
        Photon coords at beginning of lattice
    orbit : CoordStruct
        Photon coords at the detector.
    ele : EleStruct
        Element with grid.
        This parameter is an input/output and is modified in-place. As an output: Element with updatted grid.
    pixel_pt : PixelPtStruct, optional
        If present then use this grid point instead of the grid point determined by the (x, y) coords of the
        photon
    """
def photon_reflection(graze_angle_in: typing.SupportsFloat, energy: typing.SupportsFloat, surface: PhotonReflectSurfaceStruct) -> ...:
    """
    Routine to reflect a photon from a surface including both diffuse and specular reflections.
    
    Parameters
    ----------
    graze_angle_in : float
        Incident grazing (not polar) angle in radians.
    energy : float
        Photon energy in eV.
    surface : PhotonReflectSurfaceStruct
        surface info
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    graze_angle_out : float
        graze_angle in radians.
    phi_out : float
        Azimuthal angle in radians.
    """
def photon_reflection_std_surface_init() -> PhotonReflectSurfaceStruct:
    """
    Routine to initialize the standard proton reflection probability tables.
    
    The standard tables are for 10 nm C film on Al substrate.
    The surface roughness for diffuse scattering is 200 nm and the
    the surface roughness correlation length is 5.5 um.
    
    
    Returns
    -------
    surface : 
        photon_reflect_surface_struct
    """
def photon_reflectivity(angle: typing.SupportsFloat, energy: typing.SupportsFloat, surface: PhotonReflectSurfaceStruct) -> ...:
    """
    Routine to evaluate the photon reflectivity.
    
    probability of absorption          = 1 - p_reflect
    probability of reflection          = p_reflect
    probability of specular reflection = p_reflect * rel_p_specular
    probability of diffuse reflection  = p_reflect * (1 - rel_p_specular)
    Use photon_reflection_std_surface_init or read_surface_reflection_file to get surface info.
    
    Parameters
    ----------
    angle : float
        Incident grazing angle in radians.
    energy : float
        Photon energy in eV.
    surface : PhotonReflectSurfaceStruct
        surface info
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    p_reflect : float
        Reflection probability.
    rel_p_specular : float
        Relative specular reflection probability.
    """
def photon_target_corner_calc(aperture_ele: EleStruct, x_lim: typing.SupportsFloat, y_lim: typing.SupportsFloat, z_lim: typing.SupportsFloat, source_ele: EleStruct) -> PyPhotonTargetCornerCalc:
    """
    Routine to calculate the corner coords in the source_ele ref frame.
    
    Parameters
    ----------
    aperture_ele : EleStruct
        Element containing the aperture x_lim, y_lim  -- real(rp): Transverse corner points in aperture_ele coord
        frame.
    source_ele : EleStruct
        Photon source element.
    
    Returns
    -------
    corner : TargetPointStruct
        Corner coords in source_ele ref frame.
    """
def photon_target_setup(ele: EleStruct) -> None:
    """
    Routine to calculate and store the parmeters needed for photon targeting.
    
    This routine is called by Bmad parsing routines and is not meant for general use.
    Photon initialization with targeting is done by the routine init_photon_from_a_photon_init_ele
    Which is called by init_coord.
    
    Parameters
    ----------
    ele : EleStruct
        Source element to setup. Element will be of type: sample, diffraction_plate or photon_init.
        This parameter is an input/output and is modified in-place. As an output: Source element with target
        parameters setup in ele.photon.target.
    """
def photon_type(ele: EleStruct) -> int:
    """
    Routine to return the type of photon to be tracked: coherent$ or incoherent$.
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through.
    
    Returns
    -------
    e_type : int
        coherent$ or incoherent$
    """
def physical_ele_end(track_end: typing.SupportsInt, orbit: CoordStruct, ele_orientation: typing.SupportsInt, return_stream_end: bool | None = None, physical_end: typing.SupportsInt) -> PyPhysicalEleEnd:
    """
    import
    
    implicit none
    type (twiss_struct) twiss
    real(rp), optional :: tol
    real(rp) x(:), xp(:)
    real(rp) tune, emit
    real(rp) x_0, xp_0, chi
    end subroutine
    
    Parameters
    ----------
    track_end : int
        first_track_edge$, second_track_edge$, surface$, or in_between$
    orbit : CoordStruct
        Particle position.
    ele_orientation : int
        Either 1 = Normal or -1 = element reversed.
    return_stream_end : bool, optional
        If True return the stream end instead of the physical end. Default is False.
    """
def point_photon_emission(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct, direction: typing.SupportsInt, max_target_area: typing.SupportsFloat, w_to_surface: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None) -> None:
    """
    Routine to emit a photon from a point that may be on a surface.
    
    If there is a downstream target, the emission calc will take this into account.
    
    Parameters
    ----------
    ele : EleStruct
        Emitting element.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords of photon. --   Will be in curved surface coords if there is a curved surface.
        This parameter is an input/output and is modified in-place. As an output: Final phase-space coords
    direction : int
        +1 -> Emit in forward +z direction, -1 -> emit backwards.
    max_target_area : float
        Area of the solid angle photons may be emitted over. max_target_area is used for normalizing the photon
        field. generally will be equal to twopi or fourpi.
    w_to_surface : float, optional
        Rotation matrix for curved surface.
    """
@typing.overload
def pointer_to_branch(ele: EleStruct) -> BranchStruct:
    """
    Routine to return a pointer to the lattice branch associated with a given name
    
    or a given element.
    pointer_to_branch_given_ele (ele) result (branch_ptr))
    pointer_to_branch_given_name (branch_name, lat, parameter_is_branch0, blank_branch) result (branch_ptr)
    The lattice branch *associated* with a given element is not necessarily the
    branch where the element is *located*. For example, all lords live in branch #0.
    But the branch associated with a super_lord element is the branch of its slaves.
    To get the branch where the element is located, simply use ele%ix_branch.
    
    Parameters
    ----------
    ele : EleStruct
        Element contained in the branch.
    branch_name : unknown
        May be a branch name or a branch index.
    lat : LatStruct
        Lattice to search.
    parameter_is_branch0 : bool, optional
        If True, 'PARAMETER' is taken to be an alternative name for branch(0). Default is False.
    blank_branch : int, optional
        Branch index if branch_name = ''. Default is blank is an error.
    
    Returns
    -------
    branch_ptr : BranchStruct
        Pointer to the branch. Nullified if there is no associated branch.
    
    Notes
    -----
    Overloaded versions:
    """
@typing.overload
def pointer_to_branch(branch_name: str, lat: LatStruct, parameter_is_branch0: bool | None = None, blank_branch: typing.SupportsInt | None = None) -> BranchStruct:
    """
    Routine to return a pointer to the lattice branch associated with a given name
    
    or a given element.
    pointer_to_branch_given_ele (ele) result (branch_ptr))
    pointer_to_branch_given_name (branch_name, lat, parameter_is_branch0, blank_branch) result (branch_ptr)
    The lattice branch *associated* with a given element is not necessarily the
    branch where the element is *located*. For example, all lords live in branch #0.
    But the branch associated with a super_lord element is the branch of its slaves.
    To get the branch where the element is located, simply use ele%ix_branch.
    
    Parameters
    ----------
    ele : EleStruct
        Element contained in the branch.
    branch_name : unknown
        May be a branch name or a branch index.
    lat : LatStruct
        Lattice to search.
    parameter_is_branch0 : bool, optional
        If True, 'PARAMETER' is taken to be an alternative name for branch(0). Default is False.
    blank_branch : int, optional
        Branch index if branch_name = ''. Default is blank is an error.
    
    Returns
    -------
    branch_ptr : BranchStruct
        Pointer to the branch. Nullified if there is no associated branch.
    
    Notes
    -----
    Overloaded versions:
    """
@typing.overload
def pointer_to_ele(lat: LatStruct, ix_ele: typing.SupportsInt, ix_branch: typing.SupportsInt | None = None, ele_ptr: EleStruct) -> PyPointerToEle1:
    """
    Function to return a pointer to an element in a lattice.
    
    This routine is overloaded by pointer_to_ele.
    See pointer_to_ele for more details.
    
    
    Returns
    -------
    ele_ptr
    """
@typing.overload
def pointer_to_ele(lat: LatStruct, ele_loc: LatEleLocStruct, ele_ptr: EleStruct) -> None:
    """
    Function to return a pointer to an element in a lattice.
    
    This routine is overloaded by pointer_to_ele.
    See pointer_to_ele for more details.
    
    
    Returns
    -------
    ele_ptr
    """
@typing.overload
def pointer_to_ele(lat: LatStruct, ele_name: str, ele_ptr: EleStruct) -> PyPointerToEle3:
    """
    Function to return a pointer to an element in a lattice.
    
    This routine is overloaded by pointer_to_ele.
    See pointer_to_ele for more details.
    
    
    Returns
    -------
    ele_ptr
    """
@typing.overload
def pointer_to_ele(lat: LatStruct, foreign_ele: EleStruct, ele_ptr: EleStruct) -> None:
    """
    Function to return a pointer to an element in a lattice.
    
    This routine is overloaded by pointer_to_ele.
    See pointer_to_ele for more details.
    
    
    Returns
    -------
    ele_ptr
    """
def pointer_to_element_at_s(branch: BranchStruct, s: typing.SupportsFloat, choose_max: bool, print_err: bool | None = None) -> ...:
    """
    Function to return a pointer to the element at position s.
    
    That is, return ele => branch%ele(ix_ele) such that:
    If choose_max = True:
    If s = branch%ele(ix_end_of_branch): ix_ele = ix_end_of_branch
    Else: branch%ele(ix_ele)%s_strat <= s < branch%ele(ix_ele)%s
    If choose_max = False:
    If s = branch%ele(0): ix_ele = 0
    Else: branch%ele(ix_ele)%s_start < s <= branch%ele(ix_ele)%s
    That is, if s corresponds to an element boundary between elements with indexes ix1 and ix2 = ix1 + 1:
    choose_max = True  => ix_ele = ix2
    choose_max = False => ix_ele = ix1
    
    Parameters
    ----------
    branch : BranchStruct
        Branch to use
    s : float
        Longitudinal position.
    choose_max : bool
        See above.
    print_err : bool, optional
        Print error message if there is an error? Default is True.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ele : EleStruct
        Pointer to element at s.
    err_flag : bool
        Set True if s is out of bounds. False otherwise.
    s_eff : float
        Effective s. Equal to s with a open lattice. See above.
    position : CoordStruct
        Positional information. .s         -- Same as input s. .ix_ele    -- Same as output ix_ele .location  --
        Location relative to element. Upstream_end$, downstream_end$, or inside$
    
    Notes
    -----
    Related routines:
    element_at_s The setting of choose_max only makes a difference when s corresponds to an element boundary. For
    a circular lattice s is evaluated at the effective s which s_eff = s - branch_length * floor(s/branch_length)
    If there are multiple elements that are at the given s position due to the presence of an element with a
    negative length which of the possible elements is actually chosen is ill-defined.
    """
def pointer_to_field_ele(ele: EleStruct, ix_field_ele: typing.SupportsInt, field_ele: EleStruct) -> float:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with sum number of associated field elements.
    ix_field_ele : int
        Index of the field element to point to. This index runs from 1 to num_field_eles(ele).
    dz_offset : float
        Longitudinal offset of ele upstream edge from the field ele pointed to.
    field_ele : 
    """
def pointer_to_girder(ele: EleStruct, girder: EleStruct) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to check.
    ix_slave_back : int
        Index back to ele. That is, pointer_to_slave(girder, ix_slave_back) will point back to ele. Set to -1 if
        no girder present
    girder : 
    """
def pointer_to_lord(slave: EleStruct, ix_lord: typing.SupportsInt, lord_type: typing.SupportsInt | None = None, lord_ptr: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    slave : EleStruct
        Slave element.
    ix_lord : int
        Index of the lord.
    control : ControlStruct
        Pointer to control info for this lord/slave relationship. Nullified if there is an error.
    ix_slave_back : int
        Index back to the slave. That is, pointer_to_slave(lord_ptr, ix_slave_back) will point back to slave. Set
        to -1 if there is an error or the slave is a slice_slave.
    lord_type : int, optional
        See above.
    ix_control : int
        Index in lat.control(:) array the control argument is at. For ramper lord elements, ix_control is index
        for the lord.control.ramper(:) array.
    ix_ic : int
        Index of the lat.ic(:) element associated with the control argument.
    lord_ptr : 
    """
def pointer_to_multipass_lord(ele: EleStruct, multi_lord: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    ix_pass : int
        Multipass turn number. Set to 0 if element is a multipass_lord. Set to -1 if element is not a
        multipass_slave.
    super_lord : EleStruct
        super_lord of the element. Set to NULL if ele is not a super_slave or super_lord. Note: if ele is a
        multipass_lord there are multiple possible super_lord slaves.
    multi_lord : 
    """
def pointer_to_next_ele(this_ele: EleStruct, offset: typing.SupportsInt | None = None, skip_beginning: bool | None = None, follow_fork: bool | None = None, next_ele: EleStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    this_ele : EleStruct
        Starting element.
    offset : int, optional
        +1 -> return next element, +2 -> element after that, etc. Can be negative. Default = +1.
    skip_beginning : bool, optional
        If True then skip beginning element #0 when wrapping around. Default is False.
    follow_fork : bool, optional
        If True then fork at any fork element. Default is False.
    next_ele : 
    """
def pointer_to_ran_state(ran_state: _pybmad.RandomStateStruct | None = None, ix_thread: typing.SupportsInt | None = None) -> RandomStateStruct:
    """
    Routine to point to the appropriate state structure for generating random numbers
    
    Parameters
    ----------
    ran_state : RandomStateStruct, optional
        Point to this if present. Otherwise point to the global saved state.
    ix_thread : int, optional
        Thread index.
    
    Returns
    -------
    ran_state_ptr : RandomStateStruct
        Pointer to the appropriate state.
    """
def pointer_to_slave(lord: EleStruct, ix_slave: typing.SupportsInt, lord_type: typing.SupportsInt | None = None) -> ...:
    """
    Function to point to a slave of a lord.
    
    Parameters
    ----------
    lord : EleStruct
        Lord element
    ix_slave : int
        Index of the slave in the list of slaves controled by the lord..
    lord_type : int, optional
        See above.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    slave_ptr : EleStruct
        Pointer to the slave. Nullified if there is an error.
    control : ControlStruct
        Pointer to control info for this lord/slave relationship. Nullified if there is an error.
    ix_lord_back : int
        Index back to the lord. That is, pointer_to_lord(slave_ptr, ix_lord_back) will point back to the lord. Set
        to -1 if there is an error.
    ix_control : int
        Index in lat.control(:) array the control argument is at.
    ix_ic : int
        Index of the lat.ic(:) element associated with the control argument.
    
    Notes
    -----
    Related routines:
    pointer_to_lord pointer_to_super_lord pointer_to_ele num_lords
    """
def pointer_to_super_lord(slave: EleStruct, lord_type: typing.SupportsInt | None = None, lord_ptr: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    slave : EleStruct
        Slave element.
    control : ControlStruct
        Pointer to control info for this lord/slave relationship. Nullified if there is an error.
    ix_slave_back : int
        Index back to the slave. That is, pointer_to_slave(lord_ptr, ix_slave_back) will point back to slave. Set
        to -1 if there is an error or the slave is a slice_slave.
    ix_control : int
        Index in lat.control(:) array the control argument is at. For ramper lord elements, ix_control is index
        for the lord.control.ramper(:) array.
    ix_ic : int
        Index of the lat.ic(:) element associated with the control argument.
    lord_type : int, optional
        If present, only return a super_lord of this type.
    lord_ptr : 
    """
def pointer_to_surface_displacement_pt(ele: EleStruct, nearest: bool, x: typing.SupportsFloat, y: typing.SupportsFloat, ix: typing.SupportsInt | None = None, iy: typing.SupportsInt | None = None, extend_grid: bool | None = None, xx: typing.SupportsFloat | None = None, yy: typing.SupportsFloat | None = None) -> PyPointerToSurfaceDisplacementPt:
    """
    Routine to point to the grid point struct associated with point (x,y).
    
    Parameters
    ----------
    ele : EleStruct
        Element containing the grid
    nearest : bool
        If True, return pointer to nearest grid point. If False, return pointer to the grid point lower and left
        of (x,y). x, y        -- real(rp): Photon position.
    extend_grid : bool, optional
        If (x,y) past grid pretend (x,y) is at grid boundary. Default is False. ix, iy      -- integer, optional:
        Grid point index.
    
    Returns
    -------
    pt : GridPointStruct
        Pointer to grid point. Will not be associated if (x,y) outside the grid. xx, yy      -- real(rp),
        optional: Set equal to (x, y) except if (x,y) is outside of the grid. In this case, (xx, yy) will be set
        to be on the nearest grid boundary point.
    """
def pointer_to_surface_segmented_pt(ele: EleStruct, nearest: bool, x: typing.SupportsFloat, y: typing.SupportsFloat, ix: typing.SupportsInt | None = None, iy: typing.SupportsInt | None = None, extend_grid: bool | None = None, xx: typing.SupportsFloat | None = None, yy: typing.SupportsFloat | None = None) -> PyPointerToSurfaceSegmentedPt:
    """
    Routine to point to the grid point struct associated with point (x,y).
    
    Parameters
    ----------
    ele : EleStruct
        Element containing the grid
    nearest : bool
        If True, return pointer to nearest grid point. If False, return pointer to the grid point lower and left
        of (x,y). x, y        -- real(rp): Photon position.
    extend_grid : bool, optional
        If (x,y) past grid pretend (x,y) is at grid boundary. Default is False. ix, iy      -- integer, optional:
        Grid point index.
    
    Returns
    -------
    pt : GridPointStruct
        Pointer to grid point. Will not be associated if (x,y) outside the grid. xx, yy      -- real(rp),
        optional: Set equal to (x, y) except if (x,y) is outside of the grid. In this case, (xx, yy) will be set
        to be on the nearest grid boundary point.
    """
def pointer_to_wake_ele(ele: EleStruct, wake_ele: EleStruct) -> float:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    delta_s : float
        distance of wake locaiton from beginning of ele.
    wake_ele : 
    """
def pointer_to_wall3d(ele: EleStruct, ix_wall: typing.SupportsInt | None = None) -> ...:
    """
    Function to return a pointer to a wall3d structure associated
    
    with a given lattice element.
    
    Parameters
    ----------
    ele : EleStruct
        lattice element.
    ix_wall : int, optional
        index in wall3d(:) array. Default is 1.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    wall3d : Wall3DStruct
        Pointer to the associated wall structure. Will be nullified if there is no associated wall.
    ds_offset : float
        Element offset: s(beginning of ele) - s(beginning of wall3d)
    is_branch_wall : bool
        Set True if wall3d points to branch.wall3d.
    """
def polar_to_spinor(polar: SpinPolarStruct, spinor: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(2)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    polar : SpinPolarStruct
        includes polar phase
    spinor : 
    """
def polar_to_vec(polar: SpinPolarStruct, vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    polar : 
        Spin_polar_struct
    vec : 
    """
def poly_eval(poly: RealAlloc1D, x: typing.SupportsFloat, diff_coef: bool | None = None, y: typing.SupportsFloat) -> PyPolyEval:
    """
    No docstring available
    
    Parameters
    ----------
    poly : float
        Polynomial
    x : float
        Point to evaluate at.
    diff_coef : bool, optional
        poly(:) array are differentials? Default is False.
    y : 
    """
def probability_funct(x: typing.SupportsFloat, prob: typing.SupportsFloat) -> PyProbabilityFunct:
    """
    No docstring available
    
    Parameters
    ----------
    x : float
        Function argument.
    prob : 
    """
def projdd(a: ComplexAlloc1D, b: ComplexAlloc1D, func_retval__: complex) -> PyProjdd:
    """
    No docstring available
    
    Parameters
    ----------
    a : 
    b : 
    projdd : 
    """
def project_emit_to_xyz(ring: LatStruct, ix: typing.SupportsInt, mode: NormalModesStruct) -> ...:
    """
    Obtains the projected x, y, and z beamsizes by building the sigma matrix
    
    from the normal mode emittances and 1-turn transfer matrix.
    These projectes beamsize are what would be seen by instrumentation.
    This method of projecting takes into account transverse and longitudinal coupling.
    This method of obtaining the projected beam sizes is from "Alternitive approach to general
    coupled linear optics" by Andrzej Wolski.
    The normal mode emittances used to generate a beam envelop sigma matrix from the
    1-turn transfer matrix.  The projected sizes are from the 1, 1 3, 3 and 5, 5 elements of
    the sigma matrix.
    
    Parameters
    ----------
    ring : LatStruct
        the storage ring
    ix : int
        element at which to make the projection
    mode : NormalModesStruct
        normal mode emittances .a.emittance -- real(rp): a-mode emittance .b.emittance -- real(rp): b-mode
        emittance .z.emittance -- real(rp): z-mode emittance .a.tune      -- real(rp): a-mode tune.  Used to
        associate emittances with the proper mode. .b.tune      -- real(rp): b-mode tune.  Used to associate
        emittances with the proper mode.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    sigma_x : float
        projected horizontal beamsize
    sigma_y : float
        projected vertical beamsize
    sigma_z : float
        projected longitudinal beamsize
    """
def psi_prime_sca(t: typing.SupportsFloat, p: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> float:
    """
    This wraps the array-valued psi_prime function as a scalar.
    
    See psi_prime comments for details.
    
    Parameters
    ----------
    t : float
        time relative to RF bucket
    p : float
        psi(t)
    args : float
        parameters and constants of DEQ
    
    Returns
    -------
    dpdt : float
        dpsi_dt
    """
def ptc_bookkeeper(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Bmad lattice.
    """
def ptc_closed_orbit_calc(branch: BranchStruct, radiation_damping_on: bool | None = None) -> CoordStructAlloc1D:
    """
    Routine to calculate the closed orbit of a lattice branch using PTC.
    
    This routine assumes the associated PTC layout has been crated
    with lat_to_ptc_layout.
    
    Parameters
    ----------
    branch : BranchStruct
        Branch of a lattice.
    radiation_damping_on : bool, optional
        If True, radiation dampling is included in the calculation. -- logical, optional: If True, radiation
        dampling is included in the calculation. Default is the setting of bmad_com..radiation_damping_on.
    
    Returns
    -------
    closed_orbit : CoordStruct
        closed_orbit
    """
def ptc_emit_calc(ele: EleStruct, sigma_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    Routine to calculate emittances, etc.
    
    Parameters
    ----------
    ele : EleStruct
        Element at which to evaluate the parameters.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    norm_mode : 
        Normal_modes_struct %a%tune, %b%tune, %z%tune %a%alpha_damp, etc. %a%emittance, etc.
    sigma_map : float
        Sigma matrix (Bmad coordinates).
    closed_orb : CoordStruct
        Closed orbit at ele (Bmad coordinates). Notice: This closed orbit is the closed orbit with radiation on.
    """
def ptc_layouts_resplit(dKL_max: typing.SupportsFloat, l_max: typing.SupportsFloat, l_max_drift_only: bool, bend_dorb: typing.SupportsFloat, sex_dx: typing.SupportsFloat, even: bool | None = None, crossover: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"] | None = None, crossover_wiggler: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"] | None = None) -> None:
    """
    even, crossover, crossover_wiggler)
    
    Routine to resplit (that is, recalculate the number of integration steps for an element)
    For the fibres in all layouts. After doing a resplit, the tune (and any other relavent
    "adjustable" parameters) should be adjusted to the correct values.
    
    Parameters
    ----------
    dKL_max : float
        Maximum K1 * L quadrupole strength allowed for an integration step. Reasonable value would be something
        like 0.04.
    l_max : float
        Maximum step length. Ignored if set to 0.
    l_max_drift_only : bool
        If True then l_max is only used for splitting drifts. -- logical: If True then l_max is only used for
        splitting drifts.
    bend_dorb : float
        Residual bend orbit error. With some integration methods a zero orbit at the start of the bend will not be
        zero at the end. In this case, bend_dorb sets a maximum allowable orbit deviation. If set to zero, this
        argument will be ignored. A resonable value is 10d-7. Note that the actual orbit deviation is not simply
        related to bend_dorb and can be larger. In any case, lowering bend_dorb (without making it zero) will
        lower the
    sex_dx : float
        To split sextupoles, sex_dx is used as the reference position about which the quadrupole strength is
        calculated. This quadrupole strength is then used with dKL_max to calculate the number of integration
        steps. Set to zero to ignore.
    even : bool, optional
        If True then each fibre  will have an even number of steps. If False then the number of steps will be odd.
        If not present then number of steps is not constrained to be even or odd.
    crossover : int, optional
        crossover(1) sets the maximum number of 2nd order integration steps to use. If the number of steps would
        exceed crossover(1) then integration is switched to 4th order. crossover(2) sets the maximum number of 4th
        order integration steps. If this number is exceeded, 6th order integration is used. Currently the default
        in PTC is [4, 18].
    crossover_wiggler(2) : int, optional
        crossover for wiggler elements. -- integer, optional: crossover for wiggler elements.
    """
def ptc_one_turn_mat_and_closed_orbit_calc(branch: BranchStruct, pz: typing.SupportsFloat | None = None) -> None:
    """
    Routine to compute the transfer matrices for the individual elements and closed orbit
    
    for a lattice branch with closed geometry.
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch.
        This parameter is an input/output and is modified in-place. As an output: Lattice branch containing the
        matrices.
    pz : float, optional
        energy offset around which to calculate the matrices if there is no RF.
    """
def ptc_ran_seed_put(iseed: typing.SupportsInt) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    iseed : int
        0 -> Use system clock.
    """
def ptc_set_rf_state_for_c_normal(nocavity: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    nocavity : bool
        True -> RF is off and vice versa.
    """
def ptc_set_taylor_order_if_needed() -> None:
    """
    Routine to see if the taylor_order for PTC needs to be set/changed.
    
    For example, for a change in bmad_com%taylor_order.
    """
def ptc_spin_calc(ele: EleStruct, sigma_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    Routine to equilibrium polarizations, etc.
    
    Parameters
    ----------
    ele : EleStruct
        Element at which to evaluate the parameters.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    norm_mode : 
        Normal_modes_struct %a%tune, %b%tune, %z%tune %a%alpha_damp, etc. %a%emittance, etc.
    sigma_map : float
        Sigma matrix (Bmad coordinates).
    closed_orb : CoordStruct
        Closed orbit at ele (Bmad coordinates). Notice: This closed orbit is the closed orbit with radiation on.
    """
def ptc_track_all(branch: BranchStruct, orbit: CoordStructAlloc1D) -> ...:
    """
    Routine to track from the start to the end of a lattice branch.
    
    Parameters
    ----------
    branch : LatStruct
        Lat to track through.
    orbit : CoordStruct
        Coordinates at beginning of branch.
        This parameter is an input/output and is modified in-place. As an output: Orbit array.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    track_state : int
        Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
    err_flag : bool
        Set true if particle lost or error. False otherwise
    """
def ptc_transfer_map_with_spin(branch: BranchStruct, t_map: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"], s_map: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(4)"], orb0: CoordStruct, ix1: typing.SupportsInt | None = None, ix2: typing.SupportsInt | None = None, one_turn: bool | None = None, unit_start: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch used in the calculation.
    t_map : TaylorStruct
        Initial orbital map (used when unit_start = False)
        This parameter is an input/output and is modified in-place. As an output: Orbital transfer map.
    s_map : TaylorStruct
        Initial spin map (used when unit_start = False)
        This parameter is an input/output and is modified in-place. As an output: Quaternion spin transfer map.
    orb0 : CoordStruct
        Initial orbit around which the map is made.
    err_flag : bool
        Set True if problem like number overflow, etc.
    ix1 : int, optional
        Element start index for the calculation. Default is 0.
    ix2 : int, optional
        Element end index for the calculation. Default is branch.n_ele_track.
    one_turn : bool, optional
        If present and True, and if ix1 = ix2, and the lattice is circular, then construct the one-turn map from
        ix1 back to ix1. Default = False.
    unit_start : bool, optional
        If present and False then t_map will be used as the starting map instead of the unit map. Default = True
    """
def pwd_mat(lat: LatStruct, t6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], inductance: typing.SupportsFloat, sig_z: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    Calculates potential well distortion as RF defocusing.  Calculates t6_pwd=t6.Mpwd,
    
    where Mpwd is identity with 65 element proportional to the inductance.
    Vpwd = -inductance * lat%param%n_part * e_charge * c_light**3 / SQRT(twopi) / sig_z**3 / omega_RF  !effective RF voltage from PWD
    Mpwd(6,5) = omega_RF * Vpwd / c_light / lat%ele(0)%value(E_TOT$) * branch%ele(i)%value(l$) / lat%param%total_length
    
    Parameters
    ----------
    lat : LatStruct
        Bunch current in # per bunch .ele(0).value(E_TOT$) -- real(rp): Beam energy
    t6 : float
        1-turn transfer matrix
    inductance : float
        Longitudinal inductance in Henrys.  Something on the order of nH.
    sig_z : float
        Bunch length.
    
    Returns
    -------
    t6_pwd : float
        1-turn transfer matrix with PWD defocusing applied
    """
def quadratic_roots(coefs: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], root: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(2)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    coefs : float
        Coefficients of the quadratic equation with 0 = coefs(1) + coefs(2) * x + coefs(3) * x^2
    root : 
    """
@typing.overload
def quat_conj(q_in: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"]) -> typing.Annotated[list[complex], "FixedSize(4)"]:
    """
    Routine to create the conjugate of a quaternian.
    
    Overloaded by quat_conj.
    
    Parameters
    ----------
    q_in : float
        Quaternion input.
    
    Returns
    -------
    q_out : float
        Conjugate quaternion.
    """
@typing.overload
def quat_conj(q_in: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    Routine to create the conjugate of a quaternian.
    
    Overloaded by quat_conj.
    
    Parameters
    ----------
    q_in : float
        Quaternion input.
    
    Returns
    -------
    q_out : float
        Conjugate quaternion.
    """
def quat_inverse(q_in: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    Routine to create the inverse of a quaternian.
    
    Parameters
    ----------
    q_in : float
        Quaternion input.
    
    Returns
    -------
    q_out : float
        Inverse quaternion.
    """
@typing.overload
def quat_mul(q1: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"], q2: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"], q3: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None, q4: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None, q5: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None, q6: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None, q7: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None, q8: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None, q9: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"] | None = None) -> typing.Annotated[list[complex], "FixedSize(4)"]:
    """
    Routine to multiply quaternions q_out = q1 * q2 * q3 * q4 * ...
    
    Overloaded by quat_mul.
    
    Parameters
    ----------
    q1 : complex
        Quaternions.
    q3 : complex, optional
        More quaternions.
    
    Returns
    -------
    q_out : complex
        Resultant q1 * q2
    """
@typing.overload
def quat_mul(q1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], q2: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], q3: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None, q4: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None, q5: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None, q6: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None, q7: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None, q8: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None, q9: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    Routine to multiply quaternions q_out = q1 * q2 * q3 * q4 * ...
    
    Overloaded by quat_mul.
    
    Parameters
    ----------
    q1 : float
        Quaternions.
    q3 : float, optional
        More quaternions.
    
    Returns
    -------
    q_out : float
        Resultant q1 * q2
    """
@typing.overload
def quat_rotate(quat: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(4)"], vec_in: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(3)"]) -> typing.Annotated[list[complex], "FixedSize(3)"]:
    """
    Routine to rotate a vector using a quaternion..
    
    Parameters
    ----------
    quat : complex
        Quaternion to rotate with. Does not have to be normalized.
    vec_in : complex
        Initial vector.
    
    Returns
    -------
    vec_out : complex
        Final vector.
    """
@typing.overload
def quat_rotate(quat: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], vec_in: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> typing.Annotated[list[float], "FixedSize(3)"]:
    """
    Routine to rotate a vector using a quaternion..
    
    Parameters
    ----------
    quat : float
        Quaternion to rotate with. Does not have to be normalized.
    vec_in : float
        Initial vector.
    
    Returns
    -------
    vec_out : float
        Final vector.
    """
def quat_to_axis_angle(quat: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]) -> ...:
    """
    Routine to convert from quaternion to axis + angle representation.
    
    The angle will be in the range 0 <= angle <= pi.
    
    Parameters
    ----------
    quat : float
        Rotation quaternion. Assumed normalized.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    axis : float
        Axis of rotation.
    angle : float
        angle of rotation in range [0, pi].
    """
def quat_to_omega(quat: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]) -> typing.Annotated[list[float], "FixedSize(3)"]:
    """
    Routine to convert rotation from quaternion representation to omega (axis + angle).
    
    Parameters
    ----------
    quat : float
        Rotation quaternion. Assumed normalized.
    
    Returns
    -------
    omega : float
        Axis of rotation + magnitude = rotation angle.
    """
def quat_to_w_mat(quat: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
    """
    Routine to construct the 3D rotation matrix w_mat given a rotation quaternion
    
    Parameters
    ----------
    quat : float
        Quaternion.
    
    Returns
    -------
    w_mat : float
        Rotation matrix
    """
def query_string(query_str: str, upcase: bool, return_str: str, ix: typing.SupportsInt, ios: typing.SupportsInt) -> PyQueryString:
    """
    No docstring available
    
    Parameters
    ----------
    query_str : 
    upcase : 
    return_str : 
    ix : 
    ios : 
    """
def quote(str: str, q_str: str) -> PyQuote:
    """
    No docstring available
    
    Parameters
    ----------
    str : 
    q_str : 
    """
def rad1_damp_and_stoc_mats(ele: EleStruct, include_opening_angle: bool, orb_in: CoordStruct, orb_out: CoordStruct, g2_tol: typing.SupportsFloat, g3_tol: typing.SupportsFloat, ele0: _pybmad.EleStruct | None = None) -> ...:
    """
    Routine to calculate the damping and stochastic matrices for a given lattice element.
    
    Parameters
    ----------
    ele : EleStruct
        Element under consideration.
    include_opening_angle : bool
        If True include the effect of the vertical opening angle of emitted radiation. Generally use True unless
        comparing against other codes.
    orb_in : CoordStruct
        Entrance orbit about which to compute the matrices.
    orb_out : CoordStruct
        Exit orbit.
    g2_tol : float
        Tollerance on g^2 per unit length (damping tolerance).
    g3_tol : float
        Tollerance on g^3 per unit length (stocastic tolerance).
    ele0 : EleStruct, optional
        Element before `ele`. Needed if and only if rad_int1 is present
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    rad_map : RadMapStruct
        Damping and stochastic matrices. .stoc_mat             -- Variance matrix.
    err_flag : bool
        Set true if there is an error. False otherwise.
    rad_int1 : RadInt1Struct
        Radiation integrals
    """
def rad_damp_and_stoc_mats(ele1: EleStruct, ele2: EleStruct, include_opening_angle: bool, closed_orbit: _pybmad.CoordStructAlloc1D | None = None) -> ...:
    """
    Routine to calculate the damping and stochastic variance matrices from exit end of ele1
    
    to the exit end of ele2. Use ele1 = ele2 to get 1-turn matrices.
    If ele2 is before ele1 the integration range if from ele1 to the branch end plus
    from the beginning to ele2.
    
    Parameters
    ----------
    ele1 : EleStruct
        Start element of integration range.
    ele2 : EleStruct
        End element of integration range.
    include_opening_angle : bool
        If True include the effect of the vertical opening angle of emitted radiation. Generally use True unless
        comparing against other codes.
    closed_orbit : CoordStruct, optional
        Closed orbit. If not present this routine will calculate it.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    rmap : RadMapStruct
        Damping and stochastic mats .stoc_mat               --  stochastic variance matrix.
    mode : NormalModesStruct
        .dpz_damp                 -- Change in pz without RF. .pz_average               -- Average pz due to
        damping.
    xfer_nodamp_mat : float
        Transfer matrix without damping.
    rad_int_branch : RadIntBranchStruct
        Array of element-by-element radiation integrals.
    err_flag : bool
        Set true if there is a problem.
    """
def rad_g_integrals(ele: EleStruct, where: typing.SupportsInt, orb_in: CoordStruct, orb_out: CoordStruct, int_g2: typing.SupportsFloat, int_g3: typing.SupportsFloat, g_tol: typing.SupportsFloat, g2_tol: typing.SupportsFloat, g3_tol: typing.SupportsFloat) -> PyRadGIntegrals:
    """
    Routine to calculate bending strength integrals (g(s) = 1/trajectory_bending_radius(s)) in
    
    laboratory coords.
    
    Parameters
    ----------
    ele : EleStruct
        Element under consideration.
    where : int
        What part of ele to integrate over. upstream$ -> 1st half of element, downsteam$ -> 2nd half, all$ ->
        everything.
    orb_in : CoordStruct
        Entrance orbit about which to compute the matrices.
    orb_out : CoordStruct
        Exit orbit.
    g_tol : float
        Tollerance on |g| per unit length.
    g2_tol : float
        Tollerance on g^2 per unit length.
    g3_tol : float
        Tollerance on g^3 per unit length.
    
    Returns
    -------
    int_g : float
        Integrals of (gx,gy) vector. gint_g2, int_g3       -- real(rp): integrals of |g|^2 and |g|^3.
    """
def radiation_integrals(lat: LatStruct, orbit: CoordStructAlloc1D, ix_cache: typing.SupportsInt | None = None, ix_branch: typing.SupportsInt | None = None) -> PyRadiationIntegrals:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to use. The calculation assumes that the Twiss parameters have been calculated.
    orbit : CoordStruct
        Closed orbit for the branch.
    mode : NormalModesStruct
        Parameters for the ("horizontal like") a-mode, ("vertical like") b-mode, and the z-mode .synch_int(0:3) --
        Synchrotron integrals. See Bmad manual .sigE_E         -- Sigma_E/E energy spread .sig_z          -- Bunch
        Length .e_loss         -- Energy loss in eV per turn .a, .b, .z      -- Anormal_mode_struct: Substructure
        .emittance      -- Emittance. B-mode emit includes photon opening angle (I6) contribution. .synch_int(4:6)
        -- Synchrotron integrals .j_damp         -- Damping partition factor .alpha_damp     -- Exponential
        damping coefficient per turn .lin            -- Linac version of the integrals. .i2_E4           --
        Integral: g^2 * gamma^4 .i3_E7           -- Integral: g^3 * gamma^7 .i5a_E6          -- Integral: (g^3 *
        H_a) * gamma^6 .i5b_E6          -- Integral: (g^3 * H_b) * gamma^6 .sig_E1          -- Energy spread after
        1 pass (eV) .a_emittance_end -- a-mode emittance at end of linac .b_emittance_end -- b-mode emittance at
        end of linac
    ix_cache : int, optional
        Cache pointer. = -2 --> No temporary wiggler cache. This is slow so only use as a check. = -1 --> Use
        temporary cache for wiggler elements only (default). =  0 --> Create a new cache for all elements. >  0
        --> Use the corresponding cache.
        This parameter is an input/output and is modified in-place. As an output: Cache pointer. If ix_cache = 0
        at input then
    ix_branch : int, optional
        Lattice branch index. Default is 0.
    rad_int_by_ele : RadIntAllEleStruct
        Radiation integrals element by element. .branch(ix_branch).ele(0:) -- Array of rad_int1_struct structures,
        one for each element in the branch. Notes: 1) .synch_int(1) = momentum_compaction * lat_length 2) The
        lin_norm_emit values are running sums from the beginning of the lattice and include the beginning
        emittance stored in lat.a.emit and lat.b.emit.
    """
def radiation_map_setup(ele: EleStruct, ref_orbit_in: _pybmad.CoordStruct | None = None) -> bool:
    """
    Routine to calculate the radiation kick for a lattice element.
    
    Parameters
    ----------
    ele : EleStruct
        Element whose map is to be setup.
        This parameter is an input/output and is modified in-place. As an output: Element with map calculated.
    ref_orb : CoordStruct, optional
        If present, ignore ele_map.stale setting and make the map around this reference orbit.
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def ramper_slave_setup(lat: LatStruct, force_setup: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to be setup.
        This parameter is an input/output and is modified in-place. As an output: Lattice with ramper slaves
        setup.
    force_setup : bool, optional
        Default False. If True, do the setup even if lat.ramper_slave_bookkeeping = ok$. But the setup will never
        be done if lat.ramper_slave_bookkeeping = super_ok$.
    """
def ramper_value(ramper: EleStruct, r1: ControlRamp1Struct, value: typing.SupportsFloat) -> PyRamperValue:
    """
    No docstring available
    
    Parameters
    ----------
    ramper : EleStruct
        Ramper lord.
    r1 : ControlRamp1Struct
        Slave function.
    err_flag : bool
        Set True if there is an error, False otherwise.
    value : 
    """
def ran_default_state(set_state: _pybmad.RandomStateStruct | None = None) -> RandomStateStruct:
    """
    Routine to set or get the state of the default random number generator.
    
    See the ran_seed_put documentation for more details
    
    Parameters
    ----------
    set_state : RandomStateStruct, optional
        State to set the default generator to.
    
    Returns
    -------
    get_state : RandomStateStruct
        Returns the state of the default generator.
    """
def ran_engine(set: str | None = None, get: str | None = None, ran_state: _pybmad.RandomStateStruct | None = None) -> None:
    """
    Routine to set what random number generator algorithm is used.
    
    If this routine is never called then pseudo_random$ is used.
    With sobseq quasi-random numbers the maximum dimension is 6.
    
    Parameters
    ----------
    set : unknown, optional
        Set the random number engine. Possibilities are: 'pseudo' -> Uses ran from Numerical Recipies (F90).
        'quasi'  -> Uses sobseq from Numerical Recipes. ''       -> Do nothing.
    get : unknown, optional
        Get the current (before any set) random number engine.
    ran_state : RandomStateStruct, optional
        Internal state. See the ran_seed_put documentation for more details.
    """
def ran_gauss_converter(set: str | None = None, set_sigma_cut: typing.SupportsFloat | None = None, ran_state: _pybmad.RandomStateStruct | None = None) -> ...:
    """
    Routine to set what conversion routine is used for converting
    
    uniformly distributed random numbers to Gaussian distributed random numbers.
    If this routine is not called then exact_gaussian$ is used.
    exact_gaussian$ is a straight forward converter as explained in Numerical recipes.
    quick_gaussian$ is a quick a dirty approximation with a cutoff so that no
    numbers will be generated beyound what is set for sigma_cut.
    A negative sigma_cut means that the exact_gaussian$ will not be limited
    and the quick_gaussian$ will use a default of 10.0
    
    Parameters
    ----------
    set : unknown, optional
        Set the random number engine. Possibilities are: 'exact' 'quick'  ! Old deprecated: 'limited' ''       !
        Do nothing
    set_sigma_cut : float, optional
        Sigma cutoff. Initially: sigma_cut = -1.
    ran_state : RandomStateStruct, optional
        Internal state. See the ran_seed_put documentation for more details.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    get : unknown
        Get the current (before any set) gaussian converter.
    get_sigma_cut : float
        Get the current (before any set) sigma cutoff.
    """
def ran_gauss_scalar(ran_state: _pybmad.RandomStateStruct | None = None, sigma_cut: typing.SupportsFloat | None = None, index_quasi: typing.SupportsInt | None = None) -> PyRanGaussScalar:
    """
    Routine to return a gaussian distributed random number with unit sigma.
    
    See ran_gauss for more details.
    
    
    Notes
    -----
    Note: The index_quasi argument is used internally for the quasi-random number generator.
    """
def ran_gauss_vector(ran_state: _pybmad.RandomStateStruct | None = None, sigma_cut: typing.SupportsFloat | None = None) -> PyRanGaussVector:
    """
    Routine to return a gaussian distributed random number with unit sigma.
    
    See ran_gauss for more details.
    """
def ran_seed_get() -> int:
    """
    Routine to return the seed used for the random number generator.
    
    Parameters
    ----------
    ran_state : RandomStateStruct, optional
        Internal state. See the ran_seed_put documentation for more details.
    
    Returns
    -------
    seed : int
        Random number seed used.
    """
def ran_seed_put(seed: typing.SupportsInt, mpi_offset: typing.SupportsInt | None = None) -> None:
    """
    Routine to seed a random number generator.
    
    If a program never calls ran_seed_put, or ran_seed_put is called with seed = 0,
    the system clock will be used to generate the seed.
    
    Parameters
    ----------
    seed : int
        Seed number. If seed = 0 then a seed will be choosen based upon the system clock.
    mpi_offset : int, optional
        Offset added to seed. Default is zero. Used with MPI processes ensure different threads use different
        random numbers.
    
    Notes
    -----
    Note: The seed is only used with the pseudo_random$ engine.
    Note: Use the subroutine ran_seed_get(seed) to get the seed used.
    """
@typing.overload
def ran_uniform(ran_state: _pybmad.RandomStateStruct | None = None, index_quasi: typing.SupportsInt | None = None) -> PyRanUniformScalar:
    """
    Routine to return a random number uniformly distributed in the
    
    interval [0, 1].
    See ran_uniform for more details.
    
    
    Notes
    -----
    Note: The index_quasi argument is used internally for the quasi-random number generator.
    """
@typing.overload
def ran_uniform(ran_state: _pybmad.RandomStateStruct | None = None) -> RealAlloc1D:
    """
    Routine to return a vector of random numbers uniformly distributed in the
    
    interval [0, 1].
    See ran_uniform for more details.
    """
def randomize_lr_wake_frequencies(ele: EleStruct) -> bool:
    """
    Routine to randomize the frequencies of the lr wake HOMs according to:
    
    freq = freq_in * (1 + lr_freq_spread) * rr)
    where rr is a Gaussian distributed random number with unit variance.
    
    Parameters
    ----------
    ele : EleStruct
        Element with wake. If no wake then nothing is done. .value(freq_in$)        -- Frequency.
        This parameter is an input/output and is modified in-place. As an output: Element with wake frequencies
        set.
    
    Returns
    -------
    set_done : bool
        Set True if there where lr wakes to be set. False otherwise.
    """
def rchomp(rel: typing.SupportsFloat, plc: typing.SupportsInt, out: str) -> PyRchomp:
    """
    No docstring available
    
    Parameters
    ----------
    rel : 
    plc : 
    out : 
    """
@typing.overload
def re_allocate(section: Wall3DSectionStructAlloc1D, n: typing.SupportsInt, exact: bool | None = None) -> None:
    """
    Routine to reallocate an array of wall3d%section(:).
    
    Overloaded by re_allocate.
    
    Parameters
    ----------
    section : Wall3DSectionStruct
        Array of vertices
        This parameter is an input/output and is modified in-place. As an output: Allocated array.
    n : int
        Minimum size needed for array.
    exact : bool, optional
        If present and False then the size of the output array is permitted to be larger than n. Default is True.
    """
@typing.overload
def re_allocate(v: Wall3DVertexStructAlloc1D, n: typing.SupportsInt, exact: bool | None = None) -> None:
    """
    Routine to reallocate an array of vertex structures.
    
    Overloaded by re_allocate.
    
    Parameters
    ----------
    v : Wall3DVertexStruct
        Array of vertices
        This parameter is an input/output and is modified in-place. As an output: Allocated array.
    n : int
        Minimum size needed for array.
    exact : bool, optional
        If present and False then the size of the output array is permitted to be larger than n. Default is True.
    """
def re_allocate_c_double(re: RealAlloc1D, n: typing.SupportsInt, exact: bool | None = None, init_val: typing.SupportsFloat | None = None) -> PyReAllocateCDouble:
    """
    Routine to reallocate an array of c_double reals.
    
    This is modeled after the reallocate functions in Numerical Recipes.
    
    Parameters
    ----------
    re : float
        Real array.
        This parameter is an input/output and is modified in-place. As an output: Allocated array with size(re) >=
        n.
    n : int
        Size wanted.
    exact : bool, optional
        If present and False then the size of the output array is permitted to be larger than n. Default is True.
    """
def re_allocate_eles(eles: ElePointerStructAlloc1D, n: typing.SupportsInt, save_old: bool | None = None, exact: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    eles : ElePointerStruct
        Array of element pointers with possible old data.
        This parameter is an input/output and is modified in-place. As an output: Array of element pointers.
    n : int
        Array size to set.
    save_old : bool, optional
        If present and True then save the old data.
    exact : bool, optional
        If present and True then eles will have size = n If False (default), reallcation will not be done if eles
        is already large enough
    """
def re_associate_node_array(tree: ExpressionTreeStruct, n: typing.SupportsInt, exact: bool | None = None) -> None:
    """
    Routine to resize the tree%node(:) array.
    
    Parameters
    ----------
    tree : ExpressionTreeStruct
    n : int
        Size wanted.
    exact : bool, optional
        Default is False. If False, the size of the output array is permitted to be larger than n.
    """
@typing.overload
def re_str(rel: typing.SupportsFloat, str_out: str) -> PyReStrQp:
    """
    No docstring available
    
    Parameters
    ----------
    rel : 
    str_out : 
    """
@typing.overload
def re_str(rel: typing.SupportsFloat, str_out: str) -> PyReStrRp:
    """
    No docstring available
    
    Parameters
    ----------
    rel : 
    str_out : 
    """
def read_beam_ascii(file_name: str, beam_init: BeamInitStruct) -> ...:
    """
    Subroutine to read in a beam definition file.
    
    If non_zero, the following components of beam_init are used to rescale the beam:
    %n_bunch
    %n_particle
    %charge_tot
    If the beam file has '.h5' or '.hdf5' suffix then the file is taken to be an HDF5 file.
    Otherwise the file is assumed to be ASCII.
    
    Parameters
    ----------
    iu : int
        File unit number
    file_name : unknown
        Name of beam file.
    beam_init : BeamInitStruct
        See above.
    ele : EleStruct, optional
        Element with reference energy, etc.
    print_mom_shift_warning : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    shift_momentum : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    beam : BeamStruct
        Structure holding the beam information.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def read_beam_file(file_name: str, beam_init: BeamInitStruct, ele: _pybmad.EleStruct | None = None, print_mom_shift_warning: bool | None = None, conserve_momentum: bool | None = None) -> PyReadBeamFile:
    """
    Subroutine to read in a beam definition file.
    
    If non_zero, the following components of beam_init are used to rescale the beam:
    %n_bunch
    %n_particle
    %bunch_charge -> charge_tot
    %species
    If the beam file has '.h5' or '.hdf5' suffix then the file is taken to be an HDF5 file.
    Otherwise the file is assumed to be ASCII.
    
    Parameters
    ----------
    file_name : unknown
        Name of beam file.
    beam_init : BeamInitStruct
        See above.
    ele : EleStruct, optional
        Element with reference energy, etc.
    print_mom_shift_warning : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    shift_momentum : bool, optional
        Default is True. See hdf5_read_beam doc. Only used when reading hdf5 file.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    beam : BeamStruct
        Structure holding the beam information.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def read_binary_cartesian_map(file_name: str, ele: EleStruct, cart_map: CartesianMapStruct, err_flag: bool) -> None:
    """
    Routine to read a binary cartesian_map structure.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    ele : EleStruct
        Element associated with the map. Ouput:
    cart_map : 
        cartesian_map_struct, cartesian map.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def read_binary_cylindrical_map(file_name: str, ele: EleStruct, cl_map: CylindricalMapStruct, err_flag: bool) -> None:
    """
    Routine to read a binary cylindrical_map structure.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    ele : EleStruct
        Element associated with the map. Ouput:
    cl_map : 
        cylindrical_map_struct, cylindrical map.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def read_binary_grid_field(file_name: str, ele: EleStruct, g_field: GridFieldStruct, err_flag: bool) -> None:
    """
    Routine to read a binary grid_field structure.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    ele : EleStruct
        Element associated with the map. Ouput:
    g_field : 
        grid_field_struct, cylindrical map.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def read_surface_reflection_file(file_name: str) -> PhotonReflectSurfaceStruct:
    """
    Routine to read the reflection probability data for a given type of surface from a file.
    
    Parameters
    ----------
    file_name : unknown
        Name of the file.
    
    Returns
    -------
    surface : PhotonReflectSurfaceStruct
        Surface info.
    """
def real_num_fortran_format(number: typing.SupportsFloat, width: typing.SupportsInt, n_blanks: typing.SupportsInt | None = None, fmt_str: str) -> PyRealNumFortranFormat:
    """
    No docstring available
    
    Parameters
    ----------
    number : 
    width : 
    n_blanks : 
    fmt_str : 
    """
def real_path(path_in: str, path_out: str, is_ok: bool) -> PyRealPath:
    """
    No docstring available
    
    Parameters
    ----------
    path_in : 
    path_out : 
    is_ok : 
    """
def real_str(r_num: typing.SupportsFloat, n_signif: typing.SupportsInt | None = None, n_decimal: typing.SupportsInt | None = None, str: str) -> PyRealStr:
    """
    No docstring available
    
    Parameters
    ----------
    r_num : 
    n_signif : 
    n_decimal : 
    str : 
    """
def real_to_string(real_num: typing.SupportsFloat, width: typing.SupportsInt, n_signif: typing.SupportsInt | None = None, n_decimal: typing.SupportsInt | None = None, str: str) -> PyRealToString:
    """
    No docstring available
    
    Parameters
    ----------
    real_num : 
    width : 
    n_signif : 
    n_decimal : 
    str : 
    """
def reallocate_beam(beam: BeamStruct, n_bunch: typing.SupportsInt, n_particle: typing.SupportsInt | None = None, extend: bool | None = None) -> PyReallocateBeam:
    """
    No docstring available
    
    Parameters
    ----------
    beam : BeamStruct
        Beam bunches are saved if save = True.
        This parameter is an input/output and is modified in-place. As an output: Allocated beam_struct structure.
    n_bunch : int
        Number of bunches.
    n_particle : int, optional
        Number of particles. Must be non-negative. If save = True then the number of particles in existing bunches
        will not be touched. If not present, beam.bunch(i).particle(:) will be in an undefined state.
    extend : 
    """
def reallocate_bp_com_const() -> None:
    """
    No docstring available
    """
def reallocate_bunch(n_particle: typing.SupportsInt, save: bool | None = None) -> BunchStruct:
    """
    No docstring available
    
    Parameters
    ----------
    bunch : BunchStruct
        Allocated bunch_struct structure.
    n_particle : int
        Number of particles. Must be non-negative.
    save : bool, optional
        If present and True then save the old bunch info.
    """
def reallocate_control(lat: LatStruct, n: typing.SupportsInt) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice.
    n : int
        Array size for lat.control(:) and lat.ic(:).
    """
@typing.overload
def reallocate_coord(coord_array: CoordArrayStructAlloc1D, lat: LatStruct) -> None:
    """
    Routine to allocate or reallocate at allocatable coord_struct array.
    
    reallocate_coord_n (coord, n_coord)
    reallocate_coord_lat (coord, lat, ix_branch)
    Subroutine to allocate an allocatable coord_struct array to at least:
    coord(0:n_coord)                            if n_coord arg is used.
    coord(0:lat%branch(ix_branch)%n_ele_max)    if lat arg is used.
    The old coordinates are saved
    If, at input, coord(:) is not allocated, coord(0)%vec is set to zero.
    In any case, coord(n)%vec for n > 0 is set to zero.
    
    Parameters
    ----------
    coord : CoordStruct
        Allocatable array.
        This parameter is an input/output and is modified in-place. As an output: Allocated array.
    n_coord : int
        Minimum array upper bound wanted.
    lat : LatStruct
        Lattice
    ix_branch : int, optional
        Branch to use. Default is 0 (main branch).
    
    Notes
    -----
    Overloaded versions:
    """
@typing.overload
def reallocate_coord(coord: CoordStructAlloc1D, lat: LatStruct, ix_branch: typing.SupportsInt | None = None) -> None:
    """
    Routine to allocate or reallocate at allocatable coord_struct array.
    
    reallocate_coord_n (coord, n_coord)
    reallocate_coord_lat (coord, lat, ix_branch)
    Subroutine to allocate an allocatable coord_struct array to at least:
    coord(0:n_coord)                            if n_coord arg is used.
    coord(0:lat%branch(ix_branch)%n_ele_max)    if lat arg is used.
    The old coordinates are saved
    If, at input, coord(:) is not allocated, coord(0)%vec is set to zero.
    In any case, coord(n)%vec for n > 0 is set to zero.
    
    Parameters
    ----------
    coord : CoordStruct
        Allocatable array.
        This parameter is an input/output and is modified in-place. As an output: Allocated array.
    n_coord : int
        Minimum array upper bound wanted.
    lat : LatStruct
        Lattice
    ix_branch : int, optional
        Branch to use. Default is 0 (main branch).
    
    Notes
    -----
    Overloaded versions:
    """
@typing.overload
def reallocate_coord(coord: CoordStructAlloc1D, n_coord: typing.SupportsInt) -> None:
    """
    Routine to allocate or reallocate at allocatable coord_struct array.
    
    reallocate_coord_n (coord, n_coord)
    reallocate_coord_lat (coord, lat, ix_branch)
    Subroutine to allocate an allocatable coord_struct array to at least:
    coord(0:n_coord)                            if n_coord arg is used.
    coord(0:lat%branch(ix_branch)%n_ele_max)    if lat arg is used.
    The old coordinates are saved
    If, at input, coord(:) is not allocated, coord(0)%vec is set to zero.
    In any case, coord(n)%vec for n > 0 is set to zero.
    
    Parameters
    ----------
    coord : CoordStruct
        Allocatable array.
        This parameter is an input/output and is modified in-place. As an output: Allocated array.
    n_coord : int
        Minimum array upper bound wanted.
    lat : LatStruct
        Lattice
    ix_branch : int, optional
        Branch to use. Default is 0 (main branch).
    
    Notes
    -----
    Overloaded versions:
    """
def reallocate_expression_stack(stack: ExpressionAtomStructAlloc1D, n: typing.SupportsInt, exact: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    stack : unknown
        Existing stack array.
        This parameter is an input/output and is modified in-place. As an output: Resized stack.
    n : int
        Array size needed.
    exact : bool, optional
        If present and False then the size of the output array is permitted to be larger than n. Default is True.
    """
def reallocate_spline(spline: SplineStructAlloc1D, n: typing.SupportsInt, n_min: typing.SupportsInt | None = None, exact: bool | None = None) -> None:
    """
    Subroutine to allocate an allocatable spline_struct array.
    
    The data of the array is preserved but data at the end of the
    array will be lost if n is less than the original size of the array
    
    Parameters
    ----------
    spline : SplineStruct
        Spline to reallocate.
        This parameter is an input/output and is modified in-place. As an output: Allocated spline.
    n : int
        Upper bound needed for 1-dimensional arrays.
    n_min : int, optional
        Lower bound of spline array. Default is 1.
    exact : bool, optional
        If present and False then the size of the output array is permitted to be larger than n. Default is True.
    """
def rel_tracking_charge_to_mass(orbit: CoordStruct, ref_species: typing.SupportsInt, rel_charge: typing.SupportsFloat) -> PyRelTrackingChargeToMass:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle position structure.
    ref_species : int
        Reference species
    rel_charge : 
    """
def relative_mode_flip(ele1: EleStruct, ele2: EleStruct, func_retval__: bool) -> PyRelativeModeFlip:
    """
    No docstring available
    
    Parameters
    ----------
    ele1 : 
    ele2 : 
    relative_mode_flip : 
    """
def release_rad_int_cache(ix_cache: typing.SupportsInt) -> PyReleaseRadIntCache:
    """
    Subroutine to release the memory associated with caching wiggler values.
    
    See the radiation_integrals routine for further details.
    
    Parameters
    ----------
    ix_cache : int
        Cache number.
        This parameter is an input/output and is modified in-place. As an output: Cache number set to 0,
    """
def remove_constant_taylor(taylor_in: TaylorStructAlloc1D, remove_higher_order_terms: bool) -> ...:
    """
    Subroutine to remove the constant part of a taylor map.
    
    Optionally terms that are higher order than bmad_com%taylor_order can
    be removed.
    
    Parameters
    ----------
    taylor_in : TaylorStruct
        Input taylor map.
    remove_higher_order_terms : bool
        If True then terms that are higher order than bmad_com.taylor_order are removed.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    taylor_out : TaylorStruct
        Taylor with constant terms removed.
    c0 : float
        The constant part of the taylor map
    """
def remove_dead_from_bunch(bunch_in: BunchStruct) -> BunchStruct:
    """
    No docstring available
    
    Parameters
    ----------
    bunch_in : BunchStruct
        Input bunch with alive and dead particles.
    bunch_out : BunchStruct
        Output bunch with only alive and pre_born particles. Note: bunch_out can be the same actual argument as
        bunch_in.
    """
def remove_eles_from_lat(lat: LatStruct, check_sanity: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to compress.
        This parameter is an input/output and is modified in-place. As an output: Compressed lattice.
    check_sanity : bool, optional
        If True (default) then call lat_sanity_check
    """
def remove_lord_slave_link(lord: EleStruct, slave: EleStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lord : EleStruct
        Lord element
        This parameter is an input/output and is modified in-place. As an output: Lord element with link info
        removed
    slave : EleStruct
        Slave element
        This parameter is an input/output and is modified in-place. As an output: Slave element with link info
        removed
    """
def reverse_lat(lat_in: LatStruct, track_antiparticle: bool | None = None) -> LatStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat_in : LatStruct
        Input lattice to reverse.
    lat_rev : LatStruct
        Reversed lattice.
    track_antiparticle : bool, optional
        Set the particle species of the reversed lat to the anti-particle of lat_in? Default is True.
    """
def rf_cav_names(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    """
def rf_coupler_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, phase: typing.SupportsFloat, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    import
    
    implicit none
    type (branch_struct), target :: branch
    integer n_rf_included, n_rf_excluded
    logical ok
    end function
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through
    param : LatParamStruct
        branch parameters.
    particle_at : int
        first_track_edge$, or second_track_edge$.
    phase : float
        phase of cavity
    orbit : CoordStruct
        Position before kick.
        This parameter is an input/output and is modified in-place. As an output: Position after kick.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
        element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    
    Returns
    -------
    ok
    """
def rf_is_on(branch: BranchStruct, ix_ele1: typing.SupportsInt | None = None, ix_ele2: typing.SupportsInt | None = None, is_on: bool) -> PyRfIsOn:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch to check.
    ix_ele1 : int, optional
        Start of range of elements to check. Default is 0.
    ix_ele2 : int, optional
        End of range of elements to check. Default is branch.n_ele_track.
    is_on : 
    """
def rf_ref_time_offset(ele: EleStruct, ds: typing.SupportsFloat | None = None, time: typing.SupportsFloat) -> PyRfRefTimeOffset:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        RF Element being tracked through.
    ds : float, optional
        Distance of particle from start edge. Default is zero. Ouput:
    time : 
    """
def rfun(u: typing.SupportsFloat, v: typing.SupportsFloat, w: typing.SupportsFloat, gam: typing.SupportsFloat, a: typing.SupportsFloat, b: typing.SupportsFloat, hz: typing.SupportsFloat, i: typing.SupportsInt, j: typing.SupportsInt, res: typing.SupportsFloat) -> PyRfun:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    v : 
    w : 
    gam : 
    a : 
    b : 
    hz : 
    i : 
    j : 
    res : 
    """
def rk_adaptive_time_step(ele: EleStruct, param: LatParamStruct, orb: CoordStruct, t_dir: typing.SupportsInt, rf_time: typing.SupportsFloat, dt_try: typing.SupportsFloat, dt_did: typing.SupportsFloat, dt_next: typing.SupportsFloat, err_flag: bool, extra_field: _pybmad.EmFieldStruct | None = None) -> PyRkAdaptiveTimeStep:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    param : 
    orb : 
    t_dir : 
    rf_time : 
    dt_try : 
    dt_did : 
    dt_next : 
    err_flag : 
    extra_field : 
    """
def rk_time_step1(ele: EleStruct, param: LatParamStruct, rf_time: typing.SupportsFloat, orb: CoordStruct, dt: typing.SupportsFloat, new_orb: CoordStruct, dr_dt: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(10)"] | None = None, err_flag: bool, print_err: bool | None = None, extra_field: _pybmad.EmFieldStruct | None = None) -> PyRkTimeStep1:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    param : 
    rf_time : 
    orb : 
    dt : 
    new_orb : 
    r_err : 
    dr_dt : 
    err_flag : 
    print_err : 
    extra_field : 
    """
def rms_value(val_arr: RealAlloc1D, good_val: _pybmad.BoolAlloc1D | None = None, rms_val: typing.SupportsFloat) -> PyRmsValue:
    """
    No docstring available
    
    Parameters
    ----------
    val_arr : float
        Array of reals.
    good_val : bool, optional
        If present, only calculate RMS where good_val(i) = True.
    ave_val : float
        average value.
    rms_val : 
    """
def rot_2d(vec_in: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], angle: typing.SupportsFloat, vec_out: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    vec_in : float
        Init vec
    angle : float
        angle in radians.
    vec_out : 
    """
def rotate3(vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], angle: typing.SupportsFloat, rvec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> PyRotate3:
    """
    No docstring available
    
    Parameters
    ----------
    vec : 
    angle : 
    rvec : 
    """
def rotate_em_field(field: EmFieldStruct, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"], w_inv: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"], calc_dfield: bool | None = None, calc_potential: bool | None = None) -> None:
    """
    Routine to transform the fields using the given rotation matrices.
    
    Parameters
    ----------
    field : EmFieldStruct
        E and B fields and derivatives.
    w_mat : float
        rotation matrix.
    w_inv : float
        rotation matrix inverse = transpose(w_mat)
    calc_dfield : bool, optional
        If present and True then rotate the field derivatives.
    calc_potential : bool, optional
        Rotate the magnetic vector potential? Default is false.
    """
def rotate_field_zx(field: EmFieldStruct, theta: typing.SupportsFloat) -> PyRotateFieldZx:
    """
    No docstring available
    
    Parameters
    ----------
    field : 
    theta : 
    """
def rotate_for_curved_surface(ele: EleStruct, orbit: CoordStruct, set: bool, rot_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        reflecting element
    orbit : CoordStruct
        Photon position.
    set : bool
        True -> Transform body coords to local curved body coords. False -> Transform local curved body to body
        coords.
    rot_mat : float
        When set = False, rotation matrix calculated from previous call with set = True.
        This parameter is an input/output and is modified in-place. As an output: When set = True, calculated
        rotation matrix.
    """
def rotate_spin(rot_vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], spin: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    No docstring available
    
    Parameters
    ----------
    rot_vec : float
        Rotation axis. Magnitude of rot_vec is the rotation angle.
    spin : float
        Initial coords.
        This parameter is an input/output and is modified in-place. As an output: Final coords.
    qrot : float
        : rotation quaternion.
    """
def rotate_spin_a_step(orbit: CoordStruct, field: EmFieldStruct, ele: EleStruct, ds: typing.SupportsFloat) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Initial orbit.
        This parameter is an input/output and is modified in-place. As an output: Orbit with rotated spin
    field : EmFieldStruct
        EM Field
    ele : 
        ele_struct, Element being tracked through.
    ds : float
        Longitudinal step in element body frame.
    """
def rotate_spin_given_field(orbit: CoordStruct, sign_z_vel: typing.SupportsInt, BL: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None, EL: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None, qrot: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"] | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Initial orbit.
        This parameter is an input/output and is modified in-place. As an output: Orbit with rotated spin
    sign_z_vel : int
        +/- 1. Sign of direction of travel relative to the element.
    BL : float, optional
        Integrated field strength. Assumed zero if not present.
    EL : float, optional
        Integrated field strength. Assumed zero if not present.
    qrot : float, optional
        Initial rotation quaternion.
        This parameter is an input/output and is modified in-place. As an output: Rotation quaternion with
        rotation due to the field added in.
    """
def rotate_vec(vec: RealAlloc1D, axis: typing.SupportsInt, angle: typing.SupportsFloat) -> None:
    """
    Basic routine to rotate vector components around the x, y, or z axis.
    
    Parameters
    ----------
    vec : float
        vector
        This parameter is an input/output and is modified in-place. As an output: Rotated vector.
    axis : int
        x_axis$, y_axis$, or z_axis$
    angle : float
        angle to rotate.
    """
def rotate_vec_given_axis_angle(vec_in: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], axis: RealAlloc1D, angle: typing.SupportsFloat) -> typing.Annotated[list[float], "FixedSize(3)"]:
    """
    Routine to rotate a vector.
    
    Parameters
    ----------
    vec_in : float
        Initial vector.
    axis : float
        Axis of rotation. Must be normalized to 1.
    angle : float
        Angle to rotate by
    
    Returns
    -------
    vec_out : float
        Final vector.
    """
def rp8(int_in: typing.SupportsInt) -> float:
    """
    Routine to convert from integer to real of type rp.
    
    This routine is used to avoid the implicit integer to single precision that happens when
    multiplying int*real(rp).
    
    Parameters
    ----------
    int_in : int
        Input integer.
    
    Returns
    -------
    re_out : float
        Equiv real.
    """
def run_timer(command: str, time: typing.SupportsFloat | None = None, time0: typing.SupportsFloat | None = None) -> PyRunTimer:
    """
    No docstring available
    
    Parameters
    ----------
    command : 
    time : 
    time0 : 
    """
def s_body_calc(orbit: CoordStruct, ele: EleStruct, s_body: typing.SupportsFloat) -> PySBodyCalc:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle coordinates.
    ele : EleStruct
        Lattice element
    s_body : 
    """
def s_calc(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
    """
def sad_mult_hard_bend_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Routine to track through the hard edge bend fringe field for a bend or sad_mult element.
    
    Only the bend field is taken into account here. Higher order multipolse must be handled elsewhere.
    This routine assumes that the particle coordinates are with respect to the actual magnet face.
    Thus finite e1/e2 must be taken into account by other routines.
    SAD calls this the "linear" fringe even though it is nonlinear.
    
    Parameters
    ----------
    ele : EleStruct
        Element with fringe.
    param : LatParamStruct
        Tracking parameters.
    particle_at : int
        Either first_track_edge$ or second_track_edge$.
    orbit : CoordStruct
        Starting coordinates.
        This parameter is an input/output and is modified in-place. As an output: Ending coordinates.
    mat6 : float, optional
        Transfer matrix up to the fringe.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
        fringe.
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    """
def sad_soft_bend_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orb: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Subroutine to track through the ("linear") bend soft edge field of an sbend or sad_mult.
    
    Parameters
    ----------
    ele : EleStruct
        SBend or sad_mult element.
    param : LatParamStruct
    particle_at : int
        first_track_edge$, or second_track_edge$.
    orb : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Coords after tracking.
    mat6 : float, optional
        Starting matrix
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix after fringe
        field
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    k0l : float, optional
        Used with sad_mult. If present, use this instead of ele.a_pole/.b_pole.
    t0 : float, optional
        Used with sad_mult. If present, use this instead of ele.a_pole/.b_pole. Must be present if k0l is.
    """
def save_a_beam_step(ele: EleStruct, beam: BeamStruct, bunch_tracks: _pybmad.BunchTrackStructAlloc1D | None = None, s_body: typing.SupportsFloat | None = None, is_time_coords: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through.
    beam : BeamStruct
        Bunches in the beam whose parameters are to be saved.
    bunch_tracks : BunchTrackStruct, optional
        Track with current bunch info appended on. This routine does nothing if this argument is not present.
    s_body : float, optional
        Body s-position from beginning of element.
    is_time_coords : bool, optional
        Default is False. If True, input beam is using time coordinates in which case there will be a conversion
        to s-coords before bunch_params are computed. Ouput:
    """
def save_a_bunch_step(ele: EleStruct, bunch: BunchStruct, bunch_track: _pybmad.BunchTrackStruct | None = None, s_body: typing.SupportsFloat | None = None, is_time_coords: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through.
    bunch : BunchStruct
        Bunch whose parameters are to be saved.
    bunch_track : BunchTrackStruct, optional
        Track with current bunch info appended on. This routine does nothing if this argument is not present.
    s_body : float, optional
        Body s-position from beginning of element.
    is_time_coords : bool, optional
        Default is False. If True, input bunch is using time coordinates in which case there will be a conversion
        to s-coords before bunch_params are computed. Ouput:
    """
def save_a_step(track: TrackStruct, ele: EleStruct, param: LatParamStruct, local_ref_frame: bool, orb: CoordStruct, s_rel: typing.SupportsFloat, save_field: bool | None = None, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None, rf_time: typing.SupportsFloat | None = None, strong_beam: _pybmad.StrongBeamStruct | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    track : TrackStruct
        Track with current position appended on.
    ele : EleStruct
        Element being tracked through.
    param : LatParamStruct
        Lattice parameters.
    local_ref_frame : bool
        If True then input orb is with respect to body coordinates.
    orb : CoordStruct
        trajectory at s with respect to element coordinates.
    s_rel : float
        Longitudinal position wrt the element. If local_ref_frame = F: Lab coords. If local_ref_frame = T: body
        coords.
    save_field : bool, optional
        Save electric and magnetic field values? Default is False.
    mat6 : float, optional
        Matrix to store.
    make_matrix : bool, optional
        Is mat6 a valid matrix? Default is False.
    rf_time : float, optional
        RF clock time used for calculating the field.. If not present then the time will be calculated using the
        standard algorithm. This is only needed if save_field = True.
    strong_beam : StrongBeambeamStruct, optional
        Strong beam info if tracking through a beambeam element. Ouput:
    """
def sbend_body_with_k1_map(ele: EleStruct, dg: typing.SupportsFloat, b1: typing.SupportsFloat, param: LatParamStruct, n_step: typing.SupportsInt, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Sbend element.
    dg : float
        Field error.
    b1 : float
        b1 quadrupole strength * rel_charge_dir
    param : LatParamStruct
        Branch parameters.
    n_step : int
        Number of steps to divide the bend into. Only one step is taken by this routine.
    orbit : CoordStruct
        Orbit at beginning of the bend.
        This parameter is an input/output and is modified in-place. As an output: Ending coordinates.
    mat6 : float, optional
        Transfer matrix before element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix with body added
        in.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def sc_adaptive_step(bunch: BunchStruct, ele: EleStruct, include_image: bool, t_now: typing.SupportsFloat, dt_step: typing.SupportsFloat, sc_field: EmFieldStructAlloc1D) -> PyScAdaptiveStep:
    """
    Routine to track a bunch of particles with space charge for one step using
    
    adaptive step size control and determine appropriate step size for the next step
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position in t-based coordinates
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position in t-based
        coordinates.
    ele : EleStruct
        Nominal lattice element being tracked through.
    include_image : bool
        Include image charge forces?
        This parameter is an input/output and is modified in-place. As an output: Set False if image charge calc
        no longer needed (Note
    t_now : float
        Current time at the beginning of tracking
    dt_step : float
        Initial SC time step to take
        This parameter is an input/output and is modified in-place. As an output: Step done.
    sc_field : unknown
        : Array to hold space charge fields. Its length should be the number of particles.
    
    Returns
    -------
    dt_next : float
        Next SC time step the tracker would take based on the error tolerance
    """
def sc_step(bunch: BunchStruct, ele: EleStruct, include_image: bool, t_end: typing.SupportsFloat, sc_field: EmFieldStructAlloc1D) -> PyScStep:
    """
    Subroutine to track a bunch through a given time step with space charge
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position in t-based coordinates
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position in t-based
        coordinates after space charge kick.
    ele : EleStruct
        Nominal element being tracked through.
    include_image : bool
        Include image charge forces?
        This parameter is an input/output and is modified in-place. As an output: Set False if image charge calc
        no longer needed (Note
    t_end : float
        Time at which the tracking ends.
    sc_field : unknown
        : Array to hold space charge fields. Its length should be the number of particles.
    
    Returns
    -------
    n_emit : int
        The number of particles emitted in this step.
    """
def set_active_fixer(fixer: EleStruct, turn_on: bool | None = None) -> CoordStruct:
    """
    Set the acvitive fixer element.
    
    All other fixer/beginning_ele elements in the branch will be deactivated.
    If turn_on is True (default), the fixer argument becomes the active fixer.
    If turn_on is False, and fixer%is_on is also False, there is nothing to be done.
    If turn_on is False, and fixer%is_on is True, turn this fixer off and turn on the beginning element.
    
    Parameters
    ----------
    fixer : EleStruct
        Fixer element to make active.
        This parameter is an input/output and is modified in-place. As an output: Element is now active.
    turn_on : bool, optional
        If True (default), make this fixer the active element. If False, make the beginning element active.
    
    Returns
    -------
    orbit : CoordStruct
        Load with stored fixer phase space and spin values.
    """
def set_custom_attribute_name(custom_name: str, custom_index: typing.SupportsInt | None = None) -> bool:
    """
    Routine to add custom element attributes to the element attribute name table.
    
    Parameters
    ----------
    custom_name : unknown
        Name of the custom attribute. If prefixed by "<class>::" then the custom name will be set only for that
        element class. Example: "quadrupole::error" will set the alias custom namefor quadrupoles.
    custom_index : int, optional
        Index used in assigning where in the ele_struct the custom attribute is put. If not present or 0 then the
        next unused slot is used.
    
    Returns
    -------
    err_flag : bool
        Set True if an error. False otherwise.
    """
def set_ele_attribute(ele: EleStruct, set_string: str, err_print_flag: bool | None = None, set_lords: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with attribute to set.
        This parameter is an input/output and is modified in-place. As an output: Element with attribute set.
    set_string : unknown
        Attribute and value for set.
    err_flag : bool
        Set True if there is an error, False otherwise.
    err_print_flag : bool, optional
        If present and False then suppress printing of an error message if attribute is, for example, not free.
    set_lords : bool, optional
        Default False. If True, set the super_lord(s) if the element is a super_slave.
    err_id : int
        Set to an integer which identifies the error type. 0 = no error. The higher the error the further along
        the error was encountered.
    """
def set_ele_defaults(ele: EleStruct, do_allocate: bool | None = None) -> None:
    """
    import
    
    implicit none
    type (lat_struct) lat
    type (coord_struct), optional :: orb(0:)
    integer key
    logical on_switch
    end subroutine
    
    Parameters
    ----------
    ele : EleStruct
        Element to init. .key          -- Type of element.
        This parameter is an input/output and is modified in-place. As an output: Initialized element.
    do_allocate : bool, optional
        Do default allocation of element components? Default is True.
    """
def set_ele_name(ele: EleStruct, name: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element whose name is to be set.
        This parameter is an input/output and is modified in-place. As an output: Element with name set.
    name : unknown
        Name to set.
    """
def set_ele_real_attribute(ele: EleStruct, attrib_name: str, value: typing.SupportsFloat, err_print_flag: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with attribute to set.
        This parameter is an input/output and is modified in-place. As an output: Element with attribute set.
    attrib_name : unknown
        Attribute name.
    value : float
        value to set to.
    err_flag : bool
        Set True if there is an error, False otherwise.
    err_print_flag : bool, optional
        If present and False then suppress printing of an error message if attribute is, for example, not free.
    """
def set_ele_status_stale() -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element. .bookkeeping_state   -- Status block to set.
    status_group : int
        Which flag groups to set. Possibilities are: attribute_group$, control_group$, floor_position_group$,
        s_position_group$, s_and_floor_position_group$, ref_energy_group$, or mat6_group$, all_groups$
    set_slaves : bool
        If present and False then do not set the status for any slaves. Default is True.
    """
def set_emit_from_beam_init(beam_init_in: BeamInitStruct, ele: EleStruct, species: typing.SupportsInt, modes: _pybmad.NormalModesStruct | None = None, err_flag: bool | None = None, beam_init_set: BeamInitStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    beam_init_in : BeamInitStruct
        Input parameters
    ele : EleStruct
    species : int
        Beam particle species.
    modes : NormalModesStruct, optional
        Normal mode parameters. Used if stuff like beam_init_in.a_emit set negative. Ouput:
    err_flag : bool, optional
        Set true if there is an error. False otherwise.
    beam_init_set : 
    """
@typing.overload
def set_flags_for_changed_attribute(ele: EleStruct, attrib: typing.SupportsInt, set_dependent: bool | None = None) -> PySetFlagsForChangedIntegerAttribute:
    """
    Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.
    
    Also will do some dependent variable bookkeeping when a particular attribute has
    been altered.
    This routine should be called after the attribute has been set.
    set_flags_for_changed_lat_attribute (lat, set_dependent)
    set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
    set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
    set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
    set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
    The set_flags_for_changed_lat_attribute (lat) routine is used when one
    does not know what has changed and wants a complete bookkeeping done.
    And NOT:
    call set_flags_for_changed_attribute (ele, off_value)  ! WRONG
    
    Parameters
    ----------
    lat : LatStruct
        Lattice being modified.
        This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
        changes.
    ele : 
        ele_struct, Element being modified.
    real_attrib : float, optional
        Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
        potentially changed.
    int_attrib : int
        Attribute that has been changed. For example: ele.mat6_calc_method.
    logic_attrib : unknown
        ele.is_on.
    all_attrib : AllPointerStruct
        Pointer to attribute.
    set_dependent : bool, optional
        If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
        when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
        doing.
    
    Notes
    -----
    NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
    off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
    Overloaded versions:
    """
@typing.overload
def set_flags_for_changed_attribute(lat: LatStruct, set_dependent: bool | None = None) -> None:
    """
    Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.
    
    Also will do some dependent variable bookkeeping when a particular attribute has
    been altered.
    This routine should be called after the attribute has been set.
    set_flags_for_changed_lat_attribute (lat, set_dependent)
    set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
    set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
    set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
    set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
    The set_flags_for_changed_lat_attribute (lat) routine is used when one
    does not know what has changed and wants a complete bookkeeping done.
    And NOT:
    call set_flags_for_changed_attribute (ele, off_value)  ! WRONG
    
    Parameters
    ----------
    lat : LatStruct
        Lattice being modified.
        This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
        changes.
    ele : 
        ele_struct, Element being modified.
    real_attrib : float, optional
        Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
        potentially changed.
    int_attrib : int
        Attribute that has been changed. For example: ele.mat6_calc_method.
    logic_attrib : unknown
        ele.is_on.
    all_attrib : AllPointerStruct
        Pointer to attribute.
    set_dependent : bool, optional
        If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
        when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
        doing.
    
    Notes
    -----
    NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
    off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
    Overloaded versions:
    """
@typing.overload
def set_flags_for_changed_attribute(ele: EleStruct, attrib: bool, set_dependent: bool | None = None) -> PySetFlagsForChangedLogicalAttribute:
    """
    Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.
    
    Also will do some dependent variable bookkeeping when a particular attribute has
    been altered.
    This routine should be called after the attribute has been set.
    set_flags_for_changed_lat_attribute (lat, set_dependent)
    set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
    set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
    set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
    set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
    The set_flags_for_changed_lat_attribute (lat) routine is used when one
    does not know what has changed and wants a complete bookkeeping done.
    And NOT:
    call set_flags_for_changed_attribute (ele, off_value)  ! WRONG
    
    Parameters
    ----------
    lat : LatStruct
        Lattice being modified.
        This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
        changes.
    ele : 
        ele_struct, Element being modified.
    real_attrib : float, optional
        Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
        potentially changed.
    int_attrib : int
        Attribute that has been changed. For example: ele.mat6_calc_method.
    logic_attrib : unknown
        ele.is_on.
    all_attrib : AllPointerStruct
        Pointer to attribute.
    set_dependent : bool, optional
        If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
        when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
        doing.
    
    Notes
    -----
    NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
    off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
    Overloaded versions:
    """
@typing.overload
def set_flags_for_changed_attribute(ele: EleStruct, attrib: typing.SupportsFloat | None = None, set_dependent: bool | None = None) -> PySetFlagsForChangedRealAttribute:
    """
    Routine to mark an element or lattice as modified for use with "intelligent" bookkeeping.
    
    Also will do some dependent variable bookkeeping when a particular attribute has
    been altered.
    This routine should be called after the attribute has been set.
    set_flags_for_changed_lat_attribute (lat, set_dependent)
    set_flags_for_changed_real_attribute (ele, real_attrib, set_dependent)
    set_flags_for_changed_inteter_attribute (ele, int_attrib, set_dependent)
    set_flags_for_changed_logical_attribute (ele, logic_attrib, set_dependent)
    set_flags_for_changed_all_attribute (ele, all_attrib, set_dependent)
    The set_flags_for_changed_lat_attribute (lat) routine is used when one
    does not know what has changed and wants a complete bookkeeping done.
    And NOT:
    call set_flags_for_changed_attribute (ele, off_value)  ! WRONG
    
    Parameters
    ----------
    lat : LatStruct
        Lattice being modified.
        This parameter is an input/output and is modified in-place. As an output: Lattice with appropriate
        changes.
    ele : 
        ele_struct, Element being modified.
    real_attrib : float, optional
        Attribute that has been changed. For example: ele.value(hkick$). If not present then assume everything has
        potentially changed.
    int_attrib : int
        Attribute that has been changed. For example: ele.mat6_calc_method.
    logic_attrib : unknown
        ele.is_on.
    all_attrib : AllPointerStruct
        Pointer to attribute.
    set_dependent : bool, optional
        If False then dependent parameter bookkeeping will not be done. False is used, for example, during parsing
        when dependent bookkeepin is not wanted. Default is True. Do not set False unless you know what you are
        doing.
    
    Notes
    -----
    NOTE: The attribute argument MUST be the component that was changed. For example: ele%value(x_offset$) =
    off_value call set_flags_for_changed_attribute (ele, ele%value(x_offset$))
    Overloaded versions:
    """
def set_fringe_on_off(fringe_at: typing.SupportsFloat, ele_end: typing.SupportsInt, on_or_off: typing.SupportsInt) -> PySetFringeOnOff:
    """
    No docstring available
    
    Parameters
    ----------
    fringe_at : float
        Present fringe_at setting. entrance_end$, exit_end$, both_ends$, or no_end$
        This parameter is an input/output and is modified in-place. As an output: Modified fringe setting.
    ele_end : int
        Element edge: entrance_end$ or exit_end$
    on_or_off : int
        Turn on$ or off$
    """
def set_lords_status_stale(ele: EleStruct, stat_group: typing.SupportsInt, control_bookkeeping: bool | None = None, flag: typing.SupportsInt | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    stat_group : int
        which status group to set. floor_position_group$, etc. See set_ele_status_stale for more details.
    control_bookkeeping : bool, optional
        Call control_bookkeeper for each lord if needed? -- logical, optional: Call control_bookkeeper for each
        lord if needed? Default if False.
    flag : int, optional
        Do not use. For coordinating recursion. ele.lat    -- Lat_struct: Lattice with status flags of lords of
        ele set.
    """
def set_on_off(key: typing.SupportsInt, lat: LatStruct, switch_: typing.SupportsInt, orb: _pybmad.CoordStructAlloc1D | None = None, use_ref_orb: bool | None = None, ix_branch: typing.SupportsInt | None = None, saved_values: _pybmad.RealAlloc1D | None = None, attribute: str | None = None, set_val: typing.SupportsInt | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    key : int
        Class name of elements to be turned on or off. [quadrupole$, etc.]
    lat : LatStruct
        lattice structure holding the elements.
        This parameter is an input/output and is modified in-place. As an output: Modified lattice.
    switch : int
        on$            => Turn elements on. If saved_values argument is present, use this. If not present (only
        for logical attributes), set to True. off$           => Turn elements off (but will not store the present
        state). off_and_save$  => Save on/off state and then turn elements off. save_state$    => Save present
        on/off state. No turning on or off is done. restore_state$ => Restore saved on/off state from saved_values
        argument.
    orb : CoordStruct, optional
        Needed for lat_make_mat6
    use_ref_orb : bool, optional
        If present and true then use ele.map_ref_orb for the reference orbit for calculating .mat6. Default is
        false.
    ix_branch : int, optional
        If present then only set for this lattice branch.
    saved_values : float, optional
        Element-by element saved values of the component. Must be present if needed (EG if switch =
        restore_state$, etc.).
        This parameter is an input/output and is modified in-place. As an output: Saved values of the component.
    attribute : unknown, optional
        Attribute to turn on/off. Eg: 'K2', 'MULTIPOLE_ON', etc. Default is 'IS_ON'. Must be upper case.
    set_val : int, optional
        Value to set to. Overrides normal set value.
    """
def set_orbit_to_zero(n1: typing.SupportsInt, n2: typing.SupportsInt, ix_noset: typing.SupportsInt | None = None) -> CoordStructAlloc1D:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Array with particle positions in the range orbit(n1:n2) set to zero except for orbit(ix_noset).
    n1 : int
        Lower bound of orbit(:) array subset.
    n2 : int
        Upper bound of orbit(:) array subset.
    ix_noset : int, optional
        If present then orbit(ix_noset) will not be zeroed.
    """
@typing.overload
def set_parameter(param_val: typing.SupportsInt, set_val: typing.SupportsInt, save_val: typing.SupportsInt) -> PySetParameterInt:
    """
    No docstring available
    
    Parameters
    ----------
    param_val : 
    set_val : 
    save_val : 
    """
@typing.overload
def set_parameter(param_val: bool, set_val: bool, save_val: bool) -> PySetParameterLogic:
    """
    No docstring available
    
    Parameters
    ----------
    param_val : 
    set_val : 
    save_val : 
    """
@typing.overload
def set_parameter(param_val: typing.SupportsFloat, set_val: typing.SupportsFloat, save_val: typing.SupportsFloat) -> PySetParameterReal:
    """
    No docstring available
    
    Parameters
    ----------
    param_val : 
    set_val : 
    save_val : 
    """
def set_ptc(e_tot: typing.SupportsFloat | None = None, particle: typing.SupportsInt | None = None, taylor_order: typing.SupportsInt | None = None, integ_order: typing.SupportsInt | None = None, n_step: typing.SupportsInt | None = None, no_cavity: bool | None = None, force_init: bool | None = None) -> None:
    """
    import
    
    implicit none
    type (ele_struct), target :: ele
    type (coord_struct) orbit
    real(rp) rf_time
    logical reference_active_edge
    end subroutine
    
    Parameters
    ----------
    e_tot : float, optional
        Energy in eV.
    particle : int, optional
        Type of particle: electron$, proton$, etc.
    taylor_order : int, optional
        Maximum order of the taylor polynomials. 0 => Use default.
    integ_order : int, optional
        Default Order for the drift-kick-drift sympletic integrator. Possibilities are: 2, 4, or 6 Default = 2
    n_step : int, optional
        Default Number of integration steps. Default = 1
    no_cavity : bool, optional
        No RF Cavity exists? Default = False. Corresponds to the nocavity option of the PTC init routine.
        no_cavity = .true. will turn any cavity into a drift.
    force_init : bool, optional
        If present and True then force a PTC init.
    """
def set_ptc_base_state(component: str, set_val: bool) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    component : unknown
        Name of component. "TOTALPATH", "SPIN", "NOCAVITY", "TIME", etc. See the PTC internal_state structure for
        component names.
    set_val : bool
        Value to set to. For TOTALPATH, True => 1, False => 0.
    old_val : bool
        Old value.
    """
def set_ptc_com_pointers() -> None:
    """
    Routine to set ptc_com pointers to PTC global variables.
    """
def set_ptc_quiet(channel: typing.SupportsInt, set: bool, old_val: typing.SupportsInt) -> PySetPtcQuiet:
    """
    Routine to set the lielib_print(:) array or c_verbose logical to suppress informational messages
    
    that can clutter the output from a program using PTC.
    
    Parameters
    ----------
    channel : int
        Index in the lielib_print(:) array to set. 0 => c_verbose.
    set : bool
        If set$ then set lielib_print(:). If unset$ then undo a previous set$.
    old_val : int
        Old value needed for set = unset$.
        This parameter is an input/output and is modified in-place. As an output: Saved value for set = set$.
    """
def set_ptc_verbose(on: bool) -> PySetPtcVerbose:
    """
    No docstring available
    
    Parameters
    ----------
    on : 
    """
def set_pwd_ele(lat: LatStruct, mode0: NormalModesStruct, inductance: typing.SupportsFloat) -> None:
    """
    Simulates the effect of potential well distortion by adjusting lat%ele(ix_pwd)%taylor(6)%term(2)%coef for an
    
    element in the lattice.  This element will apply a pz kick based on the z coordinate.
    Element is assumed to be at lat%ele(1).  The ibs_ring driver program
    inserts a taylor element into lat%ele(1) if set to perform pwd calculations.
    
    Parameters
    ----------
    lat : LatStruct
        lattice
    mode0 : NormalModesStruct
        .sig_z and .z.sige_e should be populated before calling this subroutine.
    inductance : float
        An inductance-like parameter describing the distortion of the potential well.
    
    Returns
    -------
    sigma : float
        Bunch length
    """
def set_species_charge(species_in: typing.SupportsInt, charge: typing.SupportsInt) -> int:
    """
    Routine to return the ID for a particle of the same type as species_in but with a different charge.
    
    Exception: If species_in corresponds to a subatomic particle, the charge argument is ignored and
    species_charged will be set equal to species_in.
    
    Parameters
    ----------
    species_in : int
        Input species.
    charge : int
        Charge to set species_charged to.
    
    Returns
    -------
    species_charged : int
        Species of the same type as species_in but with different charge.
    """
def set_status_flags(stat: typing.SupportsInt) -> BookkeepingStateStruct:
    """
    No docstring available
    
    Parameters
    ----------
    bookkeeping_state : BookkeepingStateStruct
    stat : int
        bookkeeping status. ok$, stale$, etc.
    """
def set_tune(phi_a_set: typing.SupportsFloat, phi_b_set: typing.SupportsFloat, dk1: RealAlloc1D, eles: ElePointerStructAlloc1D, branch: BranchStruct, orb: CoordStructAlloc1D, print_err: bool | None = None, ok: bool) -> PySetTune:
    """
    No docstring available
    
    Parameters
    ----------
    phi_a_set : float
        Horizontal set tune (radians)
    phi_b_set : float
        Vertical set tune (radians)
    dk1 : float
        Relative amount to vary a quad in tuning. The variation will be proportional to dk1. Those quads with a
        positive dk1(i) will be varied as one group and the quads with negative dk1(i) will be varied as another
        group. The routine choose_quads_for_set_tune can be used to calculate values for dk1.
    eles : ElePointerStruct
        eles(i).ele points to quadrupole corresponding to dk1(i).
    branch : BranchStruct
        Lattice branch to tune.
        This parameter is an input/output and is modified in-place. As an output: Q_tuned lattice branch
    orb : CoordStruct
        If RF is off: Energy dE/E at which the tune is computed.
        This parameter is an input/output and is modified in-place. As an output: New closed orbit.
    print_err : bool, optional
        Print error message if there is a problem? Default is True.
    ok : 
    """
def set_tune_3d(branch: BranchStruct, target_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], mask: str | None = None, use_phase_trombone: bool | None = None, z_tune_set: bool | None = None, group_knobs: typing.Annotated[collections.abc.Sequence[str], "FixedSize(2)"] | None = None, print_err: bool | None = None, everything_ok: bool) -> PySetTune3d:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        This parameter is an input/output and is modified in-place. As an output: with adjusted quads and RF to
        match desired tunes.
    target_tunes : float
        tunes for a, b, z modes (rad/2pi). Must include integer part.
    mask : 
    use_phase_trombone : bool, optional
        Default False. If true, use a match element in phase trombone mode to adjust the tunes. The match element
        must be the first element in the lattice. Use insert_phase_trombone to insert one.
    z_tune_set : bool, optional
        Default True. If false, do not try to set the synch tune.
    group_knobs : unknown, optional
        If set non-blank, use these group elements for tuning.
    print_err : bool, optional
        Print error message if there is a problem? Default is True.
    everything_ok : 
    """
def set_twiss(branch: BranchStruct, twiss_ele: EleStruct, ix_ele: typing.SupportsInt, match_deta_ds: bool, err_flag: bool, print_err: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Branch to modify.
    twiss_ele : EleStruct
        Element with desired Twiss parameters.
    ix_ele : int
        Match branch.ele(ix_ele) Twiss to twiss_ele.
    match_deta_ds : bool
        If True, match deta_ds. If False, match etap.
    err_flag : bool
        Set True if there is an error. False otherwise.
    print_err : bool, optional
        Print an error message if there is an error? Default is True.
    """
def set_z_tune(branch: BranchStruct, z_tune: typing.SupportsFloat, print_err: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
    z_tune : float
        Longitudinal tune in radians (must be negative above transition).
    ok : bool
        If present, returns true or false if set was successful. If not present, set_z_tune will bomb if tune
        could not be set. Notes: 1) The calculation assumes that Q_z < 1. 2) By convention a positive tune
        signifies a clockwise rotation in phase space so that the transverse tunes are positive. This means the
        longitudinal tune is negative above transition.
    print_err : bool, optional
        Default is True. If False, suppress error messages
    """
def settable_dep_var_bookkeeping(ele: EleStruct) -> None:
    """
    Subroutine to initialize dependent variables in an element.
    
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    """
def setup_high_energy_space_charge_calc(calc_on: bool, branch: BranchStruct, n_part: typing.SupportsFloat, mode: NormalModesStruct, closed_orb: _pybmad.CoordStructAlloc1D | None = None) -> None:
    """
    Routine to initialize constants needed by the ultra relativistic space charge
    
    tracking routine track1_high_energy_space_charge. This setup routine must be called if
    the lattice or any of the other input parameters are changed.
    
    Parameters
    ----------
    calc_on : bool
        Turns on or off the space charge calculation.
    branch : BranchStruct
        Lattice for tracking.
    n_part : float
        Number of actual particles in a bunch. Used to compute the bunch charge.
    mode : NormalModesStruct
        Structure holding the beam info. .a.emittance  -- a-mode unnormalized emittance. .b.emittance  -- b-mode
        unnormalized emittance. .sig_z        -- Real(rp): Bunch length. .sigE_E       -- Real(rp): Sigma_E/E
        relative energy spread
    closed_orb : CoordStruct, optional
        Closed orbit. If not present the closed orbit is taken to be zero.
    """
def sigma_mat_ptc_to_bmad(sigma_mat_ptc: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], beta0: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    Routine to convert a PTC sigma matrix to a Bmad sigma matrix.
    
    The conversion includes the conversion between Bmad and PTC time coordinate systems.
    Since PTC uses delta_E/P0c and Bmad uses delta_P/P0c coordinates, and since
    the relationship between delta_E and delta_P is nonlinear, this routine
    simplifies the calculation and assumes that the particle beta is constant
    over the range of particle energies.
    
    Parameters
    ----------
    sigma_mat_ptc : float
        PTC sigma matrix.
    beta0 : float
        Reference particle velocity
    
    Returns
    -------
    sigma_mat_bmad : float
        Bmad sigma matrix.
    """
def significant_difference(value1: typing.SupportsFloat, value2: typing.SupportsFloat, abs_tol: typing.SupportsFloat | None = None, rel_tol: typing.SupportsFloat | None = None, is_different: bool) -> PySignificantDifference:
    """
    No docstring available
    
    Parameters
    ----------
    value1 : float
        First value.
    value2 : float
        Second value.
    abs_tol : float, optional
        Absolute tolerance. Default is 0.
    rel_tol : float, optional
        Relative tolerance. Default is 0.
    is_different : 
    """
def sinc(x: typing.SupportsFloat, nd: typing.SupportsInt | None = None, y: typing.SupportsFloat) -> PySinc:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    nd : 
    y : 
    """
def sincc(x: typing.SupportsFloat, nd: typing.SupportsInt | None = None, y: typing.SupportsFloat) -> PySincc:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    nd : 
    y : 
    """
def sinhx_x(x: typing.SupportsFloat, nd: typing.SupportsInt | None = None, y: typing.SupportsFloat) -> PySinhxX:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    nd : 
    y : 
    """
def skip_ele_blender(ele: EleStruct, skip: bool) -> PySkipEleBlender:
    """
    No docstring available
    
    Parameters
    ----------
    ele : 
    skip : 
    """
def skip_header(ix_unit: typing.SupportsInt, error_flag: bool) -> PySkipHeader:
    """
    No docstring available
    
    Parameters
    ----------
    ix_unit : 
    error_flag : 
    """
def slice_lattice(lat: LatStruct, ele_list: str, do_bookkeeping: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to slice.
        This parameter is an input/output and is modified in-place. As an output: Lattice with unwanted elements
        sliced out.
    ele_list : unknown
        List of elements to retain. See the documentation for the lat_ele_locator routine for the syntax of the
        list.
    error : bool
        Set True if there is an error Set False if not.
    do_bookkeeping : bool, optional
        Default is True. If false, the calling routine is responsible for: * Modifying lat.particle_start if
        needed. * Calculating Twiss functions.
    """
def soft_quadrupole_edge_kick(ele: EleStruct, param: LatParamStruct, particle_at: typing.SupportsInt, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    Routine to add the SAD "linear" soft edge (for finite f1 or f2).
    
    This routine assumes that the particle orbit has been rotated to the element reference frame.
    This routine is called with sad_mult and quadrupole elements.
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through
    param : LatParamStruct
        Tracking parameters.
    particle_at : int
        first_track_edge$, or second_track_edge$.
    orbit : CoordStruct
        Position before kick.
        This parameter is an input/output and is modified in-place. As an output: Position after kick.
    mat6 : float, optional
        Transfer matrix up to the edge.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix with edge kick
        added on.
    make_matrix : float, optional
        Propagate the transfer matrix? Default is False.
    """
def sol_quad_mat6_calc(ks_in: typing.SupportsFloat, k1_in: typing.SupportsFloat, tilt: typing.SupportsFloat, length: typing.SupportsFloat, ele: EleStruct, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> PySolQuadMat6Calc:
    """
    No docstring available
    
    Parameters
    ----------
    ks_in : 
    k1_in : 
    tilt : float
        quadrupole tilt.
    length : float
        Sol_quad length.
    ele : EleStruct
        Sol_quad element.
    orbit : CoordStruct
        Orbit at beginning of the sol_quad.
    mat6 : float, optional
        Transfer matrix up to the sol_quad.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix includeing the
        sol_quad.
    make_matrix : bool, optional
        Extend the matrix?
    """
def solve_psi_adaptive(t0: typing.SupportsFloat, t1: typing.SupportsFloat, p0: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> float:
    """
    Solve dpsi/dt for psi(t1) using adaptive steps and method:
    
    "Implicit Bulirsch-Stoer method of Bader and Deuflhard."
    The boundary condition p0 is psi(t0)
    
    Parameters
    ----------
    t0 : float
        initial time
    t1 : float
        final time
    p0 : float
        Boundary condition psi(t0)
    args : float
        Parameters.  See psi_prime comments for details.
    
    Returns
    -------
    p1 : float
        psi(t1)
    """
def solve_psi_fixed_steps(t0: typing.SupportsFloat, t1: typing.SupportsFloat, p0: typing.SupportsFloat, args: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]) -> ...:
    """
    Solve dpsi/dt for psi(t1) using fixed steps and method:
    
    "Implicit Bulirsch-Stoer method of Bader and Deuflhard."
    The boundary condition p0 is psi(t0).
    Number of steps is determined by SIZE(p).
    
    Parameters
    ----------
    t0 : float
        initial time
    t1 : float
        final time
    p0 : float
        Boundary condition psi(t0)
    args : float
        Parameters.  See psi_prime comments for details.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    t : float
        Array of times from t0 to t1
    p : float
        Array of psi evaluated at t(:)
    """
def sort_complex_taylor_terms(complex_taylor_in: ComplexTaylorStruct) -> ComplexTaylorStruct:
    """
    Subroutine to sort the complex_taylor terms from "lowest" to "highest" of
    
    a complex_taylor series.
    This subroutine is needed because what comes out of PTC is not sorted.
    Uses function complex_taylor_exponent_index to sort.
    
    Parameters
    ----------
    complex_taylor_in : ComplexTaylorStruct
        Unsorted complex_taylor series.
    
    Returns
    -------
    complex_taylor_sorted : ComplexTaylorStruct
        Sorted complex_taylor series.
    
    Notes
    -----
    Note: complex_taylor_sorted needs to have been initialized.
    """
def species_id(name: str, default_: typing.SupportsInt | None = None, print_err: bool | None = None) -> int:
    """
    Routine to return the integer ID index of a particle species given the name.
    
    For subatomic particles, the case does not matter.
    For all other types of particles, the case does matter.
    
    Parameters
    ----------
    name : unknown
        Name of the species.
    default : int, optional
        Default species to use if name is blank or 'ref_species'. If not present, a blank name is an error.
    print_err : bool, optional
        Print error message? Default is True. If False, return species = invalid$,
    
    Returns
    -------
    species : int
        Species ID. Will return invalid$ if name is not valid. Will return not_set$ if name is blank
    """
def species_id_from_openpmd(pmd_name: str, charge: typing.SupportsInt) -> int:
    """
    Routine to return the Bmad species ID given the openPMD species name and given particle charge.
    
    Parameters
    ----------
    pmd_name : unknown
        OpenPMD species name.
    charge : int
        Species charge. Ignored for subatomic particles.
    
    Returns
    -------
    species : int
        Bmad spicies ID number.
    """
def species_name(species: typing.SupportsInt) -> str:
    """
    Routine to return the name of a particle species given the integer index.
    
    Parameters
    ----------
    species : int
        Species ID.
    
    Returns
    -------
    name : unknown
        Name of the species. Will return 'INVALID!' (= invalid_name) if index is not valid.
    """
def species_of(mass: typing.SupportsFloat, charge: typing.SupportsInt) -> int:
    """
    Routine to return the integer ID index of a particle species given the mass and charge.
    
    Parameters
    ----------
    mass : float
        Mass of the particle
    charge : int
        Charge of the particle.
    
    Returns
    -------
    species : int
        Species ID. Will return invalid$ if name is not valid.
    """
def spin_dn_dpz_from_mat8(mat_1turn: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(8)"]], "FixedSize(8)"], dn_dpz_partial: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None, dn_dpz: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    mat_1turn : float
        Spin-orbital matrix.
    dn_dpz_partial : float, optional
        dn_dpz_partial(i,:) is dn_dpz with only one osccilation mode "excited". So dn_dpz_partial(1,:) represents
        a-mode excitation, etc.
    error : bool
        Set True if there is an error. False otherwise.
    dn_dpz : 
    """
def spin_dn_dpz_from_qmap(orb_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], q_map: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(7)"]], "FixedSize(4)"], dn_dpz_partial: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"], dn_dpz_partial2: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"], n0: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None, dn_dpz: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    orb_mat : float
        1-turn orbital matrix.
    q_map : float
        1-turn spin linear quaternion map.
    dn_dpz_partial : float
        ) is dn_dpz with only one osccilation mode "excited". So dn_dpz_partial(1,:) represents a-mode excitation,
        etc.
    dn_dpz_partial2 : float
        ) is dn_dpz with only two osccilation modes "excited". So dn_dpz_partial(1,:) represents b-mode and c-mode
        excitation without the a-mode, etc.
    error : bool
        Set True if there is an error. False otherwise.
    n0 : float
        3,0).
    dn_dpz : 
    """
def spin_map1_normalize(spin1: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(7)"]], "FixedSize(4)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    spin1 : float
        Unnormalized spin map.
        This parameter is an input/output and is modified in-place. As an output: Normalized spin map.
    """
def spin_mat8_resonance_strengths(orb_evec: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"], mat8: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"]) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orb_evec : complex
        Orbital eigenvector.
    mat8 : float
        Spin/orbital matrix.
    xi_sum : float
        Sum resonance strength.
    xi_diff : float
        Difference resonance strength.
    """
def spin_mat_to_eigen(orb_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], spin_map: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(7)"]], "FixedSize(4)"]) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orb_mat : float
        Orbital matrix.
    spin_map : float
        Quaternion 0th & 1st order map.
    orb_eval : complex
        Eigenvalues.
    orb_evec : complex
        Orbital eigenvectors. orb_evec(j,:) is the j^th vector.
    n0 : float
        n_0 invariant spin
    spin_evec : complex
        Spin eigenvectors. spin_evec(j,:) is the j^th vector.
    error : bool
        Set true if there is an error. False otherwise.
    """
def spin_of(species: typing.SupportsInt, non_subatomic_default: typing.SupportsFloat | None = None) -> float:
    """
    Routine to return the spin, in units of hbar, of a particle.
    
    This routine is only valid for subatomic particles.
    For all other particles, the returned spin value will be the value of non_subatomic_default.
    
    Parameters
    ----------
    species : int
        Species ID.
    non_subatomic_default : float, optional
        Default value to be used for non-subatomic species. Default value of this argument is zero.
    
    Returns
    -------
    spin : float
        Particle spin.
    """
def spin_omega(field: EmFieldStruct, orbit: CoordStruct, sign_z_vel: typing.SupportsInt, phase_space_coords: bool | None = None, omega: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> PySpinOmega:
    """
    No docstring available
    
    Parameters
    ----------
    field : 
    orbit : 
    sign_z_vel : 
    phase_space_coords : 
    omega : 
    """
def spin_quat_resonance_strengths(orb_evec: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(6)"], spin_q: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(7)"]], "FixedSize(4)"]) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orb_evec : complex
        Orbital eigenvector.
    spin_q : float
        First order spin map.
    xi_sum : float
        Sum resonance strength.
    xi_diff : float
        Difference resonance strength.
    """
def spin_taylor_to_linear(spin_taylor: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(4)"], normalize: bool, dref_orb: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"], is_on: bool, spin_map1: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(7)"]], "FixedSize(4)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    spin_taylor : TaylorStruct
        Taylor spin map.
    normalize : bool
        If True, normalize the linear map.
    dref_orb : float
        Change in Reference orbit: output_map1_ref - input_taylor_ref.
    is_on : bool
        Is map turned on? If not spin_map1 will be the unit map.
    spin_map1 : 
    """
def spinor_to_polar(spinor: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(2)"], polar: SpinPolarStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    spinor : complex
        Spinor
    polar : 
    """
def spinor_to_vec(spinor: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(2)"], vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    spinor : complex
        Spinor Output
    vec : 
    """
def spline1(a_spline: SplineStruct, x: typing.SupportsFloat, n: typing.SupportsInt | None = None) -> float:
    """
    Function for spline evaluation using a single spline (instead of a spline array).
    
    Parameters
    ----------
    a_spline : SplineStruct
        Single spline structure.
    x : float
        Point for evaluation.
    n : int, optional
        Output derivative order. May be -1, 0, 1, 2, or 3. Default is 0. n = -1 => output is integral of y from
        a_spline.x0 to x. n = 1 => output is dy/dx, n = 2 => output is d^2y/dx^2, etc.
    
    Returns
    -------
    y : float
        Interpolated spline value or derivative.
    
    Notes
    -----
    Related routines:
    spline_evaluate spline_akima_interpolate use spline_mod
    """
def spline_akima(spline: SplineStructAlloc1D) -> bool:
    """
    Given a set of (x,y) points we want to interpolate between the points.
    
    This subroutine computes the semi-hermite cubic spline developed by
    Hiroshi Akima. The spline goes thorugh all the points (that is, it is
    not a smoothing spline). For interpolation use:
    spline_evaluate
    spline_akima_interpolate ! You do not need to call spline_akima if you use this routine.
    Reference:
    H Akima, "A New Method of Interpolation and Smooth Curve Fitting Based
    on Local Procedures", J. Assoc. Comp. Mach., Vol 17(4), 589-602 (1970).
    Modules used:
    use spline_mod
    
    Parameters
    ----------
    spline : SplineStruct
        .x0  -- X-component of a point. Note: points must be in assending order. .y0  -- Y-component of a point.
    
    Returns
    -------
    ok : bool
        Set .false. if something is wrong (like less than 2 points used).
    """
def spline_akima_interpolate(x_knot: RealAlloc1D, y_knot: RealAlloc1D, x: typing.SupportsFloat) -> ...:
    """
    Routine to interpolate using an akima spline.
    
    When evaluating at enough points, this routine is slower than calling spline_akima to
    first evaluate the spline coefficients and then repeatedly calling spline_evaluate.
    The advantage of this routine is that only the (x, y) knot points need to be stored
    and it will be faster if the number of evaluations is small.
    This routine will extrapolate past the range of x_knot(:) up to a distance equal to the
    length between an end point and the point just inside the end point.
    
    Parameters
    ----------
    x_knot : float
        Array of x values for the knot points. Must have more than 2 points and be in asending order.
    y_knot : float
        Array of y values for the knot points. Must be same size as x_knot(:).
    x : float
        Point to evaluate at.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ok : bool
        Set .true. if everything ok, That is, x is within the spline range.
    y : float
        Spline interpolation.
    dy : float
        Spline derivative interpolation.
    """
def spline_evaluate(spline: SplineStructAlloc1D, x: typing.SupportsFloat) -> ...:
    """
    Subroutine to evalueate a spline at a set of points.
    
    A point outside of the range of knot points is an error.
    
    Parameters
    ----------
    spline : SplineStruct
        Spline structure.
    x : float
        point for evaluation.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ok : bool
        Set .true. if everything ok. That is, x is within the spline range.
    y : float
        Spline interpolation.
    dy : float
        Spline derivative interpolation.
    
    Notes
    -----
    Related routines:
    spline1 spline_akima_interpolate A spline may be generated using for example the spline_akima routine. use
    spline_mod
    """
def spline_fit_orbit(start_orb: CoordStruct, end_orb: CoordStruct, spline_x: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], spline_y: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    start_orb : CoordStruct
        Starting coords.
    end_orb : CoordStruct
        Ending coords.
    spline_x : float
        Spline coefs for the horizontal trajectory.
    spline_y : float
        Spline coefs for vertical trajectory.
    """
def split_lat(lat: LatStruct, s_split: typing.SupportsFloat, ix_branch: typing.SupportsInt, add_suffix: bool | None = None, check_sanity: bool | None = None, save_null_drift: bool | None = None, choose_max: bool | None = None, ix_insert: typing.SupportsInt | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Original lat structure.
        This parameter is an input/output and is modified in-place. As an output: Modified lat structure.
    s_split : float
        Position at which lat.branch(ix_branch) is to be split.
    ix_branch : int
        Index of lat.branch(:) to use.
    ix_split : int
        Index of element just before the s = s_split point.
    split_done : bool
        True if lat was split.
    add_suffix : bool, optional
        If True (default) add '#1' and '#2" suffixes to the split elements.
    check_sanity : bool, optional
        If True (default) then call lat_sanity_check after the split to make sure everything is ok.
    save_null_drift : bool, optional
        Save a copy of a drift to be split as a null_ele? This is useful when superpositions are done. See
        add_superimpose for more info. Default is False.
    err_flag : bool
        Set true if there is an error, false otherwise.
    choose_max : bool, optional
        If no splitting of an element is needed, that is, s_split is at an element boundary, there can be multiple
        possible values for ix_split if there exist zero length elements at the split point. If choose_max = True,
        ix_split will be chosen to be the maximum possible index and if choose_max = False ix_split will be chosen
        to be the minimal possible index. If s_split is not at an element boundary, the setting of choose_max is
        immaterial. If ix_insert is present, the default value of choose_max is set to give the closest element to
        ix_insert. If ix_insert is not present, the default value of choose_max is False.
    ix_insert : int, optional
        Element index near the point to be split. ix_insert is useful in the case where there is a patch with a
        negative length which can create an ambiguity as to where to do the split In this case ix_insert will
        remove the ambiguity. Also useful to ensure where to split if there are elements with zero length nearby.
        Ignored if negative.
    """
def sprint_spin_taylor_map(ele: EleStruct, start_orbit: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"] | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to form map for.
        This parameter is an input/output and is modified in-place. As an output: Element with map.
    start_orbit : float, optional
        Reference orbit for the map. Default is zero orbit.
    """
def sqrt_alpha(alpha: typing.SupportsFloat, x: typing.SupportsFloat, y: typing.SupportsFloat) -> PySqrtAlpha:
    """
    No docstring available
    
    Parameters
    ----------
    alpha : 
    x : 
    y : 
    """
def sqrt_one(x: typing.SupportsFloat, nd: typing.SupportsInt | None = None, ds1: typing.SupportsFloat) -> PySqrtOne:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    nd : 
    ds1 : 
    """
def sr_longitudinal_wake_particle(ele: EleStruct, orbit: CoordStruct) -> None:
    """
    Routine to apply the short-range wake longitudinal component kick to a particle and then add
    
    to the existing longitudinal wake the contribution from the particle.
    
    Parameters
    ----------
    ele : EleStruct
        Element with wakes.
    orbit : CoordStruct
        Particle coords.
        This parameter is an input/output and is modified in-place. As an output: coords after the kick.
    """
def sr_transverse_wake_particle(ele: EleStruct, orbit: CoordStruct) -> None:
    """
    Subroutine to apply the short-range wake transverse component of the kick to a particle and then add
    
    to the existing transverse wake the contribution from the particle.
    
    Parameters
    ----------
    ele : EleStruct
        Element with wakes.
    orbit : CoordStruct
        Starting particle coords.
        This parameter is an input/output and is modified in-place. As an output: Ending particle coords.
    """
def sr_z_long_wake(ele: EleStruct, bunch: BunchStruct, z_ave: typing.SupportsFloat) -> None:
    """
    Subroutine to apply the short-range z-wake kick to a particle.
    
    Parameters
    ----------
    ele : EleStruct
        Element with wake.
    bunch : BunchStruct
        Bunch before wake applied.
    z_ave : float
        Average z-position of all live particles.
    
    Returns
    -------
    orbit : CoordStruct
        Ending particle coords.
    """
def srdt_calc(lat: LatStruct, order: typing.SupportsInt, n_slices_gen_opt: typing.SupportsInt | None = None, n_slices_sxt_opt: typing.SupportsInt | None = None, per_ele_out: _pybmad.SummationRdtStructAlloc1D | None = None) -> SummationRdtStruct:
    """
    Calculate summation RDT terms up to order=1 or order=2 while slicing sextupoles
    
    n_slices_sxt_opt times and all other elements n_slices_gen_opt times.
    These formulas are documented in "The Sextupole Scheme for the Swiss Light Source (SLS): An Analytic Approach"
    by Johan Bengtsson.  SLS Note 9/97.
    The 2nd order formulas are documented in "Second-order driving terms due to sextupoles and
    chromatic effects of quadrupoles" by Chun-xi Wang.  AOP-TN-2009-020.
    
    Parameters
    ----------
    lat : LatStruct
        lattice with Twiss parameters calculated.
    order : int
        1 to calculate only first order terms.  2 to also calculate 2nd order terms.
    n_slices_gen_opt : int, optional
        number of times to slice elements other than sextupoles.  Default is 10.
    n_slices_sxt_opt : int, optional
        nubmer of times to slice sextupoles.  Default is 20.
    
    Returns
    -------
    srdt_sums : SummationRdtStruct
        contains complex RDT strengths.
    """
def srdt_lsq_solution(lat: LatStruct, var_indexes: IntAlloc1D, n_slices_gen_opt: typing.SupportsInt | None = None, n_slices_sxt_opt: typing.SupportsInt | None = None, chrom_set_x_opt: typing.SupportsFloat | None = None, chrom_set_y_opt: typing.SupportsFloat | None = None, weight_in: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(10)"] | None = None) -> RealAlloc1D:
    """
    chrom_set_x_opt, chrom_set_y_opt, weight_in)
    
    Given lat, finds K2 moments that set the chromaticity and zeros-out the real
    and complex parts of the first order driving terms, that minimizes the sum of the squares
    of the K2 moments.  i.e. the weakest sextupole scheme that sets chromaticity
    and zeros out the first order terms.
    
    Parameters
    ----------
    lat : LatStruct
        lattice with Twiss parameters calculated.
    var_indexes : int
        indexes in lat.ele that are K2 variables.  Must be sorted smallest index to largest index.
    n_slices_gen_opt : int, optional
        number of times to slice elements other than sextupoles.  Default is 10.
    n_slices_sxt_opt : int, optional
        nubmer of times to slice sextupoles.  Default is 20.
    chrom_set_x_opt : float, optional
        what to set x chromaticity to.  Default zero.
    chrom_set_y_opt : float, optional
        what to set y chromaticity to.  Default zero.
    weight_in : float, optional
        moment weights. Terms are: [wgt_chrom_x, wgt_chrom_y, wgt_h20001, wgt_h00201, wgt_h10002, wgt_h21000,
        wgt_h30000, wgt_h10110, wgt_h10020, wgt_h10200, If present, any terms equal to zero are given default
        values which is 1.0e4 for wgt_chrom_x and wgt_chrom_y and is 1.0 for everything else.
    
    Returns
    -------
    ls_soln : float
        contains K2 for the indexes in var_indexes
    """
def start_branch_at(lat: LatStruct, ele_start: str, move_end_marker: bool) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to modify.
        This parameter is an input/output and is modified in-place. As an output: Modified lattice.
    ele_start : unknown
        Start element. Ele_start will identify the lattice branch to modify.
    move_end_marker : bool
        If True then the end marker (if it is present) will be shifted like any other element. False means that
        the end marker will stay at the end.
    error : bool
        Set True if there is an error Set False if not.
    """
def str_count(str: str, match: str, num: typing.SupportsInt) -> PyStrCount:
    """
    No docstring available
    
    Parameters
    ----------
    str : 
    match : 
    num : 
    """
def str_downcase(src: str) -> str:
    """
    No docstring available
    
    Parameters
    ----------
    dst : 
    src : 
    """
def str_first_in_set(line: str, set: str, ignore_clauses: bool | None = None, ix_match: typing.SupportsInt) -> PyStrFirstInSet:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    set : 
    ignore_clauses : 
    ix_match : 
    """
def str_first_not_in_set(line: str, set: str, ix_match: typing.SupportsInt) -> PyStrFirstNotInSet:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    set : 
    ix_match : 
    """
def str_last_in_set(line: str, set: str, ix_match: typing.SupportsInt) -> PyStrLastInSet:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    set : 
    ix_match : 
    """
def str_last_not_in_set(line: str, set: str, ix_match: typing.SupportsInt) -> PyStrLastNotInSet:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    set : 
    ix_match : 
    """
def str_match_wild(str: str, pat: str, a_match: bool) -> PyStrMatchWild:
    """
    No docstring available
    
    Parameters
    ----------
    str : 
    pat : 
    a_match : 
    """
def str_substitute(string: str, str_match: str | None = None, str_replace: str | None = None, do_trim: bool | None = None, ignore_escaped: bool | None = None) -> PyStrSubstitute:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    str_match : 
    str_replace : 
    do_trim : 
    ignore_escaped : 
    """
def str_upcase(src: str) -> str:
    """
    No docstring available
    
    Parameters
    ----------
    dst : 
    src : 
    """
def stream_ele_end(physical_end: typing.SupportsInt, ele_orientation: typing.SupportsInt, stream_end: typing.SupportsInt) -> PyStreamEleEnd:
    """
    No docstring available
    
    Parameters
    ----------
    physical_end : int
        entrance_end$, exit_end$, surface$, etc.
    ele_orientation : int
        Either 1 = Normal or -1 = element reversed.
    stream_end : 
    """
def string_attrib(attrib_name: str, ele: EleStruct) -> str:
    """
    Routine to return the value of a string attribute of a lattice element.
    
    This routine is useful when attrib_name is specified by the program user.
    For example:
    call string_attrib ('NAME', ele, attrib_value)  ! Will return attrib_value = ele%name
    
    Parameters
    ----------
    attrib_name : unknown
        Name of the type of element attribute.
    ele : EleStruct
        Lattice element.
    
    Returns
    -------
    attrib_value : unknown
        The string associated with the attribute.
    """
def string_to_int(line: str, default_: typing.SupportsInt, err_flag: bool, err_print_flag: bool | None = None, value: typing.SupportsInt) -> PyStringToInt:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    default : 
    err_flag : 
    err_print_flag : 
    value : 
    """
def string_to_real(line: str, default_: typing.SupportsFloat, err_flag: bool, err_print_flag: bool | None = None, value: typing.SupportsFloat) -> PyStringToReal:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    default : 
    err_flag : 
    err_print_flag : 
    value : 
    """
def string_trim(in_string: str, out_string: str, word_len: typing.SupportsInt) -> PyStringTrim:
    """
    No docstring available
    
    Parameters
    ----------
    in_string : 
    out_string : 
    word_len : 
    """
def string_trim2(in_str: str, delimitors: str, out_str: str, ix_word: typing.SupportsInt, delim: str, ix_next: typing.SupportsInt) -> PyStringTrim2:
    """
    No docstring available
    
    Parameters
    ----------
    in_str : 
    delimitors : 
    out_str : 
    ix_word : 
    delim : 
    ix_next : 
    """
def strong_beam_sigma_calc(ele: EleStruct, s_pos: typing.SupportsFloat) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Beambeam element.
    s_pos : float
        Longitudinal position in lab coords of slice (used with hourglass effect correction).
    sigma : float
        Strong beam x,y sigmas.
    bbi_const : float
        BBI kick scale factor.
    dsigma_ds : float
        sig_x and sig_y longitudinal derivatives.
    """
def strong_beam_strength(ele: EleStruct, strength: typing.SupportsFloat) -> PyStrongBeamStrength:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Beambeam element.
    strength : 
    """
def super_bicubic_coef(y: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], y1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], y2: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], y12: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], d1: typing.SupportsFloat, d2: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(4)"]], "FixedSize(4)"]:
    """
    Routine to compute coefficients for bicubic interpolation.
    
    This is from NR bcucof.
    
    Parameters
    ----------
    y : float
        Function values at grid points.
    y1 : float
        dy/dx1 derivatives.
    y2 : float
        dy/dx2 derivatives.
    y12 : float
        d2y/dx1*dx2 second derivatives.
    d1 : float
        Grid width in 1-direction.
    d2 : float
        Grid width in 2-direction.
    
    Returns
    -------
    c : float
        Coefficients.
    """
def super_bicubic_interpolation(y: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], y1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], y2: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], y12: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(4)"], x1l: typing.SupportsFloat, x1u: typing.SupportsFloat, x2l: typing.SupportsFloat, x2u: typing.SupportsFloat, x1: typing.SupportsFloat, x2: typing.SupportsFloat) -> ...:
    """
    Routine to do bicubic interpolation.
    
    This is from NR bcuint.
    Note! The four grid points are arrayed in counter-clockwise order beginning from the lower left.
    So, for example, y = [y_ll, y_lu, y_uu, y_ul] where "l" = lower, "u" = upper index.
    
    Parameters
    ----------
    y : float
        Function values at grid points.
    y1 : float
        dy/dx1 derivatives.
    y2 : float
        dy/dx2 derivatives.
    y12 : float
        d2y/dx1*dx2 second derivatives.
    x1l : float
        1-direction coordinate at lower points.
    x1u : float
        1-direction coordinate at upper points
    x2l : float
        2-direction coordinate at lower points.
    x2u : float
        2-direction coordinate at upper points
    x1 : float
        1-direction coordinate at point to evaluate.
    x2 : float
        2-direction coordinate at point to evaluate.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ansy : float
        Interpolation value.
    ansy1 : float
        1-direction derivative at interpolation point.
    ansy2 : float
        2-direction derivative at interpolation point.
    """
def super_polint(xa: RealAlloc1D, ya: RealAlloc1D, x: typing.SupportsFloat) -> ...:
    """
    This is essentially polint from Numerical Recipes.
    
    Parameters
    ----------
    xa : float
    x : float
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    y : float
    dy : float
    """
def super_poly(x: typing.SupportsFloat, coeffs: RealAlloc1D) -> float:
    """
    Routine to compute Sum: coef(i)*x^i
    
    Parameters
    ----------
    x : float
        Variable.
    coef : float
        Coefficients.
    
    Returns
    -------
    value : float
        Polynomial value.
    """
def super_sobseq(ran_state: _pybmad.RandomStateStruct | None = None) -> RealAlloc1D:
    """
    Routine patterened after sobseq in Numerical Recipes.
    
    Difference is that this version has an argument for the internal state.
    
    Parameters
    ----------
    ran_state : RandomStateStruct, optional
        Generator state. See the ran_seed_put documentation for more details.
    
    Returns
    -------
    x : float
        Random vector.
    """
def super_sort(arr: IntAlloc1D) -> None:
    """
    Routine to sort an integer array in place.
    
    This is the NR routine sort modified to sort integers.
    
    Parameters
    ----------
    arr : int
        Array of integers.
        This parameter is an input/output and is modified in-place. As an output: Sorted array.
    """
def surface_grid_displacement(ele: EleStruct, x: typing.SupportsFloat, y: typing.SupportsFloat, err_flag: bool, z: typing.SupportsFloat, dz_dxy: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"] | None = None, extend_grid: bool | None = None) -> PySurfaceGridDisplacement:
    """
    Routine to add in the z displacement defined by the grid
    
    Parameters
    ----------
    ele : EleStruct
        Element containing the grid x, y          -- real(rp): Photon coords at surface.
    extend_grid : bool, optional
        If (x,y) past grid pretend (x,y) is at grid boundary. Default is False. Output
    err_flag : bool
        Set True if there is a problem.
    z : float
        surface height at (x, y).
    dz_dxy : float, optional
        Surface slope at (x, y).
    """
def symp_lie_bmad(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None, offset_ele: bool | None = None) -> TrackStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with transfer matrix
        This parameter is an input/output and is modified in-place. As an output: Element with transfer matrix.
    param : LatParamStruct
        Parameters are needed for some elements.
    orbit : CoordStruct
        Coordinates at the beginning of element.
        This parameter is an input/output and is modified in-place. As an output: Coordinates at the end of
        element.
    track : TrackStruct
        Structure holding the track information. When tracking through multiple elements, the trajectory in an
        element is appended to the existing trajectory. To reset: Set track.n_pt = -1.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
        through the element.
    make_matrix : bool
        If True then make the 6x6 transfer matrix.
    offset_ele : bool, optional
        Offset the element using ele.value(x_offset$), etc. Default is True.
    """
def system_command(line: str, err_flag: bool | None = None) -> PySystemCommand:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    err_flag : 
    """
def t6_to_b123(t6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], abz_tunes: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> ...:
    """
    This decomposes the one-turn matrix according to Equation 56 from
    
    "Alternative approach to general coupled linear optics" by A. Wolski. PRSTAB.
    
    Parameters
    ----------
    t6 : float
        1-turn transfer matrix.  RF assumed to be on.
    abz_tunes : float
        a-mode and b-mode tunes.  Used to order eigensystem.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    B1 : float
        Beta matrix associated with a-mode.
    B2 : float
        Beta matrix associated with b-mode.
    B3 : float
        Beta matrix associated with c-mode.
    err_flag : bool
        Set True if there is an error. False otherwise
    """
def tao_abort_command_file(force_abort: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    force_abort : bool, optional
        : If present and True, ignore s.global.cmd_file_abort_on_error and abort any open command files.
    """
def tao_add_to_normal_mode_h_array(h_str: str) -> ResonanceHStructAlloc1D:
    """
    Routine to add on to the "h(:)" array holding the list of normal form
    
    resonance driving terms to calculate.
    If h_str is already in the h_array(:) list, nothing is done.
    
    Parameters
    ----------
    h_str : unknown
        Resonance driving term ID. EG: "110000"
    
    Returns
    -------
    h_array : ResonanceHStruct
        Array of resonance driving terms.
    """
def tao_alias_cmd(alias: str, string: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    alias : 
        Name of the tao command file.
    string : 
        Command file arguments.
    """
def tao_allocate_data_array(u: TaoUniverseStruct, n_data: typing.SupportsInt, exact: bool | None = None) -> PyTaoAllocateDataArray:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    n_data : 
    exact : 
    """
def tao_allocate_v1_var(n_v1: typing.SupportsInt, save_old: bool) -> PyTaoAllocateV1Var:
    """
    No docstring available
    
    Parameters
    ----------
    n_v1 : 
    save_old : 
    """
def tao_allocate_var_array(n_var: typing.SupportsInt, default_good_user: bool) -> PyTaoAllocateVarArray:
    """
    Routine to increase the s%var(:) array size.
    
    Parameters
    ----------
    n_var : int
        Size of s.var(:) wanted.
    """
def tao_beam_emit_calc(plane: typing.SupportsInt, emit_type: typing.SupportsInt, ele: EleStruct, bunch_params: BunchParamsStruct, emit: typing.SupportsFloat) -> PyTaoBeamEmitCalc:
    """
    No docstring available
    
    Parameters
    ----------
    plane : int
        x_plane$ or y_plane$.
    emit_type : int
        Either projected_emit$ or apparent_emit$
    ele : EleStruct
        Element.
    bunch_params : BunchParamsStruct
        Bunch sigma matrix
    emit : 
    """
def tao_beam_track(u: TaoUniverseStruct, tao_lat: TaoLatticeStruct, ix_branch: typing.SupportsInt, beam: BeamStruct) -> bool:
    """
    Routine to track a a beam of particles.
    
    Parameters
    ----------
    u : TaoUniverseStruct
        Universe to track through.
    tao_lat : TaoLatticeStruct
        Structure containing the lattice.
    ix_branch : int
        Branch index to track through.
    beam : BeamStruct
        Initial beam distribution
        This parameter is an input/output and is modified in-place. As an output: Final beam distribution.
    
    Returns
    -------
    calc_ok : bool
        Set True if there were no problems, False otherwise.
    """
def tao_beam_track_endpoint(ele_id: str, lat: LatStruct, branch_str: str, where: str, u: TaoUniverseStruct, ele: EleStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele_id : unknown
        Name or index of the element.
    lat : LatStruct
        Lattice.
    branch_str : int
        Branch where the tracking is done. '' => Branch not specified.
    where : unknown
        'TRACK_END', 'TRACK_START', etc.. Used for error messages.
    u : TaoUniverseStruct
        Universe beam is being tracked in.
    ele : 
    """
def tao_branch_index(ix_branch: typing.SupportsInt, ix_this: typing.SupportsInt) -> PyTaoBranchIndex:
    """
    No docstring available
    
    Parameters
    ----------
    ix_branch : int
        Nominal branch number.
    ix_this : 
    """
def tao_c_out_io_buffer_reset() -> None:
    """
    Routine to reset the buffer.
    """
def tao_calc_data_at_s_pts(tao_lat: TaoLatticeStruct, curve: TaoCurveStruct, comp_sign: typing.SupportsFloat, good: BoolAlloc1D) -> PyTaoCalcDataAtSPts:
    """
    No docstring available
    
    Parameters
    ----------
    tao_lat : 
    curve : 
    comp_sign : 
    good : 
    """
def tao_cbar_wave_anal(plot: TaoPlotStruct) -> None:
    ...
def tao_change_ele(ele_name: str, attrib_name: str, num_str: str, update: bool) -> PyTaoChangeEle:
    """
    Routine to change a variable in the model lattice.
    
    Parameters
    ----------
    ele_name : unknown
        Name of variable or element.
    attrib_name : unknown
        Attribute name of element.
    num_str : unknown
        Change in value. A '@' signifies a absolute set. A 'd' signifies a set relative design.
    
    Returns
    -------
    err_flag : 
        logical, Set true if there is an error, false otherwise. s%u(s%global%default_universe)%model -- model
        lattice where the variable lives.
    """
def tao_change_tune(branch_str: str, mask_str: str, print_list: bool, dqa_str: str, dqb_str: str) -> bool:
    """
    Parameters
    ----------
    branch_str : unknown
        List of branches to apply tune set to.
    mask_str : unknown
        List of quadrupoles to veto.
    print_list : bool
        If True, print a list of elements varied and coefficients.
    dqa_str : unknown
        Expression for dQa tune.
    dqb_str : unknown
        Expression for dQb tune.
    
    Returns
    -------
    err_flag : 
        logical, Set true if there is an error, false otherwise.
    """
def tao_change_var(name: str, num_str: str, silent: bool) -> bool:
    """
    Routine to change a variable in the model lattice.
    
    Parameters
    ----------
    name : unknown
        Name of variable or element.
    num_str : unknown
        Change in value. A '@' signifies a absolute set. A 'd' signifies a set relative design.
    silent : bool
        If True then do not print any info.
    
    Returns
    -------
    err_flag : 
        logical, Set true if there is an error, false otherwise. s%u(s%global%default_universe)%model -- model
        lattice where the variable lives.
    """
def tao_change_z_tune(branch_str: str, dq_str: str) -> bool:
    """
    Parameters
    ----------
    branch_str : unknown
        List of branches to apply tune set to.
    dq_str : unknown
        Expression for dQc tune.
    
    Returns
    -------
    err_flag : 
        logical, Set true if there is an error, false otherwise.
    """
def tao_chrom_calc_needed(data_type: str, data_source: str, do_chrom: bool) -> PyTaoChromCalcNeeded:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : 
    data_source : 
    do_chrom : 
    """
def tao_clear_cmd(cmd_line: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    cmd_line : unknown
        Should be set to 'maps'.
    """
def tao_clip_cmd(gang: bool, where: str, value1: typing.SupportsFloat, value2: typing.SupportsFloat) -> PyTaoClipCmd:
    """
    No docstring available
    
    Parameters
    ----------
    gang : bool
        Gang all data d1 arrays together.
    where : unknown
        Graph() to clip. Eg: 'top:x'
    value1 : 
    value2 : 
    """
def tao_close_command_file() -> None:
    """
    No docstring available
    """
def tao_cmd_history_record(cmd: str) -> PyTaoCmdHistoryRecord:
    """
    Subroutine to record a cmd in the command history stack
    """
def tao_command(command_line: str, err: bool) -> PyTaoCommand:
    """
    No docstring available
    
    Parameters
    ----------
    command_line : unknown
        command line
    err : 
    err_is_fatal : bool
        Set True on non-recoverable error. False otherwise
    """
def tao_constraint_type_name(datum: TaoDataStruct, datum_name: str) -> PyTaoConstraintTypeName:
    """
    No docstring available
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum
    datum_name : 
    """
def tao_control_tree_list(ele: EleStruct, tree: ElePointerStructAlloc1D) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element to start at. Ouput:
    tree : ElePointerStruct
        Array of elements.
    """
def tao_count_strings(string: str, pattern: str) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    string : unknown
        the string to look at
    pattern : unknown
        the search pattern
    num : int
        number of occurances
    """
def tao_create_plot_window() -> None:
    """
    Subroutine to create the plot window.
    
    This soubroutine knows not to create a second window if one already exists.
    """
def tao_curve_beam_ellipse_setup(curve: TaoCurveStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    curve : 
    """
def tao_curve_check_universe(curve: TaoCurveStruct, uni: TaoUniverseStruct) -> bool:
    """
    Routine to check if the universe associated with a curve exists and is on.
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve to check.
        This parameter is an input/output and is modified in-place. As an output: Curve.valid set to False if
        needed.
    uni : TaoUniverseStruct
        Associated universe
    
    Returns
    -------
    is_ok : bool
        Set True if associated universe exists and is on.
    """
def tao_curve_data_setup(plot: TaoPlotStruct, graph: TaoGraphStruct, curve: TaoCurveStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    curve : 
    """
def tao_curve_datum_calc(eles: ElePointerStructAlloc1D, plot: TaoPlotStruct, curve: TaoCurveStruct, who: str) -> None:
    """
    Routine to calculate datum values.
    
    The values are calculated at the end of each eles(:)%ele element.
    
    Parameters
    ----------
    eles : ElePointerStruct
        Array of elements.
    plot : TaoPlotStruct
    curve : TaoCurveStruct
        This parameter is an input/output and is modified in-place. As an output: Structure holding the datum
        values
    who : unknown
        Where to put the data. Either: "SYMBOL" or "LINE".
    """
def tao_curve_ele_ref(curve: TaoCurveStruct, point_to_ele_ref: bool, ele_track: EleStruct) -> PyTaoCurveEleRef:
    """
    No docstring available
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve with ref ele.
    point_to_ele_ref : 
    ele_track : 
    """
def tao_curve_ix_uni(curve: TaoCurveStruct, ix_uni: typing.SupportsInt) -> PyTaoCurveIxUni:
    """
    No docstring available
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve.
    ix_uni : 
    """
def tao_curve_name(curve: TaoCurveStruct, use_region: bool | None = None, curve_name: str) -> PyTaoCurveName:
    """
    No docstring available
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve
    use_region : bool
        If present and True then use the region name instead of the plot name. Region name is 'NULL_REGION' if
        there is no assocaited region.
    curve_name : 
    """
def tao_curve_rms_calc(curve: TaoCurveStruct, who: str) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve to analyze.
    who : unknown
        "LINE" or "SYMBOL".
    rms : float
        RMS. -1 => Curve has no data.
    mean : float
        Mean.
    """
def tao_d2_d1_name(d1: TaoD1DataStruct, show_universe: bool | None = None, d2_d1_name: str) -> PyTaoD2D1Name:
    """
    No docstring available
    
    Parameters
    ----------
    d1 : TaoD1DataStruct
        Data array.
    show_universe : bool, optional
        Show the datum's universe. Default is True.
    d2_d1_name : 
    """
def tao_d2_data_stuffit(u: TaoUniverseStruct, d2_name: str, n_d1_data: typing.SupportsInt) -> PyTaoD2DataStuffit:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    d2_name : 
    n_d1_data : 
    """
def tao_data_check(err: bool) -> PyTaoDataCheck:
    """
    No docstring available
    
    Parameters
    ----------
    err : 
    """
def tao_data_coupling_init(branch: BranchStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        New lattice branch.
    """
def tao_data_sanity_check(datum: TaoDataStruct, print_err: bool, default_data_type: str, uni: _pybmad.TaoUniverseStruct | None = None, is_valid: bool) -> PyTaoDataSanityCheck:
    """
    No docstring available
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum to check.
    print_err : bool
        Print error message if data is not valid?
    default_data_type : unknown
        Default data type associated with the datum's d2 structure.
    uni : TaoUniverseStruct, optional
        Universe to use instead of datum.d1.d2.ix_universe
    is_valid : 
    """
def tao_data_type_substitute(template_: str, curve: TaoCurveStruct, graph: TaoGraphStruct) -> str:
    """
    Routine substitute the appropriate data type string for instances of "#ref" and
    
    "#comp" in template.
    Additionally, if template does not have a "|" character,
    the string "|" + component will be added at the end of str_out.
    
    Parameters
    ----------
    template : unknown
        String template.
    curve : TaoCurveStruct
        curve.ele_ref_name is substituted for all instances of "#ref".
    graph : TaoGraphStruct
    
    Returns
    -------
    str_out : unknown
        String with substitutions.
    """
def tao_data_useit_plot_calc(curve: TaoCurveStruct, graph: TaoGraphStruct, check_s_position: bool) -> ...:
    """
    Routine to set the data for plotting.
    
    Parameters
    ----------
    graph : 
        tao_graph_struct
    curve : 
        tao_curve_struct
    check_s_position : bool
        If present and True then veto data that does not have an s-position.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    data : TaoDataStruct
        .useit_plot         -- True if good for plotting.
    most_invalid : unknown
        String documenting biggest invalid data problem.
    """
def tao_datum_has_associated_ele(data_type: str, branch_geometry: typing.SupportsInt | None = None, has_associated_ele: typing.SupportsInt) -> PyTaoDatumHasAssociatedEle:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : unknown
        Type of data.
    branch_geometry : int, optional
        Geometry of the associated lattice branch. open$ or closed$.
    has_associated_ele : 
    """
def tao_datum_integrate(datum: TaoDataStruct, branch: BranchStruct, s_pos: RealAlloc1D, values: RealAlloc1D) -> ...:
    """
    Routine to calculate the integral, rms, or average of an array of values associated with a datum.
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum under consideration.
    branch : BranchStruct
        Associated lattice branch.
    s_pos : float
        Array of s-positions of the values.
    values : float
        Array of values.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    valid_value : bool
        Set false if, for example, all s_pos(:) are the same.
    why_invalid : unknown
        Information string if there is a problem.
    result : float
        Integral, rms, or average depending upon datum.merit_type.
    """
def tao_datum_name(datum: TaoDataStruct, show_universe: bool | None = None, datum_name: str) -> PyTaoDatumName:
    """
    No docstring available
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum
    show_universe : bool, optional
        Show the datum's universe. Default is True.
    datum_name : 
    """
def tao_datum_s_position(datum: TaoDataStruct, ele: EleStruct) -> float:
    """
    Routine to calculate the longitudinal position associated with a datum.
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum under conideration.
    ele : EleStruct
        Associated lattice element. Output
    s_pos : float
        Associated longitudinal position.
    
    Returns
    -------
    s_pos
    """
def tao_de_optimizer() -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    abort : bool
        Set True if an user stop signal detected.
    """
def tao_deallocate_plot_cache(plot_cache: TaoPlotCacheStructAlloc1D) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot_cache : 
    """
def tao_destroy_plot_window() -> None:
    """
    No docstring available
    """
def tao_dmerit_calc() -> None:
    ...
def tao_dmodel_dvar_calc(force_calc: bool) -> bool:
    """
    Subroutine to calculate the dModel_dVar derivative matrix.
    
    Parameters
    ----------
    s : SuperUniverseStruct
        This parameter is an input/output and is modified in-place. As an output: Super_universe_struct.
    force_calc : bool
        If true then force recalculation of the matrix. If False then only calculate matrix if it doesn't exist.
    veto_vars_with_zero_dmodel : bool
        Veto variables where -- Logical, optional (default False): Veto variables where all dModel_dvar for that
        var are zero. Sets the var.good_var logical to False.
    
    Returns
    -------
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def tao_do_wire_scan(ele: EleStruct, theta: typing.SupportsFloat, beam: BeamStruct) -> float:
    """
    Returns the beam's second moment using the wire along the specified angle.
    
    Keep in mind that the actual correlation axis is 90 degrees off of the
    wire angle
    This simulates a fast wire scanner that performs the scan over only one
    bunch. Obviously, this isn't realistic. Any dynamic effects will not be
    accounted for!
    
    Parameters
    ----------
    ele : ElementStruct
        .value(noise$) -- relative wire resolution RMS .value(tilt$)  -- wire angle error in radians rms.
    theta : float
        wire angle wrt x axis (in degrees)
    beam : BeamStruct
        contains the beam distribution
    
    Returns
    -------
    moment : float
        second moment along axis specified by angle.
    """
def tao_draw_beam_chamber_wall(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw the beam chamber wall.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_draw_curve_data(plot: TaoPlotStruct, graph: TaoGraphStruct, curve: TaoCurveStruct, have_data: bool) -> PyTaoDrawCurveData:
    """
    Routine to draw a graph with data and/or variable curves.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph containing the curve.
    curve : TaoCurveStruct
        Curve to draw.
    have_data : bool
        Intitial state.
        This parameter is an input/output and is modified in-place. As an output: Is there any data to plot? Set
        True if so.
    """
def tao_draw_ele_for_floor_plan(plot: TaoPlotStruct, graph: TaoGraphStruct, tao_lat: TaoLatticeStruct, ele: EleStruct, ele_shape: TaoEleShapeStruct, label_name: str, offset1: typing.SupportsFloat, offset2: typing.SupportsFloat) -> PyTaoDrawEleForFloorPlan:
    """
    Routine to draw one lattice element or one datum location for the floor plan graph.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    tao_lat : TaoLatticeStruct
        Lattice containing the element.
    ele : EleStruct
        Element to draw.
    ele_shape : TaoEleShapeStruct
        Shape to draw from s.plot_page.floor_plan.ele_shape(:) array. Will be NULL if no associated shape for this
        element.
    label_name : unknown
        Shape label. offset1, offset2  -- real(rp): Transverse distances used to scale the drawing of the element
        shape.
    """
def tao_draw_floor_plan(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw a floor plan graph.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_draw_graph_axes(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw a just the graph part of a data graph.
    
    The calling routine takes care of drawing any curves.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_draw_histogram_data(plot: TaoPlotStruct, graph: TaoGraphStruct, curve: TaoCurveStruct, have_data: bool) -> PyTaoDrawHistogramData:
    """
    Routine to draw a graph with data and/or variable histograms.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph containing the histogram.
    curve : TaoCurveStruct
        Histogram to draw.
    have_data : bool
        Intitial state.
        This parameter is an input/output and is modified in-place. As an output: Is there any data to plot? Set
        True if so.
    """
def tao_draw_lat_layout(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw a lattice layout graph.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_draw_plots(do_clear: bool | None = None) -> None:
    """
    Subroutine to draw the plots on the plot window.
    
    Parameters
    ----------
    do_clear : bool, optional
        If present and False then call qp_clear_page. This argument is used when drawing PS or GIF.
    """
def tao_ele_geometry_with_misalignments(datum: TaoDataStruct, ele: EleStruct) -> ...:
    """
    Routine to evaluate a floor position with misalignments at a given element.
    
    This routine is private and not for general use.
    
    Parameters
    ----------
    datum : unknown
        Datum info
    ele : EleStruct
        Lattice element to evaluate at.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    valid_value : bool
        Was able to evalute the datum?
    why_invalid : unknown
        If not valid, why not.
    value : float
        Datum value.
    """
def tao_ele_shape_info(ix_uni: typing.SupportsInt, ele: EleStruct, ele_shapes: TaoEleShapeStructAlloc1D, y1: typing.SupportsFloat, y2: typing.SupportsFloat, ix_shape_min: typing.SupportsInt | None = None) -> PyTaoEleShapeInfo:
    """
    No docstring available
    
    Parameters
    ----------
    ix_uni : int
        Universe index.
    ele : EleStruct
        Lattice element.
    ele_shapes : TaoEleShapeStruct
        Array of shapes to search.
    e_shape : TaoEleShapeStruct
        element shape. Will be nullified if no associated shape.
    label_name : unknown
        Label name. y1, y2        -- real(rp): shape transverse sizes.
    y1 : 
    y2 : 
    ix_shape_min : int, optional
        Index of minimum ele_shape(:) index to start search from. Default is 1.
        This parameter is an input/output and is modified in-place. As an output: Ele_shape(
    """
def tao_eval_floor_orbit(datum: TaoDataStruct, ele: EleStruct, orbit: CoordStruct, bunch_params: BunchParamsStruct) -> ...:
    """
    Routine to evaluate a floor_orbit datum at a given element.
    
    This routine is private and not for general use.
    
    Parameters
    ----------
    datum : unknown
        Datum info
    ele : EleStruct
        Lattice element to evaluate at.
    orbit : CoordStruct
        Particle orbit at element.
    bunch_params : BunchParamsStruct
        Bunch parameters at element.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    valid_value : bool
        Was able to evalute the datum?
    why_invalid : unknown
        If not valid, why not.
    value : float
        Datum value.
    """
def tao_evaluate_a_datum(datum: TaoDataStruct, u: TaoUniverseStruct, tao_lat: TaoLatticeStruct, called_from_lat_calc: bool | None = None, print_err: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    datum : TaoDataStruct
        What type of datum
    u : TaoUniverseStruct
        Which universe to use.
    tao_lat : TaoLatticeStruct
        Lattice to use.
    datum_value : float
        Value of the datum.
    valid_value : bool
        Set false when there is a problem. Set true otherwise.
    why_invalid : unknown
        Tells why datum value is invalid.
    called_from_lat_calc : bool, optional
        Default is False. If true, prevents infinite loop of this -- logical, optional: Default is False. If true,
        prevents infinite loop of this routine calling tao_lattice_calc
    print_err : bool, optional
        Default is True. If False, do not print an error message.
    """
def tao_evaluate_datum_at_s(datum: TaoDataStruct, tao_lat: TaoLatticeStruct, ele: EleStruct, ele_ref: EleStruct, valid_value: bool) -> ...:
    """
    Routine to evaluate a datum at a given s-position in the lattice
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum to evaluate.
    tao_lat : TaoLatticeStruct
    ele : EleStruct
        Evaluation element.
    ele_ref : EleStruct
        Reference element.
    valid_value : bool
        True if evaluation was sucessful. False if not.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err_str : unknown
        Error string for printing an error message.
    bad_datum : bool
        True -> datum is malformed. False -> Could evaluate or evaluation problem was not due to the datum itself
        (EG: the lattice was unstable).
    value : float
        Datum value.
    """
def tao_evaluate_lat_or_beam_data(data_name: str, print_err: bool, default_source: str, dflt_ele_ref: _pybmad.EleStruct | None = None, dflt_ele_start: _pybmad.EleStruct | None = None, dflt_ele: _pybmad.EleStruct | None = None, dflt_component: str | None = None, dflt_uni: typing.SupportsInt | None = None, dflt_eval_point: typing.SupportsInt | None = None, dflt_s_offset: typing.SupportsFloat | None = None) -> PyTaoEvaluateLatOrBeamData:
    """
    dflt_ele_ref, dflt_ele_start, dflt_ele, dflt_component, dflt_uni, dflt_eval_point, dflt_s_offset)
    
    Routine to evaluate data with a lat or beam source of the form:
    <universe>@lat::<data_type>[<ix_ele_start>&<ix_ele>]|<component>
    
    Parameters
    ----------
    data_name : unknown
        data name.
    print_err : bool
        Print error message?
    dflt_source : unknown
        If not blank: Default source: 'lat' or 'beam'.
    dflt_ele_ref : EleStruct, optional
        Default reference element.
    dflt_ele_start : EleStruct, optional
        Default start element.
    dflt_ele : EleStruct, optional
        Default element to evaluate at.
    dflt_component : unknown, optional
        Default component: 'model' (default), 'base', or 'design'.
    dflt_uni : int, optional
        Default universe to use.
    dflt_eval_point : int, optional
        Default eval_point. anchor_end$ (default), anchor_center$, or anchor_beginning$.
    dflt_s_offset : float, optional
        Default offset of eval_point. Default = 0.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    err : bool
        True if there is an error. False otherwise.
    values : float
        Array of datum valuse.
    """
def tao_evaluate_tune(q_str: str, q0: typing.SupportsFloat, delta_input: bool, q_val: typing.SupportsFloat) -> PyTaoEvaluateTune:
    """
    No docstring available
    
    Parameters
    ----------
    q_str : unknown
        String expression.
    q0 : float
        Default to use if q_str evaluates to zero. Also used to set the integer part of the tune.
    delta_input : bool
        If true then qa_str and qb_str are deltas from present tune. Outut:
    q_val : 
    """
def tao_expression_hash_substitute(expression_in: str, eval_ele: _pybmad.EleStruct | None = None) -> str:
    """
    Routine to, in the expression, substitute the evaluation lattice element name in place
    
    of hash ("#") characters. Care is taken to only do this where it makes sense.
    For example, "Q1##3" where here "##3" means the third instance of Q1, does not qualify.
    Specifically, a substitution will be done if the character before the hash and the
    character after are one of:
    [,]-*+/:|@<>, or a blank character, or the beginning or end of the expression
    
    Parameters
    ----------
    expression_in : unknown
        Expression.
    eval_ele : EleStruct, optional
        Evaluation element name to substitute in. If not present, expression will not be modified.
    
    Returns
    -------
    expression_out : unknown
        Expression with substitutions made.
    """
def tao_find_plot_region(where: str, print_flag: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    err : bool
        Set True on error. False otherwise.
    where : unknown
        Region name.
    region : TaoPlotRegionStruct
        Region found.
    print_flag : bool, optional
        If present and False then surpress error messages. Default is True.
    """
def tao_fixer(switch_: str, word1: str, word2: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    switch : unknown
        Action to take. One on : 'activate', 'save', 'write'.
    word1 : unknown
        First word of command.
    word2 : unknown
        Secton word of command.
    """
def tao_floor_to_screen(graph: TaoGraphStruct, r_floor: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    graph : TaoGraphStruct
        Graph defining the projection plane.
    r_floor : 
    x_screen : float
        x-coordinate of projected point.
    y_screen : float
        y-coordinate of projected point.
    """
def tao_floor_to_screen_coords(graph: TaoGraphStruct, floor: FloorPositionStruct) -> FloorPositionStruct:
    """
    No docstring available
    
    Parameters
    ----------
    graph : TaoGraphStruct
        Graph defining the projection plane.
    floor : FloorPositionStruct
        3D coordinate.
    screen : FloorPositionStruct
        Projected point .r(3)   -- projected (x, y) = (.r(1), .r(2)) .theta  -- angle in (x, y) plane of
        projection of the orientation vector.
    """
def tao_geodesic_lm_optimizer() -> bool:
    """
    Routine to minimize the merit function by varying variables until
    
    the "data" as calculated from the model matches the measured data.
    This subroutine is a wrapper for the "geodesic"
    Levenburg - Marquardt method.
    
    
    Returns
    -------
    abort : bool
        Set True if an user stop signal detected.
    """
def tao_get_data() -> ...:
    """
    Subroutine to get the values of the data used in optimization and put them
    
    in an array. The data is ordered starting with the first universe
    
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    data_value : float
        Data model values.
    data_weight : float
        Data weights in the merit function.
    data_meas_value : float
        Data values when the data was taken.
    data_ix_dModel : int
        Data ix_dModel indices
    """
def tao_get_opt_vars() -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    var_value : float
        Variable model values.
    var_step : float
        Variable step sizes.
    var_delta : float
        Variable Merit deltas.
    var_weight : float
        Variable weights in the merit function.
    var_ix : int
        Variable s.var(:) indexes
    ignore_if_weight_is_zero : bool
        If present and True then ignore all variables whose merit weight is zero.
    ignore_if_not_limited : bool
        If present and True then ignore all variables with limit constraint that are not limited.
    """
def tao_get_user_input(prompt_str: str | None = None, wait_flag: bool | None = None, cmd_in: str | None = None) -> str:
    """
    Subroutine to get the next Tao command. In order of precedence, input may come from:
    
    1) s%com%cmd string (if s%com%use_cmd_here is set to True).
    Used for recalling commands from the history stack.
    2) A saved command string.
    3) A command file.
    4) The cmd_in argument (if present). Used, for example, when interfacing with Python.
    5) The terminal.
    For example, the following string is read from a command file or terminal or passed via cmd_in:
    "show ele 1; set opti de; run"
    Then cmd_out would be "show ele 1" and "set opti de; run" would be saved for the next call to this routine.
    
    Parameters
    ----------
    prompt_str : unknown, optional
        Primpt string to print at terminal. If not present then s.global.prompt_string will be used.
    wait_flag : bool, optional
        Used for single mode: Wait state for get_a_char call.
    cmd_in : unknown, optional
        Command to be used in place getting user input.
    
    Returns
    -------
    cmd_out : unknown
        Command from the user.
    
    Notes
    -----
    Note: A saved command string is present if a prior input string contained multiple commands.
    """
def tao_graph_controller_setup(graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    graph : 
    """
def tao_graph_data_setup(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    """
def tao_graph_data_slice_setup(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    """
def tao_graph_dynamic_aperture_setup(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    """
def tao_graph_histogram_setup(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    """
def tao_graph_name(graph: TaoGraphStruct, use_region: bool | None = None, graph_name: str) -> PyTaoGraphName:
    """
    No docstring available
    
    Parameters
    ----------
    graph : TaoGraphStruct
        Graph
    use_region : bool
        If present and True then use the region name instead of the plot name. Region name is 'NULL_REGION' if
        there is no assocaited region.
    graph_name : 
    """
def tao_graph_phase_space_setup(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    """
def tao_graph_s_min_max_calc(graph: TaoGraphStruct, branch: BranchStruct) -> ...:
    """
    Routine to calculate min and max for a graph when plot%x_axis_type is set to "s".
    
    Parameters
    ----------
    graph : TaoGraphStruct
        Graph to calculate for.
    branch : BranchStruct
        Associated lattice branch.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    s_min : float
        Graph min. May be negative with graph.allow_wrap_around = T.
    s_max : float
        Graph max.
    """
def tao_graph_setup(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    plot : 
    graph : 
    """
def tao_init() -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    err_flag : bool
        Set Treu if there is an error. False otherwise.
    """
def tao_init_beam_in_universe(u: TaoUniverseStruct, beam_init: BeamInitStruct, track_start: str, track_end: str, comb_ds_save: typing.SupportsFloat) -> PyTaoInitBeamInUniverse:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    beam_init : 
    track_start : 
    track_end : 
    comb_ds_save : 
    """
def tao_init_beams(init_file: str) -> None:
    """
    Subroutine to initialize beam stuff.
    
    Parameters
    ----------
    init_file : unknown
        Tao initialization file. If blank, there is no file so just use the defaults.
    """
def tao_init_data(data_file: str) -> None:
    """
    Subroutine to initialize the tao data structures.
    
    Parameters
    ----------
    data_file : unknown
        Tao data initialization file. If blank, there is no file so just use the defaults.
    """
def tao_init_data_end_stuff() -> None:
    """
    No docstring available
    """
def tao_init_data_in_universe(u: TaoUniverseStruct, n_d2_add: typing.SupportsInt, keep_existing_data: bool | None = None) -> PyTaoInitDataInUniverse:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    n_d2_add : 
    keep_existing_data : 
    """
def tao_init_dynamic_aperture(init_file: str) -> None:
    """
    Routine to initalize dynamic aperture simulations.
    
    Parameters
    ----------
    init_file : unknown
        File setting dynamic_aperture parameters.
    """
def tao_init_find_elements(u: TaoUniverseStruct, search_string: str, attribute: str | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    u : TaoUniverseStruct
        Universe to search
    search_string : unknown
        What to search for
    eles : ElePointerStruct
        List of matching elements. Size is zero if no elements found.
    attribute : unknown, optional
        Check that attribute of element is free to vary.
    found_one : bool
        Set True if a matching element is found. However: Not set if no matching element found.
    """
def tao_init_global(init_file: str) -> None:
    """
    Subroutine to initialize the tao global structures.
    
    Parameters
    ----------
    init_file : unknown
        Tao initialization file. If blank, there is no file so just use the defaults.
    """
def tao_init_lattice(lat_file: str, err_flag: bool) -> PyTaoInitLattice:
    """
    No docstring available
    
    Parameters
    ----------
    lat_file : 
    err_flag : 
    """
def tao_init_plotting(plot_file: str) -> PyTaoInitPlotting:
    """
    No docstring available
    
    Parameters
    ----------
    plot_file : 
    """
def tao_init_variables(var_file: str) -> None:
    """
    Subroutine to initialize the tao variable structures.
    
    Parameters
    ----------
    var_file : unknown
        Tao variable initialization file. If blank, there is no file so just use the defaults.
    """
def tao_inject_beam(u: TaoUniverseStruct, model: TaoLatticeStruct, ix_branch: typing.SupportsInt) -> ...:
    """
    This will initialize the beam for a given lattice branch.
    
    Trying to inject a beam of one species into a branch with a different ref species
    (example: electron bunch into photon branch) is problematical. To avoid problems, Tao
    will set not inject (init_ok = False) if there is a mismatch.
    
    Parameters
    ----------
    u : TaoUniverseStruct
        Universe containing the lattice.
    model : TaoLatticeStruct
        Universe parameters.
    ix_branch : int
        Lattice branch index to inject into.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    beam : BeamStruct
        Initial beam.
    init_ok : bool
        Set False if there are problems. True otherwise.
    """
def tao_inject_particle(u: TaoUniverseStruct, model: TaoLatticeStruct, ix_branch: typing.SupportsInt) -> PyTaoInjectParticle:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    model : 
    ix_branch : 
    """
def tao_is_valid_name(name: str, is_valid: bool) -> PyTaoIsValidName:
    """
    implicit none
    
    character(*) single_mode_file
    end subroutine
    
    Parameters
    ----------
    name : unknown
        Name to be checked.
    
    Returns
    -------
    why_invalid : unknown
        Why invalid description.
    """
def tao_json_cmd(input_str: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    input_str : unknown
        What to show.
    """
def tao_key_info_to_str(ix_key: typing.SupportsInt, ix_min_key: typing.SupportsInt, ix_max_key: typing.SupportsInt, key_str: str, header_str: str) -> PyTaoKeyInfoToStr:
    """
    No docstring available
    
    Parameters
    ----------
    ix_key : 
    ix_min_key : 
    ix_max_key : 
    key_str : 
    header_str : 
    """
def tao_lat_bookkeeper(u: TaoUniverseStruct, tao_lat: TaoLatticeStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    u : TaoUniverseStruct
    tao_lat : TaoLatticeStruct
    err_flag : bool
        Set True if there is a problem. False otherwise.
    """
def tao_lat_emit_calc(plane: typing.SupportsInt, emit_type: typing.SupportsInt, ele: EleStruct, modes: NormalModesStruct, emit: typing.SupportsFloat) -> PyTaoLatEmitCalc:
    """
    No docstring available
    
    Parameters
    ----------
    plane : int
        x_plane$ or y_plane$.
    emit_type : int
        Either projected_emit$ or apparent_emit$
    ele : EleStruct
        Element holding the Twiss and coupling parameters.
    modes : NormalModesStruct
        Structure holding the emittances
    emit : 
    """
def tao_lat_sigma_calc_needed(data_type: str, data_source: str, do_lat_sigma: bool) -> PyTaoLatSigmaCalcNeeded:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : 
    data_source : 
    do_lat_sigma : 
    """
def tao_lat_sigma_track(tao_lat: TaoLatticeStruct, ix_branch: typing.SupportsInt, print_err: bool | None = None, force_calc: bool | None = None) -> bool:
    """
    Routine to track the 6x6 sigma matrix through the lattice using the lattice linear transfer matrices.
    
    Parameters
    ----------
    tao_lat : TaoLatticeStruct
        Structure containing the lattice.
    ix_branch : int
        Branch index to track through.
    print_err : bool, optional
        Default is False. Print error messages if, eg, lattice is unstable?
    force_calc : bool, optional
        Default is False. If True, force the calculation to be done.
    
    Returns
    -------
    calc_ok : bool
        Set True if there were no problems, False otherwise.
    """
def tao_lattice_branches_equal_tao_lattice_branches(tlb1: TaoLatticeBranchStructAlloc1D, tlb2: TaoLatticeBranchStructAlloc1D) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    tlb1 : 
    tlb2 : 
    """
def tao_lattice_calc() -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    calc_ok : bool
        Set False if there was an error in the calculation like a particle was lost or a lat is unstable.
    print_err : bool
        Default True. If False, do not print error messages if, for example, the lattice is unstable.
    """
def tao_lattice_equal_tao_lattice(lat1: TaoLatticeStruct, lat2: TaoLatticeStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat1 : 
    lat2 : 
    """
def tao_limit_calc() -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    limited : bool
        Set True if a variable is past a limit.
    """
def tao_lm_optimizer() -> bool:
    """
    Routine to minimize the merit function by varying variables until
    
    the "data" as calculated from the model matches the measured data.
    This subroutine is a wrapper for the mrqmin routine of Numerical Recipes.
    See the Numerical Recipes writeup for more details.
    'lm' stands for Levenburg - Marquardt. Otherwise known as LMDIF.
    
    
    Returns
    -------
    abort : bool
        Set True if an user stop signal detected.
    """
def tao_lmdif_optimizer() -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    abort : bool
        Set True if an user stop signal detected or there is a problem with calculating the merit function.
    """
def tao_load_this_datum(vec: RealAlloc1D, ele_ref: EleStruct, ele_start: EleStruct, ele: EleStruct, datum_value: typing.SupportsFloat, valid_value: bool, datum: TaoDataStruct, branch: BranchStruct, why_invalid: str | None = None, good: _pybmad.BoolAlloc1D | None = None) -> PyTaoLoadThisDatum:
    """
    No docstring available
    
    Parameters
    ----------
    vec : 
    ele_ref : 
    ele_start : 
    ele : 
    datum_value : 
    valid_value : 
    datum : 
    branch : 
    why_invalid : 
    good : 
    """
def tao_locate_all_elements(ele_list: str, ignore_blank: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele_list : unknown
        String with element names using element list format.
    eles : unknown
        : Array of elements in the model lat. .id  -- Set to universe number.
    err : bool
        Set true on error.
    ignore_blank : bool, optional
        If present and true then do nothing if ele_list is blank. otherwise a blank is treated as an error.
    """
def tao_locate_elements(ele_list: str, ix_universe: typing.SupportsInt, lat_type: typing.SupportsInt | None = None, ignore_blank: bool | None = None, err_stat_level: typing.SupportsInt | None = None, above_ubound_is_err: bool | None = None, ix_branch: typing.SupportsInt | None = None, multiple_eles_is_err: bool | None = None) -> PyTaoLocateElements:
    """
    No docstring available
    
    Parameters
    ----------
    ele_list : unknown
        String with element names using element list format.
    ix_universe : int
        Universe to search. -1 => search s.global.default_universe. -2 (all unis) => error. ix_universe is ignored
        if ele_list starts with a universe specifier "N@".
    eles : unknown
        : Array of elements in the model lat.
    err : bool
        Set true on error.
    lat_type : int, optional
        model$ (default), design$, or base$.
    ignore_blank : bool, optional
        If present and true then do nothing if ele_list is blank. otherwise treated as an error.
    err_stat_level : int, optional
        Status level for error messages. If not present, print with level s_error$. Use s_nooutput$ to prevent
        printing.
    above_ubound_is_err : 
    ix_branch : int, optional
        If present and non-negative then use this as the branch index for elements specified using an integer
        index (EG: "43"). If -1 use the default branch, search all branches.
    multiple_eles_is_err : bool, optional
        If present and True then matching to more than one element is an error. -- logical, optional: If present
        and True then matching to more than one element is an error.
    """
def tao_mark_lattice_ele(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Input lattice
        This parameter is an input/output and is modified in-place. As an output: Lattice with elements marked.
    """
def tao_merit(this_merit: typing.SupportsFloat) -> PyTaoMerit:
    """
    No docstring available
    
    Parameters
    ----------
    calc_ok : bool
        Set False if there was an error in the calculation like a particle was lost or a lat is unstable.
    this_merit : 
    """
def tao_next_word(line: str) -> PyTaoNextWord:
    """
    Routine to return the next word in a line.
    
    Words are delimited by a space character except if the space is within quotes.
    Additionally, spaces within brackets "(...)", "{...}", and "[...]" are ignored.
    Outer quote marks will be removed in the returned word.
    
    Parameters
    ----------
    line : unknown
        String to parse.
        This parameter is an input/output and is modified in-place. As an output: String with first word removed.
    
    Returns
    -------
    word : unknown
        First word of line.
    """
def tao_one_turn_map_calc_needed(data_type: str, data_source: str, do_one_turn_map: bool) -> PyTaoOneTurnMapCalcNeeded:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : 
    data_source : 
    do_one_turn_map : 
    """
def tao_open_file(file: str, file_name: str, error_severity: typing.SupportsInt, binary: bool | None = None) -> PyTaoOpenFile:
    """
    No docstring available
    
    Parameters
    ----------
    file : 
    iunit : int
        Logical unit number. Set to 0 if file not openable.
    file_name : unknown
        File name.
    error_severity : int
        Severity level used in the error message. Possibilities are s_fatal$, etc. See out_io doc for more
        details. Use -1 to not print a message if file cannot be opened.
    binary : bool, optional
        If present and True then open a binary file, Defaut is False.
    """
def tao_open_scratch_file(iu: typing.SupportsInt) -> PyTaoOpenScratchFile:
    """
    No docstring available
    
    Parameters
    ----------
    err : bool
        Set True if there is an error. False otherwise.
    iu : 
    """
def tao_optimization_status(datum: TaoDataStruct, why_str: str) -> PyTaoOptimizationStatus:
    """
    No docstring available
    
    Parameters
    ----------
    datum : TaoDataStruct
        Datum to evaluate.
    why_str : 
    """
def tao_orbit_beta_wave_anal(plot: TaoPlotStruct) -> None:
    ...
def tao_oreint_building_wall_pt(pt_in: TaoBuildingWallPointStruct, pt_out: TaoBuildingWallPointStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    pt_in : TaoBuildingWallPointStruct
        Building wall point.
    pt_out : 
    """
def tao_param_value_at_s(dat_name: str, ele_to_s: EleStruct, ele_here: EleStruct, orbit: CoordStruct, value: typing.SupportsFloat) -> PyTaoParamValueAtS:
    """
    No docstring available
    
    Parameters
    ----------
    dat_name : 
    ele_to_s : EleStruct
        Element whose exit end is at the evaluation s-position.
    ele_here : EleStruct
        Lattice element that overlaps the s-position ele.s.
    orbit : CoordStruct
        Orbit at the evaluation s-position.
    err_flag : bool
        Set true if parameter cannot be evaluated.
    why_invalid : unknown
        Set if  err_flag = True to document why is there a problem.
    print_err : bool
        Print error message on error? Default is True.
    bad_datum : bool
        Data_type is malformed.
    value : 
    """
def tao_parse_command_args(cmd_line: str | None = None) -> PyTaoParseCommandArgs:
    """
    No docstring available
    
    Parameters
    ----------
    error : bool
        Set True if there is an error. False otherwise.
    cmd_line : 
    """
def tao_parse_element_param_str(in_str: str) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    err : bool
        Set True if there is a parse error. False otherwise.
    in_str : unknown
        String specifying a parameter of an element or elements.
    uni : unknown
        Universe substring.
    element : unknown
        Element name.
    parameter : unknown
        Element parameter name.
    where : int
        One of not_set$, anchor_beginning$, anchor_center$, or anchor_end$.
    component : unknown
        One of "model", "design", or "base".
    """
def tao_particle_data_value(data_type: str, p: CoordStructAlloc1D, ele: EleStruct, ix_bunch: typing.SupportsInt) -> ...:
    """
    Routine to calculate the value array of a data_type for an array of particles.
    
    Parameters
    ----------
    data_type : unknown
        Type of data.
    p : 
        coord_struct, Array of particles containing the data.
    ele : EleStruct
        Needed for "Ja" evaluation.
    ix_bunch : int
        Bunch index.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    value : float
        Array of values.
    err : bool
        Set True if there is an error. False otherwise.
    """
def tao_pause_cmd(time: typing.SupportsFloat) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    time : float
        Time to pause in seconds.
    """
def tao_phase_space_axis_index(data_type: str, err: bool) -> int:
    """
    Routine to calculate the phase space axis index for a given data type.
    
    Parameters
    ----------
    data_type : unknown
        Type of data.
    err : bool
        Set True if there is an error.
    
    Returns
    -------
    ix_axis : int
        Axis index.
    """
def tao_phase_wave_anal(plot: TaoPlotStruct) -> None:
    ...
def tao_pick_universe(name_in: str, dflt_uni: typing.SupportsInt | None = None, pure_uni: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    name_in : unknown
        data name with possible universe spec.
    name_out : unknown
        name_in without any "n@" beginning.
    picked : bool
        Array showing picked universes. The array will be resized if necessary.
    err : bool
        Set True if an error is detected.
    ix_uni : int
        Set to the picked universe with the highest index.
    explicit_uni : bool
        Set True if name_in has explicit universe "n@" specification.
    dflt_uni : int, optional
        Default universe to use. Set to -1 if explicit universe is required.
    pure_uni : bool, optional
        Default is False. See above
    """
def tao_pipe_cmd(input_str: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    input_str : unknown
        What to show.
    """
def tao_place_cmd(where: str, who: str, no_buffer: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    where : unknown
        Region where the plot goes. Eg: 'top'.
    who : unknown
        Type of plot. Eg: 'orbit'.
    no_buffer : bool, optional
        If present and True then prevents buffering in the case when s.global.external_plotting = T Output
        s.plot_page.plot(j) -- Plot matched to where.
    """
def tao_plot_cmd(where: str, component: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    where : unknown
        Region name to identify the plot to set.
    component : unknown
        Who to plot. EG: 'meas - design'
    """
def tao_plot_data(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw a graph with data and/or variable curves.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_plot_histogram(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw one graph for the histogram analysis plot.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_plot_key_table(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw a key table graph.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_plot_setup() -> None:
    """
    No docstring available
    """
def tao_plot_struct_transfer(plot_in: TaoPlotStruct) -> TaoPlotStruct:
    """
    No docstring available
    
    Parameters
    ----------
    plot_in : TaoPlotStruct
        Input structure.
    plot_out : TaoPlotStruct
        Output struture.
    """
def tao_plot_wave(plot: TaoPlotStruct, graph: TaoGraphStruct) -> None:
    """
    Routine to draw one graph for the wave analysis plot.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot containing the graph.
    graph : TaoGraphStruct
        Graph to plot.
    """
def tao_pointer_to_building_wall_shape(wall_name: str, e_shape: TaoEleShapeStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    wall_name : unknown
        Name of the wall.
    e_shape : 
    """
def tao_pointer_to_datum(d1: TaoD1DataStruct, ele_name: str, datum_ptr: TaoDataStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    d1 : TaoD1DataStruct
        D1 data struct to search.
    ele_name : unknown
        Name of lattice element to match to. Ouput:
    datum_ptr : 
    """
def tao_pointer_to_datum_ele(lat: LatStruct, ele_name: str, ix_ele: typing.SupportsInt, datum: TaoDataStruct, print_err: bool | None = None) -> PyTaoPointerToDatumEle:
    """
    Routine to see if an element index corresponds to an element with a definite
    
    location such as an overlay or multipass element.
    If the element is a super_lord then the super_slave element at the exit end
    of the lord will be returned. Otherwise ix_loc will be set to ix_ele.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
    ix_ele : int
        Index of element.
    datum : TaoDataStruct
        Used for error messages and gives branch index.
    print_err : bool, optional
        Default is True. If False, do not print an error message.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ele : EleStruct
        : Pointer to the element. Set to NULL if not valid or no associated element.
    valid : bool
        Set False if element does not have a definite location. Set True otherwise
    why_invalid : unknown
        Tells why datum value is invalid.
    """
def tao_pointer_to_ele_shape(ix_uni: typing.SupportsInt, ele: EleStruct, ele_shape: TaoEleShapeStructAlloc1D, ix_shape_min: typing.SupportsInt | None = None, e_shape: TaoEleShapeStruct) -> PyTaoPointerToEleShape:
    """
    No docstring available
    
    Parameters
    ----------
    ix_uni : int
        Universe index.
    ele : EleStruct
        Lattice element.
    ele_shape : TaoEleShapeStruct
        Array of shapes to search.
    dat_var_name : unknown
        Name of datum or variable associated with e_shape. Will be set to "" if there is no associated datum or
        variable.
    dat_var_value : float
        Value of datum or variable associated with e_shape. Will be set to zero if there is no associated datum or
        variable.
    ix_shape_min : int, optional
        Index of minimum ele_shape(:) index to start search from. Default is 1.
        This parameter is an input/output and is modified in-place. As an output: Ele_shape(
    e_shape : 
    """
def tao_pointer_to_tao_lat(u: TaoUniverseStruct, lat_type: typing.SupportsInt | None = None, tao_lat: TaoLatticeStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    u : TaoUniverseStruct
        Universe to work with
    lat_type : int, optional
        model$ (default), design$, or base$.
    tao_lat : 
    """
@typing.overload
def tao_pointer_to_universe(ix_uni: typing.SupportsInt, neg2_to_default: bool | None = None, u: TaoUniverseStruct) -> PyTaoPointerToUniverseInt:
    """
    Overloaded by tao_pointer_to_universe. See this routine for more details.
    
    
    Returns
    -------
    u
    """
@typing.overload
def tao_pointer_to_universe(string: str, neg2_to_default: bool | None = None, u: TaoUniverseStruct) -> PyTaoPointerToUniverseStr:
    """
    Overloaded by tao_pointer_to_universe. See this routine for more details.
    
    
    Returns
    -------
    u
    """
def tao_pointer_to_universes(name_in: str, dflt_uni: typing.SupportsInt | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    name_in : unknown
        data name with possible universe spec.
    unis : TaoUniversePointerStruct
        Array of pointers to picked universes. The array will be resized if necessary.
    err : bool
        Set True if an error is detected.
    name_out : unknown
        name_in without any "n@" beginning.
    explicit_uni : bool
        Set True if name_in has explicit universe "n@" specification.
    dflt_uni : int, optional
        Default universe to use. Set to -1 if explicit universe is required.
    """
def tao_pointer_to_var_in_lattice(var: TaoVarStruct, ix_uni: typing.SupportsInt, ele: EleStruct) -> bool:
    """
    Routine to add a pointer from a given Tao variable
    
    to the appropriate variable in a lattice.
    
    Parameters
    ----------
    var : TaoVarStruct
        Structure has the info of where to point.
    ix_uni : int
        the universe to use
    ix_ele : int
        Index of element. var.slave(ix_slave) -- Tao_var_slave_struct: New component of .slave(:) array is added.
        .model_ptr .base_ptr .ix_ele .ix_uni
    
    Returns
    -------
    err : bool
        Set True if there is an error. False otherwise.
    """
def tao_pointer_to_var_in_lattice2(var: TaoVarStruct, ix_uni: typing.SupportsInt) -> bool:
    """
    Routine to add a pointer from a given Tao variable
    
    to the appropriate variable in a lattice.
    
    Parameters
    ----------
    var : TaoVarStruct
        Structure has the info of where to point.
    ix_uni : int
        the universe to use var.slave(ix_slave) -- Tao_var_slave_struct: New component of .slave(:) array is
        added. .model_ptr .base_ptr .ix_ele .ix_uni
    
    Returns
    -------
    err : bool
        Set True if there is an error. False otherwise.
    """
def tao_print_command_line_info() -> None:
    """
    No docstring available
    """
def tao_ptc_normal_form(do_calc: bool, tao_lat: TaoLatticeStruct, ix_branch: typing.SupportsInt, rf_on: typing.SupportsInt | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    do_calc : bool
        Set True to do the calculation.
    tao_lat : TaoLatticeStruct
        Lattice to work on.
    ix_branch : int
        Branch of lattice to work on.
    rf_on : int, optional
        RF state for calculation. yes$, no$, or maybe$ (default) maybe$ means that RF state in branch is used.
    """
def tao_python_cmd(input_str: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    input_str : unknown
        What to show.
    """
def tao_quiet_set(set: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    set : bool
        True is silent running is wanted.
    """
def tao_rad_int_calc_needed(data_type: str, data_source: str, do_rad_int: bool) -> PyTaoRadIntCalcNeeded:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : 
    data_source : 
    do_rad_int : 
    """
def tao_re_execute(string: str, err: bool) -> PyTaoReExecute:
    """
    Subroutine to execute a previous command.
    """
def tao_read_cmd(which: str, unis: str, file: str, silent: bool) -> PyTaoReadCmd:
    """
    No docstring available
    
    Parameters
    ----------
    which : 
    unis : unknown
        Universes to apply to
    file : 
    silent : bool
        Silent
    """
def tao_read_phase_space_index(name: str, ixc: typing.SupportsInt, print_err: bool | None = None, ix_ps: typing.SupportsInt) -> PyTaoReadPhaseSpaceIndex:
    """
    No docstring available
    
    Parameters
    ----------
    name : unknown
        character array holding the index. Must be in the range 1-6.
    ixc : int
        location within <name> to evaluate index.
    print_err : bool, optional
        If present and False then do not print an error message
    ix_ps : 
    """
def tao_regression_test() -> None:
    """
    No docstring available
    """
def tao_remove_blank_characters(str: str) -> PyTaoRemoveBlankCharacters:
    """
    No docstring available
    
    Parameters
    ----------
    str : unknown
        Input string.
        This parameter is an input/output and is modified in-place. As an output: String with blank characters
        removed.
    """
def tao_run_cmd(which: str) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    which : unknown
        which optimizer to use. ' '        -- Same as last time 'de'       -- Differential Evolution. 'lm'
        -- Levenberg - Marquardt (aka lmdif). 'custom'   -- Custom routine.
    abort : bool
        Set True if the run was aborted by the user, an at minimum condition, a singular matrix condition, etc..
        False otherwise.
    """
def tao_scale_cmd(where: str, y_min_in: typing.SupportsFloat, y_max_in: typing.SupportsFloat, axis: str | None = None, include_wall: bool | None = None, gang: str | None = None, exact: bool | None = None, turn_autoscale_off: bool | None = None) -> None:
    """
    Routine to scale a plot.
    
    If y_min = y_max, the scales will be chosen to show all the data.
    
    Parameters
    ----------
    where : unknown
        Region to scale. Eg: "top:x"
    y_min_in : float
        Plot y-axis min value.
    y_max_in : float
        Plot y-axis max value.
    axis : unknown, optional
        'y', 'y2', or '' (both). Default = ''.
    include_wall : bool, optional
        Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
        include the building wall position will be included in determining the the scale.
    gang : unknown, optional
        'gang', 'nogang', ''. Default = ''.
    exact : bool, optional
        Exact plot y_max, y_min to correspond to y_min_in, y_max_in? Default is False. Only relavent when y_min_in
        /= y_max_in.
    turn_autoscale_off : bool, optional
        If True (default) then turn off plot.autoscale_y logical for all plots that are scaled.
    """
def tao_scale_graph(graph: TaoGraphStruct, y_min: typing.SupportsFloat, y_max: typing.SupportsFloat, axis: str | None = None, include_wall: bool | None = None) -> ...:
    """
    Routine to scale the y-axis and/or y2-axis of a graph
    
    If y_min = y_max then autoscaling will be done and the particular value of y_min and y_max is ignored.
    
    Parameters
    ----------
    graph : TaoGraphStruct
        Graph with axis/axes to be scaled.
        This parameter is an input/output and is modified in-place. As an output: Graph with scaled axis/axes.
    y_min : float
        Axis [min, max] must cover [y_min, y_max] if not autoscaling.
    y_max : float
        Axis [min, max] must cover [y_min, y_max] if not autoscaling.
    axis : unknown, optional
        Axis to scale. ''   -> scale y and y2 (default). 'y'  -> scale y-axis. 'y2' -> scale y2-axis
    include_wall : bool, optional
        Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
        include the building wall position will be included in determining the the scale.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    y_range : float
        Only used by tao_scale_plot when ganging graphs.
    y2_range : float
        Only used by tao_scale_plot when ganging graphs.
    """
def tao_scale_ping_data(u: TaoUniverseStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    u : 
    """
def tao_scale_plot(plot: TaoPlotStruct, y_min_in: typing.SupportsFloat, y_max_in: typing.SupportsFloat, axis: str | None = None, include_wall: bool | None = None, gang: str | None = None, skip_lat_layout: bool | None = None) -> None:
    """
    Routine to scale the y-axis and/or y2-axis of the graphs of the plot.
    
    If y_min_in = y_max_in then autoscaling will be done and the particular value
    of y_min_in and y_max_in is ignored.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot with graphs to be scaled.
        This parameter is an input/output and is modified in-place. As an output: Plot with scaled graphs.
    y_min_in : float
        Axis [min, max] must cover [y_min_in, y_max_in] if not autoscaling.
    y_max_in : float
        Axis [min, max] must cover [y_min_in, y_max_in] if not autoscaling.
    axis : unknown, optional
        Axis to scale. ''   -> scale y and y2 (default). 'y'  -> scale y-axis. 'y2' -> scale y2-axis
    include_wall : bool, optional
        Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
        include the building wall position will be included in determining the the scale.
    gang : unknown, optional
        If autoscale then make all graph y-axes the same and/or make all y2-axes the same? ''        -> (default)
        Use setting of plot.autoscale_gang_y 'gang'    -> Gang graphs. 'nogang'  -> Do not gang graphs.
    skip_lat_layout : bool, optional
        If True, skip scaling any lat_layout graphs. Default is false.
    """
def tao_scratch_values_calc(ele_ref: EleStruct, ele_start: EleStruct, ele: EleStruct, datum: TaoDataStruct, branch: BranchStruct, orbit: CoordStructAlloc1D) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    ele_ref : 
    ele_start : 
    ele : 
    datum : 
    branch : 
    orbit : 
    """
def tao_set_beam_cmd(who: str, value_str: str, branch_str: str) -> None:
    """
    Routine to set various beam parameters.
    
    Parameters
    ----------
    who : unknown
        which parameter to set.
    value_str : unknown
        Value to set to.
    branch_str : unknown
        Branch to use. '' => branch 0.
    """
def tao_set_beam_init_cmd(who: str, value_str: str, branch_str: str) -> None:
    """
    Routine to set beam_init variables
    
    Parameters
    ----------
    who : unknown
        which beam_init variable to set
    value_str : unknown
        Value to set to.
    branch_str : unknown
        Branch to use. '' => branch 0 s.beam_init  -- Beam_init variables structure.
    """
def tao_set_bmad_com_cmd(who: str, value_str: str) -> None:
    """
    Routine to set bmad_com variables
    
    Parameters
    ----------
    who : unknown
        which bmad_com variable to set
    value_str : unknown
        Value to set to.
    """
def tao_set_branch_cmd(branch_str: str, component_str: str, value_str: str) -> None:
    """
    Routine to set lattice branch values.
    
    Parameters
    ----------
    branch_str : unknown
        Which branch to set.
    component_str : unknown
        Which branch parameter to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_calculate_cmd(switch_: str | None = None) -> PyTaoSetCalculateCmd:
    """
    Toggles off lattice calc and plotting.
    """
def tao_set_curve_cmd(curve_name: str, component: str, value_str: str) -> None:
    """
    Routine to set var values.
    
    Parameters
    ----------
    curve_name : unknown
        Which curve to set.
    component : unknown
        Which component to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_curve_invalid(curve: TaoCurveStruct, why_invalid: str, print_err: bool | None = None) -> None:
    """
    Routine to set curve%valid to False.
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve to set.
        This parameter is an input/output and is modified in-place. As an output: Curve properly set.
    why_invalid : unknown
        Invalid information.
    print_err : bool, optional
        If present and True then also print an error message.
    """
def tao_set_data_cmd(who_str: str, value_str: str, silent: bool | None = None) -> PyTaoSetDataCmd:
    """
    Routine to set data values.
    
    Parameters
    ----------
    who_str : unknown
        Which data component(s) to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_data_useit_opt(data: _pybmad.TaoDataStructAlloc1D | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    data : TaoDataStruct, optional
        Data to work on. Default is all data in all universes.
    """
def tao_set_default_cmd(who_str: str, value_str: str) -> None:
    """
    Routine to set default values.
    
    Parameters
    ----------
    who_str : unknown
        Which default component(s) to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_drawing_cmd(drawing: TaoDrawingStruct, component: str, value_str: str) -> None:
    """
    Routine to set floor_plan and lat_layout parameters.
    
    Parameters
    ----------
    drawing : TaoDrawingStruct
        s.plot_page.floor_plan or s.plot_page.lat_layout.
    component : unknown
        Which shape component to set.
    value_str : unknown
        Value to set to. s.shape  -- Shape variables structure.
    """
def tao_set_dynamic_aperture_cmd(who: str, value_str: str) -> None:
    """
    Sets dynamic aperture parameters.
    
    Parameters
    ----------
    who : unknown
        which parameter to set.
    value_str : unknown
        Value to set to.
    """
def tao_set_elements_cmd(ele_list: str, attribute: str, value: str, update: bool) -> PyTaoSetElementsCmd:
    """
    Sets element parameters.
    
    Parameters
    ----------
    ele_list : unknown
        which elements.
    attribute : unknown
        Attribute to set.
    value : unknown
        Value to set.
    """
def tao_set_floor_plan_axis_label(graph: TaoGraphStruct, axis_in: QpAxisStruct, axis_out: QpAxisStruct, which: str) -> PyTaoSetFloorPlanAxisLabel:
    """
    No docstring available
    
    Parameters
    ----------
    graph : 
    axis_in : 
    axis_out : 
    which : 
    """
def tao_set_geodesic_lm_cmd(who: str, value_str: str) -> None:
    """
    Routine to set geodesic_lm variables
    
    Parameters
    ----------
    who : unknown
        which geodesic_lm variable to set
    value_str : unknown
        Value to set to.
    """
def tao_set_global_cmd(who: str, value_str: str) -> None:
    """
    Routine to set global variables
    
    Parameters
    ----------
    who : unknown
        which global variable to set
    value_str : unknown
        Value to set to. s.global  -- Global variables structure.
    """
def tao_set_graph_cmd(graph_name: str, component: str, value_str: str) -> None:
    """
    Routine to set var values.
    
    Parameters
    ----------
    graph_name : unknown
        Which graph to set.
    component : unknown
        Which component to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_integer_value(var_str: str, value_str: str, min_val: typing.SupportsInt | None = None, max_val: typing.SupportsInt | None = None, print_err: bool | None = None) -> ...:
    """
    Subroutine to read and set the value of an integer varialbe.
    
    If the value is out of the range [min_val, max_val] then an error message will
    be generated and the variable will not be set.
    
    Parameters
    ----------
    var_str : unknown
        Used for error messages.
    value_str : unknown
        String with encoded value.
    min_val : int, optional
        Minimum value.
    max_val : int, optional
        Maximum value.
    print_err : bool, optional
        If True, print error message. Default is true
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    var : int
        Variable to set.
    error : bool
        Set True on an error. False otherwise.
    """
def tao_set_invalid(datum: TaoDataStruct, message: str, exterminate: bool | None = None, err_level: typing.SupportsInt | None = None, print_err: bool | None = None) -> str:
    """
    No docstring available
    
    Parameters
    ----------
    datum : TaoDataStruct
        Bad datum.
    message : unknown
        Error message.
    why_invalid : unknown
        Set to message if present.
    exterminate : bool, optional
        Default is False. If True, set datum.exists to False so that Tao will ignore this datum from now on.
    err_level : int, optional
        s_error$ (default), s_warn$, etc.
    print_err : bool, optional
        Default is True. If False, do not print an error message.
    """
def tao_set_key_cmd(key_str: str, cmd_str: str) -> None:
    """
    Associates a command with a key press for single mode.
    
    Parameters
    ----------
    key_str : unknown
        keyboard key.
    cmd_str : unknown
        Command associated with key.
    """
def tao_set_lattice_cmd(dest_lat: str, source_lat: str) -> None:
    """
    Sets a lattice equal to another. This will also update the data structs
    
    Parameters
    ----------
    dest_lat : unknown
        Maybe: 'model', 'design', or 'base' with optional '@n' at beginning to indicate the universe
    source_lat : unknown
        Maybe: 'model', 'design', or 'base' s.u(n) -- lat_struct: changes specified lattice in specified universe
    """
def tao_set_logical_value(var_str: str, value_str: str) -> ...:
    """
    Subroutine to read and set the value of an logical varialbe.
    
    If the value is out of the range [min_val, max_val] then an error message will
    be generated and the variable will not be set.
    
    Parameters
    ----------
    var_str : unknown
        Used for error messages.
    value_str : unknown
        String with encoded value.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    var : bool
        Variable to set.
    error : bool
        Set True on an error. False otherwise.
    """
def tao_set_openmp_n_threads(n_threads: typing.SupportsInt) -> None:
    """
    Routine to set OpenMP thread count.  Errors if OpenMP is not available.
    
    Parameters
    ----------
    n_threads : int
        Number of threads.
    """
def tao_set_opt_vars(var_vec: RealAlloc1D, print_limit_warning: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    var_vec : float
        Vector of variables.
    print_limit_warning : bool, optional
        Print a warning if the value is past the variable's limits. -- Logical, optional: Print a warning if the
        value is past the variable's limits. Default is True.
    """
def tao_set_opti_de_param_cmd(who: str, value_str: str) -> None:
    """
    Routine to set opti_de_param variables
    
    Parameters
    ----------
    who : unknown
        which opti_de_param variable to set
    value_str : unknown
        Value to set to.
    """
def tao_set_particle_start_cmd(who: str, value_str: str) -> None:
    """
    Routine to set particle_start variables.
    
    Parameters
    ----------
    who : unknown
        which particle_start variable to set
    value_str : unknown
        Value to set to. s.particle_start  -- Beam_start variables structure.
    """
def tao_set_plot_cmd(plot_name: str, component: str, value_str: str) -> None:
    """
    Routine to set plot parameters.
    
    Parameters
    ----------
    plot_name : unknown
        Which plot to set.
    component : unknown
        Which component to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_plot_page_cmd(component: str, value_str: str, value_str2: str | None = None) -> None:
    """
    Set various aspects of the plotting window
    
    Parameters
    ----------
    component : unknown
        Which component to set.
    value_str : unknown
        What value to set to.
    value_str2 : unknown
        2nd value if component is an array. s.plot       -- tao_plotting_struct:
    """
def tao_set_ptc_com_cmd(who: str, value_str: str) -> None:
    """
    Routine to set ptc_com variables
    
    Parameters
    ----------
    who : unknown
        which ptc_com variable to set
    value_str : unknown
        Value to set to.
    """
def tao_set_qp_axis_struct(qp_axis_name: str, component: str, qp_axis: QpAxisStruct, value: str) -> ...:
    """
    Routine to set qp_axis_names of a qp_axis_struct.
    
    Parameters
    ----------
    qp_axis_name : unknown
        qp_axis name. Used for error messages.
    component : unknown
        qp_axis component name.
    qp_axis : QpAxisStruct
        qp_axis_struct with component to modify
        This parameter is an input/output and is modified in-place. As an output: qp_axis_struct with changed
        component value.
    value : unknown
        Component value.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    error : bool
        Set true if there is an error. False otherwise.
    ix_uni : int
        Tao universe number in case the value depends upon a parameter of a particular universe.
    """
def tao_set_qp_point_struct(qp_point_name: str, component: str, qp_point: QpPointStruct, value: str) -> ...:
    """
    Routine to set qp_point_names of a qp_point_struct.
    
    Parameters
    ----------
    qp_point_name : unknown
        qp_point name. Used for error messages.
    component : unknown
        qp_point component name.
    qp_point : QpPointStruct
        qp_point_struct with component to modify
        This parameter is an input/output and is modified in-place. As an output: qp_point_struct with changed
        component value.
    value : unknown
        Component value.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    error : bool
        Set true if there is an error. False otherwise.
    ix_uni : int
        Tao universe number in case the value depends upon a parameter of a particular universe.
    """
def tao_set_qp_rect_struct(qp_rect_name: str, component: str, qp_rect: QpRectStruct, value: str) -> ...:
    """
    Routine to set qp_rect_names of a qp_rect_struct.
    
    Parameters
    ----------
    qp_rect_name : unknown
        qp_rect name. Used for error messages.
    component : unknown
        qp_rect component name.
    qp_rect : QpRectStruct
        qp_rect_struct with component to modify
        This parameter is an input/output and is modified in-place. As an output: qp_rect_struct with changed
        component value.
    value : unknown
        Component value.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    error : bool
        Set true if there is an error. False otherwise.
    ix_uni : int
        Tao universe number in case the value depends upon a parameter of a particular universe.
    """
def tao_set_ran_state_cmd(state_string: str) -> None:
    """
    Sets the random number generator state.
    
    Parameters
    ----------
    state_string : unknown
        Encoded random number state.
    """
def tao_set_real_value(var_str: str, value_str: str, min_val: typing.SupportsFloat | None = None, max_val: typing.SupportsFloat | None = None, dflt_uni: typing.SupportsInt | None = None) -> ...:
    """
    Subroutine to read and set the value of a real variable.
    
    If the value is out of the range [min_val, max_val] then an error message will
    be generated and the variable will not be set.
    
    Parameters
    ----------
    var_str : unknown
        Used for error messages.
    value_str : unknown
        String with encoded value.
    min_val : float, optional
        Minimum value.
    max_val : float, optional
        Maximum value.
    dflt_uni : int, optional
        Default universe used to evaluate parameters.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    var : float
        Variable to set.
    error : bool
        Set True on an error. False otherwise.
    """
def tao_set_region_cmd(region_name: str, component: str, value_str: str) -> None:
    """
    Routine to set region parameters.
    
    Parameters
    ----------
    region_name : unknown
        Which region to set.
    component : unknown
        Which component to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_space_charge_com_cmd(who: str, value_str: str) -> None:
    """
    Routine to set space_charge_com variables
    
    Parameters
    ----------
    who : unknown
        which space_charge_com variable to set
    value_str : unknown
        Value to set to.
    
    Returns
    -------
    space_charge_com : 
        space_charge_com variables structure.
    """
def tao_set_symbolic_number_cmd(sym_str: str, num_str: str | None = None, val: typing.SupportsFloat | None = None) -> None:
    """
    Associates a given symbol with a given number.
    
    Parameters
    ----------
    sym_str : unknown
        Symbol.
    num_str : unknown, optional
        Symbol value expression.
    val : float, optional
        Value of symbol
    """
def tao_set_tune_cmd(branch_str: str, mask_str: str, print_list: bool, qa_str: str, qb_str: str, delta_input: bool) -> None:
    """
    Routine to set the transverse tunes.
    
    Parameters
    ----------
    branch_str : unknown
        List of branches to apply tune set to.
    mask_str : unknown
        List of quadrupoles to veto.
    print_list : bool
        If True, print a list of elements varied and coefficients.
    qa_str : unknown
        Expression for Qa tune.
    qb_str : unknown
        Expression for Qb tune.
    delta_input : bool
        If true then qa_str and qb_str are deltas from present tune.
    """
def tao_set_universe_cmd(uni: str, who: str, what: str) -> None:
    """
    Sets a universe on or off, or sets the recalculate or twiss_calc logicals, etc.
    
    Parameters
    ----------
    uni : unknown
        which universe; 0 => current viewed universe
    who : unknown
        "on", "off", "recalculate", "dynamic_aperture_calc", "one_turn_map_calc", or "twiss_calc"
    what : unknown
        "on" or "off" for who = "dynamic_aperture_calc", "one_turn_map_calc" or "twiss_calc".
    """
def tao_set_var_cmd(var_str: str, value_str: str) -> None:
    """
    Routine to set var values.
    
    Parameters
    ----------
    var_str : unknown
        Which var name to set.
    value_str : unknown
        What value to set it to.
    """
def tao_set_var_model_value(var: TaoVarStruct, value: typing.SupportsFloat, print_limit_warning: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    var : TaoVarStruct
        Variable to set
    value : float
        Value to set to
    print_limit_warning : bool, optional
        Print a warning if the value is past the variable's limits. -- Logical, optional: Print a warning if the
        value is past the variable's limits. Default is True.
    """
def tao_set_var_useit_opt() -> None:
    """
    No docstring available
    """
def tao_set_wave_cmd(who: str, value_str: str) -> bool:
    """
    Routine to set wave variables
    
    Parameters
    ----------
    who : unknown
        which wave variable to set
    value_str : unknown
        Value to set to.
    
    Returns
    -------
    err : bool
        Set True if there is an error. False otherwise. s.wave  -- Wave variables structure.
    """
def tao_set_z_tune_cmd(branch_str: str, q_str: str, delta_input: bool) -> None:
    """
    Routine to set the z-tune.
    
    Parameters
    ----------
    branch_str : unknown
        List of branches to apply tune set to.
    q_str : unknown
        Expression for Qc tune.
    delta_input : bool
        If true then qa_str and qb_str are deltas from present tune.
    """
def tao_setup_key_table() -> None:
    """
    No docstring available
    """
def tao_shape_init(shape: TaoEleShapeStruct, print_err: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    shape : TaoEleShapeStruct
        Shape
    err : 
        Set true if there is a problem translating the element class.
    print_err : bool, optional
        If True then print an error message if there is a problem. Default is True.
    """
def tao_show_cmd(what: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    what : unknown
        What to show.
    """
def tao_show_constraints(iunit: typing.SupportsInt, form: str) -> None:
    """
    Routine to show a list of datums and variables and how they contribute to the merit function.
    
    Parameters
    ----------
    iunit : int
        File unit to write to. 0 => print to the terminal.
    form : unknown
        What to output: 'ALL'   -> All datums and variables. 'TOP10' -> Top datums and variables that contribute
        to the merit function.
    """
def tao_single_mode(char_: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    char : unknown
        Command. If more characters are needed to complete the command then this routine will get them.
    """
def tao_single_track(tao_lat: TaoLatticeStruct, ix_branch: typing.SupportsInt, print_err: bool | None = None) -> bool:
    """
    Routine to track a single particle and calculate lattice functions through a lattice.
    
    Parameters
    ----------
    tao_lat : TaoLatticeStruct
        Structure containing the lattice.
    ix_branch : int
        Branch index to track through.
    print_err : bool, optional
        Default False. Print error messages if, eg, lattice is unstable?
    
    Returns
    -------
    calc_ok : bool
        Set True if there were no problems, False otherwise.
    """
def tao_spin_matrices_calc_needed(data_type: str, data_source: str, do_calc: bool) -> PyTaoSpinMatricesCalcNeeded:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : 
    data_source : 
    do_calc : 
    """
def tao_spin_tracking_turn_on() -> None:
    """
    No docstring available
    """
def tao_split_component(comp_str: str) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    comp_str : unknown
        Components. EG: 'meas - design'
    comp : TaoDataVarComponentStruct
        Array of individual components.
    err : bool
        Set True if there is an error, False otherwise.
    """
def tao_srdt_calc_needed(data_type: str, data_source: str, do_srdt: typing.SupportsInt) -> PyTaoSrdtCalcNeeded:
    """
    No docstring available
    
    Parameters
    ----------
    data_type : 
    data_source : 
    do_srdt : 
    """
def tao_subin_uni_number(name_in: str, ix_uni: typing.SupportsInt, ok: bool) -> PyTaoSubinUniNumber:
    """
    No docstring available
    
    Parameters
    ----------
    name_in : unknown
        Input name with "#" character
    ix_uni : int
        Universe index.
    name_out : unknown
        Output name.
    ok : 
    """
def tao_svd_optimizer() -> bool:
    """
    Routine to minimize the merit function using svd.
    
    
    Returns
    -------
    abort : bool
        Set True if svd step increases the merit function.
    """
def tao_symbol_import_from_lat(lat: LatStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    """
def tao_taper_cmd(except: str, uni_names: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    except : unknown
        List of elements not to vary.
    uni_names : unknown
        Universes to taper.
    """
def tao_to_change_number(num_str: str, n_size: typing.SupportsInt, change_number: RealAlloc1D, abs_or_rel: str, err: bool) -> PyTaoToChangeNumber:
    """
    No docstring available
    
    Parameters
    ----------
    num_str : 
    n_size : 
    change_number : 
    abs_or_rel : 
    err : 
    """
def tao_to_int(str: str, i_int: typing.SupportsInt, err: bool) -> PyTaoToInt:
    """
    Converts a string to an integer
    
    If the string str is blank then i_int = 0
    """
def tao_to_phase_and_coupling_reading(ele: EleStruct, why_invalid: str, datum: TaoDataStruct) -> PyTaoToPhaseAndCouplingReading:
    """
    Buffer routine for to_phase_and_coupling_reading.
    
    Parameters
    ----------
    ele : EleStruct
        The monitor.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    bpm_data : BpmPhaseCouplingStruct
        Monitor values
    valid_value : bool
        Valid data value?
    """
def tao_to_real(expression: str) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    expression : unknown
        arithmetic expression
    value : float
        Value of arithmetic expression.
    err_flag : bool
        TRUE on error.
    """
def tao_too_many_particles_lost(beam: BeamStruct, no_beam: bool) -> PyTaoTooManyParticlesLost:
    """
    No docstring available
    
    Parameters
    ----------
    beam : 
    no_beam : 
    """
def tao_top10_derivative_print() -> None:
    """
    Routine to print out the top10 contributors to the merit function.
    """
def tao_top10_merit_categories_print(iunit: typing.SupportsInt) -> None:
    """
    Routine to print the top data and variable categories that contribute to
    
    the merit function.
    
    Parameters
    ----------
    iunit : int
        File unit to write to. 0 => print to the terminal.
    """
def tao_top_level(command: str | None = None) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    command : unknown, optional
        Tao command string. If present, getting user input from the terminal is bypassed. This is used when
        interfacing to Python.
    errcode : int
        Return error code: 0 => OK, Not 0 => Err.
    """
def tao_tracking_ele_index(ele: EleStruct, datum: TaoDataStruct) -> ...:
    """
    Routine to return the index in the tracking part of a lattice that corresponds to ele.
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    datum : TaoDataStruct
        Datum
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ix_branch : int
        Lattice branch associated with element
    ix_ele : int
        Element index associated with ele.
    """
def tao_turn_on_special_calcs_if_needed_for_plotting() -> None:
    """
    No docstring available
    """
def tao_uni_atsign_index(string: str) -> int:
    """
    Routine to return the index of an atsign ("@") character in a string if the atsign is
    
    being used as a separator between a universe spec and the rest of the string.
    For example:
    string = "[1:3]@orbit.x[5] => ix_amp = 6
    string = "orbit.x[5@0.2]   => ix_amp = 0 (no universe "@" present)
    
    Parameters
    ----------
    string : unknown
        String to parse
    
    Returns
    -------
    ix_amp : int
        Index of universe "@". Set to zero if no universe "@" found.
    """
def tao_universe_index(i_uni: typing.SupportsInt, neg2_to_default: bool | None = None, i_this_uni: typing.SupportsInt) -> PyTaoUniverseIndex:
    """
    No docstring available
    
    Parameters
    ----------
    i_uni : int
        Nominal universe number.
    neg2_to_default : bool, optional
        i_uni = -2 (all universes) maps to the default uni? Default if False.
    i_this_uni : 
    """
def tao_use_data(action: str, data_name: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    action : unknown
        veto, use or restore
    data_name : unknown
        the selected data
    """
def tao_use_var(action: str, var_name: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    action : unknown
        'use', 'veto', or 'restore'
    var_name : unknown
        the selected variable name or all
    """
def tao_user_is_terminating_optimization() -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    is_terminating : 
    """
def tao_var1_name(var: TaoVarStruct, var1_name: str) -> PyTaoVar1Name:
    """
    No docstring available
    
    Parameters
    ----------
    var : TaoVarStruct
        Variable
    var1_name : 
    """
def tao_var_attrib_name(var: TaoVarStruct, var_attrib_name: str) -> PyTaoVarAttribName:
    """
    No docstring available
    
    Parameters
    ----------
    var : TaoVarStruct
        Variable
    var_attrib_name : 
    """
def tao_var_check(eles: ElePointerStructAlloc1D, attribute: str, silent: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    eles : ElePointerStruct
        Array of elements which have a changed attribute.
    attribute : unknown
        Name of attribute changed.
    silent : bool
        If True and the problem can be fixed, do not issue an error message.
    """
def tao_var_repoint() -> None:
    """
    No docstring available
    """
def tao_var_target_calc() -> None:
    """
    No docstring available
    """
def tao_var_useit_plot_calc(graph: TaoGraphStruct) -> TaoVarStructAlloc1D:
    """
    No docstring available
    
    Parameters
    ----------
    graph : 
    var : TaoVarStruct
        .useit_plot -- True if good for plotting.
    """
def tao_var_write(out_file: str, show_good_opt_only: bool | None = None, tao_format: bool | None = None) -> None:
    """
    Routine to write the optimized variables. One file will be created for each universe.
    
    The created file will have three sections:
    1) The variable values
    2) The list of constraints.
    3) A list of the top 10 constraints.
    If out_file = '' the information will be dumped to the terminal.
    In this case, only the variable values will be printed.
    When tao_format = True, the output is in the form "set variable <name> = <value>"
    so the file can be used as a Tao command file. If tao_format = False, the format
    is suitable for inclusion in a Bmad lattice file.
    
    Parameters
    ----------
    out_file : unknown
        Name of output file. If blank. Ouput to the terminal.
    show_good_opt_only : bool, optional
        Write only the variables used in the optimization? Default is False.
    tao_format : bool, optional
        Output format. Default False. See above.
    """
def tao_veto_vars_with_zero_dmodel() -> None:
    """
    Routine to veto all variables with zero effect on data used in the merit function.
    """
def tao_wave_analysis(plot: TaoPlotStruct) -> None:
    """
    Routine to do a wave anaysis.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot region setup by tao_wave_cmd.
        This parameter is an input/output and is modified in-place. As an output: Plot with wave analysis curves.
    """
def tao_wave_cmd(curve_name: str, plot_place: str, err_flag: bool) -> PyTaoWaveCmd:
    """
    Routine to do the initial setup for wave plotting.
    
    The wave analysis is done by the routine tao_wave_analysis.
    
    Parameters
    ----------
    curve_name : 
        Character(*) curve for wave analysis.
    plot_place : 
        Character(*) place on plot page to put the wave plot.
    """
def tao_wave_fit(curve: TaoCurveStruct, ix1: typing.SupportsInt, n_dat: typing.SupportsInt, f1: RealAlloc1D, f2: _pybmad.RealAlloc1D | None = None, f3: _pybmad.RealAlloc1D | None = None, f4: _pybmad.RealAlloc1D | None = None) -> ...:
    """
    Routine for fitting the curve data to up to four functions using a least squares
    
    SVD fit.
    
    Parameters
    ----------
    curve : TaoCurveStruct
        Curve containing the data.
    ix1 : int
        Index of first point in the data array.
    n_dat : int
        Number of data points.
    f1 : float
        First fit function.
    f2 : float, optional
        Second fit function.
    f3 : float, optional
        third fit function.
    f4 : float, optional
        fourth fit function.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    coef : float
        Fit coefficients.
    rms : float
        Variances with rms(n_func+1) = sqrt(chi^2/n_dat).
    """
def tao_write_cmd(what: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    what : unknown
        What to output. See the code for more details.
    """
def tao_x_axis_cmd(where: str, what: str) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    where : unknown
        Region to axis. Eg: "top"
    what : unknown
        "s" or "index"
    """
def tao_x_scale_cmd(where: str, x_min_in: typing.SupportsFloat, x_max_in: typing.SupportsFloat, include_wall: bool | None = None, gang: str | None = None, exact: bool | None = None, turn_autoscale_off: bool | None = None) -> bool:
    """
    Routine to scale a plot. If x_min = x_max
    
    Then the scales will be chosen to show all the data.
    
    Parameters
    ----------
    where : unknown
        Region to scale. Eg: "top"
    x_min_in : float
        Plot x-axis min value.
    x_max_in : float
        Plot x-axis max value.
    include_wall : bool, optional
        Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
        include the building wall position will be included in determining the the scale.
    gang : unknown, optional
        'gang', 'nogang', ''. Default = ''.
    exact : bool, optional
        Exact plot y_max, y_min to correspond to y_min_in, y_max_in? Default is False. Only relavent when y_min_in
        /= y_max_in.
    turn_autoscale_off : bool, optional
        If True (default) then turn off plot.autoscale_x logical for all plots that are scaled.
    
    Returns
    -------
    err : bool
        Set to True if the plot cannot be found. False otherwise.
    """
def tao_x_scale_graph(graph: TaoGraphStruct, x_min: typing.SupportsFloat, x_max: typing.SupportsFloat, include_wall: bool | None = None, have_scaled: bool | None = None) -> PyTaoXScaleGraph:
    """
    No docstring available
    
    Parameters
    ----------
    graph : 
    x_min : 
    x_max : 
    include_wall : 
    have_scaled : 
    """
def tao_x_scale_plot(plot: TaoPlotStruct, x_min_in: typing.SupportsFloat, x_max_in: typing.SupportsFloat, include_wall: bool | None = None, gang: str | None = None) -> bool:
    """
    Routine to scale a plot. If x_min = x_max
    
    Then the scales will be chosen to show all the data.
    
    Parameters
    ----------
    plot : TaoPlotStruct
        Plot to scale. Eg: "top"
    x_min_in : float
        Plot x-axis min value.
    x_max_in : float
        Plot x-axis max value.
    include_wall : bool, optional
        Used for floor_plan plots where a building wall is drawn and y_min_in = y_max_in. If present and True
        include the building wall position will be included in determining the the scale.
    gang : unknown, optional
        'gang', 'nogang', ''. Default = ''.
    
    Returns
    -------
    have_scaled : bool
        Has a graph been scaled?
    """
def taper_mag_strengths(lat: LatStruct, ref_lat: _pybmad.LatStruct | None = None, except: str | None = None, err_flag: bool | None = None) -> PyTaperMagStrengths:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to vary.
        This parameter is an input/output and is modified in-place. As an output: Lattice with magnet strengths
        varied.
    ref_lat : LatStruct, optional
        Reference lattice. If not present, lat will be used as the ref.
    except : unknown, optional
        List of elements not to vary.
    err_flag : 
    """
def target_min_max_calc(r_corner1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], r_corner2: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], y_min: typing.SupportsFloat, y_max: typing.SupportsFloat, phi_min: typing.SupportsFloat, phi_max: typing.SupportsFloat, initial: bool | None = None) -> PyTargetMinMaxCalc:
    """
    Routine to calculate the min/max values for (y, phi).
    
    min/max values are cumulative.
    
    Parameters
    ----------
    r_corner1 : float
        In target coords: A corner of the target. Must be normalized to 1.
    r_corner2 : float
        In target coords: Adjacent corner of the target. Must be normalized to 1. y_min, y_max     -- real(rp):
        min/max values. Only needed if initial = False. phi_min, phi_max -- real(rp): min/max values. Only needed
        if initial = False.
    initial : bool, optional
        If present and True then this is the first edge for computation. y_min, y_max     -- real(rp): min/max
        values. phi_min, phi_max -- real(rp): min/max values.
    """
def target_rot_mats(r_center: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> ...:
    """
    Routine to calculate the rotation matrices between ele coords and "target" coords.
    
    By definition, in target coords r_center = [0, 0, 1].
    
    Parameters
    ----------
    r_center : float
        In lab coords: Center of target relative to phton emission point.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    w_to_target : float
        Rotation matrix from ele to target coords.
    w_to_ele : float
        Rotation matrix from target to ele coords.
    """
def taylor_equal_taylor(taylor2: TaylorStruct) -> TaylorStruct:
    """
    Subroutine that is used to set one taylor equal to another.
    
    This routine takes care of the pointers in taylor1.
    
    Parameters
    ----------
    taylor2 : TaylorStruct
        Input taylor.
    
    Returns
    -------
    taylor1 : TaylorStruct
        Output taylor.
    """
def taylor_inverse(taylor_in: TaylorStructAlloc1D) -> ...:
    """
    Subroutine to invert a taylor map. Since the inverse map is truncated, it is not exact.
    
    Parameters
    ----------
    taylor_in : TaylorStruct
        Input taylor map.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    taylor_inv : TaylorStruct
        Inverted taylor map.
    err : bool
        Set True if there is no inverse. If not present then print an error message.
    """
def taylor_propagate1(orb_taylor: TaylorStructAlloc1D, ele: EleStruct, param: LatParamStruct, ref_in: _pybmad.CoordStruct | None = None, spin_taylor: _pybmad.TaylorStructAlloc1D | None = None) -> bool:
    """
    Subroutine to track (symplectic integration) a orbital map, and optionally a spin map, through an element.
    
    The spin tracking is only done if spin_taylor is present and bmad_com%spin_tracking_on = T.
    The alternative routine, if ele has a taylor map, is concat_taylor.
    This routine will fail if there is no corresponding ptc fibre for this
    element. In general, the transfer_map_calc routine should be used instead.
    
    Parameters
    ----------
    orb_taylor : TaylorStruct
        Map to be tracked
        This parameter is an input/output and is modified in-place. As an output: Map through element.
    ele : EleStruct
        Element to track through
    param : LatParamStruct
    ref_in : CoordStruct, optional
        Particle to be tracked. Must be present if the particle to be tracked is not the reference particle or if
        the direction of propagation is backwards.
    spin_taylor : TaylorStruct, optional
        Spin map to be tracked
        This parameter is an input/output and is modified in-place. As an output: Tracked spin map.
    
    Returns
    -------
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def taylor_to_mad_map(taylor: TaylorStructAlloc1D, energy: MadEnergyStruct) -> MadMapStruct:
    """
    Subroutine to convert a Taylor map to a mad order 2 map.
    
    If any of the Taylor terms have order greater than 2 they are ignored.
    
    Parameters
    ----------
    taylor : TaylorStruct
        Taylor map.
    energy : MadEnergyStruct
        Energy numbers.
    
    Returns
    -------
    map : MadMapStruct
        Order 2 map.
    """
def taylors_equal_taylors(taylor2: TaylorStructAlloc1D) -> TaylorStructAlloc1D:
    """
    Subroutine to transfer the values from one taylor map to another:
    
    Taylor1 <= Taylor2
    
    Parameters
    ----------
    taylor2 : TaylorStruct
        Taylor map.
    
    Returns
    -------
    taylor1 : TaylorStruct
        Taylor map.
    """
def test_bunch_struct_array(arr_in: BunchStructAlloc1D, arr_inout: BunchStructAlloc1D, arr_in_opt: _pybmad.BunchStructAlloc1D | None = None, arr_inout_opt: _pybmad.BunchStructAlloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_bunch_struct_scalar(val_in: BunchStruct, val_inout: BunchStruct, val_in_opt: _pybmad.BunchStruct | None = None, val_inout_opt: _pybmad.BunchStruct | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_character_scalar(val_in: str, val_inout: str, val_in_opt: str | None = None, val_inout_opt: str | None = None) -> PyTestCharacterScalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_complex_array(arr_in: ComplexAlloc1D, arr_inout: ComplexAlloc1D, arr_in_opt: _pybmad.ComplexAlloc1D | None = None, arr_inout_opt: _pybmad.ComplexAlloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_complex_scalar(val_in: complex, val_inout: complex, val_in_opt: complex | None = None, val_inout_opt: complex | None = None) -> PyTestComplexScalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_integer8_array(arr_in: Int8Alloc1D, arr_inout: Int8Alloc1D, arr_in_opt: _pybmad.Int8Alloc1D | None = None, arr_inout_opt: _pybmad.Int8Alloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_integer8_scalar(val_in: typing.SupportsInt, val_inout: typing.SupportsInt, val_in_opt: typing.SupportsInt | None = None, val_inout_opt: typing.SupportsInt | None = None) -> PyTestInteger8Scalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_integer_array(arr_in: IntAlloc1D, arr_inout: IntAlloc1D, arr_in_opt: _pybmad.IntAlloc1D | None = None, arr_inout_opt: _pybmad.IntAlloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_integer_scalar(val_in: typing.SupportsInt, val_inout: typing.SupportsInt, val_in_opt: typing.SupportsInt | None = None, val_inout_opt: typing.SupportsInt | None = None) -> PyTestIntegerScalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_logical_array(arr_in: BoolAlloc1D, arr_inout: BoolAlloc1D, arr_in_opt: _pybmad.BoolAlloc1D | None = None, arr_inout_opt: _pybmad.BoolAlloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_logical_scalar(val_in: bool, val_inout: bool, val_in_opt: bool | None = None, val_inout_opt: bool | None = None) -> PyTestLogicalScalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_real16_array(arr_in: Real16Alloc1D, arr_inout: Real16Alloc1D, arr_in_opt: _pybmad.Real16Alloc1D | None = None, arr_inout_opt: _pybmad.Real16Alloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_real16_scalar(val_in: typing.SupportsFloat, val_inout: typing.SupportsFloat, val_in_opt: typing.SupportsFloat | None = None, val_inout_opt: typing.SupportsFloat | None = None) -> PyTestReal16Scalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def test_real_array(arr_in: RealAlloc1D, arr_inout: RealAlloc1D, arr_in_opt: _pybmad.RealAlloc1D | None = None, arr_inout_opt: _pybmad.RealAlloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    arr_in : 
    arr_inout : 
    arr_out : 
    opt_status : 
    arr_in_opt : 
    arr_inout_opt : 
    """
def test_real_scalar(val_in: typing.SupportsFloat, val_inout: typing.SupportsFloat, val_in_opt: typing.SupportsFloat | None = None, val_inout_opt: typing.SupportsFloat | None = None) -> PyTestRealScalar:
    """
    No docstring available
    
    Parameters
    ----------
    val_in : 
    val_inout : 
    val_out : 
    opt_status : 
    val_in_opt : 
    val_inout_opt : 
    """
def tilt_coords(tilt_val: typing.SupportsFloat, coord: RealAlloc1D, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    tilt_val : float
        Tilt value (could be the roll value for a bend)
    coord : float
        Coordinates of particle before rotation.
        This parameter is an input/output and is modified in-place. As an output: Coordinates of particle after
        rotation.
    mat6 : float, optional
        Transfer matrix before tilt.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix transfer matrix
        after tilt applied.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def tilt_coords_photon(tilt_val: typing.SupportsFloat, coord: RealAlloc1D, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"] | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    tilt_val : float
        Tilt value (could be the roll value for a bend)
    coord : float
        Coordinates of particle before rotation.
        This parameter is an input/output and is modified in-place. As an output: Coordinates of particle after
        rotation.
    w_mat : float, optional
        Rotation matrix before tilt.
        This parameter is an input/output and is modified in-place. As an output: Rotation matrix after tilt.
    """
def tilt_mat6(mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], tilt: typing.SupportsFloat) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    mat6 : float
        Untilted matrix.
        This parameter is an input/output and is modified in-place. As an output: Tilted matrix.
    tilt : float
        Tilt angle.
    """
def to_eta_reading(eta_actual: RealAlloc1D, ele: EleStruct, axis: typing.SupportsInt, add_noise: bool) -> ...:
    """
    Compute the measured dispersion reading given the true dispersion and the
    
    monitor offsets, noise, etc.
    This routine will only give a nonzero reading for Bmad markers,
    monitors, and instruments.
    
    Parameters
    ----------
    eta_actual : float
        Actual (eta_x, eta_y) dispersion.
    ele : EleStruct
        Element where the orbit is measured. .value(dE_eta_meas$)   -- Percent energy change used in dispersion
        measurement. .value(noise$)         -- relative bpm resolution RMS .value(tilt_tot$)      -- angle error
        in radians rms. .value(x_gain_calib$)  -- Horizontal gain correction. .value(y_gain_err$)    -- Horizontal
        gain error. ... etc ...
    axis : int
        x_plane$ or y_plane$
    add_noise : bool
        If True add noise to the reading
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    reading : float
        BPM reading
    err : bool
        Set True if there is an error. False otherwise.
    """
def to_fieldmap_coords(ele: EleStruct, local_orb: CoordStruct, s_body: typing.SupportsFloat, ele_anchor_pt: typing.SupportsInt, r0: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], curved_ref_frame: bool, x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat, cos_ang: typing.SupportsFloat, sin_ang: typing.SupportsFloat, err_flag: bool) -> PyToFieldmapCoords:
    """
    x, y, z, cos_ang, sin_ang, err_flag)
    
    Routine to return the (x,y,s) position relative to a field map.
    
    Parameters
    ----------
    ele : EleStruct
        Element being tracked through.
    local_orb : CoordStruct
        Particle orbit. Must be in local element coordinates.
    s_body : float
        Longitudinal position relative to the entrance end of the element.
    ele_anchor_pt : int
        anchor point of the field map (anchor_beginning$, anchor_center$, or anchor_end$).
    r0 : float
        origin point of the fieldmap.
    curved_ref_frame : bool
        If the element is a bend: Does the field map follow the bend reference coords? Outpt: x, y, z           --
        real(rp): Coords relative to the field map. cos_ang, sin_ang  -- real(rp): cos and sin of coordinate
        rotation angle.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def to_orbit_reading(orb: CoordStruct, ele: EleStruct, axis: typing.SupportsInt, add_noise: bool) -> ...:
    """
    Calculate the measured reading on a bpm given the actual orbit and the
    
    BPM's offsets, noise, etc.
    This routine will only give a nonzero reading for Bmad markers,
    monitors, and instruments.
    
    Parameters
    ----------
    orb : CoordStruct
        Orbit position at BPM.
    ele : EleStruct
        Element where the orbit is measured. .value(noise$)         -- relative bpm resolution RMS
        .value(tilt_tot$)      -- angle error in radians rms. .value(x_gain_calib$)  -- Horizontal gain
        correction. .value(y_gain_err$)    -- Horizontal gain error. ... etc ...
    axis : int
        x_plane$ or y_plane$
    add_noise : bool
        If True add noise to the reading
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    reading : float
        BPM reading
    err : bool
        Set True if there is no valid reading. For example, if ele.is_on = False.
    """
def to_phase_and_coupling_reading(ele: EleStruct, add_noise: bool) -> ...:
    """
    Find the measured coupling values given the actual ones
    
    This routine will only give a nonzero reading for Bmad markers,
    monitors, and instruments.
    
    Parameters
    ----------
    actual_phase : float
        Actual phase reading.
    ele : EleStruct
        Element where phase is measured. .value(phase_noise$) -- RMS Noise in radians.
    add_noise : bool
        If True add noise to the reading
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    reading : BpmPhaseCouplingStruct
        K and Cbar coupling parameters
    err : bool
        Set True if there is an error. False otherwise.
    """
def to_photon_angle_coords(orb_in: CoordStruct, ele: EleStruct) -> CoordStruct:
    """
    Routine to convert from standard photon coords to "angle" coords defined as:
    
    x, angle_x, y, angle_y, z, E-E_ref
    
    Parameters
    ----------
    orb_in : CoordStruct
        orbit in standard photon coords.
    ele : EleStruct
        Reference element (generally the detector element.)
    
    Returns
    -------
    orb_out : CoordStruct
        Transformed coordinates.
    """
def to_str(num: typing.SupportsFloat, max_signif: typing.SupportsInt | None = None, string: str) -> PyToStr:
    """
    implicit none
    
    logical tracker_locked(2)
    end subroutine
    """
def to_surface_coords(lab_orbit: CoordStruct, ele: EleStruct) -> CoordStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lab_orbit : CoordStruct
        Photon position in laboratory coords.
    ele : EleStruct
        Detector element.
    surface_orbit : CoordStruct
        Photon position in element body coordinates. .state      -- Set to lost$ if orbit outside of surface (can
        happen with sperical surface).
    """
def touschek_lifetime(mode: NormalModesStruct, lat: LatStruct) -> float:
    """
    Calculates the touschek lifetime for a lattice by calling touschek_rate1
    
    for each element.
    The loss rate at each element is averaged over one turn to obtain the lifetime.
    This function assumes that the twiss parameters and closed orbit have
    been calculated, and that mode has been populated.
    This subroutine assumes a fixed momentum aperture.  The loss rate at each element
    uses the same momentum aperture, mode%pz_aperture.
    A common way to call this function is to first populate mode using
    radiation integrals.  If an ideal lattice is used, the vertical
    emittance must also be set to a reasonable value.  If the vertical
    emittance is due only to quantum excitation, then it will likely be
    several orders of magnitude smaller than any real physical situation, in which
    case the integral in this function will have problems converging.
    In addition to setting mode, also set lat%param%n_part to the number of particles
    per bunch.
    
    Parameters
    ----------
    mode : NormalModesStruct
        beam properties .pz_aperture -- Real(rp): momentum aperture
    lat : LatStruct
        Accelerator Lattice .param.n_part -- Real(rp): number particles per bunch
    
    Returns
    -------
    Tl : float
        Touschek lifetime in seconds
    """
def touschek_rate1(mode: NormalModesStruct, lat: LatStruct, ix: typing.SupportsInt | None = None, s: typing.SupportsFloat | None = None) -> float:
    """
    Calculates the touschek rate at the location specified by s or ix
    
    This calculation is based on Piwinski 1998 "The Touschek Effect In
    Strong Focusing Storage Rings".  This is the most general case, equation
    31.
    This function uses twiss_and_track_at_s to determine the Twiss parameters
    at the location s or element index ix.
    A common way to call this function is to first populate mode using
    radiation integrals.  If an ideal lattice is used, the vertical
    emittance must also be set to a reasonable value.  If the vertical
    emittance is due only to quantum excitation, then it will likely be
    several orders of magnitude smaller than any real physical situation, in which
    case the integral in this function will have problems converging.
    Additionally, mode%pz_aperture needs to be set to the momentum aperture.
    In addition to setting mode, also set lat%param%n_part to the number of particles
    per bunch.
    IMPORTANT NOTE: If the lattice type is a circular lattice, then
    mode%a%emittance and mode%b%emittance are assumed to
    contain the normalized emittences.  If lattice geometry is
    open, the emittances are assumed to be
    unnormalized.
    IMPORTANT NOTE: The output of this subroutine is the loss rate assuming
    that two particles are lost per collision, one with too
    much energy, and one with too little energy.  This agrees
    with Piwinski's original derivation, which assumes that the
    positive energy aperture is equal in magnitude to the
    negative energy aperture.  If you are studying an
    accelerator with a non-symmetric energy aperture, then
    this subroutine should be called twice, once with the positive
    aperture, and once with the negative aperture, and rate from
    each call should be halved and summed.
    
    Parameters
    ----------
    mode : NormalModesStruct
        beam properties
    lat : LatStruct
        Lattice
    ix : int, optional
        element index (either s or ix must be specified)
    s : float, optional
        location in meters (either s or ix must be specified)
    
    Returns
    -------
    rate : float
        Touschek rate, in units particle per second, assuming two particles per event.
    """
def touschek_rate1_zap(mode: NormalModesStruct, rate: typing.SupportsFloat, lat: LatStruct, ix: typing.SupportsInt | None = None, s: typing.SupportsFloat | None = None) -> PyTouschekRate1Zap:
    """
    No docstring available
    
    Parameters
    ----------
    mode : 
    rate : 
    lat : 
    ix : 
    s : 
    """
def track1(start_orb: CoordStruct, ele: EleStruct, param: LatParamStruct, track: _pybmad.TrackStruct | None = None, ignore_radiation: bool | None = None, make_map1: bool | None = None, init_to_edge: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    start_orb : CoordStruct
        Starting position.
    ele : EleStruct
        Element to track through.
        This parameter is an input/output and is modified in-place. As an output: Modified if make_map1 is True.
    param : LatParamStruct
        Reference particle info.
    end_orb : CoordStruct
        End position.
    track : TrackStruct, optional
        Structure holding existing track.
        This parameter is an input/output and is modified in-place. As an output: Structure holding the track
        information if the
    err_flag : bool
        Set true if there is an error. False otherwise. Note: The particle getting lost (EG hitting an aperture)
        is *not* an error. An error is something like start_orb not being properly initialized.
    ignore_radiation : bool, optional
        If present and True then do not include radiation -- Logical, optional: If present and True then do not
        include radiation effects along with space charge effects.
    make_map1 : bool, optional
        Make ele.mat6 and ele.spin_q components? Default is false.
    init_to_edge : bool, optional
        Default is True. If True then force the tracked particle to begin at the element's edge. See above. Do not
        use this argument unless you know what you are doing.
    """
def track1_beam(beam: BeamStruct, ele: EleStruct, centroid: _pybmad.CoordStructAlloc1D | None = None, direction: typing.SupportsInt | None = None) -> bool:
    """
    Subroutine to track a beam of particles through an element.
    
    Parameters
    ----------
    beam : BeamStruct
        Starting beam position.
        This parameter is an input/output and is modified in-place. As an output: Ending beam position.
    ele : EleStruct
        element to track through.
    centroid : CoordStruct, optional
        Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before beam tracking by
        tracking a single particle.
    direction : int, optional
        +1 (default) -> Track forward, -1 -> Track backwards.
    
    Returns
    -------
    err : bool
        Set true if there is an error. EG: Too many particles lost for a CSR calc.
    """
def track1_bmad(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Element
    param : LatParamStruct
        .particle     -- Particle type
    err_flag : bool
        Set true if there is an error. False otherwise.
    track : TrackStruct
        Structure holding the track information if the lattice element does tracking step-by-step. See track1 for
        more details.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
        through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track1_bmad_photon(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position
        This parameter is an input/output and is modified in-place. As an output: End position
    ele : EleStruct
        Element
    param : LatParamStruct
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def track1_bunch(bunch: BunchStruct, ele: EleStruct, centroid: _pybmad.CoordStructAlloc1D | None = None, direction: typing.SupportsInt | None = None, bunch_track: _pybmad.BunchTrackStruct | None = None) -> bool:
    """
    Subroutine to track a bunch of particles through an element.
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position.
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
    ele : EleStruct
        element to track through.
    centroid : CoordStruct, optional
        Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before beam tracking by
        tracking a single particle.
    direction : int, optional
        +1 (default) -> Track forward, -1 -> Track backwards.
    bunch_track : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: Track information appended to
        track.
    
    Returns
    -------
    err : bool
        Set true if there is an error. EG: Too many particles lost for a CSR calc.
    """
def track1_bunch_csr(bunch: BunchStruct, ele: EleStruct, centroid: CoordStructAlloc1D, s_start: typing.SupportsFloat | None = None, s_end: typing.SupportsFloat | None = None, bunch_track: _pybmad.BunchTrackStruct | None = None) -> bool:
    """
    Routine to track a bunch of particles through an element with csr radiation effects.
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position.
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
    ele : EleStruct
        The element to track through. Must be part of a lattice.
    centroid : 
        coord_struct, Approximate beam centroid orbit for the lattice branch. Calculate this before beam tracking
        by tracking a single particle.
    s_start : float, optional
        Starting position relative to ele. Default = 0
    s_end : float, optional
        Ending position. Default is ele length.
    bunch_track : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: track information if the
        tracking method does
    
    Returns
    -------
    err : bool
        Set true if there is an error. EG: Too many particles lost.
    """
def track1_bunch_csr3d(bunch: BunchStruct, ele: EleStruct, centroid: CoordStructAlloc1D, s_start: typing.SupportsFloat | None = None, s_end: typing.SupportsFloat | None = None, bunch_track: _pybmad.BunchTrackStruct | None = None) -> bool:
    """
    EXPERIMENTAL. NOT CURRENTLY OPERATIONAL!
    
    Routine to track a bunch of particles through an element using
    steady-state 3D CSR.
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position.
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
    ele : EleStruct
        The element to track through. Must be part of a lattice.
    centroid : 
        coord_struct, Approximate beam centroid orbit for the lattice branch. Calculate this before beam tracking
        by tracking a single particle.
    s_start : float, optional
        Starting position relative to ele. Default = 0
    s_end : float, optional
        Ending position. Default is ele length.
    bunch_track : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: track information if the
        tracking method does
    
    Returns
    -------
    err : bool
        Set true if there is an error. EG: Too many particles lost.
    """
def track1_bunch_hom(bunch: BunchStruct, ele: EleStruct, direction: typing.SupportsInt | None = None, bunch_track: _pybmad.BunchTrackStruct | None = None) -> None:
    """
    Subroutine to track a bunch of particles through an element including wakefields.
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position.
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
    ele : EleStruct
        The element to track through.
    direction : int, optional
        +1 (default) -> Track forward, -1 -> Track backwards.
    bunch_track : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: Track information appended to
        track.
    """
def track1_bunch_space_charge(bunch: BunchStruct, ele: EleStruct, track_to_same_s: bool | None = None, bunch_track: _pybmad.BunchTrackStruct | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    bunch : BunchStruct
        Starting bunch position.
        This parameter is an input/output and is modified in-place. As an output: Ending bunch position.
    ele : EleStruct
        Element to track through. Must be part of a lattice.
    err : bool
        Set true if there is an error. EG: Too many particles lost for a CSR calc.
    track_to_same_s : bool, optional
        Default is True. If True, drift particles to all have the same s-position.
    bunch_track : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: track information if the
        tracking method does
    """
def track1_crystal(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track diffraction from a crystal.
    
    Parameters
    ----------
    ele : EleStruct
        Element tracking through.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_diffraction_plate_or_mask(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track through diffraction plate and mask elements.
    
    Parameters
    ----------
    ele : EleStruct
        Diffraction plate or mask element.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_high_energy_space_charge(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to apply the ultra-relative space charge kick to a particle at the end of an element.
    
    The routine setup_high_energy_space_charge_calc must be called initially before any tracking is done.
    This routine assumes a Gaussian bunch and is only valid with relativistic particles where the
    effect of the space charge is small.
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position
        This parameter is an input/output and is modified in-place. As an output: End position
    ele : EleStruct
        Element tracked through.
    param : LatParamStruct
    """
def track1_lens(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track through a lens.
    
    Parameters
    ----------
    ele : EleStruct
        Element tracking through.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_linear(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position
        This parameter is an input/output and is modified in-place. As an output: End position
    ele : EleStruct
        Element
    param : LatParamStruct
    """
def track1_lr_wake(bunch: BunchStruct, ele: EleStruct) -> None:
    """
    Subroutine to put in the long-range wakes for particle tracking.
    
    Parameters
    ----------
    ele : EleStruct
        Element with wakes.
        This parameter is an input/output and is modified in-place. As an output: Element with updated wake
        amplitudes.
    bunch : BunchStruct
        Bunch to track.
        This parameter is an input/output and is modified in-place. As an output: Kicked bunch.
    """
def track1_mad(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct) -> None:
    """
    Subroutine to track through an element using a 2nd order transfer map.
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Ending coords.
    ele : EleStruct
        Element to track through.
    param : LatParamStruct
        Lattice parameters.
    """
def track1_mirror(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track reflection from a mirror.
    
    Parameters
    ----------
    ele : EleStruct
        Element tracking through.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_mosaic_crystal(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track diffraction from a crystal.
    
    Parameters
    ----------
    ele : EleStruct
        Element tracking through.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_multilayer_mirror(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track reflection from a multilayer_mirror.
    
    Basic equations are from Kohn, "On the Theory of Reflectivity of an X-Ray Multilayer Mirror".
    
    Parameters
    ----------
    ele : EleStruct
        Element tracking through.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_radiation(orbit: CoordStruct, ele: EleStruct, edge: typing.SupportsInt) -> None:
    """
    Subroutine to apply a kick to a particle to account for radiation dampling and/or fluctuations.
    
    For tracking through a given element, this routine should be called initially when
    the particle is at the entrance end and at the end when the particle is at the exit end, when
    the orbit is with respect to laboratory (not element body) coordinates.
    That is, each time this routine is called it applies half the radiation kick for the entire element.
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle position before radiation applied.
        This parameter is an input/output and is modified in-place. As an output: Particle position after
        radiation has been applied.
    ele : EleStruct
        Element generating radiation.
    edge : int
        Where the particle is: start_edge$ or end_edge$.
    """
def track1_radiation_center(orbit: CoordStruct, ele1: EleStruct, ele2: EleStruct, rad_damp: bool | None = None, rad_fluct: bool | None = None) -> None:
    """
    Used for elements that have been split in half: This routine applies a kick to a particle
    
    to account for radiation dampling and/or fluctuations.
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle at center of element before radiation applied.
        This parameter is an input/output and is modified in-place. As an output: Particle position after
        radiation has been applied.
    ele1 : EleStruct
        First half of the split element.
    ele2 : EleStruct
        Second half of the split element.
    rad_damp : bool, optional
        If present, override setting of bmad_com.radiation_damping_on.
    rad_fluct : bool, optional
        If present, override setting of bmad_com.radiation_fluctuations_on.
    
    Notes
    -----
    Related routines:
    track1_radiation.
    """
def track1_runge_kutta(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Ending coords.
    ele : 
        Ele_struct
    param : LatParamStruct
        Lattice parameters.
    err_flag : bool
        Set True if there is an error. False otherwise.
    track : TrackStruct
        Structure holding the track information.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix propagated
        through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track1_sample(ele: EleStruct, param: LatParamStruct, orbit: CoordStruct) -> None:
    """
    Routine to track reflection from a sample element.
    
    Parameters
    ----------
    ele : EleStruct
        Element tracking through.
    param : LatParamStruct
        lattice parameters.
    orbit : CoordStruct
        phase-space coords to be transformed
        This parameter is an input/output and is modified in-place. As an output: final phase-space coords
    """
def track1_spin(start_orb: CoordStruct, param: LatParamStruct, make_quaternion: bool | None = None) -> PyTrack1Spin:
    """
    No docstring available
    
    Parameters
    ----------
    start_orb : 
    ele : EleStruct
        Element to track through .spin_q            -- 1st order spin map made if make_quaternion = True.
    param : 
    end_orb : CoordStruct
        Ending coords. .spin(2)           -- complex(rp): Ending spin
    make_quaternion : 
    """
def track1_spin_integration(start_orb: CoordStruct, ele: EleStruct, param: LatParamStruct) -> CoordStruct:
    """
    No docstring available
    
    Parameters
    ----------
    start_orb : 
    ele : 
    param : 
    end_orb : CoordStruct
        .spin(3)       -- Ending spin
    """
def track1_spin_taylor(start_orb: CoordStruct, ele: EleStruct, param: LatParamStruct) -> CoordStruct:
    """
    import
    
    implicit none
    type (coord_struct) :: start_orb, end_orb
    type (ele_struct) ele
    type (lat_param_struct) :: param
    end subroutine
    
    
    Returns
    -------
    end_orb : CoordStruct
        .spin(3)   -- Ending spin
    """
def track1_sr_wake(bunch: BunchStruct, ele: EleStruct) -> None:
    """
    Subroutine to apply the short range wake fields to a bunch.
    
    Parameters
    ----------
    bunch : BunchStruct
        Bunch of particles.
        This parameter is an input/output and is modified in-place. As an output: Bunch with wakefields applied to
        the particles.
    ele : EleStruct
        Element with wakefields.
    """
def track1_symp_lie_ptc(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct) -> TrackStruct:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position
        This parameter is an input/output and is modified in-place. As an output: End position
    ele : EleStruct
        Element
    param : LatParamStruct
    track : TrackStruct
        Structure holding the track information.
    """
def track1_taylor(orbit: CoordStruct, ele: EleStruct, taylor: typing.Annotated[collections.abc.Sequence[TaylorStruct], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Ending coords.
    ele : EleStruct
        Element to track through.
    taylor : TaylorStruct, optional
        Alternative map to use instead of ele.taylor.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track1_time_runge_kutta(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, t_end: typing.SupportsFloat | None = None, dt_step: typing.SupportsFloat | None = None) -> PyTrack1TimeRungeKutta:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        starting position, z-based coords
        This parameter is an input/output and is modified in-place. As an output: end position, z-based coords
    ele : EleStruct
        element
    param : LatParamStruct
        lattice parameters
    err_flag : bool
        Set True if there is an error. False otherwise
    track : TrackStruct
        Contains array of the step-by-step particle trajectory along with the field at these positions. When
        tracking through multiple elements, the trajectory in an element is appended to the existing trajectory.
        To reset: Set track.n_pt = -1.
    t_end : float, optional
        If present, maximum time to which the particle will be tracked. Used for tracking with given time steps.
        The time orb.t at which tracking stops may be less than this if the particle gets to the end of the
        element
    dt_step : float, optional
        If positive, next RK time step to take. This overrides bmad_com.init_ds_adaptive_tracking. Used by
        track_bunch_time.
        This parameter is an input/output and is modified in-place. As an output: Next RK time step that this
        tracker would take based on the error tolerance.
    """
def track_a_beambeam(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Beambeam element.
    param : LatParamStruct
        Lattice parameters.
    track : TrackStruct
        Structure holding the track information if the lattice element does tracking step-by-step. See track1 for
        more details.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_bend(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Bend element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float, optional
        Transfer matrix up to the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix to the element
        end.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_bend_photon(orb: CoordStruct, ele: EleStruct, length: typing.SupportsFloat) -> None:
    """
    Routine to track a photon through a dipole bend.
    
    The photon is traveling in a straight line but the reference frame
    is curved in a circular shape.
    
    Parameters
    ----------
    orb : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Bend element.
    length : float
        length to track.
    """
def track_a_capillary(orb: CoordStruct, ele: EleStruct) -> None:
    """
    Routine to track through a capillary.
    
    Parameters
    ----------
    orb : CoordStruct
        Input photon coordinates.
        This parameter is an input/output and is modified in-place. As an output: Output photon coordinates.
    ele : EleStruct
        Capillary element
    """
def track_a_converter(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        converter element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is False.
    """
def track_a_crab_cavity(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        crab_cavity element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_drift(orb: CoordStruct, length: typing.SupportsFloat, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None, ele_orientation: typing.SupportsInt | None = None, include_ref_motion: bool | None = None, time: typing.SupportsFloat | None = None) -> PyTrackADrift:
    """
    No docstring available
    
    Parameters
    ----------
    orb : CoordStruct
        Orbit at start of the drift.
        This parameter is an input/output and is modified in-place. As an output: Orbit at end of the drift.
    length : float
        Length to drift through in body coordinates. --    If orb.direction = 1, positive length is in +z
        direction and vice versa.
    mat6 : float, optional
        Transfer matrix up to the drift.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix including the
        drift.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    ele_orientation : int, optional
        Element orientation. Default is orb.direction.
    include_ref_motion : bool, optional
        Include effect of the motion of the reference particle? Default is True. False is basically only used by
        offset_particle. Additionally, if False, orb.s is not changed.
    time : float, optional
        Particle time before drifting. Typically this is an RF clock time which may not be equal to orb.t
        This parameter is an input/output and is modified in-place. As an output: Updated time.
    """
def track_a_drift_photon(orb: CoordStruct, length: typing.SupportsFloat, phase_relative_to_ref: bool) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orb : CoordStruct
        Orbit at start of the drift.
        This parameter is an input/output and is modified in-place. As an output: Orbit at end of the drift
    length : float
        Longitudinal length to drift through.
    phase_relative_to_ref : bool
        If true then E field phase shift is relative to ref particle. -- logical: If true then E field phase shift
        is relative to ref particle.
    """
def track_a_foil(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        foil element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is False.
    """
def track_a_gkicker(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Gkicker
    param : LatParamStruct
        Lattice parameters.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
        element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_lcavity(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Thick multipole element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
        element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_lcavity_old(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Thick multipole element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
        element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_mask(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Mask element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_match(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, err_flag: bool | None = None, make_matrix: bool | None = None) -> PyTrackAMatch:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Match element.
    param : LatParamStruct
        Lattice parameters.
    err_flag : 
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_patch(ele: EleStruct, orbit: CoordStruct, drift_to_exit: bool | None = None, track_spin: bool | None = None, make_matrix: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        patch element.
    orbit : CoordStruct
        Starting phase space coords
        This parameter is an input/output and is modified in-place. As an output: Coords after applying a patch
        transformation.
    drift_to_exit : bool, optional
        If False then do not drift the particle from beginning to end face. Also do not correct for a reference
        energy shift. Default is True.
    s_ent : float
        Longitudinal coordinate of the initial particle position in the frame of reference of the face where the
        particle exits. For a patch with positive z_offset and all other attributes zero, s_ent = -z_offset.
    ds_ref : float
        Distance reference particle travels from entrance to exit.
    track_spin : bool, optional
        If True rotate the spin vector appropriately. If ele.spin_tracking_method = symp_lie_ptc -> default =
        True. Else default = False.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_patch_photon(ele: EleStruct, orbit: CoordStruct, drift_to_exit: bool | None = None, use_z_pos: bool | None = None) -> None:
    """
    Routine to track through a patch element with a photon.
    
    The steps for tracking are:
    1) Transform from entrance to exit coordinates.
    2) Drift particle from the entrance to the exit coordinants.
    
    Parameters
    ----------
    ele : EleStruct
        patch element.
    orbit : CoordStruct
        Starting phase space coords
        This parameter is an input/output and is modified in-place. As an output: Coords after applying a patch
        transformation.
    drift_to_exit : bool, optional
        If False then do not drift the particle from start to ending faces. Default is True.
    use_z_pos : unknown, optional
        If present and True, use orbit.vec(5) as the true z-position relative to the start of the element instead
        of assuming that the particle is at the patch edge.
    """
def track_a_pickup(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, err_flag: bool | None = None, make_matrix: bool | None = None) -> PyTrackAPickup:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Pickup element.
    param : LatParamStruct
        Lattice parameters.
    err_flag : 
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_quadrupole(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Quadrupole element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_rfcavity(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        rfcavity element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_sad_mult(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Sad_mult element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float, optional
        Transfer matrix up to the sad_mult.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_sol_quad(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Sol_quad or solenoid element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_thick_multipole(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, mat6: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"] | None = None, make_matrix: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Thick multipole element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float, optional
        Transfer matrix before the element.
        This parameter is an input/output and is modified in-place. As an output: Transfer matrix through the
        element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_wiggler(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct, make_matrix: bool | None = None) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: End position.
    ele : EleStruct
        Wiggler element.
    param : LatParamStruct
        Lattice parameters.
    mat6 : float
        Transfer matrix through the element.
    make_matrix : bool, optional
        Propagate the transfer matrix? Default is false.
    """
def track_a_zero_length_element(orbit: CoordStruct, ele: EleStruct, param: LatParamStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    orbit : CoordStruct
        Starting coords.
        This parameter is an input/output and is modified in-place. As an output: Ending coords.
    ele : EleStruct
        Element tracked through.
    param : LatParamStruct
        Lattice parameters.
    err_flag : bool
        Set True if there is an error. False otherwise.
    track : TrackStruct
        Structure holding the track information.
    """
def track_all(lat: LatStruct, orbit: CoordStructAlloc1D, ix_branch: typing.SupportsInt | None = None, init_lost: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to track through.
    orbit : CoordStruct
        orbit(0) is the starting coordinates for tracking. If not allocated, the zero orbit will be used.
        This parameter is an input/output and is modified in-place. As an output: Orbit array.
    ix_branch : int, optional
        Index of branch to track. Default is 0 (main branch).
    track_state : int
        Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
    err_flag : bool
        Set true if particle lost or error. False otherwise
    orbit0 : CoordStruct
        Orbit array for branch 0. Used to fill in the orbit at lord elemenets. Only needed when orbit(:) is not
        the orbit for branch 0.
    init_lost : bool
        Default if False. If True, initialize orbit(N) terms that are not tracked through due to particle loss.
    """
def track_beam(lat: LatStruct, beam: BeamStruct, ele1: _pybmad.EleStruct | None = None, ele2: _pybmad.EleStruct | None = None, centroid: _pybmad.CoordStructAlloc1D | None = None, direction: typing.SupportsInt | None = None, bunch_tracks: _pybmad.BunchTrackStructAlloc1D | None = None) -> bool:
    """
    Subroutine to track a beam of particles from the end of
    
    ele1 Through to the end of ele2. Both must be in the same lattice branch.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to track through.
    beam : BeamStruct
        Beam at end of element ix1.
        This parameter is an input/output and is modified in-place. As an output: Beam at end of element ix2.
    ele1 : EleStruct, optional
        Starting element (this element is NOT tracked through). Default is lat.ele(0).
    ele2 : EleStruct, optional
        Ending element. Default is lat.ele(lat.n_ele_track).
    centroid : CoordStruct, optional
        Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before beam tracking by
        tracking a single particle.
    direction : int, optional
        +1 (default) -> Track forward, -1 -> Track backwards.
    bunch_tracks : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: track information if the
        tracking method does
    
    Returns
    -------
    err : bool
        Set true if there is an error. EG: Too many particles lost for a CSR calc.
    """
def track_bunch(lat: LatStruct, bunch: BunchStruct, ele1: _pybmad.EleStruct | None = None, ele2: _pybmad.EleStruct | None = None, centroid: _pybmad.CoordStructAlloc1D | None = None, direction: typing.SupportsInt | None = None, bunch_track: _pybmad.BunchTrackStruct | None = None) -> bool:
    """
    Subroutine to track a particle bunch from the end of ele1 Through to the end of ele2.
    
    Both must be in the same lattice branch.
    With forward tracking, if ele2 is at or before ele1, the tracking will "wrap" around
    the ends of the lattice.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to track through.
    bunch : BunchStruct
        Bunch at end of element ix1.
        This parameter is an input/output and is modified in-place. As an output: Bunch at end of element ix2.
    ele1 : EleStruct, optional
        Starting element (this element is NOT tracked through). Default is lat.ele(0).
    ele2 : EleStruct, optional
        Ending element. Default is lat.ele(lat.n_ele_track).
    centroid : CoordStruct, optional
        Approximate centroid orbit. Only needed if CSR is on. Hint: Calculate this before bunch tracking by
        tracking a single particle.
    direction : int, optional
        +1 (default) -> Track forward, -1 -> Track backwards.
    bunch_track : BunchTrackStruct, optional
        Existing tracks. If bunch_track.n_pt = -1 then Overwrite any existing track.
        This parameter is an input/output and is modified in-place. As an output: track information if the
        tracking method does
    
    Returns
    -------
    err : bool
        Set true if there is an error. EG: Too many particles lost for a CSR calc.
    """
def track_bunch_time(bunch: BunchStruct, branch: BranchStruct, t_end: typing.SupportsFloat, s_end: typing.SupportsFloat, dt_step: _pybmad.RealAlloc1D | None = None, extra_field: _pybmad.EmFieldStructAlloc1D | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    bunch : BunchStruct
        Coordinates must be time-coords in element body frame.
        This parameter is an input/output and is modified in-place. As an output: Coordinates will be time-coords
        in element body frame.
    branch : BranchStruct
        Lattice branch being tracked through.
    t_end : float
        Ending time.
    s_end : float
        Ending s-position.
    dt_step : float, optional
        Initial step to take for each particle. Overrides bmad_com.init_ds_adaptive_tracking.
        This parameter is an input/output and is modified in-place. As an output: Next RK time step that this
        tracker would take based on the error tolerance.
    extra_field : EmFieldStruct, optional
        Per particle static field to be added to the lattice element field. Eg used with space charge.
    """
def track_bunch_to_s(bunch: BunchStruct, s: typing.SupportsFloat, branch: BranchStruct) -> None:
    """
    Drift a bunch of particles to the same s coordinate
    
    Parameters
    ----------
    bunch : BunchStruct
        Input bunch position in s-based coordinate.
        This parameter is an input/output and is modified in-place. As an output: Output bunch position in s-based
        coordinate. Particles will be at the same s coordinate
    s : float
        Target coordinate.
    branch : BranchStruct
        Branch being tracked through.
    """
def track_bunch_to_t(bunch: BunchStruct, t_target: typing.SupportsFloat, branch: BranchStruct) -> None:
    """
    Drift a bunch of particles to the same t coordinate
    
    Parameters
    ----------
    bunch : BunchStruct
        Input bunch position in s-based coordinate.
        This parameter is an input/output and is modified in-place. As an output: Output bunch position in s-based
        coordinate. Particles will be at the same t coordinate
    t_target : float
        Target t coordinate.
    branch : BranchStruct
        Lattice branch being tracked through.
    """
def track_complex_taylor(start_orb: ComplexAlloc1D, complex_taylor: ComplexTaylorStructAlloc1D) -> ComplexAlloc1D:
    """
    Subroutine to track using a complex_taylor map.
    
    Parameters
    ----------
    complex_taylor : ComplexTaylorStruct
        complex_taylor map.
    start_orb : complex
        Starting coords.
    
    Returns
    -------
    end_orb : complex
        Ending coords.
    """
def track_from_s_to_s(lat: LatStruct, s_start: typing.SupportsFloat, s_end: typing.SupportsFloat, orbit_start: CoordStruct, ix_branch: typing.SupportsInt | None = None, ix_ele_end: typing.SupportsInt | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice to track through
    s_start : float
        Starting s-position.
    s_end : float
        Ending s-position. If <= s_start then will wrap
    orbit_start : CoordStruct
        Starting coordinates.
    orbit_end : CoordStruct
        Ending coordinates.
    all_orb : CoordStruct
        If present then the orbit at the exit ends of the elements tracked through will be recorded in this
        structure.
    ix_branch : int, optional
        Lattice branch index. Default is 0 (main branch).
    track_state : int
        Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
    ix_ele_end : int, optional
        If present, ignore s_end and track to in between ix_ele_end and ix_ele_end+1
    """
def track_many(lat: LatStruct, orbit: CoordStructAlloc1D, ix_start: typing.SupportsInt, ix_end: typing.SupportsInt, direction: typing.SupportsInt, ix_branch: typing.SupportsInt | None = None) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to track through.
    orbit : CoordStruct
        Coordinates at start of tracking.
        This parameter is an input/output and is modified in-place. As an output: Orbit.
    ix_start : int
        Start index (See Note).
    ix_end : int
        End index (See Note).
    direction : int
        Direction to track. = +1 -> Track forward (+s) = -1 -> Track backward (-s)
    ix_branch : int, optional
        Branch to track. Default is 0 (main lattice).
    track_state : int
        Set to moving_forward$ if everything is OK. Otherwise: set to index of element where particle was lost.
    """
def track_to_surface(ele: EleStruct, orbit: CoordStruct, param: LatParamStruct) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(3)"]], "FixedSize(3)"]:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element
    orbit : CoordStruct
        Coordinates in the element coordinate frame
        This parameter is an input/output and is modified in-place. As an output: At surface in local surface
        coordinate frame
    param : LatParamStruct
        Branch parameters.
    w_surface : 
        real(rp), rotation matrix to transform to surface coords.
    """
def track_until_dead(start_orb: CoordStruct, lat: LatStruct) -> ...:
    """
    Subroutine to track a particle arbitrarily through a lattice, forwards or backwards,
    
    until it is lost or exits the lattice.
    The starting element is located using start_orb%s.
    
    Parameters
    ----------
    start_orb : CoordStruct
        Starting coords.
    lat : unknown
        lattice that contains and element at start_orb.s
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    end_orb : CoordStruct
        final coords
    track : TrackStruct
        (optional)
    """
def tracking_rad_map_setup(ele: EleStruct, tollerance: typing.SupportsFloat, ref_edge: typing.SupportsInt) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to setup. Matrices will be with respect to the map reference orbit.
    tollerance : float
        Tolerance used for the computation.
    ref_edge : int
        Edge that the matrices are referenced to. upstream_end$ or downstream_end$.
    rad_map : RadMapStruct
        Structure holding the matrices.
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def transfer_ac_kick(ac_in: AcKickerStruct) -> AcKickerStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ac_in : AcKickerStruct
        Input
    ac_out : AcKickerStruct
        Gets set equal to ac_in
    """
def transfer_branch(branch1: BranchStruct) -> BranchStruct:
    """
    No docstring available
    
    Parameters
    ----------
    branch1 : BranchStruct
    branch2 : BranchStruct
    """
def transfer_branch_parameters(branch_in: BranchStruct) -> BranchStruct:
    """
    No docstring available
    
    Parameters
    ----------
    branch_in : BranchStruct
        Input branch.
    branch_out : BranchStruct
        Output branch with parameters set.
    """
def transfer_branches(branch1: BranchStructAlloc1D) -> BranchStructAlloc1D:
    """
    No docstring available
    
    Parameters
    ----------
    branch1 : BranchStruct
    branch2 : BranchStruct
    """
def transfer_ele(ele1: EleStruct, nullify_pointers: bool | None = None) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele1 : EleStruct
    ele2 : EleStruct
    nullify_pointers : bool, optional
        If present and True then nullify the pointers in ele2 except for the ele2.lat and ele2.lord pointers. This
        gives a "bare bones" copy where one does not have to worry about deallocating allocated structure
        components later.
    """
def transfer_ele_taylor(ele_in: EleStruct, taylor_order: typing.SupportsInt | None = None) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele_in : EleStruct
        Element with the Taylor map.
    ele_out : EleStruct
        Element receiving the Taylor map truncated to order taylor_order.
    taylor_order : int, optional
        Order to truncate the Taylor map at.
    """
def transfer_eles(ele1: EleStructAlloc1D) -> EleStructAlloc1D:
    """
    No docstring available
    
    Parameters
    ----------
    ele1 : EleStruct
    ele2 : EleStruct
    """
def transfer_fieldmap(ele_in: EleStruct, who: typing.SupportsInt) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele_in : EleStruct
        Input element.
    ele_out : EleStruct
        Output element.
    who : int
        Possibilities are: all$, cartesian_map$, cylindrical_map$, or grid_field$
    """
def transfer_fixer_params(fixer: EleStruct, to_stored: bool, orbit: _pybmad.CoordStruct | None = None, who: str | None = None) -> bool:
    """
    Set parameters of fixer.
    
    Parameters
    ----------
    fixer : EleStruct
        Fixer element to set.
    to_stored : bool
        If False, set real Twiss from stored. If True, set stored Twiss from real.
    orbit : CoordStruct, optional
        Used for 'phase_space' transfers.
    who : bool, optional
        Who to set. Possibilities are: Groups: 'all', ' ' (default and same as 'all') Note: This excludes all
        'start' sets., 'twiss', 'a_twiss', 'b_twiss', 'cmat', 'x_dispersion', 'y_dispersion', 'dispersion',
        'chromatic', 'orbit', 'phase_space', 'spin', 'x_plane', 'y_plane', 'z_plane', 'start', 'start_spin',
        'start_phase_space', Individula Parameters: 'x', 'px', 'cmat_11', etc.
    
    Returns
    -------
    is_ok : 
        logical
    """
def transfer_lat(lat1: LatStruct) -> LatStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat1 : LatStruct
    lat2 : LatStruct
    """
def transfer_lat_parameters(lat_in: LatStruct) -> LatStruct:
    """
    No docstring available
    
    Parameters
    ----------
    lat_in : LatStruct
        Input lat.
    lat_out : LatStruct
        Output lat with parameters set.
    """
def transfer_map_calc(lat: LatStruct, orb_map: TaylorStructAlloc1D, ix1: typing.SupportsInt | None = None, ix2: typing.SupportsInt | None = None, ref_orb: _pybmad.CoordStruct | None = None, ix_branch: typing.SupportsInt | None = None, one_turn: bool | None = None, unit_start: bool | None = None, concat_if_possible: bool | None = None, spin_map: _pybmad.TaylorStructAlloc1D | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice used in the calculation.
    orb_map : TaylorStruct
        Initial map (used when unit_start = False)
        This parameter is an input/output and is modified in-place. As an output: Transfer map.
    err_flag : bool
        Set True if problem like number overflow, etc.
    ix1 : int, optional
        Element start index for the calculation. Default is 0.
    ix2 : int, optional
        Element end index for the calculation. Default is lat.n_ele_track.
    ref_orb : CoordStruct, optional
        Reference orbit/particle at s1 around which the map is made. This arg is needed if: unit_start = True or
        particle is not the same as the reference particle of the lattice.
    ix_branch : int, optional
        Lattice branch index. Default is 0.
    one_turn : bool, optional
        If present and True, and if ix1 = ix2, and the lattice is circular, then construct the one-turn map from
        ix1 back to ix1. Default = False.
    unit_start : bool, optional
        If present and False then orb_map will be used as the starting map instead of the unit map. Default = True
    concat_if_possible : bool, optional
        If present and True then use map concatenation rather than tracking -- logical, optional: If present and
        True then use map concatenation rather than tracking if a map is present for a given lattice element. See
        above. Default is False.
    spin_map : TaylorStruct, optional
        Input quaternion spin map. Output only computed if bmad_com.spin_tracking_on = T
        This parameter is an input/output and is modified in-place. As an output: Quaternion spin map.
    """
def transfer_map_from_s_to_s(lat: LatStruct, t_map: TaylorStructAlloc1D, s1: typing.SupportsFloat | None = None, s2: typing.SupportsFloat | None = None, ref_orb_in: _pybmad.CoordStruct | None = None, ix_branch: typing.SupportsInt | None = None, one_turn: bool | None = None, unit_start: bool | None = None, concat_if_possible: bool | None = None, spin_map: _pybmad.TaylorStructAlloc1D | None = None) -> ...:
    """
    one_turn, unit_start, err_flag, concat_if_possible, spin_map)
    
    Subroutine to calculate the transfer map between longitudinal positions s1 to s2.
    If s2 < s1 and lat%param%geometry is closed$ then the
    calculation will 'wrap around' the lattice end.
    For example, if s1 = 900 and s2 = 10 then the t_map is the map from
    element 900 to the lattice end plus from 0 through 10.
    If s2 < s1 and lat%param%geometry is open$ then the inverse of the forward map of s2 -> s1 is computed.
    If s2 = s1 then you get the unit map except if one_turn = True and the lattice is circular.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice used in the calculation.
    t_map : TaylorStruct
        Initial map (used when unit_start = False)
        This parameter is an input/output and is modified in-place. As an output: Transfer map.
    s1 : float, optional
        Element start position for the calculation. Default is 0.
    s2 : float, optional
        Element end position for the calculation. Default is lat.param.total_length.
    ref_orb_in : CoordStruct, optional
        Reference orbit/particle at s1 around which the map is made. This arg is needed if: unit_start = True or
        particle is not the same as the reference particle of the lattice.
    ix_branch : int, optional
        Lattice branch index. Default is 0 (main branch).
    one_turn : bool, optional
        If present and True, and s1 = s2, and the lattice is circular: Construct the one-turn map from s1 back to
        s1. Otherwise t_map is unchanged or the unit map if unit_start = T. Default = False.
    unit_start : bool, optional
        If present and False then t_map will be used as the starting map instead of the unit map. Default = True
    concat_if_possible : bool, optional
        If present and True then use map concatenation rather than tracking -- logical, optional: If present and
        True then use map concatenation rather than tracking if a map is present for a given lattice element. See
        above. Default is False.
    spin_map : TaylorStruct, optional
        Initial spin map.
        This parameter is an input/output and is modified in-place. As an output: Final spin map. Only computed if
        bmad_com.spin_tracking_on = T.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    ref_orb_out : CoordStruct
        Ending coordinates of the reference orbit. This is also the actual orbit of particle
    err_flag : bool
        Set true if there is an error. False otherwise.
    """
def transfer_mat2_from_twiss(twiss1: TwissStruct, twiss2: TwissStruct) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"]:
    """
    No docstring available
    
    Parameters
    ----------
    twiss1 : TwissStruct
        Twiss parameters at the initial point. .beta   -- Beta parameter. .alpha  -- Alpha parameter. .phi    --
        Phase at initial point.
    twiss2 : TwissStruct
        Twiss parameters at the end point. .beta   -- Beta parameter. .alpha  -- Alpha parameter. .phi    -- Phase
        at final point.
    mat : float
        Transfer matrix between the two points.
    """
def transfer_mat_from_twiss(ele1: EleStruct, ele2: EleStruct, orb1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"], orb2: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(6)"]], "FixedSize(6)"]:
    """
    No docstring available
    
    Parameters
    ----------
    ele1 : EleStruct
        Element with twiss parameters for the starting point. .a, .b       -- a-mode and b-mode Twiss paramters
        .beta         -- Beta parameter. .alpha        -- Alpha parameter. .phi          -- Phase at initial
        point. .x, .y       -- dispersion values .eta          -- Dispersion at initial point. .etap         --
        Dispersion derivative at initial point. .c_mat(2,2)  -- Coupling matrix
    ele2 : EleStruct
        Element with twiss parameters for the ending point.
    orb1 : float
        Reference orbit at ele1 (affects m(i,6) dispersion terms).
    orb2 : float
        Reference orbit at ele2 (affects m(i,6) dispersion terms).
    m : float
        Transfer matrix between the two points.
    """
def transfer_matrix_calc(lat: LatStruct, xfer_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]], "FixedSize(6)"], xfer_vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"] | None = None, ix1: typing.SupportsInt | None = None, ix2: typing.SupportsInt | None = None, ix_branch: typing.SupportsInt | None = None, one_turn: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lattice used in the calculation. .ele(:).mat6  -- Transfer matrices used in the calculation.
    xfer_mat : 
    xfer_vec : 
    ix1 : int, optional
        Element start index for the calculation. Default is 0.
    ix2 : int, optional
        Element end index for the calculation. Defaults: If ix1 is not present: ix2 = lat.n_ele_track If ix1 is
        present and lattice is closed: Calculate the one-turn matrix from ix1 back to ix1.
    ix_branch : int, optional
        Branch index. Default is 0.
    one_turn : bool, optional
        If present and True, and ix1 = ix2, and the lattice is closed: Construct the one-turn matrix from ix1 back
        to ix1. If False, (the default), and ix1 = ix2, mat6 is the unit matrix.
    """
def transfer_twiss(ele_in: EleStruct, reverse: bool | None = None) -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele_in : EleStruct
        Element with existing Twiss parameters.
    ele_out : EleStruct
        Element receiving the Twiss parameters.
    reverse : bool, optional
        Reverse alpha and coupling as if particle is going in the reversed direction? Default is False.
    """
def transfer_wake(wake_in: WakeStruct) -> WakeStruct:
    """
    No docstring available
    
    Parameters
    ----------
    wake_in : WakeStruct
        Input wake.
    wake_out : WakeStruct
        Output wake.
    """
def tricubic_cmplx_eval(x_norm: typing.SupportsFloat, y_norm: typing.SupportsFloat, z_norm: typing.SupportsFloat, tri_coef: TricubicCmplxCoefStruct) -> ...:
    """
    Routine to evaluate a tricubic interpolating complex function.
    
    Use the routine tricubic_interpolation_cmplx_coefs to generate tri_coef.
    
    Parameters
    ----------
    x_norm : float
        x_norm = (x - x0) / dx
    y_norm : float
        y_norm = (y - y0) / dy
    z_norm : float
        z_norm = (z - z0) / dz
    tri_coef : TricubicCmplxCoefStruct
        Coefficients.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    f_val : complex
        Value of f.
    df_dx : complex
        Normalized first derivative: True df/dx = df_dx * dx
    df_dy : complex
        Normalized first derivative: True df/dy = df_dy * dy
    df_dz : complex
        Normalized first derivative: True df/dz = df_dz * dz
    """
def truncate_complex_taylor_to_order(complex_taylor_in: ComplexTaylorStructAlloc1D, order: typing.SupportsInt) -> ComplexTaylorStructAlloc1D:
    """
    Subroutine to throw out all terms in a complex_taylor map that are above a certain order.
    
    Parameters
    ----------
    complex_taylor_in : ComplexTaylorStruct
        Input complex_taylor map.
    order : int
        Order above which terms are dropped.
    
    Returns
    -------
    complex_taylor_out : ComplexTaylorStruct
        Truncated complex_taylor map.
    """
def twiss1_propagate(twiss1: TwissStruct, mat2: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]], "FixedSize(2)"], ele_key: typing.SupportsInt, length: typing.SupportsFloat) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    twiss1 : TwissStruct
        Input Twiss parameters.
    mat2 : float
        The transfer matrix.
    ele_key : int
        quadrupole$, etc.
    length : float
        Determines whether the phase is increasing or decreasing.
    twiss2 : TwissStruct
        Output Twiss parameters.
    err : bool
        Set True if there is an error, false otherwise.
    """
def twiss3_at_start(lat: LatStruct, err_flag: bool, ix_branch: typing.SupportsInt | None = None) -> PyTwiss3AtStart:
    """
    Subroutine to calculate the 3D twiss parameters of the three modes of the full 6D 1-turn transfer matrix.
    
    This routine is for lattices with closed geometries. For open lattices see: twiss3_from_twiss2.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice with
    ix_branch : int, optional
        Branch index. 0 = default.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    error : bool
        Set True if there is no RF. False otherwise.
    tune3 : float
        Normal mode tunes
    """
def twiss3_from_twiss2(ele: EleStruct) -> None:
    """
    Routine to calculate the 3D Twiss parameters given the 2D transverse Twiss parameters and some
    
    longitudinal parameters.
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element at which the calculation is made.
        This parameter is an input/output and is modified in-place. As an output: Element
    
    Notes
    -----
    Related routines:
    twiss3_at_start
    """
def twiss3_propagate1(ele1: EleStruct, ele2: EleStruct, err_flag: bool) -> PyTwiss3Propagate1:
    """
    Subroutine to propagate the twiss parameters using all three normal modes.
    
    Subroutine from original mode3_mod.
    """
def twiss3_propagate_all(lat: LatStruct, ix_branch: typing.SupportsInt | None = None) -> None:
    """
    Subroutine to propagate the twiss parameters using all three normal modes.
    
    Subroutine from original mode3_mod.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
    ix_branch : int, optional
        : Branch index. 0 = default.
    """
@typing.overload
def twiss_and_track(lat: LatStruct, orb_array: CoordArrayStructAlloc1D, status: typing.SupportsInt | None = None, print_err: bool | None = None, calc_chrom: bool | None = None) -> PyTwissAndTrackAll:
    """
    Subroutine to calculate the twiss parameters, transport matrices and orbit.
    
    
    Notes
    -----
    Note: photon branches are currently ignored. This routine is overloaded by twiss_and_track. See
    twiss_and_track for more details.
    """
@typing.overload
def twiss_and_track(lat: LatStruct, orb: CoordStructAlloc1D, status: typing.SupportsInt | None = None, ix_branch: typing.SupportsInt | None = None, print_err: bool | None = None, calc_chrom: bool | None = None, orb_start: _pybmad.CoordStruct | None = None) -> PyTwissAndTrackBranch:
    """
    Subroutine to calculate the twiss parameters, transport matrices and orbit.
    
    This routine is overloaded by twiss_and_track.
    See twiss_and_track for more details.
    """
def twiss_and_track_at_s(lat: LatStruct, s: typing.SupportsFloat, ele_at_s: _pybmad.EleStruct | None = None, orb: _pybmad.CoordStructAlloc1D | None = None, orb_at_s: _pybmad.CoordStruct | None = None, ix_branch: typing.SupportsInt | None = None, use_last: bool | None = None, compute_floor_coords: bool | None = None) -> bool:
    """
    Subroutine to return the twiss parameters and particle orbit at a
    
    given longitudinal position.
    When calculating the Twiss parameters, this routine assumes
    that the lattice elements already contain the Twiss parameters calculated
    for the ends of the elements.
    Additionally, the orbit at the ends of the elements (contained in orb(:)) must be
    precomputed when orb_at_s is present.
    Precomputation of Twiss and orbit at the element ends may be done with the twiss_and_track routine.
    See also:
    twiss_and_track_from_s_to_s
    twiss_and_track_intra_ele
    
    Parameters
    ----------
    lat : LatStruct
        Lattice.
    s : float
        Longitudinal position. If s is negative the the position is taken to be lat.param.total_length - s.
    ele_at_s : EleStruct, optional
        If the use_last argument is True, ele_at_s is taken to contain valid Twiss parameters stored from a
        previous call to this routine.
        This parameter is an input/output and is modified in-place. As an output: Element structure holding the
        Twiss parameters.
    orb : CoordStruct, optional
        Orbit through the Lattice.
    orb_at_s : CoordStruct, optional
        If the use_last argument is True, orb_at_s is taken to contain the valid orbit stored from a previous
        call.
        This parameter is an input/output and is modified in-place. As an output: Particle position at the
        position s.
    ix_branch : int, optional
        Branch index, Default is 0 (main lattice).
    use_last : bool, optional
        If present and True, and if ele_at_s.s < s, then use ele_at_s and orb_at_s as the starting point for the
        present calculation. This can speed things up when the present s-position is in the middle of a long
        complicated element and the tracking (EG: Runge-Kutta) is slow.
    compute_floor_coords : bool, optional
        If present and True then the global "floor" coordinates (without -- logical, optional: If present and True
        then the global "floor" coordinates (without misalignments) will be calculated and put in ele_at_s.floor.
    
    Returns
    -------
    err : bool
        Set True if there is a problem in the calculation, False otherwise.
    """
def twiss_and_track_from_s_to_s(branch: BranchStruct, orbit_start: CoordStruct, s_end: typing.SupportsFloat, ele_start: _pybmad.EleStruct | None = None, compute_floor_coords: bool | None = None, compute_twiss: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    branch : BranchStruct
        Lattice branch to track through.
    orbit_start : CoordStruct
        Starting phase space coordinates at s_start. .s                     -- Starting position. .ix_ele
        -- Starting element. .location              -- Location relative element.
    s_end : float
        Ending position.
    orbit_end : CoordStruct
        End phase space coordinates.
    ele_start : EleStruct, optional
        Holds the starting parameters at s_start.
    ele_end : EleStruct
        Holds the ending Twiss parameters and the transfer matrix. If present then the ele_start argument must
        also be present.
    err : bool
        Set True if there is a problem like the particle gets lost in tracking
    compute_floor_coords : bool, optional
        If present and True then the global "floor" coordinates will be calculated and put in ele_end.floor.
    compute_twiss : bool, optional
        Default True. If False, to save a little time, do not compute Twiss parameters.
    """
def twiss_and_track_intra_ele(ele: EleStruct, param: LatParamStruct, l_start: typing.SupportsFloat, l_end: typing.SupportsFloat, track_upstream_end: bool, track_downstream_end: bool, orbit_start: _pybmad.CoordStruct | None = None, ele_start: _pybmad.EleStruct | None = None, ele_end: _pybmad.EleStruct | None = None, compute_floor_coords: bool | None = None, compute_twiss: bool | None = None, reuse_ele_end: bool | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to track through.
    param : LatParamStruct
    l_start : float
        Start position measured from the beginning of the element.
    l_end : float
        Stop position measured from the beginning of the element.
    track_upstream_end : bool
        If True then entrance effects are included in the tracking. But only if l_start = 0 and
        orbit_start.location /= inside$.
    track_downstream_end : bool
        If True then exit effects are included in the tracking but only if l_end = ele.value(l$) (within
        bmad_com.significant_length tol)
    orbit_start : CoordStruct, optional
        Starting phase space coordinates at l_start.
    orbit_end : CoordStruct
        End phase space coordinates. If present then the orbit_start argument must also be present.
    ele_start : EleStruct, optional
        Holds the starting Twiss parameters at l_start.
    ele_end : EleStruct, optional
        If reuse_ele_end is set True then reuse ele_end from trancking instead of recomputing ele_end from
        scratch. This can save time.
        This parameter is an input/output and is modified in-place. As an output: Holds the ending Twiss
        parameters at l_end (except for photons).
    err : bool
        Set True if there is a problem like the particle gets lost in tracking
    compute_floor_coords : bool, optional
        If present and True then the global "floor" coordinates (without misalignments) will be calculated and put
        in ele_end.floor.
    compute_twiss : bool, optional
        Default True. If False, to save a little time, do not compute Twiss parameters. Also if ele_start is not
        present, no Twiss parameters are computed.
    reuse_ele_end : bool, optional
        If present and True, and if ele_end has the correct lonigitudianal length and key type, reuse ele_end from
        trancking instead of recomputing ele_end from scratch. This can save time.
    """
def twiss_at_element(ele: EleStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element to be averaged
    start : EleStruct
        Twiss and s at start of element.
    end : EleStruct
        Twiss and s at end of element.
    average : EleStruct
        Average Twiss and s of element. .value(l$) -- "Effective" length which for groups and overlays are
        weighted by the control coefficient.
    """
def twiss_at_start(lat: LatStruct, ix_branch: typing.SupportsInt | None = None, type_out: bool | None = None) -> int:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat
        This parameter is an input/output and is modified in-place. As an output: Lattice with twiss parameters
        computed.
    status : int
        Calculation status: ok$, in_stop_band$, unstable$, or non_symplectic$
    ix_branch : int, optional
        Branch to use. Default is 0 (main branch).
    type_out : bool, optional
        If True (the default), print an error message If the 1-turn matrix is unstable.
    """
def twiss_from_tracking(lat: LatStruct, ref_orb0: CoordStruct, d_orb: _pybmad.RealAlloc1D | None = None) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        Lat to track through.
        This parameter is an input/output and is modified in-place. As an output: Structure holding the Twiss
        parameters.
    ref_orb0 : CoordStruct
        Reference orbit at lat.ele(0).
    symp_err : float
        A measure of how symplectic the constructed matrices were before symplecitification. mat_symp_check for
        more details.
    err_flag : bool
        Set True if there is an error. False otherwise.
    d_orb : float, optional
        Vector of offsets to use. If not present or zero bmad_com.d_orb(:) will be used.
    """
def twiss_propagate1(ele1: EleStruct, ele2: EleStruct, forward: bool | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    ele1 : EleStruct
        Element holding the starting Twiss parameters for forwards propagation.
        This parameter is an input/output and is modified in-place. As an output: Element for the ending Twiss
        parameters for backwards propagation.
    ele2 : EleStruct
        Element holding the transfer matrix and, if backwards propagation, the starting Twiss. .key
        -- Needed since, for example, Match element are handled differently from other elements. .map_ref_orb_in
        -- Important for the dispersion calc. .map_ref_orb_out    -- Important for the dispersion calc.
        This parameter is an input/output and is modified in-place. As an output: Element for the ending Twiss
        parameters for forward propagation.
    err_flag : bool
        Set True if there is an error. False otherwise.
    forward : bool, optional
        Default is True. If false, propagate the Twiss backwards.
    """
def twiss_propagate_all(lat: LatStruct, ix_branch: typing.SupportsInt | None = None, ie_start: typing.SupportsInt | None = None, ie_end: typing.SupportsInt | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    lat : LatStruct
        lattice. .branch(ix_branch).ele(0) -- Branch beginning element with the starting parameters.
        This parameter is an input/output and is modified in-place. As an output: Lattice with parameters computed
        for the branch.
    ix_branch : int, optional
        Branch index. Default is 0 (main lattice).
    err_flag : bool
        Set True if there is an error. False otherwise.
    ie_start : int, optional
        Starting element index. Default is 0. Note: The first element at which the Twiss parameters are calculated
        is ie_start+1.
    ie_end : int, optional
        Ending element index, Default is branch.n_ele_track.
    """
def twiss_to_1_turn_mat(twiss: TwissStruct, phi: typing.SupportsFloat) -> typing.Annotated[list[typing.Annotated[list[float], "FixedSize(2)"]], "FixedSize(2)"]:
    """
    No docstring available
    
    Parameters
    ----------
    twiss : TwissStruct
        Structure holding the Twiss parameters. .beta .alpha
    phi : float
        Tune in radians.
    mat2 : float
        1-turn matrix.
    """
def type_coord(coord: CoordStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    coord : CoordStruct
        Coordinate
    """
def type_expression_tree(tree: ExpressionTreeStruct, indent: typing.SupportsInt | None = None) -> None:
    """
    Routine to print an expression tree in tree form.
    
    Good for debugging.
    
    Parameters
    ----------
    tree : ExpressionTreeStruct
        Tree to print.
    indent : int, optional
        Initial indent. Default is zero.
    """
def type_this_file(filename: str) -> PyTypeThisFile:
    """
    No docstring available
    
    Parameters
    ----------
    filename : 
    """
def upcase_string(string: str) -> PyUpcaseString:
    """
    No docstring available
    
    Parameters
    ----------
    string : 
    """
def update_ele_from_fibre(ele: EleStruct) -> None:
    """
    Routine to update a bmad lattice element when the associated PTC fibre has been modified.
    
    Parameters
    ----------
    ele : EleStruct
        Element with corresponding ele.ptc_fibre fibre.
        This parameter is an input/output and is modified in-place. As an output: Modified element.
    
    Notes
    -----
    Remember to call lattice_bookkeeper after calling this routine.
    """
def update_fibre_from_ele(ele: EleStruct) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with corresponding PTC fibre. ele.ptc_fibre -- PTC fibre.
    survey_needed : bool
        Set True if a call to survey will be needed. Calling survey is avoided in this routine to save time if
        multiple elements are being updated.
    """
def update_floor_angles(floor: FloorPositionStruct, floor0: _pybmad.FloorPositionStruct | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    floor : FloorPositionStruct
        Position with input w matrix. .w      -- w matrix.
        This parameter is an input/output and is modified in-place. As an output: Position with output angles.
    floor0 : FloorPositionStruct, optional
        Reference position. There are two solutions related by: [theta, phi, psi] & [pi+theta, pi-phi, pi+psi] If
        floor0 is present, choose the solution "nearest" the angles in floor0.
    """
def valid_field_calc(ele: EleStruct, field_calc: typing.SupportsInt, is_valid: bool) -> PyValidFieldCalc:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    field_calc : int
        bmad_standard$, etc.
    is_valid : 
    """
def valid_fringe_type(ele: EleStruct, fringe_type: typing.SupportsInt, is_valid: bool) -> PyValidFringeType:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    fringe_type : int
        bmad_standard$, etc.
    is_valid : 
    """
def valid_mat6_calc_method(ele: EleStruct, species: typing.SupportsInt, mat6_calc_method: typing.SupportsInt, is_valid: bool) -> PyValidMat6CalcMethod:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    species : 
        Type of particle being tracked. electron$, etc. or not_set$
    mat6_calc_method : int
        bmad_standard$, etc.
    is_valid : 
    """
def valid_spin_tracking_method(ele: EleStruct, spin_tracking_method: typing.SupportsInt, is_valid: bool) -> PyValidSpinTrackingMethod:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    spin_tracking_method : int
        bmad_standard$, etc.
    is_valid : 
    """
def valid_tracking_method(ele: EleStruct, species: typing.SupportsInt, tracking_method: typing.SupportsInt, is_valid: bool) -> PyValidTrackingMethod:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Lattice element.
    species : 
        Type of particle being tracked. electron$, etc. or not_set$
    tracking_method : int
        bmad_standard$, etc.
    is_valid : 
    """
def value_of_attribute(ele: EleStruct, attrib_name: str, err_print_flag: bool | None = None, err_value: typing.SupportsFloat | None = None, value: typing.SupportsFloat) -> PyValueOfAttribute:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        After this routine finishes Ptr_attrib will point to a variable within this element.
    attrib_name : unknown
        Name of attribute. Must be uppercase. For example: "HKICK".
    err_flag : bool
        Set True if attribtute not found. False otherwise.
    err_print_flag : bool, optional
        If present and True then print an error message if there is an  error.
    err_value : float, optional
        Value to set value argument if there is an error. Default is 0.
    value : 
    """
def value_to_line(line: str, value: typing.SupportsFloat, str: str, typ: str, ignore_if_zero: bool | None = None, use_comma: bool | None = None) -> PyValueToLine:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    value : 
    str : 
    typ : 
    ignore_if_zero : 
    use_comma : 
    """
def vec_to_polar(vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], phase: typing.SupportsFloat | None = None, polar: SpinPolarStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    vec : float
        unitary spin vector
    phase : float, optional
        Phase of the spinor, if not given then set to zero
    polar : 
    """
def vec_to_spinor(vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"], phase: typing.SupportsFloat | None = None, spinor: typing.Annotated[collections.abc.Sequence[complex], "FixedSize(2)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    vec : float
        Spin vector in cartesian coordinates
    phase : float
        Phase of the spinor, if not given then set to zero
    spinor : 
    """
def verify_valid_name(name: str, ix_name: typing.SupportsInt, pure_name: bool | None = None, include_wild: bool | None = None) -> bool:
    """
    Routine to check if a name is well formed. Examples:
    
    "0>>Q0"                           -- Invalid (will only be valid after lattice expansion).
    "Q1##1"                           -- Invalid (double hash not accepted).
    "Q2A_C.\\7#"                       -- Pure name (no "[", "]", "(", ")", "%" characters present).
    "Q3[GRID_FIELD(1)%FIELD_SCALE]"   -- Valid but not a pure name.
    "RFCAVITY::*"                     -- Valid if include_wild = True.
    This subroutine is used by bmad_parser and bmad_parser2.
    This subroutine is not intended for general use.
    
    Parameters
    ----------
    name : unknown
        Name(1:ix_name) is the string to check.
    ix_name : int
        Number of characters in the name.
    pure_name : bool, optional
        If True, reject names that contain "[", "]", "(", ")", "." characters. Default is False.
    include_wild : bool, optional
        Name can include wild card characters and additionally type prefixes like "QUAD::". Default is False.
    
    Returns
    -------
    is_valid : bool
        True if name is well formed. False otherwise.
    """
def virtual_memory_usage() -> int:
    """
    No docstring available
    
    Parameters
    ----------
    usage : 
    """
def w_mat_for_bend_angle(angle: typing.SupportsFloat, ref_tilt: typing.SupportsFloat, r_vec: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"] | None = None, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    angle : float
        Bending angle.
    ref_tilt : float
        Reference tilt.
    r_vec : float, optional
        Starting position.
        This parameter is an input/output and is modified in-place. As an output: position with ref_tilt
        transformation
    w_mat : 
    """
def w_mat_for_tilt(tilt: typing.SupportsFloat, return_inverse: bool | None = None, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    tilt : float
        pitch angle
    return_inverse : bool, optional
        If True, return the inverse matrix. Default is False.
    w_mat : 
    """
def w_mat_for_x_pitch(x_pitch: typing.SupportsFloat, return_inverse: bool | None = None, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    x_pitch : float
        pitch angle
    return_inverse : bool, optional
        If True, return the inverse matrix. Default is False.
    w_mat : 
    """
def w_mat_for_y_pitch(y_pitch: typing.SupportsFloat, return_inverse: bool | None = None, w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    y_pitch : float
        pitch angle
    return_inverse : bool, optional
        If True, return the inverse matrix. Default is False.
    w_mat : 
    """
def w_mat_to_axis_angle(w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> ...:
    """
    Routine to find the rotation axis and rotation angle corresponding to a given
    
    3D rotation matrix.
    The rotation angle is chosen in the range [0, pi].
    
    Parameters
    ----------
    w_mat : float
        Rotation matrix.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    axis : float
        Rotation axis. Normalized to 1.
    angle : float
        Rotation angle in the range [0, pi].
    """
def w_mat_to_quat(w_mat: typing.Annotated[collections.abc.Sequence[typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]], "FixedSize(3)"]) -> typing.Annotated[list[float], "FixedSize(4)"]:
    """
    Routine to find the quaternion corresponding to a given 3D rotation matrix.
    
    Parameters
    ----------
    w_mat : float
        Rotation matrix
    
    Returns
    -------
    quat : float
        Quaternion.
    """
def wall3d_d_radius(position: RealAlloc1D, ele: EleStruct, ix_wall: typing.SupportsInt | None = None) -> ...:
    """
    no_wall_here, origin, radius_wall, err_flag) result (d_radius)
    
    Routine to calculate the difference radius = particle_radius - wall_radius.
    Radiuses are measured along a line from the wall origin with the line passing through
    the particle position.
    The wall origin itself lies on a line connecting the centers of the bounding sections.
    Module needed:
    use wall3d_mod
    
    Parameters
    ----------
    position : float
        Particle position in element coordinates. In a patch, with respect to entrance coords. [position(1),
        position(3)] = [x, y] transverse coords. position(5)                = Longitudinal position relative to
        beginning of element. position(6)                = Longitudinal velocity (only +/- sign matters).
    ele : EleStruct
        Element with wall
    ix_wall : int, optional
        Index of wall in .wall3d(:) array. Default is 1.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    d_radius : float
        r_particle - r_wall
    perp : float
        Perpendicular normal to the wall.
    ix_section : int
        Set to wall slice section particle is in. That is between ix_section and ix_section+1.
    no_wall_here : bool
        True if the sub-chamber under consideration does not exist at the longitudinal location of the particle.
    origin : float
        (x, y, s) origin with respect to the radius is measured. Uses the same coords as position.
    radius_wall : float
        Radius of the wall.
    err_flag : bool
        Set True if error. (EG noassociated .wall3d), false otherwise.
    """
def wall3d_initializer(wall3d: Wall3DStruct) -> bool:
    """
    Routine to initialize a wall3d_struct
    
    1) Add vertex points if there is symmetry.
    2) Compute circular and elliptical centers.
    3) Compute spline coefficients, etc.
    
    Parameters
    ----------
    wall3d : Wall3DStruct
        Wall.
        This parameter is an input/output and is modified in-place. As an output: Initialized wall.
    
    Returns
    -------
    err : bool
        Set true if there is a problem.
    """
def wall3d_section_initializer(section: Wall3DSectionStruct) -> bool:
    """
    Routine to initialize a wall3d_section_struct:
    
    1) Add vertex points if there is symmetry.
    2) Compute circular and elliptical centers.
    
    Parameters
    ----------
    section : Wall3DSectionStruct
        Wall3d section.
        This parameter is an input/output and is modified in-place. As an output: Initialized section-section.
    
    Returns
    -------
    err : bool
        Set true if there is a problem.
    """
def wall3d_to_position(orbit: CoordStruct, ele: EleStruct) -> typing.Annotated[list[float], "FixedSize(6)"]:
    """
    Routine to return the suitable postion to be used in calling wall3d_d_radius
    
    This routine assumes that if in a patch the coordinates of orbit are with respect
    to the downstream end if orbit%direction*orbit%time_dir = 1 and vice versa.
    
    Parameters
    ----------
    orbit : CoordStruct
        Particle position.
    ele : EleStruct
        Element particle is in.
    
    Returns
    -------
    position : float
        Position used in wall3d_d_radius call.
    """
def word_len(wording: str, wlen: typing.SupportsInt) -> PyWordLen:
    """
    No docstring available
    
    Parameters
    ----------
    wording : 
    wlen : 
    """
def word_read(in_str: str, delim_list: str, word: str, ix_word: typing.SupportsInt, delim: str, delim_found: bool, out_str: str, ignore_interior: bool | None = None) -> PyWordRead:
    """
    No docstring available
    
    Parameters
    ----------
    in_str : 
    delim_list : 
    word : 
    ix_word : 
    delim : 
    delim_found : 
    out_str : 
    ignore_interior : 
    """
def word_to_value(word: str, lat: LatStruct, value: typing.SupportsFloat, err_flag: bool, ele: _pybmad.EleStruct | None = None) -> PyWordToValue:
    """
    No docstring available
    
    Parameters
    ----------
    word : 
    lat : 
    value : 
    err_flag : 
    ele : 
    """
def write_ascii_beam_file(file_name: str, beam: BeamStruct, new_file: bool | None = None, alive_only: bool | None = None) -> None:
    """
    Routine to write a beam file in ASCII format (version 4).
    
    Parameters
    ----------
    file_name : unknown
        Name of file.
    beam : BeamStruct
        Beam to write
    new_file : bool, optional
        New file or append? Default = True.
    alive_only : bool, optional
        Only write live (includes pre_born) particles to the file? Default is False.
    """
def write_astra_bend(iu: typing.SupportsInt, strength: typing.SupportsFloat, id: typing.SupportsInt, d1: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], d2: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], d3: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"], d4: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(2)"]) -> PyWriteAstraBend:
    """
    No docstring available
    
    Parameters
    ----------
    iu : 
    strength : 
    id : 
    d1 : 
    d2 : 
    d3 : 
    d4 : 
    """
def write_astra_field_grid_file(astra_file_unit: typing.SupportsInt, ele: EleStruct, dz: typing.SupportsFloat | None = None) -> ...:
    """
    Write 1-D field map files for Astra. The format is:
    
    z field
    ...
    
    Parameters
    ----------
    astra_file_unit : int
        unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
    ele : EleStruct
        element to make map
    dz : float, optional
        z step size in m. Default: 0.001 m
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    maxfield : float
        absolute maximum found for element field scaling
    err : bool
        Set True if, say a file could not be opened.
    """
def write_astra_field_grid_file_3d(base_filename: str, ele: EleStruct, dz: typing.SupportsFloat | None = None) -> ...:
    """
    Writes 3-D field map files for Astra. The format is:
    
    Nx x[1] x[2] ....... x[Nx-1] x[Nx]
    Ny y[1] y[2] ....... y[Ny-1] y[Ny]
    Nz z[1] z[2] ....... z[Nz-1] z[Nz]
    <field values>
    where field values are produced from a loop as in:
    do iz = 1, Nz
    do iy = 1, Ny
    write single line: field(:, iy, iz)
    
    Parameters
    ----------
    base_filename : unknown
        Base filename. Files will be written as: base_filename.ex, .ey, .ez, .bx, .by, .bz If set to '', no files
        will be written
    ele : EleStruct
        element to make map
    dz : float, optional
        z step size in m. Default: 0.001 m
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    maxfield : float
        absolute maximum on-axis field found for element field scaling
    err : bool
        Set True if, say a file could not be opened.
    """
def write_beam_file(file_name: str, beam: BeamStruct, new_file: bool | None = None, file_format: typing.SupportsInt | None = None, lat: _pybmad.LatStruct | None = None, alive_only: bool | None = None) -> None:
    """
    Routine to write a beam file.
    
    A '.h5' suffix will be appended to the created file if hdf5$ format is used and file_name does not
    already have a '.h5' or '.hdf5' suffix.
    
    Parameters
    ----------
    file_name : unknown
        Name of file.
    beam : BeamStruct
        Beam to write
    new_file : bool, optional
        New file or append? Default = True.
    file_format : bool, optional
        ascii$, or hdf5$ (default). old_ascii$ (deprecated) is still accepted.
    lat : LatStruct, optional
        If present, lattice info will be writen to hdf5 files.
    alive_only : bool, optional
        Only write live (includes pre_born) particles to the file? Default is False.
    """
def write_beam_floor_positions(file_name: str, beam: BeamStruct, ele: EleStruct, new_file: bool | None = None) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : unknown
        Name of file.
    beam : BeamStruct
        Beam to write
    ele : EleStruct
        Element that the beam is at.
    new_file : bool, optional
        New file or append? Default = True.
    """
def write_binary_cartesian_map(file_name: str, ele: EleStruct, cart_map: CartesianMapStruct, err_flag: bool) -> None:
    """
    Routine to write a binary cartesian_map structure.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    ele : EleStruct
        Element associated with the map.
    cart_map : CartesianMapStruct
        Cartesian map. Ouput:
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def write_binary_cylindrical_map(file_name: str, ele: EleStruct, cl_map: CylindricalMapStruct, err_flag: bool) -> None:
    """
    Routine to write a binary cylindrical_map structure.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    ele : EleStruct
        Element associated with the map.
    cl_map : CylindricalMapStruct
        Cylindrical map. Ouput:
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def write_binary_grid_field(file_name: str, ele: EleStruct, g_field: GridFieldStruct, err_flag: bool) -> None:
    """
    Routine to write a binary grid_field structure.
    
    Parameters
    ----------
    file_name : unknown
        File to create.
    ele : EleStruct
        Element associated with the map.
    g_field : GridFieldStruct
        Cylindrical map. Ouput:
    err_flag : bool
        Set True if there is an error. False otherwise.
    """
def write_blender_ele(iu: typing.SupportsInt, ele: EleStruct, old_format: bool | None = None) -> PyWriteBlenderEle:
    """
    No docstring available
    
    Parameters
    ----------
    iu : 
    ele : 
    old_format : 
    """
def write_blender_lat_layout(file_name: str, lat: LatStruct) -> PyWriteBlenderLatLayout:
    """
    No docstring available
    
    Parameters
    ----------
    file_name : 
    lat : 
    """
def write_bmad_lattice_file(bmad_file: str, lat: LatStruct, output_form: typing.SupportsInt | None = None, orbit0: _pybmad.CoordStruct | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    bmad_file : unknown
        Name of the output lattice file.
    lat : LatStruct
        Holds the lattice information.
    err : bool
        Set True if, say a file could not be opened.
    output_form : int, optional
        binary$   -> Write grid_field info in binary hdf5 form in separate files. Default. All other fields are
        writen in separate files in ASCII ascii$    -> Fields will be put in separate ASCII files. one_file$ ->
        Everything in one file.
    orbit0 : CoordStruct, optional
        Initial orbit. Used to write the inital orbit if the lattice geometry is closed.
    """
def write_bunch_by_bunch_info(lat: LatStruct, bbu_beam: BbuBeamStruct, bbu_param: BbuParamStruct, this_stage: BbuStageStruct) -> None:
    """
    No docstring available
    
    Parameters
    ----------
    lat : 
    bbu_beam : 
    bbu_param : 
    this_stage : 
    """
def write_gpt_field_grid_file_1d(gpt_file_unit: typing.SupportsInt, ele: EleStruct, dz: typing.SupportsFloat | None = None) -> ...:
    """
    Write 1-D field map files for gpt. The format is:
    
    z field
    ...
    
    Parameters
    ----------
    gpt_file_unit : int
        unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
    ele : EleStruct
        element to make map
    dz : float, optional
        z step size in m. Default: 0.001 m
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    maxfield : float
        absolute maximum found for element field scaling
    ref_time : float
        time that the field was evaluated at
    err : bool
        Set True if, say a file could not be opened.
    """
def write_gpt_field_grid_file_2d(gpt_file_unit: typing.SupportsInt, ele: EleStruct, dr: typing.SupportsFloat | None = None, dz: typing.SupportsFloat | None = None, r_max: typing.SupportsFloat | None = None) -> ...:
    """
    Subroutine to write an GPT lattice file using the information in
    
    a lat_struct. Optionally only part of the lattice can be generated.
    
    Parameters
    ----------
    gpt_file_unit : int
        unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
    ele : EleStruct
        element to make map
    dr : float, optional
        r step size in m. Default: 0.001 m
    dz : float, optional
        z step size in m. Default: 0.001 m
    r_max : float, optional
        maximum radius in m. Default: 0.02 m
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    maxfield : float
        absolute maximum found for element field scaling
    ref_time : float
        time that the field was evaluated at
    err : bool
        Set True if, say a file could not be opened.
    """
def write_gpt_field_grid_file_3d(base_filename: str, ele: EleStruct, dz: typing.SupportsFloat | None = None) -> ...:
    """
    Writes 3-D field map files for gpt. The format is:
    
    E-fields:
    'x', 'y', 'z', 'ExRe', 'EyRe', 'EzRe', 'ExIm ', 'EyIm ', 'EzIm '
    H-fields
    'x', 'y', 'z', 'HxRe', 'HyRe', 'HzRe', 'HxIm ', 'HyIm ', 'HzIm '
    where the fields oscillate as exp(+i \\omega t)
    
    Parameters
    ----------
    base_filename : unknown
        Base filename. Files will be written as: base_filename_E_ASCII.gpt, _H_ASCII.gpt If set to '', no files
        will be written
    ele : EleStruct
        element to make map
    dz : float, optional
        z step size in m. Default: 0.001 m
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    maxfield : float
        absolute maximum on-axis field found for element field scaling
    ref_time : float
        time that the field was evaluated at
    err : bool
        Set True if, say a file could not be opened.
    """
def write_lat_line(line: str, iu: typing.SupportsInt, end_is_neigh: bool, do_split: bool | None = None, scibmad: bool | None = None) -> PyWriteLatLine:
    """
    Routine to write strings to a lattice file.
    
    This routine will break the string up into multiple lines
    if the string is too long and add a continuation character if needed.
    If the "line" arg does not represent a full "sentence" (end_is_neigh = False),
    then only part of the line may be written and the part not written will be returned.
    
    Parameters
    ----------
    line : unknown
        String of text.
        This parameter is an input/output and is modified in-place. As an output: part of the string not written.
    iu : int
        Unit number to write to.
    end_is_neigh : bool
        If true then write out everything. Otherwise wait for a full line of max_char characters or so.
    do_split : bool, optional
        Split line if overlength? Default is True. False is used when line has already been split for expressions
        since the expression splitting routine does a much better job of it.
    scibmad : bool, optional
        Default False. If True then do not include "&" line continuation
    """
def write_lattice_in_elegant_format(out_file_name: str, lat: LatStruct, ref_orbit: _pybmad.CoordStructAlloc1D | None = None, use_matrix_model: bool | None = None, include_apertures: bool | None = None, dr12_drift_max: typing.SupportsFloat | None = None, ix_branch: typing.SupportsInt | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    out_file_name : unknown
        Name of the mad output lattice file.
    lat : LatStruct
        Holds the lattice information.
    ref_orbit : CoordStruct, optional
        Referece orbit for sad_mult and patch elements. This argument must be present if the lattice has sad_mult
        or patch elements and is being translated to MAD-8 or SAD.
    use_matrix_model : bool, optional
        Use a drift-matrix_drift model for wigglers/undulators? [A MAD "matrix" is a 2nd order Taylor map.] This
        switch is ignored for SAD conversion. Default is False -> Use a bend-drift-bend model. Note: sol_quad
        elements always use a drift-matrix-drift model.
    include_apertures : bool, optional
        If True (the default), add to the output lattice a zero length collimator element next to any non-
        collimator element that has an aperture. Note: MADX translations for non-drift elements can handle non-
        collimator elements with an aperture so in this case this argument is ignored.
    dr12_drift_max : float, optional
        Max deviation for drifts allowed before a correction matrix element is added. Default value is 1d-5. A
        negative number means use default.
    ix_branch : int, optional
        Index of lattice branch to use. Default = 0.
    err : bool
        Set True if, say a file could not be opened.
    """
def write_lattice_in_foreign_format(out_type: str, out_file_name: str, lat: LatStruct, ref_orbit: _pybmad.CoordStructAlloc1D | None = None, use_matrix_model: bool | None = None, include_apertures: bool | None = None, dr12_drift_max: typing.SupportsFloat | None = None, ix_branch: typing.SupportsInt | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    out_type : unknown
        Either 'ELEGANT', 'MAD-8', 'MAD-X', 'SAD', or 'OPAL-T', 'SCIBMAD'.
    out_file_name : unknown
        Name of the mad output lattice file.
    lat : LatStruct
        Holds the lattice information.
    ref_orbit : CoordStruct, optional
        Referece orbit for sad_mult and patch elements. This argument must be present if the lattice has sad_mult
        or patch elements and is being translated to MAD-8 or SAD.
    use_matrix_model : bool, optional
        Use a drift-matrix_drift model for wigglers/undulators? [A MAD "matrix" is a 2nd order Taylor map.] This
        switch is ignored for SAD conversion. Default is False -> Use a bend-drift-bend model. Note: sol_quad
        elements always use a drift-matrix-drift model.
    include_apertures : bool, optional
        If True (the default), add to the output lattice a zero length collimator element next to any non-
        collimator element that has an aperture. Note: MADX translations for non-drift elements can handle non-
        collimator elements with an aperture so in this case this argument is ignored.
    dr12_drift_max : float, optional
        Max deviation for drifts allowed before a correction matrix element is added. Default value is 1d-5. A
        negative number means use default.
    ix_branch : int, optional
        Index of lattice branch to use. Default = 0.
    err : bool
        Set True if, say a file could not be opened.
    """
def write_lattice_in_mad_format(out_type: str, out_file_name: str, lat: LatStruct, ref_orbit: _pybmad.CoordStructAlloc1D | None = None, use_matrix_model: bool | None = None, include_apertures: bool | None = None, dr12_drift_max: typing.SupportsFloat | None = None, ix_branch: typing.SupportsInt | None = None) -> bool:
    """
    No docstring available
    
    Parameters
    ----------
    out_type : unknown
        Either 'MAD-8', or 'MAD-X'
    out_file_name : unknown
        Name of the mad output lattice file.
    lat : LatStruct
        Holds the lattice information.
    ref_orbit : CoordStruct, optional
        Referece orbit for sad_mult and patch elements. This argument must be present if the lattice has sad_mult
        or patch elements and is being translated to MAD-8 or SAD.
    use_matrix_model : bool, optional
        Use a drift-matrix_drift model for wigglers/undulators? [A MAD "matrix" is a 2nd order Taylor map.] This
        switch is ignored for SAD conversion. Default is False -> Use a bend-drift-bend model. Note: sol_quad
        elements always use a drift-matrix-drift model.
    include_apertures : bool, optional
        If True (the default), add to the output lattice a zero length collimator element next to any non-
        collimator element that has an aperture. Note: MADX translations for non-drift elements can handle non-
        collimator elements with an aperture so in this case this argument is ignored.
    dr12_drift_max : float, optional
        Max deviation for drifts allowed before a correction matrix element is added. Default value is 1d-5. A
        negative number means use default.
    ix_branch : int, optional
        Index of lattice branch to use. Default = 0.
    err : bool
        Set True if, say a file could not be opened.
    """
def write_lattice_in_sad_format(out_file_name: str, lat: LatStruct, include_apertures: bool | None = None, ix_branch: typing.SupportsInt | None = None, err: bool | None = None) -> PyWriteLatticeInSadFormat:
    """
    No docstring available
    
    Parameters
    ----------
    out_file_name : 
    lat : 
    include_apertures : 
    ix_branch : 
    err : 
    """
def write_lattice_in_scibmad(lat: LatStruct) -> ...:
    """
    No docstring available
    
    Parameters
    ----------
    scibmad_file : unknown
        SciBmad lattice file name.
    lat : LatStruct
        Lattice
    err_flag : bool
        Error flag
    """
def write_line_element(line: str, iu: typing.SupportsInt, ele: EleStruct, lat: LatStruct) -> PyWriteLineElement:
    """
    No docstring available
    
    Parameters
    ----------
    line : 
    iu : 
    ele : 
    lat : 
    """
def write_opal_field_grid_file(opal_file_unit: typing.SupportsInt, ele: EleStruct, param: LatParamStruct) -> ...:
    """
    Subroutine to write an OPAL lattice file using the information in
    
    a lat_struct. Optionally only part of the lattice can be generated.
    
    Parameters
    ----------
    opal_file_unit : int
        unit number to write to, if > 0 if < 0, nothing is written, and only maxfield is returned
    ele : EleStruct
        element to make map
    param : LatParamStruct
        Contains lattice information
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    maxfield : float
        absolute maximum found for element field scaling
    err : bool
        Set True if, say a file could not be opened.
    """
def write_opal_lattice_file(opal_file_unit: typing.SupportsInt, lat: LatStruct) -> bool:
    """
    Subroutine to write an OPAL lattice file using the information in
    
    a lat_struct. Optionally only part of the lattice can be generated.
    
    Parameters
    ----------
    opal_file_unit : int
        unit number to write to
    lat : LatStruct
        Holds the lattice information.
    
    Returns
    -------
    err : bool
        Set True if, say a file could not be opened.
    """
def write_time_particle_distribution(time_file_unit: typing.SupportsInt, bunch: BunchStruct, ele: EleStruct, style: str | None = None, branch: _pybmad.BranchStruct | None = None, format: str | None = None) -> bool:
    """
    Subroutine to write a time-based bunch from a standard Bmad bunch
    
    Parameters
    ----------
    time_file_unit : int
        unit number to write to, if > 0
    bunch : BunchStruct
        bunch to be written. Particles are drifted to bmad_bunch.t_center for output
    ele : EleStruct
        Element being tracked through.
    style : unknown, optional
        Style of output file: 'BMAD' (default), 'OPAL', 'ASTRA', 'GPT'
    branch : BranchStruct, optional
        Required for 'ASTRA' style
    format : unknown
        format for numerical output. default: 'es15.7'
    
    Returns
    -------
    err : bool
        Set True if, say a file could not be opened.
    """
def x0_radiation_length(species: typing.SupportsInt) -> float:
    """
    Routine to return the X0 raidation length for atomes.
    
    Parameters
    ----------
    Species : int
        Species ID.
    
    Returns
    -------
    x0 : float
        Radiation length in kg/m^2. Set to real_garbage$ if species is not atomic or has atomic index greater than
        92.
    """
def xlafun(x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat, res: typing.SupportsFloat) -> PyXlafun:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    y : 
    z : 
    res : 
    """
def xraylib_nist_compound(name: str) -> int:
    """
    Routine to return the xraylib index for a given NIST compound.
    
    Taken from file xraylib/include/xraylib-nist_compounds.h
    
    Parameters
    ----------
    name : unknown
        Name of compound
    
    Returns
    -------
    indx : int
        Compound index. -1 if not found.
    """
def ylafun(x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat, res: typing.SupportsFloat) -> PyYlafun:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    y : 
    z : 
    res : 
    """
def z_at_surface(ele: EleStruct, x: typing.SupportsFloat, y: typing.SupportsFloat, extend_grid: bool | None = None) -> PyZAtSurface:
    """
    Routine return the height (z) of the surface for a particular (x,y) position.
    
    Parameters
    ----------
    ele : EleStruct
        Element x, y        -- real(rp): Photon coordinates on surface.
    extend_grid : bool, optional
        If a grid is involved and (x, y) is outside of the grid, and extend_grid = True: Pretend (x, y) is at
        edge. Default is False.
    
    Return value is a dictionary containing values below.
    
    
    Returns
    -------
    z : float
        z coordinate.
    err_flag : bool
        Set True if cannot compute z due to, say, point being outside of ellipseoid or grid bounds.
    dz_dxy : float
        Surface slope at (x, y).
    
    Notes
    -----
    Remember: +z points into the element.
    """
def zero_ele_kicks() -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with no kicks.
    """
def zero_ele_offsets() -> EleStruct:
    """
    No docstring available
    
    Parameters
    ----------
    ele : EleStruct
        Element with no (mis)orientation.
    """
def zero_lr_wakes_in_lat(lat: LatStruct) -> None:
    """
    Routine to zero the long range wake amplitudes for the elements that have
    
    long range wakes in a lattice.
    
    Parameters
    ----------
    lat : LatStruct
        Lattice
    """
def zlafun(x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat, res: typing.SupportsFloat) -> PyZlafun:
    """
    No docstring available
    
    Parameters
    ----------
    x : 
    y : 
    z : 
    res : 
    """
A0: int = 140
A0_ELEC: int = 190
A21: int = 161
A21_ELEC: int = 211
ABS: int = 17
ABSOLUTE: int = 1
ABSOLUTE_TIME_TRACKING: int = 96
AB_MULTIPOLE: int = 22
ACCORDION_EDGE: int = 128
ACOS: int = 15
ACOSH: int = 54
ACOTH: int = 56
AC_KICKER: int = 58
ALIAS: int = 82
ALIVE: int = 1
ALL: int = 203
ALL_CONTROL_VAR: int = 3
ALL_GROUPS: int = 8
ALPHA_A: int = 99
ALPHA_A0: int = 3
ALPHA_A1: int = 7
ALPHA_ANGLE: int = 21
ALPHA_A_OUT: int = 23
ALPHA_A_STORED: int = 22
ALPHA_A_STRONG: int = 23
ALPHA_B: int = 100
ALPHA_B0: int = 5
ALPHA_B1: int = 9
ALPHA_B_OUT: int = 24
ALPHA_B_STORED: int = 24
ALPHA_B_STRONG: int = 24
AMPERSAND: int = 73
AMP_VS_TIME: int = 104
ANCHOR_BEGINNING: int = 1
ANCHOR_CENTER: int = 2
ANCHOR_END: int = 3
ANGLE: int = 33
ANGLE_OUT_MAX: int = 7
ANOMALOUS_MAG_MOMENT_DEUTERON: float = -0.14298726925
ANOMALOUS_MAG_MOMENT_ELECTRON: float = 0.00115965218059
ANOMALOUS_MAG_MOMENT_HE3: float = -4.184153686
ANOMALOUS_MAG_MOMENT_MUON: float = 0.0011659217
ANOMALOUS_MAG_MOMENT_NEUTRON: float = -1.91304273
ANOMALOUS_MAG_MOMENT_PROTON: float = 1.79284734463
ANOMALOUS_MOMENT_OF: int = 33
ANTIMUON: int = 3
ANTIPARTICLE: int = 44
ANTIPROTON: int = -2
ANTI_ATOM: int = 199
ANTI_DEUTERON: int = -5
ANTI_HELION: int = -8
ANTI_NEUTRON: int = -6
ANTI_REF_PARTICLE: int = -7
APERTURE: int = 95
APERTURE_AT: int = 108
APERTURE_TYPE: int = 87
AREA_DENSITY: int = 85
AREA_DENSITY_USED: int = 86
ARG_COUNT: int = 43
ARROW: int = 65
ASCII: int = 1
ASIN: int = 14
ASINH: int = 53
ATAN: int = 16
ATAN2: int = 23
ATANH: int = 55
ATOMIC_MASS_UNIT: float = 931494103.72
ATTRIBUTE_GROUP: int = 1
AUTO: int = 12
AUTOSCALE_AMPLITUDE: int = 19
AUTOSCALE_PHASE: int = 20
AUTO_APERTURE: int = 1
AVERAGE: int = 40
B0: int = 162
B0_ELEC: int = 212
B1_GRADIENT: int = 45
B21: int = 183
B21_ELEC: int = 233
B2_GRADIENT: int = 46
B3_GRADIENT: int = 48
BASIC_BEND: int = 7
BBI_CONST: int = 7
BEAMBEAM: int = 11
BEGINNING_ELE: int = 28
BENDS: int = 201
BEND_TILT: int = 26
BETA_A: int = 108
BETA_A0: int = 2
BETA_A1: int = 6
BETA_A_OUT: int = 21
BETA_A_STORED: int = 21
BETA_A_STRONG: int = 21
BETA_B: int = 109
BETA_B0: int = 4
BETA_B1: int = 8
BETA_B_OUT: int = 22
BETA_B_STORED: int = 23
BETA_B_STRONG: int = 22
BINARY: int = 2
BLACK: int = 1
BLANK: int = 72
BLUE: int = 4
BL_HKICK: int = 41
BL_KICK: int = 43
BL_VKICK: int = 42
BMAD_INC_VERSION: int = 351
BMAD_STANDARD: int = 1
BOTH_ENDS: int = 3
BRAGG_ANGLE: int = 9
BRAGG_ANGLE_IN: int = 7
BRAGG_ANGLE_OUT: int = 8
BRAGG_DIFFRACTED: int = 1
BS_FIELD: int = 49
B_FIELD: int = 43
B_FIELD_ERR: int = 44
B_FIELD_TOT: int = 28
B_MAX: int = 5
B_PARAM: int = 30
C11_MAT0: int = 20
C11_MAT1: int = 25
C12_MAT0: int = 21
C12_MAT1: int = 26
C21_MAT0: int = 22
C21_MAT1: int = 27
C22_MAT0: int = 23
C22_MAT1: int = 28
CANNOT_FIND: int = 4
CAPILLARY: int = 45
CARTESIAN_MAP: int = 123
CATHODE_FFT_3D: int = 4
CAVITY_TYPE: int = 22
CEILING: int = 28
CENTER_PT: int = 3
CHAMBER_WALL: int = 1
CHARGE: int = 8
CHARGE_OF: int = 32
CHECK_SUM: int = 75
CIRCLE_DOT_SYM: int = 9
CIRCLE_FILLED_SYM: int = 17
CIRCLE_PLUS_SYM: int = 8
CIRCLE_SYM: int = 4
CLASSICAL_RADIUS_FACTOR: float = 1.43996454800674e-09
CLEAR: int = 2
CLOSED: int = 2
CMAT_11: int = 29
CMAT_11_STORED: int = 38
CMAT_12: int = 30
CMAT_12_STORED: int = 39
CMAT_21: int = 31
CMAT_21_STORED: int = 40
CMAT_22: int = 32
CMAT_22_STORED: int = 41
COHERENT: int = 2
COLON: int = 67
COMMA: int = 38
COMPOUND: int = 69
CONSTANT: int = 37
CONSTANT_REF_ENERGY: int = 18
CONTINUOUS: int = 5
CONTROL_GROUP: int = 2
CONTROL_LORD: int = 12
CONTROL_VAR: int = 1
CONVERTER: int = 38
COS: int = 12
COSH: int = 50
COT: int = 45
COTH: int = 52
COUPLER_ANGLE: int = 45
COUPLER_AT: int = 47
COUPLER_PHASE: int = 44
COUPLER_STRENGTH: int = 46
CRAB_CAVITY: int = 61
CRAB_TILT: int = 42
CRAB_X1: int = 39
CRAB_X2: int = 40
CRAB_X3: int = 41
CRAB_X4: int = 43
CRAB_X5: int = 44
CREATE_JUMBO_SLAVE: int = 127
CRITICAL_ANGLE: int = 7
CRITICAL_ANGLE_FACTOR: int = 4
CROSSING_TIME: int = 33
CROSS_HATCHED: int = 4
CRUNCH: int = 5
CRUNCH_CALIB: int = 21
CRYSTAL: int = 43
CRYSTAL_TYPE: int = 116
CSC: int = 47
CSR_DS_STEP: int = 68
CSR_METHOD: int = 89
CUBIC: int = 3
CURLY_BRACKETS: int = 63
CURRENT: int = 25
CURVATURE: int = 101
CURVE: int = 4
CUSTOM: int = 7
CUSTOM_APERTURE: int = 7
CUSTOM_ATTRIBUTE0: int = 233
CUSTOM_ATTRIBUTE_NUM: int = 40
CYAN: int = 5
CYCLES: int = 3
CYLINDRICAL_MAP: int = 124
C_LIGHT: float = 299792458.0
D1_THICKNESS: int = 20
D2_THICKNESS: int = 21
DALPHA_DPZ_A: int = 113
DALPHA_DPZ_A_STORED: int = 44
DALPHA_DPZ_B: int = 114
DALPHA_DPZ_B_STORED: int = 45
DARK_GREY: int = 14
DARWIN_WIDTH_PI: int = 12
DARWIN_WIDTH_SIGMA: int = 11
DASHED: int = 2
DASH_DOT: int = 3
DASH_DOT3: int = 5
DBETA_DPZ_A: int = 110
DBETA_DPZ_A_STORED: int = 42
DBETA_DPZ_B: int = 111
DBETA_DPZ_B_STORED: int = 43
DBRAGG_ANGLE_DE: int = 10
DB_FIELD: int = 44
DCMAT_DPZ_11_STORED: int = 65
DCMAT_DPZ_12_STORED: int = 66
DCMAT_DPZ_21_STORED: int = 67
DCMAT_DPZ_22_STORED: int = 68
DEFAULT_TRACKING_SPECIES: int = 20
DEF_BMAD_COM: int = 20
DEF_LINE: int = 29
DEF_MAD_BEAM: int = 21
DEF_PARAMETER: int = 26
DEF_PARTICLE_START: int = 39
DEF_PTC_COM: int = 63
DEF_SPACE_CHARGE_COM: int = 60
DEGREES: int = 2
DELTA_E_REF: int = 8
DELTA_REF_TIME: int = 50
DELTA_REF_TIME_USER_SET: int = 49
DELTA_TIME: int = 48
DENSITY: int = 83
DENSITY_USED: int = 84
DESCRIP: int = 112
DETAP_DPZ_X: int = 90
DETAP_DPZ_X_STORED: int = 48
DETAP_DPZ_Y: int = 91
DETAP_DPZ_Y_STORED: int = 49
DETA_DPZ_X: int = 88
DETA_DPZ_X_STORED: int = 46
DETA_DPZ_Y: int = 89
DETA_DPZ_Y_STORED: int = 47
DETA_DS_MASTER: int = 3
DETECTOR: int = 55
DEUTERON: int = 5
DE_ETA_MEAS: int = 25
DFLT_DRAW: int = 1
DFLT_SET: int = 2
DG: int = 7
DIAMOND_SYM: int = 11
DIFFRACTION_PLATE: int = 52
DIRECTION: int = 3
DISPATCH: int = 63
DISTRIBUTION: int = 81
DIVIDE: int = 4
DOTTED: int = 4
DOT_SYM: int = 1
DOUBLE_COLON: int = 68
DOWNSTREAM: int = 2
DOWNSTREAM_COORD_DIR: int = 30
DOWNSTREAM_END: int = 2
DPHI_A: int = 10
DPHI_B: int = 11
DPHI_ORIGIN: int = 31
DPSI_ORIGIN: int = 32
DRIFT: int = 1
DRIFT_KICK: int = 1
DS_PHOTON_SLICE: int = 27
DS_SLICE: int = 32
DS_STEP: int = 67
DTHETA_ORIGIN: int = 30
DTHICKNESS_DX: int = 26
DT_MAX: int = 4
DX_ORIGIN: int = 27
DY_ORIGIN: int = 28
DZ_ORIGIN: int = 29
D_SPACING: int = 39
E1: int = 19
E1_GRADIENT: int = 45
E2: int = 20
E2_CENTER: int = 22
E2_GRADIENT: int = 46
E2_PROBABILITY: int = 23
E3_GRADIENT: int = 48
ECOLLIMATOR: int = 36
ELECTRIC: int = 2
ELECTRIC_DIPOLE_MOMENT: int = 83
ELECTRON: int = -1
ELEC_MULTIPOLE: int = 4
ELE_ORIGIN: int = 119
ELLIPTICAL: int = 3
ELSEPARATOR: int = 10
EMITTANCE_A: int = 39
EMITTANCE_B: int = 40
EMITTANCE_Z: int = 41
EMIT_FRACTION: int = 22
EM_FIELD: int = 48
END_EDGE: int = 130
END_STACK: int = 0
ENERGY_DISTRIBUTION: int = 27
ENERGY_PROBABILITY_CURVE: int = 99
ENTRANCE_END: int = 1
EPS_STEP_SCALE: int = 26
EQUAL: int = 66
ETAP_A: int = 95
ETAP_B: int = 97
ETAP_X: int = 84
ETAP_X0: int = 13
ETAP_X1: int = 17
ETAP_X_OUT: int = 27
ETAP_X_STORED: int = 35
ETAP_Y: int = 85
ETAP_Y0: int = 15
ETAP_Y1: int = 19
ETAP_Y_OUT: int = 28
ETAP_Y_STORED: int = 37
ETA_A: int = 94
ETA_B: int = 96
ETA_X: int = 82
ETA_X0: int = 12
ETA_X1: int = 16
ETA_X_OUT: int = 25
ETA_X_STORED: int = 34
ETA_Y: int = 83
ETA_Y0: int = 14
ETA_Y1: int = 18
ETA_Y_OUT: int = 26
ETA_Y_STORED: int = 36
ETA_Z: int = 87
EXACT_MISALIGN: int = 100
EXACT_MODEL: int = 102
EXACT_MULTIPOLES: int = 14
EXIT_END: int = 2
EXP: int = 20
E_CENTER: int = 21
E_CENTER_RELATIVE_TO_REF: int = 24
E_CHARGE: float = 1.602176634e-19
E_FIELD: int = 43
E_FIELD_X: int = 28
E_FIELD_Y: int = 29
E_GUN: int = 47
E_LOSS: int = 21
E_MASS: float = 0.0005109989506900001
E_PHOTON: int = 9
E_TOT: int = 54
E_TOT_OFFSET: int = 47
E_TOT_REF_INIT: int = 41
E_TOT_SET: int = 48
E_TOT_START: int = 52
E_TOT_STRONG: int = 26
FACTORIAL: int = 24
FALSE_: float = 0.0
FALSE_INT: int = 0
FAMILY_QU: int = 3
FAMILY_SQ: int = 4
FAMILY_X: int = 2
FAMILY_Y: int = 1
FB1: int = 21
FB2: int = 22
FEEDBACK: int = 69
FFT_3D: int = 3
FIDUCIAL: int = 50
FIDUCIAL_PT: int = 31
FIELDMAP: int = 2
FIELD_AUTOSCALE: int = 29
FIELD_CALC: int = 106
FIELD_LORD: int = 15
FIELD_MASTER: int = 111
FIELD_OVERLAPS: int = 110
FIELD_SCALE_FACTOR: int = 6
FIELD_X: int = 10
FIELD_Y: int = 11
FILLED_ARROW_HEAD: int = 1
FINAL_CHARGE: int = 3
FINE_STRUCTURE_CONSTANT: float = 0.0072973525643
FINT: int = 21
FINTX: int = 22
FIRST_PASS: int = 1
FIRST_TRACK_EDGE: int = 11
FIXED_STEP_RUNGE_KUTTA: int = 9
FIXED_STEP_TIME_RUNGE_KUTTA: int = 13
FIXER: int = 70
FLEXIBLE: int = 5
FLOOR: int = 27
FLOOR_POSITION_GROUP: int = 3
FLOOR_SHIFT: int = 49
FOCAL_STRENGTH: int = 5
FOIL: int = 66
FORK: int = 41
FORWARD_DIFFRACTED: int = 2
FOURPI: float = 12.566370614359172
FQ1: int = 23
FQ2: int = 24
FREE: int = 3
FREQUENCIES: int = 101
FRINGE_AT: int = 11
FRINGE_TYPE: int = 10
FULL: int = 4
FUNCTION: int = 70
FUNC_PARENS: int = 64
F_FACTOR: int = 29
G: int = 6
GANG: int = 11
GAP: int = 21
GAUSSIAN: int = 2
GEN_GRAD_MAP: int = 126
GEOMETRY: int = 47
GIRDER: int = 37
GIRDER_LORD: int = 7
GKICKER: int = 65
GOVERNOR: int = 14
GRADIENT: int = 6
GRADIENT_ERR: int = 7
GRADIENT_TOT: int = 5
GRAZE_ANGLE: int = 5
GRAZE_ANGLE_IN: int = 15
GRAZE_ANGLE_OUT: int = 16
GREEN: int = 3
GRID_FIELD: int = 125
GROUP: int = 4
GROUP_LORD: int = 4
G_ERR: int = 7
G_MAX: int = 6
G_TOT: int = 8
H1: int = 25
H2: int = 26
HARD_EDGE_ONLY: int = 3
HARMON: int = 4
HARMON_MASTER: int = 5
HATCHED: int = 3
HDF5: int = 3
HELICAL_MODEL: int = 6
HELION: int = 8
HGAP: int = 23
HGAPX: int = 24
HIGHLAND: int = 2
HIGH_ENERGY_SPACE_CHARGE_ON: int = 43
HKICK: int = 39
HKICKER: int = 33
HORIZONTALLY_PURE: int = 2
HYBRID: int = 16
HYPER_X: int = 3
HYPER_XY: int = 2
HYPER_Y: int = 1
H_BAR_PLANCK: float = 6.582119568038699e-16
H_DISPLACE: int = 4
H_PLANCK: float = 4.135667696e-15
IDENTITY: int = 3
IMPACTT: int = 2
INCLUDE_KICKS: int = 1
INCOHERENT: int = 1
INHERIT_FROM_FORK: int = 2
INIT_NEEDED: int = 32
INPUT_ELE: int = 85
INSIDE: int = 3
INSTRUMENT: int = 32
INT: int = 25
INTEGRATOR_ORDER: int = 65
INTERPOLATION: int = 8
INT_GARBAGE: int = -987654
INVALID: int = -666
INVALID_NAME: int = 0
IN_BETWEEN: int = 13
IN_STOP_BAND: int = 2
IS_INTEGER: int = 2
IS_LOGICAL: int = 1
IS_MOSAIC: int = 24
IS_ON: int = 105
IS_REAL: int = 3
IS_STRING: int = 5
IS_STRUCT: int = 6
IS_SWITCH: int = 4
IX_BRANCH: int = 6
IX_FIXER: int = 4
IX_SLICE_SLAVE: int = -2
IX_TO_BRANCH: int = 7
IX_TO_ELEMENT: int = 8
K0L: int = 140
K0SL: int = 190
K1: int = 4
K1X: int = 8
K1Y: int = 9
K2: int = 5
K21L: int = 161
K21SL: int = 211
K3: int = 6
KICK: int = 3
KICK0: int = 43
KICKER: int = 15
KS: int = 18
KX: int = 4
L: int = 1
LATTICE: int = 86
LATTICE_TYPE: int = 45
LB_SUBATOMIC: int = -8
LCAVITY: int = 25
LEADING: int = 2
LENS: int = 59
LIGHT_GREEN: int = 10
LIGHT_GREY: int = 15
LINEAR: int = 4
LINEAR_EDGE: int = 6
LIVE_BRANCH: int = 46
LOG: int = 19
LONGITUDINAL_MODE: int = 32
LORD_DEFINED: int = 8
LORD_PAD1: int = 69
LORD_PAD2: int = 70
LOST: int = 2
LOST_NEG_X: int = 3
LOST_NEG_X_APERTURE: int = 3
LOST_NEG_Y: int = 5
LOST_NEG_Y_APERTURE: int = 5
LOST_POS_X: int = 4
LOST_POS_X_APERTURE: int = 4
LOST_POS_Y: int = 6
LOST_POS_Y_APERTURE: int = 6
LOST_PZ: int = 8
LOST_PZ_APERTURE: int = 8
LOST_Z: int = 7
LOST_Z_APERTURE: int = 7
LR_FREQ_SPREAD: int = 85
LR_SELF_WAKE_ON: int = 83
LR_WAKE: int = 115
LR_WAKE_FILE: int = 84
LYNCH_DAHL: int = 3
L_ACTIVE: int = 31
L_CHORD: int = 30
L_FUNC_PARENS: int = 42
L_PARENS: int = 5
L_PERIOD: int = 23
L_RECTANGLE: int = 27
L_SAGITTA: int = 29
L_SOFT_EDGE: int = 31
MACHINE: int = 87
MAD: int = 14
MAGENTA: int = 6
MAGNETIC: int = 1
MAGNUS: int = 11
MARKER: int = 14
MASK: int = 57
MASK_PLATE: int = 2
MASS_OF: int = 31
MAT6_CALC_METHOD: int = 91
MAT6_GROUP: int = 6
MATCH: int = 30
MATCH_ORBIT: int = 2
MATCH_TWISS: int = 2
MATERIAL_TYPE: int = 116
MATRIX: int = 42
MATRIX_KICK: int = 2
MAX: int = 58
MAX_FRINGE_ORDER: int = 82
MAYBE: int = 2
MEAN_EXCITATION_ENERGY: int = 31
MIN: int = 57
MINOR_SLAVE: int = 1
MINUS: int = 2
MIRROR: int = 42
MIXED: int = 3
MODE: int = 26
MODE_FLIP: int = 33
MODE_FLIP0: int = 24
MODE_FLIP1: int = 29
MODE_FLIP_STORED: int = 27
MODULO: int = 59
MONITOR: int = 31
MOSAIC_ANGLE_RMS_IN_PLANE: int = 26
MOSAIC_ANGLE_RMS_OUT_PLANE: int = 27
MOSAIC_DIFFRACTION_NUM: int = 29
MOSAIC_THICKNESS: int = 25
MOVING_FORWARD: int = -9
MULTILAYER_MIRROR: int = 46
MULTIPASS_LORD: int = 8
MULTIPASS_REF_ENERGY: int = 62
MULTIPASS_SLAVE: int = 9
MULTIPOLE: int = 19
MULTIPOLES_ON: int = 86
MULTIPOLE_SOURCE: int = -1
MULTIPOLE_SYMMETRY: int = 2
MUON: int = -3
MU_0_VAC: float = 1.25663706127e-06
M_DEUTERON: float = 1875612945.0
M_ELECTRON: float = 510998.95069
M_HELION: float = 2808391611.12
M_MUON: float = 105658375.5
M_NEUTRON: float = 939565421.94
M_PION_0: float = 134976800.0
M_PION_CHARGED: float = 139570390.0
M_PROTON: float = 938272089.43
NAVY_BLUE: int = 11
NEUTRON: int = 6
NEW_BRANCH: int = 6
NINT: int = 26
NO: int = 0
NOISE: int = 6
NONE: int = 1
NONE_PT: int = 4
NON_SYMPLECTIC: int = 3
NORMAL: int = 1
NOT_A_LORD: int = 10
NOT_SET: int = -999
NOWHERE: int = 4
NO_APERTURE: int = 4
NO_CLOSED_ORBIT: int = 9
NO_COMPLETE_ORBIT: int = 10
NO_DELIM: int = 10
NO_END: int = 4
NO_END_MARKER: int = 55
NO_FIELD: int = 5
NO_FILL: int = 2
NO_MISALIGNMENT: float = 1.0
NULL_ELE: int = 27
NUMERIC: int = 29
NUM_ELE_ATTRIB: int = 75
NUM_ELE_ATTRIB_EXTENDED: int = 273
NUM_STEPS: int = 66
N_AVOGADRO: float = 6.02214076e+23
N_CELL: int = 33
N_KEY: int = 70
N_PART: int = 2
N_PARTICLE: int = 9
N_PERIOD: int = 22
N_PLANE: int = 4
N_POLE_MAXX: int = 21
N_RF_STEPS: int = 43
N_SAMPLE: int = 26
N_SLICE: int = 20
N_SLICE_SPLINE: int = 103
N_VAR_MAX: int = 999
OCTUPOLE: int = 17
OFF: int = 1
OFFSET_MOVES_APERTURE: int = 98
OFF_AND_SAVE: int = 5
OK: int = 1
OLD_ASCII: int = 44
OLD_CONTROL_VAR: int = 2
OLD_CONTROL_VAR_OFFSET: int = 1000
OLD_INTEGRATOR: int = 101
ON: int = 2
ONE_DIM: int = 2
ONE_FILE: int = 4
OPAL: int = 1
OPAQUE: int = 3
OPEN: int = 1
ORANGE: int = 8
ORIGIN_ELE: int = 109
ORIGIN_ELE_REF_PT: int = 26
OSC_AMPLITUDE: int = 7
OUTLINE_ARROW_HEAD: int = 2
OUTPUT_ELE: int = 86
OUTSIDE: int = 5
OVERLAY: int = 6
OVERLAY_LORD: int = 6
P0C: int = 53
P0C_REF_INIT: int = 40
P0C_SET: int = 49
P0C_START: int = 51
P88: int = 88
P89: int = 89
P90: int = 90
PARENS: int = 61
PARTICLE: int = 132
PATCH: int = 24
PATCH_PROBLEM: int = 2
PC_OUT_MAX: int = 6
PC_OUT_MIN: int = 5
PC_STRONG: int = 27
PENDELLOSUNG_PERIOD_PI: int = 14
PENDELLOSUNG_PERIOD_SIGMA: int = 13
PHASE_TROMBONE: int = 4
PHASE_X: int = 12
PHASE_Y: int = 13
PHI0: int = 24
PHI0_AUTOSCALE: int = 27
PHI0_ERR: int = 25
PHI0_MAX: int = 23
PHI0_MULTIPASS: int = 26
PHI_A: int = 86
PHI_A_STORED: int = 25
PHI_B: int = 116
PHI_B_STORED: int = 26
PHI_POSITION: int = 106
PHOTON: int = 0
PHOTON_FORK: int = 40
PHOTON_INIT: int = 53
PHOTON_TYPE: int = 44
PHYSICAL_SOURCE: int = 100
PI: float = 3.141592653589793
PICKUP: int = 68
PION_0: int = 9
PION_MINUS: int = -4
PION_PLUS: int = 4
PIPE: int = 44
PIXEL: int = 88
PLANAR_MODEL: int = 3
PLUS: int = 1
PLUS_SYM: int = 2
POLARITY: int = 21
POLARIZED: int = 1
POSITRON: int = 1
POWER: int = 7
PRE_BORN: int = 0
PRINT_PAGE_LONG_LEN: float = 10.5
PRINT_PAGE_SHORT_LEN: float = 7.8
PROTON: int = 2
PROVISIONAL: int = 3
PSI_ANGLE: int = 22
PSI_POSITION: int = 107
PTC_CANONICAL_COORDS: int = 47
PTC_FIELD_GEOMETRY: int = 49
PTC_FRINGE_GEOMETRY: int = 48
PTC_INTEGRATION_TYPE: int = 93
PTC_STANDARD: int = 3
PURPLE: int = 12
PX: int = 2
PX0: int = 31
PX1: int = 37
PX_APERTURE_CENTER: int = 25
PX_APERTURE_WIDTH2: int = 24
PX_KICK: int = 34
PX_REF: int = 84
PX_STORED: int = 16
PY: int = 4
PY0: int = 33
PY1: int = 39
PY_APERTURE_CENTER: int = 27
PY_APERTURE_WIDTH2: int = 26
PY_KICK: int = 36
PY_REF: int = 86
PY_STORED: int = 18
PZ: int = 6
PZ0: int = 35
PZ1: int = 41
PZ_APERTURE_CENTER: int = 31
PZ_APERTURE_WIDTH2: int = 30
PZ_KICK: int = 38
PZ_REF: int = 90
PZ_STORED: int = 20
P_MASS: float = 0.93827208943
QUADRUPOLE: int = 3
QUAD_TILT: int = 25
R0_ELEC: int = 15
R0_MAG: int = 16
RADIANS: int = 1
RADIANS_OVER_2PI: int = 3
RADIATION_LENGTH: int = 88
RADIATION_LENGTH_USED: int = 89
RADIUS: int = 3
RAD_INT_GROUP: int = 7
RAMPER: int = 62
RAMPER_LORD: int = 13
RAN: int = 21
RAN_GAUSS: int = 22
RAN_SEED: int = 109
RBEND: int = 18
RCOLLIMATOR: int = 35
REAL_GARBAGE: float = -987654.3
RECALC: int = 44
RECTANGULAR: int = 2
RED: int = 2
REDDISH_PURPLE: int = 13
RED_CROSS_SYM: int = 14
REFERENCE: int = 122
REFER_TO_LORDS: int = 4
REFLECTION: int = 1
REFLECTIVITY_TABLE: int = 99
REF_CAP_GAMMA: int = 31
REF_COORDS: int = 4
REF_ENERGY_GROUP: int = 5
REF_ORBIT: int = 115
REF_ORBIT_FOLLOWS: int = 5
REF_ORIGIN: int = 118
REF_PARTICLE: int = 7
REF_SPECIES: int = 132
REF_TILT: int = 3
REF_TILT_TOT: int = 61
REF_TIME: int = 93
REF_TIME_START: int = 64
REF_WAVELENGTH: int = 70
RELATIVE: int = 2
REPETITION_FREQUENCY: int = 3
RESTORE_STATE: int = 4
RFCAVITY: int = 9
RF_BEND: int = 64
RF_FREQUENCY: int = 15
RF_WAVELENGTH: int = 16
RHO: int = 9
RIPKEN_KICK: int = 3
RMS: int = 39
ROLL: int = 2
ROLL_TOT: int = 60
ROOT: int = 60
ROTATIONALLY_SYMMETRIC_RZ: int = 1
RUNGE_KUTTA: int = 3
R_E: float = 2.8179403227e-15
R_P: float = 1.5346982652777385e-18
R_PARENS: int = 6
R_SOLENOID: int = 3
SAD_FULL: int = 5
SAD_MULT: int = 56
SAMPLE: int = 54
SAVE_STATE: int = 3
SBEND: int = 2
SCALE_FIELD_TO_ONE: int = 30
SCALE_MULTIPOLES: int = 113
SCATTER_METHOD: int = 30
SCATTER_TEST: int = 21
SEC: int = 46
SECOND_TRACK_EDGE: int = 12
SECTOR: int = 1
SEXTUPOLE: int = 5
SHIFTED_TO_RELATIVE: int = 3
SHORT: int = 8
SIGN: int = 48
SIG_E: int = 19
SIG_E2: int = 20
SIG_PZ: int = 19
SIG_VX: int = 17
SIG_VY: int = 18
SIG_X: int = 14
SIG_Y: int = 15
SIG_Z: int = 16
SIN: int = 11
SINC: int = 36
SINH: int = 49
SLAVE: int = 84
SLICE: int = 2
SLICE_SLAVE: int = 11
SMALL_REL_CHANGE: float = 1e-14
SOFT_EDGE: int = 8
SOFT_EDGE_ONLY: int = 2
SOLENOID: int = 23
SOLID: int = 1
SOLID_FILL: int = 1
SOL_QUAD: int = 13
SPACE_CHARGE_METHOD: int = 90
SPATIAL_DISTRIBUTION: int = 25
SPECIES: int = 34
SPECIES_CONST: int = 35
SPECIES_OUT: int = 83
SPECIES_STRONG: int = 25
SPHERICAL: int = 3
SPIN_DN_DPZ_X: int = 7
SPIN_DN_DPZ_Y: int = 8
SPIN_DN_DPZ_Z: int = 9
SPIN_FRINGE_ON: int = 13
SPIN_INTEGRATION: int = 99
SPIN_TRACKING_METHOD: int = 94
SPIN_X: int = 21
SPIN_X_STORED: int = 55
SPIN_Y: int = 22
SPIN_Y_STORED: int = 56
SPIN_Z: int = 23
SPIN_Z_STORED: int = 57
SPLIT_ID: int = 31
SPRINT: int = 12
SQRT: int = 18
SQRT_2: float = 1.4142135623730951
SQRT_3: float = 1.7320508075688772
SQUARE_BRACKETS: int = 62
SQUARE_CONCAVE_SYM: int = 10
SQUARE_FILLED_SYM: int = 16
SQUARE_SYM: int = 0
SR_WAKE: int = 114
SR_WAKE_FILE: int = 100
STALE: int = 2
STANDARD: int = 1
STANDING_WAVE: int = 1
STAR5_FILLED_SYM: int = 18
STAR5_SYM: int = 12
START_EDGE: int = 129
START_END: int = 99
STAR_OF_DAVID_SYM: int = 15
STEADY_STATE_3D: int = 3
STRAIGHT: int = 2
SUM: int = 41
SUPERIMPOSE: int = 120
SUPER_LORD: int = 5
SUPER_OFFSET: int = 121
SUPER_OK: int = 0
SUPER_SLAVE: int = 2
SURFACE: int = 6
SYMMETRY: int = 6
SYMPLECTIFY: int = 103
SYMP_LIE_BMAD: int = 10
SYMP_LIE_PTC: int = 2
S_ABORT: int = 9
S_AND_FLOOR_POSITION_GROUP: int = 9
S_BLANK: int = -1
S_DINFO: int = 1
S_DWARN: int = 5
S_ERROR: int = 7
S_FATAL: int = 8
S_IMPORTANT: int = 10
S_INFO: int = 0
S_LONG: int = 92
S_NOOUTPUT: int = -2
S_PLANE: int = 5
S_POSITION: int = 131
S_POSITION_GROUP: int = 4
S_SUCCESS: int = 2
S_TWISS_REF: int = 4
S_WARN: int = 3
T: int = 8
T0: int = 162
T21: int = 183
TAN: int = 13
TANH: int = 51
TAYLOR: int = 8
TAYLOR_MAP_INCLUDES_OFFSETS: int = 88
TAYLOR_OFFSET: int = 1000000000
TAYLOR_ORDER: int = 3
TERM: int = 101
THETA_POSITION: int = 105
THICKNESS: int = 65
THICK_MULTIPOLE: int = 67
TILT: int = 2
TILT_CALIB: int = 24
TILT_CORR: int = 4
TILT_TOT: int = 60
TIMES: int = 3
TIMES_SYM: int = 3
TIME_RUNGE_KUTTA: int = 6
TO_ELEMENT: int = 111
TO_LINE: int = 110
TRACKING: int = 5
TRACKING_METHOD: int = 92
TRAILING: int = 3
TRANSMISSION: int = 2
TRANSPARENT: int = 16
TRANSVERSE_KICK: int = 3
TRANSVERSE_SIGMA_CUT: int = 31
TRAVELING_WAVE: int = 2
TRIANGLE_FILLED_SYM: int = 13
TRIANGLE_SYM: int = 7
TRUE_: float = 1.0
TRUE_INT: int = 1
TT: int = 81
TWISS_PROPAGATE_FAILURE: int = 8
TWOPI: float = 6.283185307179586
TYPE: int = 117
T_OFFSET: int = 32
UB_SUBATOMIC: int = 9
UNARY_MINUS: int = 8
UNARY_PLUS: int = 9
UNDIFFRACTED: int = 3
UNDULATOR: int = 51
UNIFORM: int = 1
UNKNOWN: int = 7
UNPOLARIZED: int = 2
UNSTABLE: int = 4
UNSTABLE_A: int = 5
UNSTABLE_B: int = 6
UPSTREAM: int = 1
UPSTREAM_COORD_DIR: int = 29
UPSTREAM_END: int = 1
USER_SET: int = 0
USER_SETS_LENGTH: int = 28
USE_REFLECTIVITY_TABLE: int = 32
V1_UNITCELL: int = 22
V2_UNITCELL: int = 23
VAL1: int = 19
VAL10: int = 28
VAL11: int = 29
VAL12: int = 30
VAL2: int = 20
VAL3: int = 21
VAL4: int = 22
VAL5: int = 23
VAL6: int = 24
VAL7: int = 25
VAL8: int = 26
VAL9: int = 27
VAR: int = 89
VARIABLE: int = 30
VAR_OFFSET: int = 2000
VELOCITY_DISTRIBUTION: int = 26
VERTICALLY_PURE: int = 3
VERTICAL_BAR: int = 71
VERTICAL_KICK: int = 105
VKICK: int = 40
VKICKER: int = 34
VOLTAGE: int = 8
VOLTAGE_ERR: int = 9
VOLTAGE_TOT: int = 30
V_DISPLACE: int = 5
V_UNITCELL: int = 23
WALL: int = 107
WALL3D: int = 5
WALL_END: int = 10
WALL_START: int = 9
WALL_TRANSITION: int = 7
WHITE: int = 0
WIGGLER: int = 12
WIGGLERS: int = 202
WRAP_SUPERIMPOSE: int = 133
X: int = 1
X0: int = 30
X1: int = 36
X1_EDGE: int = 22
X1_LIMIT: int = 71
X2_EDGE: int = 23
X2_LIMIT: int = 72
XFER_MAT_CALC_FAILURE: int = 7
XY: int = 2
XYZ: int = 2
XY_AXIS: int = 4
X_AXIS: int = 1
X_DISPERSION_CALIB: int = 29
X_DISPERSION_ERR: int = 27
X_GAIN_CALIB: int = 8
X_GAIN_ERR: int = 3
X_INVARIANT: int = 1
X_KICK: int = 33
X_KNOT: int = 81
X_LEADING: int = 2
X_LIMIT: int = 96
X_OFFSET: int = 36
X_OFFSET_CALIB: int = 22
X_OFFSET_MULT: int = 39
X_OFFSET_TOT: int = 57
X_PITCH: int = 34
X_PITCH_TOT: int = 55
X_PLANE: int = 1
X_POLARIZATION: int = 2
X_POSITION: int = 102
X_QUAD: int = 27
X_REF: int = 83
X_STORED: int = 15
X_SYMBOL_SYM: int = 5
X_TRAILING: int = 4
Y: int = 3
Y0: int = 32
Y1: int = 38
Y1_EDGE: int = 24
Y1_LIMIT: int = 73
Y2_EDGE: int = 25
Y2_LIMIT: int = 74
YELLOW: int = 7
YELLOW_GREEN: int = 9
YES: int = 1
Y_AXIS: int = 2
Y_DISPERSION_CALIB: int = 30
Y_DISPERSION_ERR: int = 28
Y_GAIN_CALIB: int = 20
Y_GAIN_ERR: int = 4
Y_KICK: int = 35
Y_KNOT: int = 83
Y_LEADING: int = 3
Y_LIMIT: int = 97
Y_OFFSET: int = 37
Y_OFFSET_CALIB: int = 23
Y_OFFSET_MULT: int = 40
Y_OFFSET_TOT: int = 58
Y_PITCH: int = 35
Y_PITCH_TOT: int = 56
Y_PLANE: int = 2
Y_POLARIZATION: int = 3
Y_POSITION: int = 103
Y_QUAD: int = 28
Y_REF: int = 85
Y_STORED: int = 17
Y_TRAILING: int = 5
Z: int = 5
Z0: int = 34
Z1: int = 40
ZERO: int = 3
Z_APERTURE_CENTER: int = 29
Z_APERTURE_WIDTH2: int = 28
Z_AXIS: int = 3
Z_KICK: int = 37
Z_OFFSET: int = 38
Z_OFFSET_TOT: int = 59
Z_PLANE: int = 3
Z_POSITION: int = 104
Z_REF: int = 89
Z_STORED: int = 19
