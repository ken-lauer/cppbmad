#!/usr/bin/env python3

# Note:
#   Run this script in the cpp_bmad_interface directory.
#   This script searches a set of Bmad files and generates corresponding constants for use with C++ code.
#   The constants file is: include/bmad_enums.h
#   For example, the proton$ parameter on the Fortran side is translated to PROTON on the C++ side.
#
from __future__ import annotations

import pathlib
import re
from dataclasses import dataclass

from bmad_struct_parser.util import FileLine

from .paths import ACC_ROOT_DIR
from .util import write_if_differs

INCLUDE_DIR = ACC_ROOT_DIR / "cpp_bmad_interface" / "include"
INCLUDE_DIR.mkdir(parents=True, exist_ok=True)
ENUM_FILENAME = INCLUDE_DIR / "bmad_enums.h"

ENUM_FILENAMES = [
    ACC_ROOT_DIR / "bmad/modules/bmad_struct.f90",
    ACC_ROOT_DIR / "sim_utils/io/output_mod.f90",
    ACC_ROOT_DIR / "sim_utils/interfaces/physical_constants.f90",
    ACC_ROOT_DIR / "sim_utils/interfaces/particle_species_mod.f90",
    ACC_ROOT_DIR / "sim_utils/interfaces/sim_utils_struct.f90",
    ACC_ROOT_DIR / "sim_utils/plot/quick_plot_struct.f90",
]

re_int = re.compile("INTEGER, *PARAMETER *:: *")
re_real = re.compile(r"REAL\(RP\), *PARAMETER *:: *")
re_d_exp = re.compile(r"\dD[+-]?\d")
re_equal = re.compile(r"\=.*\dD[+-]?\d")


@dataclass
class EnumValue:
    name: str
    value: str
    type: str
    comment: str


def _clean_line(line: str) -> str:
    # Strip datatype information
    line = re_int.sub("", line)
    line = re_real.sub("", line)

    if "Z'" in line:
        line = line.replace("Z'", "0x").replace("'", "")
    if "z'" in line:
        line = line.replace("z'", "0x").replace("'", "")

    # Handle Fortran-style exponents, replace `D` with `E`
    if re_equal.search(line):
        sub = re_d_exp.search(line)
        if sub:
            d_exp_value = sub.group(0).replace("D", "E")  # Replace "3D6" with "3E6"
            line = re_d_exp.sub(d_exp_value, line)
    return line


def parse_fortran_enums(fn: pathlib.Path) -> dict[str, EnumValue]:
    """
    Parse Fortran-like constants into a dictionary of {enum_name: enum_value}.
    """
    enum_dict = {}

    for file_line in FileLine.from_file(fn):
        line, comment = file_line.split_comment()
        line = line.upper()

        # Skip parameter arrays or irrelevant lines
        if "[" in line:
            continue

        if re_int.match(line):
            type_ = "int"
        elif re_real.match(line):
            type_ = "double"
        else:
            continue

        line = _clean_line(line)
        # Skip lines with arrays
        if "(" in line:
            continue

        for idx, part in enumerate(line.split(",")):
            part = part.strip()

            name, value = part.split("=", 1)
            name = name.strip().rstrip("$")
            value = value.strip().replace("$", "").replace("_RP", "")
            enum_dict[name] = EnumValue(
                name=name,
                value=value,
                type=type_,
                comment=comment if idx == 0 else "",
            )

    return enum_dict


def get_enums_in_range(enums: dict[str, EnumValue], start_key: str, num_key: str) -> list[EnumValue]:
    # Length will always be the first attribute.
    # We go from L and search until we exceed NUM_ELE_ATTRIB to find attributes.
    first_attr = enums[start_key]
    num_enums = int(enums[num_key].value)
    attrs = list(enums.values())
    attrs = attrs[attrs.index(first_attr) :]
    result = []
    for attr in attrs:
        try:
            cur_value = int(attr.value)
            if cur_value > num_enums:
                break
        except TypeError:
            break

        if result:
            last_value = int(result[-1].value)
            if last_value == num_enums and cur_value < num_enums:
                # Wrapping around to 1 for the next set of enums
                break
        result.append(attr)

    return result


def get_ele_attributes(enums: dict[str, EnumValue]):
    return get_enums_in_range(enums, start_key="L", num_key="NUM_ELE_ATTRIB")


def get_ele_keys(enums: dict[str, EnumValue]):
    return get_enums_in_range(enums, start_key="DRIFT", num_key="N_KEY")


def get_class_code(clsname: str, enums: list[EnumValue]) -> str:
    code = [f"enum class {clsname} : size_t {{"]
    for attr in enums:
        if attr.comment:
            code.append(f"// {attr.comment}")
        code.append(f"  {attr.name} = {attr.value},")
    code.append(f"}}; // enum class {clsname}")
    return "\n".join(code)


def get_enum_code():
    result = [
        """
//+
// C++ constants equivalent to Bmad parameters.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY! 
//-

#ifndef BMAD_ENUMS

// The TRUE/FALSE stuff is to get around a problem with TRUE and FALSE being defined using #define

#ifdef TRUE
#undef TRUE
#define TRUE_DEF
#endif

#ifdef FALSE
#undef FALSE
#define FALSE_DEF
#endif

namespace Bmad {
"""
    ]

    for fn in ENUM_FILENAMES:
        enums = parse_fortran_enums(fn)
        result.append("")
        result.append(f"// Enums from {fn.name}")
        for enum in enums.values():
            if enum.comment:
                result.append(f"// {enum.comment}")
            result.append(f"const {enum.type} {enum.name} = {enum.value};")

        if fn.name == "bmad_struct.f90":
            result.append(get_class_code("EleAttribute", get_ele_attributes(enums)))
            result.append(get_class_code("EleKey", get_ele_keys(enums)))

    result.append("""
}

#ifdef TRUE_DEF
#define TRUE    1
#undef TRUE_DEF
#endif

#ifdef FALSE_DEF
#define FALSE   0
#undef FALSE_DEF
#endif

#define BMAD_ENUMS
#endif
""")
    return "\n".join(result)


def write_enums(file):
    # Small wrapper to use 'write_if_differs'
    file.write(get_enum_code())


if __name__ == "__main__":
    write_if_differs(write_enums, ENUM_FILENAME)
