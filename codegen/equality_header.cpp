//+
// C++ equality functions for Bmad / C++ structure interface.
//
// This file is generated as part of the Bmad/C++ interface code generation.
// The code generation files can be found in cpp_bmad_interface.
//
// DO NOT EDIT THIS FILE DIRECTLY!
//-

#include <iostream>
#include <string>
#include <vector>

#include "bmad_std_typedef.h"

using namespace std;

using std::vector, std::string;

//---------------------------------------------------

template <class T>
bool is_all_equal(
    const VariableArray1D<T>& vec1,
    const VariableArray1D<T>& vec2) {
  if (vec1.size() != vec2.size())
    return false;
  for (size_t i = 0; i < vec1.size(); i++) {
    if (!(vec1[i] == vec2[i]))
      return false;
  }
  return true;
}

template <class T>
bool is_all_equal(
    const vector<vector<T>>& mat1,
    const vector<vector<T>>& mat2) {
  if (mat1.size() != mat2.size())
    return false;
  for (size_t i = 0; i < mat1.size(); i++) {
    if (mat1[i].size() != mat2[i].size())
      return false;
    for (size_t j = 0; j < mat1[i].size(); j++) {
      if (!(mat1[i][j] == mat2[i][j]))
        return false;
    }
  }
  return true;
}

template <class T>
bool is_all_equal(
    const vector<vector<vector<T>>>& tensor1,
    const vector<vector<vector<T>>>& tensor2) {
  if (tensor1.size() != tensor2.size())
    return false;
  for (size_t i = 0; i < tensor1.size(); i++) {
    if (tensor1[i].size() != tensor2[i].size())
      return false;
    for (size_t j = 0; j < tensor1[i].size(); j++) {
      if (tensor1[i][j].size() != tensor2[i][j].size())
        return false;
      for (size_t k = 0; k < tensor1[i][j].size(); k++) {
        if (!(tensor1[i][j][k] == tensor2[i][j][k]))
          return false;
      }
    }
  }
  return true;
}

template <typename T, std::size_t DIM1>
bool is_all_equal(
    const FixedArray1D<T, DIM1>& arr1,
    const FixedArray1D<T, DIM1>& arr2) {
  // No need to check sizes since they're fixed at compile time
  for (std::size_t i = 0; i < DIM1; i++) {
    if (!(arr1[i] == arr2[i]))
      return false;
  }
  return true;
}

template <typename T, std::size_t DIM1, std::size_t DIM2>
bool is_all_equal(
    const FixedArray2D<T, DIM1, DIM2>& arr1,
    const FixedArray2D<T, DIM1, DIM2>& arr2) {
  // No need to check sizes since they're fixed at compile time
  for (std::size_t i = 0; i < DIM1; i++) {
    for (std::size_t j = 0; j < DIM2; j++) {
      if (!(arr1[i][j] == arr2[i][j]))
        return false;
    }
  }
  return true;
}

template <typename T, std::size_t DIM1, std::size_t DIM2, std::size_t DIM3>
bool is_all_equal(
    const FixedArray3D<T, DIM1, DIM2, DIM3>& arr1,
    const FixedArray3D<T, DIM1, DIM2, DIM3>& arr2) {
  // No need to check sizes since they're fixed at compile time
  for (std::size_t i = 0; i < DIM1; i++) {
    for (std::size_t j = 0; j < DIM2; j++) {
      for (std::size_t k = 0; k < DIM3; k++) {
        if (!(arr1[i][j][k] == arr2[i][j][k]))
          return false;
      }
    }
  }
  return true;
}
//---------------------------------------------------
