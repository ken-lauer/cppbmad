module cppbmad_routines

use bmad_interface
use bmad_struct
use fortran_cpp_utils
use precision_def ! , only: global_com, rp

use bmad_struct_proxy_mod

use multipole_mod, only: ab_multipole_kick, ab_multipole_kicks, multipole_kick, multipole_kicks

use photon_init_mod, only: absolute_photon_position, bend_photon_e_rel_init, &
    bend_photon_energy_integ_prob, bend_photon_energy_normalized_probability, bend_photon_init, &
    bend_photon_polarization_init, bend_photon_vert_angle_init, bend_vert_angle_integ_prob, &
    e_crit_photon, init_photon_integ_prob

use bmad_routine_interface, only: absolute_time_tracking, ac_kicker_amp, &
    add_lattice_control_structs, allocate_branch_array, allocate_lat_ele_array, &
    angle_between_polars, angle_to_canonical_coords, apply_all_rampers, apply_energy_kick, &
    apply_rampers_to_slave, at_this_ele_end, attribute_bookkeeper, autoscale_phase_and_amp, &
    average_twiss, bbi_kick, bbi_slice_calc, beam_equal_beam, bend_exact_multipole_field, &
    bend_length_has_been_set, bend_shift, bmad_parser, bmad_parser2, branch_equal_branch, &
    branch_name, bunch_equal_bunch, c_to_cbar, calc_super_slave_key, calc_z_tune, &
    canonical_to_angle_coords, cbar_to_c, check_aperture_limit, check_controller_controls, &
    check_if_s_in_bounds, choose_quads_for_set_tune, chrom_calc, chrom_tune, classical_radius, &
    clear_lat_1turn_mats, clear_taylor_maps_from_elements, closed_orbit_calc, &
    closed_orbit_from_tracking, combine_consecutive_elements, &
    complex_taylor_equal_complex_taylor, complex_taylors_equal_complex_taylors, &
    control_bookkeeper, convert_bend_exact_multipole, convert_coords, &
    convert_particle_coordinates_s_to_t, convert_particle_coordinates_t_to_s, convert_pc_to, &
    convert_total_energy_to, converter_distribution_parser, coord_equal_coord, &
    coords_body_to_local, coords_body_to_rel_exit, coords_curvilinear_to_floor, &
    coords_floor_to_curvilinear, coords_floor_to_local_curvilinear, coords_floor_to_relative, &
    coords_local_curvilinear_to_body, coords_local_curvilinear_to_floor, &
    coords_relative_to_floor, create_element_slice, create_field_overlap, create_girder, &
    create_group, create_lat_ele_nametable, create_overlay, create_ramper, &
    create_unique_ele_names, create_wiggler_cartesian_map, crystal_attribute_bookkeeper, &
    deallocate_ele_pointers, deallocate_lat_pointers, default_tracking_species, &
    diffraction_plate_or_mask_hit_spot, distance_to_aperture, do_mode_flip, dpc_given_de, &
    e_accel_field, ele_compute_ref_energy_and_time, ele_equal_ele, ele_equals_ele, &
    ele_full_name, ele_geometry, ele_geometry_with_misalignments, ele_has_constant_ds_dt_ref, &
    ele_has_nonzero_kick, ele_has_nonzero_offset, ele_loc, ele_loc_name, &
    ele_misalignment_l_s_calc, ele_nametable_index, ele_order_calc, &
    ele_reference_energy_correction, ele_rf_step_index, ele_to_spin_taylor, ele_to_taylor, &
    ele_unique_name, ele_value_has_changed, ele_vec_equal_ele_vec, elec_multipole_field, &
    element_slice_iterator, em_field_calc, em_field_plus_em_field, em_taylor_equal_em_taylor, &
    em_taylors_equal_em_taylors, entering_element, equivalent_taylor_attributes, &
    find_element_ends, find_matching_fieldmap, floor_angles_to_w_mat, floor_w_mat_to_angles, &
    fringe_here, g_bending_strength_from_em_field, g_integrals_calc, gamma_ref, &
    gen_grad1_to_em_taylor, gen_grad_at_s_to_em_taylor, get_slave_list, gradient_shift_sr_wake, &
    hdf5_write_beam, hdf5_write_grid_field, init_bmad, init_bmad_parser_common, &
    init_complex_taylor_series, init_coord1, init_coord2, init_coord3, init_custom, init_ele, &
    init_em_taylor_series, init_lat, init_multipole_cache, init_photon_from_a_photon_init_ele, &
    init_taylor_series, init_wake, insert_element, ion_kick, key_name_to_key_index, &
    kill_ptc_layouts, kill_taylor, knot_interpolate, knots_to_string, &
    lat_compute_ref_energy_and_time, lat_ele_locator, lat_equal_lat, lat_geometry, &
    lat_make_mat6, lat_sanity_check, lat_to_ptc_layout, lat_vec_equal_lat_vec, &
    lattice_bookkeeper, lcavity_rf_step_setup, linear_to_spin_taylor, lord_edge_aligned, &
    low_energy_z_correction, make_g2_mats, make_g_mats, make_hybrid_lat, make_mat6, &
    make_mat6_bmad, make_mat6_bmad_photon, make_mat6_symp_lie_ptc, make_mat6_taylor, &
    make_mat6_tracking, make_v_mats, map1_inverse, map1_make_unit, map1_times_map1, &
    map_to_angle_coords, master_parameter_value, mat4_multipole, mat6_add_offsets, &
    mat6_add_pitch, mat_symp_decouple, match_ele_to_mat6, mexp, momentum_compaction, &
    multi_turn_tracking_analysis, multipass_chain, multipole1_ab_to_kt, multipole1_kt_to_ab, &
    multipole_ab_to_kt, multipole_ele_to_ab, multipole_ele_to_kt, multipole_init, &
    multipole_kick_mat, multipole_kt_to_ab, multipole_spin_tracking, new_control, &
    normal_mode_dispersion, num_field_eles, num_lords, offset_particle, offset_photon, &
    one_turn_mat_at_ele, orbit_amplitude_calc, orbit_reference_energy_correction, &
    orbit_to_floor_phase_space, orbit_to_local_curvilinear, orbit_too_large, &
    order_super_lord_slaves, particle_is_moving_backwards, particle_is_moving_forward, &
    particle_rf_time, patch_flips_propagation_direction, patch_length, physical_ele_end, &
    pointer_to_branch_given_ele, pointer_to_branch_given_name, pointer_to_ele1, &
    pointer_to_ele2, pointer_to_ele3, pointer_to_ele4, pointer_to_field_ele, pointer_to_girder, &
    pointer_to_lord, pointer_to_multipass_lord, pointer_to_next_ele, pointer_to_super_lord, &
    pointer_to_wake_ele, polar_to_spinor, polar_to_vec, ptc_bookkeeper, ptc_ran_seed_put, &
    ptc_set_rf_state_for_c_normal, ptc_transfer_map_with_spin, radiation_integrals, &
    ramper_slave_setup, ramper_value, re_allocate_eles, reallocate_beam, reallocate_bunch, &
    reallocate_control, reallocate_coord_array, reallocate_coord_lat, reallocate_coord_n, &
    reallocate_expression_stack, rel_tracking_charge_to_mass, relative_mode_flip, &
    remove_dead_from_bunch, remove_eles_from_lat, remove_lord_slave_link, reverse_lat, &
    rf_coupler_kick, rf_is_on, rf_ref_time_offset, rotate_for_curved_surface, rotate_spin, &
    rotate_spin_a_step, rotate_spin_given_field, s_body_calc, s_calc, save_a_beam_step, &
    save_a_bunch_step, save_a_step, sbend_body_with_k1_map, set_ele_attribute, &
    set_ele_defaults, set_ele_name, set_ele_real_attribute, set_ele_status_stale, &
    set_emit_from_beam_init, set_flags_for_changed_integer_attribute, &
    set_flags_for_changed_lat_attribute, set_flags_for_changed_logical_attribute, &
    set_flags_for_changed_real_attribute, set_fringe_on_off, set_lords_status_stale, &
    set_on_off, set_orbit_to_zero, set_ptc, set_ptc_base_state, set_status_flags, set_tune, &
    set_twiss, set_z_tune, significant_difference, slice_lattice, sol_quad_mat6_calc, &
    spin_dn_dpz_from_mat8, spin_dn_dpz_from_qmap, spin_map1_normalize, &
    spin_mat8_resonance_strengths, spin_mat_to_eigen, spin_omega, &
    spin_quat_resonance_strengths, spin_taylor_to_linear, spinor_to_polar, spinor_to_vec, &
    spline_fit_orbit, split_lat, sprint_spin_taylor_map, start_branch_at, stream_ele_end, &
    strong_beam_sigma_calc, strong_beam_strength, symp_lie_bmad, taper_mag_strengths, &
    taylor_equal_taylor, taylors_equal_taylors, tilt_coords, tilt_coords_photon, tilt_mat6, &
    to_surface_coords, track1, track1_bmad, track1_bmad_photon, track1_bunch_space_charge, &
    track1_linear, track1_runge_kutta, track1_spin, track1_spin_integration, &
    track1_spin_taylor, track1_symp_lie_ptc, track1_taylor, track1_time_runge_kutta, &
    track_a_beambeam, track_a_bend, track_a_converter, track_a_crab_cavity, track_a_drift, &
    track_a_drift_photon, track_a_foil, track_a_gkicker, track_a_lcavity, track_a_lcavity_old, &
    track_a_mask, track_a_match, track_a_patch, track_a_pickup, track_a_quadrupole, &
    track_a_rfcavity, track_a_sad_mult, track_a_sol_quad, track_a_thick_multipole, &
    track_a_wiggler, track_a_zero_length_element, track_all, track_bunch_time, &
    track_from_s_to_s, track_many, track_to_surface, tracking_rad_map_setup, transfer_ac_kick, &
    transfer_branch, transfer_branch_parameters, transfer_branches, transfer_ele, &
    transfer_ele_taylor, transfer_eles, transfer_fieldmap, transfer_lat, &
    transfer_lat_parameters, transfer_map_calc, transfer_mat2_from_twiss, &
    transfer_mat_from_twiss, transfer_matrix_calc, transfer_twiss, transfer_wake, &
    twiss1_propagate, twiss_and_track_from_s_to_s, twiss_and_track_intra_ele, twiss_at_element, &
    twiss_at_start, twiss_from_tracking, twiss_propagate1, twiss_propagate_all, &
    twiss_to_1_turn_mat, type_coord, update_fibre_from_ele, update_floor_angles, &
    valid_field_calc, valid_fringe_type, valid_mat6_calc_method, valid_spin_tracking_method, &
    valid_tracking_method, value_of_attribute, vec_to_polar, vec_to_spinor, &
    w_mat_for_bend_angle, w_mat_for_tilt, w_mat_for_x_pitch, w_mat_for_y_pitch, &
    write_beam_floor_positions, write_bmad_lattice_file, write_lattice_in_elegant_format, &
    write_lattice_in_foreign_format, write_lattice_in_mad_format, write_lattice_in_sad_format, &
    write_lattice_in_scibmad, zero_ele_kicks, zero_ele_offsets

use mode3_mod, only: action_to_xyz, beam_tilts, eigen_decomp_6mat, get_emit_from_sigma_mat, &
    make_hvbp, make_n, make_smat_from_abc, mytan, normal_mode3_calc, normalize_evecs, &
    order_evecs_by_n_similarity, order_evecs_by_plane_dominance, order_evecs_by_tune, &
    project_emit_to_xyz, t6_to_b123, twiss3_at_start, twiss3_from_twiss2, twiss3_propagate1, &
    twiss3_propagate_all

use superimpose_mod, only: add_superimpose, adjust_super_slave_names

use bmad_parser_mod, only: add_this_multipass, add_this_taylor_term, bp_set_ran_status, &
    check_for_superimpose_problem, drift_and_pipe_track_methods_adjustment, &
    drift_multipass_name_correction, equal_sign_here, evaluate_array_index, evaluate_logical, &
    expect_one_of, expect_this, form_digested_bmad_file_name, get_called_file, get_next_word, &
    init_surface_segment, load_parse_line, nint_chk, parse_cartesian_map, &
    parse_cylindrical_map, parse_gen_grad_map, parse_grid_field, parse_integer_list, &
    parse_integer_list2, parse_real_list, parse_real_list2, parser_add_constant, &
    parser_call_check, parser_fast_complex_read, parser_fast_integer_read, &
    parser_fast_real_read, parser_file_stack, parser_get_integer, parser_get_logical, &
    parser_identify_fork_to_element, parser_init_custom_elements, parser_print_line, &
    parser_read_lr_wake, parser_read_old_format_lr_wake, parser_read_old_format_sr_wake, &
    parser_read_sr_wake, parser_transfer_control_struct, reallocate_bp_com_const, &
    settable_dep_var_bookkeeping, verify_valid_name, word_to_value

use bookkeeper_mod, only: aperture_bookkeeper, attributes_need_bookkeeping, &
    compute_slave_coupler, makeup_control_slave, makeup_group_lord, makeup_multipass_slave, &
    makeup_super_slave, makeup_super_slave1

use ptc_interface_mod, only: apply_patch_to_ptc_fibre, bmad_patch_parameters_to_ptc, &
    concat_ele_taylor, concat_taylor, ele_to_ptc_magnetic_bn_an, form_complex_taylor, &
    kind_name, ptc_set_taylor_order_if_needed, remove_constant_taylor, set_ptc_com_pointers, &
    set_ptc_quiet, sigma_mat_ptc_to_bmad, taylor_inverse, taylor_propagate1

use write_lattice_file_mod, only: array_re_str, cmplx_re_str, rchomp, re_str_qp, re_str_rp, &
    value_to_line, write_lat_line, write_line_element

use astra_interface_mod, only: astra_max_field_reference, rotate3, write_astra_bend, &
    write_astra_field_grid_file, write_astra_field_grid_file_3d

use attribute_mod, only: attribute_free1, attribute_free2, attribute_free3, attribute_index1, &
    attribute_index2, attribute_name1, attribute_name2, attribute_type, attribute_units, &
    custom_attribute_ubound_index, field_attribute_free, has_attribute, &
    has_orientation_attributes, init_attribute_name1, init_attribute_name_array, &
    n_attrib_string_max_len, set_custom_attribute_name, string_attrib

use envelope_mod, only: beam_envelope_ibs, damping_matrix_d, diffusion_matrix_b, &
    envelope_radints, envelope_radints_ibs, etdiv, ibs_matrix_c, integrated_mats, make_pbrh, &
    make_v

use fringe_mod, only: bend_edge_kick, exact_bend_edge_kick, hard_multipole_edge_kick, &
    hwang_bend_edge_kick, linear_bend_edge_kick, sad_mult_hard_bend_edge_kick, &
    sad_soft_bend_edge_kick, soft_quadrupole_edge_kick

use ibs_mod, only: bl_via_vlassov

use ptc_layout_mod, only: branch_to_ptc_m_u, normal_form_complex_taylors, normal_form_taylors, &
    ptc_closed_orbit_calc, ptc_emit_calc, ptc_layouts_resplit, &
    ptc_one_turn_mat_and_closed_orbit_calc, ptc_spin_calc, ptc_track_all, set_ptc_verbose, &
    update_ele_from_fibre

use beam_utils, only: calc_bunch_params, calc_bunch_params_slice, calc_bunch_params_z_slice, &
    calc_bunch_sigma_matrix_etc, calc_emittances_and_twiss_from_sigma_matrix, calc_spin_params, &
    init_beam_distribution, init_bunch_distribution, init_spin_distribution, track1_bunch_hom

use wall3d_mod, only: calc_wall_radius, create_concatenated_wall3d, mark_patch_regions, &
    pointer_to_wall3d, re_allocate_wall3d_section_array, re_allocate_wall3d_vertex_array, &
    wall3d_d_radius, wall3d_initializer, wall3d_section_initializer, wall3d_to_position

use complex_taylor_mod, only: complex_taylor_clean, complex_taylor_exponent_index, &
    complex_taylor_make_unit, complex_taylor_to_mat6, kill_complex_taylor, &
    mat6_to_complex_taylor, sort_complex_taylor_terms, track_complex_taylor, &
    truncate_complex_taylor_to_order

use transfer_map_mod, only: concat_transfer_mat, transfer_map_from_s_to_s

use em_field_mod, only: convert_field_ele_to_lab, em_field_derivatives, g_bend_from_em_field, &
    gen_grad_field, grid_field_interpolate, rotate_em_field, to_fieldmap_coords

use gpt_interface_mod, only: convert_local_cartesian_to_local_curvilinear, &
    convert_local_curvilinear_to_local_cartesian, gpt_field_grid_scaling, &
    gpt_max_field_reference, gpt_to_particle_bunch, rotate_field_zx, &
    write_gpt_field_grid_file_1d, write_gpt_field_grid_file_2d, write_gpt_field_grid_file_3d

use bmad_struct, only: coord_state_name, ele_finalizer, is_attribute, pointer_to_slave

use open_spacecharge_core_mod, only: coulombfun, igfcoulombfun, igfexfun, igfeyfun, igfezfun, &
    lafun, osc_alloc_freespace_array, osc_alloc_image_array, osc_alloc_rectpipe_arrays, &
    osc_getgrnpipe, osc_read_rectpipe_grn, osc_write_rectpipe_grn, rfun, xlafun, ylafun, zlafun

use element_modeling_mod, only: create_planar_wiggler_model, create_sol_quad_model

use track1_photon_mod, only: crystal_h_misalign, point_photon_emission, target_min_max_calc, &
    target_rot_mats, track1_crystal, track1_diffraction_plate_or_mask, track1_lens, &
    track1_mirror, track1_mosaic_crystal, track1_multilayer_mirror, track1_sample, &
    track_a_bend_photon, track_a_patch_photon

use xraylib_interface, only: crystal_type_to_crystal_params, &
    multilayer_type_to_multilayer_params, photon_absorption_and_phase_shift, &
    xraylib_nist_compound

use expression_mod, only: deallocate_expression_tree, deallocate_tree, &
    expression_stack_to_string, expression_stack_value, expression_string_to_stack, &
    expression_string_to_tree, expression_tree_to_string, expression_value, linear_coef, &
    re_associate_node_array, type_expression_tree

use photon_target_mod, only: detector_pixel_pt, photon_add_to_detector_statistics, &
    photon_target_corner_calc, photon_target_setup, to_photon_angle_coords

use time_tracker_mod, only: drift_orbit_time, em_field_kick_vector_time, odeint_bmad_time, &
    particle_in_global_frame, rk_adaptive_time_step, rk_time_step1, track_until_dead, &
    write_time_particle_distribution

use space_charge_mod, only: drift_particle_to_s, drift_particle_to_t, sc_adaptive_step, &
    sc_step, track_bunch_to_s, track_bunch_to_t

use csr_and_space_charge_mod, only: dspline_len, track1_bunch_csr, track1_bunch_csr3d

use dynamic_aperture_mod, only: dynamic_aperture_point, dynamic_aperture_scan

use measurement_mod, only: ele_is_monitor, to_eta_reading, to_orbit_reading, &
    to_phase_and_coupling_reading

use csr3d_mod, only: ellipinc_test

use rad_6d_mod, only: emit_6d, rad1_damp_and_stoc_mats, rad_damp_and_stoc_mats, rad_g_integrals

use equality_mod, only: eq_ac_kicker, eq_ac_kicker_freq, eq_ac_kicker_time, eq_anormal_mode, &
    eq_aperture_param, eq_aperture_point, eq_aperture_scan, eq_beam, eq_beam_init, &
    eq_bmad_common, eq_bookkeeping_state, eq_bpm_phase_coupling, eq_branch, eq_bunch, &
    eq_bunch_params, eq_cartesian_map, eq_cartesian_map_term, eq_cartesian_map_term1, &
    eq_complex_taylor, eq_complex_taylor_term, eq_control, eq_control_ramp1, eq_control_var1, &
    eq_controller, eq_coord, eq_coord_array, eq_cylindrical_map, eq_cylindrical_map_term, &
    eq_cylindrical_map_term1, eq_ele, eq_ellipse_beam_init, eq_em_field, eq_em_taylor, &
    eq_em_taylor_term, eq_expression_atom, eq_floor_position, eq_gen_grad1, eq_gen_grad_map, &
    eq_grid_beam_init, eq_grid_field, eq_grid_field_pt, eq_grid_field_pt1, &
    eq_high_energy_space_charge, eq_interval1_coef, eq_kv_beam_init, eq_lat, eq_lat_ele_loc, &
    eq_lat_param, eq_linac_normal_mode, eq_mode3, eq_mode_info, eq_normal_modes, &
    eq_photon_element, eq_photon_material, eq_photon_reflect_surface, eq_photon_reflect_table, &
    eq_photon_target, eq_pixel_detec, eq_pixel_pt, eq_pre_tracker, eq_rad_int1, &
    eq_rad_int_all_ele, eq_rad_int_branch, eq_rad_map, eq_rad_map_ele, eq_ramper_lord, &
    eq_space_charge_common, eq_spin_polar, eq_spline, eq_strong_beam, eq_surface_curvature, &
    eq_surface_displacement, eq_surface_displacement_pt, eq_surface_h_misalign, &
    eq_surface_h_misalign_pt, eq_surface_segmented, eq_surface_segmented_pt, eq_target_point, &
    eq_taylor, eq_taylor_term, eq_track, eq_track_point, eq_twiss, eq_wake, eq_wake_lr, &
    eq_wake_lr_mode, eq_wake_sr, eq_wake_sr_mode, eq_wake_sr_z_long, eq_wall3d, &
    eq_wall3d_section, eq_wall3d_vertex, eq_xy_disp

use touschek_mod, only: exp_bessi0, integrand_base, touschek_lifetime, touschek_rate1, &
    touschek_rate1_zap

use fast_fourier_am, only: fft1, mfft1

use photon_reflection_mod, only: finalize_reflectivity_table, photon_reflection, &
    photon_reflection_std_surface_init, photon_reflectivity, read_surface_reflection_file

use longitudinal_profile_mod, only: find_fwhm, find_normalization, get_bl_from_fwhm, &
    integrate_psi, psi_prime_sca, pwd_mat, set_pwd_ele, solve_psi_adaptive, &
    solve_psi_fixed_steps

use photon_utils_mod, only: has_curvature, photon_type, pointer_to_surface_displacement_pt, &
    pointer_to_surface_segmented_pt, surface_grid_displacement, z_at_surface

use integration_timer_mod, only: integration_timer_ele

use runge_kutta_mod, only: kick_vector_calc, odeint_bmad

use mad_mod, only: mad_tmfoc, mad_tmsymm, make_mat6_mad, track1_mad

use high_energy_space_charge_mod, only: make_mat6_high_energy_space_charge, &
    setup_high_energy_space_charge_calc, track1_high_energy_space_charge

use binary_parser_mod, only: open_binary_file, read_binary_cartesian_map, &
    read_binary_cylindrical_map, read_binary_grid_field, write_binary_cartesian_map, &
    write_binary_cylindrical_map, write_binary_grid_field

use wake_mod, only: order_particles_in_z, randomize_lr_wake_frequencies, &
    sr_longitudinal_wake_particle, sr_transverse_wake_particle, sr_z_long_wake, track1_lr_wake, &
    track1_sr_wake, zero_lr_wakes_in_lat

use element_at_s_mod, only: pointer_to_element_at_s

use radiation_mod, only: radiation_map_setup, release_rad_int_cache, track1_radiation, &
    track1_radiation_center

use beam_file_io, only: read_beam_ascii, read_beam_file, write_ascii_beam_file, write_beam_file

use fixer_mod, only: set_active_fixer, transfer_fixer_params

use blender_interface_mod, only: skip_ele_blender, write_blender_ele, write_blender_lat_layout

use srdt_mod, only: srdt_calc, srdt_lsq_solution

use beam_mod, only: track1_beam, track1_bunch, track_beam, track_bunch

use capillary_mod, only: track_a_capillary

use twiss_and_track_mod, only: twiss_and_track_at_s

use opal_interface_mod, only: write_opal_field_grid_file, write_opal_lattice_file


use, intrinsic :: iso_c_binding

contains

! shorthand for c_associated since we're going to use it a lot here
elemental function assc(ptr) result(associated)
  type(c_ptr), intent(in) :: ptr
  logical :: associated
  
  associated = c_associated(ptr)
end function assc

subroutine fortran_ab_multipole_kick (a, b, n, ref_species, ele_orientation, coord, kx, ky, dk, &
    pole_type, scale) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: a  ! 0D_NOT_real
  real(rp) :: f_a
  real(c_double) :: b  ! 0D_NOT_real
  real(rp) :: f_b
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  integer(c_int) :: ref_species  ! 0D_NOT_integer
  integer :: f_ref_species
  integer(c_int) :: ele_orientation  ! 0D_NOT_integer
  integer :: f_ele_orientation
  type(c_ptr), value :: coord  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord
  type(c_ptr), intent(in), value :: pole_type  ! 0D_NOT_integer
  integer(c_int) :: f_pole_type
  integer(c_int), pointer :: f_pole_type_ptr
  type(c_ptr), intent(in), value :: scale  ! 0D_NOT_real
  real(c_double) :: f_scale
  real(c_double), pointer :: f_scale_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: kx  ! 0D_NOT_real
  real(rp) :: f_kx
  real(c_double), pointer :: f_kx_ptr
  type(c_ptr), intent(in), value :: ky  ! 0D_NOT_real
  real(rp) :: f_ky
  real(c_double), pointer :: f_ky_ptr
  type(c_ptr), intent(in), value :: dk
  real(rp) :: f_dk(2,2)
  real(c_double), pointer :: f_dk_ptr(:)
  ! ** End of parameters **
  ! in: f_a 0D_NOT_real
  f_a = a
  ! in: f_b 0D_NOT_real
  f_b = b
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_ref_species 0D_NOT_integer
  f_ref_species = ref_species
  ! in: f_ele_orientation 0D_NOT_integer
  f_ele_orientation = ele_orientation
  ! in: f_coord 0D_NOT_type
  if (.not. c_associated(coord)) return
  call c_f_pointer(coord, f_coord)
  ! in: f_pole_type 0D_NOT_integer
  if (c_associated(pole_type)) then
    call c_f_pointer(pole_type, f_pole_type_ptr)
  else
    f_pole_type_ptr => null()
  endif
  ! in: f_scale 0D_NOT_real
  if (c_associated(scale)) then
    call c_f_pointer(scale, f_scale_ptr)
  else
    f_scale_ptr => null()
  endif
  call ab_multipole_kick(a=f_a, b=f_b, n=f_n, ref_species=f_ref_species, &
      ele_orientation=f_ele_orientation, coord=f_coord, kx=f_kx, ky=f_ky, dk=f_dk, &
      pole_type=f_pole_type_ptr, scale=f_scale_ptr)

  ! out: f_kx 0D_NOT_real
  call c_f_pointer(kx, f_kx_ptr)
  f_kx_ptr = f_kx
  ! out: f_ky 0D_NOT_real
  call c_f_pointer(ky, f_ky_ptr)
  f_ky_ptr = f_ky
  ! out: f_dk 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_dk', c_name='dk', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=317, definition='real(rp), optional :: dk(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='dk', comment='', default=None), intent='out', description='Kick derivative: dkick(x,y)/d(x,y).', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_ab_multipole_kicks (an, bn, ix_pole_max, ele, orbit, pole_type, scale, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: an
  type(real_container_alloc), pointer :: f_an
  type(c_ptr), intent(in), value :: bn
  type(real_container_alloc), pointer :: f_bn
  integer(c_int) :: ix_pole_max  ! 0D_NOT_integer
  integer :: f_ix_pole_max
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: pole_type  ! 0D_NOT_integer
  integer(c_int) :: f_pole_type
  integer(c_int), pointer :: f_pole_type_ptr
  type(c_ptr), intent(in), value :: scale  ! 0D_NOT_real
  real(c_double) :: f_scale
  real(c_double), pointer :: f_scale_ptr
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(an))   call c_f_pointer(an, f_an)
  !! container general array (1D_ALLOC_real)
  if (c_associated(bn))   call c_f_pointer(bn, f_bn)
  ! in: f_ix_pole_max 0D_NOT_integer
  f_ix_pole_max = ix_pole_max
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_pole_type 0D_NOT_integer
  if (c_associated(pole_type)) then
    call c_f_pointer(pole_type, f_pole_type_ptr)
  else
    f_pole_type_ptr => null()
  endif
  ! in: f_scale 0D_NOT_real
  if (c_associated(scale)) then
    call c_f_pointer(scale, f_scale_ptr)
  else
    f_scale_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call ab_multipole_kicks(an=f_an%data, bn=f_bn%data, ix_pole_max=f_ix_pole_max, ele=f_ele, &
      orbit=f_orbit, pole_type=f_pole_type_ptr, scale=f_scale_ptr, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_absolute_photon_position (e_orb, photon_orb) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: e_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_e_orb
  ! ** Inout parameters **
  type(c_ptr), value :: photon_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_photon_orb
  ! ** End of parameters **
  ! in: f_e_orb 0D_NOT_type
  if (.not. c_associated(e_orb)) return
  call c_f_pointer(e_orb, f_e_orb)
  ! inout: f_photon_orb 0D_NOT_type
  if (.not. c_associated(photon_orb)) return
  call c_f_pointer(photon_orb, f_photon_orb)
  call absolute_photon_position(e_orb=f_e_orb, photon_orb=f_photon_orb)

end subroutine
subroutine fortran_absolute_time_tracking (ele, is_abs_time) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_abs_time  ! 0D_NOT_logical
  logical :: f_is_abs_time
  logical(c_bool), pointer :: f_is_abs_time_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_is_abs_time = absolute_time_tracking(ele=f_ele)

  ! out: f_is_abs_time 0D_NOT_logical
  call c_f_pointer(is_abs_time, f_is_abs_time_ptr)
  f_is_abs_time_ptr = f_is_abs_time
end subroutine
subroutine fortran_ac_kicker_amp (ele, orbit, true_time, ac_amp) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: true_time  ! 0D_NOT_real
  real(c_double) :: f_true_time
  real(c_double), pointer :: f_true_time_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ac_amp  ! 0D_NOT_real
  real(rp) :: f_ac_amp
  real(c_double), pointer :: f_ac_amp_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_true_time 0D_NOT_real
  if (c_associated(true_time)) then
    call c_f_pointer(true_time, f_true_time_ptr)
  else
    f_true_time_ptr => null()
  endif
  f_ac_amp = ac_kicker_amp(ele=f_ele, orbit=f_orbit, true_time=f_true_time_ptr)

  ! out: f_ac_amp 0D_NOT_real
  call c_f_pointer(ac_amp, f_ac_amp_ptr)
  f_ac_amp_ptr = f_ac_amp
end subroutine
subroutine fortran_action_to_xyz (ring, ix, J, X, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ring  ! 0D_NOT_type
  type(lat_struct), pointer :: f_ring
  integer(c_int) :: ix  ! 0D_NOT_integer
  integer :: f_ix
  type(c_ptr), intent(in), value :: J
  real(rp) :: f_J(1:6)
  real(c_double), pointer :: f_J_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: X
  real(rp) :: f_X(1:6)
  real(c_double), pointer :: f_X_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_ring 0D_NOT_type
  if (.not. c_associated(ring)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ring, f_ring)
  ! in: f_ix 0D_NOT_integer
  f_ix = ix
  !! general array (1D_NOT_real)
  if (c_associated(J)) then
    call c_f_pointer(J, f_J_ptr, [6])
    f_J = f_J_ptr(:)
  else
    f_J_ptr => null()
  endif
  call action_to_xyz(ring=f_ring, ix=f_ix, J=f_J, X=f_X, err_flag=f_err_flag)

  ! out: f_X 1D_NOT_real
  if (c_associated(X)) then
    call c_f_pointer(X, f_X_ptr, [6])
    f_X_ptr = f_X(:)
  endif
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_add_lattice_control_structs (ele, n_add_slave, n_add_lord, &
    n_add_slave_field, n_add_lord_field, add_at_end) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: n_add_slave  ! 0D_NOT_integer
  integer(c_int) :: f_n_add_slave
  integer(c_int), pointer :: f_n_add_slave_ptr
  type(c_ptr), intent(in), value :: n_add_lord  ! 0D_NOT_integer
  integer(c_int) :: f_n_add_lord
  integer(c_int), pointer :: f_n_add_lord_ptr
  type(c_ptr), intent(in), value :: n_add_slave_field  ! 0D_NOT_integer
  integer(c_int) :: f_n_add_slave_field
  integer(c_int), pointer :: f_n_add_slave_field_ptr
  type(c_ptr), intent(in), value :: n_add_lord_field  ! 0D_NOT_integer
  integer(c_int) :: f_n_add_lord_field
  integer(c_int), pointer :: f_n_add_lord_field_ptr
  type(c_ptr), intent(in), value :: add_at_end  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_add_at_end
  logical, target :: f_add_at_end_native
  logical, pointer :: f_add_at_end_native_ptr
  logical(c_bool), pointer :: f_add_at_end_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_n_add_slave 0D_NOT_integer
  if (c_associated(n_add_slave)) then
    call c_f_pointer(n_add_slave, f_n_add_slave_ptr)
  else
    f_n_add_slave_ptr => null()
  endif
  ! in: f_n_add_lord 0D_NOT_integer
  if (c_associated(n_add_lord)) then
    call c_f_pointer(n_add_lord, f_n_add_lord_ptr)
  else
    f_n_add_lord_ptr => null()
  endif
  ! in: f_n_add_slave_field 0D_NOT_integer
  if (c_associated(n_add_slave_field)) then
    call c_f_pointer(n_add_slave_field, f_n_add_slave_field_ptr)
  else
    f_n_add_slave_field_ptr => null()
  endif
  ! in: f_n_add_lord_field 0D_NOT_integer
  if (c_associated(n_add_lord_field)) then
    call c_f_pointer(n_add_lord_field, f_n_add_lord_field_ptr)
  else
    f_n_add_lord_field_ptr => null()
  endif
  ! in: f_add_at_end 0D_NOT_logical
  if (c_associated(add_at_end)) then
    call c_f_pointer(add_at_end, f_add_at_end_ptr)
    f_add_at_end_native = f_add_at_end_ptr
    f_add_at_end_native_ptr => f_add_at_end_native
  else
    f_add_at_end_native_ptr => null()
  endif
  call add_lattice_control_structs(ele=f_ele, n_add_slave=f_n_add_slave_ptr, &
      n_add_lord=f_n_add_lord_ptr, n_add_slave_field=f_n_add_slave_field_ptr, &
      n_add_lord_field=f_n_add_lord_field_ptr, add_at_end=f_add_at_end_native_ptr)

end subroutine
subroutine fortran_add_superimpose (lat, super_ele_in, ix_branch, err_flag, super_ele_out, &
    save_null_drift, create_jumbo_slave, ix_insert, mangle_slave_names, wrap) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: super_ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_super_ele_in
  integer(c_int) :: ix_branch  ! 0D_NOT_integer
  integer :: f_ix_branch
  type(c_ptr), intent(in), value :: save_null_drift  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save_null_drift
  logical, target :: f_save_null_drift_native
  logical, pointer :: f_save_null_drift_native_ptr
  logical(c_bool), pointer :: f_save_null_drift_ptr
  type(c_ptr), intent(in), value :: create_jumbo_slave  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_create_jumbo_slave
  logical, target :: f_create_jumbo_slave_native
  logical, pointer :: f_create_jumbo_slave_native_ptr
  logical(c_bool), pointer :: f_create_jumbo_slave_ptr
  type(c_ptr), intent(in), value :: ix_insert  ! 0D_NOT_integer
  integer(c_int) :: f_ix_insert
  integer(c_int), pointer :: f_ix_insert_ptr
  type(c_ptr), intent(in), value :: mangle_slave_names  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_mangle_slave_names
  logical, target :: f_mangle_slave_names_native
  logical, pointer :: f_mangle_slave_names_native_ptr
  logical(c_bool), pointer :: f_mangle_slave_names_ptr
  type(c_ptr), intent(in), value :: wrap  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_wrap
  logical, target :: f_wrap_native
  logical, pointer :: f_wrap_native_ptr
  logical(c_bool), pointer :: f_wrap_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: super_ele_out  ! 0D_PTR_type
  type(ele_struct), pointer :: f_super_ele_out
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_super_ele_in 0D_NOT_type
  if (.not. c_associated(super_ele_in)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(super_ele_in, f_super_ele_in)
  ! in: f_ix_branch 0D_NOT_integer
  f_ix_branch = ix_branch
  ! out: f_super_ele_out 0D_PTR_type
  if (c_associated(super_ele_out))   call c_f_pointer(super_ele_out, f_super_ele_out)
  ! in: f_save_null_drift 0D_NOT_logical
  if (c_associated(save_null_drift)) then
    call c_f_pointer(save_null_drift, f_save_null_drift_ptr)
    f_save_null_drift_native = f_save_null_drift_ptr
    f_save_null_drift_native_ptr => f_save_null_drift_native
  else
    f_save_null_drift_native_ptr => null()
  endif
  ! in: f_create_jumbo_slave 0D_NOT_logical
  if (c_associated(create_jumbo_slave)) then
    call c_f_pointer(create_jumbo_slave, f_create_jumbo_slave_ptr)
    f_create_jumbo_slave_native = f_create_jumbo_slave_ptr
    f_create_jumbo_slave_native_ptr => f_create_jumbo_slave_native
  else
    f_create_jumbo_slave_native_ptr => null()
  endif
  ! in: f_ix_insert 0D_NOT_integer
  if (c_associated(ix_insert)) then
    call c_f_pointer(ix_insert, f_ix_insert_ptr)
  else
    f_ix_insert_ptr => null()
  endif
  ! in: f_mangle_slave_names 0D_NOT_logical
  if (c_associated(mangle_slave_names)) then
    call c_f_pointer(mangle_slave_names, f_mangle_slave_names_ptr)
    f_mangle_slave_names_native = f_mangle_slave_names_ptr
    f_mangle_slave_names_native_ptr => f_mangle_slave_names_native
  else
    f_mangle_slave_names_native_ptr => null()
  endif
  ! in: f_wrap 0D_NOT_logical
  if (c_associated(wrap)) then
    call c_f_pointer(wrap, f_wrap_ptr)
    f_wrap_native = f_wrap_ptr
    f_wrap_native_ptr => f_wrap_native
  else
    f_wrap_native_ptr => null()
  endif
  call add_superimpose(lat=f_lat, super_ele_in=f_super_ele_in, ix_branch=f_ix_branch, &
      err_flag=f_err_flag, super_ele_out=f_super_ele_out, &
      save_null_drift=f_save_null_drift_native_ptr, &
      create_jumbo_slave=f_create_jumbo_slave_native_ptr, ix_insert=f_ix_insert_ptr, &
      mangle_slave_names=f_mangle_slave_names_native_ptr, wrap=f_wrap_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_super_ele_out 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_add_this_multipass (lat, m_slaves, lord_in) bind(c)

  use bmad_struct, only: ele_struct, lat_ele_loc_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: m_slaves
  type(lat_ele_loc_struct_container_alloc), pointer :: f_m_slaves
  type(c_ptr), value :: lord_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord_in
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(m_slaves))   call c_f_pointer(m_slaves, f_m_slaves)
  ! inout: f_lord_in 0D_NOT_type
  if (c_associated(lord_in))   call c_f_pointer(lord_in, f_lord_in)
  call add_this_multipass(lat=f_lat, m_slaves=f_m_slaves%data, lord_in=f_lord_in)

end subroutine
subroutine fortran_add_this_taylor_term (ele, i_out, coef, expn) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: i_out  ! 0D_NOT_integer
  integer(c_int) :: f_i_out
  integer(c_int), pointer :: f_i_out_ptr
  type(c_ptr), intent(in), value :: coef  ! 0D_NOT_real
  real(c_double) :: f_coef
  real(c_double), pointer :: f_coef_ptr
  type(c_ptr), intent(in), value :: expn
  integer :: f_expn(6)
  integer(c_int), pointer :: f_expn_ptr(:)
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_i_out 0D_NOT_integer
  if (c_associated(i_out)) then
    call c_f_pointer(i_out, f_i_out_ptr)
  else
    f_i_out_ptr => null()
  endif
  ! inout: f_coef 0D_NOT_real
  if (c_associated(coef)) then
    call c_f_pointer(coef, f_coef_ptr)
  else
    f_coef_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(expn)) then
    call c_f_pointer(expn, f_expn_ptr, [6])
    f_expn = f_expn_ptr(:)
  else
    f_expn_ptr => null()
  endif
  call add_this_taylor_term(ele=f_ele, i_out=f_i_out_ptr, coef=f_coef_ptr, expn=f_expn)

  ! inout: f_i_out 0D_NOT_integer
  ! no output conversion for f_i_out
  ! inout: f_coef 0D_NOT_real
  ! no output conversion for f_coef
end subroutine
subroutine fortran_adjust_super_slave_names (lat, ix1_lord, ix2_lord, first_time) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix1_lord  ! 0D_NOT_integer
  integer(c_int) :: f_ix1_lord
  integer(c_int), pointer :: f_ix1_lord_ptr
  type(c_ptr), intent(in), value :: ix2_lord  ! 0D_NOT_integer
  integer(c_int) :: f_ix2_lord
  integer(c_int), pointer :: f_ix2_lord_ptr
  type(c_ptr), intent(in), value :: first_time  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_first_time
  logical, target :: f_first_time_native
  logical, pointer :: f_first_time_native_ptr
  logical(c_bool), pointer :: f_first_time_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_ix1_lord 0D_NOT_integer
  if (c_associated(ix1_lord)) then
    call c_f_pointer(ix1_lord, f_ix1_lord_ptr)
  else
    f_ix1_lord_ptr => null()
  endif
  ! inout: f_ix2_lord 0D_NOT_integer
  if (c_associated(ix2_lord)) then
    call c_f_pointer(ix2_lord, f_ix2_lord_ptr)
  else
    f_ix2_lord_ptr => null()
  endif
  ! inout: f_first_time 0D_NOT_logical
  if (c_associated(first_time)) then
    call c_f_pointer(first_time, f_first_time_ptr)
    f_first_time_native = f_first_time_ptr
    f_first_time_native_ptr => f_first_time_native
  else
    f_first_time_native_ptr => null()
  endif
  call adjust_super_slave_names(lat=f_lat, ix1_lord=f_ix1_lord_ptr, ix2_lord=f_ix2_lord_ptr, &
      first_time=f_first_time_native_ptr)

  ! inout: f_ix1_lord 0D_NOT_integer
  ! no output conversion for f_ix1_lord
  ! inout: f_ix2_lord 0D_NOT_integer
  ! no output conversion for f_ix2_lord
  ! inout: f_first_time 0D_NOT_logical
  if (c_associated(first_time)) then
    call c_f_pointer(first_time, f_first_time_ptr)
    f_first_time_ptr = f_first_time_native
  else
    ! f_first_time unset
  endif
end subroutine
subroutine fortran_allocate_branch_array (lat, upper_bound) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: upper_bound  ! 0D_NOT_integer
  integer :: f_upper_bound
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_upper_bound 0D_NOT_integer
  f_upper_bound = upper_bound
  call allocate_branch_array(lat=f_lat, upper_bound=f_upper_bound)

end subroutine
subroutine fortran_allocate_lat_ele_array (lat, upper_bound, ix_branch, do_ramper_slave_setup) &
    bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: upper_bound  ! 0D_NOT_integer
  integer(c_int) :: f_upper_bound
  integer(c_int), pointer :: f_upper_bound_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: do_ramper_slave_setup  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_do_ramper_slave_setup
  logical, target :: f_do_ramper_slave_setup_native
  logical, pointer :: f_do_ramper_slave_setup_native_ptr
  logical(c_bool), pointer :: f_do_ramper_slave_setup_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_upper_bound 0D_NOT_integer
  if (c_associated(upper_bound)) then
    call c_f_pointer(upper_bound, f_upper_bound_ptr)
  else
    f_upper_bound_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_do_ramper_slave_setup 0D_NOT_logical
  if (c_associated(do_ramper_slave_setup)) then
    call c_f_pointer(do_ramper_slave_setup, f_do_ramper_slave_setup_ptr)
    f_do_ramper_slave_setup_native = f_do_ramper_slave_setup_ptr
    f_do_ramper_slave_setup_native_ptr => f_do_ramper_slave_setup_native
  else
    f_do_ramper_slave_setup_native_ptr => null()
  endif
  call allocate_lat_ele_array(lat=f_lat, upper_bound=f_upper_bound_ptr, &
      ix_branch=f_ix_branch_ptr, do_ramper_slave_setup=f_do_ramper_slave_setup_native_ptr)

end subroutine
subroutine fortran_angle_between_polars (polar1, polar2, angle) bind(c)

  use bmad_struct, only: spin_polar_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: polar1  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_polar1
  type(c_ptr), value :: polar2  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_polar2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: angle  ! 0D_NOT_real
  real(rp) :: f_angle
  real(c_double), pointer :: f_angle_ptr
  ! ** End of parameters **
  ! in: f_polar1 0D_NOT_type
  if (.not. c_associated(polar1)) return
  call c_f_pointer(polar1, f_polar1)
  ! in: f_polar2 0D_NOT_type
  if (.not. c_associated(polar2)) return
  call c_f_pointer(polar2, f_polar2)
  f_angle = angle_between_polars(polar1=f_polar1, polar2=f_polar2)

  ! out: f_angle 0D_NOT_real
  call c_f_pointer(angle, f_angle_ptr)
  f_angle_ptr = f_angle
end subroutine
subroutine fortran_angle_to_canonical_coords (orbit, coord_type) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: coord_type
  character(len=4096), target :: f_coord_type
  character(kind=c_char), pointer :: f_coord_type_ptr(:)
  character(len=4096), pointer :: f_coord_type_call_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_coord_type 0D_NOT_character
  if (c_associated(coord_type)) then
    call c_f_pointer(coord_type, f_coord_type_ptr, [huge(0)])
    call to_f_str(f_coord_type_ptr, f_coord_type)
    f_coord_type_call_ptr => f_coord_type
  else
    f_coord_type_call_ptr => null()
  endif
  call angle_to_canonical_coords(orbit=f_orbit, coord_type=f_coord_type_call_ptr)

end subroutine
subroutine fortran_aperture_bookkeeper (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call aperture_bookkeeper(ele=f_ele)

end subroutine
subroutine fortran_apply_all_rampers (lat, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  call apply_all_rampers(lat=f_lat, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_apply_energy_kick (dE, orbit, ddE_dr, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: dE  ! 0D_NOT_real
  real(rp) :: f_dE
  type(c_ptr), intent(in), value :: ddE_dr
  real(rp) :: f_ddE_dr(2)
  real(c_double), pointer :: f_ddE_dr_ptr(:)
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_dE 0D_NOT_real
  f_dE = dE
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (1D_NOT_real)
  if (c_associated(ddE_dr)) then
    call c_f_pointer(ddE_dr, f_ddE_dr_ptr, [2])
    f_ddE_dr = f_ddE_dr_ptr(:)
  else
    f_ddE_dr_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call apply_energy_kick(dE=f_dE, orbit=f_orbit, ddE_dr=f_ddE_dr, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_apply_patch_to_ptc_fibre (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call apply_patch_to_ptc_fibre(ele=f_ele)

end subroutine
subroutine fortran_apply_rampers_to_slave (slave, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(slave, f_slave)
  call apply_rampers_to_slave(slave=f_slave, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_array_re_str (arr, parens_in, str_out) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str_out
  character(len=4096), target :: f_str_out
  character(kind=c_char), pointer :: f_str_out_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: arr
  type(real_container_alloc), pointer :: f_arr
  type(c_ptr), intent(in), value :: parens_in
  character(len=4096), target :: f_parens_in
  character(kind=c_char), pointer :: f_parens_in_ptr(:)
  character(len=4096), pointer :: f_parens_in_call_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(arr))   call c_f_pointer(arr, f_arr)
  ! inout: f_parens_in 0D_NOT_character
  if (c_associated(parens_in)) then
    call c_f_pointer(parens_in, f_parens_in_ptr, [huge(0)])
    call to_f_str(f_parens_in_ptr, f_parens_in)
    f_parens_in_call_ptr => f_parens_in
  else
    f_parens_in_call_ptr => null()
  endif
  f_str_out = array_re_str(arr=f_arr%data, parens_in=f_parens_in_call_ptr)

  ! inout: f_parens_in 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! out: f_str_out 0D_NOT_character
  call c_f_pointer(str_out, f_str_out_ptr, [len_trim(f_str_out) + 1]) ! output-only string
  call to_c_str(f_str_out, f_str_out_ptr)
end subroutine
subroutine fortran_astra_max_field_reference (pt0, ele, field_value) bind(c)

  use bmad_struct, only: ele_struct, grid_field_pt1_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: field_value  ! 0D_NOT_real
  real(rp) :: f_field_value
  real(c_double), pointer :: f_field_value_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: pt0  ! 0D_NOT_type
  type(grid_field_pt1_struct), pointer :: f_pt0
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_pt0 0D_NOT_type
  if (.not. c_associated(pt0)) return
  call c_f_pointer(pt0, f_pt0)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_field_value = astra_max_field_reference(pt0=f_pt0, ele=f_ele)

  ! out: f_field_value 0D_NOT_real
  call c_f_pointer(field_value, f_field_value_ptr)
  f_field_value_ptr = f_field_value
end subroutine
subroutine fortran_at_this_ele_end (now_at, where_at, is_at_this_end) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: now_at  ! 0D_NOT_integer
  integer :: f_now_at
  integer(c_int) :: where_at  ! 0D_NOT_integer
  integer :: f_where_at
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_at_this_end  ! 0D_NOT_logical
  logical :: f_is_at_this_end
  logical(c_bool), pointer :: f_is_at_this_end_ptr
  ! ** End of parameters **
  ! in: f_now_at 0D_NOT_integer
  f_now_at = now_at
  ! in: f_where_at 0D_NOT_integer
  f_where_at = where_at
  f_is_at_this_end = at_this_ele_end(now_at=f_now_at, where_at=f_where_at)

  ! out: f_is_at_this_end 0D_NOT_logical
  call c_f_pointer(is_at_this_end, f_is_at_this_end_ptr)
  f_is_at_this_end_ptr = f_is_at_this_end
end subroutine
subroutine fortran_attribute_bookkeeper (ele, force_bookkeeping) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: force_bookkeeping  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_force_bookkeeping
  logical, target :: f_force_bookkeeping_native
  logical, pointer :: f_force_bookkeeping_native_ptr
  logical(c_bool), pointer :: f_force_bookkeeping_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_force_bookkeeping 0D_NOT_logical
  if (c_associated(force_bookkeeping)) then
    call c_f_pointer(force_bookkeeping, f_force_bookkeeping_ptr)
    f_force_bookkeeping_native = f_force_bookkeeping_ptr
    f_force_bookkeeping_native_ptr => f_force_bookkeeping_native
  else
    f_force_bookkeeping_native_ptr => null()
  endif
  call attribute_bookkeeper(ele=f_ele, force_bookkeeping=f_force_bookkeeping_native_ptr)

end subroutine
subroutine fortran_attribute_free1 (ix_ele, attrib_name, lat, err_print_flag, except_overlay, &
    dependent_attribs_free, why_not_free, free) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: free  ! 0D_NOT_logical
  logical :: f_free
  logical(c_bool), pointer :: f_free_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ix_ele  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele
  integer(c_int), pointer :: f_ix_ele_ptr
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_print_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_print_flag
  logical, target :: f_err_print_flag_native
  logical, pointer :: f_err_print_flag_native_ptr
  logical(c_bool), pointer :: f_err_print_flag_ptr
  type(c_ptr), intent(in), value :: except_overlay  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_except_overlay
  logical, target :: f_except_overlay_native
  logical, pointer :: f_except_overlay_native_ptr
  logical(c_bool), pointer :: f_except_overlay_ptr
  type(c_ptr), intent(in), value :: dependent_attribs_free  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_dependent_attribs_free
  logical, target :: f_dependent_attribs_free_native
  logical, pointer :: f_dependent_attribs_free_native_ptr
  logical(c_bool), pointer :: f_dependent_attribs_free_ptr
  type(c_ptr), intent(in), value :: why_not_free  ! 0D_NOT_integer
  integer(c_int) :: f_why_not_free
  integer(c_int), pointer :: f_why_not_free_ptr
  ! ** End of parameters **
  ! inout: f_ix_ele 0D_NOT_integer
  if (c_associated(ix_ele)) then
    call c_f_pointer(ix_ele, f_ix_ele_ptr)
  else
    f_ix_ele_ptr => null()
  endif
  ! inout: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_native = f_err_print_flag_ptr
    f_err_print_flag_native_ptr => f_err_print_flag_native
  else
    f_err_print_flag_native_ptr => null()
  endif
  ! inout: f_except_overlay 0D_NOT_logical
  if (c_associated(except_overlay)) then
    call c_f_pointer(except_overlay, f_except_overlay_ptr)
    f_except_overlay_native = f_except_overlay_ptr
    f_except_overlay_native_ptr => f_except_overlay_native
  else
    f_except_overlay_native_ptr => null()
  endif
  ! inout: f_dependent_attribs_free 0D_NOT_logical
  if (c_associated(dependent_attribs_free)) then
    call c_f_pointer(dependent_attribs_free, f_dependent_attribs_free_ptr)
    f_dependent_attribs_free_native = f_dependent_attribs_free_ptr
    f_dependent_attribs_free_native_ptr => f_dependent_attribs_free_native
  else
    f_dependent_attribs_free_native_ptr => null()
  endif
  ! inout: f_why_not_free 0D_NOT_integer
  if (c_associated(why_not_free)) then
    call c_f_pointer(why_not_free, f_why_not_free_ptr)
  else
    f_why_not_free_ptr => null()
  endif
  f_free = attribute_free1(ix_ele=f_ix_ele_ptr, attrib_name=f_attrib_name, lat=f_lat, &
      err_print_flag=f_err_print_flag_native_ptr, except_overlay=f_except_overlay_native_ptr, &
      dependent_attribs_free=f_dependent_attribs_free_native_ptr, &
      why_not_free=f_why_not_free_ptr)

  ! inout: f_ix_ele 0D_NOT_integer
  ! no output conversion for f_ix_ele
  ! inout: f_attrib_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_ptr = f_err_print_flag_native
  else
    ! f_err_print_flag unset
  endif
  ! inout: f_except_overlay 0D_NOT_logical
  if (c_associated(except_overlay)) then
    call c_f_pointer(except_overlay, f_except_overlay_ptr)
    f_except_overlay_ptr = f_except_overlay_native
  else
    ! f_except_overlay unset
  endif
  ! inout: f_dependent_attribs_free 0D_NOT_logical
  if (c_associated(dependent_attribs_free)) then
    call c_f_pointer(dependent_attribs_free, f_dependent_attribs_free_ptr)
    f_dependent_attribs_free_ptr = f_dependent_attribs_free_native
  else
    ! f_dependent_attribs_free unset
  endif
  ! inout: f_why_not_free 0D_NOT_integer
  ! no output conversion for f_why_not_free
  ! out: f_free 0D_NOT_logical
  call c_f_pointer(free, f_free_ptr)
  f_free_ptr = f_free
end subroutine
subroutine fortran_attribute_free2 (ele, attrib_name, err_print_flag, except_overlay, &
    dependent_attribs_free, why_not_free, free) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: free  ! 0D_NOT_logical
  logical :: f_free
  logical(c_bool), pointer :: f_free_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), intent(in), value :: err_print_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_print_flag
  logical, target :: f_err_print_flag_native
  logical, pointer :: f_err_print_flag_native_ptr
  logical(c_bool), pointer :: f_err_print_flag_ptr
  type(c_ptr), intent(in), value :: except_overlay  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_except_overlay
  logical, target :: f_except_overlay_native
  logical, pointer :: f_except_overlay_native_ptr
  logical(c_bool), pointer :: f_except_overlay_ptr
  type(c_ptr), intent(in), value :: dependent_attribs_free  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_dependent_attribs_free
  logical, target :: f_dependent_attribs_free_native
  logical, pointer :: f_dependent_attribs_free_native_ptr
  logical(c_bool), pointer :: f_dependent_attribs_free_ptr
  type(c_ptr), intent(in), value :: why_not_free  ! 0D_NOT_integer
  integer(c_int) :: f_why_not_free
  integer(c_int), pointer :: f_why_not_free_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! inout: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_native = f_err_print_flag_ptr
    f_err_print_flag_native_ptr => f_err_print_flag_native
  else
    f_err_print_flag_native_ptr => null()
  endif
  ! inout: f_except_overlay 0D_NOT_logical
  if (c_associated(except_overlay)) then
    call c_f_pointer(except_overlay, f_except_overlay_ptr)
    f_except_overlay_native = f_except_overlay_ptr
    f_except_overlay_native_ptr => f_except_overlay_native
  else
    f_except_overlay_native_ptr => null()
  endif
  ! inout: f_dependent_attribs_free 0D_NOT_logical
  if (c_associated(dependent_attribs_free)) then
    call c_f_pointer(dependent_attribs_free, f_dependent_attribs_free_ptr)
    f_dependent_attribs_free_native = f_dependent_attribs_free_ptr
    f_dependent_attribs_free_native_ptr => f_dependent_attribs_free_native
  else
    f_dependent_attribs_free_native_ptr => null()
  endif
  ! inout: f_why_not_free 0D_NOT_integer
  if (c_associated(why_not_free)) then
    call c_f_pointer(why_not_free, f_why_not_free_ptr)
  else
    f_why_not_free_ptr => null()
  endif
  f_free = attribute_free2(ele=f_ele, attrib_name=f_attrib_name, &
      err_print_flag=f_err_print_flag_native_ptr, except_overlay=f_except_overlay_native_ptr, &
      dependent_attribs_free=f_dependent_attribs_free_native_ptr, &
      why_not_free=f_why_not_free_ptr)

  ! inout: f_attrib_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_ptr = f_err_print_flag_native
  else
    ! f_err_print_flag unset
  endif
  ! inout: f_except_overlay 0D_NOT_logical
  if (c_associated(except_overlay)) then
    call c_f_pointer(except_overlay, f_except_overlay_ptr)
    f_except_overlay_ptr = f_except_overlay_native
  else
    ! f_except_overlay unset
  endif
  ! inout: f_dependent_attribs_free 0D_NOT_logical
  if (c_associated(dependent_attribs_free)) then
    call c_f_pointer(dependent_attribs_free, f_dependent_attribs_free_ptr)
    f_dependent_attribs_free_ptr = f_dependent_attribs_free_native
  else
    ! f_dependent_attribs_free unset
  endif
  ! inout: f_why_not_free 0D_NOT_integer
  ! no output conversion for f_why_not_free
  ! out: f_free 0D_NOT_logical
  call c_f_pointer(free, f_free_ptr)
  f_free_ptr = f_free
end subroutine
subroutine fortran_attribute_free3 (ix_ele, ix_branch, attrib_name, lat, err_print_flag, &
    except_overlay, dependent_attribs_free, why_not_free, free) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: free  ! 0D_NOT_logical
  logical :: f_free
  logical(c_bool), pointer :: f_free_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ix_ele  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele
  integer(c_int), pointer :: f_ix_ele_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_print_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_print_flag
  logical, target :: f_err_print_flag_native
  logical, pointer :: f_err_print_flag_native_ptr
  logical(c_bool), pointer :: f_err_print_flag_ptr
  type(c_ptr), intent(in), value :: except_overlay  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_except_overlay
  logical, target :: f_except_overlay_native
  logical, pointer :: f_except_overlay_native_ptr
  logical(c_bool), pointer :: f_except_overlay_ptr
  type(c_ptr), intent(in), value :: dependent_attribs_free  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_dependent_attribs_free
  logical, target :: f_dependent_attribs_free_native
  logical, pointer :: f_dependent_attribs_free_native_ptr
  logical(c_bool), pointer :: f_dependent_attribs_free_ptr
  type(c_ptr), intent(in), value :: why_not_free  ! 0D_NOT_integer
  integer(c_int) :: f_why_not_free
  integer(c_int), pointer :: f_why_not_free_ptr
  ! ** End of parameters **
  ! inout: f_ix_ele 0D_NOT_integer
  if (c_associated(ix_ele)) then
    call c_f_pointer(ix_ele, f_ix_ele_ptr)
  else
    f_ix_ele_ptr => null()
  endif
  ! inout: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! inout: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_native = f_err_print_flag_ptr
    f_err_print_flag_native_ptr => f_err_print_flag_native
  else
    f_err_print_flag_native_ptr => null()
  endif
  ! inout: f_except_overlay 0D_NOT_logical
  if (c_associated(except_overlay)) then
    call c_f_pointer(except_overlay, f_except_overlay_ptr)
    f_except_overlay_native = f_except_overlay_ptr
    f_except_overlay_native_ptr => f_except_overlay_native
  else
    f_except_overlay_native_ptr => null()
  endif
  ! inout: f_dependent_attribs_free 0D_NOT_logical
  if (c_associated(dependent_attribs_free)) then
    call c_f_pointer(dependent_attribs_free, f_dependent_attribs_free_ptr)
    f_dependent_attribs_free_native = f_dependent_attribs_free_ptr
    f_dependent_attribs_free_native_ptr => f_dependent_attribs_free_native
  else
    f_dependent_attribs_free_native_ptr => null()
  endif
  ! inout: f_why_not_free 0D_NOT_integer
  if (c_associated(why_not_free)) then
    call c_f_pointer(why_not_free, f_why_not_free_ptr)
  else
    f_why_not_free_ptr => null()
  endif
  f_free = attribute_free3(ix_ele=f_ix_ele_ptr, ix_branch=f_ix_branch_ptr, &
      attrib_name=f_attrib_name, lat=f_lat, err_print_flag=f_err_print_flag_native_ptr, &
      except_overlay=f_except_overlay_native_ptr, &
      dependent_attribs_free=f_dependent_attribs_free_native_ptr, &
      why_not_free=f_why_not_free_ptr)

  ! inout: f_ix_ele 0D_NOT_integer
  ! no output conversion for f_ix_ele
  ! inout: f_ix_branch 0D_NOT_integer
  ! no output conversion for f_ix_branch
  ! inout: f_attrib_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_ptr = f_err_print_flag_native
  else
    ! f_err_print_flag unset
  endif
  ! inout: f_except_overlay 0D_NOT_logical
  if (c_associated(except_overlay)) then
    call c_f_pointer(except_overlay, f_except_overlay_ptr)
    f_except_overlay_ptr = f_except_overlay_native
  else
    ! f_except_overlay unset
  endif
  ! inout: f_dependent_attribs_free 0D_NOT_logical
  if (c_associated(dependent_attribs_free)) then
    call c_f_pointer(dependent_attribs_free, f_dependent_attribs_free_ptr)
    f_dependent_attribs_free_ptr = f_dependent_attribs_free_native
  else
    ! f_dependent_attribs_free unset
  endif
  ! inout: f_why_not_free 0D_NOT_integer
  ! no output conversion for f_why_not_free
  ! out: f_free 0D_NOT_logical
  call c_f_pointer(free, f_free_ptr)
  f_free_ptr = f_free
end subroutine
subroutine fortran_attribute_index1 (ele, name, full_name, can_abbreviate, print_error, &
    attrib_index) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_index  ! 0D_NOT_integer
  integer :: f_attrib_index
  integer(c_int), pointer :: f_attrib_index_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  type(c_ptr), intent(in), value :: full_name
  character(len=4096), target :: f_full_name
  character(kind=c_char), pointer :: f_full_name_ptr(:)
  character(len=4096), pointer :: f_full_name_call_ptr
  type(c_ptr), intent(in), value :: can_abbreviate  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_can_abbreviate
  logical, target :: f_can_abbreviate_native
  logical, pointer :: f_can_abbreviate_native_ptr
  logical(c_bool), pointer :: f_can_abbreviate_ptr
  type(c_ptr), intent(in), value :: print_error  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_error
  logical, target :: f_print_error_native
  logical, pointer :: f_print_error_native_ptr
  logical(c_bool), pointer :: f_print_error_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  ! inout: f_full_name 0D_NOT_character
  if (c_associated(full_name)) then
    call c_f_pointer(full_name, f_full_name_ptr, [huge(0)])
    call to_f_str(f_full_name_ptr, f_full_name)
    f_full_name_call_ptr => f_full_name
  else
    f_full_name_call_ptr => null()
  endif
  ! inout: f_can_abbreviate 0D_NOT_logical
  if (c_associated(can_abbreviate)) then
    call c_f_pointer(can_abbreviate, f_can_abbreviate_ptr)
    f_can_abbreviate_native = f_can_abbreviate_ptr
    f_can_abbreviate_native_ptr => f_can_abbreviate_native
  else
    f_can_abbreviate_native_ptr => null()
  endif
  ! inout: f_print_error 0D_NOT_logical
  if (c_associated(print_error)) then
    call c_f_pointer(print_error, f_print_error_ptr)
    f_print_error_native = f_print_error_ptr
    f_print_error_native_ptr => f_print_error_native
  else
    f_print_error_native_ptr => null()
  endif
  f_attrib_index = attribute_index1(ele=f_ele, name=f_name, full_name=f_full_name_call_ptr, &
      can_abbreviate=f_can_abbreviate_native_ptr, print_error=f_print_error_native_ptr)

  ! inout: f_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_full_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_can_abbreviate 0D_NOT_logical
  if (c_associated(can_abbreviate)) then
    call c_f_pointer(can_abbreviate, f_can_abbreviate_ptr)
    f_can_abbreviate_ptr = f_can_abbreviate_native
  else
    ! f_can_abbreviate unset
  endif
  ! inout: f_print_error 0D_NOT_logical
  if (c_associated(print_error)) then
    call c_f_pointer(print_error, f_print_error_ptr)
    f_print_error_ptr = f_print_error_native
  else
    ! f_print_error unset
  endif
  ! out: f_attrib_index 0D_NOT_integer
  call c_f_pointer(attrib_index, f_attrib_index_ptr)
  f_attrib_index_ptr = f_attrib_index
end subroutine
subroutine fortran_attribute_index2 (key, name, full_name, can_abbreviate, print_error, &
    attrib_index) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_index  ! 0D_NOT_integer
  integer :: f_attrib_index
  integer(c_int), pointer :: f_attrib_index_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: key  ! 0D_NOT_integer
  integer(c_int) :: f_key
  integer(c_int), pointer :: f_key_ptr
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  type(c_ptr), intent(in), value :: full_name
  character(len=4096), target :: f_full_name
  character(kind=c_char), pointer :: f_full_name_ptr(:)
  character(len=4096), pointer :: f_full_name_call_ptr
  type(c_ptr), intent(in), value :: can_abbreviate  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_can_abbreviate
  logical, target :: f_can_abbreviate_native
  logical, pointer :: f_can_abbreviate_native_ptr
  logical(c_bool), pointer :: f_can_abbreviate_ptr
  type(c_ptr), intent(in), value :: print_error  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_error
  logical, target :: f_print_error_native
  logical, pointer :: f_print_error_native_ptr
  logical(c_bool), pointer :: f_print_error_ptr
  ! ** End of parameters **
  ! inout: f_key 0D_NOT_integer
  if (c_associated(key)) then
    call c_f_pointer(key, f_key_ptr)
  else
    f_key_ptr => null()
  endif
  ! inout: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  ! inout: f_full_name 0D_NOT_character
  if (c_associated(full_name)) then
    call c_f_pointer(full_name, f_full_name_ptr, [huge(0)])
    call to_f_str(f_full_name_ptr, f_full_name)
    f_full_name_call_ptr => f_full_name
  else
    f_full_name_call_ptr => null()
  endif
  ! inout: f_can_abbreviate 0D_NOT_logical
  if (c_associated(can_abbreviate)) then
    call c_f_pointer(can_abbreviate, f_can_abbreviate_ptr)
    f_can_abbreviate_native = f_can_abbreviate_ptr
    f_can_abbreviate_native_ptr => f_can_abbreviate_native
  else
    f_can_abbreviate_native_ptr => null()
  endif
  ! inout: f_print_error 0D_NOT_logical
  if (c_associated(print_error)) then
    call c_f_pointer(print_error, f_print_error_ptr)
    f_print_error_native = f_print_error_ptr
    f_print_error_native_ptr => f_print_error_native
  else
    f_print_error_native_ptr => null()
  endif
  f_attrib_index = attribute_index2(key=f_key_ptr, name=f_name, full_name=f_full_name_call_ptr, &
      can_abbreviate=f_can_abbreviate_native_ptr, print_error=f_print_error_native_ptr)

  ! inout: f_key 0D_NOT_integer
  ! no output conversion for f_key
  ! inout: f_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_full_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_can_abbreviate 0D_NOT_logical
  if (c_associated(can_abbreviate)) then
    call c_f_pointer(can_abbreviate, f_can_abbreviate_ptr)
    f_can_abbreviate_ptr = f_can_abbreviate_native
  else
    ! f_can_abbreviate unset
  endif
  ! inout: f_print_error 0D_NOT_logical
  if (c_associated(print_error)) then
    call c_f_pointer(print_error, f_print_error_ptr)
    f_print_error_ptr = f_print_error_native
  else
    ! f_print_error unset
  endif
  ! out: f_attrib_index 0D_NOT_integer
  call c_f_pointer(attrib_index, f_attrib_index_ptr)
  f_attrib_index_ptr = f_attrib_index
end subroutine
subroutine fortran_attribute_name1 (key, ix_att, show_private, attrib_name) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: key  ! 0D_NOT_integer
  integer(c_int) :: f_key
  integer(c_int), pointer :: f_key_ptr
  type(c_ptr), intent(in), value :: ix_att  ! 0D_NOT_integer
  integer(c_int) :: f_ix_att
  integer(c_int), pointer :: f_ix_att_ptr
  type(c_ptr), intent(in), value :: show_private  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_show_private
  logical, target :: f_show_private_native
  logical, pointer :: f_show_private_native_ptr
  logical(c_bool), pointer :: f_show_private_ptr
  ! ** End of parameters **
  ! inout: f_key 0D_NOT_integer
  if (c_associated(key)) then
    call c_f_pointer(key, f_key_ptr)
  else
    f_key_ptr => null()
  endif
  ! inout: f_ix_att 0D_NOT_integer
  if (c_associated(ix_att)) then
    call c_f_pointer(ix_att, f_ix_att_ptr)
  else
    f_ix_att_ptr => null()
  endif
  ! inout: f_show_private 0D_NOT_logical
  if (c_associated(show_private)) then
    call c_f_pointer(show_private, f_show_private_ptr)
    f_show_private_native = f_show_private_ptr
    f_show_private_native_ptr => f_show_private_native
  else
    f_show_private_native_ptr => null()
  endif
  f_attrib_name = attribute_name1(key=f_key_ptr, ix_att=f_ix_att_ptr, &
      show_private=f_show_private_native_ptr)

  ! inout: f_key 0D_NOT_integer
  ! no output conversion for f_key
  ! inout: f_ix_att 0D_NOT_integer
  ! no output conversion for f_ix_att
  ! inout: f_show_private 0D_NOT_logical
  if (c_associated(show_private)) then
    call c_f_pointer(show_private, f_show_private_ptr)
    f_show_private_ptr = f_show_private_native
  else
    ! f_show_private unset
  endif
  ! out: f_attrib_name 0D_NOT_character
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [len_trim(f_attrib_name) + 1]) ! output-only string
  call to_c_str(f_attrib_name, f_attrib_name_ptr)
end subroutine
subroutine fortran_attribute_name2 (ele, ix_att, show_private, attrib_name) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: ix_att  ! 0D_NOT_integer
  integer(c_int) :: f_ix_att
  integer(c_int), pointer :: f_ix_att_ptr
  type(c_ptr), intent(in), value :: show_private  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_show_private
  logical, target :: f_show_private_native
  logical, pointer :: f_show_private_native_ptr
  logical(c_bool), pointer :: f_show_private_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_ix_att 0D_NOT_integer
  if (c_associated(ix_att)) then
    call c_f_pointer(ix_att, f_ix_att_ptr)
  else
    f_ix_att_ptr => null()
  endif
  ! inout: f_show_private 0D_NOT_logical
  if (c_associated(show_private)) then
    call c_f_pointer(show_private, f_show_private_ptr)
    f_show_private_native = f_show_private_ptr
    f_show_private_native_ptr => f_show_private_native
  else
    f_show_private_native_ptr => null()
  endif
  f_attrib_name = attribute_name2(ele=f_ele, ix_att=f_ix_att_ptr, &
      show_private=f_show_private_native_ptr)

  ! inout: f_ix_att 0D_NOT_integer
  ! no output conversion for f_ix_att
  ! inout: f_show_private 0D_NOT_logical
  if (c_associated(show_private)) then
    call c_f_pointer(show_private, f_show_private_ptr)
    f_show_private_ptr = f_show_private_native
  else
    ! f_show_private unset
  endif
  ! out: f_attrib_name 0D_NOT_character
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [len_trim(f_attrib_name) + 1]) ! output-only string
  call to_c_str(f_attrib_name, f_attrib_name_ptr)
end subroutine
subroutine fortran_attribute_type (attrib_name, ele, attrib_type) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_type  ! 0D_NOT_integer
  integer :: f_attrib_type
  integer(c_int), pointer :: f_attrib_type_ptr
  ! ** End of parameters **
  ! in: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  f_attrib_type = attribute_type(attrib_name=f_attrib_name, ele=f_ele)

  ! out: f_attrib_type 0D_NOT_integer
  call c_f_pointer(attrib_type, f_attrib_type_ptr)
  f_attrib_type_ptr = f_attrib_type
end subroutine
subroutine fortran_attribute_units (attrib_name, unrecognized_units, attrib_units) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), intent(in), value :: unrecognized_units
  character(len=4096), target :: f_unrecognized_units
  character(kind=c_char), pointer :: f_unrecognized_units_ptr(:)
  character(len=4096), pointer :: f_unrecognized_units_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_units
  character(len=4096), target :: f_attrib_units
  character(kind=c_char), pointer :: f_attrib_units_ptr(:)
  ! ** End of parameters **
  ! in: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! in: f_unrecognized_units 0D_NOT_character
  if (c_associated(unrecognized_units)) then
    call c_f_pointer(unrecognized_units, f_unrecognized_units_ptr, [huge(0)])
    call to_f_str(f_unrecognized_units_ptr, f_unrecognized_units)
    f_unrecognized_units_call_ptr => f_unrecognized_units
  else
    f_unrecognized_units_call_ptr => null()
  endif
  f_attrib_units = attribute_units(attrib_name=f_attrib_name, &
      unrecognized_units=f_unrecognized_units_call_ptr)

  ! out: f_attrib_units 0D_NOT_character
  call c_f_pointer(attrib_units, f_attrib_units_ptr, [len_trim(f_attrib_units) + 1]) ! output-only string
  call to_c_str(f_attrib_units, f_attrib_units_ptr)
end subroutine
subroutine fortran_attributes_need_bookkeeping (ele, dval) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dval
  type(real_container_alloc), pointer :: f_dval
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container general array (1D_ALLOC_real)
  if (c_associated(dval))   call c_f_pointer(dval, f_dval)
  call attributes_need_bookkeeping(ele=f_ele, dval=f_dval%data)

end subroutine
subroutine fortran_autoscale_phase_and_amp (ele, param, err_flag, scale_phase, scale_amp, &
    call_bookkeeper) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: scale_phase  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_scale_phase
  logical, target :: f_scale_phase_native
  logical, pointer :: f_scale_phase_native_ptr
  logical(c_bool), pointer :: f_scale_phase_ptr
  type(c_ptr), intent(in), value :: scale_amp  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_scale_amp
  logical, target :: f_scale_amp_native
  logical, pointer :: f_scale_amp_native_ptr
  logical(c_bool), pointer :: f_scale_amp_ptr
  type(c_ptr), intent(in), value :: call_bookkeeper  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_call_bookkeeper
  logical, target :: f_call_bookkeeper_native
  logical, pointer :: f_call_bookkeeper_native_ptr
  logical(c_bool), pointer :: f_call_bookkeeper_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_scale_phase 0D_NOT_logical
  if (c_associated(scale_phase)) then
    call c_f_pointer(scale_phase, f_scale_phase_ptr)
    f_scale_phase_native = f_scale_phase_ptr
    f_scale_phase_native_ptr => f_scale_phase_native
  else
    f_scale_phase_native_ptr => null()
  endif
  ! in: f_scale_amp 0D_NOT_logical
  if (c_associated(scale_amp)) then
    call c_f_pointer(scale_amp, f_scale_amp_ptr)
    f_scale_amp_native = f_scale_amp_ptr
    f_scale_amp_native_ptr => f_scale_amp_native
  else
    f_scale_amp_native_ptr => null()
  endif
  ! in: f_call_bookkeeper 0D_NOT_logical
  if (c_associated(call_bookkeeper)) then
    call c_f_pointer(call_bookkeeper, f_call_bookkeeper_ptr)
    f_call_bookkeeper_native = f_call_bookkeeper_ptr
    f_call_bookkeeper_native_ptr => f_call_bookkeeper_native
  else
    f_call_bookkeeper_native_ptr => null()
  endif
  call autoscale_phase_and_amp(ele=f_ele, param=f_param, err_flag=f_err_flag, &
      scale_phase=f_scale_phase_native_ptr, scale_amp=f_scale_amp_native_ptr, &
      call_bookkeeper=f_call_bookkeeper_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_average_twiss (frac1, twiss1, twiss2, ave_twiss) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: frac1  ! 0D_NOT_real
  real(rp) :: f_frac1
  type(c_ptr), value :: twiss1  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss1
  ! ** Out parameters **
  type(c_ptr), value :: ave_twiss  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_ave_twiss
  ! ** Inout parameters **
  type(c_ptr), value :: twiss2  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss2
  ! ** End of parameters **
  ! in: f_frac1 0D_NOT_real
  f_frac1 = frac1
  ! in: f_twiss1 0D_NOT_type
  if (.not. c_associated(twiss1)) return
  call c_f_pointer(twiss1, f_twiss1)
  ! inout: f_twiss2 0D_NOT_type
  if (.not. c_associated(twiss2)) return
  call c_f_pointer(twiss2, f_twiss2)
  f_ave_twiss = average_twiss(frac1=f_frac1, twiss1=f_twiss1, twiss2=f_twiss2)

  ! out: f_ave_twiss 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_bbi_kick (x, y, sigma, nk, dnk) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: x  ! 0D_NOT_real
  real(rp) :: f_x
  real(c_double) :: y  ! 0D_NOT_real
  real(rp) :: f_y
  type(c_ptr), intent(in), value :: sigma
  real(rp) :: f_sigma(2)
  real(c_double), pointer :: f_sigma_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: nk
  real(rp) :: f_nk(2)
  real(c_double), pointer :: f_nk_ptr(:)
  type(c_ptr), intent(in), value :: dnk
  real(rp) :: f_dnk(2,2)
  real(c_double), pointer :: f_dnk_ptr(:)
  ! ** End of parameters **
  ! in: f_x 0D_NOT_real
  f_x = x
  ! in: f_y 0D_NOT_real
  f_y = y
  !! general array (1D_NOT_real)
  if (c_associated(sigma)) then
    call c_f_pointer(sigma, f_sigma_ptr, [2])
    f_sigma = f_sigma_ptr(:)
  else
    f_sigma_ptr => null()
  endif
  call bbi_kick(x=f_x, y=f_y, sigma=f_sigma, nk=f_nk, dnk=f_dnk)

  ! out: f_nk 1D_NOT_real
  if (c_associated(nk)) then
    call c_f_pointer(nk, f_nk_ptr, [2])
    f_nk_ptr = f_nk(:)
  endif
  ! out: f_dnk 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_dnk', c_name='dnk', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=522, definition='real(rp) x, y, sigma(2), nk(2), dnk(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='dnk', comment='', default=None), intent='out', description='derivatives of nk. EG: dnk(2,1) = dnk(2)/dy Note: xi_x = beta_x * bbi_const / sig_x     ! Horizontal tune shift parameter xi_y = beta_y * bbi_const / sig_y     ! Vertical   tune shift parameter where bbi_const = N_particles_bunch * r_e / (2 * pi * gamma * (sig_x + sig_y)) And the tune shifts are: dQ_x = xi_x = beta_x * bbi_const / sig_x dQ_y = xi_y = beta_y * bbi_const / sig_y In the calling routine, the formulas for computing the actual kicks, kick_x and kick_y, should be: kick_x = bbi_const * nk(1) ~ -4 * pi * bbi_const * x / sigma_x                        [linear region] ~ -2 * N_p * r_e * x / (gamma * sig_x * (sig_x + sig_y))   [linear region] ~ -2 * N_p * r_e * x / (gamma * (x^2 + y^2))               [far from beam] kick_y = bbi_const * nk(2) ~ -4 * pi * bbi_const * y / sigma_y                        [linear region] ~ -2 * N_p * r_e * y / (gamma * sig_y * (sig_x + sig_y))   [linear region] ~ -2 * N_p * r_e * y / (gamma * (x^2 + y^2))               [far from beam] For the beam-ion kick, assuming the ion velocity is neglegeble, the formulas are: kick_x = ion_const * nk(1) ~ -4 * pi * ion_const * x / sigma_x                             [linear region] ~ -2 * N_p * r_p * c_light * x / (sig_x * (sig_x + sig_y) * A)  [linear region] ~ -2 * N_p * r_p * c_light * x / ((x^2 + y^2) * A)              [far from beam] kick_y = ion_const * nk(2) ~ -4 * pi * ion_const * y / sigma_y                             [linear region] ~ -2 * N_p * r_p * c_light * y / (sig_y * (sig_x + sig_y) * A)  [linear region] ~ -2 * N_p * r_p * c_light * y / ((x^2 + y^2) * A)              [far from beam] ion_const = N_particles_bunch * r_p * c_light / (2 * pi * (sig_x + sig_y) * A) A = Mass of ion in AMU.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_bbi_slice_calc (ele, n_slice, z_slice) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: n_slice  ! 0D_NOT_integer
  integer :: f_n_slice
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: z_slice
  type(real_container_alloc), pointer :: f_z_slice
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_n_slice 0D_NOT_integer
  f_n_slice = n_slice
  !! container general array (1D_ALLOC_real)
  if (c_associated(z_slice))   call c_f_pointer(z_slice, f_z_slice)
  call bbi_slice_calc(ele=f_ele, n_slice=f_n_slice, z_slice=f_z_slice%data)

end subroutine
subroutine fortran_beam_envelope_ibs (sigma_mat, ibs_mat, tail_cut, tau, energy, n_part, &
    species) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  logical(c_bool) :: tail_cut  ! 0D_NOT_logical
  logical :: f_tail_cut
  real(c_double) :: tau  ! 0D_NOT_real
  real(rp) :: f_tau
  real(c_double) :: energy  ! 0D_NOT_real
  real(rp) :: f_energy
  real(c_double) :: n_part  ! 0D_NOT_real
  real(rp) :: f_n_part
  integer(c_int) :: species  ! 0D_NOT_integer
  integer :: f_species
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ibs_mat
  real(rp) :: f_ibs_mat(6,6)
  real(c_double), pointer :: f_ibs_mat_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat)) then
    call c_f_pointer(sigma_mat, f_sigma_mat_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptr, f_sigma_mat)
  else
    f_sigma_mat_ptr => null()
  endif
  ! in: f_tail_cut 0D_NOT_logical
  f_tail_cut = tail_cut
  ! in: f_tau 0D_NOT_real
  f_tau = tau
  ! in: f_energy 0D_NOT_real
  f_energy = energy
  ! in: f_n_part 0D_NOT_real
  f_n_part = n_part
  ! in: f_species 0D_NOT_integer
  f_species = species
  call beam_envelope_ibs(sigma_mat=f_sigma_mat, ibs_mat=f_ibs_mat, tail_cut=f_tail_cut, &
      tau=f_tau, energy=f_energy, n_part=f_n_part, species=f_species)

  ! out: f_ibs_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_ibs_mat', c_name='ibs_mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=783, definition='real(rp) sigma_mat(6,6), ibs_mat(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='ibs_mat', comment='', default=None), intent='out', description='changes in 2nd order moments due to IBS are ibs_mat*element_length', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_beam_equal_beam (beam1, beam2) bind(c)

  use bmad_struct, only: beam_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: beam1  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam1
  type(c_ptr), value :: beam2  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam2
  ! ** End of parameters **
  ! in: f_beam1 0D_NOT_type
  if (.not. c_associated(beam1)) return
  call c_f_pointer(beam1, f_beam1)
  ! in: f_beam2 0D_NOT_type
  if (.not. c_associated(beam2)) return
  call c_f_pointer(beam2, f_beam2)
  call beam_equal_beam(beam1=f_beam1, beam2=f_beam2)

end subroutine
subroutine fortran_beam_tilts (S, angle_xy, angle_xz, angle_yz, angle_xpz, angle_ypz) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: S
  real(rp) :: f_S(6,6)
  real(c_double), pointer :: f_S_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: angle_xy  ! 0D_NOT_real
  real(rp) :: f_angle_xy
  real(c_double), pointer :: f_angle_xy_ptr
  type(c_ptr), intent(in), value :: angle_xz  ! 0D_NOT_real
  real(rp) :: f_angle_xz
  real(c_double), pointer :: f_angle_xz_ptr
  type(c_ptr), intent(in), value :: angle_yz  ! 0D_NOT_real
  real(rp) :: f_angle_yz
  real(c_double), pointer :: f_angle_yz_ptr
  type(c_ptr), intent(in), value :: angle_xpz  ! 0D_NOT_real
  real(rp) :: f_angle_xpz
  real(c_double), pointer :: f_angle_xpz_ptr
  type(c_ptr), intent(in), value :: angle_ypz  ! 0D_NOT_real
  real(rp) :: f_angle_ypz
  real(c_double), pointer :: f_angle_ypz_ptr
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(S)) then
    call c_f_pointer(S, f_S_ptr, [6*6])
    call vec2mat(f_S_ptr, f_S)
  else
    f_S_ptr => null()
  endif
  call beam_tilts(S=f_S, angle_xy=f_angle_xy, angle_xz=f_angle_xz, angle_yz=f_angle_yz, &
      angle_xpz=f_angle_xpz, angle_ypz=f_angle_ypz)

  ! out: f_angle_xy 0D_NOT_real
  call c_f_pointer(angle_xy, f_angle_xy_ptr)
  f_angle_xy_ptr = f_angle_xy
  ! out: f_angle_xz 0D_NOT_real
  call c_f_pointer(angle_xz, f_angle_xz_ptr)
  f_angle_xz_ptr = f_angle_xz
  ! out: f_angle_yz 0D_NOT_real
  call c_f_pointer(angle_yz, f_angle_yz_ptr)
  f_angle_yz_ptr = f_angle_yz
  ! out: f_angle_xpz 0D_NOT_real
  call c_f_pointer(angle_xpz, f_angle_xpz_ptr)
  f_angle_xpz_ptr = f_angle_xpz
  ! out: f_angle_ypz 0D_NOT_real
  call c_f_pointer(angle_ypz, f_angle_ypz_ptr)
  f_angle_ypz_ptr = f_angle_ypz
end subroutine
subroutine fortran_bend_edge_kick (ele, param, particle_at, orb, mat6, make_matrix, track_spin) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  type(c_ptr), intent(in), value :: track_spin  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_track_spin
  logical, target :: f_track_spin_native
  logical, pointer :: f_track_spin_native_ptr
  logical(c_bool), pointer :: f_track_spin_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  ! in: f_track_spin 0D_NOT_logical
  if (c_associated(track_spin)) then
    call c_f_pointer(track_spin, f_track_spin_ptr)
    f_track_spin_native = f_track_spin_ptr
    f_track_spin_native_ptr => f_track_spin_native
  else
    f_track_spin_native_ptr => null()
  endif
  call bend_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, orb=f_orb, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr, track_spin=f_track_spin_native_ptr)

end subroutine
subroutine fortran_bend_exact_multipole_field (ele, param, orbit, local_ref_frame, field, &
    calc_dfield, calc_potential) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  logical(c_bool) :: local_ref_frame  ! 0D_NOT_logical
  logical :: f_local_ref_frame
  type(c_ptr), intent(in), value :: calc_dfield  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_dfield
  logical, target :: f_calc_dfield_native
  logical, pointer :: f_calc_dfield_native_ptr
  logical(c_bool), pointer :: f_calc_dfield_ptr
  type(c_ptr), intent(in), value :: calc_potential  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_potential
  logical, target :: f_calc_potential_native
  logical, pointer :: f_calc_potential_native_ptr
  logical(c_bool), pointer :: f_calc_potential_ptr
  ! ** Out parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_local_ref_frame 0D_NOT_logical
  f_local_ref_frame = local_ref_frame
  ! out: f_field 0D_NOT_type
  if (.not. c_associated(field)) return
  call c_f_pointer(field, f_field)
  ! in: f_calc_dfield 0D_NOT_logical
  if (c_associated(calc_dfield)) then
    call c_f_pointer(calc_dfield, f_calc_dfield_ptr)
    f_calc_dfield_native = f_calc_dfield_ptr
    f_calc_dfield_native_ptr => f_calc_dfield_native
  else
    f_calc_dfield_native_ptr => null()
  endif
  ! in: f_calc_potential 0D_NOT_logical
  if (c_associated(calc_potential)) then
    call c_f_pointer(calc_potential, f_calc_potential_ptr)
    f_calc_potential_native = f_calc_potential_ptr
    f_calc_potential_native_ptr => f_calc_potential_native
  else
    f_calc_potential_native_ptr => null()
  endif
  call bend_exact_multipole_field(ele=f_ele, param=f_param, orbit=f_orbit, &
      local_ref_frame=f_local_ref_frame, field=f_field, calc_dfield=f_calc_dfield_native_ptr, &
      calc_potential=f_calc_potential_native_ptr)

  ! out: f_field 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_bend_length_has_been_set (ele, is_set) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_set  ! 0D_NOT_logical
  logical :: f_is_set
  logical(c_bool), pointer :: f_is_set_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_is_set = bend_length_has_been_set(ele=f_ele)

  ! out: f_is_set 0D_NOT_logical
  call c_f_pointer(is_set, f_is_set_ptr)
  f_is_set_ptr = f_is_set
end subroutine
subroutine fortran_bend_photon_e_rel_init (r_in, E_rel) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: r_in  ! 0D_NOT_real
  real(c_double) :: f_r_in
  real(c_double), pointer :: f_r_in_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: E_rel  ! 0D_NOT_real
  real(rp) :: f_E_rel
  real(c_double), pointer :: f_E_rel_ptr
  ! ** End of parameters **
  ! in: f_r_in 0D_NOT_real
  if (c_associated(r_in)) then
    call c_f_pointer(r_in, f_r_in_ptr)
  else
    f_r_in_ptr => null()
  endif
  f_E_rel = bend_photon_e_rel_init(r_in=f_r_in_ptr)

  ! out: f_E_rel 0D_NOT_real
  call c_f_pointer(E_rel, f_E_rel_ptr)
  f_E_rel_ptr = f_E_rel
end subroutine
subroutine fortran_bend_photon_energy_integ_prob (E_photon, g_bend, gamma, integ_prob) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: E_photon  ! 0D_NOT_real
  real(rp) :: f_E_photon
  real(c_double) :: g_bend  ! 0D_NOT_real
  real(rp) :: f_g_bend
  real(c_double) :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: integ_prob  ! 0D_NOT_real
  real(rp) :: f_integ_prob
  real(c_double), pointer :: f_integ_prob_ptr
  ! ** End of parameters **
  ! in: f_E_photon 0D_NOT_real
  f_E_photon = E_photon
  ! in: f_g_bend 0D_NOT_real
  f_g_bend = g_bend
  ! in: f_gamma 0D_NOT_real
  f_gamma = gamma
  f_integ_prob = bend_photon_energy_integ_prob(E_photon=f_E_photon, g_bend=f_g_bend, &
      gamma=f_gamma)

  ! out: f_integ_prob 0D_NOT_real
  call c_f_pointer(integ_prob, f_integ_prob_ptr)
  f_integ_prob_ptr = f_integ_prob
end subroutine
subroutine fortran_bend_photon_energy_normalized_probability (E_rel, prob) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: E_rel  ! 0D_NOT_real
  real(rp) :: f_E_rel
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: prob  ! 0D_NOT_real
  real(rp) :: f_prob
  real(c_double), pointer :: f_prob_ptr
  ! ** End of parameters **
  ! in: f_E_rel 0D_NOT_real
  f_E_rel = E_rel
  f_prob = bend_photon_energy_normalized_probability(E_rel=f_E_rel)

  ! out: f_prob 0D_NOT_real
  call c_f_pointer(prob, f_prob_ptr)
  f_prob_ptr = f_prob
end subroutine
subroutine fortran_bend_photon_init (g_bend_x, g_bend_y, gamma, orbit, E_min, E_max, &
    E_integ_prob, vert_angle_min, vert_angle_max, vert_angle_symmetric, emit_probability) &
    bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: g_bend_x  ! 0D_NOT_real
  real(rp) :: f_g_bend_x
  real(c_double) :: g_bend_y  ! 0D_NOT_real
  real(rp) :: f_g_bend_y
  real(c_double) :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  type(c_ptr), intent(in), value :: E_min  ! 0D_NOT_real
  real(c_double) :: f_E_min
  real(c_double), pointer :: f_E_min_ptr
  type(c_ptr), intent(in), value :: E_max  ! 0D_NOT_real
  real(c_double) :: f_E_max
  real(c_double), pointer :: f_E_max_ptr
  type(c_ptr), intent(in), value :: E_integ_prob  ! 0D_NOT_real
  real(c_double) :: f_E_integ_prob
  real(c_double), pointer :: f_E_integ_prob_ptr
  type(c_ptr), intent(in), value :: vert_angle_min  ! 0D_NOT_real
  real(c_double) :: f_vert_angle_min
  real(c_double), pointer :: f_vert_angle_min_ptr
  type(c_ptr), intent(in), value :: vert_angle_max  ! 0D_NOT_real
  real(c_double) :: f_vert_angle_max
  real(c_double), pointer :: f_vert_angle_max_ptr
  type(c_ptr), intent(in), value :: vert_angle_symmetric  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_vert_angle_symmetric
  logical, target :: f_vert_angle_symmetric_native
  logical, pointer :: f_vert_angle_symmetric_native_ptr
  logical(c_bool), pointer :: f_vert_angle_symmetric_ptr
  type(c_ptr), intent(in), value :: emit_probability  ! 0D_NOT_real
  real(c_double) :: f_emit_probability
  real(c_double), pointer :: f_emit_probability_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_g_bend_x 0D_NOT_real
  f_g_bend_x = g_bend_x
  ! in: f_g_bend_y 0D_NOT_real
  f_g_bend_y = g_bend_y
  ! in: f_gamma 0D_NOT_real
  f_gamma = gamma
  ! out: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_E_min 0D_NOT_real
  if (c_associated(E_min)) then
    call c_f_pointer(E_min, f_E_min_ptr)
  else
    f_E_min_ptr => null()
  endif
  ! in: f_E_max 0D_NOT_real
  if (c_associated(E_max)) then
    call c_f_pointer(E_max, f_E_max_ptr)
  else
    f_E_max_ptr => null()
  endif
  ! in: f_E_integ_prob 0D_NOT_real
  if (c_associated(E_integ_prob)) then
    call c_f_pointer(E_integ_prob, f_E_integ_prob_ptr)
  else
    f_E_integ_prob_ptr => null()
  endif
  ! in: f_vert_angle_min 0D_NOT_real
  if (c_associated(vert_angle_min)) then
    call c_f_pointer(vert_angle_min, f_vert_angle_min_ptr)
  else
    f_vert_angle_min_ptr => null()
  endif
  ! in: f_vert_angle_max 0D_NOT_real
  if (c_associated(vert_angle_max)) then
    call c_f_pointer(vert_angle_max, f_vert_angle_max_ptr)
  else
    f_vert_angle_max_ptr => null()
  endif
  ! in: f_vert_angle_symmetric 0D_NOT_logical
  if (c_associated(vert_angle_symmetric)) then
    call c_f_pointer(vert_angle_symmetric, f_vert_angle_symmetric_ptr)
    f_vert_angle_symmetric_native = f_vert_angle_symmetric_ptr
    f_vert_angle_symmetric_native_ptr => f_vert_angle_symmetric_native
  else
    f_vert_angle_symmetric_native_ptr => null()
  endif
  ! in: f_emit_probability 0D_NOT_real
  if (c_associated(emit_probability)) then
    call c_f_pointer(emit_probability, f_emit_probability_ptr)
  else
    f_emit_probability_ptr => null()
  endif
  call bend_photon_init(g_bend_x=f_g_bend_x, g_bend_y=f_g_bend_y, gamma=f_gamma, orbit=f_orbit, &
      E_min=f_E_min_ptr, E_max=f_E_max_ptr, E_integ_prob=f_E_integ_prob_ptr, &
      vert_angle_min=f_vert_angle_min_ptr, vert_angle_max=f_vert_angle_max_ptr, &
      vert_angle_symmetric=f_vert_angle_symmetric_native_ptr, &
      emit_probability=f_emit_probability_ptr)

  ! out: f_orbit 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_bend_photon_polarization_init (g_bend_x, g_bend_y, E_rel, gamma_phi, orbit) &
    bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: g_bend_x  ! 0D_NOT_real
  real(rp) :: f_g_bend_x
  real(c_double) :: g_bend_y  ! 0D_NOT_real
  real(rp) :: f_g_bend_y
  real(c_double) :: E_rel  ! 0D_NOT_real
  real(rp) :: f_E_rel
  real(c_double) :: gamma_phi  ! 0D_NOT_real
  real(rp) :: f_gamma_phi
  ! ** Out parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_g_bend_x 0D_NOT_real
  f_g_bend_x = g_bend_x
  ! in: f_g_bend_y 0D_NOT_real
  f_g_bend_y = g_bend_y
  ! in: f_E_rel 0D_NOT_real
  f_E_rel = E_rel
  ! in: f_gamma_phi 0D_NOT_real
  f_gamma_phi = gamma_phi
  ! out: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call bend_photon_polarization_init(g_bend_x=f_g_bend_x, g_bend_y=f_g_bend_y, E_rel=f_E_rel, &
      gamma_phi=f_gamma_phi, orbit=f_orbit)

  ! out: f_orbit 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_bend_photon_vert_angle_init (E_rel, gamma, r_in, invert, phi) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: E_rel  ! 0D_NOT_real
  real(rp) :: f_E_rel
  real(c_double) :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  type(c_ptr), intent(in), value :: r_in  ! 0D_NOT_real
  real(c_double) :: f_r_in
  real(c_double), pointer :: f_r_in_ptr
  type(c_ptr), intent(in), value :: invert  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_invert
  logical, target :: f_invert_native
  logical, pointer :: f_invert_native_ptr
  logical(c_bool), pointer :: f_invert_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: phi  ! 0D_NOT_real
  real(rp) :: f_phi
  real(c_double), pointer :: f_phi_ptr
  ! ** End of parameters **
  ! in: f_E_rel 0D_NOT_real
  f_E_rel = E_rel
  ! in: f_gamma 0D_NOT_real
  f_gamma = gamma
  ! in: f_r_in 0D_NOT_real
  if (c_associated(r_in)) then
    call c_f_pointer(r_in, f_r_in_ptr)
  else
    f_r_in_ptr => null()
  endif
  ! in: f_invert 0D_NOT_logical
  if (c_associated(invert)) then
    call c_f_pointer(invert, f_invert_ptr)
    f_invert_native = f_invert_ptr
    f_invert_native_ptr => f_invert_native
  else
    f_invert_native_ptr => null()
  endif
  f_phi = bend_photon_vert_angle_init(E_rel=f_E_rel, gamma=f_gamma, r_in=f_r_in_ptr, &
      invert=f_invert_native_ptr)

  ! out: f_phi 0D_NOT_real
  call c_f_pointer(phi, f_phi_ptr)
  f_phi_ptr = f_phi
end subroutine
subroutine fortran_bend_shift (position1, g, delta_s, w_mat, ref_tilt, position2) bind(c)

  use bmad_struct, only: floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: position1  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_position1
  real(c_double) :: g  ! 0D_NOT_real
  real(rp) :: f_g
  real(c_double) :: delta_s  ! 0D_NOT_real
  real(rp) :: f_delta_s
  type(c_ptr), intent(in), value :: ref_tilt  ! 0D_NOT_real
  real(c_double) :: f_ref_tilt
  real(c_double), pointer :: f_ref_tilt_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), value :: position2  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_position2
  ! ** End of parameters **
  ! in: f_position1 0D_NOT_type
  if (.not. c_associated(position1)) return
  call c_f_pointer(position1, f_position1)
  ! in: f_g 0D_NOT_real
  f_g = g
  ! in: f_delta_s 0D_NOT_real
  f_delta_s = delta_s
  ! in: f_ref_tilt 0D_NOT_real
  if (c_associated(ref_tilt)) then
    call c_f_pointer(ref_tilt, f_ref_tilt_ptr)
  else
    f_ref_tilt_ptr => null()
  endif
  f_position2 = bend_shift(position1=f_position1, g=f_g, delta_s=f_delta_s, w_mat=f_w_mat, &
      ref_tilt=f_ref_tilt_ptr)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=556, definition='real(rp), optional :: w_mat(3,3), ref_tilt', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='out', description='W matrix used in the transformation', doc_data_type='float', doc_is_optional=False)
  ! out: f_position2 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_bend_vert_angle_integ_prob (vert_angle, E_rel, gamma, integ_prob) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: vert_angle  ! 0D_NOT_real
  real(rp) :: f_vert_angle
  real(c_double) :: E_rel  ! 0D_NOT_real
  real(rp) :: f_E_rel
  real(c_double) :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: integ_prob  ! 0D_NOT_real
  real(rp) :: f_integ_prob
  real(c_double), pointer :: f_integ_prob_ptr
  ! ** End of parameters **
  ! in: f_vert_angle 0D_NOT_real
  f_vert_angle = vert_angle
  ! in: f_E_rel 0D_NOT_real
  f_E_rel = E_rel
  ! in: f_gamma 0D_NOT_real
  f_gamma = gamma
  f_integ_prob = bend_vert_angle_integ_prob(vert_angle=f_vert_angle, E_rel=f_E_rel, &
      gamma=f_gamma)

  ! out: f_integ_prob 0D_NOT_real
  call c_f_pointer(integ_prob, f_integ_prob_ptr)
  f_integ_prob_ptr = f_integ_prob
end subroutine
subroutine fortran_bl_via_vlassov (current, alpha, Energy, sigma_p, Vrf, omega, U0, circ, R, L, &
    sigma_z) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: current  ! 0D_NOT_real
  real(rp) :: f_current
  real(c_double) :: alpha  ! 0D_NOT_real
  real(rp) :: f_alpha
  real(c_double) :: Energy  ! 0D_NOT_real
  real(rp) :: f_Energy
  real(c_double) :: sigma_p  ! 0D_NOT_real
  real(rp) :: f_sigma_p
  real(c_double) :: Vrf  ! 0D_NOT_real
  real(rp) :: f_Vrf
  real(c_double) :: omega  ! 0D_NOT_real
  real(rp) :: f_omega
  real(c_double) :: U0  ! 0D_NOT_real
  real(rp) :: f_U0
  real(c_double) :: circ  ! 0D_NOT_real
  real(rp) :: f_circ
  real(c_double) :: R  ! 0D_NOT_real
  real(rp) :: f_R
  real(c_double) :: L  ! 0D_NOT_real
  real(rp) :: f_L
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: sigma_z  ! 0D_NOT_real
  real(rp) :: f_sigma_z
  real(c_double), pointer :: f_sigma_z_ptr
  ! ** End of parameters **
  ! in: f_current 0D_NOT_real
  f_current = current
  ! in: f_alpha 0D_NOT_real
  f_alpha = alpha
  ! in: f_Energy 0D_NOT_real
  f_Energy = Energy
  ! in: f_sigma_p 0D_NOT_real
  f_sigma_p = sigma_p
  ! in: f_Vrf 0D_NOT_real
  f_Vrf = Vrf
  ! in: f_omega 0D_NOT_real
  f_omega = omega
  ! in: f_U0 0D_NOT_real
  f_U0 = U0
  ! in: f_circ 0D_NOT_real
  f_circ = circ
  ! in: f_R 0D_NOT_real
  f_R = R
  ! in: f_L 0D_NOT_real
  f_L = L
  call bl_via_vlassov(current=f_current, alpha=f_alpha, Energy=f_Energy, sigma_p=f_sigma_p, &
      Vrf=f_Vrf, omega=f_omega, U0=f_U0, circ=f_circ, R=f_R, L=f_L, sigma_z=f_sigma_z)

  ! out: f_sigma_z 0D_NOT_real
  call c_f_pointer(sigma_z, f_sigma_z_ptr)
  f_sigma_z_ptr = f_sigma_z
end subroutine
subroutine fortran_bmad_parser (lat_file, lat, make_mats6, digested_read_ok, use_line, &
    err_flag, parse_lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: lat_file
  character(len=4096), target :: f_lat_file
  character(kind=c_char), pointer :: f_lat_file_ptr(:)
  type(c_ptr), intent(in), value :: make_mats6  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_mats6
  logical, target :: f_make_mats6_native
  logical, pointer :: f_make_mats6_native_ptr
  logical(c_bool), pointer :: f_make_mats6_ptr
  type(c_ptr), intent(in), value :: use_line
  character(len=4096), target :: f_use_line
  character(kind=c_char), pointer :: f_use_line_ptr(:)
  character(len=4096), pointer :: f_use_line_call_ptr
  ! ** Out parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: digested_read_ok  ! 0D_NOT_logical
  logical :: f_digested_read_ok
  logical(c_bool), pointer :: f_digested_read_ok_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: parse_lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_parse_lat
  ! ** End of parameters **
  ! in: f_lat_file 0D_NOT_character
  if (.not. c_associated(lat_file)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat_file, f_lat_file_ptr, [huge(0)])
  call to_f_str(f_lat_file_ptr, f_lat_file)
  ! out: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_make_mats6 0D_NOT_logical
  if (c_associated(make_mats6)) then
    call c_f_pointer(make_mats6, f_make_mats6_ptr)
    f_make_mats6_native = f_make_mats6_ptr
    f_make_mats6_native_ptr => f_make_mats6_native
  else
    f_make_mats6_native_ptr => null()
  endif
  ! in: f_use_line 0D_NOT_character
  if (c_associated(use_line)) then
    call c_f_pointer(use_line, f_use_line_ptr, [huge(0)])
    call to_f_str(f_use_line_ptr, f_use_line)
    f_use_line_call_ptr => f_use_line
  else
    f_use_line_call_ptr => null()
  endif
  ! out: f_parse_lat 0D_NOT_type
  if (c_associated(parse_lat))   call c_f_pointer(parse_lat, f_parse_lat)
  call bmad_parser(lat_file=f_lat_file, lat=f_lat, make_mats6=f_make_mats6_native_ptr, &
      digested_read_ok=f_digested_read_ok, use_line=f_use_line_call_ptr, err_flag=f_err_flag, &
      parse_lat=f_parse_lat)

  ! out: f_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_digested_read_ok 0D_NOT_logical
  ! no output conversion for f_digested_read_ok
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_parse_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_bmad_parser2 (lat_file, lat, orbit, make_mats6, err_flag, parse_lat) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: lat_file
  character(len=4096), target :: f_lat_file
  character(kind=c_char), pointer :: f_lat_file_ptr(:)
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  type(c_ptr), intent(in), value :: make_mats6  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_mats6
  logical, target :: f_make_mats6_native
  logical, pointer :: f_make_mats6_native_ptr
  logical(c_bool), pointer :: f_make_mats6_ptr
  type(c_ptr), value :: parse_lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_parse_lat
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_lat_file 0D_NOT_character
  if (.not. c_associated(lat_file)) return
  call c_f_pointer(lat_file, f_lat_file_ptr, [huge(0)])
  call to_f_str(f_lat_file_ptr, f_lat_file)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  ! in: f_make_mats6 0D_NOT_logical
  if (c_associated(make_mats6)) then
    call c_f_pointer(make_mats6, f_make_mats6_ptr)
    f_make_mats6_native = f_make_mats6_ptr
    f_make_mats6_native_ptr => f_make_mats6_native
  else
    f_make_mats6_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! in: f_parse_lat 0D_NOT_type
  if (c_associated(parse_lat))   call c_f_pointer(parse_lat, f_parse_lat)
  call bmad_parser2(lat_file=f_lat_file, lat=f_lat, orbit=f_orbit%data, &
      make_mats6=f_make_mats6_native_ptr, err_flag=f_err_flag_native_ptr, &
      parse_lat=f_parse_lat)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_bmad_patch_parameters_to_ptc (ang, exi) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ang
  real(dp) :: f_ang(3)
  real(c_double), pointer :: f_ang_ptr(:)
  type(c_ptr), intent(in), value :: exi
  real(dp) :: f_exi(3,3)
  real(c_double), pointer :: f_exi_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(ang)) then
    call c_f_pointer(ang, f_ang_ptr, [3])
    f_ang = f_ang_ptr(:)
  else
    f_ang_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(exi)) then
    call c_f_pointer(exi, f_exi_ptr, [3*3])
    call vec2mat(f_exi_ptr, f_exi)
  else
    f_exi_ptr => null()
  endif
  call bmad_patch_parameters_to_ptc(ang=f_ang, exi=f_exi)

end subroutine
subroutine fortran_bp_set_ran_status () bind(c)

  implicit none
  ! ** End of parameters **
  call bp_set_ran_status()

end subroutine
subroutine fortran_branch_equal_branch (branch1, branch2) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch2  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch2
  ! ** Out parameters **
  type(c_ptr), value :: branch1  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch1
  ! ** End of parameters **
  ! out: f_branch1 0D_NOT_type
  if (.not. c_associated(branch1)) return
  call c_f_pointer(branch1, f_branch1)
  ! in: f_branch2 0D_NOT_type
  if (.not. c_associated(branch2)) return
  call c_f_pointer(branch2, f_branch2)
  call branch_equal_branch(branch1=f_branch1, branch2=f_branch2)

  ! out: f_branch1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_branch_name (branch, name) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  f_name = branch_name(branch=f_branch)

  ! out: f_name 0D_NOT_character
  call c_f_pointer(name, f_name_ptr, [len_trim(f_name) + 1]) ! output-only string
  call to_c_str(f_name, f_name_ptr)
end subroutine
subroutine fortran_branch_to_ptc_m_u (branch) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call branch_to_ptc_m_u(branch=f_branch)

end subroutine
subroutine fortran_bunch_equal_bunch (bunch1, bunch2) bind(c)

  use bmad_struct, only: bunch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: bunch1  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch1
  type(c_ptr), value :: bunch2  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch2
  ! ** End of parameters **
  ! in: f_bunch1 0D_NOT_type
  if (.not. c_associated(bunch1)) return
  call c_f_pointer(bunch1, f_bunch1)
  ! in: f_bunch2 0D_NOT_type
  if (.not. c_associated(bunch2)) return
  call c_f_pointer(bunch2, f_bunch2)
  call bunch_equal_bunch(bunch1=f_bunch1, bunch2=f_bunch2)

end subroutine
subroutine fortran_c_to_cbar (ele, cbar_mat) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: cbar_mat
  real(rp) :: f_cbar_mat(2,2)
  real(c_double), pointer :: f_cbar_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call c_to_cbar(ele=f_ele, cbar_mat=f_cbar_mat)

  ! out: f_cbar_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_cbar_mat', c_name='cbar_mat', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=633, definition='real(rp) cbar_mat(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='cbar_mat', comment='', default=None), intent='out', description='Cbar matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_calc_bunch_params (bunch, bunch_params, error, print_err, n_mat, &
    is_time_coords, ele) bind(c)

  use bmad_struct, only: bunch_params_struct, bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_params  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_bunch_params
  logical(c_bool) :: error  ! 0D_NOT_logical
  logical :: f_error
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  type(c_ptr), intent(in), value :: n_mat
  real(rp) :: f_n_mat(6,6)
  real(c_double), pointer :: f_n_mat_ptr(:)
  type(c_ptr), intent(in), value :: is_time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_time_coords
  logical, target :: f_is_time_coords_native
  logical, pointer :: f_is_time_coords_native_ptr
  logical(c_bool), pointer :: f_is_time_coords_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! in: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_bunch_params 0D_NOT_type
  if (.not. c_associated(bunch_params)) return
  call c_f_pointer(bunch_params, f_bunch_params)
  ! in: f_error 0D_NOT_logical
  f_error = error
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(n_mat)) then
    call c_f_pointer(n_mat, f_n_mat_ptr, [6*6])
    call vec2mat(f_n_mat_ptr, f_n_mat)
  else
    f_n_mat_ptr => null()
  endif
  ! in: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_native = f_is_time_coords_ptr
    f_is_time_coords_native_ptr => f_is_time_coords_native
  else
    f_is_time_coords_native_ptr => null()
  endif
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  call calc_bunch_params(bunch=f_bunch, bunch_params=f_bunch_params, error=f_error, &
      print_err=f_print_err_native_ptr, n_mat=f_n_mat, &
      is_time_coords=f_is_time_coords_native_ptr, ele=f_ele)

end subroutine
subroutine fortran_calc_bunch_params_slice (bunch, bunch_params, plane, slice_center, &
    slice_spread, err, print_err, is_time_coords, ele) bind(c)

  use bmad_struct, only: bunch_params_struct, bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  integer(c_int) :: plane  ! 0D_NOT_integer
  integer :: f_plane
  real(c_double) :: slice_center  ! 0D_NOT_real
  real(rp) :: f_slice_center
  real(c_double) :: slice_spread  ! 0D_NOT_real
  real(rp) :: f_slice_spread
  logical(c_bool) :: err  ! 0D_NOT_logical
  logical :: f_err
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  type(c_ptr), intent(in), value :: is_time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_time_coords
  logical, target :: f_is_time_coords_native
  logical, pointer :: f_is_time_coords_native_ptr
  logical(c_bool), pointer :: f_is_time_coords_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Inout parameters **
  type(c_ptr), value :: bunch_params  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_bunch_params
  ! ** End of parameters **
  ! in: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! inout: f_bunch_params 0D_NOT_type
  if (.not. c_associated(bunch_params)) return
  call c_f_pointer(bunch_params, f_bunch_params)
  ! in: f_plane 0D_NOT_integer
  f_plane = plane
  ! in: f_slice_center 0D_NOT_real
  f_slice_center = slice_center
  ! in: f_slice_spread 0D_NOT_real
  f_slice_spread = slice_spread
  ! in: f_err 0D_NOT_logical
  f_err = err
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  ! in: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_native = f_is_time_coords_ptr
    f_is_time_coords_native_ptr => f_is_time_coords_native
  else
    f_is_time_coords_native_ptr => null()
  endif
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  call calc_bunch_params_slice(bunch=f_bunch, bunch_params=f_bunch_params, plane=f_plane, &
      slice_center=f_slice_center, slice_spread=f_slice_spread, err=f_err, &
      print_err=f_print_err_native_ptr, is_time_coords=f_is_time_coords_native_ptr, ele=f_ele)

end subroutine
subroutine fortran_calc_bunch_params_z_slice (bunch, bunch_params, slice_bounds, err, &
    print_err, is_time_coords, ele) bind(c)

  use bmad_struct, only: bunch_params_struct, bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), intent(in), value :: slice_bounds
  real(rp) :: f_slice_bounds(2)
  real(c_double), pointer :: f_slice_bounds_ptr(:)
  logical(c_bool) :: err  ! 0D_NOT_logical
  logical :: f_err
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  type(c_ptr), intent(in), value :: is_time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_time_coords
  logical, target :: f_is_time_coords_native
  logical, pointer :: f_is_time_coords_native_ptr
  logical(c_bool), pointer :: f_is_time_coords_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Inout parameters **
  type(c_ptr), value :: bunch_params  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_bunch_params
  ! ** End of parameters **
  ! in: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! inout: f_bunch_params 0D_NOT_type
  if (.not. c_associated(bunch_params)) return
  call c_f_pointer(bunch_params, f_bunch_params)
  !! general array (1D_NOT_real)
  if (c_associated(slice_bounds)) then
    call c_f_pointer(slice_bounds, f_slice_bounds_ptr, [2])
    f_slice_bounds = f_slice_bounds_ptr(:)
  else
    f_slice_bounds_ptr => null()
  endif
  ! in: f_err 0D_NOT_logical
  f_err = err
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  ! in: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_native = f_is_time_coords_ptr
    f_is_time_coords_native_ptr => f_is_time_coords_native
  else
    f_is_time_coords_native_ptr => null()
  endif
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  call calc_bunch_params_z_slice(bunch=f_bunch, bunch_params=f_bunch_params, &
      slice_bounds=f_slice_bounds, err=f_err, print_err=f_print_err_native_ptr, &
      is_time_coords=f_is_time_coords_native_ptr, ele=f_ele)

end subroutine
subroutine fortran_calc_bunch_sigma_matrix_etc (particle, charge, bunch_params, is_time_coords, &
    ele) bind(c)

  use bmad_struct, only: bunch_params_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: particle
  type(coord_struct_container_alloc), pointer :: f_particle
  type(c_ptr), intent(in), value :: charge
  type(real_container_alloc), pointer :: f_charge
  ! ** Out parameters **
  type(c_ptr), value :: bunch_params  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_bunch_params
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: is_time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_time_coords
  logical, target :: f_is_time_coords_native
  logical, pointer :: f_is_time_coords_native_ptr
  logical(c_bool), pointer :: f_is_time_coords_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(particle))   call c_f_pointer(particle, f_particle)
  !! container general array (1D_ALLOC_real)
  if (c_associated(charge))   call c_f_pointer(charge, f_charge)
  ! out: f_bunch_params 0D_NOT_type
  if (.not. c_associated(bunch_params)) return
  call c_f_pointer(bunch_params, f_bunch_params)
  ! inout: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_native = f_is_time_coords_ptr
    f_is_time_coords_native_ptr => f_is_time_coords_native
  else
    f_is_time_coords_native_ptr => null()
  endif
  ! inout: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  call calc_bunch_sigma_matrix_etc(particle=f_particle%data, charge=f_charge%data, &
      bunch_params=f_bunch_params, is_time_coords=f_is_time_coords_native_ptr, ele=f_ele)

  ! out: f_bunch_params 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_ptr = f_is_time_coords_native
  else
    ! f_is_time_coords unset
  endif
end subroutine
subroutine fortran_calc_emittances_and_twiss_from_sigma_matrix (sigma_mat, bunch_params, error, &
    print_err, n_mat) bind(c)

  use bmad_struct, only: bunch_params_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), value :: bunch_params  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_bunch_params
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  type(c_ptr), intent(in), value :: n_mat
  real(rp) :: f_n_mat(6,6)
  real(c_double), pointer :: f_n_mat_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat)) then
    call c_f_pointer(sigma_mat, f_sigma_mat_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptr, f_sigma_mat)
  else
    f_sigma_mat_ptr => null()
  endif
  ! out: f_bunch_params 0D_NOT_type
  if (.not. c_associated(bunch_params)) return
  call c_f_pointer(bunch_params, f_bunch_params)
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call calc_emittances_and_twiss_from_sigma_matrix(sigma_mat=f_sigma_mat, &
      bunch_params=f_bunch_params, error=f_error, print_err=f_print_err_native_ptr, &
      n_mat=f_n_mat)

  ! out: f_bunch_params 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
  ! out: f_n_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_n_mat', c_name='n_mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=1448, definition='real(rp), optional :: n_mat(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='n_mat', comment='', default=None), intent='out', description='N matrix defined in Wolski Eq 44 and used to convert from action-angle coords to lab coords (Wolski Eq 51.).', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_calc_spin_params (bunch, bunch_params) bind(c)

  use bmad_struct, only: bunch_params_struct, bunch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** Out parameters **
  type(c_ptr), value :: bunch_params  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_bunch_params
  ! ** End of parameters **
  ! in: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! out: f_bunch_params 0D_NOT_type
  if (.not. c_associated(bunch_params)) return
  call c_f_pointer(bunch_params, f_bunch_params)
  call calc_spin_params(bunch=f_bunch, bunch_params=f_bunch_params)

  ! out: f_bunch_params 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_calc_super_slave_key (lord1, lord2, slave, create_jumbo_slave) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lord1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord1
  type(c_ptr), value :: lord2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord2
  type(c_ptr), intent(in), value :: create_jumbo_slave  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_create_jumbo_slave
  logical, target :: f_create_jumbo_slave_native
  logical, pointer :: f_create_jumbo_slave_native_ptr
  logical(c_bool), pointer :: f_create_jumbo_slave_ptr
  ! ** Out parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  ! ** End of parameters **
  ! in: f_lord1 0D_NOT_type
  if (.not. c_associated(lord1)) return
  call c_f_pointer(lord1, f_lord1)
  ! in: f_lord2 0D_NOT_type
  if (.not. c_associated(lord2)) return
  call c_f_pointer(lord2, f_lord2)
  ! out: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! in: f_create_jumbo_slave 0D_NOT_logical
  if (c_associated(create_jumbo_slave)) then
    call c_f_pointer(create_jumbo_slave, f_create_jumbo_slave_ptr)
    f_create_jumbo_slave_native = f_create_jumbo_slave_ptr
    f_create_jumbo_slave_native_ptr => f_create_jumbo_slave_native
  else
    f_create_jumbo_slave_native_ptr => null()
  endif
  call calc_super_slave_key(lord1=f_lord1, lord2=f_lord2, slave=f_slave, &
      create_jumbo_slave=f_create_jumbo_slave_native_ptr)

  ! out: f_slave 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_calc_wall_radius (v, cos_ang, sin_ang, r_wall, dr_dtheta, ix_vertex) bind(c)

  use bmad_struct, only: wall3d_vertex_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: v
  type(wall3d_vertex_struct_container_alloc), pointer :: f_v
  real(c_double) :: cos_ang  ! 0D_NOT_real
  real(rp) :: f_cos_ang
  real(c_double) :: sin_ang  ! 0D_NOT_real
  real(rp) :: f_sin_ang
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: r_wall  ! 0D_NOT_real
  real(rp) :: f_r_wall
  real(c_double), pointer :: f_r_wall_ptr
  type(c_ptr), intent(in), value :: dr_dtheta  ! 0D_NOT_real
  real(rp) :: f_dr_dtheta
  real(c_double), pointer :: f_dr_dtheta_ptr
  type(c_ptr), intent(in), value :: ix_vertex  ! 0D_NOT_integer
  integer :: f_ix_vertex
  integer(c_int), pointer :: f_ix_vertex_ptr
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(v))   call c_f_pointer(v, f_v)
  ! in: f_cos_ang 0D_NOT_real
  f_cos_ang = cos_ang
  ! in: f_sin_ang 0D_NOT_real
  f_sin_ang = sin_ang
  call calc_wall_radius(v=f_v%data, cos_ang=f_cos_ang, sin_ang=f_sin_ang, r_wall=f_r_wall, &
      dr_dtheta=f_dr_dtheta, ix_vertex=f_ix_vertex)

  ! out: f_r_wall 0D_NOT_real
  call c_f_pointer(r_wall, f_r_wall_ptr)
  f_r_wall_ptr = f_r_wall
  ! out: f_dr_dtheta 0D_NOT_real
  call c_f_pointer(dr_dtheta, f_dr_dtheta_ptr)
  f_dr_dtheta_ptr = f_dr_dtheta
  ! out: f_ix_vertex 0D_NOT_integer
  ! no output conversion for f_ix_vertex
end subroutine
subroutine fortran_calc_z_tune (branch) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** End of parameters **
  ! inout: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call calc_z_tune(branch=f_branch)

end subroutine
subroutine fortran_canonical_to_angle_coords (orbit, coord_type) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: coord_type
  character(len=4096), target :: f_coord_type
  character(kind=c_char), pointer :: f_coord_type_ptr(:)
  character(len=4096), pointer :: f_coord_type_call_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_coord_type 0D_NOT_character
  if (c_associated(coord_type)) then
    call c_f_pointer(coord_type, f_coord_type_ptr, [huge(0)])
    call to_f_str(f_coord_type_ptr, f_coord_type)
    f_coord_type_call_ptr => f_coord_type
  else
    f_coord_type_call_ptr => null()
  endif
  call canonical_to_angle_coords(orbit=f_orbit, coord_type=f_coord_type_call_ptr)

end subroutine
subroutine fortran_cbar_to_c (cbar_mat, a, b, c_mat) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: cbar_mat
  real(rp) :: f_cbar_mat(2,2)
  real(c_double), pointer :: f_cbar_mat_ptr(:)
  type(c_ptr), value :: a  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_a
  type(c_ptr), value :: b  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_b
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: c_mat
  real(rp) :: f_c_mat(2,2)
  real(c_double), pointer :: f_c_mat_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(cbar_mat)) then
    call c_f_pointer(cbar_mat, f_cbar_mat_ptr, [2*2])
    call vec2mat(f_cbar_mat_ptr, f_cbar_mat)
  else
    f_cbar_mat_ptr => null()
  endif
  ! in: f_a 0D_NOT_type
  if (.not. c_associated(a)) return
  call c_f_pointer(a, f_a)
  ! in: f_b 0D_NOT_type
  if (.not. c_associated(b)) return
  call c_f_pointer(b, f_b)
  call cbar_to_c(cbar_mat=f_cbar_mat, a=f_a, b=f_b, c_mat=f_c_mat)

  ! out: f_c_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_c_mat', c_name='c_mat', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=668, definition='real(rp) cbar_mat(2,2), c_mat(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='c_mat', comment='', default=None), intent='out', description='C matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_check_aperture_limit (orb, ele, particle_at, param, old_orb, check_momentum) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), value :: old_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_old_orb
  type(c_ptr), intent(in), value :: check_momentum  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_check_momentum
  logical, target :: f_check_momentum_native
  logical, pointer :: f_check_momentum_native_ptr
  logical(c_bool), pointer :: f_check_momentum_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_old_orb 0D_NOT_type
  if (c_associated(old_orb))   call c_f_pointer(old_orb, f_old_orb)
  ! in: f_check_momentum 0D_NOT_logical
  if (c_associated(check_momentum)) then
    call c_f_pointer(check_momentum, f_check_momentum_ptr)
    f_check_momentum_native = f_check_momentum_ptr
    f_check_momentum_native_ptr => f_check_momentum_native
  else
    f_check_momentum_native_ptr => null()
  endif
  call check_aperture_limit(orb=f_orb, ele=f_ele, particle_at=f_particle_at, param=f_param, &
      old_orb=f_old_orb, check_momentum=f_check_momentum_native_ptr)

end subroutine
subroutine fortran_check_controller_controls (ele_key, contrl, name, err) bind(c)

  use bmad_struct, only: control_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: ele_key  ! 0D_NOT_integer
  integer :: f_ele_key
  type(c_ptr), intent(in), value :: contrl
  type(control_struct_container_alloc), pointer :: f_contrl
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_ele_key 0D_NOT_integer
  f_ele_key = ele_key
  !! container type array (1D_ALLOC_type)
  if (c_associated(contrl))   call c_f_pointer(contrl, f_contrl)
  ! in: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  call check_controller_controls(ele_key=f_ele_key, contrl=f_contrl%data, name=f_name, &
      err=f_err)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_check_for_superimpose_problem (branch, super_ele, err_flag, ref_ele, wrap) &
    bind(c)

  use bmad_struct, only: branch_struct, ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), value :: super_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_super_ele
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: ref_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ref_ele
  type(c_ptr), intent(in), value :: wrap  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_wrap
  logical, target :: f_wrap_native
  logical, pointer :: f_wrap_native_ptr
  logical(c_bool), pointer :: f_wrap_ptr
  ! ** End of parameters **
  ! inout: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! inout: f_super_ele 0D_NOT_type
  if (.not. c_associated(super_ele)) return
  call c_f_pointer(super_ele, f_super_ele)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! inout: f_ref_ele 0D_NOT_type
  if (c_associated(ref_ele))   call c_f_pointer(ref_ele, f_ref_ele)
  ! inout: f_wrap 0D_NOT_logical
  if (c_associated(wrap)) then
    call c_f_pointer(wrap, f_wrap_ptr)
    f_wrap_native = f_wrap_ptr
    f_wrap_native_ptr => f_wrap_native
  else
    f_wrap_native_ptr => null()
  endif
  call check_for_superimpose_problem(branch=f_branch, super_ele=f_super_ele, &
      err_flag=f_err_flag_native_ptr, ref_ele=f_ref_ele, wrap=f_wrap_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
  ! inout: f_wrap 0D_NOT_logical
  if (c_associated(wrap)) then
    call c_f_pointer(wrap, f_wrap_ptr)
    f_wrap_ptr = f_wrap_native
  else
    ! f_wrap unset
  endif
end subroutine
subroutine fortran_check_if_s_in_bounds (branch, s, err_flag, translated_s, print_err) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  real(c_double) :: s  ! 0D_NOT_real
  real(rp) :: f_s
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: translated_s  ! 0D_NOT_real
  real(rp) :: f_translated_s
  real(c_double), pointer :: f_translated_s_ptr
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(branch, f_branch)
  ! in: f_s 0D_NOT_real
  f_s = s
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call check_if_s_in_bounds(branch=f_branch, s=f_s, err_flag=f_err_flag, &
      translated_s=f_translated_s, print_err=f_print_err_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_translated_s 0D_NOT_real
  ! no output conversion for f_translated_s
end subroutine
subroutine fortran_choose_quads_for_set_tune (branch, dk1, eles, mask, err_flag) bind(c)

  use bmad_struct, only: branch_struct, ele_pointer_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), intent(in), value :: mask
  character(len=4096), target :: f_mask
  character(kind=c_char), pointer :: f_mask_ptr(:)
  character(len=4096), pointer :: f_mask_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dk1
  type(real_container_alloc), pointer :: f_dk1
  type(c_ptr), intent(in), value :: eles
  type(ele_pointer_struct_container_alloc), pointer :: f_eles
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(branch, f_branch)
  !! container general array (1D_ALLOC_real)
  if (c_associated(dk1))   call c_f_pointer(dk1, f_dk1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(eles))   call c_f_pointer(eles, f_eles)
  ! in: f_mask 0D_NOT_character
  if (c_associated(mask)) then
    call c_f_pointer(mask, f_mask_ptr, [huge(0)])
    call to_f_str(f_mask_ptr, f_mask)
    f_mask_call_ptr => f_mask
  else
    f_mask_call_ptr => null()
  endif
  call choose_quads_for_set_tune(branch=f_branch, dk1=f_dk1%data, eles=f_eles%data, &
      mask=f_mask_call_ptr, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_chrom_calc (lat, delta_e, chrom_a, chrom_b, err_flag, pz, low_E_lat, &
    high_E_lat, low_E_orb, high_E_orb, ix_branch, orb0) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: pz  ! 0D_NOT_real
  real(c_double) :: f_pz
  real(c_double), pointer :: f_pz_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), value :: orb0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb0
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: chrom_a  ! 0D_NOT_real
  real(rp) :: f_chrom_a
  real(c_double), pointer :: f_chrom_a_ptr
  type(c_ptr), intent(in), value :: chrom_b  ! 0D_NOT_real
  real(rp) :: f_chrom_b
  real(c_double), pointer :: f_chrom_b_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: low_E_lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_low_E_lat
  type(c_ptr), value :: high_E_lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_high_E_lat
  type(c_ptr), intent(in), value :: low_E_orb
  type(coord_struct_container_alloc), pointer :: f_low_E_orb
  type(c_ptr), intent(in), value :: high_E_orb
  type(coord_struct_container_alloc), pointer :: f_high_E_orb
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: delta_e  ! 0D_NOT_real
  real(c_double) :: f_delta_e
  real(c_double), pointer :: f_delta_e_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! inout: f_delta_e 0D_NOT_real
  if (c_associated(delta_e)) then
    call c_f_pointer(delta_e, f_delta_e_ptr)
  else
    f_delta_e_ptr => null()
  endif
  ! in: f_pz 0D_NOT_real
  if (c_associated(pz)) then
    call c_f_pointer(pz, f_pz_ptr)
  else
    f_pz_ptr => null()
  endif
  ! out: f_low_E_lat 0D_NOT_type
  if (c_associated(low_E_lat))   call c_f_pointer(low_E_lat, f_low_E_lat)
  ! out: f_high_E_lat 0D_NOT_type
  if (c_associated(high_E_lat))   call c_f_pointer(high_E_lat, f_high_E_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(low_E_orb))   call c_f_pointer(low_E_orb, f_low_E_orb)
  !! container type array (1D_ALLOC_type)
  if (c_associated(high_E_orb))   call c_f_pointer(high_E_orb, f_high_E_orb)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_orb0 0D_NOT_type
  if (c_associated(orb0))   call c_f_pointer(orb0, f_orb0)
  call chrom_calc(lat=f_lat, delta_e=f_delta_e_ptr, chrom_a=f_chrom_a, chrom_b=f_chrom_b, &
      err_flag=f_err_flag, pz=f_pz_ptr, low_E_lat=f_low_E_lat, high_E_lat=f_high_E_lat, &
      low_E_orb=f_low_E_orb%data, high_E_orb=f_high_E_orb%data, ix_branch=f_ix_branch_ptr, &
      orb0=f_orb0)

  ! inout: f_delta_e 0D_NOT_real
  ! no output conversion for f_delta_e
  ! out: f_chrom_a 0D_NOT_real
  call c_f_pointer(chrom_a, f_chrom_a_ptr)
  f_chrom_a_ptr = f_chrom_a
  ! out: f_chrom_b 0D_NOT_real
  call c_f_pointer(chrom_b, f_chrom_b_ptr)
  f_chrom_b_ptr = f_chrom_b
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_low_E_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_high_E_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_chrom_tune (lat, delta_e, target_x, target_y, err_tol, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: target_x  ! 0D_NOT_real
  real(rp) :: f_target_x
  real(c_double) :: target_y  ! 0D_NOT_real
  real(rp) :: f_target_y
  real(c_double) :: err_tol  ! 0D_NOT_real
  real(rp) :: f_err_tol
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: delta_e  ! 0D_NOT_real
  real(c_double) :: f_delta_e
  real(c_double), pointer :: f_delta_e_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! inout: f_delta_e 0D_NOT_real
  if (c_associated(delta_e)) then
    call c_f_pointer(delta_e, f_delta_e_ptr)
  else
    f_delta_e_ptr => null()
  endif
  ! in: f_target_x 0D_NOT_real
  f_target_x = target_x
  ! in: f_target_y 0D_NOT_real
  f_target_y = target_y
  ! in: f_err_tol 0D_NOT_real
  f_err_tol = err_tol
  call chrom_tune(lat=f_lat, delta_e=f_delta_e_ptr, target_x=f_target_x, target_y=f_target_y, &
      err_tol=f_err_tol, err_flag=f_err_flag)

  ! inout: f_delta_e 0D_NOT_real
  ! no output conversion for f_delta_e
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_classical_radius (species, radius) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: species  ! 0D_NOT_integer
  integer :: f_species
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: radius  ! 0D_NOT_real
  real(rp) :: f_radius
  real(c_double), pointer :: f_radius_ptr
  ! ** End of parameters **
  ! in: f_species 0D_NOT_integer
  f_species = species
  f_radius = classical_radius(species=f_species)

  ! out: f_radius 0D_NOT_real
  call c_f_pointer(radius, f_radius_ptr)
  f_radius_ptr = f_radius
end subroutine
subroutine fortran_clear_lat_1turn_mats (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! out: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call clear_lat_1turn_mats(lat=f_lat)

  ! out: f_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_clear_taylor_maps_from_elements (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call clear_taylor_maps_from_elements(lat=f_lat)

end subroutine
subroutine fortran_closed_orbit_calc (lat, closed_orb, i_dim, direction, ix_branch, err_flag, &
    print_err) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: i_dim  ! 0D_NOT_integer
  integer(c_int) :: f_i_dim
  integer(c_int), pointer :: f_i_dim_ptr
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: closed_orb
  type(coord_struct_container_alloc), pointer :: f_closed_orb
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(closed_orb))   call c_f_pointer(closed_orb, f_closed_orb)
  ! in: f_i_dim 0D_NOT_integer
  if (c_associated(i_dim)) then
    call c_f_pointer(i_dim, f_i_dim_ptr)
  else
    f_i_dim_ptr => null()
  endif
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call closed_orbit_calc(lat=f_lat, closed_orb=f_closed_orb%data, i_dim=f_i_dim_ptr, &
      direction=f_direction_ptr, ix_branch=f_ix_branch_ptr, err_flag=f_err_flag, &
      print_err=f_print_err_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_closed_orbit_from_tracking (lat, closed_orb, i_dim, eps_rel, eps_abs, &
    init_guess, err_flag) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  integer(c_int) :: i_dim  ! 0D_NOT_integer
  integer :: f_i_dim
  type(c_ptr), intent(in), value :: eps_rel
  type(real_container_alloc), pointer :: f_eps_rel
  type(c_ptr), intent(in), value :: eps_abs
  type(real_container_alloc), pointer :: f_eps_abs
  type(c_ptr), value :: init_guess  ! 0D_NOT_type
  type(coord_struct), pointer :: f_init_guess
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: closed_orb
  type(coord_struct_container_alloc), pointer :: f_closed_orb
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(closed_orb))   call c_f_pointer(closed_orb, f_closed_orb)
  ! in: f_i_dim 0D_NOT_integer
  f_i_dim = i_dim
  !! container general array (1D_ALLOC_real)
  if (c_associated(eps_rel))   call c_f_pointer(eps_rel, f_eps_rel)
  !! container general array (1D_ALLOC_real)
  if (c_associated(eps_abs))   call c_f_pointer(eps_abs, f_eps_abs)
  ! in: f_init_guess 0D_NOT_type
  if (c_associated(init_guess))   call c_f_pointer(init_guess, f_init_guess)
  call closed_orbit_from_tracking(lat=f_lat, closed_orb=f_closed_orb%data, i_dim=f_i_dim, &
      eps_rel=f_eps_rel%data, eps_abs=f_eps_abs%data, init_guess=f_init_guess, &
      err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_cmplx_re_str (cmp, str_out) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str_out
  character(len=4096), target :: f_str_out
  character(kind=c_char), pointer :: f_str_out_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: cmp  ! 0D_NOT_complex
  complex(c_double_complex) :: f_cmp
  complex(c_double_complex), pointer :: f_cmp_ptr
  ! ** End of parameters **
  ! inout: f_cmp 0D_NOT_complex
  if (c_associated(cmp)) then
    call c_f_pointer(cmp, f_cmp_ptr)
  else
    f_cmp_ptr => null()
  endif
  f_str_out = cmplx_re_str(cmp=f_cmp_ptr)

  ! inout: f_cmp 0D_NOT_complex
  ! no output conversion for f_cmp
  ! out: f_str_out 0D_NOT_character
  call c_f_pointer(str_out, f_str_out_ptr, [len_trim(f_str_out) + 1]) ! output-only string
  call to_c_str(f_str_out, f_str_out_ptr)
end subroutine
subroutine fortran_combine_consecutive_elements (lat, error) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call combine_consecutive_elements(lat=f_lat, error=f_error)

  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
end subroutine
subroutine fortran_complex_taylor_clean (complex_taylor) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: complex_taylor  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor
  ! ** End of parameters **
  ! inout: f_complex_taylor 0D_NOT_type
  if (.not. c_associated(complex_taylor)) return
  call c_f_pointer(complex_taylor, f_complex_taylor)
  call complex_taylor_clean(complex_taylor=f_complex_taylor)

end subroutine
subroutine fortran_complex_taylor_equal_complex_taylor (complex_taylor1, complex_taylor2) &
    bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: complex_taylor2  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor2
  ! ** Out parameters **
  type(c_ptr), value :: complex_taylor1  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor1
  ! ** End of parameters **
  ! out: f_complex_taylor1 0D_NOT_type
  if (.not. c_associated(complex_taylor1)) return
  call c_f_pointer(complex_taylor1, f_complex_taylor1)
  ! in: f_complex_taylor2 0D_NOT_type
  if (.not. c_associated(complex_taylor2)) return
  call c_f_pointer(complex_taylor2, f_complex_taylor2)
  call complex_taylor_equal_complex_taylor(complex_taylor1=f_complex_taylor1, &
      complex_taylor2=f_complex_taylor2)

  ! out: f_complex_taylor1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_complex_taylor_exponent_index (expn, index) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: expn
  integer :: f_expn(6)
  integer(c_int), pointer :: f_expn_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: index  ! 0D_NOT_integer
  integer :: f_index
  integer(c_int), pointer :: f_index_ptr
  ! ** End of parameters **
  !! general array (1D_NOT_integer)
  if (c_associated(expn)) then
    call c_f_pointer(expn, f_expn_ptr, [6])
    f_expn = f_expn_ptr(:)
  else
    f_expn_ptr => null()
  endif
  f_index = complex_taylor_exponent_index(expn=f_expn)

  ! out: f_index 0D_NOT_integer
  call c_f_pointer(index, f_index_ptr)
  f_index_ptr = f_index
end subroutine
subroutine fortran_complex_taylor_make_unit (complex_taylor) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: complex_taylor
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor))   call c_f_pointer(complex_taylor, f_complex_taylor)
  call complex_taylor_make_unit(complex_taylor=f_complex_taylor%data)

end subroutine
subroutine fortran_complex_taylor_to_mat6 (a_complex_taylor, r_in, vec0, mat6, r_out) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: a_complex_taylor
  type(complex_taylor_struct), pointer :: f_a_complex_taylor(:)
  type(c_ptr), intent(in), value :: r_in
  type(complex_container_alloc), pointer :: f_r_in
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: vec0
  complex(rp) :: f_vec0(6)
  complex(c_double_complex), pointer :: f_vec0_ptr(:)
  type(c_ptr), intent(in), value :: mat6
  complex(rp) :: f_mat6(6,6)
  complex(c_double_complex), pointer :: f_mat6_ptr(:)
  type(c_ptr), intent(in), value :: r_out
  type(complex_container_alloc), pointer :: f_r_out
  ! ** End of parameters **
  !! type array (1D_NOT_type)
  call c_f_pointer(a_complex_taylor, f_a_complex_taylor, [6])
  !! container general array (1D_ALLOC_complex)
  if (c_associated(r_in))   call c_f_pointer(r_in, f_r_in)
  !! container general array (1D_ALLOC_complex)
  if (c_associated(r_out))   call c_f_pointer(r_out, f_r_out)
  call complex_taylor_to_mat6(a_complex_taylor=f_a_complex_taylor, r_in=f_r_in%data, &
      vec0=f_vec0, mat6=f_mat6, r_out=f_r_out%data)

  ! out: f_vec0 1D_NOT_complex
  if (c_associated(vec0)) then
    call c_f_pointer(vec0, f_vec0_ptr, [6])
    f_vec0_ptr = f_vec0(:)
  endif
  ! out: f_mat6 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=698, definition='complex(rp), intent(out) :: mat6(6,6), vec0(6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent='out', intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='1st order transfer map (6x6 matrix).', doc_data_type='complex', doc_is_optional=False)
end subroutine
subroutine fortran_complex_taylors_equal_complex_taylors (complex_taylor1, complex_taylor2) &
    bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: complex_taylor2
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: complex_taylor1
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor1
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor1))   call c_f_pointer(complex_taylor1, f_complex_taylor1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor2))   call c_f_pointer(complex_taylor2, f_complex_taylor2)
  call complex_taylors_equal_complex_taylors(complex_taylor1=f_complex_taylor1%data, &
      complex_taylor2=f_complex_taylor2%data)

end subroutine
subroutine fortran_compute_slave_coupler (slave) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  ! ** End of parameters **
  ! inout: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  call compute_slave_coupler(slave=f_slave)

end subroutine
subroutine fortran_concat_ele_taylor (orb_taylor, ele, err_flag, spin_taylor) bind(c)

  use bmad_struct, only: ele_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: orb_taylor
  type(taylor_struct_container_alloc), pointer :: f_orb_taylor
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  type(c_ptr), intent(in), value :: spin_taylor
  type(taylor_struct_container_alloc), pointer :: f_spin_taylor
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb_taylor))   call c_f_pointer(orb_taylor, f_orb_taylor)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  !! container type array (1D_ALLOC_type)
  if (c_associated(spin_taylor))   call c_f_pointer(spin_taylor, f_spin_taylor)
  call concat_ele_taylor(orb_taylor=f_orb_taylor%data, ele=f_ele, err_flag=f_err_flag, &
      spin_taylor=f_spin_taylor%data)

end subroutine
subroutine fortran_concat_taylor (taylor1, taylor2, taylor3) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: taylor1
  type(taylor_struct_container_alloc), pointer :: f_taylor1
  type(c_ptr), intent(in), value :: taylor2
  type(taylor_struct_container_alloc), pointer :: f_taylor2
  type(c_ptr), intent(in), value :: taylor3
  type(taylor_struct_container_alloc), pointer :: f_taylor3
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor1))   call c_f_pointer(taylor1, f_taylor1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor2))   call c_f_pointer(taylor2, f_taylor2)
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor3))   call c_f_pointer(taylor3, f_taylor3)
  call concat_taylor(taylor1=f_taylor1%data, taylor2=f_taylor2%data, taylor3=f_taylor3%data)

end subroutine
subroutine fortran_concat_transfer_mat (mat_1, vec_1, mat_0, vec_0, mat_out, vec_out) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: mat_1
  real(rp) :: f_mat_1(6,6)
  real(c_double), pointer :: f_mat_1_ptr(:)
  type(c_ptr), intent(in), value :: mat_0
  real(rp) :: f_mat_0(6,6)
  real(c_double), pointer :: f_mat_0_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat_out
  real(rp) :: f_mat_out(6,6)
  real(c_double), pointer :: f_mat_out_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: vec_1
  real(rp) :: f_vec_1(6)
  real(c_double), pointer :: f_vec_1_ptr(:)
  type(c_ptr), intent(in), value :: vec_0
  real(rp) :: f_vec_0(6)
  real(c_double), pointer :: f_vec_0_ptr(:)
  type(c_ptr), intent(in), value :: vec_out
  real(rp) :: f_vec_out(6)
  real(c_double), pointer :: f_vec_out_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(mat_1)) then
    call c_f_pointer(mat_1, f_mat_1_ptr, [6*6])
    call vec2mat(f_mat_1_ptr, f_mat_1)
  else
    f_mat_1_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(vec_1)) then
    call c_f_pointer(vec_1, f_vec_1_ptr, [6])
    f_vec_1 = f_vec_1_ptr(:)
  else
    f_vec_1_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(mat_0)) then
    call c_f_pointer(mat_0, f_mat_0_ptr, [6*6])
    call vec2mat(f_mat_0_ptr, f_mat_0)
  else
    f_mat_0_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(vec_0)) then
    call c_f_pointer(vec_0, f_vec_0_ptr, [6])
    f_vec_0 = f_vec_0_ptr(:)
  else
    f_vec_0_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(vec_out)) then
    call c_f_pointer(vec_out, f_vec_out_ptr, [6])
    f_vec_out = f_vec_out_ptr(:)
  else
    f_vec_out_ptr => null()
  endif
  call concat_transfer_mat(mat_1=f_mat_1, vec_1=f_vec_1, mat_0=f_mat_0, vec_0=f_vec_0, &
      mat_out=f_mat_out, vec_out=f_vec_out)

  ! out: f_mat_out 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat_out', c_name='mat_out', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=564, definition='real(rp) mat_1(6,6), vec_1(6), mat_0(6,6), vec_0(6), mat_out(6,6), vec_out(6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat_out', comment='', default=None), intent='out', description='Map from s0 to s2', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_control_bookkeeper (lat, ele, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  ! in: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call control_bookkeeper(lat=f_lat, ele=f_ele, err_flag=f_err_flag_native_ptr)

end subroutine
subroutine fortran_convert_bend_exact_multipole (g, out_type, an, bn) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: g  ! 0D_NOT_real
  real(rp) :: f_g
  integer(c_int) :: out_type  ! 0D_NOT_integer
  integer :: f_out_type
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: an
  real(rp) :: f_an(0:n_pole_maxx)
  real(c_double), pointer :: f_an_ptr(:)
  type(c_ptr), intent(in), value :: bn
  real(rp) :: f_bn(0:n_pole_maxx)
  real(c_double), pointer :: f_bn_ptr(:)
  ! ** End of parameters **
  ! in: f_g 0D_NOT_real
  f_g = g
  ! in: f_out_type 0D_NOT_integer
  f_out_type = out_type
  !! general array (1D_NOT_real)
  if (c_associated(an)) then
    call c_f_pointer(an, f_an_ptr, [n_pole_maxx])
    f_an = f_an_ptr(:)
  else
    f_an_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(bn)) then
    call c_f_pointer(bn, f_bn_ptr, [n_pole_maxx])
    f_bn = f_bn_ptr(:)
  else
    f_bn_ptr => null()
  endif
  call convert_bend_exact_multipole(g=f_g, out_type=f_out_type, an=f_an, bn=f_bn)

end subroutine
subroutine fortran_convert_coords (in_type_str, coord_in, ele, out_type_str, coord_out, &
    err_flag) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: in_type_str
  character(len=4096), target :: f_in_type_str
  character(kind=c_char), pointer :: f_in_type_str_ptr(:)
  type(c_ptr), value :: coord_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord_in
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: out_type_str
  character(len=4096), target :: f_out_type_str
  character(kind=c_char), pointer :: f_out_type_str_ptr(:)
  type(c_ptr), value :: coord_out  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord_out
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_in_type_str 0D_NOT_character
  if (.not. c_associated(in_type_str)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(in_type_str, f_in_type_str_ptr, [huge(0)])
  call to_f_str(f_in_type_str_ptr, f_in_type_str)
  ! in: f_coord_in 0D_NOT_type
  if (.not. c_associated(coord_in)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(coord_in, f_coord_in)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! out: f_coord_out 0D_NOT_type
  if (.not. c_associated(coord_out)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(coord_out, f_coord_out)
  call convert_coords(in_type_str=f_in_type_str, coord_in=f_coord_in, ele=f_ele, &
      out_type_str=f_out_type_str, coord_out=f_coord_out, err_flag=f_err_flag)

  ! out: f_out_type_str 0D_NOT_character
  call c_f_pointer(out_type_str, f_out_type_str_ptr, [len_trim(f_out_type_str) + 1]) ! output-only string
  call to_c_str(f_out_type_str, f_out_type_str_ptr)
  ! out: f_coord_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_convert_field_ele_to_lab (ele, s_here, forward_transform, field, &
    calc_dfield, calc_potential) bind(c)

  use bmad_struct, only: ele_struct, em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: s_here  ! 0D_NOT_real
  real(rp) :: f_s_here
  logical(c_bool) :: forward_transform  ! 0D_NOT_logical
  logical :: f_forward_transform
  type(c_ptr), intent(in), value :: calc_dfield  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_dfield
  logical, target :: f_calc_dfield_native
  logical, pointer :: f_calc_dfield_native_ptr
  logical(c_bool), pointer :: f_calc_dfield_ptr
  type(c_ptr), intent(in), value :: calc_potential  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_potential
  logical, target :: f_calc_potential_native
  logical, pointer :: f_calc_potential_native_ptr
  logical(c_bool), pointer :: f_calc_potential_ptr
  ! ** Out parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_s_here 0D_NOT_real
  f_s_here = s_here
  ! in: f_forward_transform 0D_NOT_logical
  f_forward_transform = forward_transform
  ! out: f_field 0D_NOT_type
  if (.not. c_associated(field)) return
  call c_f_pointer(field, f_field)
  ! in: f_calc_dfield 0D_NOT_logical
  if (c_associated(calc_dfield)) then
    call c_f_pointer(calc_dfield, f_calc_dfield_ptr)
    f_calc_dfield_native = f_calc_dfield_ptr
    f_calc_dfield_native_ptr => f_calc_dfield_native
  else
    f_calc_dfield_native_ptr => null()
  endif
  ! in: f_calc_potential 0D_NOT_logical
  if (c_associated(calc_potential)) then
    call c_f_pointer(calc_potential, f_calc_potential_ptr)
    f_calc_potential_native = f_calc_potential_ptr
    f_calc_potential_native_ptr => f_calc_potential_native
  else
    f_calc_potential_native_ptr => null()
  endif
  call convert_field_ele_to_lab(ele=f_ele, s_here=f_s_here, &
      forward_transform=f_forward_transform, field=f_field, &
      calc_dfield=f_calc_dfield_native_ptr, calc_potential=f_calc_potential_native_ptr)

  ! out: f_field 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_convert_local_cartesian_to_local_curvilinear (x, z, g, xout, sout) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(c_double) :: f_z
  real(c_double), pointer :: f_z_ptr
  type(c_ptr), intent(in), value :: g  ! 0D_NOT_real
  real(c_double) :: f_g
  real(c_double), pointer :: f_g_ptr
  type(c_ptr), intent(in), value :: xout  ! 0D_NOT_real
  real(c_double) :: f_xout
  real(c_double), pointer :: f_xout_ptr
  type(c_ptr), intent(in), value :: sout  ! 0D_NOT_real
  real(c_double) :: f_sout
  real(c_double), pointer :: f_sout_ptr
  ! ** End of parameters **
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_z 0D_NOT_real
  if (c_associated(z)) then
    call c_f_pointer(z, f_z_ptr)
  else
    f_z_ptr => null()
  endif
  ! inout: f_g 0D_NOT_real
  if (c_associated(g)) then
    call c_f_pointer(g, f_g_ptr)
  else
    f_g_ptr => null()
  endif
  ! inout: f_xout 0D_NOT_real
  if (c_associated(xout)) then
    call c_f_pointer(xout, f_xout_ptr)
  else
    f_xout_ptr => null()
  endif
  ! inout: f_sout 0D_NOT_real
  if (c_associated(sout)) then
    call c_f_pointer(sout, f_sout_ptr)
  else
    f_sout_ptr => null()
  endif
  call convert_local_cartesian_to_local_curvilinear(x=f_x_ptr, z=f_z_ptr, g=f_g_ptr, &
      xout=f_xout_ptr, sout=f_sout_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_z 0D_NOT_real
  ! no output conversion for f_z
  ! inout: f_g 0D_NOT_real
  ! no output conversion for f_g
  ! inout: f_xout 0D_NOT_real
  ! no output conversion for f_xout
  ! inout: f_sout 0D_NOT_real
  ! no output conversion for f_sout
end subroutine
subroutine fortran_convert_local_curvilinear_to_local_cartesian (x, s, g, xout, zout) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: s  ! 0D_NOT_real
  real(c_double) :: f_s
  real(c_double), pointer :: f_s_ptr
  type(c_ptr), intent(in), value :: g  ! 0D_NOT_real
  real(c_double) :: f_g
  real(c_double), pointer :: f_g_ptr
  type(c_ptr), intent(in), value :: xout  ! 0D_NOT_real
  real(c_double) :: f_xout
  real(c_double), pointer :: f_xout_ptr
  type(c_ptr), intent(in), value :: zout  ! 0D_NOT_real
  real(c_double) :: f_zout
  real(c_double), pointer :: f_zout_ptr
  ! ** End of parameters **
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_s 0D_NOT_real
  if (c_associated(s)) then
    call c_f_pointer(s, f_s_ptr)
  else
    f_s_ptr => null()
  endif
  ! inout: f_g 0D_NOT_real
  if (c_associated(g)) then
    call c_f_pointer(g, f_g_ptr)
  else
    f_g_ptr => null()
  endif
  ! inout: f_xout 0D_NOT_real
  if (c_associated(xout)) then
    call c_f_pointer(xout, f_xout_ptr)
  else
    f_xout_ptr => null()
  endif
  ! inout: f_zout 0D_NOT_real
  if (c_associated(zout)) then
    call c_f_pointer(zout, f_zout_ptr)
  else
    f_zout_ptr => null()
  endif
  call convert_local_curvilinear_to_local_cartesian(x=f_x_ptr, s=f_s_ptr, g=f_g_ptr, &
      xout=f_xout_ptr, zout=f_zout_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_s 0D_NOT_real
  ! no output conversion for f_s
  ! inout: f_g 0D_NOT_real
  ! no output conversion for f_g
  ! inout: f_xout 0D_NOT_real
  ! no output conversion for f_xout
  ! inout: f_zout 0D_NOT_real
  ! no output conversion for f_zout
end subroutine
subroutine fortran_convert_particle_coordinates_s_to_t (particle, s_body, orientation) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: s_body  ! 0D_NOT_real
  real(rp) :: f_s_body
  integer(c_int) :: orientation  ! 0D_NOT_integer
  integer :: f_orientation
  ! ** Inout parameters **
  type(c_ptr), value :: particle  ! 0D_NOT_type
  type(coord_struct), pointer :: f_particle
  ! ** End of parameters **
  ! inout: f_particle 0D_NOT_type
  if (.not. c_associated(particle)) return
  call c_f_pointer(particle, f_particle)
  ! in: f_s_body 0D_NOT_real
  f_s_body = s_body
  ! in: f_orientation 0D_NOT_integer
  f_orientation = orientation
  call convert_particle_coordinates_s_to_t(particle=f_particle, s_body=f_s_body, &
      orientation=f_orientation)

end subroutine
subroutine fortran_convert_particle_coordinates_t_to_s (particle, ele, s_body, &
    use_downstream_p0c) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: use_downstream_p0c  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_downstream_p0c
  logical, target :: f_use_downstream_p0c_native
  logical, pointer :: f_use_downstream_p0c_native_ptr
  logical(c_bool), pointer :: f_use_downstream_p0c_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: s_body  ! 0D_NOT_real
  real(rp) :: f_s_body
  real(c_double), pointer :: f_s_body_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: particle  ! 0D_NOT_type
  type(coord_struct), pointer :: f_particle
  ! ** End of parameters **
  ! inout: f_particle 0D_NOT_type
  if (.not. c_associated(particle)) return
  call c_f_pointer(particle, f_particle)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_use_downstream_p0c 0D_NOT_logical
  if (c_associated(use_downstream_p0c)) then
    call c_f_pointer(use_downstream_p0c, f_use_downstream_p0c_ptr)
    f_use_downstream_p0c_native = f_use_downstream_p0c_ptr
    f_use_downstream_p0c_native_ptr => f_use_downstream_p0c_native
  else
    f_use_downstream_p0c_native_ptr => null()
  endif
  call convert_particle_coordinates_t_to_s(particle=f_particle, ele=f_ele, s_body=f_s_body, &
      use_downstream_p0c=f_use_downstream_p0c_native_ptr)

  ! out: f_s_body 0D_NOT_real
  ! no output conversion for f_s_body
end subroutine
subroutine fortran_convert_pc_to (pc, particle, E_tot, gamma, kinetic, beta, brho, beta1, &
    err_flag) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: pc  ! 0D_NOT_real
  real(rp) :: f_pc
  integer(c_int) :: particle  ! 0D_NOT_integer
  integer :: f_particle
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: E_tot  ! 0D_NOT_real
  real(rp) :: f_E_tot
  real(c_double), pointer :: f_E_tot_ptr
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  type(c_ptr), intent(in), value :: kinetic  ! 0D_NOT_real
  real(rp) :: f_kinetic
  real(c_double), pointer :: f_kinetic_ptr
  type(c_ptr), intent(in), value :: beta  ! 0D_NOT_real
  real(rp) :: f_beta
  real(c_double), pointer :: f_beta_ptr
  type(c_ptr), intent(in), value :: brho  ! 0D_NOT_real
  real(rp) :: f_brho
  real(c_double), pointer :: f_brho_ptr
  type(c_ptr), intent(in), value :: beta1  ! 0D_NOT_real
  real(rp) :: f_beta1
  real(c_double), pointer :: f_beta1_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_pc 0D_NOT_real
  f_pc = pc
  ! in: f_particle 0D_NOT_integer
  f_particle = particle
  call convert_pc_to(pc=f_pc, particle=f_particle, E_tot=f_E_tot, gamma=f_gamma, &
      kinetic=f_kinetic, beta=f_beta, brho=f_brho, beta1=f_beta1, err_flag=f_err_flag)

  ! out: f_E_tot 0D_NOT_real
  ! no output conversion for f_E_tot
  ! out: f_gamma 0D_NOT_real
  ! no output conversion for f_gamma
  ! out: f_kinetic 0D_NOT_real
  ! no output conversion for f_kinetic
  ! out: f_beta 0D_NOT_real
  ! no output conversion for f_beta
  ! out: f_brho 0D_NOT_real
  ! no output conversion for f_brho
  ! out: f_beta1 0D_NOT_real
  ! no output conversion for f_beta1
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_convert_total_energy_to (E_tot, particle, gamma, kinetic, beta, pc, brho, &
    beta1, err_flag, print_err) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: E_tot  ! 0D_NOT_real
  real(rp) :: f_E_tot
  integer(c_int) :: particle  ! 0D_NOT_integer
  integer :: f_particle
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  type(c_ptr), intent(in), value :: kinetic  ! 0D_NOT_real
  real(rp) :: f_kinetic
  real(c_double), pointer :: f_kinetic_ptr
  type(c_ptr), intent(in), value :: beta  ! 0D_NOT_real
  real(rp) :: f_beta
  real(c_double), pointer :: f_beta_ptr
  type(c_ptr), intent(in), value :: pc  ! 0D_NOT_real
  real(rp) :: f_pc
  real(c_double), pointer :: f_pc_ptr
  type(c_ptr), intent(in), value :: brho  ! 0D_NOT_real
  real(rp) :: f_brho
  real(c_double), pointer :: f_brho_ptr
  type(c_ptr), intent(in), value :: beta1  ! 0D_NOT_real
  real(rp) :: f_beta1
  real(c_double), pointer :: f_beta1_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_E_tot 0D_NOT_real
  f_E_tot = E_tot
  ! in: f_particle 0D_NOT_integer
  f_particle = particle
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call convert_total_energy_to(E_tot=f_E_tot, particle=f_particle, gamma=f_gamma, &
      kinetic=f_kinetic, beta=f_beta, pc=f_pc, brho=f_brho, beta1=f_beta1, err_flag=f_err_flag, &
      print_err=f_print_err_native_ptr)

  ! out: f_gamma 0D_NOT_real
  ! no output conversion for f_gamma
  ! out: f_kinetic 0D_NOT_real
  ! no output conversion for f_kinetic
  ! out: f_beta 0D_NOT_real
  ! no output conversion for f_beta
  ! out: f_pc 0D_NOT_real
  ! no output conversion for f_pc
  ! out: f_brho 0D_NOT_real
  ! no output conversion for f_brho
  ! out: f_beta1 0D_NOT_real
  ! no output conversion for f_beta1
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_converter_distribution_parser (ele, delim, delim_found, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical :: f_delim_found
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  call converter_distribution_parser(ele=f_ele, delim=f_delim, delim_found=f_delim_found, &
      err_flag=f_err_flag)

  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_delim_found 0D_NOT_logical
  call c_f_pointer(delim_found, f_delim_found_ptr)
  f_delim_found_ptr = f_delim_found
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_coord_equal_coord (coord1, coord2) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: coord2  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord2
  ! ** Out parameters **
  type(c_ptr), value :: coord1  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord1
  ! ** End of parameters **
  ! out: f_coord1 0D_NOT_type
  if (.not. c_associated(coord1)) return
  call c_f_pointer(coord1, f_coord1)
  ! in: f_coord2 0D_NOT_type
  if (.not. c_associated(coord2)) return
  call c_f_pointer(coord2, f_coord2)
  call coord_equal_coord(coord1=f_coord1, coord2=f_coord2)

  ! out: f_coord1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coord_state_name (coord_state, one_word, state_str) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: coord_state  ! 0D_NOT_integer
  integer :: f_coord_state
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: state_str
  character(len=4096), target :: f_state_str
  character(kind=c_char), pointer :: f_state_str_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: one_word  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_one_word
  logical, target :: f_one_word_native
  logical, pointer :: f_one_word_native_ptr
  logical(c_bool), pointer :: f_one_word_ptr
  ! ** End of parameters **
  ! in: f_coord_state 0D_NOT_integer
  f_coord_state = coord_state
  ! inout: f_one_word 0D_NOT_logical
  if (c_associated(one_word)) then
    call c_f_pointer(one_word, f_one_word_ptr)
    f_one_word_native = f_one_word_ptr
    f_one_word_native_ptr => f_one_word_native
  else
    f_one_word_native_ptr => null()
  endif
  f_state_str = coord_state_name(coord_state=f_coord_state, one_word=f_one_word_native_ptr)

  ! inout: f_one_word 0D_NOT_logical
  if (c_associated(one_word)) then
    call c_f_pointer(one_word, f_one_word_ptr)
    f_one_word_ptr = f_one_word_native
  else
    ! f_one_word unset
  endif
  ! out: f_state_str 0D_NOT_character
  call c_f_pointer(state_str, f_state_str_ptr, [len_trim(f_state_str) + 1]) ! output-only string
  call to_c_str(f_state_str, f_state_str_ptr)
end subroutine
subroutine fortran_coords_body_to_local (body_position, ele, w_mat, calculate_angles, &
    local_position) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: body_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_body_position
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), intent(in), value :: calculate_angles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calculate_angles
  logical, target :: f_calculate_angles_native
  logical, pointer :: f_calculate_angles_native_ptr
  logical(c_bool), pointer :: f_calculate_angles_ptr
  ! ** Out parameters **
  type(c_ptr), value :: local_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_position
  ! ** End of parameters **
  ! in: f_body_position 0D_NOT_type
  if (.not. c_associated(body_position)) return
  call c_f_pointer(body_position, f_body_position)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! general array (2D_NOT_real)
  if (c_associated(w_mat)) then
    call c_f_pointer(w_mat, f_w_mat_ptr, [3*3])
    call vec2mat(f_w_mat_ptr, f_w_mat)
  else
    f_w_mat_ptr => null()
  endif
  ! in: f_calculate_angles 0D_NOT_logical
  if (c_associated(calculate_angles)) then
    call c_f_pointer(calculate_angles, f_calculate_angles_ptr)
    f_calculate_angles_native = f_calculate_angles_ptr
    f_calculate_angles_native_ptr => f_calculate_angles_native
  else
    f_calculate_angles_native_ptr => null()
  endif
  f_local_position = coords_body_to_local(body_position=f_body_position, ele=f_ele, &
      w_mat=f_w_mat, calculate_angles=f_calculate_angles_native_ptr)

  ! out: f_local_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_body_to_rel_exit (body_position, ele, w_mat, calculate_angles, &
    rel_exit) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: body_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_body_position
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), intent(in), value :: calculate_angles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calculate_angles
  logical, target :: f_calculate_angles_native
  logical, pointer :: f_calculate_angles_native_ptr
  logical(c_bool), pointer :: f_calculate_angles_ptr
  ! ** Out parameters **
  type(c_ptr), value :: rel_exit  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_rel_exit
  ! ** End of parameters **
  ! in: f_body_position 0D_NOT_type
  if (.not. c_associated(body_position)) return
  call c_f_pointer(body_position, f_body_position)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! general array (2D_NOT_real)
  if (c_associated(w_mat)) then
    call c_f_pointer(w_mat, f_w_mat_ptr, [3*3])
    call vec2mat(f_w_mat_ptr, f_w_mat)
  else
    f_w_mat_ptr => null()
  endif
  ! in: f_calculate_angles 0D_NOT_logical
  if (c_associated(calculate_angles)) then
    call c_f_pointer(calculate_angles, f_calculate_angles_ptr)
    f_calculate_angles_native = f_calculate_angles_ptr
    f_calculate_angles_native_ptr => f_calculate_angles_native
  else
    f_calculate_angles_native_ptr => null()
  endif
  f_rel_exit = coords_body_to_rel_exit(body_position=f_body_position, ele=f_ele, w_mat=f_w_mat, &
      calculate_angles=f_calculate_angles_native_ptr)

  ! out: f_rel_exit 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_curvilinear_to_floor (xys, branch, err_flag, global) bind(c)

  use bmad_struct, only: branch_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: xys
  real(rp) :: f_xys(3)
  real(c_double), pointer :: f_xys_ptr(:)
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: global  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_global
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(xys)) then
    call c_f_pointer(xys, f_xys_ptr, [3])
    f_xys = f_xys_ptr(:)
  else
    f_xys_ptr => null()
  endif
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(branch, f_branch)
  f_global = coords_curvilinear_to_floor(xys=f_xys, branch=f_branch, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_global 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_floor_to_curvilinear (floor_coords, ele0, ele1, status, w_mat, &
    local_coords) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: floor_coords  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor_coords
  type(c_ptr), value :: ele0  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele0
  ! ** Out parameters **
  type(c_ptr), value :: ele1  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), intent(in), value :: status  ! 0D_NOT_integer
  integer :: f_status
  integer(c_int), pointer :: f_status_ptr
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), value :: local_coords  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_coords
  ! ** End of parameters **
  ! in: f_floor_coords 0D_NOT_type
  if (.not. c_associated(floor_coords)) return
  call c_f_pointer(floor_coords, f_floor_coords)
  ! in: f_ele0 0D_NOT_type
  if (.not. c_associated(ele0)) return
  call c_f_pointer(ele0, f_ele0)
  ! out: f_ele1 0D_PTR_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  f_local_coords = coords_floor_to_curvilinear(floor_coords=f_floor_coords, ele0=f_ele0, &
      ele1=f_ele1, status=f_status, w_mat=f_w_mat)

  ! out: f_ele1 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_status 0D_NOT_integer
  call c_f_pointer(status, f_status_ptr)
  f_status_ptr = f_status
  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=739, definition='real(rp), optional :: w_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='out', description='W matrix at s, to transform vectors from floor to local. w_mat will only be well defined if status = ok$', doc_data_type='float', doc_is_optional=False)
  ! out: f_local_coords 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_floor_to_local_curvilinear (global_position, ele, status, w_mat, &
    relative_to, local_position) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: global_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_global_position
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: relative_to  ! 0D_NOT_integer
  integer(c_int) :: f_relative_to
  integer(c_int), pointer :: f_relative_to_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: status  ! 0D_NOT_integer
  integer :: f_status
  integer(c_int), pointer :: f_status_ptr
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), value :: local_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_position
  ! ** End of parameters **
  ! in: f_global_position 0D_NOT_type
  if (.not. c_associated(global_position)) return
  call c_f_pointer(global_position, f_global_position)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_relative_to 0D_NOT_integer
  if (c_associated(relative_to)) then
    call c_f_pointer(relative_to, f_relative_to_ptr)
  else
    f_relative_to_ptr => null()
  endif
  f_local_position = coords_floor_to_local_curvilinear(global_position=f_global_position, &
      ele=f_ele, status=f_status, w_mat=f_w_mat, relative_to=f_relative_to_ptr)

  ! out: f_status 0D_NOT_integer
  call c_f_pointer(status, f_status_ptr)
  f_status_ptr = f_status
  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=727, definition='real(rp), optional :: w_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='out', description='W matrix at s, to transform vectors. v_global = w_mat.v_local v_local = transpose(w_mat).v_global', doc_data_type='float', doc_is_optional=False)
  ! out: f_local_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_floor_to_relative (floor0, global_position, calculate_angles, &
    is_delta_position, local_position) bind(c)

  use bmad_struct, only: floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: floor0  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor0
  type(c_ptr), value :: global_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_global_position
  type(c_ptr), intent(in), value :: calculate_angles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calculate_angles
  logical, target :: f_calculate_angles_native
  logical, pointer :: f_calculate_angles_native_ptr
  logical(c_bool), pointer :: f_calculate_angles_ptr
  type(c_ptr), intent(in), value :: is_delta_position  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_delta_position
  logical, target :: f_is_delta_position_native
  logical, pointer :: f_is_delta_position_native_ptr
  logical(c_bool), pointer :: f_is_delta_position_ptr
  ! ** Out parameters **
  type(c_ptr), value :: local_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_position
  ! ** End of parameters **
  ! in: f_floor0 0D_NOT_type
  if (.not. c_associated(floor0)) return
  call c_f_pointer(floor0, f_floor0)
  ! in: f_global_position 0D_NOT_type
  if (.not. c_associated(global_position)) return
  call c_f_pointer(global_position, f_global_position)
  ! in: f_calculate_angles 0D_NOT_logical
  if (c_associated(calculate_angles)) then
    call c_f_pointer(calculate_angles, f_calculate_angles_ptr)
    f_calculate_angles_native = f_calculate_angles_ptr
    f_calculate_angles_native_ptr => f_calculate_angles_native
  else
    f_calculate_angles_native_ptr => null()
  endif
  ! in: f_is_delta_position 0D_NOT_logical
  if (c_associated(is_delta_position)) then
    call c_f_pointer(is_delta_position, f_is_delta_position_ptr)
    f_is_delta_position_native = f_is_delta_position_ptr
    f_is_delta_position_native_ptr => f_is_delta_position_native
  else
    f_is_delta_position_native_ptr => null()
  endif
  f_local_position = coords_floor_to_relative(floor0=f_floor0, &
      global_position=f_global_position, calculate_angles=f_calculate_angles_native_ptr, &
      is_delta_position=f_is_delta_position_native_ptr)

  ! out: f_local_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_local_curvilinear_to_body (local_position, ele, w_mat, &
    calculate_angles, body_position) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: local_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_position
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), intent(in), value :: calculate_angles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calculate_angles
  logical, target :: f_calculate_angles_native
  logical, pointer :: f_calculate_angles_native_ptr
  logical(c_bool), pointer :: f_calculate_angles_ptr
  ! ** Out parameters **
  type(c_ptr), value :: body_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_body_position
  ! ** End of parameters **
  ! in: f_local_position 0D_NOT_type
  if (.not. c_associated(local_position)) return
  call c_f_pointer(local_position, f_local_position)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! general array (2D_NOT_real)
  if (c_associated(w_mat)) then
    call c_f_pointer(w_mat, f_w_mat_ptr, [3*3])
    call vec2mat(f_w_mat_ptr, f_w_mat)
  else
    f_w_mat_ptr => null()
  endif
  ! in: f_calculate_angles 0D_NOT_logical
  if (c_associated(calculate_angles)) then
    call c_f_pointer(calculate_angles, f_calculate_angles_ptr)
    f_calculate_angles_native = f_calculate_angles_ptr
    f_calculate_angles_native_ptr => f_calculate_angles_native
  else
    f_calculate_angles_native_ptr => null()
  endif
  f_body_position = coords_local_curvilinear_to_body(local_position=f_local_position, &
      ele=f_ele, w_mat=f_w_mat, calculate_angles=f_calculate_angles_native_ptr)

  ! out: f_body_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_local_curvilinear_to_floor (local_position, ele, in_body_frame, &
    w_mat, calculate_angles, relative_to, global_position) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: local_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_position
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: in_body_frame  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_in_body_frame
  logical, target :: f_in_body_frame_native
  logical, pointer :: f_in_body_frame_native_ptr
  logical(c_bool), pointer :: f_in_body_frame_ptr
  type(c_ptr), intent(in), value :: calculate_angles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calculate_angles
  logical, target :: f_calculate_angles_native
  logical, pointer :: f_calculate_angles_native_ptr
  logical(c_bool), pointer :: f_calculate_angles_ptr
  type(c_ptr), intent(in), value :: relative_to  ! 0D_NOT_integer
  integer(c_int) :: f_relative_to
  integer(c_int), pointer :: f_relative_to_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), value :: global_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_global_position
  ! ** End of parameters **
  ! in: f_local_position 0D_NOT_type
  if (.not. c_associated(local_position)) return
  call c_f_pointer(local_position, f_local_position)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_in_body_frame 0D_NOT_logical
  if (c_associated(in_body_frame)) then
    call c_f_pointer(in_body_frame, f_in_body_frame_ptr)
    f_in_body_frame_native = f_in_body_frame_ptr
    f_in_body_frame_native_ptr => f_in_body_frame_native
  else
    f_in_body_frame_native_ptr => null()
  endif
  ! in: f_calculate_angles 0D_NOT_logical
  if (c_associated(calculate_angles)) then
    call c_f_pointer(calculate_angles, f_calculate_angles_ptr)
    f_calculate_angles_native = f_calculate_angles_ptr
    f_calculate_angles_native_ptr => f_calculate_angles_native
  else
    f_calculate_angles_native_ptr => null()
  endif
  ! in: f_relative_to 0D_NOT_integer
  if (c_associated(relative_to)) then
    call c_f_pointer(relative_to, f_relative_to_ptr)
  else
    f_relative_to_ptr => null()
  endif
  f_global_position = coords_local_curvilinear_to_floor(local_position=f_local_position, &
      ele=f_ele, in_body_frame=f_in_body_frame_native_ptr, w_mat=f_w_mat, &
      calculate_angles=f_calculate_angles_native_ptr, relative_to=f_relative_to_ptr)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=757, definition='real(rp), optional :: w_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='out', description='W matrix at z, to transform vectors. v_global     = w_mat . v_local/body v_local/body = transpose(w_mat) . v_global', doc_data_type='float', doc_is_optional=False)
  ! out: f_global_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coords_relative_to_floor (floor0, dr, theta, phi, psi, floor1) bind(c)

  use bmad_struct, only: floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: floor0  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor0
  type(c_ptr), intent(in), value :: dr
  real(rp) :: f_dr(3)
  real(c_double), pointer :: f_dr_ptr(:)
  ! ** Out parameters **
  type(c_ptr), value :: floor1  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor1
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: theta  ! 0D_NOT_real
  real(c_double) :: f_theta
  real(c_double), pointer :: f_theta_ptr
  type(c_ptr), intent(in), value :: phi  ! 0D_NOT_real
  real(c_double) :: f_phi
  real(c_double), pointer :: f_phi_ptr
  type(c_ptr), intent(in), value :: psi  ! 0D_NOT_real
  real(c_double) :: f_psi
  real(c_double), pointer :: f_psi_ptr
  ! ** End of parameters **
  ! in: f_floor0 0D_NOT_type
  if (.not. c_associated(floor0)) return
  call c_f_pointer(floor0, f_floor0)
  !! general array (1D_NOT_real)
  if (c_associated(dr)) then
    call c_f_pointer(dr, f_dr_ptr, [3])
    f_dr = f_dr_ptr(:)
  else
    f_dr_ptr => null()
  endif
  ! inout: f_theta 0D_NOT_real
  if (c_associated(theta)) then
    call c_f_pointer(theta, f_theta_ptr)
  else
    f_theta_ptr => null()
  endif
  ! inout: f_phi 0D_NOT_real
  if (c_associated(phi)) then
    call c_f_pointer(phi, f_phi_ptr)
  else
    f_phi_ptr => null()
  endif
  ! inout: f_psi 0D_NOT_real
  if (c_associated(psi)) then
    call c_f_pointer(psi, f_psi_ptr)
  else
    f_psi_ptr => null()
  endif
  f_floor1 = coords_relative_to_floor(floor0=f_floor0, dr=f_dr, theta=f_theta_ptr, &
      phi=f_phi_ptr, psi=f_psi_ptr)

  ! inout: f_theta 0D_NOT_real
  ! no output conversion for f_theta
  ! inout: f_phi 0D_NOT_real
  ! no output conversion for f_phi
  ! inout: f_psi 0D_NOT_real
  ! no output conversion for f_psi
  ! out: f_floor1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_coulombfun (u, v, w, gam, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: u  ! 0D_NOT_real
  real(c_double) :: f_u
  real(c_double), pointer :: f_u_ptr
  type(c_ptr), intent(in), value :: v  ! 0D_NOT_real
  real(c_double) :: f_v
  real(c_double), pointer :: f_v_ptr
  type(c_ptr), intent(in), value :: w  ! 0D_NOT_real
  real(c_double) :: f_w
  real(c_double), pointer :: f_w_ptr
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  ! ** End of parameters **
  ! inout: f_u 0D_NOT_real
  if (c_associated(u)) then
    call c_f_pointer(u, f_u_ptr)
  else
    f_u_ptr => null()
  endif
  ! inout: f_v 0D_NOT_real
  if (c_associated(v)) then
    call c_f_pointer(v, f_v_ptr)
  else
    f_v_ptr => null()
  endif
  ! inout: f_w 0D_NOT_real
  if (c_associated(w)) then
    call c_f_pointer(w, f_w_ptr)
  else
    f_w_ptr => null()
  endif
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  f_res = coulombfun(u=f_u_ptr, v=f_v_ptr, w=f_w_ptr, gam=f_gam_ptr)

  ! inout: f_u 0D_NOT_real
  ! no output conversion for f_u
  ! inout: f_v 0D_NOT_real
  ! no output conversion for f_v
  ! inout: f_w 0D_NOT_real
  ! no output conversion for f_w
  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_create_concatenated_wall3d (lat, err) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err
  logical, target :: f_err_native
  logical, pointer :: f_err_native_ptr
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_native = f_err_ptr
    f_err_native_ptr => f_err_native
  else
    f_err_native_ptr => null()
  endif
  call create_concatenated_wall3d(lat=f_lat, err=f_err_native_ptr)

  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_ptr = f_err_native
  else
    ! f_err unset
  endif
end subroutine
subroutine fortran_create_element_slice (sliced_ele, ele_in, l_slice, offset, param, &
    include_upstream_end, include_downstream_end, err_flag, old_slice, orb_in) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_in
  real(c_double) :: l_slice  ! 0D_NOT_real
  real(rp) :: f_l_slice
  real(c_double) :: offset  ! 0D_NOT_real
  real(rp) :: f_offset
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  logical(c_bool) :: include_upstream_end  ! 0D_NOT_logical
  logical :: f_include_upstream_end
  logical(c_bool) :: include_downstream_end  ! 0D_NOT_logical
  logical :: f_include_downstream_end
  type(c_ptr), value :: old_slice  ! 0D_NOT_type
  type(ele_struct), pointer :: f_old_slice
  type(c_ptr), value :: orb_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_in
  ! ** Out parameters **
  type(c_ptr), value :: sliced_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_sliced_ele
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! out: f_sliced_ele 0D_NOT_type
  if (.not. c_associated(sliced_ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(sliced_ele, f_sliced_ele)
  ! in: f_ele_in 0D_NOT_type
  if (.not. c_associated(ele_in)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele_in, f_ele_in)
  ! in: f_l_slice 0D_NOT_real
  f_l_slice = l_slice
  ! in: f_offset 0D_NOT_real
  f_offset = offset
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_include_upstream_end 0D_NOT_logical
  f_include_upstream_end = include_upstream_end
  ! in: f_include_downstream_end 0D_NOT_logical
  f_include_downstream_end = include_downstream_end
  ! in: f_old_slice 0D_NOT_type
  if (c_associated(old_slice))   call c_f_pointer(old_slice, f_old_slice)
  ! in: f_orb_in 0D_NOT_type
  if (c_associated(orb_in))   call c_f_pointer(orb_in, f_orb_in)
  call create_element_slice(sliced_ele=f_sliced_ele, ele_in=f_ele_in, l_slice=f_l_slice, &
      offset=f_offset, param=f_param, include_upstream_end=f_include_upstream_end, &
      include_downstream_end=f_include_downstream_end, err_flag=f_err_flag, &
      old_slice=f_old_slice, orb_in=f_orb_in)

  ! out: f_sliced_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_create_field_overlap (lat, lord_name, slave_name, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: lord_name
  character(len=4096), target :: f_lord_name
  character(kind=c_char), pointer :: f_lord_name_ptr(:)
  type(c_ptr), intent(in), value :: slave_name
  character(len=4096), target :: f_slave_name
  character(kind=c_char), pointer :: f_slave_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_lord_name 0D_NOT_character
  if (.not. c_associated(lord_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lord_name, f_lord_name_ptr, [huge(0)])
  call to_f_str(f_lord_name_ptr, f_lord_name)
  ! in: f_slave_name 0D_NOT_character
  if (.not. c_associated(slave_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(slave_name, f_slave_name_ptr, [huge(0)])
  call to_f_str(f_slave_name_ptr, f_slave_name)
  call create_field_overlap(lat=f_lat, lord_name=f_lord_name, slave_name=f_slave_name, &
      err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_create_girder (lat, ix_girder, contrl, girder_info, err_flag) bind(c)

  use bmad_struct, only: control_struct, ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: ix_girder  ! 0D_NOT_integer
  integer :: f_ix_girder
  type(c_ptr), intent(in), value :: contrl
  type(control_struct_container_alloc), pointer :: f_contrl
  type(c_ptr), value :: girder_info  ! 0D_NOT_type
  type(ele_struct), pointer :: f_girder_info
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_girder 0D_NOT_integer
  f_ix_girder = ix_girder
  !! container type array (1D_ALLOC_type)
  if (c_associated(contrl))   call c_f_pointer(contrl, f_contrl)
  ! in: f_girder_info 0D_NOT_type
  if (.not. c_associated(girder_info)) return
  call c_f_pointer(girder_info, f_girder_info)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call create_girder(lat=f_lat, ix_girder=f_ix_girder, contrl=f_contrl%data, &
      girder_info=f_girder_info, err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_create_group (lord, contrl, err) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: contrl
  type(control_struct_container_alloc), pointer :: f_contrl
  logical(c_bool) :: err  ! 0D_NOT_logical
  logical :: f_err
  ! ** Inout parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  ! ** End of parameters **
  ! inout: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  !! container type array (1D_ALLOC_type)
  if (c_associated(contrl))   call c_f_pointer(contrl, f_contrl)
  ! in: f_err 0D_NOT_logical
  f_err = err
  call create_group(lord=f_lord, contrl=f_contrl%data, err=f_err)

end subroutine
subroutine fortran_create_lat_ele_nametable (lat, nametable) bind(c)

  use bmad_struct, only: lat_struct
  use sim_utils_struct, only: nametable_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: nametable  ! 0D_NOT_type
  type(nametable_struct), pointer :: f_nametable
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_nametable 0D_NOT_type
  if (.not. c_associated(nametable)) return
  call c_f_pointer(nametable, f_nametable)
  call create_lat_ele_nametable(lat=f_lat, nametable=f_nametable)

end subroutine
subroutine fortran_create_overlay (lord, contrl, err) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: contrl
  type(control_struct_container_alloc), pointer :: f_contrl
  logical(c_bool) :: err  ! 0D_NOT_logical
  logical :: f_err
  ! ** Inout parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  ! ** End of parameters **
  ! inout: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  !! container type array (1D_ALLOC_type)
  if (c_associated(contrl))   call c_f_pointer(contrl, f_contrl)
  ! in: f_err 0D_NOT_logical
  f_err = err
  call create_overlay(lord=f_lord, contrl=f_contrl%data, err=f_err)

end subroutine
subroutine fortran_create_planar_wiggler_model (wiggler_in, lat, err_flag, print_err) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: wiggler_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_wiggler_in
  ! ** End of parameters **
  ! inout: f_wiggler_in 0D_NOT_type
  if (.not. c_associated(wiggler_in)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(wiggler_in, f_wiggler_in)
  ! out: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call create_planar_wiggler_model(wiggler_in=f_wiggler_in, lat=f_lat, err_flag=f_err_flag, &
      print_err=f_print_err_native_ptr)

  ! out: f_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_create_ramper (lord, contrl, err) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: contrl
  type(control_struct_container_alloc), pointer :: f_contrl
  logical(c_bool) :: err  ! 0D_NOT_logical
  logical :: f_err
  ! ** Inout parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  ! ** End of parameters **
  ! inout: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  !! container type array (1D_ALLOC_type)
  if (c_associated(contrl))   call c_f_pointer(contrl, f_contrl)
  ! in: f_err 0D_NOT_logical
  f_err = err
  call create_ramper(lord=f_lord, contrl=f_contrl%data, err=f_err)

end subroutine
subroutine fortran_create_sol_quad_model (sol_quad, lat) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: sol_quad  ! 0D_NOT_type
  type(ele_struct), pointer :: f_sol_quad
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_sol_quad 0D_NOT_type
  if (.not. c_associated(sol_quad)) return
  call c_f_pointer(sol_quad, f_sol_quad)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call create_sol_quad_model(sol_quad=f_sol_quad, lat=f_lat)

end subroutine
subroutine fortran_create_unique_ele_names (lat, key, suffix) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: key  ! 0D_NOT_integer
  integer :: f_key
  type(c_ptr), intent(in), value :: suffix
  character(len=4096), target :: f_suffix
  character(kind=c_char), pointer :: f_suffix_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_key 0D_NOT_integer
  f_key = key
  ! in: f_suffix 0D_NOT_character
  if (.not. c_associated(suffix)) return
  call c_f_pointer(suffix, f_suffix_ptr, [huge(0)])
  call to_f_str(f_suffix_ptr, f_suffix)
  call create_unique_ele_names(lat=f_lat, key=f_key, suffix=f_suffix)

end subroutine
subroutine fortran_create_wiggler_cartesian_map (ele, cart_map) bind(c)

  use bmad_struct, only: cartesian_map_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: cart_map  ! 0D_NOT_type
  type(cartesian_map_struct), pointer :: f_cart_map
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_cart_map 0D_NOT_type
  if (.not. c_associated(cart_map)) return
  call c_f_pointer(cart_map, f_cart_map)
  call create_wiggler_cartesian_map(ele=f_ele, cart_map=f_cart_map)

  ! out: f_cart_map 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_crystal_attribute_bookkeeper (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call crystal_attribute_bookkeeper(ele=f_ele)

end subroutine
subroutine fortran_crystal_h_misalign (ele, orbit, h_vec) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: h_vec
  real(rp) :: f_h_vec(3)
  real(c_double), pointer :: f_h_vec_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (1D_NOT_real)
  if (c_associated(h_vec)) then
    call c_f_pointer(h_vec, f_h_vec_ptr, [3])
    f_h_vec = f_h_vec_ptr(:)
  else
    f_h_vec_ptr => null()
  endif
  call crystal_h_misalign(ele=f_ele, orbit=f_orbit, h_vec=f_h_vec)

end subroutine
subroutine fortran_crystal_type_to_crystal_params (ele, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  call crystal_type_to_crystal_params(ele=f_ele, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_custom_attribute_ubound_index (ele_class, ix_ubound) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: ele_class  ! 0D_NOT_integer
  integer :: f_ele_class
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_ubound  ! 0D_NOT_integer
  integer :: f_ix_ubound
  integer(c_int), pointer :: f_ix_ubound_ptr
  ! ** End of parameters **
  ! in: f_ele_class 0D_NOT_integer
  f_ele_class = ele_class
  f_ix_ubound = custom_attribute_ubound_index(ele_class=f_ele_class)

  ! out: f_ix_ubound 0D_NOT_integer
  call c_f_pointer(ix_ubound, f_ix_ubound_ptr)
  f_ix_ubound_ptr = f_ix_ubound
end subroutine
subroutine fortran_damping_matrix_d (gamma, g_tot, B0, B1, delta, species, mat) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat
  real(rp) :: f_mat(6,6)
  real(c_double), pointer :: f_mat_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(c_double) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  type(c_ptr), intent(in), value :: g_tot  ! 0D_NOT_real
  real(c_double) :: f_g_tot
  real(c_double), pointer :: f_g_tot_ptr
  type(c_ptr), intent(in), value :: B0  ! 0D_NOT_real
  real(c_double) :: f_B0
  real(c_double), pointer :: f_B0_ptr
  type(c_ptr), intent(in), value :: B1  ! 0D_NOT_real
  real(c_double) :: f_B1
  real(c_double), pointer :: f_B1_ptr
  type(c_ptr), intent(in), value :: delta  ! 0D_NOT_real
  real(c_double) :: f_delta
  real(c_double), pointer :: f_delta_ptr
  type(c_ptr), intent(in), value :: species  ! 0D_NOT_integer
  integer(c_int) :: f_species
  integer(c_int), pointer :: f_species_ptr
  ! ** End of parameters **
  ! inout: f_gamma 0D_NOT_real
  if (c_associated(gamma)) then
    call c_f_pointer(gamma, f_gamma_ptr)
  else
    f_gamma_ptr => null()
  endif
  ! inout: f_g_tot 0D_NOT_real
  if (c_associated(g_tot)) then
    call c_f_pointer(g_tot, f_g_tot_ptr)
  else
    f_g_tot_ptr => null()
  endif
  ! inout: f_B0 0D_NOT_real
  if (c_associated(B0)) then
    call c_f_pointer(B0, f_B0_ptr)
  else
    f_B0_ptr => null()
  endif
  ! inout: f_B1 0D_NOT_real
  if (c_associated(B1)) then
    call c_f_pointer(B1, f_B1_ptr)
  else
    f_B1_ptr => null()
  endif
  ! inout: f_delta 0D_NOT_real
  if (c_associated(delta)) then
    call c_f_pointer(delta, f_delta_ptr)
  else
    f_delta_ptr => null()
  endif
  ! inout: f_species 0D_NOT_integer
  if (c_associated(species)) then
    call c_f_pointer(species, f_species_ptr)
  else
    f_species_ptr => null()
  endif
  f_mat = damping_matrix_d(gamma=f_gamma_ptr, g_tot=f_g_tot_ptr, B0=f_B0_ptr, B1=f_B1_ptr, &
      delta=f_delta_ptr, species=f_species_ptr)

  ! inout: f_gamma 0D_NOT_real
  ! no output conversion for f_gamma
  ! inout: f_g_tot 0D_NOT_real
  ! no output conversion for f_g_tot
  ! inout: f_B0 0D_NOT_real
  ! no output conversion for f_B0
  ! inout: f_B1 0D_NOT_real
  ! no output conversion for f_B1
  ! inout: f_delta 0D_NOT_real
  ! no output conversion for f_delta
  ! inout: f_species 0D_NOT_integer
  ! no output conversion for f_species
  ! out: f_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat', c_name='mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=150, definition='real(rp) mat(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_deallocate_ele_pointers (ele, nullify_only, nullify_branch, dealloc_poles) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: nullify_only  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_nullify_only
  logical, target :: f_nullify_only_native
  logical, pointer :: f_nullify_only_native_ptr
  logical(c_bool), pointer :: f_nullify_only_ptr
  type(c_ptr), intent(in), value :: nullify_branch  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_nullify_branch
  logical, target :: f_nullify_branch_native
  logical, pointer :: f_nullify_branch_native_ptr
  logical(c_bool), pointer :: f_nullify_branch_ptr
  type(c_ptr), intent(in), value :: dealloc_poles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_dealloc_poles
  logical, target :: f_dealloc_poles_native
  logical, pointer :: f_dealloc_poles_native_ptr
  logical(c_bool), pointer :: f_dealloc_poles_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_nullify_only 0D_NOT_logical
  if (c_associated(nullify_only)) then
    call c_f_pointer(nullify_only, f_nullify_only_ptr)
    f_nullify_only_native = f_nullify_only_ptr
    f_nullify_only_native_ptr => f_nullify_only_native
  else
    f_nullify_only_native_ptr => null()
  endif
  ! in: f_nullify_branch 0D_NOT_logical
  if (c_associated(nullify_branch)) then
    call c_f_pointer(nullify_branch, f_nullify_branch_ptr)
    f_nullify_branch_native = f_nullify_branch_ptr
    f_nullify_branch_native_ptr => f_nullify_branch_native
  else
    f_nullify_branch_native_ptr => null()
  endif
  ! in: f_dealloc_poles 0D_NOT_logical
  if (c_associated(dealloc_poles)) then
    call c_f_pointer(dealloc_poles, f_dealloc_poles_ptr)
    f_dealloc_poles_native = f_dealloc_poles_ptr
    f_dealloc_poles_native_ptr => f_dealloc_poles_native
  else
    f_dealloc_poles_native_ptr => null()
  endif
  call deallocate_ele_pointers(ele=f_ele, nullify_only=f_nullify_only_native_ptr, &
      nullify_branch=f_nullify_branch_native_ptr, dealloc_poles=f_dealloc_poles_native_ptr)

end subroutine
subroutine fortran_deallocate_expression_tree (tree) bind(c)

  use bmad_struct, only: expression_tree_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: tree  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_tree
  ! ** End of parameters **
  ! inout: f_tree 0D_NOT_type
  if (.not. c_associated(tree)) return
  call c_f_pointer(tree, f_tree)
  call deallocate_expression_tree(tree=f_tree)

end subroutine
subroutine fortran_deallocate_lat_pointers (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call deallocate_lat_pointers(lat=f_lat)

end subroutine
subroutine fortran_deallocate_tree (tree) bind(c)

  use bmad_struct, only: expression_tree_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: tree  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_tree
  ! ** End of parameters **
  ! inout: f_tree 0D_NOT_type
  if (.not. c_associated(tree)) return
  call c_f_pointer(tree, f_tree)
  call deallocate_tree(tree=f_tree)

end subroutine
subroutine fortran_default_tracking_species (param, species) bind(c)

  use bmad_struct, only: lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: species  ! 0D_NOT_integer
  integer :: f_species
  integer(c_int), pointer :: f_species_ptr
  ! ** End of parameters **
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  f_species = default_tracking_species(param=f_param)

  ! out: f_species 0D_NOT_integer
  call c_f_pointer(species, f_species_ptr)
  f_species_ptr = f_species
end subroutine
subroutine fortran_detector_pixel_pt (orbit, ele, ix_pix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_pix
  integer :: f_ix_pix(2)
  integer(c_int), pointer :: f_ix_pix_ptr(:)
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_ix_pix = detector_pixel_pt(orbit=f_orbit, ele=f_ele)

  ! out: f_ix_pix 1D_NOT_integer
  if (c_associated(ix_pix)) then
    call c_f_pointer(ix_pix, f_ix_pix_ptr, [2])
    f_ix_pix_ptr = f_ix_pix(:)
  endif
end subroutine
subroutine fortran_diffraction_plate_or_mask_hit_spot (ele, orbit, ix_section) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_section  ! 0D_NOT_integer
  integer :: f_ix_section
  integer(c_int), pointer :: f_ix_section_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  f_ix_section = diffraction_plate_or_mask_hit_spot(ele=f_ele, orbit=f_orbit)

  ! out: f_ix_section 0D_NOT_integer
  call c_f_pointer(ix_section, f_ix_section_ptr)
  f_ix_section_ptr = f_ix_section
end subroutine
subroutine fortran_diffusion_matrix_b (gamma, g_tot, species, mat) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat
  real(rp) :: f_mat(6,6)
  real(c_double), pointer :: f_mat_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(c_double) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  type(c_ptr), intent(in), value :: g_tot  ! 0D_NOT_real
  real(c_double) :: f_g_tot
  real(c_double), pointer :: f_g_tot_ptr
  type(c_ptr), intent(in), value :: species  ! 0D_NOT_integer
  integer(c_int) :: f_species
  integer(c_int), pointer :: f_species_ptr
  ! ** End of parameters **
  ! inout: f_gamma 0D_NOT_real
  if (c_associated(gamma)) then
    call c_f_pointer(gamma, f_gamma_ptr)
  else
    f_gamma_ptr => null()
  endif
  ! inout: f_g_tot 0D_NOT_real
  if (c_associated(g_tot)) then
    call c_f_pointer(g_tot, f_g_tot_ptr)
  else
    f_g_tot_ptr => null()
  endif
  ! inout: f_species 0D_NOT_integer
  if (c_associated(species)) then
    call c_f_pointer(species, f_species_ptr)
  else
    f_species_ptr => null()
  endif
  f_mat = diffusion_matrix_b(gamma=f_gamma_ptr, g_tot=f_g_tot_ptr, species=f_species_ptr)

  ! inout: f_gamma 0D_NOT_real
  ! no output conversion for f_gamma
  ! inout: f_g_tot 0D_NOT_real
  ! no output conversion for f_g_tot
  ! inout: f_species 0D_NOT_integer
  ! no output conversion for f_species
  ! out: f_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat', c_name='mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=128, definition='real(rp) mat(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_distance_to_aperture (orbit, particle_at, ele, no_aperture_here, dist) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: no_aperture_here  ! 0D_NOT_logical
  logical :: f_no_aperture_here
  logical(c_bool), pointer :: f_no_aperture_here_ptr
  type(c_ptr), intent(in), value :: dist  ! 0D_NOT_real
  real(rp) :: f_dist
  real(c_double), pointer :: f_dist_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_dist = distance_to_aperture(orbit=f_orbit, particle_at=f_particle_at, ele=f_ele, &
      no_aperture_here=f_no_aperture_here)

  ! out: f_no_aperture_here 0D_NOT_logical
  call c_f_pointer(no_aperture_here, f_no_aperture_here_ptr)
  f_no_aperture_here_ptr = f_no_aperture_here
  ! out: f_dist 0D_NOT_real
  call c_f_pointer(dist, f_dist_ptr)
  f_dist_ptr = f_dist
end subroutine
subroutine fortran_do_mode_flip (ele, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  call do_mode_flip(ele=f_ele, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_dpc_given_de (pc_old, mass, dE, dpc) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dpc  ! 0D_NOT_real
  real(rp) :: f_dpc
  real(c_double), pointer :: f_dpc_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: pc_old  ! 0D_NOT_real
  real(c_double) :: f_pc_old
  real(c_double), pointer :: f_pc_old_ptr
  type(c_ptr), intent(in), value :: mass  ! 0D_NOT_real
  real(c_double) :: f_mass
  real(c_double), pointer :: f_mass_ptr
  type(c_ptr), intent(in), value :: dE  ! 0D_NOT_real
  real(c_double) :: f_dE
  real(c_double), pointer :: f_dE_ptr
  ! ** End of parameters **
  ! inout: f_pc_old 0D_NOT_real
  if (c_associated(pc_old)) then
    call c_f_pointer(pc_old, f_pc_old_ptr)
  else
    f_pc_old_ptr => null()
  endif
  ! inout: f_mass 0D_NOT_real
  if (c_associated(mass)) then
    call c_f_pointer(mass, f_mass_ptr)
  else
    f_mass_ptr => null()
  endif
  ! inout: f_dE 0D_NOT_real
  if (c_associated(dE)) then
    call c_f_pointer(dE, f_dE_ptr)
  else
    f_dE_ptr => null()
  endif
  f_dpc = dpc_given_de(pc_old=f_pc_old_ptr, mass=f_mass_ptr, dE=f_dE_ptr)

  ! inout: f_pc_old 0D_NOT_real
  ! no output conversion for f_pc_old
  ! inout: f_mass 0D_NOT_real
  ! no output conversion for f_mass
  ! inout: f_dE 0D_NOT_real
  ! no output conversion for f_dE
  ! out: f_dpc 0D_NOT_real
  call c_f_pointer(dpc, f_dpc_ptr)
  f_dpc_ptr = f_dpc
end subroutine
subroutine fortran_drift_and_pipe_track_methods_adjustment (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call drift_and_pipe_track_methods_adjustment(lat=f_lat)

end subroutine
subroutine fortran_drift_multipass_name_correction (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call drift_multipass_name_correction(lat=f_lat)

end subroutine
subroutine fortran_drift_orbit_time (orbit, beta0, delta_s, delta_t) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: beta0  ! 0D_NOT_real
  real(rp) :: f_beta0
  type(c_ptr), intent(in), value :: delta_s  ! 0D_NOT_real
  real(c_double) :: f_delta_s
  real(c_double), pointer :: f_delta_s_ptr
  type(c_ptr), intent(in), value :: delta_t  ! 0D_NOT_real
  real(c_double) :: f_delta_t
  real(c_double), pointer :: f_delta_t_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_beta0 0D_NOT_real
  f_beta0 = beta0
  ! in: f_delta_s 0D_NOT_real
  if (c_associated(delta_s)) then
    call c_f_pointer(delta_s, f_delta_s_ptr)
  else
    f_delta_s_ptr => null()
  endif
  ! in: f_delta_t 0D_NOT_real
  if (c_associated(delta_t)) then
    call c_f_pointer(delta_t, f_delta_t_ptr)
  else
    f_delta_t_ptr => null()
  endif
  call drift_orbit_time(orbit=f_orbit, beta0=f_beta0, delta_s=f_delta_s_ptr, &
      delta_t=f_delta_t_ptr)

end subroutine
subroutine fortran_drift_particle_to_s (p, s, branch) bind(c)

  use bmad_struct, only: branch_struct, coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: s  ! 0D_NOT_real
  real(rp) :: f_s
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Inout parameters **
  type(c_ptr), value :: p  ! 0D_NOT_type
  type(coord_struct), pointer :: f_p
  ! ** End of parameters **
  ! inout: f_p 0D_NOT_type
  if (.not. c_associated(p)) return
  call c_f_pointer(p, f_p)
  ! in: f_s 0D_NOT_real
  f_s = s
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call drift_particle_to_s(p=f_p, s=f_s, branch=f_branch)

end subroutine
subroutine fortran_drift_particle_to_t (p, t, branch) bind(c)

  use bmad_struct, only: branch_struct, coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: t  ! 0D_NOT_real
  real(rp) :: f_t
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Inout parameters **
  type(c_ptr), value :: p  ! 0D_NOT_type
  type(coord_struct), pointer :: f_p
  ! ** End of parameters **
  ! inout: f_p 0D_NOT_type
  if (.not. c_associated(p)) return
  call c_f_pointer(p, f_p)
  ! in: f_t 0D_NOT_real
  f_t = t
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call drift_particle_to_t(p=f_p, t=f_t, branch=f_branch)

end subroutine
subroutine fortran_dspline_len (s_chord0, s_chord1, spline, dtheta_ref, dlen) bind(c)

  use spline_mod, only: spline_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: s_chord0  ! 0D_NOT_real
  real(rp) :: f_s_chord0
  real(c_double) :: s_chord1  ! 0D_NOT_real
  real(rp) :: f_s_chord1
  type(c_ptr), value :: spline  ! 0D_NOT_type
  type(spline_struct), pointer :: f_spline
  type(c_ptr), intent(in), value :: dtheta_ref  ! 0D_NOT_real
  real(c_double) :: f_dtheta_ref
  real(c_double), pointer :: f_dtheta_ref_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dlen  ! 0D_NOT_real
  real(rp) :: f_dlen
  real(c_double), pointer :: f_dlen_ptr
  ! ** End of parameters **
  ! in: f_s_chord0 0D_NOT_real
  f_s_chord0 = s_chord0
  ! in: f_s_chord1 0D_NOT_real
  f_s_chord1 = s_chord1
  ! in: f_spline 0D_NOT_type
  if (.not. c_associated(spline)) return
  call c_f_pointer(spline, f_spline)
  ! in: f_dtheta_ref 0D_NOT_real
  if (c_associated(dtheta_ref)) then
    call c_f_pointer(dtheta_ref, f_dtheta_ref_ptr)
  else
    f_dtheta_ref_ptr => null()
  endif
  f_dlen = dspline_len(s_chord0=f_s_chord0, s_chord1=f_s_chord1, spline=f_spline, &
      dtheta_ref=f_dtheta_ref_ptr)

  ! out: f_dlen 0D_NOT_real
  call c_f_pointer(dlen, f_dlen_ptr)
  f_dlen_ptr = f_dlen
end subroutine
subroutine fortran_dynamic_aperture_point (branch, ele0, orb0, theta_xy, ap_param, ap_point, &
    check_xy_init) bind(c)

  use bmad_struct, only: aperture_param_struct, aperture_point_struct, branch_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), value :: ele0  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele0
  type(c_ptr), value :: orb0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb0
  real(c_double) :: theta_xy  ! 0D_NOT_real
  real(rp) :: f_theta_xy
  type(c_ptr), value :: ap_param  ! 0D_NOT_type
  type(aperture_param_struct), pointer :: f_ap_param
  type(c_ptr), intent(in), value :: check_xy_init  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_check_xy_init
  logical, target :: f_check_xy_init_native
  logical, pointer :: f_check_xy_init_native_ptr
  logical(c_bool), pointer :: f_check_xy_init_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ap_point  ! 0D_NOT_type
  type(aperture_point_struct), pointer :: f_ap_point
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_ele0 0D_NOT_type
  if (.not. c_associated(ele0)) return
  call c_f_pointer(ele0, f_ele0)
  ! in: f_orb0 0D_NOT_type
  if (.not. c_associated(orb0)) return
  call c_f_pointer(orb0, f_orb0)
  ! in: f_theta_xy 0D_NOT_real
  f_theta_xy = theta_xy
  ! in: f_ap_param 0D_NOT_type
  if (.not. c_associated(ap_param)) return
  call c_f_pointer(ap_param, f_ap_param)
  ! out: f_ap_point 0D_NOT_type
  if (.not. c_associated(ap_point)) return
  call c_f_pointer(ap_point, f_ap_point)
  ! in: f_check_xy_init 0D_NOT_logical
  if (c_associated(check_xy_init)) then
    call c_f_pointer(check_xy_init, f_check_xy_init_ptr)
    f_check_xy_init_native = f_check_xy_init_ptr
    f_check_xy_init_native_ptr => f_check_xy_init_native
  else
    f_check_xy_init_native_ptr => null()
  endif
  call dynamic_aperture_point(branch=f_branch, ele0=f_ele0, orb0=f_orb0, theta_xy=f_theta_xy, &
      ap_param=f_ap_param, ap_point=f_ap_point, check_xy_init=f_check_xy_init_native_ptr)

  ! out: f_ap_point 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_dynamic_aperture_scan (aperture_scan, aperture_param, pz_start, lat, &
    print_timing) bind(c)

  use bmad_struct, only: aperture_param_struct, aperture_scan_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: aperture_param  ! 0D_NOT_type
  type(aperture_param_struct), pointer :: f_aperture_param
  type(c_ptr), intent(in), value :: pz_start
  type(real_container_alloc), pointer :: f_pz_start
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: print_timing  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_timing
  logical, target :: f_print_timing_native
  logical, pointer :: f_print_timing_native_ptr
  logical(c_bool), pointer :: f_print_timing_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: aperture_scan
  type(aperture_scan_struct_container_alloc), pointer :: f_aperture_scan
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(aperture_scan))   call c_f_pointer(aperture_scan, f_aperture_scan)
  ! in: f_aperture_param 0D_NOT_type
  if (.not. c_associated(aperture_param)) return
  call c_f_pointer(aperture_param, f_aperture_param)
  !! container general array (1D_ALLOC_real)
  if (c_associated(pz_start))   call c_f_pointer(pz_start, f_pz_start)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_print_timing 0D_NOT_logical
  if (c_associated(print_timing)) then
    call c_f_pointer(print_timing, f_print_timing_ptr)
    f_print_timing_native = f_print_timing_ptr
    f_print_timing_native_ptr => f_print_timing_native
  else
    f_print_timing_native_ptr => null()
  endif
  call dynamic_aperture_scan(aperture_scan=f_aperture_scan%data, &
      aperture_param=f_aperture_param, pz_start=f_pz_start%data, lat=f_lat, &
      print_timing=f_print_timing_native_ptr)

end subroutine
subroutine fortran_e_accel_field (ele, voltage_or_gradient, bmad_standard_tracking, field) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: voltage_or_gradient  ! 0D_NOT_integer
  integer :: f_voltage_or_gradient
  type(c_ptr), intent(in), value :: bmad_standard_tracking  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_bmad_standard_tracking
  logical, target :: f_bmad_standard_tracking_native
  logical, pointer :: f_bmad_standard_tracking_native_ptr
  logical(c_bool), pointer :: f_bmad_standard_tracking_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: field  ! 0D_NOT_real
  real(rp) :: f_field
  real(c_double), pointer :: f_field_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_voltage_or_gradient 0D_NOT_integer
  f_voltage_or_gradient = voltage_or_gradient
  ! in: f_bmad_standard_tracking 0D_NOT_logical
  if (c_associated(bmad_standard_tracking)) then
    call c_f_pointer(bmad_standard_tracking, f_bmad_standard_tracking_ptr)
    f_bmad_standard_tracking_native = f_bmad_standard_tracking_ptr
    f_bmad_standard_tracking_native_ptr => f_bmad_standard_tracking_native
  else
    f_bmad_standard_tracking_native_ptr => null()
  endif
  f_field = e_accel_field(ele=f_ele, voltage_or_gradient=f_voltage_or_gradient, &
      bmad_standard_tracking=f_bmad_standard_tracking_native_ptr)

  ! out: f_field 0D_NOT_real
  call c_f_pointer(field, f_field_ptr)
  f_field_ptr = f_field
end subroutine
subroutine fortran_e_crit_photon (gamma, g_bend, E_crit) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  real(c_double) :: g_bend  ! 0D_NOT_real
  real(rp) :: f_g_bend
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: E_crit  ! 0D_NOT_real
  real(rp) :: f_E_crit
  real(c_double), pointer :: f_E_crit_ptr
  ! ** End of parameters **
  ! in: f_gamma 0D_NOT_real
  f_gamma = gamma
  ! in: f_g_bend 0D_NOT_real
  f_g_bend = g_bend
  f_E_crit = e_crit_photon(gamma=f_gamma, g_bend=f_g_bend)

  ! out: f_E_crit 0D_NOT_real
  call c_f_pointer(E_crit, f_E_crit_ptr)
  f_E_crit_ptr = f_E_crit
end subroutine
subroutine fortran_eigen_decomp_6mat (mat, eval, evec, err_flag, tunes) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: mat
  real(rp) :: f_mat(6,6)
  real(c_double), pointer :: f_mat_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: eval
  complex(rp) :: f_eval(6)
  complex(c_double_complex), pointer :: f_eval_ptr(:)
  type(c_ptr), intent(in), value :: evec
  complex(rp) :: f_evec(6,6)
  complex(c_double_complex), pointer :: f_evec_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: tunes
  real(rp) :: f_tunes(3)
  real(c_double), pointer :: f_tunes_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(mat)) then
    call c_f_pointer(mat, f_mat_ptr, [6*6])
    call vec2mat(f_mat_ptr, f_mat)
  else
    f_mat_ptr => null()
  endif
  call eigen_decomp_6mat(mat=f_mat, eval=f_eval, evec=f_evec, err_flag=f_err_flag, &
      tunes=f_tunes)

  ! out: f_eval 1D_NOT_complex
  if (c_associated(eval)) then
    call c_f_pointer(eval, f_eval_ptr, [6])
    f_eval_ptr = f_eval(:)
  endif
  ! out: f_evec 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_evec', c_name='evec', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=459, definition='complex(rp) evec(6,6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='evec', comment='', default=None), intent='out', description='complex eigenvectors arranged down columns.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_tunes 1D_NOT_real
  if (c_associated(tunes)) then
    call c_f_pointer(tunes, f_tunes_ptr, [3])
    f_tunes_ptr = f_tunes(:)
  endif
end subroutine
subroutine fortran_ele_compute_ref_energy_and_time (ele0, ele, param, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele0  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele0
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! in: f_ele0 0D_NOT_type
  if (.not. c_associated(ele0)) return
  call c_f_pointer(ele0, f_ele0)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call ele_compute_ref_energy_and_time(ele0=f_ele0, ele=f_ele, param=f_param, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_ele_equal_ele (ele_out, ele_in) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_in
  ! ** Out parameters **
  type(c_ptr), value :: ele_out  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_out
  ! ** End of parameters **
  ! out: f_ele_out 0D_NOT_type
  if (.not. c_associated(ele_out)) return
  call c_f_pointer(ele_out, f_ele_out)
  ! in: f_ele_in 0D_NOT_type
  if (.not. c_associated(ele_in)) return
  call c_f_pointer(ele_in, f_ele_in)
  call ele_equal_ele(ele_out=f_ele_out, ele_in=f_ele_in)

  ! out: f_ele_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ele_equals_ele (ele_out, ele_in, update_nametable) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_in
  logical(c_bool) :: update_nametable  ! 0D_NOT_logical
  logical :: f_update_nametable
  ! ** Out parameters **
  type(c_ptr), value :: ele_out  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_out
  ! ** End of parameters **
  ! out: f_ele_out 0D_NOT_type
  if (.not. c_associated(ele_out)) return
  call c_f_pointer(ele_out, f_ele_out)
  ! in: f_ele_in 0D_NOT_type
  if (.not. c_associated(ele_in)) return
  call c_f_pointer(ele_in, f_ele_in)
  ! in: f_update_nametable 0D_NOT_logical
  f_update_nametable = update_nametable
  call ele_equals_ele(ele_out=f_ele_out, ele_in=f_ele_in, update_nametable=f_update_nametable)

  ! out: f_ele_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ele_finalizer (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call ele_finalizer(ele=f_ele)

end subroutine
subroutine fortran_ele_full_name (ele, template_, str) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: template_
  character(len=4096), target :: f_template
  character(kind=c_char), pointer :: f_template_ptr(:)
  character(len=4096), pointer :: f_template_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str
  character(len=4096), target :: f_str
  character(kind=c_char), pointer :: f_str_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_template 0D_NOT_character
  if (c_associated(template_)) then
    call c_f_pointer(template_, f_template_ptr, [huge(0)])
    call to_f_str(f_template_ptr, f_template)
    f_template_call_ptr => f_template
  else
    f_template_call_ptr => null()
  endif
  f_str = ele_full_name(ele=f_ele, template=f_template_call_ptr)

  ! out: f_str 0D_ALLOC_character
  call c_f_pointer(str, f_str_ptr, [len_trim(f_str) + 1]) ! output-only string
  call to_c_str(f_str, f_str_ptr)
end subroutine
subroutine fortran_ele_geometry (floor_start, ele, floor_end, len_scale, ignore_patch_err) &
    bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: floor_start  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor_start
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: len_scale  ! 0D_NOT_real
  real(c_double) :: f_len_scale
  real(c_double), pointer :: f_len_scale_ptr
  type(c_ptr), intent(in), value :: ignore_patch_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_ignore_patch_err
  logical, target :: f_ignore_patch_err_native
  logical, pointer :: f_ignore_patch_err_native_ptr
  logical(c_bool), pointer :: f_ignore_patch_err_ptr
  ! ** Out parameters **
  type(c_ptr), value :: floor_end  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor_end
  ! ** End of parameters **
  ! in: f_floor_start 0D_NOT_type
  if (.not. c_associated(floor_start)) return
  call c_f_pointer(floor_start, f_floor_start)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_floor_end 0D_NOT_type
  if (c_associated(floor_end))   call c_f_pointer(floor_end, f_floor_end)
  ! in: f_len_scale 0D_NOT_real
  if (c_associated(len_scale)) then
    call c_f_pointer(len_scale, f_len_scale_ptr)
  else
    f_len_scale_ptr => null()
  endif
  ! in: f_ignore_patch_err 0D_NOT_logical
  if (c_associated(ignore_patch_err)) then
    call c_f_pointer(ignore_patch_err, f_ignore_patch_err_ptr)
    f_ignore_patch_err_native = f_ignore_patch_err_ptr
    f_ignore_patch_err_native_ptr => f_ignore_patch_err_native
  else
    f_ignore_patch_err_native_ptr => null()
  endif
  call ele_geometry(floor_start=f_floor_start, ele=f_ele, floor_end=f_floor_end, &
      len_scale=f_len_scale_ptr, ignore_patch_err=f_ignore_patch_err_native_ptr)

  ! out: f_floor_end 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ele_geometry_with_misalignments (ele, len_scale, floor) bind(c)

  use bmad_struct, only: ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: len_scale  ! 0D_NOT_real
  real(c_double) :: f_len_scale
  real(c_double), pointer :: f_len_scale_ptr
  ! ** Out parameters **
  type(c_ptr), value :: floor  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_len_scale 0D_NOT_real
  if (c_associated(len_scale)) then
    call c_f_pointer(len_scale, f_len_scale_ptr)
  else
    f_len_scale_ptr => null()
  endif
  f_floor = ele_geometry_with_misalignments(ele=f_ele, len_scale=f_len_scale_ptr)

  ! out: f_floor 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ele_has_constant_ds_dt_ref (ele, is_const) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_const  ! 0D_NOT_logical
  logical :: f_is_const
  logical(c_bool), pointer :: f_is_const_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_is_const = ele_has_constant_ds_dt_ref(ele=f_ele)

  ! out: f_is_const 0D_NOT_logical
  call c_f_pointer(is_const, f_is_const_ptr)
  f_is_const_ptr = f_is_const
end subroutine
subroutine fortran_ele_has_nonzero_kick (ele, has_kick) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: has_kick  ! 0D_NOT_logical
  logical :: f_has_kick
  logical(c_bool), pointer :: f_has_kick_ptr
  ! ** End of parameters **
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_has_kick = ele_has_nonzero_kick(ele=f_ele)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_has_kick 0D_NOT_logical
  call c_f_pointer(has_kick, f_has_kick_ptr)
  f_has_kick_ptr = f_has_kick
end subroutine
subroutine fortran_ele_has_nonzero_offset (ele, has_offset) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: has_offset  ! 0D_NOT_logical
  logical :: f_has_offset
  logical(c_bool), pointer :: f_has_offset_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_has_offset = ele_has_nonzero_offset(ele=f_ele)

  ! out: f_has_offset 0D_NOT_logical
  call c_f_pointer(has_offset, f_has_offset_ptr)
  f_has_offset_ptr = f_has_offset
end subroutine
subroutine fortran_ele_is_monitor (ele, print_warning, is_monitor) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: print_warning  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_warning
  logical, target :: f_print_warning_native
  logical, pointer :: f_print_warning_native_ptr
  logical(c_bool), pointer :: f_print_warning_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_monitor  ! 0D_NOT_logical
  logical :: f_is_monitor
  logical(c_bool), pointer :: f_is_monitor_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_print_warning 0D_NOT_logical
  if (c_associated(print_warning)) then
    call c_f_pointer(print_warning, f_print_warning_ptr)
    f_print_warning_native = f_print_warning_ptr
    f_print_warning_native_ptr => f_print_warning_native
  else
    f_print_warning_native_ptr => null()
  endif
  f_is_monitor = ele_is_monitor(ele=f_ele, print_warning=f_print_warning_native_ptr)

  ! out: f_is_monitor 0D_NOT_logical
  call c_f_pointer(is_monitor, f_is_monitor_ptr)
  f_is_monitor_ptr = f_is_monitor
end subroutine
subroutine fortran_ele_loc (ele, loc) bind(c)

  use bmad_struct, only: ele_struct, lat_ele_loc_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: loc  ! 0D_NOT_type
  type(lat_ele_loc_struct), pointer :: f_loc
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_loc = ele_loc(ele=f_ele)

  ! out: f_loc 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ele_loc_name (ele, show_branch0, parens, str) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: show_branch0  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_show_branch0
  logical, target :: f_show_branch0_native
  logical, pointer :: f_show_branch0_native_ptr
  logical(c_bool), pointer :: f_show_branch0_ptr
  type(c_ptr), intent(in), value :: parens
  character(len=4096), target :: f_parens
  character(kind=c_char), pointer :: f_parens_ptr(:)
  character(len=4096), pointer :: f_parens_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str
  character(len=4096), target :: f_str
  character(kind=c_char), pointer :: f_str_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_show_branch0 0D_NOT_logical
  if (c_associated(show_branch0)) then
    call c_f_pointer(show_branch0, f_show_branch0_ptr)
    f_show_branch0_native = f_show_branch0_ptr
    f_show_branch0_native_ptr => f_show_branch0_native
  else
    f_show_branch0_native_ptr => null()
  endif
  ! in: f_parens 0D_NOT_character
  if (c_associated(parens)) then
    call c_f_pointer(parens, f_parens_ptr, [huge(0)])
    call to_f_str(f_parens_ptr, f_parens)
    f_parens_call_ptr => f_parens
  else
    f_parens_call_ptr => null()
  endif
  f_str = ele_loc_name(ele=f_ele, show_branch0=f_show_branch0_native_ptr, &
      parens=f_parens_call_ptr)

  ! out: f_str 0D_NOT_character
  call c_f_pointer(str, f_str_ptr, [len_trim(f_str) + 1]) ! output-only string
  call to_c_str(f_str, f_str_ptr)
end subroutine
subroutine fortran_ele_misalignment_l_s_calc (ele, L_mis, S_mis) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: L_mis
  real(rp) :: f_L_mis(3)
  real(c_double), pointer :: f_L_mis_ptr(:)
  type(c_ptr), intent(in), value :: S_mis
  real(rp) :: f_S_mis(3,3)
  real(c_double), pointer :: f_S_mis_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call ele_misalignment_l_s_calc(ele=f_ele, L_mis=f_L_mis, S_mis=f_S_mis)

  ! out: f_L_mis 1D_NOT_real
  if (c_associated(L_mis)) then
    call c_f_pointer(L_mis, f_L_mis_ptr, [3])
    f_L_mis_ptr = f_L_mis(:)
  endif
  ! out: f_S_mis 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_S_mis', c_name='S_mis', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=1154, definition='real(rp) :: L_mis(3), S_mis(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='S_mis', comment='', default=None), intent='out', description='Misalignment matrix relative to center of element', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_ele_nametable_index (ele, ix_nt) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_nt  ! 0D_NOT_integer
  integer :: f_ix_nt
  integer(c_int), pointer :: f_ix_nt_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_ix_nt = ele_nametable_index(ele=f_ele)

  ! out: f_ix_nt 0D_NOT_integer
  call c_f_pointer(ix_nt, f_ix_nt_ptr)
  f_ix_nt_ptr = f_ix_nt
end subroutine
subroutine fortran_ele_order_calc (lat, order) bind(c)

  use bmad_struct, only: lat_ele_order_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), value :: order  ! 0D_NOT_type
  type(lat_ele_order_struct), pointer :: f_order
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! out: f_order 0D_NOT_type
  if (.not. c_associated(order)) return
  call c_f_pointer(order, f_order)
  call ele_order_calc(lat=f_lat, order=f_order)

  ! out: f_order 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ele_reference_energy_correction (ele, orbit, particle_at, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call ele_reference_energy_correction(ele=f_ele, orbit=f_orbit, particle_at=f_particle_at, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_ele_rf_step_index (E_ref, s_rel, ele, ix_step) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: E_ref  ! 0D_NOT_real
  real(rp) :: f_E_ref
  real(c_double) :: s_rel  ! 0D_NOT_real
  real(rp) :: f_s_rel
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_step  ! 0D_NOT_integer
  integer :: f_ix_step
  integer(c_int), pointer :: f_ix_step_ptr
  ! ** End of parameters **
  ! in: f_E_ref 0D_NOT_real
  f_E_ref = E_ref
  ! in: f_s_rel 0D_NOT_real
  f_s_rel = s_rel
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_ix_step = ele_rf_step_index(E_ref=f_E_ref, s_rel=f_s_rel, ele=f_ele)

  ! out: f_ix_step 0D_NOT_integer
  call c_f_pointer(ix_step, f_ix_step_ptr)
  f_ix_step_ptr = f_ix_step
end subroutine
subroutine fortran_ele_to_ptc_magnetic_bn_an (ele, bn, an, n_max) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: bn
  type(real_container_alloc), pointer :: f_bn
  type(c_ptr), intent(in), value :: an
  type(real_container_alloc), pointer :: f_an
  type(c_ptr), intent(in), value :: n_max  ! 0D_NOT_integer
  integer :: f_n_max
  integer(c_int), pointer :: f_n_max_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container general array (1D_ALLOC_real)
  if (c_associated(bn))   call c_f_pointer(bn, f_bn)
  !! container general array (1D_ALLOC_real)
  if (c_associated(an))   call c_f_pointer(an, f_an)
  call ele_to_ptc_magnetic_bn_an(ele=f_ele, bn=f_bn%data, an=f_an%data, n_max=f_n_max)

  ! out: f_n_max 0D_NOT_integer
  ! no output conversion for f_n_max
end subroutine
subroutine fortran_ele_to_spin_taylor (ele, param, orb0) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: orb0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb0
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_orb0 0D_NOT_type
  if (.not. c_associated(orb0)) return
  call c_f_pointer(orb0, f_orb0)
  call ele_to_spin_taylor(ele=f_ele, param=f_param, orb0=f_orb0)

end subroutine
subroutine fortran_ele_to_taylor (ele, orb0, taylor_map_includes_offsets, include_damping, &
    orbital_taylor, spin_taylor) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orb0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb0
  type(c_ptr), intent(in), value :: taylor_map_includes_offsets  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_taylor_map_includes_offsets
  logical, target :: f_taylor_map_includes_offsets_native
  logical, pointer :: f_taylor_map_includes_offsets_native_ptr
  logical(c_bool), pointer :: f_taylor_map_includes_offsets_ptr
  type(c_ptr), intent(in), value :: include_damping  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_damping
  logical, target :: f_include_damping_native
  logical, pointer :: f_include_damping_native_ptr
  logical(c_bool), pointer :: f_include_damping_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: orbital_taylor
  type(taylor_struct), pointer :: f_orbital_taylor(:)
  type(c_ptr), intent(in), value :: spin_taylor
  type(taylor_struct), pointer :: f_spin_taylor(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orb0 0D_NOT_type
  if (c_associated(orb0))   call c_f_pointer(orb0, f_orb0)
  ! in: f_taylor_map_includes_offsets 0D_NOT_logical
  if (c_associated(taylor_map_includes_offsets)) then
    call c_f_pointer(taylor_map_includes_offsets, f_taylor_map_includes_offsets_ptr)
    f_taylor_map_includes_offsets_native = f_taylor_map_includes_offsets_ptr
    f_taylor_map_includes_offsets_native_ptr => f_taylor_map_includes_offsets_native
  else
    f_taylor_map_includes_offsets_native_ptr => null()
  endif
  ! in: f_include_damping 0D_NOT_logical
  if (c_associated(include_damping)) then
    call c_f_pointer(include_damping, f_include_damping_ptr)
    f_include_damping_native = f_include_damping_ptr
    f_include_damping_native_ptr => f_include_damping_native
  else
    f_include_damping_native_ptr => null()
  endif
  !! type array (1D_NOT_type)
  call c_f_pointer(orbital_taylor, f_orbital_taylor, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(spin_taylor, f_spin_taylor, [4])
  call ele_to_taylor(ele=f_ele, orb0=f_orb0, &
      taylor_map_includes_offsets=f_taylor_map_includes_offsets_native_ptr, &
      include_damping=f_include_damping_native_ptr, orbital_taylor=f_orbital_taylor, &
      spin_taylor=f_spin_taylor)

  ! out: f_orbital_taylor 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
  ! out: f_spin_taylor 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_ele_unique_name (ele, order, unique_name) bind(c)

  use bmad_struct, only: ele_struct, lat_ele_order_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: order  ! 0D_NOT_type
  type(lat_ele_order_struct), pointer :: f_order
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: unique_name
  character(len=4096), target :: f_unique_name
  character(kind=c_char), pointer :: f_unique_name_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_order 0D_NOT_type
  if (.not. c_associated(order)) return
  call c_f_pointer(order, f_order)
  f_unique_name = ele_unique_name(ele=f_ele, order=f_order)

  ! out: f_unique_name 0D_NOT_character
  call c_f_pointer(unique_name, f_unique_name_ptr, [len_trim(f_unique_name) + 1]) ! output-only string
  call to_c_str(f_unique_name, f_unique_name_ptr)
end subroutine
subroutine fortran_ele_value_has_changed (ele, list, abs_tol, set_old, has_changed) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: list
  type(integer_container_alloc), pointer :: f_list
  type(c_ptr), intent(in), value :: abs_tol
  type(real_container_alloc), pointer :: f_abs_tol
  logical(c_bool) :: set_old  ! 0D_NOT_logical
  logical :: f_set_old
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: has_changed  ! 0D_NOT_logical
  logical :: f_has_changed
  logical(c_bool), pointer :: f_has_changed_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container general array (1D_ALLOC_integer)
  if (c_associated(list))   call c_f_pointer(list, f_list)
  !! container general array (1D_ALLOC_real)
  if (c_associated(abs_tol))   call c_f_pointer(abs_tol, f_abs_tol)
  ! in: f_set_old 0D_NOT_logical
  f_set_old = set_old
  f_has_changed = ele_value_has_changed(ele=f_ele, list=f_list%data, abs_tol=f_abs_tol%data, &
      set_old=f_set_old)

  ! out: f_has_changed 0D_NOT_logical
  call c_f_pointer(has_changed, f_has_changed_ptr)
  f_has_changed_ptr = f_has_changed
end subroutine
subroutine fortran_ele_vec_equal_ele_vec (ele1, ele2) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ele2
  type(ele_struct_container_alloc), pointer :: f_ele2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ele1
  type(ele_struct_container_alloc), pointer :: f_ele1
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(ele1))   call c_f_pointer(ele1, f_ele1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(ele2))   call c_f_pointer(ele2, f_ele2)
  call ele_vec_equal_ele_vec(ele1=f_ele1%data, ele2=f_ele2%data)

end subroutine
subroutine fortran_elec_multipole_field (a, b, n, coord, Ex, Ey, dE, compute_dE) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: a  ! 0D_NOT_real
  real(rp) :: f_a
  real(c_double) :: b  ! 0D_NOT_real
  real(rp) :: f_b
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  type(c_ptr), value :: coord  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: Ex  ! 0D_NOT_real
  real(rp) :: f_Ex
  real(c_double), pointer :: f_Ex_ptr
  type(c_ptr), intent(in), value :: Ey  ! 0D_NOT_real
  real(rp) :: f_Ey
  real(c_double), pointer :: f_Ey_ptr
  type(c_ptr), intent(in), value :: dE
  real(rp) :: f_dE(2,2)
  real(c_double), pointer :: f_dE_ptr(:)
  type(c_ptr), intent(in), value :: compute_dE  ! 0D_NOT_logical
  logical :: f_compute_dE
  logical(c_bool), pointer :: f_compute_dE_ptr
  ! ** End of parameters **
  ! in: f_a 0D_NOT_real
  f_a = a
  ! in: f_b 0D_NOT_real
  f_b = b
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_coord 0D_NOT_type
  if (.not. c_associated(coord)) return
  call c_f_pointer(coord, f_coord)
  call elec_multipole_field(a=f_a, b=f_b, n=f_n, coord=f_coord, Ex=f_Ex, Ey=f_Ey, dE=f_dE, &
      compute_dE=f_compute_dE)

  ! out: f_Ex 0D_NOT_real
  call c_f_pointer(Ex, f_Ex_ptr)
  f_Ex_ptr = f_Ex
  ! out: f_Ey 0D_NOT_real
  call c_f_pointer(Ey, f_Ey_ptr)
  f_Ey_ptr = f_Ey
  ! out: f_dE 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_dE', c_name='dE', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=1253, definition='real(rp), optional :: dE(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='dE', comment='', default=None), intent='out', description='Field derivatives: dfield(x,y)/d(x,y).', doc_data_type='float', doc_is_optional=False)
  ! out: f_compute_dE 0D_NOT_logical
  ! no output conversion for f_compute_dE
end subroutine
subroutine fortran_element_slice_iterator (ele, param, i_slice, n_slice_tot, sliced_ele, &
    s_start, s_end) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: i_slice  ! 0D_NOT_integer
  integer :: f_i_slice
  integer(c_int) :: n_slice_tot  ! 0D_NOT_integer
  integer :: f_n_slice_tot
  type(c_ptr), intent(in), value :: s_start  ! 0D_NOT_real
  real(c_double) :: f_s_start
  real(c_double), pointer :: f_s_start_ptr
  type(c_ptr), intent(in), value :: s_end  ! 0D_NOT_real
  real(c_double) :: f_s_end
  real(c_double), pointer :: f_s_end_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: sliced_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_sliced_ele
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_i_slice 0D_NOT_integer
  f_i_slice = i_slice
  ! in: f_n_slice_tot 0D_NOT_integer
  f_n_slice_tot = n_slice_tot
  ! inout: f_sliced_ele 0D_NOT_type
  if (.not. c_associated(sliced_ele)) return
  call c_f_pointer(sliced_ele, f_sliced_ele)
  ! in: f_s_start 0D_NOT_real
  if (c_associated(s_start)) then
    call c_f_pointer(s_start, f_s_start_ptr)
  else
    f_s_start_ptr => null()
  endif
  ! in: f_s_end 0D_NOT_real
  if (c_associated(s_end)) then
    call c_f_pointer(s_end, f_s_end_ptr)
  else
    f_s_end_ptr => null()
  endif
  call element_slice_iterator(ele=f_ele, param=f_param, i_slice=f_i_slice, &
      n_slice_tot=f_n_slice_tot, sliced_ele=f_sliced_ele, s_start=f_s_start_ptr, &
      s_end=f_s_end_ptr)

end subroutine
subroutine fortran_ellipinc_test () bind(c)

  implicit none
  ! ** End of parameters **
  call ellipinc_test()

end subroutine
subroutine fortran_em_field_calc (ele, param, s_pos, orbit, local_ref_frame, field, &
    calc_dfield, err_flag, calc_potential, use_overlap, grid_allow_s_out_of_bounds, rf_time, &
    used_eles, print_err, original_ele) bind(c)

  use bmad_struct, only: coord_struct, ele_pointer_struct, ele_struct, em_field_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  real(c_double) :: s_pos  ! 0D_NOT_real
  real(rp) :: f_s_pos
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  logical(c_bool) :: local_ref_frame  ! 0D_NOT_logical
  logical :: f_local_ref_frame
  type(c_ptr), intent(in), value :: calc_dfield  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_dfield
  logical, target :: f_calc_dfield_native
  logical, pointer :: f_calc_dfield_native_ptr
  logical(c_bool), pointer :: f_calc_dfield_ptr
  type(c_ptr), intent(in), value :: calc_potential  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_potential
  logical, target :: f_calc_potential_native
  logical, pointer :: f_calc_potential_native_ptr
  logical(c_bool), pointer :: f_calc_potential_ptr
  type(c_ptr), intent(in), value :: use_overlap  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_overlap
  logical, target :: f_use_overlap_native
  logical, pointer :: f_use_overlap_native_ptr
  logical(c_bool), pointer :: f_use_overlap_ptr
  type(c_ptr), intent(in), value :: grid_allow_s_out_of_bounds  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_grid_allow_s_out_of_bounds
  logical, target :: f_grid_allow_s_out_of_bounds_native
  logical, pointer :: f_grid_allow_s_out_of_bounds_native_ptr
  logical(c_bool), pointer :: f_grid_allow_s_out_of_bounds_ptr
  type(c_ptr), intent(in), value :: rf_time  ! 0D_NOT_real
  real(c_double) :: f_rf_time
  real(c_double), pointer :: f_rf_time_ptr
  type(c_ptr), intent(in), value :: used_eles
  type(ele_pointer_struct_container_alloc), pointer :: f_used_eles
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  type(c_ptr), value :: original_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_original_ele
  ! ** Out parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_s_pos 0D_NOT_real
  f_s_pos = s_pos
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_local_ref_frame 0D_NOT_logical
  f_local_ref_frame = local_ref_frame
  ! out: f_field 0D_NOT_type
  if (.not. c_associated(field)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(field, f_field)
  ! in: f_calc_dfield 0D_NOT_logical
  if (c_associated(calc_dfield)) then
    call c_f_pointer(calc_dfield, f_calc_dfield_ptr)
    f_calc_dfield_native = f_calc_dfield_ptr
    f_calc_dfield_native_ptr => f_calc_dfield_native
  else
    f_calc_dfield_native_ptr => null()
  endif
  ! in: f_calc_potential 0D_NOT_logical
  if (c_associated(calc_potential)) then
    call c_f_pointer(calc_potential, f_calc_potential_ptr)
    f_calc_potential_native = f_calc_potential_ptr
    f_calc_potential_native_ptr => f_calc_potential_native
  else
    f_calc_potential_native_ptr => null()
  endif
  ! in: f_use_overlap 0D_NOT_logical
  if (c_associated(use_overlap)) then
    call c_f_pointer(use_overlap, f_use_overlap_ptr)
    f_use_overlap_native = f_use_overlap_ptr
    f_use_overlap_native_ptr => f_use_overlap_native
  else
    f_use_overlap_native_ptr => null()
  endif
  ! in: f_grid_allow_s_out_of_bounds 0D_NOT_logical
  if (c_associated(grid_allow_s_out_of_bounds)) then
    call c_f_pointer(grid_allow_s_out_of_bounds, f_grid_allow_s_out_of_bounds_ptr)
    f_grid_allow_s_out_of_bounds_native = f_grid_allow_s_out_of_bounds_ptr
    f_grid_allow_s_out_of_bounds_native_ptr => f_grid_allow_s_out_of_bounds_native
  else
    f_grid_allow_s_out_of_bounds_native_ptr => null()
  endif
  ! in: f_rf_time 0D_NOT_real
  if (c_associated(rf_time)) then
    call c_f_pointer(rf_time, f_rf_time_ptr)
  else
    f_rf_time_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(used_eles))   call c_f_pointer(used_eles, f_used_eles)
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  ! in: f_original_ele 0D_NOT_type
  if (c_associated(original_ele))   call c_f_pointer(original_ele, f_original_ele)
  call em_field_calc(ele=f_ele, param=f_param, s_pos=f_s_pos, orbit=f_orbit, &
      local_ref_frame=f_local_ref_frame, field=f_field, calc_dfield=f_calc_dfield_native_ptr, &
      err_flag=f_err_flag, calc_potential=f_calc_potential_native_ptr, &
      use_overlap=f_use_overlap_native_ptr, &
      grid_allow_s_out_of_bounds=f_grid_allow_s_out_of_bounds_native_ptr, &
      rf_time=f_rf_time_ptr, used_eles=f_used_eles%data, print_err=f_print_err_native_ptr, &
      original_ele=f_original_ele)

  ! out: f_field 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_em_field_derivatives (ele, param, s_pos, orbit, local_ref_frame, dfield, &
    grid_allow_s_out_of_bounds, rf_time) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct, lat_param_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: dfield  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_dfield
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: s_pos  ! 0D_NOT_real
  real(c_double) :: f_s_pos
  real(c_double), pointer :: f_s_pos_ptr
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: local_ref_frame  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_local_ref_frame
  logical, target :: f_local_ref_frame_native
  logical, pointer :: f_local_ref_frame_native_ptr
  logical(c_bool), pointer :: f_local_ref_frame_ptr
  type(c_ptr), intent(in), value :: grid_allow_s_out_of_bounds  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_grid_allow_s_out_of_bounds
  logical, target :: f_grid_allow_s_out_of_bounds_native
  logical, pointer :: f_grid_allow_s_out_of_bounds_native_ptr
  logical(c_bool), pointer :: f_grid_allow_s_out_of_bounds_ptr
  type(c_ptr), intent(in), value :: rf_time  ! 0D_NOT_real
  real(c_double) :: f_rf_time
  real(c_double), pointer :: f_rf_time_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_s_pos 0D_NOT_real
  if (c_associated(s_pos)) then
    call c_f_pointer(s_pos, f_s_pos_ptr)
  else
    f_s_pos_ptr => null()
  endif
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! inout: f_local_ref_frame 0D_NOT_logical
  if (c_associated(local_ref_frame)) then
    call c_f_pointer(local_ref_frame, f_local_ref_frame_ptr)
    f_local_ref_frame_native = f_local_ref_frame_ptr
    f_local_ref_frame_native_ptr => f_local_ref_frame_native
  else
    f_local_ref_frame_native_ptr => null()
  endif
  ! out: f_dfield 0D_NOT_type
  if (.not. c_associated(dfield)) return
  call c_f_pointer(dfield, f_dfield)
  ! inout: f_grid_allow_s_out_of_bounds 0D_NOT_logical
  if (c_associated(grid_allow_s_out_of_bounds)) then
    call c_f_pointer(grid_allow_s_out_of_bounds, f_grid_allow_s_out_of_bounds_ptr)
    f_grid_allow_s_out_of_bounds_native = f_grid_allow_s_out_of_bounds_ptr
    f_grid_allow_s_out_of_bounds_native_ptr => f_grid_allow_s_out_of_bounds_native
  else
    f_grid_allow_s_out_of_bounds_native_ptr => null()
  endif
  ! inout: f_rf_time 0D_NOT_real
  if (c_associated(rf_time)) then
    call c_f_pointer(rf_time, f_rf_time_ptr)
  else
    f_rf_time_ptr => null()
  endif
  call em_field_derivatives(ele=f_ele, param=f_param, s_pos=f_s_pos_ptr, orbit=f_orbit, &
      local_ref_frame=f_local_ref_frame_native_ptr, dfield=f_dfield, &
      grid_allow_s_out_of_bounds=f_grid_allow_s_out_of_bounds_native_ptr, &
      rf_time=f_rf_time_ptr)

  ! inout: f_s_pos 0D_NOT_real
  ! no output conversion for f_s_pos
  ! inout: f_local_ref_frame 0D_NOT_logical
  if (c_associated(local_ref_frame)) then
    call c_f_pointer(local_ref_frame, f_local_ref_frame_ptr)
    f_local_ref_frame_ptr = f_local_ref_frame_native
  else
    ! f_local_ref_frame unset
  endif
  ! out: f_dfield 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_grid_allow_s_out_of_bounds 0D_NOT_logical
  if (c_associated(grid_allow_s_out_of_bounds)) then
    call c_f_pointer(grid_allow_s_out_of_bounds, f_grid_allow_s_out_of_bounds_ptr)
    f_grid_allow_s_out_of_bounds_ptr = f_grid_allow_s_out_of_bounds_native
  else
    ! f_grid_allow_s_out_of_bounds unset
  endif
  ! inout: f_rf_time 0D_NOT_real
  ! no output conversion for f_rf_time
end subroutine
subroutine fortran_em_field_kick_vector_time (ele, param, rf_time, orbit, dvec_dt, err_flag, &
    print_err, extra_field) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  real(c_double) :: rf_time  ! 0D_NOT_real
  real(rp) :: f_rf_time
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  type(c_ptr), value :: extra_field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_extra_field
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dvec_dt
  real(rp) :: f_dvec_dt(10)
  real(c_double), pointer :: f_dvec_dt_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_rf_time 0D_NOT_real
  f_rf_time = rf_time
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  ! in: f_extra_field 0D_NOT_type
  if (c_associated(extra_field))   call c_f_pointer(extra_field, f_extra_field)
  call em_field_kick_vector_time(ele=f_ele, param=f_param, rf_time=f_rf_time, orbit=f_orbit, &
      dvec_dt=f_dvec_dt, err_flag=f_err_flag, print_err=f_print_err_native_ptr, &
      extra_field=f_extra_field)

  ! out: f_dvec_dt 1D_NOT_real
  if (c_associated(dvec_dt)) then
    call c_f_pointer(dvec_dt, f_dvec_dt_ptr, [10])
    f_dvec_dt_ptr = f_dvec_dt(:)
  endif
end subroutine
subroutine fortran_em_field_plus_em_field (field1, field2, field_tot) bind(c)

  use bmad_struct, only: em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: field1  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field1
  type(c_ptr), value :: field2  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field2
  ! ** Out parameters **
  type(c_ptr), value :: field_tot  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field_tot
  ! ** End of parameters **
  ! in: f_field1 0D_NOT_type
  if (.not. c_associated(field1)) return
  call c_f_pointer(field1, f_field1)
  ! in: f_field2 0D_NOT_type
  if (.not. c_associated(field2)) return
  call c_f_pointer(field2, f_field2)
  f_field_tot = em_field_plus_em_field(field1=f_field1, field2=f_field2)

  ! out: f_field_tot 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_em_taylor_equal_em_taylor (em_taylor1, em_taylor2) bind(c)

  use bmad_struct, only: em_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: em_taylor2  ! 0D_NOT_type
  type(em_taylor_struct), pointer :: f_em_taylor2
  ! ** Out parameters **
  type(c_ptr), value :: em_taylor1  ! 0D_NOT_type
  type(em_taylor_struct), pointer :: f_em_taylor1
  ! ** End of parameters **
  ! out: f_em_taylor1 0D_NOT_type
  if (.not. c_associated(em_taylor1)) return
  call c_f_pointer(em_taylor1, f_em_taylor1)
  ! in: f_em_taylor2 0D_NOT_type
  if (.not. c_associated(em_taylor2)) return
  call c_f_pointer(em_taylor2, f_em_taylor2)
  call em_taylor_equal_em_taylor(em_taylor1=f_em_taylor1, em_taylor2=f_em_taylor2)

  ! out: f_em_taylor1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_em_taylors_equal_em_taylors (em_taylor1, em_taylor2) bind(c)

  use bmad_struct, only: em_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: em_taylor2
  type(em_taylor_struct_container_alloc), pointer :: f_em_taylor2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: em_taylor1
  type(em_taylor_struct_container_alloc), pointer :: f_em_taylor1
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(em_taylor1))   call c_f_pointer(em_taylor1, f_em_taylor1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(em_taylor2))   call c_f_pointer(em_taylor2, f_em_taylor2)
  call em_taylors_equal_em_taylors(em_taylor1=f_em_taylor1%data, em_taylor2=f_em_taylor2%data)

end subroutine
subroutine fortran_emit_6d (ele_ref, include_opening_angle, mode, sigma_mat, closed_orbit, &
    rad_int_by_ele) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, normal_modes_struct, rad_int_all_ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_ref  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_ref
  logical(c_bool) :: include_opening_angle  ! 0D_NOT_logical
  logical :: f_include_opening_angle
  type(c_ptr), intent(in), value :: closed_orbit
  type(coord_struct_container_alloc), pointer :: f_closed_orbit
  ! ** Out parameters **
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  type(c_ptr), value :: rad_int_by_ele  ! 0D_NOT_type
  type(rad_int_all_ele_struct), pointer :: f_rad_int_by_ele
  ! ** End of parameters **
  ! in: f_ele_ref 0D_NOT_type
  if (.not. c_associated(ele_ref)) return
  call c_f_pointer(ele_ref, f_ele_ref)
  ! in: f_include_opening_angle 0D_NOT_logical
  f_include_opening_angle = include_opening_angle
  ! out: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  !! container type array (1D_ALLOC_type)
  if (c_associated(closed_orbit))   call c_f_pointer(closed_orbit, f_closed_orbit)
  ! out: f_rad_int_by_ele 0D_NOT_type
  if (c_associated(rad_int_by_ele))   call c_f_pointer(rad_int_by_ele, f_rad_int_by_ele)
  call emit_6d(ele_ref=f_ele_ref, include_opening_angle=f_include_opening_angle, mode=f_mode, &
      sigma_mat=f_sigma_mat, closed_orbit=f_closed_orbit%data, rad_int_by_ele=f_rad_int_by_ele)

  ! out: f_mode 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_sigma_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_sigma_mat', c_name='sigma_mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=65, definition='real(rp) sigma_mat(6,6), rf65, sig_s(6,6), mat6(6,6), xfer_nodamp_mat(6,6), mt(21,21), v_sig(21,1)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='sigma_mat', comment='', default=None), intent='out', description='Sigma matrix.', doc_data_type='float', doc_is_optional=False)
  ! out: f_rad_int_by_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_entering_element (orbit, particle_at, is_entering) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_entering  ! 0D_NOT_logical
  logical :: f_is_entering
  logical(c_bool), pointer :: f_is_entering_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  f_is_entering = entering_element(orbit=f_orbit, particle_at=f_particle_at)

  ! out: f_is_entering 0D_NOT_logical
  call c_f_pointer(is_entering, f_is_entering_ptr)
  f_is_entering_ptr = f_is_entering
end subroutine
subroutine fortran_envelope_radints (Lambda, Theta, Iota, alpha, emit) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: Lambda
  complex(rp) :: f_Lambda(6,6)
  complex(c_double_complex), pointer :: f_Lambda_ptr(:)
  type(c_ptr), intent(in), value :: Theta
  complex(rp) :: f_Theta(6,6)
  complex(c_double_complex), pointer :: f_Theta_ptr(:)
  type(c_ptr), intent(in), value :: Iota
  complex(rp) :: f_Iota(6,6)
  complex(c_double_complex), pointer :: f_Iota_ptr(:)
  type(c_ptr), intent(in), value :: alpha
  real(rp) :: f_alpha(3)
  real(c_double), pointer :: f_alpha_ptr(:)
  type(c_ptr), intent(in), value :: emit
  real(rp) :: f_emit(3)
  real(c_double), pointer :: f_emit_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_complex)
  if (c_associated(Lambda)) then
    call c_f_pointer(Lambda, f_Lambda_ptr, [6*6])
    call vec2mat(f_Lambda_ptr, f_Lambda)
  else
    f_Lambda_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(Theta)) then
    call c_f_pointer(Theta, f_Theta_ptr, [6*6])
    call vec2mat(f_Theta_ptr, f_Theta)
  else
    f_Theta_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(Iota)) then
    call c_f_pointer(Iota, f_Iota_ptr, [6*6])
    call vec2mat(f_Iota_ptr, f_Iota)
  else
    f_Iota_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(alpha)) then
    call c_f_pointer(alpha, f_alpha_ptr, [3])
    f_alpha = f_alpha_ptr(:)
  else
    f_alpha_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(emit)) then
    call c_f_pointer(emit, f_emit_ptr, [3])
    f_emit = f_emit_ptr(:)
  else
    f_emit_ptr => null()
  endif
  call envelope_radints(Lambda=f_Lambda, Theta=f_Theta, Iota=f_Iota, alpha=f_alpha, &
      emit=f_emit)

end subroutine
subroutine fortran_envelope_radints_ibs (Lambda, Theta, Iota, eles, alpha, emit, mode, &
    tail_cut, npart, species) bind(c)

  use bmad_struct, only: ele_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: Lambda
  complex(rp) :: f_Lambda(6,6)
  complex(c_double_complex), pointer :: f_Lambda_ptr(:)
  type(c_ptr), intent(in), value :: Theta
  complex(rp) :: f_Theta(6,6)
  complex(c_double_complex), pointer :: f_Theta_ptr(:)
  type(c_ptr), intent(in), value :: Iota
  complex(rp) :: f_Iota(6,6)
  complex(c_double_complex), pointer :: f_Iota_ptr(:)
  type(c_ptr), intent(in), value :: eles
  type(ele_struct_container_alloc), pointer :: f_eles
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  logical(c_bool) :: tail_cut  ! 0D_NOT_logical
  logical :: f_tail_cut
  real(c_double) :: npart  ! 0D_NOT_real
  real(rp) :: f_npart
  integer(c_int) :: species  ! 0D_NOT_integer
  integer :: f_species
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: alpha
  real(rp) :: f_alpha(3)
  real(c_double), pointer :: f_alpha_ptr(:)
  type(c_ptr), intent(in), value :: emit
  real(rp) :: f_emit(3)
  real(c_double), pointer :: f_emit_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_complex)
  if (c_associated(Lambda)) then
    call c_f_pointer(Lambda, f_Lambda_ptr, [6*6])
    call vec2mat(f_Lambda_ptr, f_Lambda)
  else
    f_Lambda_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(Theta)) then
    call c_f_pointer(Theta, f_Theta_ptr, [6*6])
    call vec2mat(f_Theta_ptr, f_Theta)
  else
    f_Theta_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(Iota)) then
    call c_f_pointer(Iota, f_Iota_ptr, [6*6])
    call vec2mat(f_Iota_ptr, f_Iota)
  else
    f_Iota_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(eles))   call c_f_pointer(eles, f_eles)
  ! in: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  ! in: f_tail_cut 0D_NOT_logical
  f_tail_cut = tail_cut
  ! in: f_npart 0D_NOT_real
  f_npart = npart
  ! in: f_species 0D_NOT_integer
  f_species = species
  call envelope_radints_ibs(Lambda=f_Lambda, Theta=f_Theta, Iota=f_Iota, eles=f_eles%data, &
      alpha=f_alpha, emit=f_emit, mode=f_mode, tail_cut=f_tail_cut, npart=f_npart, &
      species=f_species)

  ! out: f_alpha 1D_NOT_real
  if (c_associated(alpha)) then
    call c_f_pointer(alpha, f_alpha_ptr, [3])
    f_alpha_ptr = f_alpha(:)
  endif
  ! out: f_emit 1D_NOT_real
  if (c_associated(emit)) then
    call c_f_pointer(emit, f_emit_ptr, [3])
    f_emit_ptr = f_emit(:)
  endif
end subroutine
subroutine fortran_eq_ac_kicker (f1, f2, is_eq) bind(c)

  use bmad_struct, only: ac_kicker_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(ac_kicker_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(ac_kicker_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_ac_kicker(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_ac_kicker_freq (f1, f2, is_eq) bind(c)

  use bmad_struct, only: ac_kicker_freq_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(ac_kicker_freq_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(ac_kicker_freq_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_ac_kicker_freq(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_ac_kicker_time (f1, f2, is_eq) bind(c)

  use bmad_struct, only: ac_kicker_time_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(ac_kicker_time_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(ac_kicker_time_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_ac_kicker_time(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_anormal_mode (f1, f2, is_eq) bind(c)

  use bmad_struct, only: anormal_mode_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(anormal_mode_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(anormal_mode_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_anormal_mode(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_aperture_param (f1, f2, is_eq) bind(c)

  use bmad_struct, only: aperture_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(aperture_param_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(aperture_param_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_aperture_param(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_aperture_point (f1, f2, is_eq) bind(c)

  use bmad_struct, only: aperture_point_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(aperture_point_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(aperture_point_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_aperture_point(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_aperture_scan (f1, f2, is_eq) bind(c)

  use bmad_struct, only: aperture_scan_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(aperture_scan_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(aperture_scan_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_aperture_scan(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_beam (f1, f2, is_eq) bind(c)

  use bmad_struct, only: beam_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(beam_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(beam_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_beam(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_beam_init (f1, f2, is_eq) bind(c)

  use bmad_struct, only: beam_init_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_beam_init(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_bmad_common (f1, f2, is_eq) bind(c)

  use bmad_struct, only: bmad_common_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(bmad_common_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(bmad_common_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_bmad_common(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_bookkeeping_state (f1, f2, is_eq) bind(c)

  use bmad_struct, only: bookkeeping_state_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(bookkeeping_state_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(bookkeeping_state_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_bookkeeping_state(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_bpm_phase_coupling (f1, f2, is_eq) bind(c)

  use bmad_struct, only: bpm_phase_coupling_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(bpm_phase_coupling_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(bpm_phase_coupling_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_bpm_phase_coupling(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_branch (f1, f2, is_eq) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(branch_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(branch_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_branch(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_bunch (f1, f2, is_eq) bind(c)

  use bmad_struct, only: bunch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_bunch(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_bunch_params (f1, f2, is_eq) bind(c)

  use bmad_struct, only: bunch_params_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(bunch_params_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_bunch_params(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_cartesian_map (f1, f2, is_eq) bind(c)

  use bmad_struct, only: cartesian_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(cartesian_map_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(cartesian_map_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_cartesian_map(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_cartesian_map_term (f1, f2, is_eq) bind(c)

  use bmad_struct, only: cartesian_map_term_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(cartesian_map_term_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(cartesian_map_term_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_cartesian_map_term(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_cartesian_map_term1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: cartesian_map_term1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(cartesian_map_term1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(cartesian_map_term1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_cartesian_map_term1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_complex_taylor (f1, f2, is_eq) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_complex_taylor(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_complex_taylor_term (f1, f2, is_eq) bind(c)

  use bmad_struct, only: complex_taylor_term_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(complex_taylor_term_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(complex_taylor_term_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_complex_taylor_term(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_control (f1, f2, is_eq) bind(c)

  use bmad_struct, only: control_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(control_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(control_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_control(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_control_ramp1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: control_ramp1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(control_ramp1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(control_ramp1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_control_ramp1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_control_var1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: control_var1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(control_var1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(control_var1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_control_var1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_controller (f1, f2, is_eq) bind(c)

  use bmad_struct, only: controller_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(controller_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(controller_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_controller(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_coord (f1, f2, is_eq) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(coord_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(coord_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_coord(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_coord_array (f1, f2, is_eq) bind(c)

  use bmad_struct, only: coord_array_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(coord_array_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(coord_array_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_coord_array(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_cylindrical_map (f1, f2, is_eq) bind(c)

  use bmad_struct, only: cylindrical_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(cylindrical_map_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(cylindrical_map_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_cylindrical_map(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_cylindrical_map_term (f1, f2, is_eq) bind(c)

  use bmad_struct, only: cylindrical_map_term_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(cylindrical_map_term_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(cylindrical_map_term_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_cylindrical_map_term(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_cylindrical_map_term1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: cylindrical_map_term1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(cylindrical_map_term1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(cylindrical_map_term1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_cylindrical_map_term1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_ele (f1, f2, is_eq) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_ele(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_ellipse_beam_init (f1, f2, is_eq) bind(c)

  use bmad_struct, only: ellipse_beam_init_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(ellipse_beam_init_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(ellipse_beam_init_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_ellipse_beam_init(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_em_field (f1, f2, is_eq) bind(c)

  use bmad_struct, only: em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_em_field(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_em_taylor (f1, f2, is_eq) bind(c)

  use bmad_struct, only: em_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(em_taylor_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(em_taylor_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_em_taylor(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_em_taylor_term (f1, f2, is_eq) bind(c)

  use bmad_struct, only: em_taylor_term_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(em_taylor_term_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(em_taylor_term_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_em_taylor_term(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_expression_atom (f1, f2, is_eq) bind(c)

  use bmad_struct, only: expression_atom_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(expression_atom_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(expression_atom_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_expression_atom(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_floor_position (f1, f2, is_eq) bind(c)

  use bmad_struct, only: floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_floor_position(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_gen_grad1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: gen_grad1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(gen_grad1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(gen_grad1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_gen_grad1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_gen_grad_map (f1, f2, is_eq) bind(c)

  use bmad_struct, only: gen_grad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(gen_grad_map_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(gen_grad_map_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_gen_grad_map(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_grid_beam_init (f1, f2, is_eq) bind(c)

  use bmad_struct, only: grid_beam_init_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(grid_beam_init_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(grid_beam_init_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_grid_beam_init(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_grid_field (f1, f2, is_eq) bind(c)

  use bmad_struct, only: grid_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(grid_field_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(grid_field_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_grid_field(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_grid_field_pt (f1, f2, is_eq) bind(c)

  use bmad_struct, only: grid_field_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(grid_field_pt_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(grid_field_pt_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_grid_field_pt(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_grid_field_pt1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: grid_field_pt1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(grid_field_pt1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(grid_field_pt1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_grid_field_pt1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_high_energy_space_charge (f1, f2, is_eq) bind(c)

  use bmad_struct, only: high_energy_space_charge_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(high_energy_space_charge_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(high_energy_space_charge_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_high_energy_space_charge(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_interval1_coef (f1, f2, is_eq) bind(c)

  use bmad_struct, only: interval1_coef_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(interval1_coef_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(interval1_coef_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_interval1_coef(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_kv_beam_init (f1, f2, is_eq) bind(c)

  use bmad_struct, only: kv_beam_init_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(kv_beam_init_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(kv_beam_init_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_kv_beam_init(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_lat (f1, f2, is_eq) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(lat_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(lat_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_lat(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_lat_ele_loc (f1, f2, is_eq) bind(c)

  use bmad_struct, only: lat_ele_loc_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(lat_ele_loc_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(lat_ele_loc_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_lat_ele_loc(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_lat_param (f1, f2, is_eq) bind(c)

  use bmad_struct, only: lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_lat_param(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_linac_normal_mode (f1, f2, is_eq) bind(c)

  use bmad_struct, only: linac_normal_mode_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(linac_normal_mode_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(linac_normal_mode_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_linac_normal_mode(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_mode3 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: mode3_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(mode3_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(mode3_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_mode3(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_mode_info (f1, f2, is_eq) bind(c)

  use bmad_struct, only: mode_info_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(mode_info_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(mode_info_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_mode_info(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_normal_modes (f1, f2, is_eq) bind(c)

  use bmad_struct, only: normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_normal_modes(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_photon_element (f1, f2, is_eq) bind(c)

  use bmad_struct, only: photon_element_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(photon_element_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(photon_element_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_photon_element(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_photon_material (f1, f2, is_eq) bind(c)

  use bmad_struct, only: photon_material_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(photon_material_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(photon_material_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_photon_material(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_photon_reflect_surface (f1, f2, is_eq) bind(c)

  use bmad_struct, only: photon_reflect_surface_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(photon_reflect_surface_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(photon_reflect_surface_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_photon_reflect_surface(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_photon_reflect_table (f1, f2, is_eq) bind(c)

  use bmad_struct, only: photon_reflect_table_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(photon_reflect_table_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(photon_reflect_table_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_photon_reflect_table(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_photon_target (f1, f2, is_eq) bind(c)

  use bmad_struct, only: photon_target_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(photon_target_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(photon_target_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_photon_target(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_pixel_detec (f1, f2, is_eq) bind(c)

  use bmad_struct, only: pixel_detec_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(pixel_detec_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(pixel_detec_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_pixel_detec(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_pixel_pt (f1, f2, is_eq) bind(c)

  use bmad_struct, only: pixel_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(pixel_pt_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(pixel_pt_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_pixel_pt(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_pre_tracker (f1, f2, is_eq) bind(c)

  use bmad_struct, only: pre_tracker_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(pre_tracker_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(pre_tracker_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_pre_tracker(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_rad_int1 (f1, f2, is_eq) bind(c)

  use bmad_struct, only: rad_int1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(rad_int1_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(rad_int1_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_rad_int1(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_rad_int_all_ele (f1, f2, is_eq) bind(c)

  use bmad_struct, only: rad_int_all_ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(rad_int_all_ele_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(rad_int_all_ele_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_rad_int_all_ele(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_rad_int_branch (f1, f2, is_eq) bind(c)

  use bmad_struct, only: rad_int_branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(rad_int_branch_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(rad_int_branch_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_rad_int_branch(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_rad_map (f1, f2, is_eq) bind(c)

  use bmad_struct, only: rad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(rad_map_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(rad_map_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_rad_map(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_rad_map_ele (f1, f2, is_eq) bind(c)

  use bmad_struct, only: rad_map_ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(rad_map_ele_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(rad_map_ele_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_rad_map_ele(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_ramper_lord (f1, f2, is_eq) bind(c)

  use bmad_struct, only: ramper_lord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(ramper_lord_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(ramper_lord_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_ramper_lord(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_space_charge_common (f1, f2, is_eq) bind(c)

  use bmad_struct, only: space_charge_common_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(space_charge_common_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(space_charge_common_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_space_charge_common(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_spin_polar (f1, f2, is_eq) bind(c)

  use bmad_struct, only: spin_polar_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_spin_polar(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_spline (f1, f2, is_eq) bind(c)

  use spline_mod, only: spline_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(spline_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(spline_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_spline(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_strong_beam (f1, f2, is_eq) bind(c)

  use bmad_struct, only: strong_beam_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(strong_beam_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(strong_beam_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_strong_beam(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_curvature (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_curvature_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_curvature_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_curvature_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_curvature(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_displacement (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_displacement_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_displacement_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_displacement_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_displacement(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_displacement_pt (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_displacement_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_displacement_pt_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_displacement_pt_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_displacement_pt(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_h_misalign (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_h_misalign_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_h_misalign_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_h_misalign_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_h_misalign(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_h_misalign_pt (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_h_misalign_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_h_misalign_pt_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_h_misalign_pt_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_h_misalign_pt(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_segmented (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_segmented_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_segmented_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_segmented_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_segmented(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_surface_segmented_pt (f1, f2, is_eq) bind(c)

  use bmad_struct, only: surface_segmented_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(surface_segmented_pt_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(surface_segmented_pt_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_surface_segmented_pt(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_target_point (f1, f2, is_eq) bind(c)

  use bmad_struct, only: target_point_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(target_point_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(target_point_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_target_point(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_taylor (f1, f2, is_eq) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_taylor(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_taylor_term (f1, f2, is_eq) bind(c)

  use bmad_struct, only: taylor_term_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(taylor_term_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(taylor_term_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_taylor_term(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_track (f1, f2, is_eq) bind(c)

  use bmad_struct, only: track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(track_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(track_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_track(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_track_point (f1, f2, is_eq) bind(c)

  use bmad_struct, only: track_point_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(track_point_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(track_point_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_track_point(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_twiss (f1, f2, is_eq) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_twiss(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wake (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wake_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wake_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wake_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wake(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wake_lr (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wake_lr_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wake_lr_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wake_lr_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wake_lr(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wake_lr_mode (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wake_lr_mode_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wake_lr_mode_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wake_lr_mode_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wake_lr_mode(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wake_sr (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wake_sr_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wake_sr_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wake_sr_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wake_sr(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wake_sr_mode (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wake_sr_mode_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wake_sr_mode_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wake_sr_mode_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wake_sr_mode(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wake_sr_z_long (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wake_sr_z_long_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wake_sr_z_long_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wake_sr_z_long_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wake_sr_z_long(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wall3d (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wall3d_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wall3d_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wall3d_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wall3d(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wall3d_section (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wall3d_section_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wall3d_section_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wall3d_section_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wall3d_section(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_wall3d_vertex (f1, f2, is_eq) bind(c)

  use bmad_struct, only: wall3d_vertex_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(wall3d_vertex_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(wall3d_vertex_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_wall3d_vertex(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_eq_xy_disp (f1, f2, is_eq) bind(c)

  use bmad_struct, only: xy_disp_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: f1  ! 0D_NOT_type
  type(xy_disp_struct), pointer :: f_f1
  type(c_ptr), value :: f2  ! 0D_NOT_type
  type(xy_disp_struct), pointer :: f_f2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_eq  ! 0D_NOT_logical
  logical :: f_is_eq
  logical(c_bool), pointer :: f_is_eq_ptr
  ! ** End of parameters **
  ! in: f_f1 0D_NOT_type
  if (.not. c_associated(f1)) return
  call c_f_pointer(f1, f_f1)
  ! in: f_f2 0D_NOT_type
  if (.not. c_associated(f2)) return
  call c_f_pointer(f2, f_f2)
  f_is_eq = eq_xy_disp(f1=f_f1, f2=f_f2)

  ! out: f_is_eq 0D_NOT_logical
  call c_f_pointer(is_eq, f_is_eq_ptr)
  f_is_eq_ptr = f_is_eq
end subroutine
subroutine fortran_equal_sign_here (ele, delim, is_here) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_here  ! 0D_NOT_logical
  logical :: f_is_here
  logical(c_bool), pointer :: f_is_here_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  f_is_here = equal_sign_here(ele=f_ele, delim=f_delim)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! out: f_is_here 0D_NOT_logical
  call c_f_pointer(is_here, f_is_here_ptr)
  f_is_here_ptr = f_is_here
end subroutine
subroutine fortran_equivalent_taylor_attributes (ele_taylor, ele2, equiv) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_taylor  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_taylor
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: equiv  ! 0D_NOT_logical
  logical :: f_equiv
  logical(c_bool), pointer :: f_equiv_ptr
  ! ** End of parameters **
  ! in: f_ele_taylor 0D_NOT_type
  if (.not. c_associated(ele_taylor)) return
  call c_f_pointer(ele_taylor, f_ele_taylor)
  ! in: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  f_equiv = equivalent_taylor_attributes(ele_taylor=f_ele_taylor, ele2=f_ele2)

  ! out: f_equiv 0D_NOT_logical
  call c_f_pointer(equiv, f_equiv_ptr)
  f_equiv_ptr = f_equiv
end subroutine
subroutine fortran_etdiv (A, B, C, D, E, F) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: A  ! 0D_NOT_real
  real(c_double) :: f_A
  real(c_double), pointer :: f_A_ptr
  type(c_ptr), intent(in), value :: B  ! 0D_NOT_real
  real(c_double) :: f_B
  real(c_double), pointer :: f_B_ptr
  type(c_ptr), intent(in), value :: C  ! 0D_NOT_real
  real(c_double) :: f_C
  real(c_double), pointer :: f_C_ptr
  type(c_ptr), intent(in), value :: D  ! 0D_NOT_real
  real(c_double) :: f_D
  real(c_double), pointer :: f_D_ptr
  type(c_ptr), intent(in), value :: E  ! 0D_NOT_real
  real(c_double) :: f_E
  real(c_double), pointer :: f_E_ptr
  type(c_ptr), intent(in), value :: F  ! 0D_NOT_real
  real(c_double) :: f_F
  real(c_double), pointer :: f_F_ptr
  ! ** End of parameters **
  ! inout: f_A 0D_NOT_real
  if (c_associated(A)) then
    call c_f_pointer(A, f_A_ptr)
  else
    f_A_ptr => null()
  endif
  ! inout: f_B 0D_NOT_real
  if (c_associated(B)) then
    call c_f_pointer(B, f_B_ptr)
  else
    f_B_ptr => null()
  endif
  ! inout: f_C 0D_NOT_real
  if (c_associated(C)) then
    call c_f_pointer(C, f_C_ptr)
  else
    f_C_ptr => null()
  endif
  ! inout: f_D 0D_NOT_real
  if (c_associated(D)) then
    call c_f_pointer(D, f_D_ptr)
  else
    f_D_ptr => null()
  endif
  ! inout: f_E 0D_NOT_real
  if (c_associated(E)) then
    call c_f_pointer(E, f_E_ptr)
  else
    f_E_ptr => null()
  endif
  ! inout: f_F 0D_NOT_real
  if (c_associated(F)) then
    call c_f_pointer(F, f_F_ptr)
  else
    f_F_ptr => null()
  endif
  call etdiv(A=f_A_ptr, B=f_B_ptr, C=f_C_ptr, D=f_D_ptr, E=f_E_ptr, F=f_F_ptr)

  ! inout: f_A 0D_NOT_real
  ! no output conversion for f_A
  ! inout: f_B 0D_NOT_real
  ! no output conversion for f_B
  ! inout: f_C 0D_NOT_real
  ! no output conversion for f_C
  ! inout: f_D 0D_NOT_real
  ! no output conversion for f_D
  ! inout: f_E 0D_NOT_real
  ! no output conversion for f_E
  ! inout: f_F 0D_NOT_real
  ! no output conversion for f_F
end subroutine
subroutine fortran_evaluate_array_index (err_flag, delim_list1, word2, delim_list2, delim2, &
    this_index) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: delim_list1
  character(len=4096), target :: f_delim_list1
  character(kind=c_char), pointer :: f_delim_list1_ptr(:)
  type(c_ptr), intent(in), value :: delim_list2
  character(len=4096), target :: f_delim_list2
  character(kind=c_char), pointer :: f_delim_list2_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: word2
  character(len=4096), target :: f_word2
  character(kind=c_char), pointer :: f_word2_ptr(:)
  type(c_ptr), intent(in), value :: delim2
  character(len=4096), target :: f_delim2
  character(kind=c_char), pointer :: f_delim2_ptr(:)
  type(c_ptr), intent(in), value :: this_index  ! 0D_NOT_integer
  integer :: f_this_index
  integer(c_int), pointer :: f_this_index_ptr
  ! ** End of parameters **
  ! in: f_delim_list1 0D_NOT_character
  if (.not. c_associated(delim_list1)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(delim_list1, f_delim_list1_ptr, [huge(0)])
  call to_f_str(f_delim_list1_ptr, f_delim_list1)
  ! in: f_delim_list2 0D_NOT_character
  if (.not. c_associated(delim_list2)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(delim_list2, f_delim_list2_ptr, [huge(0)])
  call to_f_str(f_delim_list2_ptr, f_delim_list2)
  f_this_index = evaluate_array_index(err_flag=f_err_flag, delim_list1=f_delim_list1, &
      word2=f_word2, delim_list2=f_delim_list2, delim2=f_delim2)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_word2 0D_NOT_character
  call c_f_pointer(word2, f_word2_ptr, [len_trim(f_word2) + 1]) ! output-only string
  call to_c_str(f_word2, f_word2_ptr)
  ! out: f_delim2 0D_NOT_character
  call c_f_pointer(delim2, f_delim2_ptr, [len_trim(f_delim2) + 1]) ! output-only string
  call to_c_str(f_delim2, f_delim2_ptr)
  ! out: f_this_index 0D_NOT_integer
  call c_f_pointer(this_index, f_this_index_ptr)
  f_this_index_ptr = f_this_index
end subroutine
subroutine fortran_evaluate_logical (word, iostat, this_logic) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: word
  character(len=4096), target :: f_word
  character(kind=c_char), pointer :: f_word_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: iostat  ! 0D_NOT_integer
  integer :: f_iostat
  integer(c_int), pointer :: f_iostat_ptr
  type(c_ptr), intent(in), value :: this_logic  ! 0D_NOT_logical
  logical :: f_this_logic
  logical(c_bool), pointer :: f_this_logic_ptr
  ! ** End of parameters **
  ! in: f_word 0D_NOT_character
  if (.not. c_associated(word)) return
  call c_f_pointer(word, f_word_ptr, [huge(0)])
  call to_f_str(f_word_ptr, f_word)
  f_this_logic = evaluate_logical(word=f_word, iostat=f_iostat)

  ! out: f_iostat 0D_NOT_integer
  call c_f_pointer(iostat, f_iostat_ptr)
  f_iostat_ptr = f_iostat
  ! out: f_this_logic 0D_NOT_logical
  call c_f_pointer(this_logic, f_this_logic_ptr)
  f_this_logic_ptr = f_this_logic
end subroutine
subroutine fortran_exact_bend_edge_kick (ele, param, particle_at, orb, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call exact_bend_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, orb=f_orb, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_exp_bessi0 (t, B1, B2, func_retval__) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: t  ! 0D_NOT_real
  REAL(rp) :: f_t
  real(c_double) :: B1  ! 0D_NOT_real
  REAL(rp) :: f_B1
  real(c_double) :: B2  ! 0D_NOT_real
  REAL(rp) :: f_B2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: func_retval__  ! 0D_NOT_real
  REAL(rp) :: f_func_retval__
  real(c_double), pointer :: f_func_retval___ptr
  ! ** End of parameters **
  ! in: f_t 0D_NOT_real
  f_t = t
  ! in: f_B1 0D_NOT_real
  f_B1 = B1
  ! in: f_B2 0D_NOT_real
  f_B2 = B2
  f_func_retval__ = exp_bessi0(t=f_t, B1=f_B1, B2=f_B2)

  ! out: f_func_retval__ 0D_NOT_real
  call c_f_pointer(func_retval__, f_func_retval___ptr)
  f_func_retval___ptr = f_func_retval__
end subroutine
subroutine fortran_expect_one_of (delim_list, check_input_delim, ele_name, delim, delim_found, &
    is_ok) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: delim_list
  character(len=4096), target :: f_delim_list
  character(kind=c_char), pointer :: f_delim_list_ptr(:)
  logical(c_bool) :: check_input_delim  ! 0D_NOT_logical
  logical :: f_check_input_delim
  type(c_ptr), intent(in), value :: ele_name
  character(len=4096), target :: f_ele_name
  character(kind=c_char), pointer :: f_ele_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  ! ** End of parameters **
  ! in: f_delim_list 0D_NOT_character
  if (.not. c_associated(delim_list)) return
  call c_f_pointer(delim_list, f_delim_list_ptr, [huge(0)])
  call to_f_str(f_delim_list_ptr, f_delim_list)
  ! in: f_check_input_delim 0D_NOT_logical
  f_check_input_delim = check_input_delim
  ! in: f_ele_name 0D_NOT_character
  if (.not. c_associated(ele_name)) return
  call c_f_pointer(ele_name, f_ele_name_ptr, [huge(0)])
  call to_f_str(f_ele_name_ptr, f_ele_name)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  f_is_ok = expect_one_of(delim_list=f_delim_list, check_input_delim=f_check_input_delim, &
      ele_name=f_ele_name, delim=f_delim, delim_found=f_delim_found_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_expect_this (expecting, check_delim, call_check, err_str, ele, delim, &
    delim_found, is_ok) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: expecting
  character(len=4096), target :: f_expecting
  character(kind=c_char), pointer :: f_expecting_ptr(:)
  logical(c_bool) :: check_delim  ! 0D_NOT_logical
  logical :: f_check_delim
  logical(c_bool) :: call_check  ! 0D_NOT_logical
  logical :: f_call_check
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical :: f_delim_found
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** End of parameters **
  ! in: f_expecting 0D_NOT_character
  if (.not. c_associated(expecting)) return
  call c_f_pointer(expecting, f_expecting_ptr, [huge(0)])
  call to_f_str(f_expecting_ptr, f_expecting)
  ! in: f_check_delim 0D_NOT_logical
  f_check_delim = check_delim
  ! in: f_call_check 0D_NOT_logical
  f_call_check = call_check
  ! in: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_is_ok = expect_this(expecting=f_expecting, check_delim=f_check_delim, &
      call_check=f_call_check, err_str=f_err_str, ele=f_ele, delim=f_delim, &
      delim_found=f_delim_found)

  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_delim_found 0D_NOT_logical
  call c_f_pointer(delim_found, f_delim_found_ptr)
  f_delim_found_ptr = f_delim_found
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_expression_stack_to_string (stack, polish, str) bind(c)

  use bmad_struct, only: expression_atom_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: stack
  type(expression_atom_struct_container_alloc), pointer :: f_stack
  type(c_ptr), intent(in), value :: polish  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_polish
  logical, target :: f_polish_native
  logical, pointer :: f_polish_native_ptr
  logical(c_bool), pointer :: f_polish_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str
  character(len=4096), target :: f_str
  character(kind=c_char), pointer :: f_str_ptr(:)
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(stack))   call c_f_pointer(stack, f_stack)
  ! in: f_polish 0D_NOT_logical
  if (c_associated(polish)) then
    call c_f_pointer(polish, f_polish_ptr)
    f_polish_native = f_polish_ptr
    f_polish_native_ptr => f_polish_native
  else
    f_polish_native_ptr => null()
  endif
  f_str = expression_stack_to_string(stack=f_stack%data, polish=f_polish_native_ptr)

  ! out: f_str 0D_ALLOC_character
  call c_f_pointer(str, f_str_ptr, [len_trim(f_str) + 1]) ! output-only string
  call to_c_str(f_str, f_str_ptr)
end subroutine
subroutine fortran_expression_stack_value (stack, err_flag, err_str, var, use_old, value) &
    bind(c)

  use bmad_struct, only: control_var1_struct, expression_atom_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: stack
  type(expression_atom_struct_container_alloc), pointer :: f_stack
  type(c_ptr), intent(in), value :: var
  type(control_var1_struct_container_alloc), pointer :: f_var
  type(c_ptr), intent(in), value :: use_old  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_old
  logical, target :: f_use_old_native
  logical, pointer :: f_use_old_native_ptr
  logical(c_bool), pointer :: f_use_old_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(rp) :: f_value
  real(c_double), pointer :: f_value_ptr
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(stack))   call c_f_pointer(stack, f_stack)
  !! container type array (1D_ALLOC_type)
  if (c_associated(var))   call c_f_pointer(var, f_var)
  ! in: f_use_old 0D_NOT_logical
  if (c_associated(use_old)) then
    call c_f_pointer(use_old, f_use_old_ptr)
    f_use_old_native = f_use_old_ptr
    f_use_old_native_ptr => f_use_old_native
  else
    f_use_old_native_ptr => null()
  endif
  f_value = expression_stack_value(stack=f_stack%data, err_flag=f_err_flag, err_str=f_err_str, &
      var=f_var%data, use_old=f_use_old_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_err_str 0D_NOT_character
  call c_f_pointer(err_str, f_err_str_ptr, [len_trim(f_err_str) + 1]) ! output-only string
  call to_c_str(f_err_str, f_err_str_ptr)
  ! out: f_value 0D_NOT_real
  call c_f_pointer(value, f_value_ptr)
  f_value_ptr = f_value
end subroutine
subroutine fortran_expression_string_to_stack (string, stack, n_stack, err_flag, err_str) &
    bind(c)

  use bmad_struct, only: expression_atom_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: string
  character(len=4096), target :: f_string
  character(kind=c_char), pointer :: f_string_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: stack
  type(expression_atom_struct_container_alloc), pointer :: f_stack
  type(c_ptr), intent(in), value :: n_stack  ! 0D_NOT_integer
  integer :: f_n_stack
  integer(c_int), pointer :: f_n_stack_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  ! ** End of parameters **
  ! in: f_string 0D_NOT_character
  if (.not. c_associated(string)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(string, f_string_ptr, [huge(0)])
  call to_f_str(f_string_ptr, f_string)
  !! container type array (1D_ALLOC_type)
  if (c_associated(stack))   call c_f_pointer(stack, f_stack)
  call expression_string_to_stack(string=f_string, stack=f_stack%data, n_stack=f_n_stack, &
      err_flag=f_err_flag, err_str=f_err_str)

  ! out: f_n_stack 0D_NOT_integer
  call c_f_pointer(n_stack, f_n_stack_ptr)
  f_n_stack_ptr = f_n_stack
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_err_str 0D_NOT_character
  call c_f_pointer(err_str, f_err_str_ptr, [len_trim(f_err_str) + 1]) ! output-only string
  call to_c_str(f_err_str, f_err_str_ptr)
end subroutine
subroutine fortran_expression_string_to_tree (string, root_tree, err_flag, err_str) bind(c)

  use bmad_struct, only: expression_tree_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: string
  character(len=4096), target :: f_string
  character(kind=c_char), pointer :: f_string_ptr(:)
  type(c_ptr), value :: root_tree  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_root_tree
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  ! ** End of parameters **
  ! in: f_string 0D_NOT_character
  if (.not. c_associated(string)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(string, f_string_ptr, [huge(0)])
  call to_f_str(f_string_ptr, f_string)
  ! in: f_root_tree 0D_NOT_type
  if (.not. c_associated(root_tree)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(root_tree, f_root_tree)
  call expression_string_to_tree(string=f_string, root_tree=f_root_tree, err_flag=f_err_flag, &
      err_str=f_err_str)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_err_str 0D_NOT_character
  call c_f_pointer(err_str, f_err_str_ptr, [len_trim(f_err_str) + 1]) ! output-only string
  call to_c_str(f_err_str, f_err_str_ptr)
end subroutine
subroutine fortran_expression_tree_to_string (tree, include_root, n_node, parent, str_out) &
    bind(c)

  use bmad_struct, only: expression_tree_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: tree  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_tree
  type(c_ptr), intent(in), value :: include_root  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_root
  logical, target :: f_include_root_native
  logical, pointer :: f_include_root_native_ptr
  logical(c_bool), pointer :: f_include_root_ptr
  type(c_ptr), intent(in), value :: n_node  ! 0D_NOT_integer
  integer(c_int) :: f_n_node
  integer(c_int), pointer :: f_n_node_ptr
  type(c_ptr), value :: parent  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_parent
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str_out
  character(len=4096), target :: f_str_out
  character(kind=c_char), pointer :: f_str_out_ptr(:)
  ! ** End of parameters **
  ! in: f_tree 0D_NOT_type
  if (.not. c_associated(tree)) return
  call c_f_pointer(tree, f_tree)
  ! in: f_include_root 0D_NOT_logical
  if (c_associated(include_root)) then
    call c_f_pointer(include_root, f_include_root_ptr)
    f_include_root_native = f_include_root_ptr
    f_include_root_native_ptr => f_include_root_native
  else
    f_include_root_native_ptr => null()
  endif
  ! in: f_n_node 0D_NOT_integer
  if (c_associated(n_node)) then
    call c_f_pointer(n_node, f_n_node_ptr)
  else
    f_n_node_ptr => null()
  endif
  ! in: f_parent 0D_NOT_type
  if (c_associated(parent))   call c_f_pointer(parent, f_parent)
  f_str_out = expression_tree_to_string(tree=f_tree, include_root=f_include_root_native_ptr, &
      n_node=f_n_node_ptr, parent=f_parent)

  ! out: f_str_out 0D_ALLOC_character
  call c_f_pointer(str_out, f_str_out_ptr, [len_trim(f_str_out) + 1]) ! output-only string
  call to_c_str(f_str_out, f_str_out_ptr)
end subroutine
subroutine fortran_expression_value (expression, err_flag, err_str, var, use_old, value) &
    bind(c)

  use bmad_struct, only: control_var1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: expression
  character(len=4096), target :: f_expression
  character(kind=c_char), pointer :: f_expression_ptr(:)
  type(c_ptr), intent(in), value :: var
  type(control_var1_struct_container_alloc), pointer :: f_var
  type(c_ptr), intent(in), value :: use_old  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_old
  logical, target :: f_use_old_native
  logical, pointer :: f_use_old_native_ptr
  logical(c_bool), pointer :: f_use_old_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  character(len=4096), pointer :: f_err_str_call_ptr
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(rp) :: f_value
  real(c_double), pointer :: f_value_ptr
  ! ** End of parameters **
  ! in: f_expression 0D_NOT_character
  if (.not. c_associated(expression)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(expression, f_expression_ptr, [huge(0)])
  call to_f_str(f_expression_ptr, f_expression)
  !! container type array (1D_ALLOC_type)
  if (c_associated(var))   call c_f_pointer(var, f_var)
  ! in: f_use_old 0D_NOT_logical
  if (c_associated(use_old)) then
    call c_f_pointer(use_old, f_use_old_ptr)
    f_use_old_native = f_use_old_ptr
    f_use_old_native_ptr => f_use_old_native
  else
    f_use_old_native_ptr => null()
  endif
  f_value = expression_value(expression=f_expression, err_flag=f_err_flag, &
      err_str=f_err_str_call_ptr, var=f_var%data, use_old=f_use_old_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_err_str 0D_NOT_character
  call c_f_pointer(err_str, f_err_str_ptr, [len_trim(f_err_str) + 1]) ! output-only string
  call to_c_str(f_err_str, f_err_str_ptr)
  ! out: f_value 0D_NOT_real
  call c_f_pointer(value, f_value_ptr)
  f_value_ptr = f_value
end subroutine
subroutine fortran_fft1 (a, b, n, isn, ierr) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  INTEGER :: f_n
  integer(c_int) :: isn  ! 0D_NOT_integer
  INTEGER :: f_isn
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ierr  ! 0D_NOT_integer
  INTEGER :: f_ierr
  integer(c_int), pointer :: f_ierr_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: a
  type(real_container_alloc), pointer :: f_a
  type(c_ptr), intent(in), value :: b
  type(real_container_alloc), pointer :: f_b
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(a))   call c_f_pointer(a, f_a)
  !! container general array (1D_ALLOC_real)
  if (c_associated(b))   call c_f_pointer(b, f_b)
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_isn 0D_NOT_integer
  f_isn = isn
  call fft1(a=f_a%data, b=f_b%data, n=f_n, isn=f_isn, ierr=f_ierr)

  ! out: f_ierr 0D_NOT_integer
  call c_f_pointer(ierr, f_ierr_ptr)
  f_ierr_ptr = f_ierr
end subroutine
subroutine fortran_field_attribute_free (ele, attrib_name, free) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: free  ! 0D_NOT_logical
  logical :: f_free
  logical(c_bool), pointer :: f_free_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  f_free = field_attribute_free(ele=f_ele, attrib_name=f_attrib_name)

  ! out: f_free 0D_NOT_logical
  call c_f_pointer(free, f_free_ptr)
  f_free_ptr = f_free
end subroutine
subroutine fortran_finalize_reflectivity_table (table, in_degrees) bind(c)

  use bmad_struct, only: photon_reflect_table_struct
  implicit none
  ! ** In parameters **
  logical(c_bool) :: in_degrees  ! 0D_NOT_logical
  logical :: f_in_degrees
  ! ** Inout parameters **
  type(c_ptr), value :: table  ! 0D_NOT_type
  type(photon_reflect_table_struct), pointer :: f_table
  ! ** End of parameters **
  ! inout: f_table 0D_NOT_type
  if (.not. c_associated(table)) return
  call c_f_pointer(table, f_table)
  ! in: f_in_degrees 0D_NOT_logical
  f_in_degrees = in_degrees
  call finalize_reflectivity_table(table=f_table, in_degrees=f_in_degrees)

end subroutine
subroutine fortran_find_element_ends (ele, ele1, ele2, ix_multipass) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: ix_multipass  ! 0D_NOT_integer
  integer(c_int) :: f_ix_multipass
  integer(c_int), pointer :: f_ix_multipass_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ele1  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele2
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_ele1 0D_PTR_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  ! out: f_ele2 0D_PTR_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  ! in: f_ix_multipass 0D_NOT_integer
  if (c_associated(ix_multipass)) then
    call c_f_pointer(ix_multipass, f_ix_multipass_ptr)
  else
    f_ix_multipass_ptr => null()
  endif
  call find_element_ends(ele=f_ele, ele1=f_ele1, ele2=f_ele2, ix_multipass=f_ix_multipass_ptr)

  ! out: f_ele1 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_ele2 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_find_fwhm (bound, args, fwhm) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: bound  ! 0D_NOT_real
  REAL(rp) :: f_bound
  type(c_ptr), intent(in), value :: args
  REAL(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: fwhm  ! 0D_NOT_real
  REAL(rp) :: f_fwhm
  real(c_double), pointer :: f_fwhm_ptr
  ! ** End of parameters **
  ! in: f_bound 0D_NOT_real
  f_bound = bound
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  call find_fwhm(bound=f_bound, args=f_args, fwhm=f_fwhm)

  ! out: f_fwhm 0D_NOT_real
  call c_f_pointer(fwhm, f_fwhm_ptr)
  f_fwhm_ptr = f_fwhm
end subroutine
subroutine fortran_find_matching_fieldmap (file_name, ele, fm_type, match_ele, ix_field, &
    ignore_slaves) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: fm_type  ! 0D_NOT_integer
  integer :: f_fm_type
  type(c_ptr), intent(in), value :: ignore_slaves  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_ignore_slaves
  logical, target :: f_ignore_slaves_native
  logical, pointer :: f_ignore_slaves_native_ptr
  logical(c_bool), pointer :: f_ignore_slaves_ptr
  ! ** Out parameters **
  type(c_ptr), value :: match_ele  ! 0D_PTR_type
  type(ele_struct), pointer :: f_match_ele
  type(c_ptr), intent(in), value :: ix_field  ! 0D_NOT_integer
  integer :: f_ix_field
  integer(c_int), pointer :: f_ix_field_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_fm_type 0D_NOT_integer
  f_fm_type = fm_type
  ! out: f_match_ele 0D_PTR_type
  if (.not. c_associated(match_ele)) return
  call c_f_pointer(match_ele, f_match_ele)
  ! in: f_ignore_slaves 0D_NOT_logical
  if (c_associated(ignore_slaves)) then
    call c_f_pointer(ignore_slaves, f_ignore_slaves_ptr)
    f_ignore_slaves_native = f_ignore_slaves_ptr
    f_ignore_slaves_native_ptr => f_ignore_slaves_native
  else
    f_ignore_slaves_native_ptr => null()
  endif
  call find_matching_fieldmap(file_name=f_file_name, ele=f_ele, fm_type=f_fm_type, &
      match_ele=f_match_ele, ix_field=f_ix_field, ignore_slaves=f_ignore_slaves_native_ptr)

  ! out: f_match_ele 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_ix_field 0D_NOT_integer
  call c_f_pointer(ix_field, f_ix_field_ptr)
  f_ix_field_ptr = f_ix_field
end subroutine
subroutine fortran_find_normalization (bound, p0, args, pnrml) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: bound  ! 0D_NOT_real
  REAL(rp) :: f_bound
  real(c_double) :: p0  ! 0D_NOT_real
  REAL(rp) :: f_p0
  type(c_ptr), intent(in), value :: args
  REAL(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: pnrml  ! 0D_NOT_real
  REAL(rp) :: f_pnrml
  real(c_double), pointer :: f_pnrml_ptr
  ! ** End of parameters **
  ! in: f_bound 0D_NOT_real
  f_bound = bound
  ! in: f_p0 0D_NOT_real
  f_p0 = p0
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  call find_normalization(bound=f_bound, p0=f_p0, args=f_args, pnrml=f_pnrml)

  ! out: f_pnrml 0D_NOT_real
  call c_f_pointer(pnrml, f_pnrml_ptr)
  f_pnrml_ptr = f_pnrml
end subroutine
subroutine fortran_floor_angles_to_w_mat (theta, phi, psi, w_mat, w_mat_inv) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: theta  ! 0D_NOT_real
  real(rp) :: f_theta
  real(c_double) :: phi  ! 0D_NOT_real
  real(rp) :: f_phi
  real(c_double) :: psi  ! 0D_NOT_real
  real(rp) :: f_psi
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), intent(in), value :: w_mat_inv
  real(rp) :: f_w_mat_inv(3,3)
  real(c_double), pointer :: f_w_mat_inv_ptr(:)
  ! ** End of parameters **
  ! in: f_theta 0D_NOT_real
  f_theta = theta
  ! in: f_phi 0D_NOT_real
  f_phi = phi
  ! in: f_psi 0D_NOT_real
  f_psi = psi
  call floor_angles_to_w_mat(theta=f_theta, phi=f_phi, psi=f_psi, w_mat=f_w_mat, &
      w_mat_inv=f_w_mat_inv)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=1330, definition='real(rp), optional :: w_mat(3,3), w_mat_inv(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='out', description='Orientation matrix.', doc_data_type='float', doc_is_optional=False)
  ! out: f_w_mat_inv 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat_inv', c_name='w_mat_inv', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=1330, definition='real(rp), optional :: w_mat(3,3), w_mat_inv(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat_inv', comment='', default=None), intent='out', description='Inverse Orientation matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_floor_w_mat_to_angles (w_mat, theta, phi, psi, floor0) bind(c)

  use bmad_struct, only: floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), value :: floor0  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor0
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: theta  ! 0D_NOT_real
  real(rp) :: f_theta
  real(c_double), pointer :: f_theta_ptr
  type(c_ptr), intent(in), value :: phi  ! 0D_NOT_real
  real(rp) :: f_phi
  real(c_double), pointer :: f_phi_ptr
  type(c_ptr), intent(in), value :: psi  ! 0D_NOT_real
  real(rp) :: f_psi
  real(c_double), pointer :: f_psi_ptr
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(w_mat)) then
    call c_f_pointer(w_mat, f_w_mat_ptr, [3*3])
    call vec2mat(f_w_mat_ptr, f_w_mat)
  else
    f_w_mat_ptr => null()
  endif
  ! in: f_floor0 0D_NOT_type
  if (c_associated(floor0))   call c_f_pointer(floor0, f_floor0)
  call floor_w_mat_to_angles(w_mat=f_w_mat, theta=f_theta, phi=f_phi, psi=f_psi, &
      floor0=f_floor0)

  ! out: f_theta 0D_NOT_real
  call c_f_pointer(theta, f_theta_ptr)
  f_theta_ptr = f_theta
  ! out: f_phi 0D_NOT_real
  call c_f_pointer(phi, f_phi_ptr)
  f_phi_ptr = f_phi
  ! out: f_psi 0D_NOT_real
  call c_f_pointer(psi, f_psi_ptr)
  f_psi_ptr = f_psi
end subroutine
subroutine fortran_form_complex_taylor (re_taylor, im_taylor, complex_taylor) bind(c)

  use bmad_struct, only: complex_taylor_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: re_taylor  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_re_taylor
  type(c_ptr), value :: im_taylor  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_im_taylor
  ! ** Out parameters **
  type(c_ptr), value :: complex_taylor  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor
  ! ** End of parameters **
  ! in: f_re_taylor 0D_NOT_type
  if (.not. c_associated(re_taylor)) return
  call c_f_pointer(re_taylor, f_re_taylor)
  ! in: f_im_taylor 0D_NOT_type
  if (.not. c_associated(im_taylor)) return
  call c_f_pointer(im_taylor, f_im_taylor)
  ! out: f_complex_taylor 0D_NOT_type
  if (.not. c_associated(complex_taylor)) return
  call c_f_pointer(complex_taylor, f_complex_taylor)
  call form_complex_taylor(re_taylor=f_re_taylor, im_taylor=f_im_taylor, &
      complex_taylor=f_complex_taylor)

  ! out: f_complex_taylor 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_form_digested_bmad_file_name (lat_file, digested_file, full_lat_file, &
    use_line) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: lat_file
  character(len=4096), target :: f_lat_file
  character(kind=c_char), pointer :: f_lat_file_ptr(:)
  type(c_ptr), intent(in), value :: use_line
  character(len=4096), target :: f_use_line
  character(kind=c_char), pointer :: f_use_line_ptr(:)
  character(len=4096), pointer :: f_use_line_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: digested_file
  character(len=4096), target :: f_digested_file
  character(kind=c_char), pointer :: f_digested_file_ptr(:)
  type(c_ptr), intent(in), value :: full_lat_file
  character(len=4096), target :: f_full_lat_file
  character(kind=c_char), pointer :: f_full_lat_file_ptr(:)
  character(len=4096), pointer :: f_full_lat_file_call_ptr
  ! ** End of parameters **
  ! in: f_lat_file 0D_NOT_character
  if (.not. c_associated(lat_file)) return
  call c_f_pointer(lat_file, f_lat_file_ptr, [huge(0)])
  call to_f_str(f_lat_file_ptr, f_lat_file)
  ! in: f_use_line 0D_NOT_character
  if (c_associated(use_line)) then
    call c_f_pointer(use_line, f_use_line_ptr, [huge(0)])
    call to_f_str(f_use_line_ptr, f_use_line)
    f_use_line_call_ptr => f_use_line
  else
    f_use_line_call_ptr => null()
  endif
  call form_digested_bmad_file_name(lat_file=f_lat_file, digested_file=f_digested_file, &
      full_lat_file=f_full_lat_file_call_ptr, use_line=f_use_line_call_ptr)

  ! out: f_digested_file 0D_NOT_character
  call c_f_pointer(digested_file, f_digested_file_ptr, [len_trim(f_digested_file) + 1]) ! output-only string
  call to_c_str(f_digested_file, f_digested_file_ptr)
  ! out: f_full_lat_file 0D_NOT_character
  call c_f_pointer(full_lat_file, f_full_lat_file_ptr, [len_trim(f_full_lat_file) + 1]) ! output-only string
  call to_c_str(f_full_lat_file, f_full_lat_file_ptr)
end subroutine
subroutine fortran_fringe_here (ele, orbit, particle_at, is_here) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_here  ! 0D_NOT_logical
  logical :: f_is_here
  logical(c_bool), pointer :: f_is_here_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  f_is_here = fringe_here(ele=f_ele, orbit=f_orbit, particle_at=f_particle_at)

  ! out: f_is_here 0D_NOT_logical
  call c_f_pointer(is_here, f_is_here_ptr)
  f_is_here_ptr = f_is_here
end subroutine
subroutine fortran_g_bend_from_em_field (b, e, orbit, g_bend) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: b
  real(rp) :: f_b(3)
  real(c_double), pointer :: f_b_ptr(:)
  type(c_ptr), intent(in), value :: e
  real(rp) :: f_e(3)
  real(c_double), pointer :: f_e_ptr(:)
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: g_bend
  real(rp) :: f_g_bend(3)
  real(c_double), pointer :: f_g_bend_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(b)) then
    call c_f_pointer(b, f_b_ptr, [3])
    f_b = f_b_ptr(:)
  else
    f_b_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(e)) then
    call c_f_pointer(e, f_e_ptr, [3])
    f_e = f_e_ptr(:)
  else
    f_e_ptr => null()
  endif
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  f_g_bend = g_bend_from_em_field(B=f_b, E=f_e, orbit=f_orbit)

  ! out: f_g_bend 1D_NOT_real
  if (c_associated(g_bend)) then
    call c_f_pointer(g_bend, f_g_bend_ptr, [3])
    f_g_bend_ptr = f_g_bend(:)
  endif
end subroutine
subroutine fortran_g_bending_strength_from_em_field (ele, param, s_rel, orbit, local_ref_frame, &
    g, dg) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  real(c_double) :: s_rel  ! 0D_NOT_real
  real(rp) :: f_s_rel
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  logical(c_bool) :: local_ref_frame  ! 0D_NOT_logical
  logical :: f_local_ref_frame
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: g
  real(rp) :: f_g(3)
  real(c_double), pointer :: f_g_ptr(:)
  type(c_ptr), intent(in), value :: dg
  real(rp) :: f_dg(3,3)
  real(c_double), pointer :: f_dg_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_s_rel 0D_NOT_real
  f_s_rel = s_rel
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_local_ref_frame 0D_NOT_logical
  f_local_ref_frame = local_ref_frame
  call g_bending_strength_from_em_field(ele=f_ele, param=f_param, s_rel=f_s_rel, orbit=f_orbit, &
      local_ref_frame=f_local_ref_frame, g=f_g, dg=f_dg)

  ! out: f_g 1D_NOT_real
  if (c_associated(g)) then
    call c_f_pointer(g, f_g_ptr, [3])
    f_g_ptr = f_g(:)
  endif
  ! out: f_dg 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_dg', c_name='dg', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=1358, definition='real(rp), optional :: dg(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='dg', comment='', default=None), intent='out', description='dg(:)/dr gradient. Takes into account dg_x/dx in a bend due to curvilinear coords.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_g_integrals_calc (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call g_integrals_calc(lat=f_lat)

end subroutine
subroutine fortran_gamma_ref (ele, gamma) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_gamma = gamma_ref(ele=f_ele)

  ! out: f_gamma 0D_NOT_real
  call c_f_pointer(gamma, f_gamma_ptr)
  f_gamma_ptr = f_gamma
end subroutine
subroutine fortran_gen_grad1_to_em_taylor (ele, gen_grad, iz, em_taylor) bind(c)

  use bmad_struct, only: ele_struct, em_taylor_struct, gen_grad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: gen_grad  ! 0D_NOT_type
  type(gen_grad_map_struct), pointer :: f_gen_grad
  integer(c_int) :: iz  ! 0D_NOT_integer
  integer :: f_iz
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: em_taylor
  type(em_taylor_struct), pointer :: f_em_taylor(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_gen_grad 0D_NOT_type
  if (.not. c_associated(gen_grad)) return
  call c_f_pointer(gen_grad, f_gen_grad)
  ! in: f_iz 0D_NOT_integer
  f_iz = iz
  !! type array (1D_NOT_type)
  call c_f_pointer(em_taylor, f_em_taylor, [3])
  call gen_grad1_to_em_taylor(ele=f_ele, gen_grad=f_gen_grad, iz=f_iz, em_taylor=f_em_taylor)

  ! out: f_em_taylor 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_gen_grad_at_s_to_em_taylor (ele, gen_grad, s_pos, em_taylor) bind(c)

  use bmad_struct, only: ele_struct, em_taylor_struct, gen_grad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: gen_grad  ! 0D_NOT_type
  type(gen_grad_map_struct), pointer :: f_gen_grad
  real(c_double) :: s_pos  ! 0D_NOT_real
  real(rp) :: f_s_pos
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: em_taylor
  type(em_taylor_struct), pointer :: f_em_taylor(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_gen_grad 0D_NOT_type
  if (.not. c_associated(gen_grad)) return
  call c_f_pointer(gen_grad, f_gen_grad)
  ! in: f_s_pos 0D_NOT_real
  f_s_pos = s_pos
  !! type array (1D_NOT_type)
  call c_f_pointer(em_taylor, f_em_taylor, [3])
  call gen_grad_at_s_to_em_taylor(ele=f_ele, gen_grad=f_gen_grad, s_pos=f_s_pos, &
      em_taylor=f_em_taylor)

  ! out: f_em_taylor 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_gen_grad_field (deriv, gg, rho, theta, field) bind(c)

  use bmad_struct, only: gen_grad1_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: field
  real(rp) :: f_field(3)
  real(c_double), pointer :: f_field_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: deriv
  type(real_container_alloc), pointer :: f_deriv
  type(c_ptr), value :: gg  ! 0D_NOT_type
  type(gen_grad1_struct), pointer :: f_gg
  type(c_ptr), intent(in), value :: rho  ! 0D_NOT_real
  real(c_double) :: f_rho
  real(c_double), pointer :: f_rho_ptr
  type(c_ptr), intent(in), value :: theta  ! 0D_NOT_real
  real(c_double) :: f_theta
  real(c_double), pointer :: f_theta_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(deriv))   call c_f_pointer(deriv, f_deriv)
  ! inout: f_gg 0D_NOT_type
  if (.not. c_associated(gg)) return
  call c_f_pointer(gg, f_gg)
  ! inout: f_rho 0D_NOT_real
  if (c_associated(rho)) then
    call c_f_pointer(rho, f_rho_ptr)
  else
    f_rho_ptr => null()
  endif
  ! inout: f_theta 0D_NOT_real
  if (c_associated(theta)) then
    call c_f_pointer(theta, f_theta_ptr)
  else
    f_theta_ptr => null()
  endif
  f_field = gen_grad_field(deriv=f_deriv%data, gg=f_gg, rho=f_rho_ptr, theta=f_theta_ptr)

  ! inout: f_rho 0D_NOT_real
  ! no output conversion for f_rho
  ! inout: f_theta 0D_NOT_real
  ! no output conversion for f_theta
  ! out: f_field 1D_NOT_real
  if (c_associated(field)) then
    call c_f_pointer(field, f_field_ptr, [3])
    f_field_ptr = f_field(:)
  endif
end subroutine
subroutine fortran_get_bl_from_fwhm (bound, args, sigma) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: bound  ! 0D_NOT_real
  REAL(rp) :: f_bound
  type(c_ptr), intent(in), value :: args
  REAL(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: sigma  ! 0D_NOT_real
  REAL(rp) :: f_sigma
  real(c_double), pointer :: f_sigma_ptr
  ! ** End of parameters **
  ! in: f_bound 0D_NOT_real
  f_bound = bound
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  call get_bl_from_fwhm(bound=f_bound, args=f_args, sigma=f_sigma)

  ! out: f_sigma 0D_NOT_real
  call c_f_pointer(sigma, f_sigma_ptr)
  f_sigma_ptr = f_sigma
end subroutine
subroutine fortran_get_called_file (delim, call_file, err) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: call_file
  character(len=4096), target :: f_call_file
  character(kind=c_char), pointer :: f_call_file_ptr(:)
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err
  logical, target :: f_err_native
  logical, pointer :: f_err_native_ptr
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_call_file 0D_NOT_character
  if (.not. c_associated(call_file)) return
  call c_f_pointer(call_file, f_call_file_ptr, [huge(0)])
  call to_f_str(f_call_file_ptr, f_call_file)
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_native = f_err_ptr
    f_err_native_ptr => f_err_native
  else
    f_err_native_ptr => null()
  endif
  call get_called_file(delim=f_delim, call_file=f_call_file, err=f_err_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_call_file 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_ptr = f_err_native
  else
    ! f_err unset
  endif
end subroutine
subroutine fortran_get_emit_from_sigma_mat (sigma_mat, normal, Nmat, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  type(c_ptr), intent(in), value :: Nmat
  real(rp) :: f_Nmat(6,6)
  real(c_double), pointer :: f_Nmat_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: normal
  real(rp) :: f_normal(3)
  real(c_double), pointer :: f_normal_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat)) then
    call c_f_pointer(sigma_mat, f_sigma_mat_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptr, f_sigma_mat)
  else
    f_sigma_mat_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(Nmat)) then
    call c_f_pointer(Nmat, f_Nmat_ptr, [6*6])
    call vec2mat(f_Nmat_ptr, f_Nmat)
  else
    f_Nmat_ptr => null()
  endif
  call get_emit_from_sigma_mat(sigma_mat=f_sigma_mat, normal=f_normal, Nmat=f_Nmat, &
      err_flag=f_err_flag)

  ! out: f_normal 1D_NOT_real
  if (c_associated(normal)) then
    call c_f_pointer(normal, f_normal_ptr, [3])
    f_normal_ptr = f_normal(:)
  endif
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_get_next_word (word, ix_word, delim_list, delim, delim_found, &
    upper_case_word, call_check, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: word
  character(len=4096), target :: f_word
  character(kind=c_char), pointer :: f_word_ptr(:)
  integer(c_int) :: ix_word  ! 0D_NOT_integer
  integer :: f_ix_word
  type(c_ptr), intent(in), value :: delim_list
  character(len=4096), target :: f_delim_list
  character(kind=c_char), pointer :: f_delim_list_ptr(:)
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  logical(c_bool) :: delim_found  ! 0D_NOT_logical
  logical :: f_delim_found
  type(c_ptr), intent(in), value :: upper_case_word  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_upper_case_word
  logical, target :: f_upper_case_word_native
  logical, pointer :: f_upper_case_word_native_ptr
  logical(c_bool), pointer :: f_upper_case_word_ptr
  type(c_ptr), intent(in), value :: call_check  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_call_check
  logical, target :: f_call_check_native
  logical, pointer :: f_call_check_native_ptr
  logical(c_bool), pointer :: f_call_check_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_word 0D_NOT_character
  if (.not. c_associated(word)) return
  call c_f_pointer(word, f_word_ptr, [huge(0)])
  call to_f_str(f_word_ptr, f_word)
  ! in: f_ix_word 0D_NOT_integer
  f_ix_word = ix_word
  ! in: f_delim_list 0D_NOT_character
  if (.not. c_associated(delim_list)) return
  call c_f_pointer(delim_list, f_delim_list_ptr, [huge(0)])
  call to_f_str(f_delim_list_ptr, f_delim_list)
  ! in: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! in: f_delim_found 0D_NOT_logical
  f_delim_found = delim_found
  ! in: f_upper_case_word 0D_NOT_logical
  if (c_associated(upper_case_word)) then
    call c_f_pointer(upper_case_word, f_upper_case_word_ptr)
    f_upper_case_word_native = f_upper_case_word_ptr
    f_upper_case_word_native_ptr => f_upper_case_word_native
  else
    f_upper_case_word_native_ptr => null()
  endif
  ! in: f_call_check 0D_NOT_logical
  if (c_associated(call_check)) then
    call c_f_pointer(call_check, f_call_check_ptr)
    f_call_check_native = f_call_check_ptr
    f_call_check_native_ptr => f_call_check_native
  else
    f_call_check_native_ptr => null()
  endif
  ! in: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call get_next_word(word=f_word, ix_word=f_ix_word, delim_list=f_delim_list, delim=f_delim, &
      delim_found=f_delim_found, upper_case_word=f_upper_case_word_native_ptr, &
      call_check=f_call_check_native_ptr, err_flag=f_err_flag_native_ptr)

end subroutine
subroutine fortran_get_slave_list (lord, slaves, n_slave) bind(c)

  use bmad_struct, only: ele_pointer_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: slaves
  type(ele_pointer_struct_container_alloc), pointer :: f_slaves
  type(c_ptr), intent(in), value :: n_slave  ! 0D_NOT_integer
  integer :: f_n_slave
  integer(c_int), pointer :: f_n_slave_ptr
  ! ** End of parameters **
  ! in: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  !! container type array (1D_ALLOC_type)
  if (c_associated(slaves))   call c_f_pointer(slaves, f_slaves)
  call get_slave_list(lord=f_lord, slaves=f_slaves%data, n_slave=f_n_slave)

  ! out: f_n_slave 0D_NOT_integer
  call c_f_pointer(n_slave, f_n_slave_ptr)
  f_n_slave_ptr = f_n_slave
end subroutine
subroutine fortran_gpt_field_grid_scaling (ele, dimensions, field_scale, ref_time) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: dimensions  ! 0D_NOT_integer
  integer(c_int) :: f_dimensions
  integer(c_int), pointer :: f_dimensions_ptr
  type(c_ptr), intent(in), value :: field_scale  ! 0D_NOT_real
  real(c_double) :: f_field_scale
  real(c_double), pointer :: f_field_scale_ptr
  type(c_ptr), intent(in), value :: ref_time  ! 0D_NOT_real
  real(c_double) :: f_ref_time
  real(c_double), pointer :: f_ref_time_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_dimensions 0D_NOT_integer
  if (c_associated(dimensions)) then
    call c_f_pointer(dimensions, f_dimensions_ptr)
  else
    f_dimensions_ptr => null()
  endif
  ! inout: f_field_scale 0D_NOT_real
  if (c_associated(field_scale)) then
    call c_f_pointer(field_scale, f_field_scale_ptr)
  else
    f_field_scale_ptr => null()
  endif
  ! inout: f_ref_time 0D_NOT_real
  if (c_associated(ref_time)) then
    call c_f_pointer(ref_time, f_ref_time_ptr)
  else
    f_ref_time_ptr => null()
  endif
  call gpt_field_grid_scaling(ele=f_ele, dimensions=f_dimensions_ptr, &
      field_scale=f_field_scale_ptr, ref_time=f_ref_time_ptr)

  ! inout: f_dimensions 0D_NOT_integer
  ! no output conversion for f_dimensions
  ! inout: f_field_scale 0D_NOT_real
  ! no output conversion for f_field_scale
  ! inout: f_ref_time 0D_NOT_real
  ! no output conversion for f_ref_time
end subroutine
subroutine fortran_gpt_max_field_reference (pt0, ele, field_value) bind(c)

  use bmad_struct, only: ele_struct, grid_field_pt1_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: field_value  ! 0D_NOT_real
  real(rp) :: f_field_value
  real(c_double), pointer :: f_field_value_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: pt0  ! 0D_NOT_type
  type(grid_field_pt1_struct), pointer :: f_pt0
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_pt0 0D_NOT_type
  if (.not. c_associated(pt0)) return
  call c_f_pointer(pt0, f_pt0)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_field_value = gpt_max_field_reference(pt0=f_pt0, ele=f_ele)

  ! out: f_field_value 0D_NOT_real
  call c_f_pointer(field_value, f_field_value_ptr)
  f_field_value_ptr = f_field_value
end subroutine
subroutine fortran_gpt_to_particle_bunch (gpt_file, ele, bunch, err_flag) bind(c)

  use bmad_struct, only: bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: gpt_file
  character(len=4096), target :: f_gpt_file
  character(kind=c_char), pointer :: f_gpt_file_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_gpt_file 0D_NOT_character
  if (.not. c_associated(gpt_file)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(gpt_file, f_gpt_file_ptr, [huge(0)])
  call to_f_str(f_gpt_file_ptr, f_gpt_file)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! out: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(bunch, f_bunch)
  call gpt_to_particle_bunch(gpt_file=f_gpt_file, ele=f_ele, bunch=f_bunch, &
      err_flag=f_err_flag)

  ! out: f_bunch 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_gradient_shift_sr_wake (ele, param, grad_shift) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: grad_shift  ! 0D_NOT_real
  real(rp) :: f_grad_shift
  real(c_double), pointer :: f_grad_shift_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  f_grad_shift = gradient_shift_sr_wake(ele=f_ele, param=f_param)

  ! out: f_grad_shift 0D_NOT_real
  call c_f_pointer(grad_shift, f_grad_shift_ptr)
  f_grad_shift_ptr = f_grad_shift
end subroutine
subroutine fortran_grid_field_interpolate (ele, orbit, grid, g_field, err_flag, x1, x2, x3, &
    allow_s_out_of_bounds, print_err) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, grid_field_pt1_struct, grid_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: grid  ! 0D_NOT_type
  type(grid_field_struct), pointer :: f_grid
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  real(c_double) :: x1  ! 0D_NOT_real
  real(rp) :: f_x1
  type(c_ptr), intent(in), value :: x2  ! 0D_NOT_real
  real(c_double) :: f_x2
  real(c_double), pointer :: f_x2_ptr
  type(c_ptr), intent(in), value :: x3  ! 0D_NOT_real
  real(c_double) :: f_x3
  real(c_double), pointer :: f_x3_ptr
  type(c_ptr), intent(in), value :: allow_s_out_of_bounds  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_allow_s_out_of_bounds
  logical, target :: f_allow_s_out_of_bounds_native
  logical, pointer :: f_allow_s_out_of_bounds_native_ptr
  logical(c_bool), pointer :: f_allow_s_out_of_bounds_ptr
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), value :: g_field  ! 0D_NOT_type
  type(grid_field_pt1_struct), pointer :: f_g_field
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_grid 0D_NOT_type
  if (.not. c_associated(grid)) return
  call c_f_pointer(grid, f_grid)
  ! out: f_g_field 0D_NOT_type
  if (.not. c_associated(g_field)) return
  call c_f_pointer(g_field, f_g_field)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  ! in: f_x1 0D_NOT_real
  f_x1 = x1
  ! in: f_x2 0D_NOT_real
  if (c_associated(x2)) then
    call c_f_pointer(x2, f_x2_ptr)
  else
    f_x2_ptr => null()
  endif
  ! in: f_x3 0D_NOT_real
  if (c_associated(x3)) then
    call c_f_pointer(x3, f_x3_ptr)
  else
    f_x3_ptr => null()
  endif
  ! in: f_allow_s_out_of_bounds 0D_NOT_logical
  if (c_associated(allow_s_out_of_bounds)) then
    call c_f_pointer(allow_s_out_of_bounds, f_allow_s_out_of_bounds_ptr)
    f_allow_s_out_of_bounds_native = f_allow_s_out_of_bounds_ptr
    f_allow_s_out_of_bounds_native_ptr => f_allow_s_out_of_bounds_native
  else
    f_allow_s_out_of_bounds_native_ptr => null()
  endif
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call grid_field_interpolate(ele=f_ele, orbit=f_orbit, grid=f_grid, g_field=f_g_field, &
      err_flag=f_err_flag, x1=f_x1, x2=f_x2_ptr, x3=f_x3_ptr, &
      allow_s_out_of_bounds=f_allow_s_out_of_bounds_native_ptr, &
      print_err=f_print_err_native_ptr)

  ! out: f_g_field 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_hard_multipole_edge_kick (ele, param, particle_at, orbit, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call hard_multipole_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, &
      orbit=f_orbit, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_has_attribute (ele, attrib, has_it) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: has_it  ! 0D_NOT_logical
  logical :: f_has_it
  logical(c_bool), pointer :: f_has_it_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: attrib
  character(len=4096), target :: f_attrib
  character(kind=c_char), pointer :: f_attrib_ptr(:)
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_attrib 0D_NOT_character
  if (.not. c_associated(attrib)) return
  call c_f_pointer(attrib, f_attrib_ptr, [huge(0)])
  call to_f_str(f_attrib_ptr, f_attrib)
  f_has_it = has_attribute(ele=f_ele, attrib=f_attrib)

  ! inout: f_attrib 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! out: f_has_it 0D_NOT_logical
  call c_f_pointer(has_it, f_has_it_ptr)
  f_has_it_ptr = f_has_it
end subroutine
subroutine fortran_has_curvature (phot_ele, curved) bind(c)

  use bmad_struct, only: photon_element_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: phot_ele  ! 0D_NOT_type
  type(photon_element_struct), pointer :: f_phot_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: curved  ! 0D_NOT_logical
  logical :: f_curved
  logical(c_bool), pointer :: f_curved_ptr
  ! ** End of parameters **
  ! in: f_phot_ele 0D_NOT_type
  if (.not. c_associated(phot_ele)) return
  call c_f_pointer(phot_ele, f_phot_ele)
  f_curved = has_curvature(phot_ele=f_phot_ele)

  ! out: f_curved 0D_NOT_logical
  call c_f_pointer(curved, f_curved_ptr)
  f_curved_ptr = f_curved
end subroutine
subroutine fortran_has_orientation_attributes (ele, has_attribs) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: has_attribs  ! 0D_NOT_logical
  logical :: f_has_attribs
  logical(c_bool), pointer :: f_has_attribs_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_has_attribs = has_orientation_attributes(ele=f_ele)

  ! out: f_has_attribs 0D_NOT_logical
  call c_f_pointer(has_attribs, f_has_attribs_ptr)
  f_has_attribs_ptr = f_has_attribs
end subroutine
subroutine fortran_hdf5_write_beam (file_name, bunches, append, error, lat, alive_only) bind(c)

  use bmad_struct, only: bunch_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), intent(in), value :: bunches
  type(bunch_struct_container_alloc), pointer :: f_bunches
  type(c_ptr), intent(in), value :: append  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_append
  logical, target :: f_append_native
  logical, pointer :: f_append_native_ptr
  logical(c_bool), pointer :: f_append_ptr
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_error
  logical, target :: f_error_native
  logical, pointer :: f_error_native_ptr
  logical(c_bool), pointer :: f_error_ptr
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: alive_only  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_alive_only
  logical, target :: f_alive_only_native
  logical, pointer :: f_alive_only_native_ptr
  logical(c_bool), pointer :: f_alive_only_ptr
  ! ** End of parameters **
  ! inout: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  !! container type array (1D_ALLOC_type)
  if (c_associated(bunches))   call c_f_pointer(bunches, f_bunches)
  ! inout: f_append 0D_NOT_logical
  if (c_associated(append)) then
    call c_f_pointer(append, f_append_ptr)
    f_append_native = f_append_ptr
    f_append_native_ptr => f_append_native
  else
    f_append_native_ptr => null()
  endif
  ! inout: f_error 0D_NOT_logical
  if (c_associated(error)) then
    call c_f_pointer(error, f_error_ptr)
    f_error_native = f_error_ptr
    f_error_native_ptr => f_error_native
  else
    f_error_native_ptr => null()
  endif
  ! inout: f_lat 0D_NOT_type
  if (c_associated(lat))   call c_f_pointer(lat, f_lat)
  ! inout: f_alive_only 0D_NOT_logical
  if (c_associated(alive_only)) then
    call c_f_pointer(alive_only, f_alive_only_ptr)
    f_alive_only_native = f_alive_only_ptr
    f_alive_only_native_ptr => f_alive_only_native
  else
    f_alive_only_native_ptr => null()
  endif
  call hdf5_write_beam(file_name=f_file_name, bunches=f_bunches%data, &
      append=f_append_native_ptr, error=f_error_native_ptr, lat=f_lat, &
      alive_only=f_alive_only_native_ptr)

  ! inout: f_file_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_append 0D_NOT_logical
  if (c_associated(append)) then
    call c_f_pointer(append, f_append_ptr)
    f_append_ptr = f_append_native
  else
    ! f_append unset
  endif
  ! inout: f_error 0D_NOT_logical
  if (c_associated(error)) then
    call c_f_pointer(error, f_error_ptr)
    f_error_ptr = f_error_native
  else
    ! f_error unset
  endif
  ! inout: f_alive_only 0D_NOT_logical
  if (c_associated(alive_only)) then
    call c_f_pointer(alive_only, f_alive_only_ptr)
    f_alive_only_ptr = f_alive_only_native
  else
    ! f_alive_only unset
  endif
end subroutine
subroutine fortran_hdf5_write_grid_field (file_name, ele, g_field, err_flag) bind(c)

  use bmad_struct, only: ele_struct, grid_field_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: g_field
  type(grid_field_struct_container_alloc), pointer :: f_g_field
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container type array (1D_ALLOC_type)
  if (c_associated(g_field))   call c_f_pointer(g_field, f_g_field)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call hdf5_write_grid_field(file_name=f_file_name, ele=f_ele, g_field=f_g_field%data, &
      err_flag=f_err_flag_native_ptr)

  ! inout: f_file_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_hwang_bend_edge_kick (ele, param, particle_at, orb, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call hwang_bend_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, orb=f_orb, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_ibs_matrix_c (sigma_mat, tail_cut, tau, energy, n_part, species, ibs_mat) &
    bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ibs_mat
  real(rp) :: f_ibs_mat(6,6)
  real(c_double), pointer :: f_ibs_mat_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  type(c_ptr), intent(in), value :: tail_cut  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_tail_cut
  logical, target :: f_tail_cut_native
  logical, pointer :: f_tail_cut_native_ptr
  logical(c_bool), pointer :: f_tail_cut_ptr
  type(c_ptr), intent(in), value :: tau  ! 0D_NOT_real
  real(c_double) :: f_tau
  real(c_double), pointer :: f_tau_ptr
  type(c_ptr), intent(in), value :: energy  ! 0D_NOT_real
  real(c_double) :: f_energy
  real(c_double), pointer :: f_energy_ptr
  type(c_ptr), intent(in), value :: n_part  ! 0D_NOT_real
  real(c_double) :: f_n_part
  real(c_double), pointer :: f_n_part_ptr
  type(c_ptr), intent(in), value :: species  ! 0D_NOT_integer
  integer(c_int) :: f_species
  integer(c_int), pointer :: f_species_ptr
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat)) then
    call c_f_pointer(sigma_mat, f_sigma_mat_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptr, f_sigma_mat)
  else
    f_sigma_mat_ptr => null()
  endif
  ! inout: f_tail_cut 0D_NOT_logical
  if (c_associated(tail_cut)) then
    call c_f_pointer(tail_cut, f_tail_cut_ptr)
    f_tail_cut_native = f_tail_cut_ptr
    f_tail_cut_native_ptr => f_tail_cut_native
  else
    f_tail_cut_native_ptr => null()
  endif
  ! inout: f_tau 0D_NOT_real
  if (c_associated(tau)) then
    call c_f_pointer(tau, f_tau_ptr)
  else
    f_tau_ptr => null()
  endif
  ! inout: f_energy 0D_NOT_real
  if (c_associated(energy)) then
    call c_f_pointer(energy, f_energy_ptr)
  else
    f_energy_ptr => null()
  endif
  ! inout: f_n_part 0D_NOT_real
  if (c_associated(n_part)) then
    call c_f_pointer(n_part, f_n_part_ptr)
  else
    f_n_part_ptr => null()
  endif
  ! inout: f_species 0D_NOT_integer
  if (c_associated(species)) then
    call c_f_pointer(species, f_species_ptr)
  else
    f_species_ptr => null()
  endif
  f_ibs_mat = ibs_matrix_c(sigma_mat=f_sigma_mat, tail_cut=f_tail_cut_native_ptr, &
      tau=f_tau_ptr, energy=f_energy_ptr, n_part=f_n_part_ptr, species=f_species_ptr)

  ! inout: f_tail_cut 0D_NOT_logical
  if (c_associated(tail_cut)) then
    call c_f_pointer(tail_cut, f_tail_cut_ptr)
    f_tail_cut_ptr = f_tail_cut_native
  else
    ! f_tail_cut unset
  endif
  ! inout: f_tau 0D_NOT_real
  ! no output conversion for f_tau
  ! inout: f_energy 0D_NOT_real
  ! no output conversion for f_energy
  ! inout: f_n_part 0D_NOT_real
  ! no output conversion for f_n_part
  ! inout: f_species 0D_NOT_integer
  ! no output conversion for f_species
  ! out: f_ibs_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_ibs_mat', c_name='ibs_mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=736, definition='real(rp) sigma_mat(6,6), ibs_mat(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='ibs_mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_igfcoulombfun (u, v, w, gam, dx, dy, dz, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: u  ! 0D_NOT_real
  real(c_double) :: f_u
  real(c_double), pointer :: f_u_ptr
  type(c_ptr), intent(in), value :: v  ! 0D_NOT_real
  real(c_double) :: f_v
  real(c_double), pointer :: f_v_ptr
  type(c_ptr), intent(in), value :: w  ! 0D_NOT_real
  real(c_double) :: f_w
  real(c_double), pointer :: f_w_ptr
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  type(c_ptr), intent(in), value :: dx  ! 0D_NOT_real
  real(c_double) :: f_dx
  real(c_double), pointer :: f_dx_ptr
  type(c_ptr), intent(in), value :: dy  ! 0D_NOT_real
  real(c_double) :: f_dy
  real(c_double), pointer :: f_dy_ptr
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** End of parameters **
  ! inout: f_u 0D_NOT_real
  if (c_associated(u)) then
    call c_f_pointer(u, f_u_ptr)
  else
    f_u_ptr => null()
  endif
  ! inout: f_v 0D_NOT_real
  if (c_associated(v)) then
    call c_f_pointer(v, f_v_ptr)
  else
    f_v_ptr => null()
  endif
  ! inout: f_w 0D_NOT_real
  if (c_associated(w)) then
    call c_f_pointer(w, f_w_ptr)
  else
    f_w_ptr => null()
  endif
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  ! inout: f_dx 0D_NOT_real
  if (c_associated(dx)) then
    call c_f_pointer(dx, f_dx_ptr)
  else
    f_dx_ptr => null()
  endif
  ! inout: f_dy 0D_NOT_real
  if (c_associated(dy)) then
    call c_f_pointer(dy, f_dy_ptr)
  else
    f_dy_ptr => null()
  endif
  ! inout: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  f_res = igfcoulombfun(u=f_u_ptr, v=f_v_ptr, w=f_w_ptr, gam=f_gam_ptr, dx=f_dx_ptr, &
      dy=f_dy_ptr, dz=f_dz_ptr)

  ! inout: f_u 0D_NOT_real
  ! no output conversion for f_u
  ! inout: f_v 0D_NOT_real
  ! no output conversion for f_v
  ! inout: f_w 0D_NOT_real
  ! no output conversion for f_w
  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! inout: f_dx 0D_NOT_real
  ! no output conversion for f_dx
  ! inout: f_dy 0D_NOT_real
  ! no output conversion for f_dy
  ! inout: f_dz 0D_NOT_real
  ! no output conversion for f_dz
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_igfexfun (u, v, w, gam, dx, dy, dz, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: u  ! 0D_NOT_real
  real(c_double) :: f_u
  real(c_double), pointer :: f_u_ptr
  type(c_ptr), intent(in), value :: v  ! 0D_NOT_real
  real(c_double) :: f_v
  real(c_double), pointer :: f_v_ptr
  type(c_ptr), intent(in), value :: w  ! 0D_NOT_real
  real(c_double) :: f_w
  real(c_double), pointer :: f_w_ptr
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  type(c_ptr), intent(in), value :: dx  ! 0D_NOT_real
  real(c_double) :: f_dx
  real(c_double), pointer :: f_dx_ptr
  type(c_ptr), intent(in), value :: dy  ! 0D_NOT_real
  real(c_double) :: f_dy
  real(c_double), pointer :: f_dy_ptr
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** End of parameters **
  ! inout: f_u 0D_NOT_real
  if (c_associated(u)) then
    call c_f_pointer(u, f_u_ptr)
  else
    f_u_ptr => null()
  endif
  ! inout: f_v 0D_NOT_real
  if (c_associated(v)) then
    call c_f_pointer(v, f_v_ptr)
  else
    f_v_ptr => null()
  endif
  ! inout: f_w 0D_NOT_real
  if (c_associated(w)) then
    call c_f_pointer(w, f_w_ptr)
  else
    f_w_ptr => null()
  endif
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  ! inout: f_dx 0D_NOT_real
  if (c_associated(dx)) then
    call c_f_pointer(dx, f_dx_ptr)
  else
    f_dx_ptr => null()
  endif
  ! inout: f_dy 0D_NOT_real
  if (c_associated(dy)) then
    call c_f_pointer(dy, f_dy_ptr)
  else
    f_dy_ptr => null()
  endif
  ! inout: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  f_res = igfexfun(u=f_u_ptr, v=f_v_ptr, w=f_w_ptr, gam=f_gam_ptr, dx=f_dx_ptr, dy=f_dy_ptr, &
      dz=f_dz_ptr)

  ! inout: f_u 0D_NOT_real
  ! no output conversion for f_u
  ! inout: f_v 0D_NOT_real
  ! no output conversion for f_v
  ! inout: f_w 0D_NOT_real
  ! no output conversion for f_w
  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! inout: f_dx 0D_NOT_real
  ! no output conversion for f_dx
  ! inout: f_dy 0D_NOT_real
  ! no output conversion for f_dy
  ! inout: f_dz 0D_NOT_real
  ! no output conversion for f_dz
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_igfeyfun (u, v, w, gam, dx, dy, dz, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: u  ! 0D_NOT_real
  real(c_double) :: f_u
  real(c_double), pointer :: f_u_ptr
  type(c_ptr), intent(in), value :: v  ! 0D_NOT_real
  real(c_double) :: f_v
  real(c_double), pointer :: f_v_ptr
  type(c_ptr), intent(in), value :: w  ! 0D_NOT_real
  real(c_double) :: f_w
  real(c_double), pointer :: f_w_ptr
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  type(c_ptr), intent(in), value :: dx  ! 0D_NOT_real
  real(c_double) :: f_dx
  real(c_double), pointer :: f_dx_ptr
  type(c_ptr), intent(in), value :: dy  ! 0D_NOT_real
  real(c_double) :: f_dy
  real(c_double), pointer :: f_dy_ptr
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** End of parameters **
  ! inout: f_u 0D_NOT_real
  if (c_associated(u)) then
    call c_f_pointer(u, f_u_ptr)
  else
    f_u_ptr => null()
  endif
  ! inout: f_v 0D_NOT_real
  if (c_associated(v)) then
    call c_f_pointer(v, f_v_ptr)
  else
    f_v_ptr => null()
  endif
  ! inout: f_w 0D_NOT_real
  if (c_associated(w)) then
    call c_f_pointer(w, f_w_ptr)
  else
    f_w_ptr => null()
  endif
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  ! inout: f_dx 0D_NOT_real
  if (c_associated(dx)) then
    call c_f_pointer(dx, f_dx_ptr)
  else
    f_dx_ptr => null()
  endif
  ! inout: f_dy 0D_NOT_real
  if (c_associated(dy)) then
    call c_f_pointer(dy, f_dy_ptr)
  else
    f_dy_ptr => null()
  endif
  ! inout: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  f_res = igfeyfun(u=f_u_ptr, v=f_v_ptr, w=f_w_ptr, gam=f_gam_ptr, dx=f_dx_ptr, dy=f_dy_ptr, &
      dz=f_dz_ptr)

  ! inout: f_u 0D_NOT_real
  ! no output conversion for f_u
  ! inout: f_v 0D_NOT_real
  ! no output conversion for f_v
  ! inout: f_w 0D_NOT_real
  ! no output conversion for f_w
  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! inout: f_dx 0D_NOT_real
  ! no output conversion for f_dx
  ! inout: f_dy 0D_NOT_real
  ! no output conversion for f_dy
  ! inout: f_dz 0D_NOT_real
  ! no output conversion for f_dz
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_igfezfun (u, v, w, gam, dx, dy, dz, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: u  ! 0D_NOT_real
  real(c_double) :: f_u
  real(c_double), pointer :: f_u_ptr
  type(c_ptr), intent(in), value :: v  ! 0D_NOT_real
  real(c_double) :: f_v
  real(c_double), pointer :: f_v_ptr
  type(c_ptr), intent(in), value :: w  ! 0D_NOT_real
  real(c_double) :: f_w
  real(c_double), pointer :: f_w_ptr
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  type(c_ptr), intent(in), value :: dx  ! 0D_NOT_real
  real(c_double) :: f_dx
  real(c_double), pointer :: f_dx_ptr
  type(c_ptr), intent(in), value :: dy  ! 0D_NOT_real
  real(c_double) :: f_dy
  real(c_double), pointer :: f_dy_ptr
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** End of parameters **
  ! inout: f_u 0D_NOT_real
  if (c_associated(u)) then
    call c_f_pointer(u, f_u_ptr)
  else
    f_u_ptr => null()
  endif
  ! inout: f_v 0D_NOT_real
  if (c_associated(v)) then
    call c_f_pointer(v, f_v_ptr)
  else
    f_v_ptr => null()
  endif
  ! inout: f_w 0D_NOT_real
  if (c_associated(w)) then
    call c_f_pointer(w, f_w_ptr)
  else
    f_w_ptr => null()
  endif
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  ! inout: f_dx 0D_NOT_real
  if (c_associated(dx)) then
    call c_f_pointer(dx, f_dx_ptr)
  else
    f_dx_ptr => null()
  endif
  ! inout: f_dy 0D_NOT_real
  if (c_associated(dy)) then
    call c_f_pointer(dy, f_dy_ptr)
  else
    f_dy_ptr => null()
  endif
  ! inout: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  f_res = igfezfun(u=f_u_ptr, v=f_v_ptr, w=f_w_ptr, gam=f_gam_ptr, dx=f_dx_ptr, dy=f_dy_ptr, &
      dz=f_dz_ptr)

  ! inout: f_u 0D_NOT_real
  ! no output conversion for f_u
  ! inout: f_v 0D_NOT_real
  ! no output conversion for f_v
  ! inout: f_w 0D_NOT_real
  ! no output conversion for f_w
  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! inout: f_dx 0D_NOT_real
  ! no output conversion for f_dx
  ! inout: f_dy 0D_NOT_real
  ! no output conversion for f_dy
  ! inout: f_dz 0D_NOT_real
  ! no output conversion for f_dz
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_init_attribute_name1 (ix_key, ix_attrib, name, attrib_state, override) &
    bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: ix_key  ! 0D_NOT_integer
  integer :: f_ix_key
  integer(c_int) :: ix_attrib  ! 0D_NOT_integer
  integer :: f_ix_attrib
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  type(c_ptr), intent(in), value :: attrib_state  ! 0D_NOT_integer
  integer(c_int) :: f_attrib_state
  integer(c_int), pointer :: f_attrib_state_ptr
  type(c_ptr), intent(in), value :: override  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_override
  logical, target :: f_override_native
  logical, pointer :: f_override_native_ptr
  logical(c_bool), pointer :: f_override_ptr
  ! ** End of parameters **
  ! in: f_ix_key 0D_NOT_integer
  f_ix_key = ix_key
  ! in: f_ix_attrib 0D_NOT_integer
  f_ix_attrib = ix_attrib
  ! in: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  ! in: f_attrib_state 0D_NOT_integer
  if (c_associated(attrib_state)) then
    call c_f_pointer(attrib_state, f_attrib_state_ptr)
  else
    f_attrib_state_ptr => null()
  endif
  ! in: f_override 0D_NOT_logical
  if (c_associated(override)) then
    call c_f_pointer(override, f_override_ptr)
    f_override_native = f_override_ptr
    f_override_native_ptr => f_override_native
  else
    f_override_native_ptr => null()
  endif
  call init_attribute_name1(ix_key=f_ix_key, ix_attrib=f_ix_attrib, name=f_name, &
      attrib_state=f_attrib_state_ptr, override=f_override_native_ptr)

end subroutine
subroutine fortran_init_attribute_name_array () bind(c)

  implicit none
  ! ** End of parameters **
  call init_attribute_name_array()

end subroutine
subroutine fortran_init_beam_distribution (ele, param, beam_init, beam, err_flag, modes, &
    beam_init_set, print_p0c_shift_warning, conserve_momentum) bind(c)

  use bmad_struct, only: beam_init_struct, beam_struct, ele_struct, lat_param_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: beam_init  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init
  type(c_ptr), value :: modes  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_modes
  type(c_ptr), intent(in), value :: print_p0c_shift_warning  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_p0c_shift_warning
  logical, target :: f_print_p0c_shift_warning_native
  logical, pointer :: f_print_p0c_shift_warning_native_ptr
  logical(c_bool), pointer :: f_print_p0c_shift_warning_ptr
  ! ** Out parameters **
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: beam_init_set  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init_set
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: conserve_momentum  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_conserve_momentum
  logical, target :: f_conserve_momentum_native
  logical, pointer :: f_conserve_momentum_native_ptr
  logical(c_bool), pointer :: f_conserve_momentum_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_beam_init 0D_NOT_type
  if (.not. c_associated(beam_init)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam_init, f_beam_init)
  ! out: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam, f_beam)
  ! in: f_modes 0D_NOT_type
  if (c_associated(modes))   call c_f_pointer(modes, f_modes)
  ! out: f_beam_init_set 0D_NOT_type
  if (c_associated(beam_init_set))   call c_f_pointer(beam_init_set, f_beam_init_set)
  ! in: f_print_p0c_shift_warning 0D_NOT_logical
  if (c_associated(print_p0c_shift_warning)) then
    call c_f_pointer(print_p0c_shift_warning, f_print_p0c_shift_warning_ptr)
    f_print_p0c_shift_warning_native = f_print_p0c_shift_warning_ptr
    f_print_p0c_shift_warning_native_ptr => f_print_p0c_shift_warning_native
  else
    f_print_p0c_shift_warning_native_ptr => null()
  endif
  ! inout: f_conserve_momentum 0D_NOT_logical
  if (c_associated(conserve_momentum)) then
    call c_f_pointer(conserve_momentum, f_conserve_momentum_ptr)
    f_conserve_momentum_native = f_conserve_momentum_ptr
    f_conserve_momentum_native_ptr => f_conserve_momentum_native
  else
    f_conserve_momentum_native_ptr => null()
  endif
  call init_beam_distribution(ele=f_ele, param=f_param, beam_init=f_beam_init, beam=f_beam, &
      err_flag=f_err_flag, modes=f_modes, beam_init_set=f_beam_init_set, &
      print_p0c_shift_warning=f_print_p0c_shift_warning_native_ptr, &
      conserve_momentum=f_conserve_momentum_native_ptr)

  ! out: f_beam 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_beam_init_set 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_conserve_momentum 0D_NOT_logical
  if (c_associated(conserve_momentum)) then
    call c_f_pointer(conserve_momentum, f_conserve_momentum_ptr)
    f_conserve_momentum_ptr = f_conserve_momentum_native
  else
    ! f_conserve_momentum unset
  endif
end subroutine
subroutine fortran_init_bmad () bind(c)

  implicit none
  ! ** End of parameters **
  call init_bmad()

end subroutine
subroutine fortran_init_bmad_parser_common (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (c_associated(lat))   call c_f_pointer(lat, f_lat)
  call init_bmad_parser_common(lat=f_lat)

end subroutine
subroutine fortran_init_bunch_distribution (ele, param, beam_init, ix_bunch, bunch, err_flag, &
    modes, beam_init_used, print_p0c_shift_warning, conserve_momentum) bind(c)

  use bmad_struct, only: beam_init_struct, bunch_struct, ele_struct, lat_param_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: beam_init  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init
  integer(c_int) :: ix_bunch  ! 0D_NOT_integer
  integer :: f_ix_bunch
  type(c_ptr), value :: modes  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_modes
  type(c_ptr), intent(in), value :: print_p0c_shift_warning  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_p0c_shift_warning
  logical, target :: f_print_p0c_shift_warning_native
  logical, pointer :: f_print_p0c_shift_warning_native_ptr
  logical(c_bool), pointer :: f_print_p0c_shift_warning_ptr
  ! ** Out parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: beam_init_used  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init_used
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: conserve_momentum  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_conserve_momentum
  logical, target :: f_conserve_momentum_native
  logical, pointer :: f_conserve_momentum_native_ptr
  logical(c_bool), pointer :: f_conserve_momentum_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_beam_init 0D_NOT_type
  if (.not. c_associated(beam_init)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam_init, f_beam_init)
  ! in: f_ix_bunch 0D_NOT_integer
  f_ix_bunch = ix_bunch
  ! out: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(bunch, f_bunch)
  ! in: f_modes 0D_NOT_type
  if (c_associated(modes))   call c_f_pointer(modes, f_modes)
  ! out: f_beam_init_used 0D_NOT_type
  if (c_associated(beam_init_used))   call c_f_pointer(beam_init_used, f_beam_init_used)
  ! in: f_print_p0c_shift_warning 0D_NOT_logical
  if (c_associated(print_p0c_shift_warning)) then
    call c_f_pointer(print_p0c_shift_warning, f_print_p0c_shift_warning_ptr)
    f_print_p0c_shift_warning_native = f_print_p0c_shift_warning_ptr
    f_print_p0c_shift_warning_native_ptr => f_print_p0c_shift_warning_native
  else
    f_print_p0c_shift_warning_native_ptr => null()
  endif
  ! inout: f_conserve_momentum 0D_NOT_logical
  if (c_associated(conserve_momentum)) then
    call c_f_pointer(conserve_momentum, f_conserve_momentum_ptr)
    f_conserve_momentum_native = f_conserve_momentum_ptr
    f_conserve_momentum_native_ptr => f_conserve_momentum_native
  else
    f_conserve_momentum_native_ptr => null()
  endif
  call init_bunch_distribution(ele=f_ele, param=f_param, beam_init=f_beam_init, &
      ix_bunch=f_ix_bunch, bunch=f_bunch, err_flag=f_err_flag, modes=f_modes, &
      beam_init_used=f_beam_init_used, &
      print_p0c_shift_warning=f_print_p0c_shift_warning_native_ptr, &
      conserve_momentum=f_conserve_momentum_native_ptr)

  ! out: f_bunch 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_beam_init_used 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_conserve_momentum 0D_NOT_logical
  if (c_associated(conserve_momentum)) then
    call c_f_pointer(conserve_momentum, f_conserve_momentum_ptr)
    f_conserve_momentum_ptr = f_conserve_momentum_native
  else
    ! f_conserve_momentum unset
  endif
end subroutine
subroutine fortran_init_complex_taylor_series (complex_taylor, n_term, save) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_term  ! 0D_NOT_integer
  integer :: f_n_term
  type(c_ptr), intent(in), value :: save  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save
  logical, target :: f_save_native
  logical, pointer :: f_save_native_ptr
  logical(c_bool), pointer :: f_save_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: complex_taylor  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor
  ! ** End of parameters **
  ! inout: f_complex_taylor 0D_NOT_type
  if (.not. c_associated(complex_taylor)) return
  call c_f_pointer(complex_taylor, f_complex_taylor)
  ! in: f_n_term 0D_NOT_integer
  f_n_term = n_term
  ! in: f_save 0D_NOT_logical
  if (c_associated(save)) then
    call c_f_pointer(save, f_save_ptr)
    f_save_native = f_save_ptr
    f_save_native_ptr => f_save_native
  else
    f_save_native_ptr => null()
  endif
  call init_complex_taylor_series(complex_taylor=f_complex_taylor, n_term=f_n_term, &
      save=f_save_native_ptr)

end subroutine
subroutine fortran_init_coord1 (orb, vec, ele, element_end, particle, direction, E_photon, &
    t_offset, shift_vec6, spin, s_pos, random_on) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: vec
  real(rp) :: f_vec(6)
  real(c_double), pointer :: f_vec_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: element_end  ! 0D_NOT_integer
  integer(c_int) :: f_element_end
  integer(c_int), pointer :: f_element_end_ptr
  type(c_ptr), intent(in), value :: particle  ! 0D_NOT_integer
  integer(c_int) :: f_particle
  integer(c_int), pointer :: f_particle_ptr
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  type(c_ptr), intent(in), value :: E_photon  ! 0D_NOT_real
  real(c_double) :: f_E_photon
  real(c_double), pointer :: f_E_photon_ptr
  type(c_ptr), intent(in), value :: t_offset  ! 0D_NOT_real
  real(c_double) :: f_t_offset
  real(c_double), pointer :: f_t_offset_ptr
  type(c_ptr), intent(in), value :: shift_vec6  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_shift_vec6
  logical, target :: f_shift_vec6_native
  logical, pointer :: f_shift_vec6_native_ptr
  logical(c_bool), pointer :: f_shift_vec6_ptr
  type(c_ptr), intent(in), value :: spin
  real(rp) :: f_spin(3)
  real(c_double), pointer :: f_spin_ptr(:)
  type(c_ptr), intent(in), value :: s_pos  ! 0D_NOT_real
  real(c_double) :: f_s_pos
  real(c_double), pointer :: f_s_pos_ptr
  type(c_ptr), intent(in), value :: random_on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_random_on
  logical, target :: f_random_on_native
  logical, pointer :: f_random_on_native_ptr
  logical(c_bool), pointer :: f_random_on_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  !! general array (1D_NOT_real)
  if (c_associated(vec)) then
    call c_f_pointer(vec, f_vec_ptr, [6])
    f_vec = f_vec_ptr(:)
  else
    f_vec_ptr => null()
  endif
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  ! in: f_element_end 0D_NOT_integer
  if (c_associated(element_end)) then
    call c_f_pointer(element_end, f_element_end_ptr)
  else
    f_element_end_ptr => null()
  endif
  ! in: f_particle 0D_NOT_integer
  if (c_associated(particle)) then
    call c_f_pointer(particle, f_particle_ptr)
  else
    f_particle_ptr => null()
  endif
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! in: f_E_photon 0D_NOT_real
  if (c_associated(E_photon)) then
    call c_f_pointer(E_photon, f_E_photon_ptr)
  else
    f_E_photon_ptr => null()
  endif
  ! in: f_t_offset 0D_NOT_real
  if (c_associated(t_offset)) then
    call c_f_pointer(t_offset, f_t_offset_ptr)
  else
    f_t_offset_ptr => null()
  endif
  ! in: f_shift_vec6 0D_NOT_logical
  if (c_associated(shift_vec6)) then
    call c_f_pointer(shift_vec6, f_shift_vec6_ptr)
    f_shift_vec6_native = f_shift_vec6_ptr
    f_shift_vec6_native_ptr => f_shift_vec6_native
  else
    f_shift_vec6_native_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(spin)) then
    call c_f_pointer(spin, f_spin_ptr, [3])
    f_spin = f_spin_ptr(:)
  else
    f_spin_ptr => null()
  endif
  ! in: f_s_pos 0D_NOT_real
  if (c_associated(s_pos)) then
    call c_f_pointer(s_pos, f_s_pos_ptr)
  else
    f_s_pos_ptr => null()
  endif
  ! in: f_random_on 0D_NOT_logical
  if (c_associated(random_on)) then
    call c_f_pointer(random_on, f_random_on_ptr)
    f_random_on_native = f_random_on_ptr
    f_random_on_native_ptr => f_random_on_native
  else
    f_random_on_native_ptr => null()
  endif
  call init_coord1(orb=f_orb, vec=f_vec, ele=f_ele, element_end=f_element_end_ptr, &
      particle=f_particle_ptr, direction=f_direction_ptr, E_photon=f_E_photon_ptr, &
      t_offset=f_t_offset_ptr, shift_vec6=f_shift_vec6_native_ptr, spin=f_spin, &
      s_pos=f_s_pos_ptr, random_on=f_random_on_native_ptr)

end subroutine
subroutine fortran_init_coord2 (orb_out, orb_in, ele, element_end, particle, direction, &
    E_photon, t_offset, shift_vec6, spin, s_pos, random_on) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: element_end  ! 0D_NOT_integer
  integer(c_int) :: f_element_end
  integer(c_int), pointer :: f_element_end_ptr
  type(c_ptr), intent(in), value :: particle  ! 0D_NOT_integer
  integer(c_int) :: f_particle
  integer(c_int), pointer :: f_particle_ptr
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  type(c_ptr), intent(in), value :: E_photon  ! 0D_NOT_real
  real(c_double) :: f_E_photon
  real(c_double), pointer :: f_E_photon_ptr
  type(c_ptr), intent(in), value :: t_offset  ! 0D_NOT_real
  real(c_double) :: f_t_offset
  real(c_double), pointer :: f_t_offset_ptr
  type(c_ptr), intent(in), value :: shift_vec6  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_shift_vec6
  logical, target :: f_shift_vec6_native
  logical, pointer :: f_shift_vec6_native_ptr
  logical(c_bool), pointer :: f_shift_vec6_ptr
  type(c_ptr), intent(in), value :: spin
  real(rp) :: f_spin(3)
  real(c_double), pointer :: f_spin_ptr(:)
  type(c_ptr), intent(in), value :: s_pos  ! 0D_NOT_real
  real(c_double) :: f_s_pos
  real(c_double), pointer :: f_s_pos_ptr
  type(c_ptr), intent(in), value :: random_on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_random_on
  logical, target :: f_random_on_native
  logical, pointer :: f_random_on_native_ptr
  logical(c_bool), pointer :: f_random_on_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orb_out  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_out
  ! ** Inout parameters **
  type(c_ptr), value :: orb_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_in
  ! ** End of parameters **
  ! out: f_orb_out 0D_NOT_type
  if (.not. c_associated(orb_out)) return
  call c_f_pointer(orb_out, f_orb_out)
  ! inout: f_orb_in 0D_NOT_type
  if (.not. c_associated(orb_in)) return
  call c_f_pointer(orb_in, f_orb_in)
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  ! in: f_element_end 0D_NOT_integer
  if (c_associated(element_end)) then
    call c_f_pointer(element_end, f_element_end_ptr)
  else
    f_element_end_ptr => null()
  endif
  ! in: f_particle 0D_NOT_integer
  if (c_associated(particle)) then
    call c_f_pointer(particle, f_particle_ptr)
  else
    f_particle_ptr => null()
  endif
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! in: f_E_photon 0D_NOT_real
  if (c_associated(E_photon)) then
    call c_f_pointer(E_photon, f_E_photon_ptr)
  else
    f_E_photon_ptr => null()
  endif
  ! in: f_t_offset 0D_NOT_real
  if (c_associated(t_offset)) then
    call c_f_pointer(t_offset, f_t_offset_ptr)
  else
    f_t_offset_ptr => null()
  endif
  ! in: f_shift_vec6 0D_NOT_logical
  if (c_associated(shift_vec6)) then
    call c_f_pointer(shift_vec6, f_shift_vec6_ptr)
    f_shift_vec6_native = f_shift_vec6_ptr
    f_shift_vec6_native_ptr => f_shift_vec6_native
  else
    f_shift_vec6_native_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(spin)) then
    call c_f_pointer(spin, f_spin_ptr, [3])
    f_spin = f_spin_ptr(:)
  else
    f_spin_ptr => null()
  endif
  ! in: f_s_pos 0D_NOT_real
  if (c_associated(s_pos)) then
    call c_f_pointer(s_pos, f_s_pos_ptr)
  else
    f_s_pos_ptr => null()
  endif
  ! in: f_random_on 0D_NOT_logical
  if (c_associated(random_on)) then
    call c_f_pointer(random_on, f_random_on_ptr)
    f_random_on_native = f_random_on_ptr
    f_random_on_native_ptr => f_random_on_native
  else
    f_random_on_native_ptr => null()
  endif
  call init_coord2(orb_out=f_orb_out, orb_in=f_orb_in, ele=f_ele, &
      element_end=f_element_end_ptr, particle=f_particle_ptr, direction=f_direction_ptr, &
      E_photon=f_E_photon_ptr, t_offset=f_t_offset_ptr, shift_vec6=f_shift_vec6_native_ptr, &
      spin=f_spin, s_pos=f_s_pos_ptr, random_on=f_random_on_native_ptr)

  ! out: f_orb_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_init_coord3 (orb, ele, element_end, particle, direction, E_photon, t_offset, &
    shift_vec6, spin) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: element_end  ! 0D_NOT_integer
  integer(c_int) :: f_element_end
  integer(c_int), pointer :: f_element_end_ptr
  type(c_ptr), intent(in), value :: particle  ! 0D_NOT_integer
  integer(c_int) :: f_particle
  integer(c_int), pointer :: f_particle_ptr
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  type(c_ptr), intent(in), value :: E_photon  ! 0D_NOT_real
  real(c_double) :: f_E_photon
  real(c_double), pointer :: f_E_photon_ptr
  type(c_ptr), intent(in), value :: t_offset  ! 0D_NOT_real
  real(c_double) :: f_t_offset
  real(c_double), pointer :: f_t_offset_ptr
  type(c_ptr), intent(in), value :: shift_vec6  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_shift_vec6
  logical, target :: f_shift_vec6_native
  logical, pointer :: f_shift_vec6_native_ptr
  logical(c_bool), pointer :: f_shift_vec6_ptr
  type(c_ptr), intent(in), value :: spin
  real(rp) :: f_spin(3)
  real(c_double), pointer :: f_spin_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  ! in: f_element_end 0D_NOT_integer
  if (c_associated(element_end)) then
    call c_f_pointer(element_end, f_element_end_ptr)
  else
    f_element_end_ptr => null()
  endif
  ! in: f_particle 0D_NOT_integer
  if (c_associated(particle)) then
    call c_f_pointer(particle, f_particle_ptr)
  else
    f_particle_ptr => null()
  endif
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! in: f_E_photon 0D_NOT_real
  if (c_associated(E_photon)) then
    call c_f_pointer(E_photon, f_E_photon_ptr)
  else
    f_E_photon_ptr => null()
  endif
  ! in: f_t_offset 0D_NOT_real
  if (c_associated(t_offset)) then
    call c_f_pointer(t_offset, f_t_offset_ptr)
  else
    f_t_offset_ptr => null()
  endif
  ! in: f_shift_vec6 0D_NOT_logical
  if (c_associated(shift_vec6)) then
    call c_f_pointer(shift_vec6, f_shift_vec6_ptr)
    f_shift_vec6_native = f_shift_vec6_ptr
    f_shift_vec6_native_ptr => f_shift_vec6_native
  else
    f_shift_vec6_native_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(spin)) then
    call c_f_pointer(spin, f_spin_ptr, [3])
    f_spin = f_spin_ptr(:)
  else
    f_spin_ptr => null()
  endif
  call init_coord3(orb=f_orb, ele=f_ele, element_end=f_element_end_ptr, &
      particle=f_particle_ptr, direction=f_direction_ptr, E_photon=f_E_photon_ptr, &
      t_offset=f_t_offset_ptr, shift_vec6=f_shift_vec6_native_ptr, spin=f_spin)

end subroutine
subroutine fortran_init_custom (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call init_custom(lat=f_lat)

end subroutine
subroutine fortran_init_ele (ele, key, sub_key, ix_ele, branch) bind(c)

  use bmad_struct, only: branch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: key  ! 0D_NOT_integer
  integer(c_int) :: f_key
  integer(c_int), pointer :: f_key_ptr
  type(c_ptr), intent(in), value :: sub_key  ! 0D_NOT_integer
  integer(c_int) :: f_sub_key
  integer(c_int), pointer :: f_sub_key_ptr
  type(c_ptr), intent(in), value :: ix_ele  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele
  integer(c_int), pointer :: f_ix_ele_ptr
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_key 0D_NOT_integer
  if (c_associated(key)) then
    call c_f_pointer(key, f_key_ptr)
  else
    f_key_ptr => null()
  endif
  ! in: f_sub_key 0D_NOT_integer
  if (c_associated(sub_key)) then
    call c_f_pointer(sub_key, f_sub_key_ptr)
  else
    f_sub_key_ptr => null()
  endif
  ! in: f_ix_ele 0D_NOT_integer
  if (c_associated(ix_ele)) then
    call c_f_pointer(ix_ele, f_ix_ele_ptr)
  else
    f_ix_ele_ptr => null()
  endif
  ! in: f_branch 0D_NOT_type
  if (c_associated(branch))   call c_f_pointer(branch, f_branch)
  call init_ele(ele=f_ele, key=f_key_ptr, sub_key=f_sub_key_ptr, ix_ele=f_ix_ele_ptr, &
      branch=f_branch)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_init_em_taylor_series (em_taylor, n_term, save_old) bind(c)

  use bmad_struct, only: em_taylor_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_term  ! 0D_NOT_integer
  integer :: f_n_term
  type(c_ptr), intent(in), value :: save_old  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save_old
  logical, target :: f_save_old_native
  logical, pointer :: f_save_old_native_ptr
  logical(c_bool), pointer :: f_save_old_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: em_taylor  ! 0D_NOT_type
  type(em_taylor_struct), pointer :: f_em_taylor
  ! ** End of parameters **
  ! inout: f_em_taylor 0D_NOT_type
  if (.not. c_associated(em_taylor)) return
  call c_f_pointer(em_taylor, f_em_taylor)
  ! in: f_n_term 0D_NOT_integer
  f_n_term = n_term
  ! in: f_save_old 0D_NOT_logical
  if (c_associated(save_old)) then
    call c_f_pointer(save_old, f_save_old_ptr)
    f_save_old_native = f_save_old_ptr
    f_save_old_native_ptr => f_save_old_native
  else
    f_save_old_native_ptr => null()
  endif
  call init_em_taylor_series(em_taylor=f_em_taylor, n_term=f_n_term, &
      save_old=f_save_old_native_ptr)

end subroutine
subroutine fortran_init_lat (lat, n, init_beginning_ele) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: n  ! 0D_NOT_integer
  integer(c_int) :: f_n
  integer(c_int), pointer :: f_n_ptr
  type(c_ptr), intent(in), value :: init_beginning_ele  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_init_beginning_ele
  logical, target :: f_init_beginning_ele_native
  logical, pointer :: f_init_beginning_ele_native_ptr
  logical(c_bool), pointer :: f_init_beginning_ele_ptr
  ! ** Out parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! out: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_n 0D_NOT_integer
  if (c_associated(n)) then
    call c_f_pointer(n, f_n_ptr)
  else
    f_n_ptr => null()
  endif
  ! in: f_init_beginning_ele 0D_NOT_logical
  if (c_associated(init_beginning_ele)) then
    call c_f_pointer(init_beginning_ele, f_init_beginning_ele_ptr)
    f_init_beginning_ele_native = f_init_beginning_ele_ptr
    f_init_beginning_ele_native_ptr => f_init_beginning_ele_native
  else
    f_init_beginning_ele_native_ptr => null()
  endif
  call init_lat(lat=f_lat, n=f_n_ptr, init_beginning_ele=f_init_beginning_ele_native_ptr)

  ! out: f_lat 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_init_multipole_cache (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call init_multipole_cache(ele=f_ele)

end subroutine
subroutine fortran_init_photon_from_a_photon_init_ele (ele, param, orbit, random_on) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: random_on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_random_on
  logical, target :: f_random_on_native
  logical, pointer :: f_random_on_native_ptr
  logical(c_bool), pointer :: f_random_on_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! out: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_random_on 0D_NOT_logical
  if (c_associated(random_on)) then
    call c_f_pointer(random_on, f_random_on_ptr)
    f_random_on_native = f_random_on_ptr
    f_random_on_native_ptr => f_random_on_native
  else
    f_random_on_native_ptr => null()
  endif
  call init_photon_from_a_photon_init_ele(ele=f_ele, param=f_param, orbit=f_orbit, &
      random_on=f_random_on_native_ptr)

  ! out: f_orbit 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_init_photon_integ_prob (gamma, g, E_min, E_max, vert_angle_min, &
    vert_angle_max, vert_angle_symmetric, energy_integ_prob, E_photon, integ_prob) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  real(c_double) :: g  ! 0D_NOT_real
  real(rp) :: f_g
  real(c_double) :: E_min  ! 0D_NOT_real
  real(rp) :: f_E_min
  real(c_double) :: E_max  ! 0D_NOT_real
  real(rp) :: f_E_max
  type(c_ptr), intent(in), value :: vert_angle_min  ! 0D_NOT_real
  real(c_double) :: f_vert_angle_min
  real(c_double), pointer :: f_vert_angle_min_ptr
  type(c_ptr), intent(in), value :: vert_angle_max  ! 0D_NOT_real
  real(c_double) :: f_vert_angle_max
  real(c_double), pointer :: f_vert_angle_max_ptr
  type(c_ptr), intent(in), value :: vert_angle_symmetric  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_vert_angle_symmetric
  logical, target :: f_vert_angle_symmetric_native
  logical, pointer :: f_vert_angle_symmetric_native_ptr
  logical(c_bool), pointer :: f_vert_angle_symmetric_ptr
  type(c_ptr), intent(in), value :: energy_integ_prob  ! 0D_NOT_real
  real(c_double) :: f_energy_integ_prob
  real(c_double), pointer :: f_energy_integ_prob_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: E_photon  ! 0D_NOT_real
  real(rp) :: f_E_photon
  real(c_double), pointer :: f_E_photon_ptr
  type(c_ptr), intent(in), value :: integ_prob  ! 0D_NOT_real
  real(rp) :: f_integ_prob
  real(c_double), pointer :: f_integ_prob_ptr
  ! ** End of parameters **
  ! in: f_gamma 0D_NOT_real
  f_gamma = gamma
  ! in: f_g 0D_NOT_real
  f_g = g
  ! in: f_E_min 0D_NOT_real
  f_E_min = E_min
  ! in: f_E_max 0D_NOT_real
  f_E_max = E_max
  ! in: f_vert_angle_min 0D_NOT_real
  if (c_associated(vert_angle_min)) then
    call c_f_pointer(vert_angle_min, f_vert_angle_min_ptr)
  else
    f_vert_angle_min_ptr => null()
  endif
  ! in: f_vert_angle_max 0D_NOT_real
  if (c_associated(vert_angle_max)) then
    call c_f_pointer(vert_angle_max, f_vert_angle_max_ptr)
  else
    f_vert_angle_max_ptr => null()
  endif
  ! in: f_vert_angle_symmetric 0D_NOT_logical
  if (c_associated(vert_angle_symmetric)) then
    call c_f_pointer(vert_angle_symmetric, f_vert_angle_symmetric_ptr)
    f_vert_angle_symmetric_native = f_vert_angle_symmetric_ptr
    f_vert_angle_symmetric_native_ptr => f_vert_angle_symmetric_native
  else
    f_vert_angle_symmetric_native_ptr => null()
  endif
  ! in: f_energy_integ_prob 0D_NOT_real
  if (c_associated(energy_integ_prob)) then
    call c_f_pointer(energy_integ_prob, f_energy_integ_prob_ptr)
  else
    f_energy_integ_prob_ptr => null()
  endif
  f_integ_prob = init_photon_integ_prob(gamma=f_gamma, g=f_g, E_min=f_E_min, E_max=f_E_max, &
      vert_angle_min=f_vert_angle_min_ptr, vert_angle_max=f_vert_angle_max_ptr, &
      vert_angle_symmetric=f_vert_angle_symmetric_native_ptr, &
      energy_integ_prob=f_energy_integ_prob_ptr, E_photon=f_E_photon)

  ! out: f_E_photon 0D_NOT_real
  ! no output conversion for f_E_photon
  ! out: f_integ_prob 0D_NOT_real
  call c_f_pointer(integ_prob, f_integ_prob_ptr)
  f_integ_prob_ptr = f_integ_prob
end subroutine
subroutine fortran_init_spin_distribution (beam_init, bunch, ele) bind(c)

  use bmad_struct, only: beam_init_struct, bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: beam_init  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init
  ! ** Out parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! in: f_beam_init 0D_NOT_type
  if (.not. c_associated(beam_init)) return
  call c_f_pointer(beam_init, f_beam_init)
  ! out: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call init_spin_distribution(beam_init=f_beam_init, bunch=f_bunch, ele=f_ele)

  ! out: f_bunch 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_init_surface_segment (phot, ix, iy) bind(c)

  use bmad_struct, only: photon_element_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: phot  ! 0D_NOT_type
  type(photon_element_struct), pointer :: f_phot
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ix  ! 0D_NOT_integer
  integer(c_int) :: f_ix
  integer(c_int), pointer :: f_ix_ptr
  type(c_ptr), intent(in), value :: iy  ! 0D_NOT_integer
  integer(c_int) :: f_iy
  integer(c_int), pointer :: f_iy_ptr
  ! ** End of parameters **
  ! in: f_phot 0D_NOT_type
  if (.not. c_associated(phot)) return
  call c_f_pointer(phot, f_phot)
  ! inout: f_ix 0D_NOT_integer
  if (c_associated(ix)) then
    call c_f_pointer(ix, f_ix_ptr)
  else
    f_ix_ptr => null()
  endif
  ! inout: f_iy 0D_NOT_integer
  if (c_associated(iy)) then
    call c_f_pointer(iy, f_iy_ptr)
  else
    f_iy_ptr => null()
  endif
  call init_surface_segment(phot=f_phot, ix=f_ix_ptr, iy=f_iy_ptr)

  ! inout: f_ix 0D_NOT_integer
  ! no output conversion for f_ix
  ! inout: f_iy 0D_NOT_integer
  ! no output conversion for f_iy
end subroutine
subroutine fortran_init_taylor_series (bmad_taylor, n_term, save_old) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_term  ! 0D_NOT_integer
  integer :: f_n_term
  type(c_ptr), intent(in), value :: save_old  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save_old
  logical, target :: f_save_old_native
  logical, pointer :: f_save_old_native_ptr
  logical(c_bool), pointer :: f_save_old_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bmad_taylor  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_bmad_taylor
  ! ** End of parameters **
  ! inout: f_bmad_taylor 0D_NOT_type
  if (.not. c_associated(bmad_taylor)) return
  call c_f_pointer(bmad_taylor, f_bmad_taylor)
  ! in: f_n_term 0D_NOT_integer
  f_n_term = n_term
  ! in: f_save_old 0D_NOT_logical
  if (c_associated(save_old)) then
    call c_f_pointer(save_old, f_save_old_ptr)
    f_save_old_native = f_save_old_ptr
    f_save_old_native_ptr => f_save_old_native
  else
    f_save_old_native_ptr => null()
  endif
  call init_taylor_series(bmad_taylor=f_bmad_taylor, n_term=f_n_term, &
      save_old=f_save_old_native_ptr)

end subroutine
subroutine fortran_init_wake (wake, n_sr_long, n_sr_trans, n_sr_z, n_lr_mode, always_allocate) &
    bind(c)

  use bmad_struct, only: wake_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_sr_long  ! 0D_NOT_integer
  integer :: f_n_sr_long
  integer(c_int) :: n_sr_trans  ! 0D_NOT_integer
  integer :: f_n_sr_trans
  integer(c_int) :: n_sr_z  ! 0D_NOT_integer
  integer :: f_n_sr_z
  integer(c_int) :: n_lr_mode  ! 0D_NOT_integer
  integer :: f_n_lr_mode
  type(c_ptr), intent(in), value :: always_allocate  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_always_allocate
  logical, target :: f_always_allocate_native
  logical, pointer :: f_always_allocate_native_ptr
  logical(c_bool), pointer :: f_always_allocate_ptr
  ! ** Out parameters **
  type(c_ptr), value :: wake  ! 0D_PTR_type
  type(wake_struct), pointer :: f_wake
  ! ** End of parameters **
  ! out: f_wake 0D_PTR_type
  if (.not. c_associated(wake)) return
  call c_f_pointer(wake, f_wake)
  ! in: f_n_sr_long 0D_NOT_integer
  f_n_sr_long = n_sr_long
  ! in: f_n_sr_trans 0D_NOT_integer
  f_n_sr_trans = n_sr_trans
  ! in: f_n_sr_z 0D_NOT_integer
  f_n_sr_z = n_sr_z
  ! in: f_n_lr_mode 0D_NOT_integer
  f_n_lr_mode = n_lr_mode
  ! in: f_always_allocate 0D_NOT_logical
  if (c_associated(always_allocate)) then
    call c_f_pointer(always_allocate, f_always_allocate_ptr)
    f_always_allocate_native = f_always_allocate_ptr
    f_always_allocate_native_ptr => f_always_allocate_native
  else
    f_always_allocate_native_ptr => null()
  endif
  call init_wake(wake=f_wake, n_sr_long=f_n_sr_long, n_sr_trans=f_n_sr_trans, n_sr_z=f_n_sr_z, &
      n_lr_mode=f_n_lr_mode, always_allocate=f_always_allocate_native_ptr)

  ! out: f_wake 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_insert_element (lat, insert_ele, ix_ele, ix_branch, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: insert_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_insert_ele
  integer(c_int) :: ix_ele  ! 0D_NOT_integer
  integer :: f_ix_ele
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_insert_ele 0D_NOT_type
  if (.not. c_associated(insert_ele)) return
  call c_f_pointer(insert_ele, f_insert_ele)
  ! in: f_ix_ele 0D_NOT_integer
  f_ix_ele = ix_ele
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  call insert_element(lat=f_lat, insert_ele=f_insert_ele, ix_ele=f_ix_ele, &
      ix_branch=f_ix_branch_ptr, orbit=f_orbit%data)

end subroutine
subroutine fortran_integrand_base (t, args, func_retval__) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: t  ! 0D_NOT_real
  REAL(rp) :: f_t
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: func_retval__  ! 0D_NOT_real
  REAL(rp) :: f_func_retval__
  real(c_double), pointer :: f_func_retval___ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: args
  type(real_container_alloc), pointer :: f_args
  ! ** End of parameters **
  ! in: f_t 0D_NOT_real
  f_t = t
  !! container general array (1D_ALLOC_real)
  if (c_associated(args))   call c_f_pointer(args, f_args)
  f_func_retval__ = integrand_base(t=f_t, args=f_args%data)

  ! out: f_func_retval__ 0D_NOT_real
  call c_f_pointer(func_retval__, f_func_retval___ptr)
  f_func_retval___ptr = f_func_retval__
end subroutine
subroutine fortran_integrate_psi (bound, p0, args, result) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: bound  ! 0D_NOT_real
  REAL(rp) :: f_bound
  real(c_double) :: p0  ! 0D_NOT_real
  REAL(rp) :: f_p0
  type(c_ptr), intent(in), value :: args
  REAL(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: result  ! 0D_NOT_real
  REAL(rp) :: f_result
  real(c_double), pointer :: f_result_ptr
  ! ** End of parameters **
  ! in: f_bound 0D_NOT_real
  f_bound = bound
  ! in: f_p0 0D_NOT_real
  f_p0 = p0
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  call integrate_psi(bound=f_bound, p0=f_p0, args=f_args, result=f_result)

  ! out: f_result 0D_NOT_real
  call c_f_pointer(result, f_result_ptr)
  f_result_ptr = f_result
end subroutine
subroutine fortran_integrated_mats (eles, coos, Lambda, Theta, Iota, mode) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, normal_modes_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: eles
  type(ele_struct_container_alloc), pointer :: f_eles
  type(c_ptr), intent(in), value :: coos
  type(coord_struct_container_alloc), pointer :: f_coos
  type(c_ptr), intent(in), value :: Lambda
  complex(rp) :: f_Lambda(6,6)
  complex(c_double_complex), pointer :: f_Lambda_ptr(:)
  type(c_ptr), intent(in), value :: Theta
  complex(rp) :: f_Theta(6,6)
  complex(c_double_complex), pointer :: f_Theta_ptr(:)
  type(c_ptr), intent(in), value :: Iota
  complex(rp) :: f_Iota(6,6)
  complex(c_double_complex), pointer :: f_Iota_ptr(:)
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(eles))   call c_f_pointer(eles, f_eles)
  !! container type array (1D_ALLOC_type)
  if (c_associated(coos))   call c_f_pointer(coos, f_coos)
  !! general array (2D_NOT_complex)
  if (c_associated(Lambda)) then
    call c_f_pointer(Lambda, f_Lambda_ptr, [6*6])
    call vec2mat(f_Lambda_ptr, f_Lambda)
  else
    f_Lambda_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(Theta)) then
    call c_f_pointer(Theta, f_Theta_ptr, [6*6])
    call vec2mat(f_Theta_ptr, f_Theta)
  else
    f_Theta_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(Iota)) then
    call c_f_pointer(Iota, f_Iota_ptr, [6*6])
    call vec2mat(f_Iota_ptr, f_Iota)
  else
    f_Iota_ptr => null()
  endif
  ! inout: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  call integrated_mats(eles=f_eles%data, coos=f_coos%data, Lambda=f_Lambda, Theta=f_Theta, &
      Iota=f_Iota, mode=f_mode)

end subroutine
subroutine fortran_integration_timer_ele (ele, param, start, orb_max, tol) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: start  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start
  type(c_ptr), value :: orb_max  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_max
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: tol  ! 0D_NOT_real
  real(c_double) :: f_tol
  real(c_double), pointer :: f_tol_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_start 0D_NOT_type
  if (.not. c_associated(start)) return
  call c_f_pointer(start, f_start)
  ! in: f_orb_max 0D_NOT_type
  if (.not. c_associated(orb_max)) return
  call c_f_pointer(orb_max, f_orb_max)
  ! inout: f_tol 0D_NOT_real
  if (c_associated(tol)) then
    call c_f_pointer(tol, f_tol_ptr)
  else
    f_tol_ptr => null()
  endif
  call integration_timer_ele(ele=f_ele, param=f_param, start=f_start, orb_max=f_orb_max, &
      tol=f_tol_ptr)

  ! inout: f_tol 0D_NOT_real
  ! no output conversion for f_tol
end subroutine
subroutine fortran_ion_kick (orbit, r_beam, n_beam_part, a_twiss, b_twiss, sig_ee, kick) &
    bind(c)

  use bmad_struct, only: coord_struct, twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: r_beam
  real(rp) :: f_r_beam(2)
  real(c_double), pointer :: f_r_beam_ptr(:)
  real(c_double) :: n_beam_part  ! 0D_NOT_real
  real(rp) :: f_n_beam_part
  type(c_ptr), value :: a_twiss  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_a_twiss
  type(c_ptr), value :: b_twiss  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_b_twiss
  real(c_double) :: sig_ee  ! 0D_NOT_real
  real(rp) :: f_sig_ee
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: kick
  real(rp) :: f_kick(3)
  real(c_double), pointer :: f_kick_ptr(:)
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (1D_NOT_real)
  if (c_associated(r_beam)) then
    call c_f_pointer(r_beam, f_r_beam_ptr, [2])
    f_r_beam = f_r_beam_ptr(:)
  else
    f_r_beam_ptr => null()
  endif
  ! in: f_n_beam_part 0D_NOT_real
  f_n_beam_part = n_beam_part
  ! in: f_a_twiss 0D_NOT_type
  if (.not. c_associated(a_twiss)) return
  call c_f_pointer(a_twiss, f_a_twiss)
  ! in: f_b_twiss 0D_NOT_type
  if (.not. c_associated(b_twiss)) return
  call c_f_pointer(b_twiss, f_b_twiss)
  ! in: f_sig_ee 0D_NOT_real
  f_sig_ee = sig_ee
  call ion_kick(orbit=f_orbit, r_beam=f_r_beam, n_beam_part=f_n_beam_part, a_twiss=f_a_twiss, &
      b_twiss=f_b_twiss, sig_ee=f_sig_ee, kick=f_kick)

  ! out: f_kick 1D_NOT_real
  if (c_associated(kick)) then
    call c_f_pointer(kick, f_kick_ptr, [3])
    f_kick_ptr = f_kick(:)
  endif
end subroutine
subroutine fortran_is_attribute (ix_attrib, which, is_attrib) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: ix_attrib  ! 0D_NOT_integer
  integer :: f_ix_attrib
  integer(c_int) :: which  ! 0D_NOT_integer
  integer :: f_which
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_attrib  ! 0D_NOT_logical
  logical :: f_is_attrib
  logical(c_bool), pointer :: f_is_attrib_ptr
  ! ** End of parameters **
  ! in: f_ix_attrib 0D_NOT_integer
  f_ix_attrib = ix_attrib
  ! in: f_which 0D_NOT_integer
  f_which = which
  f_is_attrib = is_attribute(ix_attrib=f_ix_attrib, which=f_which)

  ! out: f_is_attrib 0D_NOT_logical
  call c_f_pointer(is_attrib, f_is_attrib_ptr)
  f_is_attrib_ptr = f_is_attrib
end subroutine
subroutine fortran_key_name_to_key_index (key_str, abbrev_allowed, key_index) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: key_str
  character(len=4096), target :: f_key_str
  character(kind=c_char), pointer :: f_key_str_ptr(:)
  type(c_ptr), intent(in), value :: abbrev_allowed  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_abbrev_allowed
  logical, target :: f_abbrev_allowed_native
  logical, pointer :: f_abbrev_allowed_native_ptr
  logical(c_bool), pointer :: f_abbrev_allowed_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: key_index  ! 0D_NOT_integer
  integer :: f_key_index
  integer(c_int), pointer :: f_key_index_ptr
  ! ** End of parameters **
  ! in: f_key_str 0D_NOT_character
  if (.not. c_associated(key_str)) return
  call c_f_pointer(key_str, f_key_str_ptr, [huge(0)])
  call to_f_str(f_key_str_ptr, f_key_str)
  ! in: f_abbrev_allowed 0D_NOT_logical
  if (c_associated(abbrev_allowed)) then
    call c_f_pointer(abbrev_allowed, f_abbrev_allowed_ptr)
    f_abbrev_allowed_native = f_abbrev_allowed_ptr
    f_abbrev_allowed_native_ptr => f_abbrev_allowed_native
  else
    f_abbrev_allowed_native_ptr => null()
  endif
  f_key_index = key_name_to_key_index(key_str=f_key_str, &
      abbrev_allowed=f_abbrev_allowed_native_ptr)

  ! out: f_key_index 0D_NOT_integer
  call c_f_pointer(key_index, f_key_index_ptr)
  f_key_index_ptr = f_key_index
end subroutine
subroutine fortran_kick_vector_calc (ele, param, s_body, orbit, dr_ds, err, print_err) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  real(c_double) :: s_body  ! 0D_NOT_real
  real(rp) :: f_s_body
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dr_ds
  real(rp) :: f_dr_ds(11)
  real(c_double), pointer :: f_dr_ds_ptr(:)
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_s_body 0D_NOT_real
  f_s_body = s_body
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! inout: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call kick_vector_calc(ele=f_ele, param=f_param, s_body=f_s_body, orbit=f_orbit, &
      dr_ds=f_dr_ds, err=f_err, print_err=f_print_err_native_ptr)

  ! out: f_dr_ds 1D_NOT_real
  if (c_associated(dr_ds)) then
    call c_f_pointer(dr_ds, f_dr_ds_ptr, [11])
    f_dr_ds_ptr = f_dr_ds(:)
  endif
  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
  ! inout: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_ptr = f_print_err_native
  else
    ! f_print_err unset
  endif
end subroutine
subroutine fortran_kill_complex_taylor (complex_taylor) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: complex_taylor
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor))   call c_f_pointer(complex_taylor, f_complex_taylor)
  call kill_complex_taylor(complex_taylor=f_complex_taylor%data)

end subroutine
subroutine fortran_kill_ptc_layouts (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call kill_ptc_layouts(lat=f_lat)

end subroutine
subroutine fortran_kill_taylor (bmad_taylor) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: bmad_taylor
  type(taylor_struct_container_alloc), pointer :: f_bmad_taylor
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(bmad_taylor))   call c_f_pointer(bmad_taylor, f_bmad_taylor)
  call kill_taylor(bmad_taylor=f_bmad_taylor%data)

end subroutine
subroutine fortran_kind_name (this_kind, kind_str) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: this_kind  ! 0D_PTR_integer
  integer, pointer :: f_this_kind
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: kind_str
  character(len=4096), target :: f_kind_str
  character(kind=c_char), pointer :: f_kind_str_ptr(:)
  ! ** End of parameters **
  ! in: f_this_kind 0D_PTR_integer
  if (c_associated(this_kind)) then
    call c_f_pointer(this_kind, f_this_kind)
  else
    f_this_kind => null()
  endif
  f_kind_str = kind_name(this_kind=f_this_kind)

  ! out: f_kind_str 0D_NOT_character
  call c_f_pointer(kind_str, f_kind_str_ptr, [len_trim(f_kind_str) + 1]) ! output-only string
  call to_c_str(f_kind_str, f_kind_str_ptr)
end subroutine
subroutine fortran_knot_interpolate (x_knot, y_knot, x_pt, interpolation, err_flag, y_pt) &
    bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: x_knot
  type(real_container_alloc), pointer :: f_x_knot
  type(c_ptr), intent(in), value :: y_knot
  type(real_container_alloc), pointer :: f_y_knot
  real(c_double) :: x_pt  ! 0D_NOT_real
  real(rp) :: f_x_pt
  integer(c_int) :: interpolation  ! 0D_NOT_integer
  integer :: f_interpolation
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: y_pt  ! 0D_NOT_real
  real(rp) :: f_y_pt
  real(c_double), pointer :: f_y_pt_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(x_knot))   call c_f_pointer(x_knot, f_x_knot)
  !! container general array (1D_ALLOC_real)
  if (c_associated(y_knot))   call c_f_pointer(y_knot, f_y_knot)
  ! in: f_x_pt 0D_NOT_real
  f_x_pt = x_pt
  ! in: f_interpolation 0D_NOT_integer
  f_interpolation = interpolation
  f_y_pt = knot_interpolate(x_knot=f_x_knot%data, y_knot=f_y_knot%data, x_pt=f_x_pt, &
      interpolation=f_interpolation, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_y_pt 0D_NOT_real
  call c_f_pointer(y_pt, f_y_pt_ptr)
  f_y_pt_ptr = f_y_pt
end subroutine
subroutine fortran_knots_to_string (x_knot, y_knot, str) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str
  character(len=4096), target :: f_str
  character(kind=c_char), pointer :: f_str_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x_knot
  type(real_container_alloc), pointer :: f_x_knot
  type(c_ptr), intent(in), value :: y_knot
  type(real_container_alloc), pointer :: f_y_knot
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(x_knot))   call c_f_pointer(x_knot, f_x_knot)
  !! container general array (1D_ALLOC_real)
  if (c_associated(y_knot))   call c_f_pointer(y_knot, f_y_knot)
  f_str = knots_to_string(x_knot=f_x_knot%data, y_knot=f_y_knot%data)

  ! out: f_str 0D_ALLOC_character
  call c_f_pointer(str, f_str_ptr, [len_trim(f_str) + 1]) ! output-only string
  call to_c_str(f_str, f_str_ptr)
end subroutine
subroutine fortran_lafun (x, y, z, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(c_double) :: f_z
  real(c_double), pointer :: f_z_ptr
  ! ** End of parameters **
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_z 0D_NOT_real
  if (c_associated(z)) then
    call c_f_pointer(z, f_z_ptr)
  else
    f_z_ptr => null()
  endif
  f_res = lafun(x=f_x_ptr, y=f_y_ptr, z=f_z_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_z 0D_NOT_real
  ! no output conversion for f_z
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_lat_compute_ref_energy_and_time (lat, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  call lat_compute_ref_energy_and_time(lat=f_lat, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_lat_ele_locator (loc_str, lat, eles, n_loc, err, above_ubound_is_err, &
    ix_dflt_branch, order_by_index, append_eles) bind(c)

  use bmad_struct, only: ele_pointer_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: loc_str
  character(len=4096), target :: f_loc_str
  character(kind=c_char), pointer :: f_loc_str_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: above_ubound_is_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_above_ubound_is_err
  logical, target :: f_above_ubound_is_err_native
  logical, pointer :: f_above_ubound_is_err_native_ptr
  logical(c_bool), pointer :: f_above_ubound_is_err_ptr
  type(c_ptr), intent(in), value :: ix_dflt_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_dflt_branch
  integer(c_int), pointer :: f_ix_dflt_branch_ptr
  type(c_ptr), intent(in), value :: order_by_index  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_order_by_index
  logical, target :: f_order_by_index_native
  logical, pointer :: f_order_by_index_native_ptr
  logical(c_bool), pointer :: f_order_by_index_ptr
  type(c_ptr), intent(in), value :: append_eles  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_append_eles
  logical, target :: f_append_eles_native
  logical, pointer :: f_append_eles_native_ptr
  logical(c_bool), pointer :: f_append_eles_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: eles
  type(ele_pointer_struct_container_alloc), pointer :: f_eles
  type(c_ptr), intent(in), value :: n_loc  ! 0D_NOT_integer
  integer(c_int) :: f_n_loc
  integer(c_int), pointer :: f_n_loc_ptr
  ! ** End of parameters **
  ! in: f_loc_str 0D_NOT_character
  if (.not. c_associated(loc_str)) return
  call c_f_pointer(loc_str, f_loc_str_ptr, [huge(0)])
  call to_f_str(f_loc_str_ptr, f_loc_str)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(eles))   call c_f_pointer(eles, f_eles)
  ! inout: f_n_loc 0D_NOT_integer
  if (c_associated(n_loc)) then
    call c_f_pointer(n_loc, f_n_loc_ptr)
  else
    f_n_loc_ptr => null()
  endif
  ! in: f_above_ubound_is_err 0D_NOT_logical
  if (c_associated(above_ubound_is_err)) then
    call c_f_pointer(above_ubound_is_err, f_above_ubound_is_err_ptr)
    f_above_ubound_is_err_native = f_above_ubound_is_err_ptr
    f_above_ubound_is_err_native_ptr => f_above_ubound_is_err_native
  else
    f_above_ubound_is_err_native_ptr => null()
  endif
  ! in: f_ix_dflt_branch 0D_NOT_integer
  if (c_associated(ix_dflt_branch)) then
    call c_f_pointer(ix_dflt_branch, f_ix_dflt_branch_ptr)
  else
    f_ix_dflt_branch_ptr => null()
  endif
  ! in: f_order_by_index 0D_NOT_logical
  if (c_associated(order_by_index)) then
    call c_f_pointer(order_by_index, f_order_by_index_ptr)
    f_order_by_index_native = f_order_by_index_ptr
    f_order_by_index_native_ptr => f_order_by_index_native
  else
    f_order_by_index_native_ptr => null()
  endif
  ! in: f_append_eles 0D_NOT_logical
  if (c_associated(append_eles)) then
    call c_f_pointer(append_eles, f_append_eles_ptr)
    f_append_eles_native = f_append_eles_ptr
    f_append_eles_native_ptr => f_append_eles_native
  else
    f_append_eles_native_ptr => null()
  endif
  call lat_ele_locator(loc_str=f_loc_str, lat=f_lat, eles=f_eles%data, n_loc=f_n_loc_ptr, &
      err=f_err, above_ubound_is_err=f_above_ubound_is_err_native_ptr, &
      ix_dflt_branch=f_ix_dflt_branch_ptr, order_by_index=f_order_by_index_native_ptr, &
      append_eles=f_append_eles_native_ptr)

  ! inout: f_n_loc 0D_NOT_integer
  ! no output conversion for f_n_loc
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_lat_equal_lat (lat_out, lat_in) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat_in  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_in
  ! ** Out parameters **
  type(c_ptr), value :: lat_out  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_out
  ! ** End of parameters **
  ! out: f_lat_out 0D_NOT_type
  if (.not. c_associated(lat_out)) return
  call c_f_pointer(lat_out, f_lat_out)
  ! in: f_lat_in 0D_NOT_type
  if (.not. c_associated(lat_in)) return
  call c_f_pointer(lat_in, f_lat_in)
  call lat_equal_lat(lat_out=f_lat_out, lat_in=f_lat_in)

  ! out: f_lat_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_lat_geometry (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call lat_geometry(lat=f_lat)

end subroutine
subroutine fortran_lat_make_mat6 (lat, ix_ele, ref_orb, ix_branch, err_flag) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ix_ele  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele
  integer(c_int), pointer :: f_ix_ele_ptr
  type(c_ptr), intent(in), value :: ref_orb
  type(coord_struct_container_alloc), pointer :: f_ref_orb
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_ele 0D_NOT_integer
  if (c_associated(ix_ele)) then
    call c_f_pointer(ix_ele, f_ix_ele_ptr)
  else
    f_ix_ele_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(ref_orb))   call c_f_pointer(ref_orb, f_ref_orb)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call lat_make_mat6(lat=f_lat, ix_ele=f_ix_ele_ptr, ref_orb=f_ref_orb%data, &
      ix_branch=f_ix_branch_ptr, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_lat_sanity_check (lat, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  call lat_sanity_check(lat=f_lat, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_lat_to_ptc_layout (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call lat_to_ptc_layout(lat=f_lat)

end subroutine
subroutine fortran_lat_vec_equal_lat_vec (lat1, lat2) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: lat2
  type(lat_struct_container_alloc), pointer :: f_lat2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: lat1
  type(lat_struct_container_alloc), pointer :: f_lat1
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(lat1))   call c_f_pointer(lat1, f_lat1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(lat2))   call c_f_pointer(lat2, f_lat2)
  call lat_vec_equal_lat_vec(lat1=f_lat1%data, lat2=f_lat2%data)

end subroutine
subroutine fortran_lattice_bookkeeper (lat, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  call lattice_bookkeeper(lat=f_lat, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_lcavity_rf_step_setup (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call lcavity_rf_step_setup(ele=f_ele)

end subroutine
subroutine fortran_linear_bend_edge_kick (ele, param, particle_at, orb, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call linear_bend_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, orb=f_orb, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_linear_coef (stack, err_flag, coef) bind(c)

  use bmad_struct, only: expression_atom_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: stack
  type(expression_atom_struct_container_alloc), pointer :: f_stack
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: coef  ! 0D_NOT_real
  real(rp) :: f_coef
  real(c_double), pointer :: f_coef_ptr
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(stack))   call c_f_pointer(stack, f_stack)
  f_coef = linear_coef(stack=f_stack%data, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_coef 0D_NOT_real
  call c_f_pointer(coef, f_coef_ptr)
  f_coef_ptr = f_coef
end subroutine
subroutine fortran_linear_to_spin_taylor (q_map, spin_taylor) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: q_map
  real(rp) :: f_q_map(0:3,0:6)
  real(c_double), pointer :: f_q_map_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: spin_taylor
  type(taylor_struct), pointer :: f_spin_taylor(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(q_map)) then
    call c_f_pointer(q_map, f_q_map_ptr, [4*7])
    call vec2mat(f_q_map_ptr, f_q_map)
  else
    f_q_map_ptr => null()
  endif
  !! type array (1D_NOT_type)
  call c_f_pointer(spin_taylor, f_spin_taylor, [4])
  call linear_to_spin_taylor(q_map=f_q_map, spin_taylor=f_spin_taylor)

  ! out: f_spin_taylor 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_load_parse_line (action, ix_start, end_of_file, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: action
  character(len=4096), target :: f_action
  character(kind=c_char), pointer :: f_action_ptr(:)
  integer(c_int) :: ix_start  ! 0D_NOT_integer
  integer :: f_ix_start
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: end_of_file  ! 0D_NOT_logical
  logical :: f_end_of_file
  logical(c_bool), pointer :: f_end_of_file_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_action 0D_NOT_character
  if (.not. c_associated(action)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(action, f_action_ptr, [huge(0)])
  call to_f_str(f_action_ptr, f_action)
  ! in: f_ix_start 0D_NOT_integer
  f_ix_start = ix_start
  call load_parse_line(action=f_action, ix_start=f_ix_start, end_of_file=f_end_of_file, &
      err_flag=f_err_flag)

  ! out: f_end_of_file 0D_NOT_logical
  call c_f_pointer(end_of_file, f_end_of_file_ptr)
  f_end_of_file_ptr = f_end_of_file
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_lord_edge_aligned (slave, slave_edge, lord, is_aligned) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  integer(c_int) :: slave_edge  ! 0D_NOT_integer
  integer :: f_slave_edge
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_aligned  ! 0D_NOT_logical
  logical :: f_is_aligned
  logical(c_bool), pointer :: f_is_aligned_ptr
  ! ** End of parameters **
  ! in: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! in: f_slave_edge 0D_NOT_integer
  f_slave_edge = slave_edge
  ! in: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  f_is_aligned = lord_edge_aligned(slave=f_slave, slave_edge=f_slave_edge, lord=f_lord)

  ! out: f_is_aligned 0D_NOT_logical
  call c_f_pointer(is_aligned, f_is_aligned_ptr)
  f_is_aligned_ptr = f_is_aligned
end subroutine
subroutine fortran_low_energy_z_correction (orbit, ele, ds, mat6, make_matrix, dz) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: ds  ! 0D_NOT_real
  real(rp) :: f_ds
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(rp) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_ds 0D_NOT_real
  f_ds = ds
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  f_dz = low_energy_z_correction(orbit=f_orbit, ele=f_ele, ds=f_ds, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_dz 0D_NOT_real
  call c_f_pointer(dz, f_dz_ptr)
  f_dz_ptr = f_dz
end subroutine
subroutine fortran_mad_tmfoc (el, sk1, c, s, d, f) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: el  ! 0D_NOT_real
  real(rp) :: f_el
  real(c_double) :: sk1  ! 0D_NOT_real
  real(rp) :: f_sk1
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: c  ! 0D_NOT_real
  real(rp) :: f_c
  real(c_double), pointer :: f_c_ptr
  type(c_ptr), intent(in), value :: s  ! 0D_NOT_real
  real(rp) :: f_s
  real(c_double), pointer :: f_s_ptr
  type(c_ptr), intent(in), value :: d  ! 0D_NOT_real
  real(rp) :: f_d
  real(c_double), pointer :: f_d_ptr
  type(c_ptr), intent(in), value :: f  ! 0D_NOT_real
  real(rp) :: f_f
  real(c_double), pointer :: f_f_ptr
  ! ** End of parameters **
  ! in: f_el 0D_NOT_real
  f_el = el
  ! in: f_sk1 0D_NOT_real
  f_sk1 = sk1
  call mad_tmfoc(el=f_el, sk1=f_sk1, c=f_c, s=f_s, d=f_d, f=f_f)

  ! out: f_c 0D_NOT_real
  call c_f_pointer(c, f_c_ptr)
  f_c_ptr = f_c
  ! out: f_s 0D_NOT_real
  call c_f_pointer(s, f_s_ptr)
  f_s_ptr = f_s
  ! out: f_d 0D_NOT_real
  call c_f_pointer(d, f_d_ptr)
  f_d_ptr = f_d
  ! out: f_f 0D_NOT_real
  call c_f_pointer(f, f_f_ptr)
  f_f_ptr = f_f
end subroutine
subroutine fortran_mad_tmsymm (te) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: te
  real(rp) :: f_te(6,6,6)
  real(c_double), pointer :: f_te_ptr(:)
  ! ** End of parameters **
  !! general array (3D_NOT_real)
  if (c_associated(te)) then
    call c_f_pointer(te, f_te_ptr, [6*6*6])
    call vec2tensor(f_te_ptr, f_te)
  else
    f_te_ptr => null()
  endif
  call mad_tmsymm(te=f_te)

end subroutine
subroutine fortran_make_g2_mats (twiss, g2_mat, g2_inv_mat) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: twiss  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: g2_mat
  real(rp) :: f_g2_mat(2,2)
  real(c_double), pointer :: f_g2_mat_ptr(:)
  type(c_ptr), intent(in), value :: g2_inv_mat
  real(rp) :: f_g2_inv_mat(2,2)
  real(c_double), pointer :: f_g2_inv_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_twiss 0D_NOT_type
  if (.not. c_associated(twiss)) return
  call c_f_pointer(twiss, f_twiss)
  !! general array (2D_NOT_real)
  if (c_associated(g2_mat)) then
    call c_f_pointer(g2_mat, f_g2_mat_ptr, [2*2])
    call vec2mat(f_g2_mat_ptr, f_g2_mat)
  else
    f_g2_mat_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(g2_inv_mat)) then
    call c_f_pointer(g2_inv_mat, f_g2_inv_mat_ptr, [2*2])
    call vec2mat(f_g2_inv_mat_ptr, f_g2_inv_mat)
  else
    f_g2_inv_mat_ptr => null()
  endif
  call make_g2_mats(twiss=f_twiss, g2_mat=f_g2_mat, g2_inv_mat=f_g2_inv_mat)

end subroutine
subroutine fortran_make_g_mats (ele, g_mat, g_inv_mat) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: g_mat
  real(rp) :: f_g_mat(4,4)
  real(c_double), pointer :: f_g_mat_ptr(:)
  type(c_ptr), intent(in), value :: g_inv_mat
  real(rp) :: f_g_inv_mat(4,4)
  real(c_double), pointer :: f_g_inv_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call make_g_mats(ele=f_ele, g_mat=f_g_mat, g_inv_mat=f_g_inv_mat)

  ! out: f_g_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_g_mat', c_name='g_mat', type='real', kind='rp', pointer_type='NOT', array=['4', '4'], init_value=None, comment='', member=StructureMember(line=1665, definition='real(rp) g_mat(4,4)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='4,4', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='g_mat', comment='', default=None), intent='out', description='Normal mode to betaless coords', doc_data_type='float', doc_is_optional=False)
  ! out: f_g_inv_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_g_inv_mat', c_name='g_inv_mat', type='real', kind='rp', pointer_type='NOT', array=['4', '4'], init_value=None, comment='', member=StructureMember(line=1666, definition='real(rp) g_inv_mat(4,4)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='4,4', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='g_inv_mat', comment='', default=None), intent='out', description='The inverse of G_MAT', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_make_hvbp (N, B, V, H, Vbar, Hbar) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: N
  real(rp) :: f_N(6,6)
  real(c_double), pointer :: f_N_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: B
  real(rp) :: f_B(6,6)
  real(c_double), pointer :: f_B_ptr(:)
  type(c_ptr), intent(in), value :: V
  real(rp) :: f_V(6,6)
  real(c_double), pointer :: f_V_ptr(:)
  type(c_ptr), intent(in), value :: H
  real(rp) :: f_H(6,6)
  real(c_double), pointer :: f_H_ptr(:)
  type(c_ptr), intent(in), value :: Vbar
  real(rp) :: f_Vbar(6,6)
  real(c_double), pointer :: f_Vbar_ptr(:)
  type(c_ptr), intent(in), value :: Hbar
  real(rp) :: f_Hbar(6,6)
  real(c_double), pointer :: f_Hbar_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(N)) then
    call c_f_pointer(N, f_N_ptr, [6*6])
    call vec2mat(f_N_ptr, f_N)
  else
    f_N_ptr => null()
  endif
  call make_hvbp(N=f_N, B=f_B, V=f_V, H=f_H, Vbar=f_Vbar, Hbar=f_Hbar)

  ! out: f_B 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_B', c_name='B', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=201, definition='real(rp) B(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='B', comment='', default=None), intent='out', description='Block diagonal matrix of Twiss parameters', doc_data_type='float', doc_is_optional=False)
  ! out: f_V 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_V', c_name='V', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=210, definition='real(rp) V(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='V', comment='', default=None), intent='out', description='horizontal-vertical coupling information', doc_data_type='float', doc_is_optional=False)
  ! out: f_H 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_H', c_name='H', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=203, definition='real(rp) H(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='H', comment='', default=None), intent='out', description='horizontal-longitudinal and vertical-longitudinal coupling information', doc_data_type='float', doc_is_optional=False)
  ! out: f_Vbar 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_Vbar', c_name='Vbar', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=204, definition='real(rp), optional :: Vbar(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='Vbar', comment='', default=None), intent='out', description='mat_symp_conj(B).V.B', doc_data_type='float', doc_is_optional=False)
  ! out: f_Hbar 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_Hbar', c_name='Hbar', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=205, definition='real(rp), optional :: Hbar(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='Hbar', comment='', default=None), intent='out', description='mat_symp_conj(B).H.B', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_make_hybrid_lat (lat_in, lat_out, use_taylor, orb0_arr) bind(c)

  use bmad_struct, only: coord_array_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat_in  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_in
  type(c_ptr), intent(in), value :: use_taylor  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_taylor
  logical, target :: f_use_taylor_native
  logical, pointer :: f_use_taylor_native_ptr
  logical(c_bool), pointer :: f_use_taylor_ptr
  type(c_ptr), intent(in), value :: orb0_arr
  type(coord_array_struct_container_alloc), pointer :: f_orb0_arr
  ! ** Out parameters **
  type(c_ptr), value :: lat_out  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_out
  ! ** End of parameters **
  ! in: f_lat_in 0D_NOT_type
  if (.not. c_associated(lat_in)) return
  call c_f_pointer(lat_in, f_lat_in)
  ! out: f_lat_out 0D_NOT_type
  if (.not. c_associated(lat_out)) return
  call c_f_pointer(lat_out, f_lat_out)
  ! in: f_use_taylor 0D_NOT_logical
  if (c_associated(use_taylor)) then
    call c_f_pointer(use_taylor, f_use_taylor_ptr)
    f_use_taylor_native = f_use_taylor_ptr
    f_use_taylor_native_ptr => f_use_taylor_native
  else
    f_use_taylor_native_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb0_arr))   call c_f_pointer(orb0_arr, f_orb0_arr)
  call make_hybrid_lat(lat_in=f_lat_in, lat_out=f_lat_out, use_taylor=f_use_taylor_native_ptr, &
      orb0_arr=f_orb0_arr%data)

  ! out: f_lat_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_make_mat6 (ele, param, start_orb, end_orb, err_flag) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_start_orb 0D_NOT_type
  if (c_associated(start_orb))   call c_f_pointer(start_orb, f_start_orb)
  ! out: f_end_orb 0D_NOT_type
  if (c_associated(end_orb))   call c_f_pointer(end_orb, f_end_orb)
  call make_mat6(ele=f_ele, param=f_param, start_orb=f_start_orb, end_orb=f_end_orb, &
      err_flag=f_err_flag)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_make_mat6_bmad (ele, param, start_orb, end_orb, err) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  call make_mat6_bmad(ele=f_ele, param=f_param, start_orb=f_start_orb, end_orb=f_end_orb, &
      err=f_err)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_make_mat6_bmad_photon (ele, param, start_orb, end_orb, err) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  call make_mat6_bmad_photon(ele=f_ele, param=f_param, start_orb=f_start_orb, &
      end_orb=f_end_orb, err=f_err)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_make_mat6_high_energy_space_charge (ele, param) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  call make_mat6_high_energy_space_charge(ele=f_ele, param=f_param)

end subroutine
subroutine fortran_make_mat6_mad (ele, param, c0, c1) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: c0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_c0
  ! ** Out parameters **
  type(c_ptr), value :: c1  ! 0D_NOT_type
  type(coord_struct), pointer :: f_c1
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_c0 0D_NOT_type
  if (.not. c_associated(c0)) return
  call c_f_pointer(c0, f_c0)
  ! out: f_c1 0D_NOT_type
  if (.not. c_associated(c1)) return
  call c_f_pointer(c1, f_c1)
  call make_mat6_mad(ele=f_ele, param=f_param, c0=f_c0, c1=f_c1)

  ! out: f_c1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_make_mat6_symp_lie_ptc (ele, start_orb, end_orb) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  call make_mat6_symp_lie_ptc(ele=f_ele, start_orb=f_start_orb, end_orb=f_end_orb)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_make_mat6_taylor (ele, start_orb, end_orb, err_flag) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call make_mat6_taylor(ele=f_ele, start_orb=f_start_orb, end_orb=f_end_orb, &
      err_flag=f_err_flag_native_ptr)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_make_mat6_tracking (ele, param, start_orb, end_orb, err_flag, spin_only) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), intent(in), value :: spin_only  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_spin_only
  logical, target :: f_spin_only_native
  logical, pointer :: f_spin_only_native_ptr
  logical(c_bool), pointer :: f_spin_only_ptr
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(start_orb, f_start_orb)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(end_orb, f_end_orb)
  ! in: f_spin_only 0D_NOT_logical
  if (c_associated(spin_only)) then
    call c_f_pointer(spin_only, f_spin_only_ptr)
    f_spin_only_native = f_spin_only_ptr
    f_spin_only_native_ptr => f_spin_only_native
  else
    f_spin_only_native_ptr => null()
  endif
  call make_mat6_tracking(ele=f_ele, param=f_param, start_orb=f_start_orb, end_orb=f_end_orb, &
      err_flag=f_err_flag, spin_only=f_spin_only_native_ptr)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_make_n (t6, N, err_flag, abz_tunes, tunes_out, U) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: t6
  real(rp) :: f_t6(6,6)
  real(c_double), pointer :: f_t6_ptr(:)
  type(c_ptr), intent(in), value :: abz_tunes
  real(rp) :: f_abz_tunes(3)
  real(c_double), pointer :: f_abz_tunes_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: N
  real(rp) :: f_N(6,6)
  real(c_double), pointer :: f_N_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: tunes_out
  real(rp) :: f_tunes_out(3)
  real(c_double), pointer :: f_tunes_out_ptr(:)
  type(c_ptr), intent(in), value :: U
  real(rp) :: f_U(6,6)
  real(c_double), pointer :: f_U_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(t6)) then
    call c_f_pointer(t6, f_t6_ptr, [6*6])
    call vec2mat(f_t6_ptr, f_t6)
  else
    f_t6_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(abz_tunes)) then
    call c_f_pointer(abz_tunes, f_abz_tunes_ptr, [3])
    f_abz_tunes = f_abz_tunes_ptr(:)
  else
    f_abz_tunes_ptr => null()
  endif
  call make_n(t6=f_t6, N=f_N, err_flag=f_err_flag, abz_tunes=f_abz_tunes, &
      tunes_out=f_tunes_out, U=f_U)

  ! out: f_N 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_N', c_name='N', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=828, definition='real(rp) N(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='N', comment='', default=None), intent='out', description='X = N.J', doc_data_type='float', doc_is_optional=False)
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_tunes_out 1D_NOT_real
  if (c_associated(tunes_out)) then
    call c_f_pointer(tunes_out, f_tunes_out_ptr, [3])
    f_tunes_out_ptr = f_tunes_out(:)
  endif
  ! out: f_U 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_U', c_name='U', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=832, definition='real(rp), optional :: U(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='U', comment='', default=None), intent='out', description='U = Inverse(N).t6.N.  Block diagonal matrix of 2x2 rotation matrices.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_make_pbrh (M, P, Bp, R, H, abz_tunes) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: M
  real(rp) :: f_M(6,6)
  real(c_double), pointer :: f_M_ptr(:)
  type(c_ptr), intent(in), value :: abz_tunes
  real(rp) :: f_abz_tunes(3)
  real(c_double), pointer :: f_abz_tunes_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: P
  complex(rp) :: f_P(6,6)
  complex(c_double_complex), pointer :: f_P_ptr(:)
  type(c_ptr), intent(in), value :: Bp
  complex(rp) :: f_Bp(6,6)
  complex(c_double_complex), pointer :: f_Bp_ptr(:)
  type(c_ptr), intent(in), value :: R
  complex(rp) :: f_R(6,6)
  complex(c_double_complex), pointer :: f_R_ptr(:)
  type(c_ptr), intent(in), value :: H
  complex(rp) :: f_H(6,6)
  complex(c_double_complex), pointer :: f_H_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(M)) then
    call c_f_pointer(M, f_M_ptr, [6*6])
    call vec2mat(f_M_ptr, f_M)
  else
    f_M_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(abz_tunes)) then
    call c_f_pointer(abz_tunes, f_abz_tunes_ptr, [3])
    f_abz_tunes = f_abz_tunes_ptr(:)
  else
    f_abz_tunes_ptr => null()
  endif
  call make_pbrh(M=f_M, P=f_P, Bp=f_Bp, R=f_R, H=f_H, abz_tunes=f_abz_tunes)

  ! out: f_P 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_P', c_name='P', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=660, definition='complex(rp) P(6,6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='P', comment='', default=None), intent='out', description='Eqn. 97.  Phase advances.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_Bp 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_Bp', c_name='Bp', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=661, definition='complex(rp) Bp(6,6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='Bp', comment='', default=None), intent='out', description='Eqns. 89 & 101.  Beta functions.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_R 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_R', c_name='R', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=662, definition='complex(rp) R(6,6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='R', comment='', default=None), intent='out', description='Eqn. 99.  Transverse coupling.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_H 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_H', c_name='H', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=663, definition='complex(rp) H(6,6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='H', comment='', default=None), intent='out', description='Eqn. 100.  Longitudinal coupling.', doc_data_type='complex', doc_is_optional=False)
end subroutine
subroutine fortran_make_smat_from_abc (t6, mode, sigma_mat, err_flag, Nout) bind(c)

  use bmad_struct, only: normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: t6
  real(rp) :: f_t6(6,6)
  real(c_double), pointer :: f_t6_ptr(:)
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: Nout
  real(rp) :: f_Nout(6,6)
  real(c_double), pointer :: f_Nout_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(t6)) then
    call c_f_pointer(t6, f_t6_ptr, [6*6])
    call vec2mat(f_t6_ptr, f_t6)
  else
    f_t6_ptr => null()
  endif
  ! in: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(mode, f_mode)
  call make_smat_from_abc(t6=f_t6, mode=f_mode, sigma_mat=f_sigma_mat, err_flag=f_err_flag, &
      Nout=f_Nout)

  ! out: f_sigma_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_sigma_mat', c_name='sigma_mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=1070, definition='real(rp) sigma_mat(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='sigma_mat', comment='', default=None), intent='out', description='beam envelop sigma matrix', doc_data_type='float', doc_is_optional=False)
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_Nout 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_Nout', c_name='Nout', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=1072, definition='real(rp), optional :: Nout(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='Nout', comment='', default=None), intent='out', description='Contains the normalized eigenvectors that were used to make the sigma matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_make_v (M, V, abz_tunes) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: M
  real(rp) :: f_M(6,6)
  real(c_double), pointer :: f_M_ptr(:)
  type(c_ptr), intent(in), value :: V
  complex(rp) :: f_V(6,6)
  complex(c_double_complex), pointer :: f_V_ptr(:)
  type(c_ptr), intent(in), value :: abz_tunes
  real(rp) :: f_abz_tunes(3)
  real(c_double), pointer :: f_abz_tunes_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(M)) then
    call c_f_pointer(M, f_M_ptr, [6*6])
    call vec2mat(f_M_ptr, f_M)
  else
    f_M_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(V)) then
    call c_f_pointer(V, f_V_ptr, [6*6])
    call vec2mat(f_V_ptr, f_V)
  else
    f_V_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(abz_tunes)) then
    call c_f_pointer(abz_tunes, f_abz_tunes_ptr, [3])
    f_abz_tunes = f_abz_tunes_ptr(:)
  else
    f_abz_tunes_ptr => null()
  endif
  call make_v(M=f_M, V=f_V, abz_tunes=f_abz_tunes)

end subroutine
subroutine fortran_make_v_mats (ele, v_mat, v_inv_mat) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: v_mat
  real(rp) :: f_v_mat(4,4)
  real(c_double), pointer :: f_v_mat_ptr(:)
  type(c_ptr), intent(in), value :: v_inv_mat
  real(rp) :: f_v_inv_mat(4,4)
  real(c_double), pointer :: f_v_inv_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call make_v_mats(ele=f_ele, v_mat=f_v_mat, v_inv_mat=f_v_inv_mat)

  ! out: f_v_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_v_mat', c_name='v_mat', type='real', kind='rp', pointer_type='NOT', array=['4', '4'], init_value=None, comment='', member=StructureMember(line=1762, definition='real(rp), optional :: v_mat(4,4)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='4,4', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='v_mat', comment='', default=None), intent='out', description='Normal mode to X-Y coords transformation', doc_data_type='float', doc_is_optional=False)
  ! out: f_v_inv_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_v_inv_mat', c_name='v_inv_mat', type='real', kind='rp', pointer_type='NOT', array=['4', '4'], init_value=None, comment='', member=StructureMember(line=1763, definition='real(rp), optional :: v_inv_mat(4,4)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='4,4', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='v_inv_mat', comment='', default=None), intent='out', description='X-Y coords to Normal mode transformation', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_makeup_control_slave (lat, slave, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call makeup_control_slave(lat=f_lat, slave=f_slave, err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_makeup_group_lord (lat, lord, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call makeup_group_lord(lat=f_lat, lord=f_lord, err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_makeup_multipass_slave (lat, slave, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call makeup_multipass_slave(lat=f_lat, slave=f_slave, err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_makeup_super_slave (lat, slave, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call makeup_super_slave(lat=f_lat, slave=f_slave, err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_makeup_super_slave1 (slave, lord, offset, param, include_upstream_end, &
    include_downstream_end, err_flag) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  real(c_double) :: offset  ! 0D_NOT_real
  real(rp) :: f_offset
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  logical(c_bool) :: include_upstream_end  ! 0D_NOT_logical
  logical :: f_include_upstream_end
  logical(c_bool) :: include_downstream_end  ! 0D_NOT_logical
  logical :: f_include_downstream_end
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  ! ** End of parameters **
  ! inout: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(slave, f_slave)
  ! in: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lord, f_lord)
  ! in: f_offset 0D_NOT_real
  f_offset = offset
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_include_upstream_end 0D_NOT_logical
  f_include_upstream_end = include_upstream_end
  ! in: f_include_downstream_end 0D_NOT_logical
  f_include_downstream_end = include_downstream_end
  call makeup_super_slave1(slave=f_slave, lord=f_lord, offset=f_offset, param=f_param, &
      include_upstream_end=f_include_upstream_end, &
      include_downstream_end=f_include_downstream_end, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_map1_inverse (map1, inv_map1) bind(c)

  use bmad_struct, only: spin_orbit_map1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: map1  ! 0D_NOT_type
  type(spin_orbit_map1_struct), pointer :: f_map1
  ! ** Out parameters **
  type(c_ptr), value :: inv_map1  ! 0D_NOT_type
  type(spin_orbit_map1_struct), pointer :: f_inv_map1
  ! ** End of parameters **
  ! in: f_map1 0D_NOT_type
  if (.not. c_associated(map1)) return
  call c_f_pointer(map1, f_map1)
  f_inv_map1 = map1_inverse(map1=f_map1)

  ! out: f_inv_map1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_map1_make_unit (map1) bind(c)

  use bmad_struct, only: spin_orbit_map1_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: map1  ! 0D_NOT_type
  type(spin_orbit_map1_struct), pointer :: f_map1
  ! ** End of parameters **
  ! out: f_map1 0D_NOT_type
  if (.not. c_associated(map1)) return
  call c_f_pointer(map1, f_map1)
  call map1_make_unit(map1=f_map1)

  ! out: f_map1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_map1_times_map1 (map2, map1, map_out) bind(c)

  use bmad_struct, only: spin_orbit_map1_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: map2  ! 0D_NOT_type
  type(spin_orbit_map1_struct), pointer :: f_map2
  type(c_ptr), value :: map1  ! 0D_NOT_type
  type(spin_orbit_map1_struct), pointer :: f_map1
  ! ** Out parameters **
  type(c_ptr), value :: map_out  ! 0D_NOT_type
  type(spin_orbit_map1_struct), pointer :: f_map_out
  ! ** End of parameters **
  ! in: f_map2 0D_NOT_type
  if (.not. c_associated(map2)) return
  call c_f_pointer(map2, f_map2)
  ! in: f_map1 0D_NOT_type
  if (.not. c_associated(map1)) return
  call c_f_pointer(map1, f_map1)
  f_map_out = map1_times_map1(map2=f_map2, map1=f_map1)

  ! out: f_map_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_map_to_angle_coords (t_canon, t_angle) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: t_canon
  type(taylor_struct), pointer :: f_t_canon(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: t_angle
  type(taylor_struct), pointer :: f_t_angle(:)
  ! ** End of parameters **
  !! type array (1D_NOT_type)
  call c_f_pointer(t_canon, f_t_canon, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(t_angle, f_t_angle, [6])
  call map_to_angle_coords(t_canon=f_t_canon, t_angle=f_t_angle)

  ! out: f_t_angle 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_mark_patch_regions (branch) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** End of parameters **
  ! inout: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call mark_patch_regions(branch=f_branch)

end subroutine
subroutine fortran_master_parameter_value (master_parameter, ele, value) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: master_parameter  ! 0D_NOT_integer
  integer :: f_master_parameter
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(rp) :: f_value
  real(c_double), pointer :: f_value_ptr
  ! ** End of parameters **
  ! in: f_master_parameter 0D_NOT_integer
  f_master_parameter = master_parameter
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_value = master_parameter_value(master_parameter=f_master_parameter, ele=f_ele)

  ! out: f_value 0D_NOT_real
  call c_f_pointer(value, f_value_ptr)
  f_value_ptr = f_value
end subroutine
subroutine fortran_mat4_multipole (knl, tilt, n, orbit, kick_mat) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: knl  ! 0D_NOT_real
  real(rp) :: f_knl
  real(c_double) :: tilt  ! 0D_NOT_real
  real(rp) :: f_tilt
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: kick_mat
  real(rp) :: f_kick_mat(4,4)
  real(c_double), pointer :: f_kick_mat_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: n  ! 0D_NOT_integer
  integer(c_int) :: f_n
  integer(c_int), pointer :: f_n_ptr
  ! ** End of parameters **
  ! in: f_knl 0D_NOT_real
  f_knl = knl
  ! in: f_tilt 0D_NOT_real
  f_tilt = tilt
  ! inout: f_n 0D_NOT_integer
  if (c_associated(n)) then
    call c_f_pointer(n, f_n_ptr)
  else
    f_n_ptr => null()
  endif
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call mat4_multipole(knl=f_knl, tilt=f_tilt, n=f_n_ptr, orbit=f_orbit, kick_mat=f_kick_mat)

  ! inout: f_n 0D_NOT_integer
  ! no output conversion for f_n
  ! out: f_kick_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_kick_mat', c_name='kick_mat', type='real', kind='rp', pointer_type='NOT', array=['4', '4'], init_value=None, comment='', member=StructureMember(line=1811, definition='real(rp) kick_mat(4,4)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='4,4', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='kick_mat', comment='', default=None), intent='out', description='Kick matrix (Jacobian) at orbit.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_mat6_add_offsets (ele, param) bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  call mat6_add_offsets(ele=f_ele, param=f_param)

end subroutine
subroutine fortran_mat6_add_pitch (x_pitch_tot, y_pitch_tot, orientation, mat6) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: x_pitch_tot  ! 0D_NOT_real
  real(rp) :: f_x_pitch_tot
  real(c_double) :: y_pitch_tot  ! 0D_NOT_real
  real(rp) :: f_y_pitch_tot
  integer(c_int) :: orientation  ! 0D_NOT_integer
  integer :: f_orientation
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_x_pitch_tot 0D_NOT_real
  f_x_pitch_tot = x_pitch_tot
  ! in: f_y_pitch_tot 0D_NOT_real
  f_y_pitch_tot = y_pitch_tot
  ! in: f_orientation 0D_NOT_integer
  f_orientation = orientation
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  call mat6_add_pitch(x_pitch_tot=f_x_pitch_tot, y_pitch_tot=f_y_pitch_tot, &
      orientation=f_orientation, mat6=f_mat6)

end subroutine
subroutine fortran_mat6_to_complex_taylor (vec0, mat6, complex_taylor) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: vec0
  complex(rp) :: f_vec0(6)
  complex(c_double_complex), pointer :: f_vec0_ptr(:)
  type(c_ptr), intent(in), value :: mat6
  complex(rp) :: f_mat6(6,6)
  complex(c_double_complex), pointer :: f_mat6_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: complex_taylor
  type(complex_taylor_struct), pointer :: f_complex_taylor(:)
  ! ** End of parameters **
  !! general array (1D_NOT_complex)
  if (c_associated(vec0)) then
    call c_f_pointer(vec0, f_vec0_ptr, [6])
    f_vec0 = f_vec0_ptr(:)
  else
    f_vec0_ptr => null()
  endif
  !! general array (2D_NOT_complex)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  !! type array (1D_NOT_type)
  call c_f_pointer(complex_taylor, f_complex_taylor, [6])
  call mat6_to_complex_taylor(vec0=f_vec0, mat6=f_mat6, complex_taylor=f_complex_taylor)

  ! out: f_complex_taylor 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_mat_symp_decouple (t0, stat, U, V, Ubar, Vbar, G, twiss1, twiss2, gamma, &
    type_out) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: t0
  real(rp) :: f_t0(4,4)
  real(c_double), pointer :: f_t0_ptr(:)
  logical(c_bool) :: type_out  ! 0D_NOT_logical
  logical :: f_type_out
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: stat  ! 0D_NOT_integer
  integer :: f_stat
  integer(c_int), pointer :: f_stat_ptr
  type(c_ptr), value :: twiss1  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss1
  type(c_ptr), value :: twiss2  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss2
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(rp) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: U
  real(rp) :: f_U(4,4)
  real(c_double), pointer :: f_U_ptr(:)
  type(c_ptr), intent(in), value :: V
  real(rp) :: f_V(4,4)
  real(c_double), pointer :: f_V_ptr(:)
  type(c_ptr), intent(in), value :: Ubar
  real(rp) :: f_Ubar(4,4)
  real(c_double), pointer :: f_Ubar_ptr(:)
  type(c_ptr), intent(in), value :: Vbar
  real(rp) :: f_Vbar(4,4)
  real(c_double), pointer :: f_Vbar_ptr(:)
  type(c_ptr), intent(in), value :: G
  real(rp) :: f_G(4,4)
  real(c_double), pointer :: f_G_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(t0)) then
    call c_f_pointer(t0, f_t0_ptr, [4*4])
    call vec2mat(f_t0_ptr, f_t0)
  else
    f_t0_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(U)) then
    call c_f_pointer(U, f_U_ptr, [4*4])
    call vec2mat(f_U_ptr, f_U)
  else
    f_U_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(V)) then
    call c_f_pointer(V, f_V_ptr, [4*4])
    call vec2mat(f_V_ptr, f_V)
  else
    f_V_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(Ubar)) then
    call c_f_pointer(Ubar, f_Ubar_ptr, [4*4])
    call vec2mat(f_Ubar_ptr, f_Ubar)
  else
    f_Ubar_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(Vbar)) then
    call c_f_pointer(Vbar, f_Vbar_ptr, [4*4])
    call vec2mat(f_Vbar_ptr, f_Vbar)
  else
    f_Vbar_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(G)) then
    call c_f_pointer(G, f_G_ptr, [4*4])
    call vec2mat(f_G_ptr, f_G)
  else
    f_G_ptr => null()
  endif
  ! out: f_twiss1 0D_NOT_type
  if (.not. c_associated(twiss1)) return
  call c_f_pointer(twiss1, f_twiss1)
  ! out: f_twiss2 0D_NOT_type
  if (.not. c_associated(twiss2)) return
  call c_f_pointer(twiss2, f_twiss2)
  ! in: f_type_out 0D_NOT_logical
  f_type_out = type_out
  call mat_symp_decouple(t0=f_t0, stat=f_stat, U=f_U, V=f_V, Ubar=f_Ubar, Vbar=f_Vbar, G=f_G, &
      twiss1=f_twiss1, twiss2=f_twiss2, gamma=f_gamma, type_out=f_type_out)

  ! out: f_stat 0D_NOT_integer
  call c_f_pointer(stat, f_stat_ptr)
  f_stat_ptr = f_stat
  ! out: f_twiss1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_twiss2 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_gamma 0D_NOT_real
  call c_f_pointer(gamma, f_gamma_ptr)
  f_gamma_ptr = f_gamma
end subroutine
subroutine fortran_match_ele_to_mat6 (ele, start_orb, mat6, vec0, err_flag, include_delta_time, &
    set_trombone) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), intent(in), value :: include_delta_time  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_delta_time
  logical, target :: f_include_delta_time_native
  logical, pointer :: f_include_delta_time_native_ptr
  logical(c_bool), pointer :: f_include_delta_time_ptr
  type(c_ptr), intent(in), value :: set_trombone  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_trombone
  logical, target :: f_set_trombone_native
  logical, pointer :: f_set_trombone_native_ptr
  logical(c_bool), pointer :: f_set_trombone_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  type(c_ptr), intent(in), value :: vec0
  real(rp) :: f_vec0(6)
  real(c_double), pointer :: f_vec0_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(start_orb, f_start_orb)
  ! in: f_include_delta_time 0D_NOT_logical
  if (c_associated(include_delta_time)) then
    call c_f_pointer(include_delta_time, f_include_delta_time_ptr)
    f_include_delta_time_native = f_include_delta_time_ptr
    f_include_delta_time_native_ptr => f_include_delta_time_native
  else
    f_include_delta_time_native_ptr => null()
  endif
  ! in: f_set_trombone 0D_NOT_logical
  if (c_associated(set_trombone)) then
    call c_f_pointer(set_trombone, f_set_trombone_ptr)
    f_set_trombone_native = f_set_trombone_ptr
    f_set_trombone_native_ptr => f_set_trombone_native
  else
    f_set_trombone_native_ptr => null()
  endif
  call match_ele_to_mat6(ele=f_ele, start_orb=f_start_orb, mat6=f_mat6, vec0=f_vec0, &
      err_flag=f_err_flag, include_delta_time=f_include_delta_time_native_ptr, &
      set_trombone=f_set_trombone_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=1819, definition='real(rp) mat6(6,6), vec0(6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix (1st order part of xfer map).', doc_data_type='float', doc_is_optional=False)
  ! out: f_vec0 1D_NOT_real
  if (c_associated(vec0)) then
    call c_f_pointer(vec0, f_vec0_ptr, [6])
    f_vec0_ptr = f_vec0(:)
  endif
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_mexp (x, m, this_exp) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: x  ! 0D_NOT_real
  real(rp) :: f_x
  integer(c_int) :: m  ! 0D_NOT_integer
  integer :: f_m
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: this_exp  ! 0D_NOT_real
  real(rp) :: f_this_exp
  real(c_double), pointer :: f_this_exp_ptr
  ! ** End of parameters **
  ! in: f_x 0D_NOT_real
  f_x = x
  ! in: f_m 0D_NOT_integer
  f_m = m
  f_this_exp = mexp(x=f_x, m=f_m)

  ! out: f_this_exp 0D_NOT_real
  call c_f_pointer(this_exp, f_this_exp_ptr)
  f_this_exp_ptr = f_this_exp
end subroutine
subroutine fortran_mfft1 (a, b, n, ndim, isn, ierr) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: n
  type(integer_container_alloc), pointer :: f_n
  integer(c_int) :: ndim  ! 0D_NOT_integer
  INTEGER :: f_ndim
  integer(c_int) :: isn  ! 0D_NOT_integer
  INTEGER :: f_isn
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ierr  ! 0D_NOT_integer
  INTEGER :: f_ierr
  integer(c_int), pointer :: f_ierr_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: a
  type(real_container_alloc), pointer :: f_a
  type(c_ptr), intent(in), value :: b
  type(real_container_alloc), pointer :: f_b
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(a))   call c_f_pointer(a, f_a)
  !! container general array (1D_ALLOC_real)
  if (c_associated(b))   call c_f_pointer(b, f_b)
  !! container general array (1D_ALLOC_integer)
  if (c_associated(n))   call c_f_pointer(n, f_n)
  ! in: f_ndim 0D_NOT_integer
  f_ndim = ndim
  ! in: f_isn 0D_NOT_integer
  f_isn = isn
  call mfft1(a=f_a%data, b=f_b%data, n=f_n%data, ndim=f_ndim, isn=f_isn, ierr=f_ierr)

  ! out: f_ierr 0D_NOT_integer
  call c_f_pointer(ierr, f_ierr_ptr)
  f_ierr_ptr = f_ierr
end subroutine
subroutine fortran_momentum_compaction (branch, mom_comp) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mom_comp  ! 0D_NOT_real
  real(rp) :: f_mom_comp
  real(c_double), pointer :: f_mom_comp_ptr
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  f_mom_comp = momentum_compaction(branch=f_branch)

  ! out: f_mom_comp 0D_NOT_real
  call c_f_pointer(mom_comp, f_mom_comp_ptr)
  f_mom_comp_ptr = f_mom_comp
end subroutine
subroutine fortran_multi_turn_tracking_analysis (track, i_dim, track0, ele, stable, &
    growth_rate, chi, err_flag) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: track
  type(coord_struct_container_alloc), pointer :: f_track
  integer(c_int) :: i_dim  ! 0D_NOT_integer
  integer :: f_i_dim
  ! ** Out parameters **
  type(c_ptr), value :: track0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_track0
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: stable  ! 0D_NOT_logical
  logical :: f_stable
  logical(c_bool), pointer :: f_stable_ptr
  type(c_ptr), intent(in), value :: growth_rate  ! 0D_NOT_real
  real(rp) :: f_growth_rate
  real(c_double), pointer :: f_growth_rate_ptr
  type(c_ptr), intent(in), value :: chi  ! 0D_NOT_real
  real(rp) :: f_chi
  real(c_double), pointer :: f_chi_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(track))   call c_f_pointer(track, f_track)
  ! in: f_i_dim 0D_NOT_integer
  f_i_dim = i_dim
  ! out: f_track0 0D_NOT_type
  if (.not. c_associated(track0)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(track0, f_track0)
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  call multi_turn_tracking_analysis(track=f_track%data, i_dim=f_i_dim, track0=f_track0, &
      ele=f_ele, stable=f_stable, growth_rate=f_growth_rate, chi=f_chi, err_flag=f_err_flag)

  ! out: f_track0 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_stable 0D_NOT_logical
  call c_f_pointer(stable, f_stable_ptr)
  f_stable_ptr = f_stable
  ! out: f_growth_rate 0D_NOT_real
  call c_f_pointer(growth_rate, f_growth_rate_ptr)
  f_growth_rate_ptr = f_growth_rate
  ! out: f_chi 0D_NOT_real
  call c_f_pointer(chi, f_chi_ptr)
  f_chi_ptr = f_chi
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_multilayer_type_to_multilayer_params (ele, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  call multilayer_type_to_multilayer_params(ele=f_ele, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_multipass_chain (ele, ix_pass, n_links, chain_ele, use_super_lord) bind(c)

  use bmad_struct, only: ele_pointer_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: ix_pass  ! 0D_NOT_integer
  integer :: f_ix_pass
  integer(c_int) :: n_links  ! 0D_NOT_integer
  integer :: f_n_links
  type(c_ptr), intent(in), value :: chain_ele
  type(ele_pointer_struct_container_alloc), pointer :: f_chain_ele
  type(c_ptr), intent(in), value :: use_super_lord  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_super_lord
  logical, target :: f_use_super_lord_native
  logical, pointer :: f_use_super_lord_native_ptr
  logical(c_bool), pointer :: f_use_super_lord_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_ix_pass 0D_NOT_integer
  f_ix_pass = ix_pass
  ! in: f_n_links 0D_NOT_integer
  f_n_links = n_links
  !! container type array (1D_ALLOC_type)
  if (c_associated(chain_ele))   call c_f_pointer(chain_ele, f_chain_ele)
  ! in: f_use_super_lord 0D_NOT_logical
  if (c_associated(use_super_lord)) then
    call c_f_pointer(use_super_lord, f_use_super_lord_ptr)
    f_use_super_lord_native = f_use_super_lord_ptr
    f_use_super_lord_native_ptr => f_use_super_lord_native
  else
    f_use_super_lord_native_ptr => null()
  endif
  call multipass_chain(ele=f_ele, ix_pass=f_ix_pass, n_links=f_n_links, &
      chain_ele=f_chain_ele%data, use_super_lord=f_use_super_lord_native_ptr)

end subroutine
subroutine fortran_multipole1_ab_to_kt (an, bn, n, knl, tn) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: an  ! 0D_NOT_real
  real(rp) :: f_an
  real(c_double) :: bn  ! 0D_NOT_real
  real(rp) :: f_bn
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: knl  ! 0D_NOT_real
  real(rp) :: f_knl
  real(c_double), pointer :: f_knl_ptr
  type(c_ptr), intent(in), value :: tn  ! 0D_NOT_real
  real(rp) :: f_tn
  real(c_double), pointer :: f_tn_ptr
  ! ** End of parameters **
  ! in: f_an 0D_NOT_real
  f_an = an
  ! in: f_bn 0D_NOT_real
  f_bn = bn
  ! in: f_n 0D_NOT_integer
  f_n = n
  call multipole1_ab_to_kt(an=f_an, bn=f_bn, n=f_n, knl=f_knl, tn=f_tn)

  ! out: f_knl 0D_NOT_real
  call c_f_pointer(knl, f_knl_ptr)
  f_knl_ptr = f_knl
  ! out: f_tn 0D_NOT_real
  call c_f_pointer(tn, f_tn_ptr)
  f_tn_ptr = f_tn
end subroutine
subroutine fortran_multipole1_kt_to_ab (knl, knsl, tn, n, an, bn) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: knl  ! 0D_NOT_real
  real(rp) :: f_knl
  real(c_double) :: knsl  ! 0D_NOT_real
  real(rp) :: f_knsl
  real(c_double) :: tn  ! 0D_NOT_real
  real(rp) :: f_tn
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: an  ! 0D_NOT_real
  real(rp) :: f_an
  real(c_double), pointer :: f_an_ptr
  type(c_ptr), intent(in), value :: bn  ! 0D_NOT_real
  real(rp) :: f_bn
  real(c_double), pointer :: f_bn_ptr
  ! ** End of parameters **
  ! in: f_knl 0D_NOT_real
  f_knl = knl
  ! in: f_knsl 0D_NOT_real
  f_knsl = knsl
  ! in: f_tn 0D_NOT_real
  f_tn = tn
  ! in: f_n 0D_NOT_integer
  f_n = n
  call multipole1_kt_to_ab(knl=f_knl, knsl=f_knsl, tn=f_tn, n=f_n, an=f_an, bn=f_bn)

  ! out: f_an 0D_NOT_real
  call c_f_pointer(an, f_an_ptr)
  f_an_ptr = f_an
  ! out: f_bn 0D_NOT_real
  call c_f_pointer(bn, f_bn_ptr)
  f_bn_ptr = f_bn
end subroutine
subroutine fortran_multipole_ab_to_kt (an, bn, knl, tn) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: an
  type(real_container_alloc), pointer :: f_an
  type(c_ptr), intent(in), value :: bn
  type(real_container_alloc), pointer :: f_bn
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: knl
  type(real_container_alloc), pointer :: f_knl
  type(c_ptr), intent(in), value :: tn
  type(real_container_alloc), pointer :: f_tn
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(an))   call c_f_pointer(an, f_an)
  !! container general array (1D_ALLOC_real)
  if (c_associated(bn))   call c_f_pointer(bn, f_bn)
  !! container general array (1D_ALLOC_real)
  if (c_associated(knl))   call c_f_pointer(knl, f_knl)
  !! container general array (1D_ALLOC_real)
  if (c_associated(tn))   call c_f_pointer(tn, f_tn)
  call multipole_ab_to_kt(an=f_an%data, bn=f_bn%data, knl=f_knl%data, tn=f_tn%data)

end subroutine
subroutine fortran_multipole_ele_to_ab (ele, use_ele_tilt, ix_pole_max, a, b, pole_type, &
    include_kicks, b1, original) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: use_ele_tilt  ! 0D_NOT_logical
  logical :: f_use_ele_tilt
  type(c_ptr), intent(in), value :: pole_type  ! 0D_NOT_integer
  integer(c_int) :: f_pole_type
  integer(c_int), pointer :: f_pole_type_ptr
  type(c_ptr), intent(in), value :: include_kicks  ! 0D_NOT_integer
  integer(c_int) :: f_include_kicks
  integer(c_int), pointer :: f_include_kicks_ptr
  type(c_ptr), intent(in), value :: original  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_original
  logical, target :: f_original_native
  logical, pointer :: f_original_native_ptr
  logical(c_bool), pointer :: f_original_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_pole_max  ! 0D_NOT_integer
  integer :: f_ix_pole_max
  integer(c_int), pointer :: f_ix_pole_max_ptr
  type(c_ptr), intent(in), value :: a
  real(rp) :: f_a(0:n_pole_maxx)
  real(c_double), pointer :: f_a_ptr(:)
  type(c_ptr), intent(in), value :: b
  real(rp) :: f_b(0:n_pole_maxx)
  real(c_double), pointer :: f_b_ptr(:)
  type(c_ptr), intent(in), value :: b1  ! 0D_NOT_real
  real(rp) :: f_b1
  real(c_double), pointer :: f_b1_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_use_ele_tilt 0D_NOT_logical
  f_use_ele_tilt = use_ele_tilt
  ! in: f_pole_type 0D_NOT_integer
  if (c_associated(pole_type)) then
    call c_f_pointer(pole_type, f_pole_type_ptr)
  else
    f_pole_type_ptr => null()
  endif
  ! in: f_include_kicks 0D_NOT_integer
  if (c_associated(include_kicks)) then
    call c_f_pointer(include_kicks, f_include_kicks_ptr)
  else
    f_include_kicks_ptr => null()
  endif
  ! in: f_original 0D_NOT_logical
  if (c_associated(original)) then
    call c_f_pointer(original, f_original_ptr)
    f_original_native = f_original_ptr
    f_original_native_ptr => f_original_native
  else
    f_original_native_ptr => null()
  endif
  call multipole_ele_to_ab(ele=f_ele, use_ele_tilt=f_use_ele_tilt, ix_pole_max=f_ix_pole_max, &
      a=f_a, b=f_b, pole_type=f_pole_type_ptr, include_kicks=f_include_kicks_ptr, b1=f_b1, &
      original=f_original_native_ptr)

  ! out: f_ix_pole_max 0D_NOT_integer
  call c_f_pointer(ix_pole_max, f_ix_pole_max_ptr)
  f_ix_pole_max_ptr = f_ix_pole_max
  ! out: f_a 1D_NOT_real
  if (c_associated(a)) then
    call c_f_pointer(a, f_a_ptr, [n_pole_maxx])
    f_a_ptr = f_a(:)
  endif
  ! out: f_b 1D_NOT_real
  if (c_associated(b)) then
    call c_f_pointer(b, f_b_ptr, [n_pole_maxx])
    f_b_ptr = f_b(:)
  endif
  ! out: f_b1 0D_NOT_real
  ! no output conversion for f_b1
end subroutine
subroutine fortran_multipole_ele_to_kt (ele, use_ele_tilt, ix_pole_max, knl, tilt, pole_type, &
    include_kicks) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: use_ele_tilt  ! 0D_NOT_logical
  logical :: f_use_ele_tilt
  type(c_ptr), intent(in), value :: pole_type  ! 0D_NOT_integer
  integer(c_int) :: f_pole_type
  integer(c_int), pointer :: f_pole_type_ptr
  type(c_ptr), intent(in), value :: include_kicks  ! 0D_NOT_integer
  integer(c_int) :: f_include_kicks
  integer(c_int), pointer :: f_include_kicks_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_pole_max  ! 0D_NOT_integer
  integer :: f_ix_pole_max
  integer(c_int), pointer :: f_ix_pole_max_ptr
  type(c_ptr), intent(in), value :: knl
  type(real_container_alloc), pointer :: f_knl
  type(c_ptr), intent(in), value :: tilt
  type(real_container_alloc), pointer :: f_tilt
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_use_ele_tilt 0D_NOT_logical
  f_use_ele_tilt = use_ele_tilt
  !! container general array (1D_ALLOC_real)
  if (c_associated(knl))   call c_f_pointer(knl, f_knl)
  !! container general array (1D_ALLOC_real)
  if (c_associated(tilt))   call c_f_pointer(tilt, f_tilt)
  ! in: f_pole_type 0D_NOT_integer
  if (c_associated(pole_type)) then
    call c_f_pointer(pole_type, f_pole_type_ptr)
  else
    f_pole_type_ptr => null()
  endif
  ! in: f_include_kicks 0D_NOT_integer
  if (c_associated(include_kicks)) then
    call c_f_pointer(include_kicks, f_include_kicks_ptr)
  else
    f_include_kicks_ptr => null()
  endif
  call multipole_ele_to_kt(ele=f_ele, use_ele_tilt=f_use_ele_tilt, ix_pole_max=f_ix_pole_max, &
      knl=f_knl%data, tilt=f_tilt%data, pole_type=f_pole_type_ptr, &
      include_kicks=f_include_kicks_ptr)

  ! out: f_ix_pole_max 0D_NOT_integer
  call c_f_pointer(ix_pole_max, f_ix_pole_max_ptr)
  f_ix_pole_max_ptr = f_ix_pole_max
end subroutine
subroutine fortran_multipole_init (ele, who, zero) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: who  ! 0D_NOT_integer
  integer :: f_who
  type(c_ptr), intent(in), value :: zero  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_zero
  logical, target :: f_zero_native
  logical, pointer :: f_zero_native_ptr
  logical(c_bool), pointer :: f_zero_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_who 0D_NOT_integer
  f_who = who
  ! in: f_zero 0D_NOT_logical
  if (c_associated(zero)) then
    call c_f_pointer(zero, f_zero_ptr)
    f_zero_native = f_zero_ptr
    f_zero_native_ptr => f_zero_native
  else
    f_zero_native_ptr => null()
  endif
  call multipole_init(ele=f_ele, who=f_who, zero=f_zero_native_ptr)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_multipole_kick (knl, tilt, n, ref_species, ele_orientation, coord, &
    pole_type, ref_orb_offset) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: knl  ! 0D_NOT_real
  real(rp) :: f_knl
  real(c_double) :: tilt  ! 0D_NOT_real
  real(rp) :: f_tilt
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  integer(c_int) :: ref_species  ! 0D_NOT_integer
  integer :: f_ref_species
  integer(c_int) :: ele_orientation  ! 0D_NOT_integer
  integer :: f_ele_orientation
  type(c_ptr), intent(in), value :: pole_type  ! 0D_NOT_integer
  integer(c_int) :: f_pole_type
  integer(c_int), pointer :: f_pole_type_ptr
  type(c_ptr), intent(in), value :: ref_orb_offset  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_ref_orb_offset
  logical, target :: f_ref_orb_offset_native
  logical, pointer :: f_ref_orb_offset_native_ptr
  logical(c_bool), pointer :: f_ref_orb_offset_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: coord  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord
  ! ** End of parameters **
  ! in: f_knl 0D_NOT_real
  f_knl = knl
  ! in: f_tilt 0D_NOT_real
  f_tilt = tilt
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_ref_species 0D_NOT_integer
  f_ref_species = ref_species
  ! in: f_ele_orientation 0D_NOT_integer
  f_ele_orientation = ele_orientation
  ! inout: f_coord 0D_NOT_type
  if (.not. c_associated(coord)) return
  call c_f_pointer(coord, f_coord)
  ! in: f_pole_type 0D_NOT_integer
  if (c_associated(pole_type)) then
    call c_f_pointer(pole_type, f_pole_type_ptr)
  else
    f_pole_type_ptr => null()
  endif
  ! in: f_ref_orb_offset 0D_NOT_logical
  if (c_associated(ref_orb_offset)) then
    call c_f_pointer(ref_orb_offset, f_ref_orb_offset_ptr)
    f_ref_orb_offset_native = f_ref_orb_offset_ptr
    f_ref_orb_offset_native_ptr => f_ref_orb_offset_native
  else
    f_ref_orb_offset_native_ptr => null()
  endif
  call multipole_kick(knl=f_knl, tilt=f_tilt, n=f_n, ref_species=f_ref_species, &
      ele_orientation=f_ele_orientation, coord=f_coord, pole_type=f_pole_type_ptr, &
      ref_orb_offset=f_ref_orb_offset_native_ptr)

end subroutine
subroutine fortran_multipole_kick_mat (knl, tilt, ref_species, ele, orbit, factor, mat6) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: knl
  type(real_container_alloc), pointer :: f_knl
  type(c_ptr), intent(in), value :: tilt
  type(real_container_alloc), pointer :: f_tilt
  integer(c_int) :: ref_species  ! 0D_NOT_integer
  integer :: f_ref_species
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  real(c_double) :: factor  ! 0D_NOT_real
  real(rp) :: f_factor
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(knl))   call c_f_pointer(knl, f_knl)
  !! container general array (1D_ALLOC_real)
  if (c_associated(tilt))   call c_f_pointer(tilt, f_tilt)
  ! in: f_ref_species 0D_NOT_integer
  f_ref_species = ref_species
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_factor 0D_NOT_real
  f_factor = factor
  call multipole_kick_mat(knl=f_knl%data, tilt=f_tilt%data, ref_species=f_ref_species, &
      ele=f_ele, orbit=f_orbit, factor=f_factor, mat6=f_mat6)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=1943, definition='real(rp) mat6(6,6), factor', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='matrix with kick values at mat6(2:4:2, 1:3:2). The rest of the matrix is untouched.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_multipole_kicks (knl, tilt, ele, orbit, pole_type, ref_orb_offset) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: knl
  type(real_container_alloc), pointer :: f_knl
  type(c_ptr), intent(in), value :: tilt
  type(real_container_alloc), pointer :: f_tilt
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: pole_type  ! 0D_NOT_integer
  integer(c_int) :: f_pole_type
  integer(c_int), pointer :: f_pole_type_ptr
  type(c_ptr), intent(in), value :: ref_orb_offset  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_ref_orb_offset
  logical, target :: f_ref_orb_offset_native
  logical, pointer :: f_ref_orb_offset_native_ptr
  logical(c_bool), pointer :: f_ref_orb_offset_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(knl))   call c_f_pointer(knl, f_knl)
  !! container general array (1D_ALLOC_real)
  if (c_associated(tilt))   call c_f_pointer(tilt, f_tilt)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_pole_type 0D_NOT_integer
  if (c_associated(pole_type)) then
    call c_f_pointer(pole_type, f_pole_type_ptr)
  else
    f_pole_type_ptr => null()
  endif
  ! in: f_ref_orb_offset 0D_NOT_logical
  if (c_associated(ref_orb_offset)) then
    call c_f_pointer(ref_orb_offset, f_ref_orb_offset_ptr)
    f_ref_orb_offset_native = f_ref_orb_offset_ptr
    f_ref_orb_offset_native_ptr => f_ref_orb_offset_native
  else
    f_ref_orb_offset_native_ptr => null()
  endif
  call multipole_kicks(knl=f_knl%data, tilt=f_tilt%data, ele=f_ele, orbit=f_orbit, &
      pole_type=f_pole_type_ptr, ref_orb_offset=f_ref_orb_offset_native_ptr)

end subroutine
subroutine fortran_multipole_kt_to_ab (knl, knsl, tn, an, bn) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: knl
  type(real_container_alloc), pointer :: f_knl
  type(c_ptr), intent(in), value :: knsl
  type(real_container_alloc), pointer :: f_knsl
  type(c_ptr), intent(in), value :: tn
  type(real_container_alloc), pointer :: f_tn
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: an
  type(real_container_alloc), pointer :: f_an
  type(c_ptr), intent(in), value :: bn
  type(real_container_alloc), pointer :: f_bn
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(knl))   call c_f_pointer(knl, f_knl)
  !! container general array (1D_ALLOC_real)
  if (c_associated(knsl))   call c_f_pointer(knsl, f_knsl)
  !! container general array (1D_ALLOC_real)
  if (c_associated(tn))   call c_f_pointer(tn, f_tn)
  !! container general array (1D_ALLOC_real)
  if (c_associated(an))   call c_f_pointer(an, f_an)
  !! container general array (1D_ALLOC_real)
  if (c_associated(bn))   call c_f_pointer(bn, f_bn)
  call multipole_kt_to_ab(knl=f_knl%data, knsl=f_knsl%data, tn=f_tn%data, an=f_an%data, &
      bn=f_bn%data)

end subroutine
subroutine fortran_multipole_spin_tracking (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call multipole_spin_tracking(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_mytan (y, x, arg) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: arg  ! 0D_NOT_real
  real(rp) :: f_arg
  real(c_double), pointer :: f_arg_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  ! ** End of parameters **
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  f_arg = mytan(y=f_y_ptr, x=f_x_ptr)

  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! out: f_arg 0D_NOT_real
  call c_f_pointer(arg, f_arg_ptr)
  f_arg_ptr = f_arg
end subroutine
subroutine fortran_n_attrib_string_max_len (max_len) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: max_len  ! 0D_NOT_integer
  integer :: f_max_len
  integer(c_int), pointer :: f_max_len_ptr
  ! ** End of parameters **
  f_max_len = n_attrib_string_max_len()

  ! out: f_max_len 0D_NOT_integer
  call c_f_pointer(max_len, f_max_len_ptr)
  f_max_len_ptr = f_max_len
end subroutine
subroutine fortran_new_control (lat, ix_ele, ele_name) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  integer(c_int) :: ix_ele  ! 0D_NOT_integer
  integer :: f_ix_ele
  type(c_ptr), intent(in), value :: ele_name
  character(len=4096), target :: f_ele_name
  character(kind=c_char), pointer :: f_ele_name_ptr(:)
  character(len=4096), pointer :: f_ele_name_call_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_ele 0D_NOT_integer
  f_ix_ele = ix_ele
  ! in: f_ele_name 0D_NOT_character
  if (c_associated(ele_name)) then
    call c_f_pointer(ele_name, f_ele_name_ptr, [huge(0)])
    call to_f_str(f_ele_name_ptr, f_ele_name)
    f_ele_name_call_ptr => f_ele_name
  else
    f_ele_name_call_ptr => null()
  endif
  call new_control(lat=f_lat, ix_ele=f_ix_ele, ele_name=f_ele_name_call_ptr)

end subroutine
subroutine fortran_nint_chk (re_val, int_val) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: re_val  ! 0D_NOT_real
  real(rp) :: f_re_val
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: int_val  ! 0D_NOT_integer
  integer :: f_int_val
  integer(c_int), pointer :: f_int_val_ptr
  ! ** End of parameters **
  ! in: f_re_val 0D_NOT_real
  f_re_val = re_val
  f_int_val = nint_chk(re_val=f_re_val)

  ! out: f_int_val 0D_NOT_integer
  call c_f_pointer(int_val, f_int_val_ptr)
  f_int_val_ptr = f_int_val
end subroutine
subroutine fortran_normal_form_complex_taylors (one_turn_taylor, rf_on, F, L, A, A_inverse, &
    order) bind(c)

  use bmad_struct, only: complex_taylor_struct, taylor_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: one_turn_taylor
  type(taylor_struct), pointer :: f_one_turn_taylor(:)
  type(c_ptr), intent(in), value :: rf_on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_rf_on
  logical, target :: f_rf_on_native
  logical, pointer :: f_rf_on_native_ptr
  logical(c_bool), pointer :: f_rf_on_ptr
  type(c_ptr), intent(in), value :: F
  type(complex_taylor_struct), pointer :: f_F(:)
  type(c_ptr), intent(in), value :: L
  type(complex_taylor_struct), pointer :: f_L(:)
  type(c_ptr), intent(in), value :: A
  type(taylor_struct), pointer :: f_A(:)
  type(c_ptr), intent(in), value :: A_inverse
  type(taylor_struct), pointer :: f_A_inverse(:)
  type(c_ptr), intent(in), value :: order  ! 0D_NOT_integer
  integer(c_int) :: f_order
  integer(c_int), pointer :: f_order_ptr
  ! ** End of parameters **
  !! type array (1D_NOT_type)
  call c_f_pointer(one_turn_taylor, f_one_turn_taylor, [6])
  ! inout: f_rf_on 0D_NOT_logical
  if (c_associated(rf_on)) then
    call c_f_pointer(rf_on, f_rf_on_ptr)
    f_rf_on_native = f_rf_on_ptr
    f_rf_on_native_ptr => f_rf_on_native
  else
    f_rf_on_native_ptr => null()
  endif
  !! type array (1D_NOT_type)
  call c_f_pointer(F, f_F, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(L, f_L, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(A, f_A, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(A_inverse, f_A_inverse, [6])
  ! inout: f_order 0D_NOT_integer
  if (c_associated(order)) then
    call c_f_pointer(order, f_order_ptr)
  else
    f_order_ptr => null()
  endif
  call normal_form_complex_taylors(one_turn_taylor=f_one_turn_taylor, rf_on=f_rf_on_native_ptr, &
      F=f_F, L=f_L, A=f_A, A_inverse=f_A_inverse, order=f_order_ptr)

  ! inout: f_rf_on 0D_NOT_logical
  if (c_associated(rf_on)) then
    call c_f_pointer(rf_on, f_rf_on_ptr)
    f_rf_on_ptr = f_rf_on_native
  else
    ! f_rf_on unset
  endif
  ! inout: f_order 0D_NOT_integer
  ! no output conversion for f_order
end subroutine
subroutine fortran_normal_form_taylors (one_turn_taylor, rf_on, dhdj, A, A_inverse) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: one_turn_taylor
  type(taylor_struct), pointer :: f_one_turn_taylor(:)
  logical(c_bool) :: rf_on  ! 0D_NOT_logical
  logical :: f_rf_on
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dhdj
  type(taylor_struct), pointer :: f_dhdj(:)
  type(c_ptr), intent(in), value :: A
  type(taylor_struct), pointer :: f_A(:)
  type(c_ptr), intent(in), value :: A_inverse
  type(taylor_struct), pointer :: f_A_inverse(:)
  ! ** End of parameters **
  !! type array (1D_NOT_type)
  call c_f_pointer(one_turn_taylor, f_one_turn_taylor, [6])
  ! in: f_rf_on 0D_NOT_logical
  f_rf_on = rf_on
  !! type array (1D_NOT_type)
  call c_f_pointer(dhdj, f_dhdj, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(A, f_A, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(A_inverse, f_A_inverse, [6])
  call normal_form_taylors(one_turn_taylor=f_one_turn_taylor, rf_on=f_rf_on, dhdj=f_dhdj, &
      A=f_A, A_inverse=f_A_inverse)

  ! out: f_dhdj 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
  ! out: f_A 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
  ! out: f_A_inverse 1D_NOT_type
  ! TODO may require output conversion? 1D_NOT_type
end subroutine
subroutine fortran_normal_mode3_calc (t6, tune, B, HV, above_transition, abz_tunes) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: above_transition  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_above_transition
  logical, target :: f_above_transition_native
  logical, pointer :: f_above_transition_native_ptr
  logical(c_bool), pointer :: f_above_transition_ptr
  type(c_ptr), intent(in), value :: abz_tunes
  real(rp) :: f_abz_tunes(3)
  real(c_double), pointer :: f_abz_tunes_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: tune
  real(rp) :: f_tune(3)
  real(c_double), pointer :: f_tune_ptr(:)
  type(c_ptr), intent(in), value :: B
  real(rp) :: f_B(6,6)
  real(c_double), pointer :: f_B_ptr(:)
  type(c_ptr), intent(in), value :: HV
  real(rp) :: f_HV(6,6)
  real(c_double), pointer :: f_HV_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: t6
  real(rp) :: f_t6(6,6)
  real(c_double), pointer :: f_t6_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(t6)) then
    call c_f_pointer(t6, f_t6_ptr, [6*6])
    call vec2mat(f_t6_ptr, f_t6)
  else
    f_t6_ptr => null()
  endif
  ! in: f_above_transition 0D_NOT_logical
  if (c_associated(above_transition)) then
    call c_f_pointer(above_transition, f_above_transition_ptr)
    f_above_transition_native = f_above_transition_ptr
    f_above_transition_native_ptr => f_above_transition_native
  else
    f_above_transition_native_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(abz_tunes)) then
    call c_f_pointer(abz_tunes, f_abz_tunes_ptr, [3])
    f_abz_tunes = f_abz_tunes_ptr(:)
  else
    f_abz_tunes_ptr => null()
  endif
  call normal_mode3_calc(t6=f_t6, tune=f_tune, B=f_B, HV=f_HV, &
      above_transition=f_above_transition_native_ptr, abz_tunes=f_abz_tunes)

  ! out: f_tune 1D_NOT_real
  if (c_associated(tune)) then
    call c_f_pointer(tune, f_tune_ptr, [3])
    f_tune_ptr = f_tune(:)
  endif
  ! out: f_B 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_B', c_name='B', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=132, definition='real(rp) t6(6,6), tune(3), B(6,6), HV(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='B', comment='', default=None), intent='out', description='B is block diagonal and related to the normal mode Twiss parameters.', doc_data_type='float', doc_is_optional=False)
  ! out: f_HV 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_HV', c_name='HV', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=132, definition='real(rp) t6(6,6), tune(3), B(6,6), HV(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='HV', comment='', default=None), intent='out', description='Transforms from normal mode coordinates to canonical coordinates: x = H.V.a', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_normal_mode_dispersion (ele, reverse) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: reverse  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_reverse
  logical, target :: f_reverse_native
  logical, pointer :: f_reverse_native_ptr
  logical(c_bool), pointer :: f_reverse_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_reverse 0D_NOT_logical
  if (c_associated(reverse)) then
    call c_f_pointer(reverse, f_reverse_ptr)
    f_reverse_native = f_reverse_ptr
    f_reverse_native_ptr => f_reverse_native
  else
    f_reverse_native_ptr => null()
  endif
  call normal_mode_dispersion(ele=f_ele, reverse=f_reverse_native_ptr)

end subroutine
subroutine fortran_normalize_evecs (evec, err_flag) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: evec
  complex(rp) :: f_evec(6,6)
  complex(c_double_complex), pointer :: f_evec_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_complex)
  if (c_associated(evec)) then
    call c_f_pointer(evec, f_evec_ptr, [6*6])
    call vec2mat(f_evec_ptr, f_evec)
  else
    f_evec_ptr => null()
  endif
  call normalize_evecs(evec=f_evec, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_num_field_eles (ele, n_field_ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: n_field_ele  ! 0D_NOT_integer
  integer :: f_n_field_ele
  integer(c_int), pointer :: f_n_field_ele_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_n_field_ele = num_field_eles(ele=f_ele)

  ! out: f_n_field_ele 0D_NOT_integer
  call c_f_pointer(n_field_ele, f_n_field_ele_ptr)
  f_n_field_ele_ptr = f_n_field_ele
end subroutine
subroutine fortran_num_lords (slave, lord_type, num) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  integer(c_int) :: lord_type  ! 0D_NOT_integer
  integer :: f_lord_type
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: num  ! 0D_NOT_integer
  integer :: f_num
  integer(c_int), pointer :: f_num_ptr
  ! ** End of parameters **
  ! in: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! in: f_lord_type 0D_NOT_integer
  f_lord_type = lord_type
  f_num = num_lords(slave=f_slave, lord_type=f_lord_type)

  ! out: f_num 0D_NOT_integer
  call c_f_pointer(num, f_num_ptr)
  f_num_ptr = f_num
end subroutine
subroutine fortran_odeint_bmad (orbit, ele, param, s1_body, s2_body, err_flag, track, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  real(c_double) :: s1_body  ! 0D_NOT_real
  real(rp) :: f_s1_body
  real(c_double) :: s2_body  ! 0D_NOT_real
  real(rp) :: f_s2_body
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_s1_body 0D_NOT_real
  f_s1_body = s1_body
  ! in: f_s2_body 0D_NOT_real
  f_s2_body = s2_body
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call odeint_bmad(orbit=f_orbit, ele=f_ele, param=f_param, s1_body=f_s1_body, &
      s2_body=f_s2_body, err_flag=f_err_flag, track=f_track, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_odeint_bmad_time (orb, ele, param, t_dir, rf_time, err_flag, track, t_end, &
    dt_step, extra_field) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: t_dir  ! 0D_NOT_integer
  integer :: f_t_dir
  type(c_ptr), intent(in), value :: t_end  ! 0D_NOT_real
  real(c_double) :: f_t_end
  real(c_double), pointer :: f_t_end_ptr
  type(c_ptr), value :: extra_field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_extra_field
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: dt_step  ! 0D_NOT_real
  real(rp) :: f_dt_step
  real(c_double), pointer :: f_dt_step_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: rf_time  ! 0D_NOT_real
  real(c_double) :: f_rf_time
  real(c_double), pointer :: f_rf_time_ptr
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orb, f_orb)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_t_dir 0D_NOT_integer
  f_t_dir = t_dir
  ! inout: f_rf_time 0D_NOT_real
  if (c_associated(rf_time)) then
    call c_f_pointer(rf_time, f_rf_time_ptr)
  else
    f_rf_time_ptr => null()
  endif
  ! inout: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  ! in: f_t_end 0D_NOT_real
  if (c_associated(t_end)) then
    call c_f_pointer(t_end, f_t_end_ptr)
  else
    f_t_end_ptr => null()
  endif
  ! in: f_extra_field 0D_NOT_type
  if (c_associated(extra_field))   call c_f_pointer(extra_field, f_extra_field)
  call odeint_bmad_time(orb=f_orb, ele=f_ele, param=f_param, t_dir=f_t_dir, &
      rf_time=f_rf_time_ptr, err_flag=f_err_flag, track=f_track, t_end=f_t_end_ptr, &
      dt_step=f_dt_step, extra_field=f_extra_field)

  ! inout: f_rf_time 0D_NOT_real
  ! no output conversion for f_rf_time
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_dt_step 0D_NOT_real
  ! no output conversion for f_dt_step
end subroutine
subroutine fortran_offset_particle (ele, set, orbit, set_tilt, set_hvkicks, drift_to_edge, &
    s_pos, s_out, set_spin, mat6, make_matrix, spin_qrot, time) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: set  ! 0D_NOT_logical
  logical :: f_set
  type(c_ptr), intent(in), value :: set_tilt  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_tilt
  logical, target :: f_set_tilt_native
  logical, pointer :: f_set_tilt_native_ptr
  logical(c_bool), pointer :: f_set_tilt_ptr
  type(c_ptr), intent(in), value :: set_hvkicks  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_hvkicks
  logical, target :: f_set_hvkicks_native
  logical, pointer :: f_set_hvkicks_native_ptr
  logical(c_bool), pointer :: f_set_hvkicks_ptr
  type(c_ptr), intent(in), value :: drift_to_edge  ! 0D_NOT_integer
  integer(c_int) :: f_drift_to_edge
  integer(c_int), pointer :: f_drift_to_edge_ptr
  type(c_ptr), intent(in), value :: s_pos  ! 0D_NOT_real
  real(c_double) :: f_s_pos
  real(c_double), pointer :: f_s_pos_ptr
  type(c_ptr), intent(in), value :: set_spin  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_spin
  logical, target :: f_set_spin_native
  logical, pointer :: f_set_spin_native_ptr
  logical(c_bool), pointer :: f_set_spin_ptr
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: s_out  ! 0D_NOT_real
  real(rp) :: f_s_out
  real(c_double), pointer :: f_s_out_ptr
  type(c_ptr), intent(in), value :: spin_qrot
  real(rp) :: f_spin_qrot(0:3)
  real(c_double), pointer :: f_spin_qrot_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  type(c_ptr), intent(in), value :: time  ! 0D_NOT_real
  real(c_double) :: f_time
  real(c_double), pointer :: f_time_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_set 0D_NOT_logical
  f_set = set
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_set_tilt 0D_NOT_logical
  if (c_associated(set_tilt)) then
    call c_f_pointer(set_tilt, f_set_tilt_ptr)
    f_set_tilt_native = f_set_tilt_ptr
    f_set_tilt_native_ptr => f_set_tilt_native
  else
    f_set_tilt_native_ptr => null()
  endif
  ! in: f_set_hvkicks 0D_NOT_logical
  if (c_associated(set_hvkicks)) then
    call c_f_pointer(set_hvkicks, f_set_hvkicks_ptr)
    f_set_hvkicks_native = f_set_hvkicks_ptr
    f_set_hvkicks_native_ptr => f_set_hvkicks_native
  else
    f_set_hvkicks_native_ptr => null()
  endif
  ! in: f_drift_to_edge 0D_NOT_integer
  if (c_associated(drift_to_edge)) then
    call c_f_pointer(drift_to_edge, f_drift_to_edge_ptr)
  else
    f_drift_to_edge_ptr => null()
  endif
  ! in: f_s_pos 0D_NOT_real
  if (c_associated(s_pos)) then
    call c_f_pointer(s_pos, f_s_pos_ptr)
  else
    f_s_pos_ptr => null()
  endif
  ! in: f_set_spin 0D_NOT_logical
  if (c_associated(set_spin)) then
    call c_f_pointer(set_spin, f_set_spin_ptr)
    f_set_spin_native = f_set_spin_ptr
    f_set_spin_native_ptr => f_set_spin_native
  else
    f_set_spin_native_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  ! inout: f_time 0D_NOT_real
  if (c_associated(time)) then
    call c_f_pointer(time, f_time_ptr)
  else
    f_time_ptr => null()
  endif
  call offset_particle(ele=f_ele, set=f_set, orbit=f_orbit, set_tilt=f_set_tilt_native_ptr, &
      set_hvkicks=f_set_hvkicks_native_ptr, drift_to_edge=f_drift_to_edge_ptr, &
      s_pos=f_s_pos_ptr, s_out=f_s_out, set_spin=f_set_spin_native_ptr, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr, spin_qrot=f_spin_qrot, time=f_time_ptr)

  ! out: f_s_out 0D_NOT_real
  ! no output conversion for f_s_out
  ! out: f_spin_qrot 1D_NOT_real
  if (c_associated(spin_qrot)) then
    call c_f_pointer(spin_qrot, f_spin_qrot_ptr, [4])
    f_spin_qrot_ptr = f_spin_qrot(:)
  endif
  ! inout: f_time 0D_NOT_real
  ! no output conversion for f_time
end subroutine
subroutine fortran_offset_photon (ele, orbit, set, offset_position_only, rot_mat) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: set  ! 0D_NOT_logical
  logical :: f_set
  type(c_ptr), intent(in), value :: offset_position_only  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_offset_position_only
  logical, target :: f_offset_position_only_native
  logical, pointer :: f_offset_position_only_native_ptr
  logical(c_bool), pointer :: f_offset_position_only_ptr
  type(c_ptr), intent(in), value :: rot_mat
  real(rp) :: f_rot_mat(3,3)
  real(c_double), pointer :: f_rot_mat_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_set 0D_NOT_logical
  f_set = set
  ! in: f_offset_position_only 0D_NOT_logical
  if (c_associated(offset_position_only)) then
    call c_f_pointer(offset_position_only, f_offset_position_only_ptr)
    f_offset_position_only_native = f_offset_position_only_ptr
    f_offset_position_only_native_ptr => f_offset_position_only_native
  else
    f_offset_position_only_native_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(rot_mat)) then
    call c_f_pointer(rot_mat, f_rot_mat_ptr, [3*3])
    call vec2mat(f_rot_mat_ptr, f_rot_mat)
  else
    f_rot_mat_ptr => null()
  endif
  call offset_photon(ele=f_ele, orbit=f_orbit, set=f_set, &
      offset_position_only=f_offset_position_only_native_ptr, rot_mat=f_rot_mat)

end subroutine
subroutine fortran_one_turn_mat_at_ele (ele, phi_a, phi_b, mat4) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: phi_a  ! 0D_NOT_real
  real(rp) :: f_phi_a
  real(c_double) :: phi_b  ! 0D_NOT_real
  real(rp) :: f_phi_b
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat4
  real(rp) :: f_mat4(4,4)
  real(c_double), pointer :: f_mat4_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_phi_a 0D_NOT_real
  f_phi_a = phi_a
  ! in: f_phi_b 0D_NOT_real
  f_phi_b = phi_b
  call one_turn_mat_at_ele(ele=f_ele, phi_a=f_phi_a, phi_b=f_phi_b, mat4=f_mat4)

  ! out: f_mat4 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat4', c_name='mat4', type='real', kind='rp', pointer_type='NOT', array=['4', '4'], init_value=None, comment='', member=StructureMember(line=2011, definition='real(rp) mat4(4,4)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='4,4', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat4', comment='', default=None), intent='out', description='1-Turn coupled matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_open_binary_file (file_name, action, iu, r_name, iver, is_ok) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), intent(in), value :: action
  character(len=4096), target :: f_action
  character(kind=c_char), pointer :: f_action_ptr(:)
  type(c_ptr), intent(in), value :: r_name
  character(len=4096), target :: f_r_name
  character(kind=c_char), pointer :: f_r_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: iu  ! 0D_NOT_integer
  integer :: f_iu
  integer(c_int), pointer :: f_iu_ptr
  type(c_ptr), intent(in), value :: iver  ! 0D_NOT_integer
  integer :: f_iver
  integer(c_int), pointer :: f_iver_ptr
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_action 0D_NOT_character
  if (.not. c_associated(action)) return
  call c_f_pointer(action, f_action_ptr, [huge(0)])
  call to_f_str(f_action_ptr, f_action)
  ! in: f_r_name 0D_NOT_character
  if (.not. c_associated(r_name)) return
  call c_f_pointer(r_name, f_r_name_ptr, [huge(0)])
  call to_f_str(f_r_name_ptr, f_r_name)
  f_is_ok = open_binary_file(file_name=f_file_name, action=f_action, iu=f_iu, r_name=f_r_name, &
      iver=f_iver)

  ! out: f_iu 0D_NOT_integer
  call c_f_pointer(iu, f_iu_ptr)
  f_iu_ptr = f_iu
  ! out: f_iver 0D_NOT_integer
  call c_f_pointer(iver, f_iver_ptr)
  f_iver_ptr = f_iver
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_orbit_amplitude_calc (ele, orb, amp_a, amp_b, amp_na, amp_nb) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: amp_a  ! 0D_NOT_real
  real(rp) :: f_amp_a
  real(c_double), pointer :: f_amp_a_ptr
  type(c_ptr), intent(in), value :: amp_b  ! 0D_NOT_real
  real(rp) :: f_amp_b
  real(c_double), pointer :: f_amp_b_ptr
  type(c_ptr), intent(in), value :: amp_na  ! 0D_NOT_real
  real(rp) :: f_amp_na
  real(c_double), pointer :: f_amp_na_ptr
  type(c_ptr), intent(in), value :: amp_nb  ! 0D_NOT_real
  real(rp) :: f_amp_nb
  real(c_double), pointer :: f_amp_nb_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  call orbit_amplitude_calc(ele=f_ele, orb=f_orb, amp_a=f_amp_a, amp_b=f_amp_b, &
      amp_na=f_amp_na, amp_nb=f_amp_nb)

  ! out: f_amp_a 0D_NOT_real
  ! no output conversion for f_amp_a
  ! out: f_amp_b 0D_NOT_real
  ! no output conversion for f_amp_b
  ! out: f_amp_na 0D_NOT_real
  ! no output conversion for f_amp_na
  ! out: f_amp_nb 0D_NOT_real
  ! no output conversion for f_amp_nb
end subroutine
subroutine fortran_orbit_reference_energy_correction (orbit, p0c_new, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: p0c_new  ! 0D_NOT_real
  real(rp) :: f_p0c_new
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_p0c_new 0D_NOT_real
  f_p0c_new = p0c_new
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call orbit_reference_energy_correction(orbit=f_orbit, p0c_new=f_p0c_new, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_orbit_to_floor_phase_space (orbit, ele, floor_phase_space) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: floor_phase_space
  real(rp) :: f_floor_phase_space(6)
  real(c_double), pointer :: f_floor_phase_space_ptr(:)
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_floor_phase_space = orbit_to_floor_phase_space(orbit=f_orbit, ele=f_ele)

  ! out: f_floor_phase_space 1D_NOT_real
  if (c_associated(floor_phase_space)) then
    call c_f_pointer(floor_phase_space, f_floor_phase_space_ptr, [6])
    f_floor_phase_space_ptr = f_floor_phase_space(:)
  endif
end subroutine
subroutine fortran_orbit_to_local_curvilinear (orbit, ele, z_direction, relative_to, &
    local_position) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: z_direction  ! 0D_NOT_integer
  integer(c_int) :: f_z_direction
  integer(c_int), pointer :: f_z_direction_ptr
  type(c_ptr), intent(in), value :: relative_to  ! 0D_NOT_integer
  integer(c_int) :: f_relative_to
  integer(c_int), pointer :: f_relative_to_ptr
  ! ** Out parameters **
  type(c_ptr), value :: local_position  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_local_position
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_z_direction 0D_NOT_integer
  if (c_associated(z_direction)) then
    call c_f_pointer(z_direction, f_z_direction_ptr)
  else
    f_z_direction_ptr => null()
  endif
  ! in: f_relative_to 0D_NOT_integer
  if (c_associated(relative_to)) then
    call c_f_pointer(relative_to, f_relative_to_ptr)
  else
    f_relative_to_ptr => null()
  endif
  f_local_position = orbit_to_local_curvilinear(orbit=f_orbit, ele=f_ele, &
      z_direction=f_z_direction_ptr, relative_to=f_relative_to_ptr)

  ! out: f_local_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_orbit_too_large (orbit, param, check_momentum, is_too_large) bind(c)

  use bmad_struct, only: coord_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: check_momentum  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_check_momentum
  logical, target :: f_check_momentum_native
  logical, pointer :: f_check_momentum_native_ptr
  logical(c_bool), pointer :: f_check_momentum_ptr
  ! ** Out parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: is_too_large  ! 0D_NOT_logical
  logical :: f_is_too_large
  logical(c_bool), pointer :: f_is_too_large_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! out: f_param 0D_NOT_type
  if (c_associated(param))   call c_f_pointer(param, f_param)
  ! in: f_check_momentum 0D_NOT_logical
  if (c_associated(check_momentum)) then
    call c_f_pointer(check_momentum, f_check_momentum_ptr)
    f_check_momentum_native = f_check_momentum_ptr
    f_check_momentum_native_ptr => f_check_momentum_native
  else
    f_check_momentum_native_ptr => null()
  endif
  f_is_too_large = orbit_too_large(orbit=f_orbit, param=f_param, &
      check_momentum=f_check_momentum_native_ptr)

  ! out: f_param 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_is_too_large 0D_NOT_logical
  call c_f_pointer(is_too_large, f_is_too_large_ptr)
  f_is_too_large_ptr = f_is_too_large
end subroutine
subroutine fortran_order_evecs_by_n_similarity (evec, eval, mat_tunes, Nmat, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: Nmat
  real(rp) :: f_Nmat(6,6)
  real(c_double), pointer :: f_Nmat_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: evec
  complex(rp) :: f_evec(6,6)
  complex(c_double_complex), pointer :: f_evec_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: eval
  complex(rp) :: f_eval(6)
  complex(c_double_complex), pointer :: f_eval_ptr(:)
  type(c_ptr), intent(in), value :: mat_tunes
  real(rp) :: f_mat_tunes(3)
  real(c_double), pointer :: f_mat_tunes_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_complex)
  if (c_associated(eval)) then
    call c_f_pointer(eval, f_eval_ptr, [6])
    f_eval = f_eval_ptr(:)
  else
    f_eval_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(mat_tunes)) then
    call c_f_pointer(mat_tunes, f_mat_tunes_ptr, [3])
    f_mat_tunes = f_mat_tunes_ptr(:)
  else
    f_mat_tunes_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(Nmat)) then
    call c_f_pointer(Nmat, f_Nmat_ptr, [6*6])
    call vec2mat(f_Nmat_ptr, f_Nmat)
  else
    f_Nmat_ptr => null()
  endif
  call order_evecs_by_n_similarity(evec=f_evec, eval=f_eval, mat_tunes=f_mat_tunes, &
      Nmat=f_Nmat, err_flag=f_err_flag)

  ! out: f_evec 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_evec', c_name='evec', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=570, definition='complex(rp) evec(6,6)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='evec', comment='', default=None), intent='out', description='complex eigenvectors arranged down columns.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_order_evecs_by_plane_dominance (evec, eval, mat_tunes) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: evec
  complex(rp) :: f_evec(6,6)
  complex(c_double_complex), pointer :: f_evec_ptr(:)
  type(c_ptr), intent(in), value :: eval
  complex(rp) :: f_eval(6)
  complex(c_double_complex), pointer :: f_eval_ptr(:)
  type(c_ptr), intent(in), value :: mat_tunes
  real(rp) :: f_mat_tunes(3)
  real(c_double), pointer :: f_mat_tunes_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_complex)
  if (c_associated(evec)) then
    call c_f_pointer(evec, f_evec_ptr, [6*6])
    call vec2mat(f_evec_ptr, f_evec)
  else
    f_evec_ptr => null()
  endif
  !! general array (1D_NOT_complex)
  if (c_associated(eval)) then
    call c_f_pointer(eval, f_eval_ptr, [6])
    f_eval = f_eval_ptr(:)
  else
    f_eval_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(mat_tunes)) then
    call c_f_pointer(mat_tunes, f_mat_tunes_ptr, [3])
    f_mat_tunes = f_mat_tunes_ptr(:)
  else
    f_mat_tunes_ptr => null()
  endif
  call order_evecs_by_plane_dominance(evec=f_evec, eval=f_eval, mat_tunes=f_mat_tunes)

end subroutine
subroutine fortran_order_evecs_by_tune (evec, eval, mat_tunes, abz_tunes, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: mat_tunes
  real(rp) :: f_mat_tunes(3)
  real(c_double), pointer :: f_mat_tunes_ptr(:)
  type(c_ptr), intent(in), value :: abz_tunes
  real(rp) :: f_abz_tunes(3)
  real(c_double), pointer :: f_abz_tunes_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: evec
  complex(rp) :: f_evec(6,6)
  complex(c_double_complex), pointer :: f_evec_ptr(:)
  type(c_ptr), intent(in), value :: eval
  complex(rp) :: f_eval(6)
  complex(c_double_complex), pointer :: f_eval_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_complex)
  if (c_associated(evec)) then
    call c_f_pointer(evec, f_evec_ptr, [6*6])
    call vec2mat(f_evec_ptr, f_evec)
  else
    f_evec_ptr => null()
  endif
  !! general array (1D_NOT_complex)
  if (c_associated(eval)) then
    call c_f_pointer(eval, f_eval_ptr, [6])
    f_eval = f_eval_ptr(:)
  else
    f_eval_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(mat_tunes)) then
    call c_f_pointer(mat_tunes, f_mat_tunes_ptr, [3])
    f_mat_tunes = f_mat_tunes_ptr(:)
  else
    f_mat_tunes_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(abz_tunes)) then
    call c_f_pointer(abz_tunes, f_abz_tunes_ptr, [3])
    f_abz_tunes = f_abz_tunes_ptr(:)
  else
    f_abz_tunes_ptr => null()
  endif
  call order_evecs_by_tune(evec=f_evec, eval=f_eval, mat_tunes=f_mat_tunes, &
      abz_tunes=f_abz_tunes, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_order_particles_in_z (bunch) bind(c)

  use bmad_struct, only: bunch_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  call order_particles_in_z(bunch=f_bunch)

end subroutine
subroutine fortran_order_super_lord_slaves (lat, ix_lord) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  integer(c_int) :: ix_lord  ! 0D_NOT_integer
  integer :: f_ix_lord
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_lord 0D_NOT_integer
  f_ix_lord = ix_lord
  call order_super_lord_slaves(lat=f_lat, ix_lord=f_ix_lord)

end subroutine
subroutine fortran_osc_alloc_freespace_array (nlo, nhi, npad) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: nlo
  integer :: f_nlo(3)
  integer(c_int), pointer :: f_nlo_ptr(:)
  type(c_ptr), intent(in), value :: nhi
  integer :: f_nhi(3)
  integer(c_int), pointer :: f_nhi_ptr(:)
  type(c_ptr), intent(in), value :: npad
  integer :: f_npad(3)
  integer(c_int), pointer :: f_npad_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_integer)
  if (c_associated(nlo)) then
    call c_f_pointer(nlo, f_nlo_ptr, [3])
    f_nlo = f_nlo_ptr(:)
  else
    f_nlo_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(nhi)) then
    call c_f_pointer(nhi, f_nhi_ptr, [3])
    f_nhi = f_nhi_ptr(:)
  else
    f_nhi_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(npad)) then
    call c_f_pointer(npad, f_npad_ptr, [3])
    f_npad = f_npad_ptr(:)
  else
    f_npad_ptr => null()
  endif
  call osc_alloc_freespace_array(nlo=f_nlo, nhi=f_nhi, npad=f_npad)

end subroutine
subroutine fortran_osc_alloc_image_array (nlo, nhi, npad) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: nlo
  integer :: f_nlo(3)
  integer(c_int), pointer :: f_nlo_ptr(:)
  type(c_ptr), intent(in), value :: nhi
  integer :: f_nhi(3)
  integer(c_int), pointer :: f_nhi_ptr(:)
  type(c_ptr), intent(in), value :: npad
  integer :: f_npad(3)
  integer(c_int), pointer :: f_npad_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_integer)
  if (c_associated(nlo)) then
    call c_f_pointer(nlo, f_nlo_ptr, [3])
    f_nlo = f_nlo_ptr(:)
  else
    f_nlo_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(nhi)) then
    call c_f_pointer(nhi, f_nhi_ptr, [3])
    f_nhi = f_nhi_ptr(:)
  else
    f_nhi_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(npad)) then
    call c_f_pointer(npad, f_npad_ptr, [3])
    f_npad = f_npad_ptr(:)
  else
    f_npad_ptr => null()
  endif
  call osc_alloc_image_array(nlo=f_nlo, nhi=f_nhi, npad=f_npad)

end subroutine
subroutine fortran_osc_alloc_rectpipe_arrays (nlo, nhi, npad) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: nlo
  integer :: f_nlo(3)
  integer(c_int), pointer :: f_nlo_ptr(:)
  type(c_ptr), intent(in), value :: nhi
  integer :: f_nhi(3)
  integer(c_int), pointer :: f_nhi_ptr(:)
  type(c_ptr), intent(in), value :: npad
  integer :: f_npad(3)
  integer(c_int), pointer :: f_npad_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_integer)
  if (c_associated(nlo)) then
    call c_f_pointer(nlo, f_nlo_ptr, [3])
    f_nlo = f_nlo_ptr(:)
  else
    f_nlo_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(nhi)) then
    call c_f_pointer(nhi, f_nhi_ptr, [3])
    f_nhi = f_nhi_ptr(:)
  else
    f_nhi_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(npad)) then
    call c_f_pointer(npad, f_npad_ptr, [3])
    f_npad = f_npad_ptr(:)
  else
    f_npad_ptr => null()
  endif
  call osc_alloc_rectpipe_arrays(nlo=f_nlo, nhi=f_nhi, npad=f_npad)

end subroutine
subroutine fortran_osc_getgrnpipe (gam, a, b, delta, umin, npad) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  type(c_ptr), intent(in), value :: a  ! 0D_NOT_real
  real(c_double) :: f_a
  real(c_double), pointer :: f_a_ptr
  type(c_ptr), intent(in), value :: b  ! 0D_NOT_real
  real(c_double) :: f_b
  real(c_double), pointer :: f_b_ptr
  type(c_ptr), intent(in), value :: delta
  real(dp) :: f_delta(3)
  real(c_double), pointer :: f_delta_ptr(:)
  type(c_ptr), intent(in), value :: umin
  real(dp) :: f_umin(3)
  real(c_double), pointer :: f_umin_ptr(:)
  type(c_ptr), intent(in), value :: npad
  integer :: f_npad(3)
  integer(c_int), pointer :: f_npad_ptr(:)
  ! ** End of parameters **
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  ! inout: f_a 0D_NOT_real
  if (c_associated(a)) then
    call c_f_pointer(a, f_a_ptr)
  else
    f_a_ptr => null()
  endif
  ! inout: f_b 0D_NOT_real
  if (c_associated(b)) then
    call c_f_pointer(b, f_b_ptr)
  else
    f_b_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(delta)) then
    call c_f_pointer(delta, f_delta_ptr, [3])
    f_delta = f_delta_ptr(:)
  else
    f_delta_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(umin)) then
    call c_f_pointer(umin, f_umin_ptr, [3])
    f_umin = f_umin_ptr(:)
  else
    f_umin_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(npad)) then
    call c_f_pointer(npad, f_npad_ptr, [3])
    f_npad = f_npad_ptr(:)
  else
    f_npad_ptr => null()
  endif
  call osc_getgrnpipe(gam=f_gam_ptr, a=f_a_ptr, b=f_b_ptr, delta=f_delta, umin=f_umin, &
      npad=f_npad)

  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! inout: f_a 0D_NOT_real
  ! no output conversion for f_a
  ! inout: f_b 0D_NOT_real
  ! no output conversion for f_b
end subroutine
subroutine fortran_osc_read_rectpipe_grn () bind(c)

  implicit none
  ! ** End of parameters **
  call osc_read_rectpipe_grn()

end subroutine
subroutine fortran_osc_write_rectpipe_grn (apipe, bpipe, delta, umin, umax, nlo, nhi, gamma) &
    bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: apipe  ! 0D_NOT_real
  real(c_double) :: f_apipe
  real(c_double), pointer :: f_apipe_ptr
  type(c_ptr), intent(in), value :: bpipe  ! 0D_NOT_real
  real(c_double) :: f_bpipe
  real(c_double), pointer :: f_bpipe_ptr
  type(c_ptr), intent(in), value :: delta
  real(dp) :: f_delta(3)
  real(c_double), pointer :: f_delta_ptr(:)
  type(c_ptr), intent(in), value :: umin
  real(dp) :: f_umin(3)
  real(c_double), pointer :: f_umin_ptr(:)
  type(c_ptr), intent(in), value :: umax
  real(dp) :: f_umax(3)
  real(c_double), pointer :: f_umax_ptr(:)
  type(c_ptr), intent(in), value :: nlo
  integer :: f_nlo(3)
  integer(c_int), pointer :: f_nlo_ptr(:)
  type(c_ptr), intent(in), value :: nhi
  integer :: f_nhi(3)
  integer(c_int), pointer :: f_nhi_ptr(:)
  type(c_ptr), intent(in), value :: gamma  ! 0D_NOT_real
  real(c_double) :: f_gamma
  real(c_double), pointer :: f_gamma_ptr
  ! ** End of parameters **
  ! inout: f_apipe 0D_NOT_real
  if (c_associated(apipe)) then
    call c_f_pointer(apipe, f_apipe_ptr)
  else
    f_apipe_ptr => null()
  endif
  ! inout: f_bpipe 0D_NOT_real
  if (c_associated(bpipe)) then
    call c_f_pointer(bpipe, f_bpipe_ptr)
  else
    f_bpipe_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(delta)) then
    call c_f_pointer(delta, f_delta_ptr, [3])
    f_delta = f_delta_ptr(:)
  else
    f_delta_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(umin)) then
    call c_f_pointer(umin, f_umin_ptr, [3])
    f_umin = f_umin_ptr(:)
  else
    f_umin_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(umax)) then
    call c_f_pointer(umax, f_umax_ptr, [3])
    f_umax = f_umax_ptr(:)
  else
    f_umax_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(nlo)) then
    call c_f_pointer(nlo, f_nlo_ptr, [3])
    f_nlo = f_nlo_ptr(:)
  else
    f_nlo_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(nhi)) then
    call c_f_pointer(nhi, f_nhi_ptr, [3])
    f_nhi = f_nhi_ptr(:)
  else
    f_nhi_ptr => null()
  endif
  ! inout: f_gamma 0D_NOT_real
  if (c_associated(gamma)) then
    call c_f_pointer(gamma, f_gamma_ptr)
  else
    f_gamma_ptr => null()
  endif
  call osc_write_rectpipe_grn(apipe=f_apipe_ptr, bpipe=f_bpipe_ptr, delta=f_delta, umin=f_umin, &
      umax=f_umax, nlo=f_nlo, nhi=f_nhi, gamma=f_gamma_ptr)

  ! inout: f_apipe 0D_NOT_real
  ! no output conversion for f_apipe
  ! inout: f_bpipe 0D_NOT_real
  ! no output conversion for f_bpipe
  ! inout: f_gamma 0D_NOT_real
  ! no output conversion for f_gamma
end subroutine
subroutine fortran_parse_cartesian_map (ct_map, ele, lat, delim, delim_found, err_flag) bind(c)

  use bmad_struct, only: cartesian_map_struct, ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ct_map  ! 0D_NOT_type
  type(cartesian_map_struct), pointer :: f_ct_map
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_ct_map 0D_NOT_type
  if (.not. c_associated(ct_map)) return
  call c_f_pointer(ct_map, f_ct_map)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parse_cartesian_map(ct_map=f_ct_map, ele=f_ele, lat=f_lat, delim=f_delim, &
      delim_found=f_delim_found_native_ptr, err_flag=f_err_flag_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parse_cylindrical_map (cl_map, ele, lat, delim, delim_found, err_flag) &
    bind(c)

  use bmad_struct, only: cylindrical_map_struct, ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: cl_map  ! 0D_PTR_type
  type(cylindrical_map_struct), pointer :: f_cl_map
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_cl_map 0D_PTR_type
  if (.not. c_associated(cl_map)) return
  call c_f_pointer(cl_map, f_cl_map)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parse_cylindrical_map(cl_map=f_cl_map, ele=f_ele, lat=f_lat, delim=f_delim, &
      delim_found=f_delim_found_native_ptr, err_flag=f_err_flag_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parse_gen_grad_map (gg_map, ele, lat, delim, delim_found, err_flag) bind(c)

  use bmad_struct, only: ele_struct, gen_grad_map_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: gg_map  ! 0D_PTR_type
  type(gen_grad_map_struct), pointer :: f_gg_map
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_gg_map 0D_PTR_type
  if (.not. c_associated(gg_map)) return
  call c_f_pointer(gg_map, f_gg_map)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parse_gen_grad_map(gg_map=f_gg_map, ele=f_ele, lat=f_lat, delim=f_delim, &
      delim_found=f_delim_found_native_ptr, err_flag=f_err_flag_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parse_grid_field (g_field, ele, lat, delim, delim_found, err_flag) bind(c)

  use bmad_struct, only: ele_struct, grid_field_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: g_field  ! 0D_PTR_type
  type(grid_field_struct), pointer :: f_g_field
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_g_field 0D_PTR_type
  if (.not. c_associated(g_field)) return
  call c_f_pointer(g_field, f_g_field)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parse_grid_field(g_field=f_g_field, ele=f_ele, lat=f_lat, delim=f_delim, &
      delim_found=f_delim_found_native_ptr, err_flag=f_err_flag_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parse_integer_list (err_str, lat, int_array, exact_size, delim, delim_found, &
    open_delim, separator, close_delim, default_value, is_ok) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: int_array
  type(integer_container_alloc), pointer :: f_int_array
  type(c_ptr), intent(in), value :: exact_size  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact_size
  logical, target :: f_exact_size_native
  logical, pointer :: f_exact_size_native_ptr
  logical(c_bool), pointer :: f_exact_size_ptr
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: open_delim
  character(len=4096), target :: f_open_delim
  character(kind=c_char), pointer :: f_open_delim_ptr(:)
  character(len=4096), pointer :: f_open_delim_call_ptr
  type(c_ptr), intent(in), value :: separator
  character(len=4096), target :: f_separator
  character(kind=c_char), pointer :: f_separator_ptr(:)
  character(len=4096), pointer :: f_separator_call_ptr
  type(c_ptr), intent(in), value :: close_delim
  character(len=4096), target :: f_close_delim
  character(kind=c_char), pointer :: f_close_delim_ptr(:)
  character(len=4096), pointer :: f_close_delim_call_ptr
  type(c_ptr), intent(in), value :: default_value  ! 0D_NOT_integer
  integer(c_int) :: f_default_value
  integer(c_int), pointer :: f_default_value_ptr
  ! ** End of parameters **
  ! inout: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container general array (1D_ALLOC_integer)
  if (c_associated(int_array))   call c_f_pointer(int_array, f_int_array)
  ! inout: f_exact_size 0D_NOT_logical
  if (c_associated(exact_size)) then
    call c_f_pointer(exact_size, f_exact_size_ptr)
    f_exact_size_native = f_exact_size_ptr
    f_exact_size_native_ptr => f_exact_size_native
  else
    f_exact_size_native_ptr => null()
  endif
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_open_delim 0D_NOT_character
  if (c_associated(open_delim)) then
    call c_f_pointer(open_delim, f_open_delim_ptr, [huge(0)])
    call to_f_str(f_open_delim_ptr, f_open_delim)
    f_open_delim_call_ptr => f_open_delim
  else
    f_open_delim_call_ptr => null()
  endif
  ! inout: f_separator 0D_NOT_character
  if (c_associated(separator)) then
    call c_f_pointer(separator, f_separator_ptr, [huge(0)])
    call to_f_str(f_separator_ptr, f_separator)
    f_separator_call_ptr => f_separator
  else
    f_separator_call_ptr => null()
  endif
  ! inout: f_close_delim 0D_NOT_character
  if (c_associated(close_delim)) then
    call c_f_pointer(close_delim, f_close_delim_ptr, [huge(0)])
    call to_f_str(f_close_delim_ptr, f_close_delim)
    f_close_delim_call_ptr => f_close_delim
  else
    f_close_delim_call_ptr => null()
  endif
  ! inout: f_default_value 0D_NOT_integer
  if (c_associated(default_value)) then
    call c_f_pointer(default_value, f_default_value_ptr)
  else
    f_default_value_ptr => null()
  endif
  f_is_ok = parse_integer_list(err_str=f_err_str, lat=f_lat, int_array=f_int_array%data, &
      exact_size=f_exact_size_native_ptr, delim=f_delim, delim_found=f_delim_found_native_ptr, &
      open_delim=f_open_delim_call_ptr, separator=f_separator_call_ptr, &
      close_delim=f_close_delim_call_ptr, default_value=f_default_value_ptr)

  ! inout: f_err_str 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_exact_size 0D_NOT_logical
  if (c_associated(exact_size)) then
    call c_f_pointer(exact_size, f_exact_size_ptr)
    f_exact_size_ptr = f_exact_size_native
  else
    ! f_exact_size unset
  endif
  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_open_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_separator 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_close_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_default_value 0D_NOT_integer
  ! no output conversion for f_default_value
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parse_integer_list2 (err_str, lat, int_array, num_found, delim, delim_found, &
    num_expected, open_delim, separator, close_delim, default_value, is_ok) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: num_found  ! 0D_NOT_integer
  integer :: f_num_found
  integer(c_int), pointer :: f_num_found_ptr
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical :: f_delim_found
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: int_array
  type(integer_container_alloc), pointer :: f_int_array
  type(c_ptr), intent(in), value :: num_expected  ! 0D_NOT_integer
  integer(c_int) :: f_num_expected
  integer(c_int), pointer :: f_num_expected_ptr
  type(c_ptr), intent(in), value :: open_delim
  character(len=4096), target :: f_open_delim
  character(kind=c_char), pointer :: f_open_delim_ptr(:)
  character(len=4096), pointer :: f_open_delim_call_ptr
  type(c_ptr), intent(in), value :: separator
  character(len=4096), target :: f_separator
  character(kind=c_char), pointer :: f_separator_ptr(:)
  character(len=4096), pointer :: f_separator_call_ptr
  type(c_ptr), intent(in), value :: close_delim
  character(len=4096), target :: f_close_delim
  character(kind=c_char), pointer :: f_close_delim_ptr(:)
  character(len=4096), pointer :: f_close_delim_call_ptr
  type(c_ptr), intent(in), value :: default_value  ! 0D_NOT_integer
  integer(c_int) :: f_default_value
  integer(c_int), pointer :: f_default_value_ptr
  ! ** End of parameters **
  ! in: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container general array (1D_ALLOC_integer)
  if (c_associated(int_array))   call c_f_pointer(int_array, f_int_array)
  ! inout: f_num_expected 0D_NOT_integer
  if (c_associated(num_expected)) then
    call c_f_pointer(num_expected, f_num_expected_ptr)
  else
    f_num_expected_ptr => null()
  endif
  ! inout: f_open_delim 0D_NOT_character
  if (c_associated(open_delim)) then
    call c_f_pointer(open_delim, f_open_delim_ptr, [huge(0)])
    call to_f_str(f_open_delim_ptr, f_open_delim)
    f_open_delim_call_ptr => f_open_delim
  else
    f_open_delim_call_ptr => null()
  endif
  ! inout: f_separator 0D_NOT_character
  if (c_associated(separator)) then
    call c_f_pointer(separator, f_separator_ptr, [huge(0)])
    call to_f_str(f_separator_ptr, f_separator)
    f_separator_call_ptr => f_separator
  else
    f_separator_call_ptr => null()
  endif
  ! inout: f_close_delim 0D_NOT_character
  if (c_associated(close_delim)) then
    call c_f_pointer(close_delim, f_close_delim_ptr, [huge(0)])
    call to_f_str(f_close_delim_ptr, f_close_delim)
    f_close_delim_call_ptr => f_close_delim
  else
    f_close_delim_call_ptr => null()
  endif
  ! inout: f_default_value 0D_NOT_integer
  if (c_associated(default_value)) then
    call c_f_pointer(default_value, f_default_value_ptr)
  else
    f_default_value_ptr => null()
  endif
  f_is_ok = parse_integer_list2(err_str=f_err_str, lat=f_lat, int_array=f_int_array%data, &
      num_found=f_num_found, delim=f_delim, delim_found=f_delim_found, &
      num_expected=f_num_expected_ptr, open_delim=f_open_delim_call_ptr, &
      separator=f_separator_call_ptr, close_delim=f_close_delim_call_ptr, &
      default_value=f_default_value_ptr)

  ! out: f_num_found 0D_NOT_integer
  call c_f_pointer(num_found, f_num_found_ptr)
  f_num_found_ptr = f_num_found
  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_delim_found 0D_NOT_logical
  call c_f_pointer(delim_found, f_delim_found_ptr)
  f_delim_found_ptr = f_delim_found
  ! inout: f_num_expected 0D_NOT_integer
  ! no output conversion for f_num_expected
  ! inout: f_open_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_separator 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_close_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_default_value 0D_NOT_integer
  ! no output conversion for f_default_value
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parse_real_list (lat, err_str, real_array, exact_size, delim, delim_found, &
    open_delim, separator, close_delim, default_value, num_found, is_ok) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  logical(c_bool) :: exact_size  ! 0D_NOT_logical
  logical :: f_exact_size
  type(c_ptr), intent(in), value :: open_delim
  character(len=4096), target :: f_open_delim
  character(kind=c_char), pointer :: f_open_delim_ptr(:)
  character(len=4096), pointer :: f_open_delim_call_ptr
  type(c_ptr), intent(in), value :: separator
  character(len=4096), target :: f_separator
  character(kind=c_char), pointer :: f_separator_ptr(:)
  character(len=4096), pointer :: f_separator_call_ptr
  type(c_ptr), intent(in), value :: close_delim
  character(len=4096), target :: f_close_delim
  character(kind=c_char), pointer :: f_close_delim_ptr(:)
  character(len=4096), pointer :: f_close_delim_call_ptr
  type(c_ptr), intent(in), value :: default_value  ! 0D_NOT_real
  real(c_double) :: f_default_value
  real(c_double), pointer :: f_default_value_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: real_array
  type(real_container_alloc), pointer :: f_real_array
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical :: f_delim_found
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: num_found  ! 0D_NOT_integer
  integer :: f_num_found
  integer(c_int), pointer :: f_num_found_ptr
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  !! container general array (1D_ALLOC_real)
  if (c_associated(real_array))   call c_f_pointer(real_array, f_real_array)
  ! in: f_exact_size 0D_NOT_logical
  f_exact_size = exact_size
  ! in: f_open_delim 0D_NOT_character
  if (c_associated(open_delim)) then
    call c_f_pointer(open_delim, f_open_delim_ptr, [huge(0)])
    call to_f_str(f_open_delim_ptr, f_open_delim)
    f_open_delim_call_ptr => f_open_delim
  else
    f_open_delim_call_ptr => null()
  endif
  ! in: f_separator 0D_NOT_character
  if (c_associated(separator)) then
    call c_f_pointer(separator, f_separator_ptr, [huge(0)])
    call to_f_str(f_separator_ptr, f_separator)
    f_separator_call_ptr => f_separator
  else
    f_separator_call_ptr => null()
  endif
  ! in: f_close_delim 0D_NOT_character
  if (c_associated(close_delim)) then
    call c_f_pointer(close_delim, f_close_delim_ptr, [huge(0)])
    call to_f_str(f_close_delim_ptr, f_close_delim)
    f_close_delim_call_ptr => f_close_delim
  else
    f_close_delim_call_ptr => null()
  endif
  ! in: f_default_value 0D_NOT_real
  if (c_associated(default_value)) then
    call c_f_pointer(default_value, f_default_value_ptr)
  else
    f_default_value_ptr => null()
  endif
  f_is_ok = parse_real_list(lat=f_lat, err_str=f_err_str, real_array=f_real_array%data, &
      exact_size=f_exact_size, delim=f_delim, delim_found=f_delim_found, &
      open_delim=f_open_delim_call_ptr, separator=f_separator_call_ptr, &
      close_delim=f_close_delim_call_ptr, default_value=f_default_value_ptr, &
      num_found=f_num_found)

  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_delim_found 0D_NOT_logical
  call c_f_pointer(delim_found, f_delim_found_ptr)
  f_delim_found_ptr = f_delim_found
  ! out: f_num_found 0D_NOT_integer
  ! no output conversion for f_num_found
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parse_real_list2 (lat, err_str, real_array, num_found, delim, delim_found, &
    num_expected, open_brace, separator, close_brace, default_value, single_value, is_ok) &
    bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: num_found  ! 0D_NOT_integer
  integer :: f_num_found
  integer(c_int), pointer :: f_num_found_ptr
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical :: f_delim_found
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: real_array
  type(real_container_alloc), pointer :: f_real_array
  type(c_ptr), intent(in), value :: num_expected  ! 0D_NOT_integer
  integer(c_int) :: f_num_expected
  integer(c_int), pointer :: f_num_expected_ptr
  type(c_ptr), intent(in), value :: open_brace
  character(len=4096), target :: f_open_brace
  character(kind=c_char), pointer :: f_open_brace_ptr(:)
  character(len=4096), pointer :: f_open_brace_call_ptr
  type(c_ptr), intent(in), value :: separator
  character(len=4096), target :: f_separator
  character(kind=c_char), pointer :: f_separator_ptr(:)
  character(len=4096), pointer :: f_separator_call_ptr
  type(c_ptr), intent(in), value :: close_brace
  character(len=4096), target :: f_close_brace
  character(kind=c_char), pointer :: f_close_brace_ptr(:)
  character(len=4096), pointer :: f_close_brace_call_ptr
  type(c_ptr), intent(in), value :: default_value  ! 0D_NOT_real
  real(c_double) :: f_default_value
  real(c_double), pointer :: f_default_value_ptr
  type(c_ptr), intent(in), value :: single_value  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_single_value
  logical, target :: f_single_value_native
  logical, pointer :: f_single_value_native_ptr
  logical(c_bool), pointer :: f_single_value_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  !! container general array (1D_ALLOC_real)
  if (c_associated(real_array))   call c_f_pointer(real_array, f_real_array)
  ! inout: f_num_expected 0D_NOT_integer
  if (c_associated(num_expected)) then
    call c_f_pointer(num_expected, f_num_expected_ptr)
  else
    f_num_expected_ptr => null()
  endif
  ! inout: f_open_brace 0D_NOT_character
  if (c_associated(open_brace)) then
    call c_f_pointer(open_brace, f_open_brace_ptr, [huge(0)])
    call to_f_str(f_open_brace_ptr, f_open_brace)
    f_open_brace_call_ptr => f_open_brace
  else
    f_open_brace_call_ptr => null()
  endif
  ! inout: f_separator 0D_NOT_character
  if (c_associated(separator)) then
    call c_f_pointer(separator, f_separator_ptr, [huge(0)])
    call to_f_str(f_separator_ptr, f_separator)
    f_separator_call_ptr => f_separator
  else
    f_separator_call_ptr => null()
  endif
  ! inout: f_close_brace 0D_NOT_character
  if (c_associated(close_brace)) then
    call c_f_pointer(close_brace, f_close_brace_ptr, [huge(0)])
    call to_f_str(f_close_brace_ptr, f_close_brace)
    f_close_brace_call_ptr => f_close_brace
  else
    f_close_brace_call_ptr => null()
  endif
  ! inout: f_default_value 0D_NOT_real
  if (c_associated(default_value)) then
    call c_f_pointer(default_value, f_default_value_ptr)
  else
    f_default_value_ptr => null()
  endif
  ! inout: f_single_value 0D_NOT_logical
  if (c_associated(single_value)) then
    call c_f_pointer(single_value, f_single_value_ptr)
    f_single_value_native = f_single_value_ptr
    f_single_value_native_ptr => f_single_value_native
  else
    f_single_value_native_ptr => null()
  endif
  f_is_ok = parse_real_list2(lat=f_lat, err_str=f_err_str, real_array=f_real_array%data, &
      num_found=f_num_found, delim=f_delim, delim_found=f_delim_found, &
      num_expected=f_num_expected_ptr, open_brace=f_open_brace_call_ptr, &
      separator=f_separator_call_ptr, close_brace=f_close_brace_call_ptr, &
      default_value=f_default_value_ptr, single_value=f_single_value_native_ptr)

  ! out: f_num_found 0D_NOT_integer
  call c_f_pointer(num_found, f_num_found_ptr)
  f_num_found_ptr = f_num_found
  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_delim_found 0D_NOT_logical
  call c_f_pointer(delim_found, f_delim_found_ptr)
  f_delim_found_ptr = f_delim_found
  ! inout: f_num_expected 0D_NOT_integer
  ! no output conversion for f_num_expected
  ! inout: f_open_brace 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_separator 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_close_brace 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_default_value 0D_NOT_real
  ! no output conversion for f_default_value
  ! inout: f_single_value 0D_NOT_logical
  if (c_associated(single_value)) then
    call c_f_pointer(single_value, f_single_value_ptr)
    f_single_value_ptr = f_single_value_native
  else
    ! f_single_value unset
  endif
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parser_add_constant (word, lat, redef_is_error) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: word
  character(len=4096), target :: f_word
  character(kind=c_char), pointer :: f_word_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: redef_is_error  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_redef_is_error
  logical, target :: f_redef_is_error_native
  logical, pointer :: f_redef_is_error_native_ptr
  logical(c_bool), pointer :: f_redef_is_error_ptr
  ! ** End of parameters **
  ! inout: f_word 0D_NOT_character
  if (.not. c_associated(word)) return
  call c_f_pointer(word, f_word_ptr, [huge(0)])
  call to_f_str(f_word_ptr, f_word)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_redef_is_error 0D_NOT_logical
  if (c_associated(redef_is_error)) then
    call c_f_pointer(redef_is_error, f_redef_is_error_ptr)
    f_redef_is_error_native = f_redef_is_error_ptr
    f_redef_is_error_native_ptr => f_redef_is_error_native
  else
    f_redef_is_error_native_ptr => null()
  endif
  call parser_add_constant(word=f_word, lat=f_lat, redef_is_error=f_redef_is_error_native_ptr)

  ! inout: f_word 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_redef_is_error 0D_NOT_logical
  if (c_associated(redef_is_error)) then
    call c_f_pointer(redef_is_error, f_redef_is_error_ptr)
    f_redef_is_error_ptr = f_redef_is_error_native
  else
    ! f_redef_is_error unset
  endif
end subroutine
subroutine fortran_parser_call_check (word, ix_word, delim, delim_found, call_found, err_flag) &
    bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: word
  character(len=4096), target :: f_word
  character(kind=c_char), pointer :: f_word_ptr(:)
  type(c_ptr), intent(in), value :: ix_word  ! 0D_NOT_integer
  integer(c_int) :: f_ix_word
  integer(c_int), pointer :: f_ix_word_ptr
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: call_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_call_found
  logical, target :: f_call_found_native
  logical, pointer :: f_call_found_native_ptr
  logical(c_bool), pointer :: f_call_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_word 0D_NOT_character
  if (.not. c_associated(word)) return
  call c_f_pointer(word, f_word_ptr, [huge(0)])
  call to_f_str(f_word_ptr, f_word)
  ! inout: f_ix_word 0D_NOT_integer
  if (c_associated(ix_word)) then
    call c_f_pointer(ix_word, f_ix_word_ptr)
  else
    f_ix_word_ptr => null()
  endif
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_call_found 0D_NOT_logical
  if (c_associated(call_found)) then
    call c_f_pointer(call_found, f_call_found_ptr)
    f_call_found_native = f_call_found_ptr
    f_call_found_native_ptr => f_call_found_native
  else
    f_call_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parser_call_check(word=f_word, ix_word=f_ix_word_ptr, delim=f_delim, &
      delim_found=f_delim_found_native_ptr, call_found=f_call_found_native_ptr, &
      err_flag=f_err_flag_native_ptr)

  ! inout: f_word 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_ix_word 0D_NOT_integer
  ! no output conversion for f_ix_word
  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_call_found 0D_NOT_logical
  if (c_associated(call_found)) then
    call c_f_pointer(call_found, f_call_found_ptr)
    f_call_found_ptr = f_call_found_native
  else
    ! f_call_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parser_fast_complex_read (cmplx_vec, ele, delim, err_str, is_ok) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: cmplx_vec
  type(complex_container_alloc), pointer :: f_cmplx_vec
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_complex)
  if (c_associated(cmplx_vec))   call c_f_pointer(cmplx_vec, f_cmplx_vec)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  f_is_ok = parser_fast_complex_read(cmplx_vec=f_cmplx_vec%data, ele=f_ele, delim=f_delim, &
      err_str=f_err_str)

  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parser_fast_integer_read (int_vec, ele, delim_wanted, err_str, is_ok) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: int_vec
  type(integer_container_alloc), pointer :: f_int_vec
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: delim_wanted
  character(len=4096), target :: f_delim_wanted
  character(kind=c_char), pointer :: f_delim_wanted_ptr(:)
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  ! ** End of parameters **
  !! container general array (1D_ALLOC_integer)
  if (c_associated(int_vec))   call c_f_pointer(int_vec, f_int_vec)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_delim_wanted 0D_NOT_character
  if (.not. c_associated(delim_wanted)) return
  call c_f_pointer(delim_wanted, f_delim_wanted_ptr, [huge(0)])
  call to_f_str(f_delim_wanted_ptr, f_delim_wanted)
  ! inout: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  f_is_ok = parser_fast_integer_read(int_vec=f_int_vec%data, ele=f_ele, &
      delim_wanted=f_delim_wanted, err_str=f_err_str)

  ! inout: f_delim_wanted 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_err_str 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parser_fast_real_read (real_vec, ele, end_delims, delim, err_str, &
    exact_size, n_real, is_ok) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: end_delims
  character(len=4096), target :: f_end_delims
  character(kind=c_char), pointer :: f_end_delims_ptr(:)
  type(c_ptr), intent(in), value :: err_str
  character(len=4096), target :: f_err_str
  character(kind=c_char), pointer :: f_err_str_ptr(:)
  type(c_ptr), intent(in), value :: exact_size  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact_size
  logical, target :: f_exact_size_native
  logical, pointer :: f_exact_size_native_ptr
  logical(c_bool), pointer :: f_exact_size_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: real_vec
  type(real_container_alloc), pointer :: f_real_vec
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: n_real  ! 0D_NOT_integer
  integer :: f_n_real
  integer(c_int), pointer :: f_n_real_ptr
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(real_vec))   call c_f_pointer(real_vec, f_real_vec)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_end_delims 0D_NOT_character
  if (.not. c_associated(end_delims)) return
  call c_f_pointer(end_delims, f_end_delims_ptr, [huge(0)])
  call to_f_str(f_end_delims_ptr, f_end_delims)
  ! in: f_err_str 0D_NOT_character
  if (.not. c_associated(err_str)) return
  call c_f_pointer(err_str, f_err_str_ptr, [huge(0)])
  call to_f_str(f_err_str_ptr, f_err_str)
  ! in: f_exact_size 0D_NOT_logical
  if (c_associated(exact_size)) then
    call c_f_pointer(exact_size, f_exact_size_ptr)
    f_exact_size_native = f_exact_size_ptr
    f_exact_size_native_ptr => f_exact_size_native
  else
    f_exact_size_native_ptr => null()
  endif
  f_is_ok = parser_fast_real_read(real_vec=f_real_vec%data, ele=f_ele, end_delims=f_end_delims, &
      delim=f_delim, err_str=f_err_str, exact_size=f_exact_size_native_ptr, n_real=f_n_real)

  ! out: f_delim 0D_NOT_character
  call c_f_pointer(delim, f_delim_ptr, [len_trim(f_delim) + 1]) ! output-only string
  call to_c_str(f_delim, f_delim_ptr)
  ! out: f_n_real 0D_NOT_integer
  ! no output conversion for f_n_real
  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_parser_file_stack (how, file_name_in, finished, err, open_file, &
    abort_on_open_error) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: how
  character(len=4096), target :: f_how
  character(kind=c_char), pointer :: f_how_ptr(:)
  type(c_ptr), intent(in), value :: file_name_in
  character(len=4096), target :: f_file_name_in
  character(kind=c_char), pointer :: f_file_name_in_ptr(:)
  character(len=4096), pointer :: f_file_name_in_call_ptr
  type(c_ptr), intent(in), value :: finished  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_finished
  logical, target :: f_finished_native
  logical, pointer :: f_finished_native_ptr
  logical(c_bool), pointer :: f_finished_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err
  logical, target :: f_err_native
  logical, pointer :: f_err_native_ptr
  logical(c_bool), pointer :: f_err_ptr
  type(c_ptr), intent(in), value :: open_file  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_open_file
  logical, target :: f_open_file_native
  logical, pointer :: f_open_file_native_ptr
  logical(c_bool), pointer :: f_open_file_ptr
  type(c_ptr), intent(in), value :: abort_on_open_error  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_abort_on_open_error
  logical, target :: f_abort_on_open_error_native
  logical, pointer :: f_abort_on_open_error_native_ptr
  logical(c_bool), pointer :: f_abort_on_open_error_ptr
  ! ** End of parameters **
  ! inout: f_how 0D_NOT_character
  if (.not. c_associated(how)) return
  call c_f_pointer(how, f_how_ptr, [huge(0)])
  call to_f_str(f_how_ptr, f_how)
  ! inout: f_file_name_in 0D_NOT_character
  if (c_associated(file_name_in)) then
    call c_f_pointer(file_name_in, f_file_name_in_ptr, [huge(0)])
    call to_f_str(f_file_name_in_ptr, f_file_name_in)
    f_file_name_in_call_ptr => f_file_name_in
  else
    f_file_name_in_call_ptr => null()
  endif
  ! inout: f_finished 0D_NOT_logical
  if (c_associated(finished)) then
    call c_f_pointer(finished, f_finished_ptr)
    f_finished_native = f_finished_ptr
    f_finished_native_ptr => f_finished_native
  else
    f_finished_native_ptr => null()
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_native = f_err_ptr
    f_err_native_ptr => f_err_native
  else
    f_err_native_ptr => null()
  endif
  ! inout: f_open_file 0D_NOT_logical
  if (c_associated(open_file)) then
    call c_f_pointer(open_file, f_open_file_ptr)
    f_open_file_native = f_open_file_ptr
    f_open_file_native_ptr => f_open_file_native
  else
    f_open_file_native_ptr => null()
  endif
  ! inout: f_abort_on_open_error 0D_NOT_logical
  if (c_associated(abort_on_open_error)) then
    call c_f_pointer(abort_on_open_error, f_abort_on_open_error_ptr)
    f_abort_on_open_error_native = f_abort_on_open_error_ptr
    f_abort_on_open_error_native_ptr => f_abort_on_open_error_native
  else
    f_abort_on_open_error_native_ptr => null()
  endif
  call parser_file_stack(how=f_how, file_name_in=f_file_name_in_call_ptr, &
      finished=f_finished_native_ptr, err=f_err_native_ptr, open_file=f_open_file_native_ptr, &
      abort_on_open_error=f_abort_on_open_error_native_ptr)

  ! inout: f_how 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_file_name_in 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_finished 0D_NOT_logical
  if (c_associated(finished)) then
    call c_f_pointer(finished, f_finished_ptr)
    f_finished_ptr = f_finished_native
  else
    ! f_finished unset
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_ptr = f_err_native
  else
    ! f_err unset
  endif
  ! inout: f_open_file 0D_NOT_logical
  if (c_associated(open_file)) then
    call c_f_pointer(open_file, f_open_file_ptr)
    f_open_file_ptr = f_open_file_native
  else
    ! f_open_file unset
  endif
  ! inout: f_abort_on_open_error 0D_NOT_logical
  if (c_associated(abort_on_open_error)) then
    call c_f_pointer(abort_on_open_error, f_abort_on_open_error_ptr)
    f_abort_on_open_error_ptr = f_abort_on_open_error_native
  else
    ! f_abort_on_open_error unset
  endif
end subroutine
subroutine fortran_parser_get_integer (int_val, word, ix_word, delim, delim_found, err, str1, &
    str2) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: int_val  ! 0D_NOT_integer
  integer(c_int) :: f_int_val
  integer(c_int), pointer :: f_int_val_ptr
  type(c_ptr), intent(in), value :: word
  character(len=4096), target :: f_word
  character(kind=c_char), pointer :: f_word_ptr(:)
  type(c_ptr), intent(in), value :: ix_word  ! 0D_NOT_integer
  integer(c_int) :: f_ix_word
  integer(c_int), pointer :: f_ix_word_ptr
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err
  logical, target :: f_err_native
  logical, pointer :: f_err_native_ptr
  logical(c_bool), pointer :: f_err_ptr
  type(c_ptr), intent(in), value :: str1
  character(len=4096), target :: f_str1
  character(kind=c_char), pointer :: f_str1_ptr(:)
  character(len=4096), pointer :: f_str1_call_ptr
  type(c_ptr), intent(in), value :: str2
  character(len=4096), target :: f_str2
  character(kind=c_char), pointer :: f_str2_ptr(:)
  character(len=4096), pointer :: f_str2_call_ptr
  ! ** End of parameters **
  ! inout: f_int_val 0D_NOT_integer
  if (c_associated(int_val)) then
    call c_f_pointer(int_val, f_int_val_ptr)
  else
    f_int_val_ptr => null()
  endif
  ! inout: f_word 0D_NOT_character
  if (.not. c_associated(word)) return
  call c_f_pointer(word, f_word_ptr, [huge(0)])
  call to_f_str(f_word_ptr, f_word)
  ! inout: f_ix_word 0D_NOT_integer
  if (c_associated(ix_word)) then
    call c_f_pointer(ix_word, f_ix_word_ptr)
  else
    f_ix_word_ptr => null()
  endif
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_native = f_err_ptr
    f_err_native_ptr => f_err_native
  else
    f_err_native_ptr => null()
  endif
  ! inout: f_str1 0D_NOT_character
  if (c_associated(str1)) then
    call c_f_pointer(str1, f_str1_ptr, [huge(0)])
    call to_f_str(f_str1_ptr, f_str1)
    f_str1_call_ptr => f_str1
  else
    f_str1_call_ptr => null()
  endif
  ! inout: f_str2 0D_NOT_character
  if (c_associated(str2)) then
    call c_f_pointer(str2, f_str2_ptr, [huge(0)])
    call to_f_str(f_str2_ptr, f_str2)
    f_str2_call_ptr => f_str2
  else
    f_str2_call_ptr => null()
  endif
  call parser_get_integer(int_val=f_int_val_ptr, word=f_word, ix_word=f_ix_word_ptr, &
      delim=f_delim, delim_found=f_delim_found_native_ptr, err=f_err_native_ptr, &
      str1=f_str1_call_ptr, str2=f_str2_call_ptr)

  ! inout: f_int_val 0D_NOT_integer
  ! no output conversion for f_int_val
  ! inout: f_word 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_ix_word 0D_NOT_integer
  ! no output conversion for f_ix_word
  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_ptr = f_err_native
  else
    ! f_err unset
  endif
  ! inout: f_str1 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_str2 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
end subroutine
subroutine fortran_parser_get_logical (attrib_name, this_logic, ele_name, delim, delim_found, &
    err) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), intent(in), value :: this_logic  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_this_logic
  logical, target :: f_this_logic_native
  logical, pointer :: f_this_logic_native_ptr
  logical(c_bool), pointer :: f_this_logic_ptr
  type(c_ptr), intent(in), value :: ele_name
  character(len=4096), target :: f_ele_name
  character(kind=c_char), pointer :: f_ele_name_ptr(:)
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err
  logical, target :: f_err_native
  logical, pointer :: f_err_native_ptr
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! inout: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! inout: f_this_logic 0D_NOT_logical
  if (c_associated(this_logic)) then
    call c_f_pointer(this_logic, f_this_logic_ptr)
    f_this_logic_native = f_this_logic_ptr
    f_this_logic_native_ptr => f_this_logic_native
  else
    f_this_logic_native_ptr => null()
  endif
  ! inout: f_ele_name 0D_NOT_character
  if (.not. c_associated(ele_name)) return
  call c_f_pointer(ele_name, f_ele_name_ptr, [huge(0)])
  call to_f_str(f_ele_name_ptr, f_ele_name)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_native = f_err_ptr
    f_err_native_ptr => f_err_native
  else
    f_err_native_ptr => null()
  endif
  call parser_get_logical(attrib_name=f_attrib_name, this_logic=f_this_logic_native_ptr, &
      ele_name=f_ele_name, delim=f_delim, delim_found=f_delim_found_native_ptr, &
      err=f_err_native_ptr)

  ! inout: f_attrib_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_this_logic 0D_NOT_logical
  if (c_associated(this_logic)) then
    call c_f_pointer(this_logic, f_this_logic_ptr)
    f_this_logic_ptr = f_this_logic_native
  else
    ! f_this_logic unset
  endif
  ! inout: f_ele_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_ptr = f_err_native
  else
    ! f_err unset
  endif
end subroutine
subroutine fortran_parser_identify_fork_to_element (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call parser_identify_fork_to_element(lat=f_lat)

end subroutine
subroutine fortran_parser_init_custom_elements (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call parser_init_custom_elements(lat=f_lat)

end subroutine
subroutine fortran_parser_print_line (lat, end_of_file) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: end_of_file  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_end_of_file
  logical, target :: f_end_of_file_native
  logical, pointer :: f_end_of_file_native_ptr
  logical(c_bool), pointer :: f_end_of_file_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_end_of_file 0D_NOT_logical
  if (c_associated(end_of_file)) then
    call c_f_pointer(end_of_file, f_end_of_file_ptr)
    f_end_of_file_native = f_end_of_file_ptr
    f_end_of_file_native_ptr => f_end_of_file_native
  else
    f_end_of_file_native_ptr => null()
  endif
  call parser_print_line(lat=f_lat, end_of_file=f_end_of_file_native_ptr)

  ! inout: f_end_of_file 0D_NOT_logical
  if (c_associated(end_of_file)) then
    call c_f_pointer(end_of_file, f_end_of_file_ptr)
    f_end_of_file_ptr = f_end_of_file_native
  else
    ! f_end_of_file unset
  endif
end subroutine
subroutine fortran_parser_read_lr_wake (ele, delim, delim_found, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parser_read_lr_wake(ele=f_ele, delim=f_delim, delim_found=f_delim_found_native_ptr, &
      err_flag=f_err_flag_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parser_read_old_format_lr_wake (ele, lr_file_name) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: lr_file_name
  character(len=4096), target :: f_lr_file_name
  character(kind=c_char), pointer :: f_lr_file_name_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_lr_file_name 0D_NOT_character
  if (.not. c_associated(lr_file_name)) return
  call c_f_pointer(lr_file_name, f_lr_file_name_ptr, [huge(0)])
  call to_f_str(f_lr_file_name_ptr, f_lr_file_name)
  call parser_read_old_format_lr_wake(ele=f_ele, lr_file_name=f_lr_file_name)

end subroutine
subroutine fortran_parser_read_old_format_sr_wake (ele, sr_file_name) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: sr_file_name
  character(len=4096), target :: f_sr_file_name
  character(kind=c_char), pointer :: f_sr_file_name_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_sr_file_name 0D_NOT_character
  if (.not. c_associated(sr_file_name)) return
  call c_f_pointer(sr_file_name, f_sr_file_name_ptr, [huge(0)])
  call to_f_str(f_sr_file_name_ptr, f_sr_file_name)
  call parser_read_old_format_sr_wake(ele=f_ele, sr_file_name=f_sr_file_name)

end subroutine
subroutine fortran_parser_read_sr_wake (ele, delim, delim_found, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: delim
  character(len=4096), target :: f_delim
  character(kind=c_char), pointer :: f_delim_ptr(:)
  type(c_ptr), intent(in), value :: delim_found  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_delim_found
  logical, target :: f_delim_found_native
  logical, pointer :: f_delim_found_native_ptr
  logical(c_bool), pointer :: f_delim_found_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_delim 0D_NOT_character
  if (.not. c_associated(delim)) return
  call c_f_pointer(delim, f_delim_ptr, [huge(0)])
  call to_f_str(f_delim_ptr, f_delim)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_native = f_delim_found_ptr
    f_delim_found_native_ptr => f_delim_found_native
  else
    f_delim_found_native_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call parser_read_sr_wake(ele=f_ele, delim=f_delim, delim_found=f_delim_found_native_ptr, &
      err_flag=f_err_flag_native_ptr)

  ! inout: f_delim 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_delim_found 0D_NOT_logical
  if (c_associated(delim_found)) then
    call c_f_pointer(delim_found, f_delim_found_ptr)
    f_delim_found_ptr = f_delim_found_native
  else
    ! f_delim_found unset
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_parser_transfer_control_struct (con_in, con_out, lord, ix_var) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: con_in  ! 0D_NOT_type
  type(control_struct), pointer :: f_con_in
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  integer(c_int) :: ix_var  ! 0D_NOT_integer
  integer :: f_ix_var
  ! ** Out parameters **
  type(c_ptr), value :: con_out  ! 0D_NOT_type
  type(control_struct), pointer :: f_con_out
  ! ** End of parameters **
  ! in: f_con_in 0D_NOT_type
  if (.not. c_associated(con_in)) return
  call c_f_pointer(con_in, f_con_in)
  ! out: f_con_out 0D_NOT_type
  if (.not. c_associated(con_out)) return
  call c_f_pointer(con_out, f_con_out)
  ! in: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  ! in: f_ix_var 0D_NOT_integer
  f_ix_var = ix_var
  call parser_transfer_control_struct(con_in=f_con_in, con_out=f_con_out, lord=f_lord, &
      ix_var=f_ix_var)

  ! out: f_con_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_particle_in_global_frame (orb, branch, in_time_coordinates, in_body_frame, &
    w_mat_out, particle) bind(c)

  use bmad_struct, only: branch_struct, coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), intent(in), value :: in_time_coordinates  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_in_time_coordinates
  logical, target :: f_in_time_coordinates_native
  logical, pointer :: f_in_time_coordinates_native_ptr
  logical(c_bool), pointer :: f_in_time_coordinates_ptr
  type(c_ptr), intent(in), value :: in_body_frame  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_in_body_frame
  logical, target :: f_in_body_frame_native
  logical, pointer :: f_in_body_frame_native_ptr
  logical(c_bool), pointer :: f_in_body_frame_ptr
  ! ** Out parameters **
  type(c_ptr), value :: particle  ! 0D_NOT_type
  type(coord_struct), pointer :: f_particle
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: w_mat_out
  real(rp) :: f_w_mat_out(3,3)
  real(c_double), pointer :: f_w_mat_out_ptr(:)
  ! ** End of parameters **
  ! in: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_in_time_coordinates 0D_NOT_logical
  if (c_associated(in_time_coordinates)) then
    call c_f_pointer(in_time_coordinates, f_in_time_coordinates_ptr)
    f_in_time_coordinates_native = f_in_time_coordinates_ptr
    f_in_time_coordinates_native_ptr => f_in_time_coordinates_native
  else
    f_in_time_coordinates_native_ptr => null()
  endif
  ! in: f_in_body_frame 0D_NOT_logical
  if (c_associated(in_body_frame)) then
    call c_f_pointer(in_body_frame, f_in_body_frame_ptr)
    f_in_body_frame_native = f_in_body_frame_ptr
    f_in_body_frame_native_ptr => f_in_body_frame_native
  else
    f_in_body_frame_native_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(w_mat_out)) then
    call c_f_pointer(w_mat_out, f_w_mat_out_ptr, [3*3])
    call vec2mat(f_w_mat_out_ptr, f_w_mat_out)
  else
    f_w_mat_out_ptr => null()
  endif
  f_particle = particle_in_global_frame(orb=f_orb, branch=f_branch, &
      in_time_coordinates=f_in_time_coordinates_native_ptr, &
      in_body_frame=f_in_body_frame_native_ptr, w_mat_out=f_w_mat_out)

  ! out: f_particle 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_particle_is_moving_backwards (orbit, is_moving_backwards) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_moving_backwards  ! 0D_NOT_logical
  logical :: f_is_moving_backwards
  logical(c_bool), pointer :: f_is_moving_backwards_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  f_is_moving_backwards = particle_is_moving_backwards(orbit=f_orbit)

  ! out: f_is_moving_backwards 0D_NOT_logical
  call c_f_pointer(is_moving_backwards, f_is_moving_backwards_ptr)
  f_is_moving_backwards_ptr = f_is_moving_backwards
end subroutine
subroutine fortran_particle_is_moving_forward (orbit, dir, is_moving_forward) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: dir  ! 0D_NOT_integer
  integer(c_int) :: f_dir
  integer(c_int), pointer :: f_dir_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_moving_forward  ! 0D_NOT_logical
  logical :: f_is_moving_forward
  logical(c_bool), pointer :: f_is_moving_forward_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_dir 0D_NOT_integer
  if (c_associated(dir)) then
    call c_f_pointer(dir, f_dir_ptr)
  else
    f_dir_ptr => null()
  endif
  f_is_moving_forward = particle_is_moving_forward(orbit=f_orbit, dir=f_dir_ptr)

  ! out: f_is_moving_forward 0D_NOT_logical
  call c_f_pointer(is_moving_forward, f_is_moving_forward_ptr)
  f_is_moving_forward_ptr = f_is_moving_forward
end subroutine
subroutine fortran_particle_rf_time (orbit, ele, reference_active_edge, s_rel, time_coords, &
    rf_freq, abs_time, time) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: reference_active_edge  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_reference_active_edge
  logical, target :: f_reference_active_edge_native
  logical, pointer :: f_reference_active_edge_native_ptr
  logical(c_bool), pointer :: f_reference_active_edge_ptr
  type(c_ptr), intent(in), value :: s_rel  ! 0D_NOT_real
  real(c_double) :: f_s_rel
  real(c_double), pointer :: f_s_rel_ptr
  type(c_ptr), intent(in), value :: time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_time_coords
  logical, target :: f_time_coords_native
  logical, pointer :: f_time_coords_native_ptr
  logical(c_bool), pointer :: f_time_coords_ptr
  type(c_ptr), intent(in), value :: rf_freq  ! 0D_NOT_real
  real(c_double) :: f_rf_freq
  real(c_double), pointer :: f_rf_freq_ptr
  type(c_ptr), intent(in), value :: abs_time  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_abs_time
  logical, target :: f_abs_time_native
  logical, pointer :: f_abs_time_native_ptr
  logical(c_bool), pointer :: f_abs_time_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: time  ! 0D_NOT_real16
  real(qp) :: f_time
  real(c_long_double), pointer :: f_time_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_reference_active_edge 0D_NOT_logical
  if (c_associated(reference_active_edge)) then
    call c_f_pointer(reference_active_edge, f_reference_active_edge_ptr)
    f_reference_active_edge_native = f_reference_active_edge_ptr
    f_reference_active_edge_native_ptr => f_reference_active_edge_native
  else
    f_reference_active_edge_native_ptr => null()
  endif
  ! in: f_s_rel 0D_NOT_real
  if (c_associated(s_rel)) then
    call c_f_pointer(s_rel, f_s_rel_ptr)
  else
    f_s_rel_ptr => null()
  endif
  ! in: f_time_coords 0D_NOT_logical
  if (c_associated(time_coords)) then
    call c_f_pointer(time_coords, f_time_coords_ptr)
    f_time_coords_native = f_time_coords_ptr
    f_time_coords_native_ptr => f_time_coords_native
  else
    f_time_coords_native_ptr => null()
  endif
  ! in: f_rf_freq 0D_NOT_real
  if (c_associated(rf_freq)) then
    call c_f_pointer(rf_freq, f_rf_freq_ptr)
  else
    f_rf_freq_ptr => null()
  endif
  ! in: f_abs_time 0D_NOT_logical
  if (c_associated(abs_time)) then
    call c_f_pointer(abs_time, f_abs_time_ptr)
    f_abs_time_native = f_abs_time_ptr
    f_abs_time_native_ptr => f_abs_time_native
  else
    f_abs_time_native_ptr => null()
  endif
  f_time = particle_rf_time(orbit=f_orbit, ele=f_ele, &
      reference_active_edge=f_reference_active_edge_native_ptr, s_rel=f_s_rel_ptr, &
      time_coords=f_time_coords_native_ptr, rf_freq=f_rf_freq_ptr, &
      abs_time=f_abs_time_native_ptr)

  ! out: f_time 0D_NOT_real16
  call c_f_pointer(time, f_time_ptr)
  f_time_ptr = f_time
end subroutine
subroutine fortran_patch_flips_propagation_direction (x_pitch, y_pitch, is_flip) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: x_pitch  ! 0D_NOT_real
  real(rp) :: f_x_pitch
  real(c_double) :: y_pitch  ! 0D_NOT_real
  real(rp) :: f_y_pitch
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_flip  ! 0D_NOT_logical
  logical :: f_is_flip
  logical(c_bool), pointer :: f_is_flip_ptr
  ! ** End of parameters **
  ! in: f_x_pitch 0D_NOT_real
  f_x_pitch = x_pitch
  ! in: f_y_pitch 0D_NOT_real
  f_y_pitch = y_pitch
  f_is_flip = patch_flips_propagation_direction(x_pitch=f_x_pitch, y_pitch=f_y_pitch)

  ! out: f_is_flip 0D_NOT_logical
  call c_f_pointer(is_flip, f_is_flip_ptr)
  f_is_flip_ptr = f_is_flip
end subroutine
subroutine fortran_patch_length (patch, ref_coords, length) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: patch  ! 0D_NOT_type
  type(ele_struct), pointer :: f_patch
  type(c_ptr), intent(in), value :: ref_coords  ! 0D_NOT_integer
  integer(c_int) :: f_ref_coords
  integer(c_int), pointer :: f_ref_coords_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: length  ! 0D_NOT_real
  real(rp) :: f_length
  real(c_double), pointer :: f_length_ptr
  ! ** End of parameters **
  ! in: f_patch 0D_NOT_type
  if (.not. c_associated(patch)) return
  call c_f_pointer(patch, f_patch)
  ! in: f_ref_coords 0D_NOT_integer
  if (c_associated(ref_coords)) then
    call c_f_pointer(ref_coords, f_ref_coords_ptr)
  else
    f_ref_coords_ptr => null()
  endif
  f_length = patch_length(patch=f_patch, ref_coords=f_ref_coords_ptr)

  ! out: f_length 0D_NOT_real
  call c_f_pointer(length, f_length_ptr)
  f_length_ptr = f_length
end subroutine
subroutine fortran_photon_absorption_and_phase_shift (material, Energy, absorption, &
    phase_shift, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: material
  character(len=4096), target :: f_material
  character(kind=c_char), pointer :: f_material_ptr(:)
  real(c_double) :: Energy  ! 0D_NOT_real
  real(rp) :: f_Energy
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: absorption  ! 0D_NOT_real
  real(rp) :: f_absorption
  real(c_double), pointer :: f_absorption_ptr
  type(c_ptr), intent(in), value :: phase_shift  ! 0D_NOT_real
  real(rp) :: f_phase_shift
  real(c_double), pointer :: f_phase_shift_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_material 0D_NOT_character
  if (.not. c_associated(material)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(material, f_material_ptr, [huge(0)])
  call to_f_str(f_material_ptr, f_material)
  ! in: f_Energy 0D_NOT_real
  f_Energy = Energy
  call photon_absorption_and_phase_shift(material=f_material, Energy=f_Energy, &
      absorption=f_absorption, phase_shift=f_phase_shift, err_flag=f_err_flag)

  ! out: f_absorption 0D_NOT_real
  call c_f_pointer(absorption, f_absorption_ptr)
  f_absorption_ptr = f_absorption
  ! out: f_phase_shift 0D_NOT_real
  call c_f_pointer(phase_shift, f_phase_shift_ptr)
  f_phase_shift_ptr = f_phase_shift
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_photon_add_to_detector_statistics (orbit0, orbit, ele, ix_pt, iy_pt, &
    pixel_pt) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, pixel_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit0
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: pixel_pt  ! 0D_NOT_type
  type(pixel_pt_struct), pointer :: f_pixel_pt
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: ix_pt  ! 0D_NOT_integer
  integer(c_int) :: f_ix_pt
  integer(c_int), pointer :: f_ix_pt_ptr
  type(c_ptr), intent(in), value :: iy_pt  ! 0D_NOT_integer
  integer(c_int) :: f_iy_pt
  integer(c_int), pointer :: f_iy_pt_ptr
  ! ** End of parameters **
  ! in: f_orbit0 0D_NOT_type
  if (.not. c_associated(orbit0)) return
  call c_f_pointer(orbit0, f_orbit0)
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_ix_pt 0D_NOT_integer
  if (c_associated(ix_pt)) then
    call c_f_pointer(ix_pt, f_ix_pt_ptr)
  else
    f_ix_pt_ptr => null()
  endif
  ! inout: f_iy_pt 0D_NOT_integer
  if (c_associated(iy_pt)) then
    call c_f_pointer(iy_pt, f_iy_pt_ptr)
  else
    f_iy_pt_ptr => null()
  endif
  ! in: f_pixel_pt 0D_NOT_type
  if (c_associated(pixel_pt))   call c_f_pointer(pixel_pt, f_pixel_pt)
  call photon_add_to_detector_statistics(orbit0=f_orbit0, orbit=f_orbit, ele=f_ele, &
      ix_pt=f_ix_pt_ptr, iy_pt=f_iy_pt_ptr, pixel_pt=f_pixel_pt)

  ! inout: f_ix_pt 0D_NOT_integer
  ! no output conversion for f_ix_pt
  ! inout: f_iy_pt 0D_NOT_integer
  ! no output conversion for f_iy_pt
end subroutine
subroutine fortran_photon_reflection (graze_angle_in, energy, surface, graze_angle_out, &
    phi_out) bind(c)

  use bmad_struct, only: photon_reflect_surface_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: graze_angle_in  ! 0D_NOT_real
  real(rp) :: f_graze_angle_in
  real(c_double) :: energy  ! 0D_NOT_real
  real(rp) :: f_energy
  type(c_ptr), value :: surface  ! 0D_NOT_type
  type(photon_reflect_surface_struct), pointer :: f_surface
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: graze_angle_out  ! 0D_NOT_real
  real(rp) :: f_graze_angle_out
  real(c_double), pointer :: f_graze_angle_out_ptr
  type(c_ptr), intent(in), value :: phi_out  ! 0D_NOT_real
  real(rp) :: f_phi_out
  real(c_double), pointer :: f_phi_out_ptr
  ! ** End of parameters **
  ! in: f_graze_angle_in 0D_NOT_real
  f_graze_angle_in = graze_angle_in
  ! in: f_energy 0D_NOT_real
  f_energy = energy
  ! in: f_surface 0D_NOT_type
  if (.not. c_associated(surface)) return
  call c_f_pointer(surface, f_surface)
  call photon_reflection(graze_angle_in=f_graze_angle_in, energy=f_energy, surface=f_surface, &
      graze_angle_out=f_graze_angle_out, phi_out=f_phi_out)

  ! out: f_graze_angle_out 0D_NOT_real
  call c_f_pointer(graze_angle_out, f_graze_angle_out_ptr)
  f_graze_angle_out_ptr = f_graze_angle_out
  ! out: f_phi_out 0D_NOT_real
  call c_f_pointer(phi_out, f_phi_out_ptr)
  f_phi_out_ptr = f_phi_out
end subroutine
subroutine fortran_photon_reflection_std_surface_init (surface) bind(c)

  use bmad_struct, only: photon_reflect_surface_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: surface  ! 0D_NOT_type
  type(photon_reflect_surface_struct), pointer :: f_surface
  ! ** End of parameters **
  ! out: f_surface 0D_NOT_type
  if (.not. c_associated(surface)) return
  call c_f_pointer(surface, f_surface)
  call photon_reflection_std_surface_init(surface=f_surface)

  ! out: f_surface 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_photon_reflectivity (angle, energy, surface, p_reflect, rel_p_specular) &
    bind(c)

  use bmad_struct, only: photon_reflect_surface_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: angle  ! 0D_NOT_real
  real(rp) :: f_angle
  real(c_double) :: energy  ! 0D_NOT_real
  real(rp) :: f_energy
  type(c_ptr), value :: surface  ! 0D_NOT_type
  type(photon_reflect_surface_struct), pointer :: f_surface
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: p_reflect  ! 0D_NOT_real
  real(rp) :: f_p_reflect
  real(c_double), pointer :: f_p_reflect_ptr
  type(c_ptr), intent(in), value :: rel_p_specular  ! 0D_NOT_real
  real(rp) :: f_rel_p_specular
  real(c_double), pointer :: f_rel_p_specular_ptr
  ! ** End of parameters **
  ! in: f_angle 0D_NOT_real
  f_angle = angle
  ! in: f_energy 0D_NOT_real
  f_energy = energy
  ! in: f_surface 0D_NOT_type
  if (.not. c_associated(surface)) return
  call c_f_pointer(surface, f_surface)
  call photon_reflectivity(angle=f_angle, energy=f_energy, surface=f_surface, &
      p_reflect=f_p_reflect, rel_p_specular=f_rel_p_specular)

  ! out: f_p_reflect 0D_NOT_real
  call c_f_pointer(p_reflect, f_p_reflect_ptr)
  f_p_reflect_ptr = f_p_reflect
  ! out: f_rel_p_specular 0D_NOT_real
  call c_f_pointer(rel_p_specular, f_rel_p_specular_ptr)
  f_rel_p_specular_ptr = f_rel_p_specular
end subroutine
subroutine fortran_photon_target_corner_calc (aperture_ele, x_lim, y_lim, z_lim, source_ele, &
    corner) bind(c)

  use bmad_struct, only: ele_struct, target_point_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: aperture_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_aperture_ele
  type(c_ptr), value :: source_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_source_ele
  ! ** Out parameters **
  type(c_ptr), value :: corner  ! 0D_NOT_type
  type(target_point_struct), pointer :: f_corner
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x_lim  ! 0D_NOT_real
  real(c_double) :: f_x_lim
  real(c_double), pointer :: f_x_lim_ptr
  type(c_ptr), intent(in), value :: y_lim  ! 0D_NOT_real
  real(c_double) :: f_y_lim
  real(c_double), pointer :: f_y_lim_ptr
  type(c_ptr), intent(in), value :: z_lim  ! 0D_NOT_real
  real(c_double) :: f_z_lim
  real(c_double), pointer :: f_z_lim_ptr
  ! ** End of parameters **
  ! in: f_aperture_ele 0D_NOT_type
  if (.not. c_associated(aperture_ele)) return
  call c_f_pointer(aperture_ele, f_aperture_ele)
  ! inout: f_x_lim 0D_NOT_real
  if (c_associated(x_lim)) then
    call c_f_pointer(x_lim, f_x_lim_ptr)
  else
    f_x_lim_ptr => null()
  endif
  ! inout: f_y_lim 0D_NOT_real
  if (c_associated(y_lim)) then
    call c_f_pointer(y_lim, f_y_lim_ptr)
  else
    f_y_lim_ptr => null()
  endif
  ! inout: f_z_lim 0D_NOT_real
  if (c_associated(z_lim)) then
    call c_f_pointer(z_lim, f_z_lim_ptr)
  else
    f_z_lim_ptr => null()
  endif
  ! in: f_source_ele 0D_NOT_type
  if (.not. c_associated(source_ele)) return
  call c_f_pointer(source_ele, f_source_ele)
  ! out: f_corner 0D_NOT_type
  if (.not. c_associated(corner)) return
  call c_f_pointer(corner, f_corner)
  call photon_target_corner_calc(aperture_ele=f_aperture_ele, x_lim=f_x_lim_ptr, &
      y_lim=f_y_lim_ptr, z_lim=f_z_lim_ptr, source_ele=f_source_ele, corner=f_corner)

  ! inout: f_x_lim 0D_NOT_real
  ! no output conversion for f_x_lim
  ! inout: f_y_lim 0D_NOT_real
  ! no output conversion for f_y_lim
  ! inout: f_z_lim 0D_NOT_real
  ! no output conversion for f_z_lim
  ! out: f_corner 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_photon_target_setup (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call photon_target_setup(ele=f_ele)

end subroutine
subroutine fortran_photon_type (ele, e_type) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: e_type  ! 0D_NOT_integer
  integer :: f_e_type
  integer(c_int), pointer :: f_e_type_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_e_type = photon_type(ele=f_ele)

  ! out: f_e_type 0D_NOT_integer
  call c_f_pointer(e_type, f_e_type_ptr)
  f_e_type_ptr = f_e_type
end subroutine
subroutine fortran_physical_ele_end (track_end, orbit, ele_orientation, return_stream_end, &
    physical_end) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: track_end  ! 0D_NOT_integer
  integer :: f_track_end
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  integer(c_int) :: ele_orientation  ! 0D_NOT_integer
  integer :: f_ele_orientation
  type(c_ptr), intent(in), value :: return_stream_end  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_return_stream_end
  logical, target :: f_return_stream_end_native
  logical, pointer :: f_return_stream_end_native_ptr
  logical(c_bool), pointer :: f_return_stream_end_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: physical_end  ! 0D_NOT_integer
  integer :: f_physical_end
  integer(c_int), pointer :: f_physical_end_ptr
  ! ** End of parameters **
  ! in: f_track_end 0D_NOT_integer
  f_track_end = track_end
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele_orientation 0D_NOT_integer
  f_ele_orientation = ele_orientation
  ! in: f_return_stream_end 0D_NOT_logical
  if (c_associated(return_stream_end)) then
    call c_f_pointer(return_stream_end, f_return_stream_end_ptr)
    f_return_stream_end_native = f_return_stream_end_ptr
    f_return_stream_end_native_ptr => f_return_stream_end_native
  else
    f_return_stream_end_native_ptr => null()
  endif
  f_physical_end = physical_ele_end(track_end=f_track_end, orbit=f_orbit, &
      ele_orientation=f_ele_orientation, return_stream_end=f_return_stream_end_native_ptr)

  ! out: f_physical_end 0D_NOT_integer
  call c_f_pointer(physical_end, f_physical_end_ptr)
  f_physical_end_ptr = f_physical_end
end subroutine
subroutine fortran_point_photon_emission (ele, param, orbit, direction, max_target_area, &
    w_to_surface) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: direction  ! 0D_NOT_integer
  integer :: f_direction
  real(c_double) :: max_target_area  ! 0D_NOT_real
  real(rp) :: f_max_target_area
  type(c_ptr), intent(in), value :: w_to_surface
  real(rp) :: f_w_to_surface(3,3)
  real(c_double), pointer :: f_w_to_surface_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_direction 0D_NOT_integer
  f_direction = direction
  ! in: f_max_target_area 0D_NOT_real
  f_max_target_area = max_target_area
  !! general array (2D_NOT_real)
  if (c_associated(w_to_surface)) then
    call c_f_pointer(w_to_surface, f_w_to_surface_ptr, [3*3])
    call vec2mat(f_w_to_surface_ptr, f_w_to_surface)
  else
    f_w_to_surface_ptr => null()
  endif
  call point_photon_emission(ele=f_ele, param=f_param, orbit=f_orbit, direction=f_direction, &
      max_target_area=f_max_target_area, w_to_surface=f_w_to_surface)

end subroutine
subroutine fortran_pointer_to_branch_given_ele (ele, branch_ptr) bind(c)

  use bmad_struct, only: branch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: branch_ptr  ! 0D_PTR_type
  type(branch_struct), pointer :: f_branch_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_branch_ptr = pointer_to_branch_given_ele(ele=f_ele)

  ! out: f_branch_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_branch_given_name (branch_name, lat, parameter_is_branch0, &
    blank_branch, branch_ptr) bind(c)

  use bmad_struct, only: branch_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: branch_name
  character(len=4096), target :: f_branch_name
  character(kind=c_char), pointer :: f_branch_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: parameter_is_branch0  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_parameter_is_branch0
  logical, target :: f_parameter_is_branch0_native
  logical, pointer :: f_parameter_is_branch0_native_ptr
  logical(c_bool), pointer :: f_parameter_is_branch0_ptr
  type(c_ptr), intent(in), value :: blank_branch  ! 0D_NOT_integer
  integer(c_int) :: f_blank_branch
  integer(c_int), pointer :: f_blank_branch_ptr
  ! ** Out parameters **
  type(c_ptr), value :: branch_ptr  ! 0D_PTR_type
  type(branch_struct), pointer :: f_branch_ptr
  ! ** End of parameters **
  ! in: f_branch_name 0D_NOT_character
  if (.not. c_associated(branch_name)) return
  call c_f_pointer(branch_name, f_branch_name_ptr, [huge(0)])
  call to_f_str(f_branch_name_ptr, f_branch_name)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_parameter_is_branch0 0D_NOT_logical
  if (c_associated(parameter_is_branch0)) then
    call c_f_pointer(parameter_is_branch0, f_parameter_is_branch0_ptr)
    f_parameter_is_branch0_native = f_parameter_is_branch0_ptr
    f_parameter_is_branch0_native_ptr => f_parameter_is_branch0_native
  else
    f_parameter_is_branch0_native_ptr => null()
  endif
  ! in: f_blank_branch 0D_NOT_integer
  if (c_associated(blank_branch)) then
    call c_f_pointer(blank_branch, f_blank_branch_ptr)
  else
    f_blank_branch_ptr => null()
  endif
  f_branch_ptr = pointer_to_branch_given_name(branch_name=f_branch_name, lat=f_lat, &
      parameter_is_branch0=f_parameter_is_branch0_native_ptr, blank_branch=f_blank_branch_ptr)

  ! out: f_branch_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_ele1 (lat, ix_ele, ix_branch, ele_ptr) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix_ele  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele
  integer(c_int), pointer :: f_ix_ele_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_ix_ele 0D_NOT_integer
  if (c_associated(ix_ele)) then
    call c_f_pointer(ix_ele, f_ix_ele_ptr)
  else
    f_ix_ele_ptr => null()
  endif
  ! inout: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  f_ele_ptr = pointer_to_ele1(lat=f_lat, ix_ele=f_ix_ele_ptr, ix_branch=f_ix_branch_ptr)

  ! inout: f_ix_ele 0D_NOT_integer
  ! no output conversion for f_ix_ele
  ! inout: f_ix_branch 0D_NOT_integer
  ! no output conversion for f_ix_branch
  ! out: f_ele_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_ele2 (lat, ele_loc, ele_ptr) bind(c)

  use bmad_struct, only: ele_struct, lat_ele_loc_struct, lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: ele_loc  ! 0D_NOT_type
  type(lat_ele_loc_struct), pointer :: f_ele_loc
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_ele_loc 0D_NOT_type
  if (.not. c_associated(ele_loc)) return
  call c_f_pointer(ele_loc, f_ele_loc)
  f_ele_ptr = pointer_to_ele2(lat=f_lat, ele_loc=f_ele_loc)

  ! out: f_ele_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_ele3 (lat, ele_name, ele_ptr) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ele_name
  character(len=4096), target :: f_ele_name
  character(kind=c_char), pointer :: f_ele_name_ptr(:)
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_ele_name 0D_NOT_character
  if (.not. c_associated(ele_name)) return
  call c_f_pointer(ele_name, f_ele_name_ptr, [huge(0)])
  call to_f_str(f_ele_name_ptr, f_ele_name)
  f_ele_ptr = pointer_to_ele3(lat=f_lat, ele_name=f_ele_name)

  ! inout: f_ele_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! out: f_ele_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_ele4 (lat, foreign_ele, ele_ptr) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: foreign_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_foreign_ele
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_foreign_ele 0D_NOT_type
  if (.not. c_associated(foreign_ele)) return
  call c_f_pointer(foreign_ele, f_foreign_ele)
  f_ele_ptr = pointer_to_ele4(lat=f_lat, foreign_ele=f_foreign_ele)

  ! out: f_ele_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_element_at_s (branch, s, choose_max, err_flag, s_eff, position, &
    print_err, ele) bind(c)

  use bmad_struct, only: branch_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  real(c_double) :: s  ! 0D_NOT_real
  real(rp) :: f_s
  logical(c_bool) :: choose_max  ! 0D_NOT_logical
  logical :: f_choose_max
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: s_eff  ! 0D_NOT_real
  real(rp) :: f_s_eff
  real(c_double), pointer :: f_s_eff_ptr
  type(c_ptr), value :: position  ! 0D_NOT_type
  type(coord_struct), pointer :: f_position
  type(c_ptr), value :: ele  ! 0D_PTR_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(branch, f_branch)
  ! in: f_s 0D_NOT_real
  f_s = s
  ! in: f_choose_max 0D_NOT_logical
  f_choose_max = choose_max
  ! out: f_position 0D_NOT_type
  if (c_associated(position))   call c_f_pointer(position, f_position)
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  f_ele = pointer_to_element_at_s(branch=f_branch, s=f_s, choose_max=f_choose_max, &
      err_flag=f_err_flag, s_eff=f_s_eff, position=f_position, &
      print_err=f_print_err_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_s_eff 0D_NOT_real
  ! no output conversion for f_s_eff
  ! out: f_position 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_ele 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_field_ele (ele, ix_field_ele, dz_offset, field_ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: ix_field_ele  ! 0D_NOT_integer
  integer :: f_ix_field_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dz_offset  ! 0D_NOT_real
  real(rp) :: f_dz_offset
  real(c_double), pointer :: f_dz_offset_ptr
  type(c_ptr), value :: field_ele  ! 0D_PTR_type
  type(ele_struct), pointer :: f_field_ele
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_ix_field_ele 0D_NOT_integer
  f_ix_field_ele = ix_field_ele
  f_field_ele = pointer_to_field_ele(ele=f_ele, ix_field_ele=f_ix_field_ele, &
      dz_offset=f_dz_offset)

  ! out: f_dz_offset 0D_NOT_real
  ! no output conversion for f_dz_offset
  ! out: f_field_ele 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_girder (ele, ix_slave_back, girder) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_slave_back  ! 0D_NOT_integer
  integer :: f_ix_slave_back
  integer(c_int), pointer :: f_ix_slave_back_ptr
  type(c_ptr), value :: girder  ! 0D_PTR_type
  type(ele_struct), pointer :: f_girder
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_girder = pointer_to_girder(ele=f_ele, ix_slave_back=f_ix_slave_back)

  ! out: f_ix_slave_back 0D_NOT_integer
  ! no output conversion for f_ix_slave_back
  ! out: f_girder 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_lord (slave, ix_lord, control, ix_slave_back, lord_type, &
    ix_control, ix_ic, lord_ptr) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  integer(c_int) :: ix_lord  ! 0D_NOT_integer
  integer :: f_ix_lord
  type(c_ptr), intent(in), value :: lord_type  ! 0D_NOT_integer
  integer(c_int) :: f_lord_type
  integer(c_int), pointer :: f_lord_type_ptr
  ! ** Out parameters **
  type(c_ptr), value :: control  ! 0D_PTR_type
  type(control_struct), pointer :: f_control
  type(c_ptr), intent(in), value :: ix_slave_back  ! 0D_NOT_integer
  integer :: f_ix_slave_back
  integer(c_int), pointer :: f_ix_slave_back_ptr
  type(c_ptr), intent(in), value :: ix_control  ! 0D_NOT_integer
  integer :: f_ix_control
  integer(c_int), pointer :: f_ix_control_ptr
  type(c_ptr), intent(in), value :: ix_ic  ! 0D_NOT_integer
  integer :: f_ix_ic
  integer(c_int), pointer :: f_ix_ic_ptr
  type(c_ptr), value :: lord_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_lord_ptr
  ! ** End of parameters **
  ! in: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! in: f_ix_lord 0D_NOT_integer
  f_ix_lord = ix_lord
  ! out: f_control 0D_PTR_type
  if (c_associated(control))   call c_f_pointer(control, f_control)
  ! in: f_lord_type 0D_NOT_integer
  if (c_associated(lord_type)) then
    call c_f_pointer(lord_type, f_lord_type_ptr)
  else
    f_lord_type_ptr => null()
  endif
  f_lord_ptr = pointer_to_lord(slave=f_slave, ix_lord=f_ix_lord, control=f_control, &
      ix_slave_back=f_ix_slave_back, lord_type=f_lord_type_ptr, ix_control=f_ix_control, &
      ix_ic=f_ix_ic)

  ! out: f_control 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_ix_slave_back 0D_NOT_integer
  ! no output conversion for f_ix_slave_back
  ! out: f_ix_control 0D_NOT_integer
  ! no output conversion for f_ix_control
  ! out: f_ix_ic 0D_NOT_integer
  ! no output conversion for f_ix_ic
  ! out: f_lord_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_multipass_lord (ele, ix_pass, super_lord, multi_lord) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_pass  ! 0D_NOT_integer
  integer :: f_ix_pass
  integer(c_int), pointer :: f_ix_pass_ptr
  type(c_ptr), value :: super_lord  ! 0D_PTR_type
  type(ele_struct), pointer :: f_super_lord
  type(c_ptr), value :: multi_lord  ! 0D_PTR_type
  type(ele_struct), pointer :: f_multi_lord
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_super_lord 0D_PTR_type
  if (c_associated(super_lord))   call c_f_pointer(super_lord, f_super_lord)
  f_multi_lord = pointer_to_multipass_lord(ele=f_ele, ix_pass=f_ix_pass, &
      super_lord=f_super_lord)

  ! out: f_ix_pass 0D_NOT_integer
  ! no output conversion for f_ix_pass
  ! out: f_super_lord 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_multi_lord 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_next_ele (this_ele, offset, skip_beginning, follow_fork, &
    next_ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: this_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_this_ele
  type(c_ptr), intent(in), value :: offset  ! 0D_NOT_integer
  integer(c_int) :: f_offset
  integer(c_int), pointer :: f_offset_ptr
  type(c_ptr), intent(in), value :: skip_beginning  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_skip_beginning
  logical, target :: f_skip_beginning_native
  logical, pointer :: f_skip_beginning_native_ptr
  logical(c_bool), pointer :: f_skip_beginning_ptr
  type(c_ptr), intent(in), value :: follow_fork  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_follow_fork
  logical, target :: f_follow_fork_native
  logical, pointer :: f_follow_fork_native_ptr
  logical(c_bool), pointer :: f_follow_fork_ptr
  ! ** Out parameters **
  type(c_ptr), value :: next_ele  ! 0D_PTR_type
  type(ele_struct), pointer :: f_next_ele
  ! ** End of parameters **
  ! in: f_this_ele 0D_NOT_type
  if (.not. c_associated(this_ele)) return
  call c_f_pointer(this_ele, f_this_ele)
  ! in: f_offset 0D_NOT_integer
  if (c_associated(offset)) then
    call c_f_pointer(offset, f_offset_ptr)
  else
    f_offset_ptr => null()
  endif
  ! in: f_skip_beginning 0D_NOT_logical
  if (c_associated(skip_beginning)) then
    call c_f_pointer(skip_beginning, f_skip_beginning_ptr)
    f_skip_beginning_native = f_skip_beginning_ptr
    f_skip_beginning_native_ptr => f_skip_beginning_native
  else
    f_skip_beginning_native_ptr => null()
  endif
  ! in: f_follow_fork 0D_NOT_logical
  if (c_associated(follow_fork)) then
    call c_f_pointer(follow_fork, f_follow_fork_ptr)
    f_follow_fork_native = f_follow_fork_ptr
    f_follow_fork_native_ptr => f_follow_fork_native
  else
    f_follow_fork_native_ptr => null()
  endif
  f_next_ele = pointer_to_next_ele(this_ele=f_this_ele, offset=f_offset_ptr, &
      skip_beginning=f_skip_beginning_native_ptr, follow_fork=f_follow_fork_native_ptr)

  ! out: f_next_ele 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_slave (lord, ix_slave, control, lord_type, ix_lord_back, &
    ix_control, ix_ic, slave_ptr) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  integer(c_int) :: ix_slave  ! 0D_NOT_integer
  integer :: f_ix_slave
  type(c_ptr), intent(in), value :: lord_type  ! 0D_NOT_integer
  integer(c_int) :: f_lord_type
  integer(c_int), pointer :: f_lord_type_ptr
  ! ** Out parameters **
  type(c_ptr), value :: control  ! 0D_PTR_type
  type(control_struct), pointer :: f_control
  type(c_ptr), intent(in), value :: ix_lord_back  ! 0D_NOT_integer
  integer :: f_ix_lord_back
  integer(c_int), pointer :: f_ix_lord_back_ptr
  type(c_ptr), intent(in), value :: ix_control  ! 0D_NOT_integer
  integer :: f_ix_control
  integer(c_int), pointer :: f_ix_control_ptr
  type(c_ptr), intent(in), value :: ix_ic  ! 0D_NOT_integer
  integer :: f_ix_ic
  integer(c_int), pointer :: f_ix_ic_ptr
  type(c_ptr), value :: slave_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_slave_ptr
  ! ** End of parameters **
  ! in: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  ! in: f_ix_slave 0D_NOT_integer
  f_ix_slave = ix_slave
  ! out: f_control 0D_PTR_type
  if (c_associated(control))   call c_f_pointer(control, f_control)
  ! in: f_lord_type 0D_NOT_integer
  if (c_associated(lord_type)) then
    call c_f_pointer(lord_type, f_lord_type_ptr)
  else
    f_lord_type_ptr => null()
  endif
  f_slave_ptr = pointer_to_slave(lord=f_lord, ix_slave=f_ix_slave, control=f_control, &
      lord_type=f_lord_type_ptr, ix_lord_back=f_ix_lord_back, ix_control=f_ix_control, &
      ix_ic=f_ix_ic)

  ! out: f_control 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_ix_lord_back 0D_NOT_integer
  ! no output conversion for f_ix_lord_back
  ! out: f_ix_control 0D_NOT_integer
  ! no output conversion for f_ix_control
  ! out: f_ix_ic 0D_NOT_integer
  ! no output conversion for f_ix_ic
  ! out: f_slave_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_super_lord (slave, control, ix_slave_back, ix_control, ix_ic, &
    lord_type, lord_ptr) bind(c)

  use bmad_struct, only: control_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  type(c_ptr), intent(in), value :: lord_type  ! 0D_NOT_integer
  integer(c_int) :: f_lord_type
  integer(c_int), pointer :: f_lord_type_ptr
  ! ** Out parameters **
  type(c_ptr), value :: control  ! 0D_PTR_type
  type(control_struct), pointer :: f_control
  type(c_ptr), intent(in), value :: ix_slave_back  ! 0D_NOT_integer
  integer :: f_ix_slave_back
  integer(c_int), pointer :: f_ix_slave_back_ptr
  type(c_ptr), intent(in), value :: ix_control  ! 0D_NOT_integer
  integer :: f_ix_control
  integer(c_int), pointer :: f_ix_control_ptr
  type(c_ptr), intent(in), value :: ix_ic  ! 0D_NOT_integer
  integer :: f_ix_ic
  integer(c_int), pointer :: f_ix_ic_ptr
  type(c_ptr), value :: lord_ptr  ! 0D_PTR_type
  type(ele_struct), pointer :: f_lord_ptr
  ! ** End of parameters **
  ! in: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  ! out: f_control 0D_PTR_type
  if (c_associated(control))   call c_f_pointer(control, f_control)
  ! in: f_lord_type 0D_NOT_integer
  if (c_associated(lord_type)) then
    call c_f_pointer(lord_type, f_lord_type_ptr)
  else
    f_lord_type_ptr => null()
  endif
  f_lord_ptr = pointer_to_super_lord(slave=f_slave, control=f_control, &
      ix_slave_back=f_ix_slave_back, ix_control=f_ix_control, ix_ic=f_ix_ic, &
      lord_type=f_lord_type_ptr)

  ! out: f_control 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
  ! out: f_ix_slave_back 0D_NOT_integer
  ! no output conversion for f_ix_slave_back
  ! out: f_ix_control 0D_NOT_integer
  ! no output conversion for f_ix_control
  ! out: f_ix_ic 0D_NOT_integer
  ! no output conversion for f_ix_ic
  ! out: f_lord_ptr 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_surface_displacement_pt (ele, nearest, x, y, ix, iy, extend_grid, &
    xx, yy, pt) bind(c)

  use bmad_struct, only: ele_struct, surface_displacement_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: nearest  ! 0D_NOT_logical
  logical :: f_nearest
  type(c_ptr), intent(in), value :: extend_grid  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_extend_grid
  logical, target :: f_extend_grid_native
  logical, pointer :: f_extend_grid_native_ptr
  logical(c_bool), pointer :: f_extend_grid_ptr
  ! ** Out parameters **
  type(c_ptr), value :: pt  ! 0D_PTR_type
  type(surface_displacement_pt_struct), pointer :: f_pt
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: ix  ! 0D_NOT_integer
  integer(c_int) :: f_ix
  integer(c_int), pointer :: f_ix_ptr
  type(c_ptr), intent(in), value :: iy  ! 0D_NOT_integer
  integer(c_int) :: f_iy
  integer(c_int), pointer :: f_iy_ptr
  type(c_ptr), intent(in), value :: xx  ! 0D_NOT_real
  real(c_double) :: f_xx
  real(c_double), pointer :: f_xx_ptr
  type(c_ptr), intent(in), value :: yy  ! 0D_NOT_real
  real(c_double) :: f_yy
  real(c_double), pointer :: f_yy_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_nearest 0D_NOT_logical
  f_nearest = nearest
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_ix 0D_NOT_integer
  if (c_associated(ix)) then
    call c_f_pointer(ix, f_ix_ptr)
  else
    f_ix_ptr => null()
  endif
  ! inout: f_iy 0D_NOT_integer
  if (c_associated(iy)) then
    call c_f_pointer(iy, f_iy_ptr)
  else
    f_iy_ptr => null()
  endif
  ! in: f_extend_grid 0D_NOT_logical
  if (c_associated(extend_grid)) then
    call c_f_pointer(extend_grid, f_extend_grid_ptr)
    f_extend_grid_native = f_extend_grid_ptr
    f_extend_grid_native_ptr => f_extend_grid_native
  else
    f_extend_grid_native_ptr => null()
  endif
  ! inout: f_xx 0D_NOT_real
  if (c_associated(xx)) then
    call c_f_pointer(xx, f_xx_ptr)
  else
    f_xx_ptr => null()
  endif
  ! inout: f_yy 0D_NOT_real
  if (c_associated(yy)) then
    call c_f_pointer(yy, f_yy_ptr)
  else
    f_yy_ptr => null()
  endif
  f_pt = pointer_to_surface_displacement_pt(ele=f_ele, nearest=f_nearest, x=f_x_ptr, y=f_y_ptr, &
      ix=f_ix_ptr, iy=f_iy_ptr, extend_grid=f_extend_grid_native_ptr, xx=f_xx_ptr, yy=f_yy_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_ix 0D_NOT_integer
  ! no output conversion for f_ix
  ! inout: f_iy 0D_NOT_integer
  ! no output conversion for f_iy
  ! inout: f_xx 0D_NOT_real
  ! no output conversion for f_xx
  ! inout: f_yy 0D_NOT_real
  ! no output conversion for f_yy
  ! out: f_pt 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_surface_segmented_pt (ele, nearest, x, y, ix, iy, extend_grid, &
    xx, yy, pt) bind(c)

  use bmad_struct, only: ele_struct, surface_segmented_pt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: nearest  ! 0D_NOT_logical
  logical :: f_nearest
  type(c_ptr), intent(in), value :: extend_grid  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_extend_grid
  logical, target :: f_extend_grid_native
  logical, pointer :: f_extend_grid_native_ptr
  logical(c_bool), pointer :: f_extend_grid_ptr
  ! ** Out parameters **
  type(c_ptr), value :: pt  ! 0D_PTR_type
  type(surface_segmented_pt_struct), pointer :: f_pt
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: ix  ! 0D_NOT_integer
  integer(c_int) :: f_ix
  integer(c_int), pointer :: f_ix_ptr
  type(c_ptr), intent(in), value :: iy  ! 0D_NOT_integer
  integer(c_int) :: f_iy
  integer(c_int), pointer :: f_iy_ptr
  type(c_ptr), intent(in), value :: xx  ! 0D_NOT_real
  real(c_double) :: f_xx
  real(c_double), pointer :: f_xx_ptr
  type(c_ptr), intent(in), value :: yy  ! 0D_NOT_real
  real(c_double) :: f_yy
  real(c_double), pointer :: f_yy_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_nearest 0D_NOT_logical
  f_nearest = nearest
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_ix 0D_NOT_integer
  if (c_associated(ix)) then
    call c_f_pointer(ix, f_ix_ptr)
  else
    f_ix_ptr => null()
  endif
  ! inout: f_iy 0D_NOT_integer
  if (c_associated(iy)) then
    call c_f_pointer(iy, f_iy_ptr)
  else
    f_iy_ptr => null()
  endif
  ! in: f_extend_grid 0D_NOT_logical
  if (c_associated(extend_grid)) then
    call c_f_pointer(extend_grid, f_extend_grid_ptr)
    f_extend_grid_native = f_extend_grid_ptr
    f_extend_grid_native_ptr => f_extend_grid_native
  else
    f_extend_grid_native_ptr => null()
  endif
  ! inout: f_xx 0D_NOT_real
  if (c_associated(xx)) then
    call c_f_pointer(xx, f_xx_ptr)
  else
    f_xx_ptr => null()
  endif
  ! inout: f_yy 0D_NOT_real
  if (c_associated(yy)) then
    call c_f_pointer(yy, f_yy_ptr)
  else
    f_yy_ptr => null()
  endif
  f_pt = pointer_to_surface_segmented_pt(ele=f_ele, nearest=f_nearest, x=f_x_ptr, y=f_y_ptr, &
      ix=f_ix_ptr, iy=f_iy_ptr, extend_grid=f_extend_grid_native_ptr, xx=f_xx_ptr, yy=f_yy_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_ix 0D_NOT_integer
  ! no output conversion for f_ix
  ! inout: f_iy 0D_NOT_integer
  ! no output conversion for f_iy
  ! inout: f_xx 0D_NOT_real
  ! no output conversion for f_xx
  ! inout: f_yy 0D_NOT_real
  ! no output conversion for f_yy
  ! out: f_pt 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_wake_ele (ele, delta_s, wake_ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: delta_s  ! 0D_NOT_real
  real(rp) :: f_delta_s
  real(c_double), pointer :: f_delta_s_ptr
  type(c_ptr), value :: wake_ele  ! 0D_PTR_type
  type(ele_struct), pointer :: f_wake_ele
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_wake_ele = pointer_to_wake_ele(ele=f_ele, delta_s=f_delta_s)

  ! out: f_delta_s 0D_NOT_real
  ! no output conversion for f_delta_s
  ! out: f_wake_ele 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_pointer_to_wall3d (ele, ix_wall, ds_offset, is_branch_wall, wall3d) bind(c)

  use bmad_struct, only: ele_struct, wall3d_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: ix_wall  ! 0D_NOT_integer
  integer(c_int) :: f_ix_wall
  integer(c_int), pointer :: f_ix_wall_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ds_offset  ! 0D_NOT_real
  real(rp) :: f_ds_offset
  real(c_double), pointer :: f_ds_offset_ptr
  type(c_ptr), intent(in), value :: is_branch_wall  ! 0D_NOT_logical
  logical :: f_is_branch_wall
  logical(c_bool), pointer :: f_is_branch_wall_ptr
  type(c_ptr), value :: wall3d  ! 0D_PTR_type
  type(wall3d_struct), pointer :: f_wall3d
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_ix_wall 0D_NOT_integer
  if (c_associated(ix_wall)) then
    call c_f_pointer(ix_wall, f_ix_wall_ptr)
  else
    f_ix_wall_ptr => null()
  endif
  f_wall3d = pointer_to_wall3d(ele=f_ele, ix_wall=f_ix_wall_ptr, ds_offset=f_ds_offset, &
      is_branch_wall=f_is_branch_wall)

  ! out: f_ds_offset 0D_NOT_real
  ! no output conversion for f_ds_offset
  ! out: f_is_branch_wall 0D_NOT_logical
  ! no output conversion for f_is_branch_wall
  ! out: f_wall3d 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_polar_to_spinor (polar, spinor) bind(c)

  use bmad_struct, only: spin_polar_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: polar  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_polar
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: spinor
  complex(rp) :: f_spinor(2)
  complex(c_double_complex), pointer :: f_spinor_ptr(:)
  ! ** End of parameters **
  ! in: f_polar 0D_NOT_type
  if (.not. c_associated(polar)) return
  call c_f_pointer(polar, f_polar)
  f_spinor = polar_to_spinor(polar=f_polar)

  ! out: f_spinor 1D_NOT_complex
  if (c_associated(spinor)) then
    call c_f_pointer(spinor, f_spinor_ptr, [2])
    f_spinor_ptr = f_spinor(:)
  endif
end subroutine
subroutine fortran_polar_to_vec (polar, vec) bind(c)

  use bmad_struct, only: spin_polar_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: polar  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_polar
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: vec
  real(rp) :: f_vec(3)
  real(c_double), pointer :: f_vec_ptr(:)
  ! ** End of parameters **
  ! in: f_polar 0D_NOT_type
  if (.not. c_associated(polar)) return
  call c_f_pointer(polar, f_polar)
  f_vec = polar_to_vec(polar=f_polar)

  ! out: f_vec 1D_NOT_real
  if (c_associated(vec)) then
    call c_f_pointer(vec, f_vec_ptr, [3])
    f_vec_ptr = f_vec(:)
  endif
end subroutine
subroutine fortran_project_emit_to_xyz (ring, ix, mode, sigma_x, sigma_y, sigma_z) bind(c)

  use bmad_struct, only: lat_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ring  ! 0D_NOT_type
  type(lat_struct), pointer :: f_ring
  integer(c_int) :: ix  ! 0D_NOT_integer
  integer :: f_ix
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: sigma_x  ! 0D_NOT_real
  real(rp) :: f_sigma_x
  real(c_double), pointer :: f_sigma_x_ptr
  type(c_ptr), intent(in), value :: sigma_y  ! 0D_NOT_real
  real(rp) :: f_sigma_y
  real(c_double), pointer :: f_sigma_y_ptr
  type(c_ptr), intent(in), value :: sigma_z  ! 0D_NOT_real
  real(rp) :: f_sigma_z
  real(c_double), pointer :: f_sigma_z_ptr
  ! ** End of parameters **
  ! in: f_ring 0D_NOT_type
  if (.not. c_associated(ring)) return
  call c_f_pointer(ring, f_ring)
  ! in: f_ix 0D_NOT_integer
  f_ix = ix
  ! in: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  call project_emit_to_xyz(ring=f_ring, ix=f_ix, mode=f_mode, sigma_x=f_sigma_x, &
      sigma_y=f_sigma_y, sigma_z=f_sigma_z)

  ! out: f_sigma_x 0D_NOT_real
  call c_f_pointer(sigma_x, f_sigma_x_ptr)
  f_sigma_x_ptr = f_sigma_x
  ! out: f_sigma_y 0D_NOT_real
  call c_f_pointer(sigma_y, f_sigma_y_ptr)
  f_sigma_y_ptr = f_sigma_y
  ! out: f_sigma_z 0D_NOT_real
  call c_f_pointer(sigma_z, f_sigma_z_ptr)
  f_sigma_z_ptr = f_sigma_z
end subroutine
subroutine fortran_psi_prime_sca (t, p, dpdt, args) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: t  ! 0D_NOT_real
  real(rp) :: f_t
  real(c_double) :: p  ! 0D_NOT_real
  real(rp) :: f_p
  type(c_ptr), intent(in), value :: args
  real(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dpdt  ! 0D_NOT_real
  real(rp) :: f_dpdt
  real(c_double), pointer :: f_dpdt_ptr
  ! ** End of parameters **
  ! in: f_t 0D_NOT_real
  f_t = t
  ! in: f_p 0D_NOT_real
  f_p = p
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  call psi_prime_sca(t=f_t, p=f_p, dpdt=f_dpdt, args=f_args)

  ! out: f_dpdt 0D_NOT_real
  call c_f_pointer(dpdt, f_dpdt_ptr)
  f_dpdt_ptr = f_dpdt
end subroutine
subroutine fortran_ptc_bookkeeper (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call ptc_bookkeeper(lat=f_lat)

end subroutine
subroutine fortran_ptc_closed_orbit_calc (branch, closed_orbit, radiation_damping_on) bind(c)

  use bmad_struct, only: branch_struct, coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), intent(in), value :: radiation_damping_on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_radiation_damping_on
  logical, target :: f_radiation_damping_on_native
  logical, pointer :: f_radiation_damping_on_native_ptr
  logical(c_bool), pointer :: f_radiation_damping_on_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: closed_orbit
  type(coord_struct_container_alloc), pointer :: f_closed_orbit
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  !! container type array (1D_ALLOC_type)
  if (c_associated(closed_orbit))   call c_f_pointer(closed_orbit, f_closed_orbit)
  ! in: f_radiation_damping_on 0D_NOT_logical
  if (c_associated(radiation_damping_on)) then
    call c_f_pointer(radiation_damping_on, f_radiation_damping_on_ptr)
    f_radiation_damping_on_native = f_radiation_damping_on_ptr
    f_radiation_damping_on_native_ptr => f_radiation_damping_on_native
  else
    f_radiation_damping_on_native_ptr => null()
  endif
  call ptc_closed_orbit_calc(branch=f_branch, closed_orbit=f_closed_orbit%data, &
      radiation_damping_on=f_radiation_damping_on_native_ptr)

end subroutine
subroutine fortran_ptc_emit_calc (ele, norm_mode, sigma_mat, closed_orb) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: norm_mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_norm_mode
  type(c_ptr), value :: closed_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_closed_orb
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_norm_mode 0D_NOT_type
  if (.not. c_associated(norm_mode)) return
  call c_f_pointer(norm_mode, f_norm_mode)
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat)) then
    call c_f_pointer(sigma_mat, f_sigma_mat_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptr, f_sigma_mat)
  else
    f_sigma_mat_ptr => null()
  endif
  ! out: f_closed_orb 0D_NOT_type
  if (.not. c_associated(closed_orb)) return
  call c_f_pointer(closed_orb, f_closed_orb)
  call ptc_emit_calc(ele=f_ele, norm_mode=f_norm_mode, sigma_mat=f_sigma_mat, &
      closed_orb=f_closed_orb)

  ! out: f_norm_mode 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_closed_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ptc_layouts_resplit (dKL_max, l_max, l_max_drift_only, bend_dorb, sex_dx, &
    even, crossover, crossover_wiggler) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: dKL_max  ! 0D_NOT_real
  real(rp) :: f_dKL_max
  real(c_double) :: l_max  ! 0D_NOT_real
  real(rp) :: f_l_max
  logical(c_bool) :: l_max_drift_only  ! 0D_NOT_logical
  logical :: f_l_max_drift_only
  real(c_double) :: bend_dorb  ! 0D_NOT_real
  real(rp) :: f_bend_dorb
  real(c_double) :: sex_dx  ! 0D_NOT_real
  real(rp) :: f_sex_dx
  type(c_ptr), intent(in), value :: even  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_even
  logical, target :: f_even_native
  logical, pointer :: f_even_native_ptr
  logical(c_bool), pointer :: f_even_ptr
  type(c_ptr), intent(in), value :: crossover
  integer :: f_crossover(2)
  integer(c_int), pointer :: f_crossover_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: crossover_wiggler
  integer :: f_crossover_wiggler(2)
  integer(c_int), pointer :: f_crossover_wiggler_ptr(:)
  ! ** End of parameters **
  ! in: f_dKL_max 0D_NOT_real
  f_dKL_max = dKL_max
  ! in: f_l_max 0D_NOT_real
  f_l_max = l_max
  ! in: f_l_max_drift_only 0D_NOT_logical
  f_l_max_drift_only = l_max_drift_only
  ! in: f_bend_dorb 0D_NOT_real
  f_bend_dorb = bend_dorb
  ! in: f_sex_dx 0D_NOT_real
  f_sex_dx = sex_dx
  ! in: f_even 0D_NOT_logical
  if (c_associated(even)) then
    call c_f_pointer(even, f_even_ptr)
    f_even_native = f_even_ptr
    f_even_native_ptr => f_even_native
  else
    f_even_native_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(crossover)) then
    call c_f_pointer(crossover, f_crossover_ptr, [2])
    f_crossover = f_crossover_ptr(:)
  else
    f_crossover_ptr => null()
  endif
  !! general array (1D_NOT_integer)
  if (c_associated(crossover_wiggler)) then
    call c_f_pointer(crossover_wiggler, f_crossover_wiggler_ptr, [2])
    f_crossover_wiggler = f_crossover_wiggler_ptr(:)
  else
    f_crossover_wiggler_ptr => null()
  endif
  call ptc_layouts_resplit(dKL_max=f_dKL_max, l_max=f_l_max, &
      l_max_drift_only=f_l_max_drift_only, bend_dorb=f_bend_dorb, sex_dx=f_sex_dx, &
      even=f_even_native_ptr, crossover=f_crossover, crossover_wiggler=f_crossover_wiggler)

end subroutine
subroutine fortran_ptc_one_turn_mat_and_closed_orbit_calc (branch, pz) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: pz  ! 0D_NOT_real
  real(c_double) :: f_pz
  real(c_double), pointer :: f_pz_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** End of parameters **
  ! inout: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_pz 0D_NOT_real
  if (c_associated(pz)) then
    call c_f_pointer(pz, f_pz_ptr)
  else
    f_pz_ptr => null()
  endif
  call ptc_one_turn_mat_and_closed_orbit_calc(branch=f_branch, pz=f_pz_ptr)

end subroutine
subroutine fortran_ptc_ran_seed_put (iseed) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: iseed  ! 0D_NOT_integer
  integer :: f_iseed
  ! ** End of parameters **
  ! in: f_iseed 0D_NOT_integer
  f_iseed = iseed
  call ptc_ran_seed_put(iseed=f_iseed)

end subroutine
subroutine fortran_ptc_set_rf_state_for_c_normal (nocavity) bind(c)

  implicit none
  ! ** In parameters **
  logical(c_bool) :: nocavity  ! 0D_NOT_logical
  logical :: f_nocavity
  ! ** End of parameters **
  ! in: f_nocavity 0D_NOT_logical
  f_nocavity = nocavity
  call ptc_set_rf_state_for_c_normal(nocavity=f_nocavity)

end subroutine
subroutine fortran_ptc_set_taylor_order_if_needed () bind(c)

  implicit none
  ! ** End of parameters **
  call ptc_set_taylor_order_if_needed()

end subroutine
subroutine fortran_ptc_spin_calc (ele, norm_mode, sigma_mat, closed_orb) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: norm_mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_norm_mode
  type(c_ptr), value :: closed_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_closed_orb
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: sigma_mat
  real(rp) :: f_sigma_mat(6,6)
  real(c_double), pointer :: f_sigma_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_norm_mode 0D_NOT_type
  if (.not. c_associated(norm_mode)) return
  call c_f_pointer(norm_mode, f_norm_mode)
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat)) then
    call c_f_pointer(sigma_mat, f_sigma_mat_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptr, f_sigma_mat)
  else
    f_sigma_mat_ptr => null()
  endif
  ! out: f_closed_orb 0D_NOT_type
  if (.not. c_associated(closed_orb)) return
  call c_f_pointer(closed_orb, f_closed_orb)
  call ptc_spin_calc(ele=f_ele, norm_mode=f_norm_mode, sigma_mat=f_sigma_mat, &
      closed_orb=f_closed_orb)

  ! out: f_norm_mode 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_closed_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_ptc_track_all (branch, orbit, track_state, err_flag) bind(c)

  use bmad_struct, only: branch_struct, coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: track_state  ! 0D_NOT_integer
  integer :: f_track_state
  integer(c_int), pointer :: f_track_state_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(branch, f_branch)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  call ptc_track_all(branch=f_branch, orbit=f_orbit%data, track_state=f_track_state, &
      err_flag=f_err_flag)

  ! out: f_track_state 0D_NOT_integer
  ! no output conversion for f_track_state
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_ptc_transfer_map_with_spin (branch, t_map, s_map, orb0, err_flag, ix1, ix2, &
    one_turn, unit_start) bind(c)

  use bmad_struct, only: branch_struct, coord_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), value :: orb0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb0
  type(c_ptr), intent(in), value :: ix1  ! 0D_NOT_integer
  integer(c_int) :: f_ix1
  integer(c_int), pointer :: f_ix1_ptr
  type(c_ptr), intent(in), value :: ix2  ! 0D_NOT_integer
  integer(c_int) :: f_ix2
  integer(c_int), pointer :: f_ix2_ptr
  type(c_ptr), intent(in), value :: one_turn  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_one_turn
  logical, target :: f_one_turn_native
  logical, pointer :: f_one_turn_native_ptr
  logical(c_bool), pointer :: f_one_turn_ptr
  type(c_ptr), intent(in), value :: unit_start  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_unit_start
  logical, target :: f_unit_start_native
  logical, pointer :: f_unit_start_native_ptr
  logical(c_bool), pointer :: f_unit_start_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: t_map
  type(taylor_struct), pointer :: f_t_map(:)
  type(c_ptr), intent(in), value :: s_map
  type(taylor_struct), pointer :: f_s_map(:)
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(branch, f_branch)
  !! type array (1D_NOT_type)
  call c_f_pointer(t_map, f_t_map, [6])
  !! type array (1D_NOT_type)
  call c_f_pointer(s_map, f_s_map, [4])
  ! in: f_orb0 0D_NOT_type
  if (.not. c_associated(orb0)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orb0, f_orb0)
  ! in: f_ix1 0D_NOT_integer
  if (c_associated(ix1)) then
    call c_f_pointer(ix1, f_ix1_ptr)
  else
    f_ix1_ptr => null()
  endif
  ! in: f_ix2 0D_NOT_integer
  if (c_associated(ix2)) then
    call c_f_pointer(ix2, f_ix2_ptr)
  else
    f_ix2_ptr => null()
  endif
  ! in: f_one_turn 0D_NOT_logical
  if (c_associated(one_turn)) then
    call c_f_pointer(one_turn, f_one_turn_ptr)
    f_one_turn_native = f_one_turn_ptr
    f_one_turn_native_ptr => f_one_turn_native
  else
    f_one_turn_native_ptr => null()
  endif
  ! in: f_unit_start 0D_NOT_logical
  if (c_associated(unit_start)) then
    call c_f_pointer(unit_start, f_unit_start_ptr)
    f_unit_start_native = f_unit_start_ptr
    f_unit_start_native_ptr => f_unit_start_native
  else
    f_unit_start_native_ptr => null()
  endif
  call ptc_transfer_map_with_spin(branch=f_branch, t_map=f_t_map, s_map=f_s_map, orb0=f_orb0, &
      err_flag=f_err_flag, ix1=f_ix1_ptr, ix2=f_ix2_ptr, one_turn=f_one_turn_native_ptr, &
      unit_start=f_unit_start_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_pwd_mat (lat, t6, inductance, sig_z, t6_pwd) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  TYPE(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: t6
  REAL(rp) :: f_t6(6,6)
  real(c_double), pointer :: f_t6_ptr(:)
  real(c_double) :: inductance  ! 0D_NOT_real
  REAL(rp) :: f_inductance
  real(c_double) :: sig_z  ! 0D_NOT_real
  REAL(rp) :: f_sig_z
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: t6_pwd
  REAL(rp) :: f_t6_pwd(6,6)
  real(c_double), pointer :: f_t6_pwd_ptr(:)
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! general array (2D_NOT_real)
  if (c_associated(t6)) then
    call c_f_pointer(t6, f_t6_ptr, [6*6])
    call vec2mat(f_t6_ptr, f_t6)
  else
    f_t6_ptr => null()
  endif
  ! in: f_inductance 0D_NOT_real
  f_inductance = inductance
  ! in: f_sig_z 0D_NOT_real
  f_sig_z = sig_z
  f_t6_pwd = pwd_mat(lat=f_lat, t6=f_t6, inductance=f_inductance, sig_z=f_sig_z)

  ! out: f_t6_pwd 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_t6_pwd', c_name='t6_pwd', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=682, definition='REAL(rp) t6_pwd(6,6)', type_info=TypeInformation(type='REAL', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='t6_pwd', comment='', default=None), intent='out', description='1-turn transfer matrix with PWD defocusing applied', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_rad1_damp_and_stoc_mats (ele, include_opening_angle, orb_in, orb_out, &
    rad_map, g2_tol, g3_tol, err_flag, ele0, rad_int1) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, rad_int1_struct, rad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: include_opening_angle  ! 0D_NOT_logical
  logical :: f_include_opening_angle
  type(c_ptr), value :: orb_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_in
  type(c_ptr), value :: orb_out  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_out
  real(c_double) :: g2_tol  ! 0D_NOT_real
  real(rp) :: f_g2_tol
  real(c_double) :: g3_tol  ! 0D_NOT_real
  real(rp) :: f_g3_tol
  type(c_ptr), value :: ele0  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele0
  ! ** Out parameters **
  type(c_ptr), value :: rad_map  ! 0D_NOT_type
  type(rad_map_struct), pointer :: f_rad_map
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: rad_int1  ! 0D_NOT_type
  type(rad_int1_struct), pointer :: f_rad_int1
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_include_opening_angle 0D_NOT_logical
  f_include_opening_angle = include_opening_angle
  ! in: f_orb_in 0D_NOT_type
  if (.not. c_associated(orb_in)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orb_in, f_orb_in)
  ! in: f_orb_out 0D_NOT_type
  if (.not. c_associated(orb_out)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orb_out, f_orb_out)
  ! out: f_rad_map 0D_NOT_type
  if (.not. c_associated(rad_map)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(rad_map, f_rad_map)
  ! in: f_g2_tol 0D_NOT_real
  f_g2_tol = g2_tol
  ! in: f_g3_tol 0D_NOT_real
  f_g3_tol = g3_tol
  ! in: f_ele0 0D_NOT_type
  if (c_associated(ele0))   call c_f_pointer(ele0, f_ele0)
  ! out: f_rad_int1 0D_NOT_type
  if (c_associated(rad_int1))   call c_f_pointer(rad_int1, f_rad_int1)
  call rad1_damp_and_stoc_mats(ele=f_ele, include_opening_angle=f_include_opening_angle, &
      orb_in=f_orb_in, orb_out=f_orb_out, rad_map=f_rad_map, g2_tol=f_g2_tol, g3_tol=f_g3_tol, &
      err_flag=f_err_flag, ele0=f_ele0, rad_int1=f_rad_int1)

  ! out: f_rad_map 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_rad_int1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_rad_damp_and_stoc_mats (ele1, ele2, include_opening_angle, rmap, mode, &
    xfer_nodamp_mat, err_flag, closed_orbit, rad_int_branch) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, normal_modes_struct, rad_int_branch_struct, rad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  logical(c_bool) :: include_opening_angle  ! 0D_NOT_logical
  logical :: f_include_opening_angle
  type(c_ptr), intent(in), value :: closed_orbit
  type(coord_struct_container_alloc), pointer :: f_closed_orbit
  ! ** Out parameters **
  type(c_ptr), value :: rmap  ! 0D_NOT_type
  type(rad_map_struct), pointer :: f_rmap
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  type(c_ptr), intent(in), value :: xfer_nodamp_mat
  real(rp) :: f_xfer_nodamp_mat(6,6)
  real(c_double), pointer :: f_xfer_nodamp_mat_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: rad_int_branch  ! 0D_NOT_type
  type(rad_int_branch_struct), pointer :: f_rad_int_branch
  ! ** End of parameters **
  ! in: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele1, f_ele1)
  ! in: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele2, f_ele2)
  ! in: f_include_opening_angle 0D_NOT_logical
  f_include_opening_angle = include_opening_angle
  ! out: f_rmap 0D_NOT_type
  if (.not. c_associated(rmap)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(rmap, f_rmap)
  ! out: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(mode, f_mode)
  !! container type array (1D_ALLOC_type)
  if (c_associated(closed_orbit))   call c_f_pointer(closed_orbit, f_closed_orbit)
  ! out: f_rad_int_branch 0D_NOT_type
  if (c_associated(rad_int_branch))   call c_f_pointer(rad_int_branch, f_rad_int_branch)
  call rad_damp_and_stoc_mats(ele1=f_ele1, ele2=f_ele2, &
      include_opening_angle=f_include_opening_angle, rmap=f_rmap, mode=f_mode, &
      xfer_nodamp_mat=f_xfer_nodamp_mat, err_flag=f_err_flag, closed_orbit=f_closed_orbit%data, &
      rad_int_branch=f_rad_int_branch)

  ! out: f_rmap 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_mode 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_xfer_nodamp_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_xfer_nodamp_mat', c_name='xfer_nodamp_mat', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=276, definition='real(rp) sig_mat(6,6), mt(6,6), xfer_nodamp_mat(6,6), tol, length', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='xfer_nodamp_mat', comment='', default=None), intent='out', description='Transfer matrix without damping.', doc_data_type='float', doc_is_optional=False)
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_rad_int_branch 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_rad_g_integrals (ele, where, orb_in, orb_out, int_g, int_g2, int_g3, g_tol, &
    g2_tol, g3_tol) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: where  ! 0D_NOT_integer
  integer :: f_where
  type(c_ptr), value :: orb_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_in
  type(c_ptr), value :: orb_out  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_out
  real(c_double) :: g_tol  ! 0D_NOT_real
  real(rp) :: f_g_tol
  real(c_double) :: g2_tol  ! 0D_NOT_real
  real(rp) :: f_g2_tol
  real(c_double) :: g3_tol  ! 0D_NOT_real
  real(rp) :: f_g3_tol
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: int_g
  real(rp) :: f_int_g(2)
  real(c_double), pointer :: f_int_g_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: int_g2  ! 0D_NOT_real
  real(c_double) :: f_int_g2
  real(c_double), pointer :: f_int_g2_ptr
  type(c_ptr), intent(in), value :: int_g3  ! 0D_NOT_real
  real(c_double) :: f_int_g3
  real(c_double), pointer :: f_int_g3_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_where 0D_NOT_integer
  f_where = where
  ! in: f_orb_in 0D_NOT_type
  if (.not. c_associated(orb_in)) return
  call c_f_pointer(orb_in, f_orb_in)
  ! in: f_orb_out 0D_NOT_type
  if (.not. c_associated(orb_out)) return
  call c_f_pointer(orb_out, f_orb_out)
  ! inout: f_int_g2 0D_NOT_real
  if (c_associated(int_g2)) then
    call c_f_pointer(int_g2, f_int_g2_ptr)
  else
    f_int_g2_ptr => null()
  endif
  ! inout: f_int_g3 0D_NOT_real
  if (c_associated(int_g3)) then
    call c_f_pointer(int_g3, f_int_g3_ptr)
  else
    f_int_g3_ptr => null()
  endif
  ! in: f_g_tol 0D_NOT_real
  f_g_tol = g_tol
  ! in: f_g2_tol 0D_NOT_real
  f_g2_tol = g2_tol
  ! in: f_g3_tol 0D_NOT_real
  f_g3_tol = g3_tol
  call rad_g_integrals(ele=f_ele, where=f_where, orb_in=f_orb_in, orb_out=f_orb_out, &
      int_g=f_int_g, int_g2=f_int_g2_ptr, int_g3=f_int_g3_ptr, g_tol=f_g_tol, g2_tol=f_g2_tol, &
      g3_tol=f_g3_tol)

  ! out: f_int_g 1D_NOT_real
  if (c_associated(int_g)) then
    call c_f_pointer(int_g, f_int_g_ptr, [2])
    f_int_g_ptr = f_int_g(:)
  endif
  ! inout: f_int_g2 0D_NOT_real
  ! no output conversion for f_int_g2
  ! inout: f_int_g3 0D_NOT_real
  ! no output conversion for f_int_g3
end subroutine
subroutine fortran_radiation_integrals (lat, orbit, mode, ix_cache, ix_branch, rad_int_by_ele) &
    bind(c)

  use bmad_struct, only: coord_struct, lat_struct, normal_modes_struct, rad_int_all_ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  type(c_ptr), value :: rad_int_by_ele  ! 0D_NOT_type
  type(rad_int_all_ele_struct), pointer :: f_rad_int_by_ele
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ix_cache  ! 0D_NOT_integer
  integer(c_int) :: f_ix_cache
  integer(c_int), pointer :: f_ix_cache_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  ! out: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  ! inout: f_ix_cache 0D_NOT_integer
  if (c_associated(ix_cache)) then
    call c_f_pointer(ix_cache, f_ix_cache_ptr)
  else
    f_ix_cache_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! out: f_rad_int_by_ele 0D_NOT_type
  if (c_associated(rad_int_by_ele))   call c_f_pointer(rad_int_by_ele, f_rad_int_by_ele)
  call radiation_integrals(lat=f_lat, orbit=f_orbit%data, mode=f_mode, ix_cache=f_ix_cache_ptr, &
      ix_branch=f_ix_branch_ptr, rad_int_by_ele=f_rad_int_by_ele)

  ! out: f_mode 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_ix_cache 0D_NOT_integer
  ! no output conversion for f_ix_cache
  ! out: f_rad_int_by_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_radiation_map_setup (ele, err_flag, ref_orbit_in) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: ref_orbit_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_ref_orbit_in
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! inout: f_ref_orbit_in 0D_NOT_type
  if (c_associated(ref_orbit_in))   call c_f_pointer(ref_orbit_in, f_ref_orbit_in)
  call radiation_map_setup(ele=f_ele, err_flag=f_err_flag, ref_orbit_in=f_ref_orbit_in)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_ramper_slave_setup (lat, force_setup) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: force_setup  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_force_setup
  logical, target :: f_force_setup_native
  logical, pointer :: f_force_setup_native_ptr
  logical(c_bool), pointer :: f_force_setup_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_force_setup 0D_NOT_logical
  if (c_associated(force_setup)) then
    call c_f_pointer(force_setup, f_force_setup_ptr)
    f_force_setup_native = f_force_setup_ptr
    f_force_setup_native_ptr => f_force_setup_native
  else
    f_force_setup_native_ptr => null()
  endif
  call ramper_slave_setup(lat=f_lat, force_setup=f_force_setup_native_ptr)

end subroutine
subroutine fortran_ramper_value (ramper, r1, err_flag, value) bind(c)

  use bmad_struct, only: control_ramp1_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ramper  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ramper
  type(c_ptr), value :: r1  ! 0D_NOT_type
  type(control_ramp1_struct), pointer :: f_r1
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(rp) :: f_value
  real(c_double), pointer :: f_value_ptr
  ! ** End of parameters **
  ! in: f_ramper 0D_NOT_type
  if (.not. c_associated(ramper)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ramper, f_ramper)
  ! in: f_r1 0D_NOT_type
  if (.not. c_associated(r1)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(r1, f_r1)
  f_value = ramper_value(ramper=f_ramper, r1=f_r1, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_value 0D_NOT_real
  call c_f_pointer(value, f_value_ptr)
  f_value_ptr = f_value
end subroutine
subroutine fortran_randomize_lr_wake_frequencies (ele, set_done) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: set_done  ! 0D_NOT_logical
  logical :: f_set_done
  logical(c_bool), pointer :: f_set_done_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call randomize_lr_wake_frequencies(ele=f_ele, set_done=f_set_done)

  ! out: f_set_done 0D_NOT_logical
  ! no output conversion for f_set_done
end subroutine
subroutine fortran_rchomp (rel, plc, out) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: out
  character(len=4096), target :: f_out
  character(kind=c_char), pointer :: f_out_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: rel  ! 0D_NOT_real
  real(c_double) :: f_rel
  real(c_double), pointer :: f_rel_ptr
  type(c_ptr), intent(in), value :: plc  ! 0D_NOT_integer
  integer(c_int) :: f_plc
  integer(c_int), pointer :: f_plc_ptr
  ! ** End of parameters **
  ! inout: f_rel 0D_NOT_real
  if (c_associated(rel)) then
    call c_f_pointer(rel, f_rel_ptr)
  else
    f_rel_ptr => null()
  endif
  ! inout: f_plc 0D_NOT_integer
  if (c_associated(plc)) then
    call c_f_pointer(plc, f_plc_ptr)
  else
    f_plc_ptr => null()
  endif
  f_out = rchomp(rel=f_rel_ptr, plc=f_plc_ptr)

  ! inout: f_rel 0D_NOT_real
  ! no output conversion for f_rel
  ! inout: f_plc 0D_NOT_integer
  ! no output conversion for f_plc
  ! out: f_out 0D_NOT_character
  call c_f_pointer(out, f_out_ptr, [len_trim(f_out) + 1]) ! output-only string
  call to_c_str(f_out, f_out_ptr)
end subroutine
subroutine fortran_re_allocate_eles (eles, n, save_old, exact) bind(c)

  use bmad_struct, only: ele_pointer_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  type(c_ptr), intent(in), value :: save_old  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save_old
  logical, target :: f_save_old_native
  logical, pointer :: f_save_old_native_ptr
  logical(c_bool), pointer :: f_save_old_ptr
  type(c_ptr), intent(in), value :: exact  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact
  logical, target :: f_exact_native
  logical, pointer :: f_exact_native_ptr
  logical(c_bool), pointer :: f_exact_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: eles
  type(ele_pointer_struct_container_alloc), pointer :: f_eles
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(eles))   call c_f_pointer(eles, f_eles)
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_save_old 0D_NOT_logical
  if (c_associated(save_old)) then
    call c_f_pointer(save_old, f_save_old_ptr)
    f_save_old_native = f_save_old_ptr
    f_save_old_native_ptr => f_save_old_native
  else
    f_save_old_native_ptr => null()
  endif
  ! in: f_exact 0D_NOT_logical
  if (c_associated(exact)) then
    call c_f_pointer(exact, f_exact_ptr)
    f_exact_native = f_exact_ptr
    f_exact_native_ptr => f_exact_native
  else
    f_exact_native_ptr => null()
  endif
  call re_allocate_eles(eles=f_eles%data, n=f_n, save_old=f_save_old_native_ptr, &
      exact=f_exact_native_ptr)

end subroutine
subroutine fortran_re_allocate_wall3d_section_array (section, n, exact) bind(c)

  use bmad_struct, only: wall3d_section_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  type(c_ptr), intent(in), value :: exact  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact
  logical, target :: f_exact_native
  logical, pointer :: f_exact_native_ptr
  logical(c_bool), pointer :: f_exact_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: section
  type(wall3d_section_struct_container_alloc), pointer :: f_section
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(section))   call c_f_pointer(section, f_section)
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_exact 0D_NOT_logical
  if (c_associated(exact)) then
    call c_f_pointer(exact, f_exact_ptr)
    f_exact_native = f_exact_ptr
    f_exact_native_ptr => f_exact_native
  else
    f_exact_native_ptr => null()
  endif
  call re_allocate_wall3d_section_array(section=f_section%data, n=f_n, &
      exact=f_exact_native_ptr)

end subroutine
subroutine fortran_re_allocate_wall3d_vertex_array (v, n, exact) bind(c)

  use bmad_struct, only: wall3d_vertex_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  type(c_ptr), intent(in), value :: exact  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact
  logical, target :: f_exact_native
  logical, pointer :: f_exact_native_ptr
  logical(c_bool), pointer :: f_exact_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: v
  type(wall3d_vertex_struct_container_alloc), pointer :: f_v
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(v))   call c_f_pointer(v, f_v)
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_exact 0D_NOT_logical
  if (c_associated(exact)) then
    call c_f_pointer(exact, f_exact_ptr)
    f_exact_native = f_exact_ptr
    f_exact_native_ptr => f_exact_native
  else
    f_exact_native_ptr => null()
  endif
  call re_allocate_wall3d_vertex_array(v=f_v%data, n=f_n, exact=f_exact_native_ptr)

end subroutine
subroutine fortran_re_associate_node_array (tree, n, exact) bind(c)

  use bmad_struct, only: expression_tree_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  type(c_ptr), intent(in), value :: exact  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact
  logical, target :: f_exact_native
  logical, pointer :: f_exact_native_ptr
  logical(c_bool), pointer :: f_exact_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: tree  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_tree
  ! ** End of parameters **
  ! inout: f_tree 0D_NOT_type
  if (.not. c_associated(tree)) return
  call c_f_pointer(tree, f_tree)
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_exact 0D_NOT_logical
  if (c_associated(exact)) then
    call c_f_pointer(exact, f_exact_ptr)
    f_exact_native = f_exact_ptr
    f_exact_native_ptr => f_exact_native
  else
    f_exact_native_ptr => null()
  endif
  call re_associate_node_array(tree=f_tree, n=f_n, exact=f_exact_native_ptr)

end subroutine
subroutine fortran_re_str_qp (rel, str_out) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str_out
  character(len=4096), target :: f_str_out
  character(kind=c_char), pointer :: f_str_out_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: rel  ! 0D_NOT_real16
  real(c_long_double), pointer :: f_rel
  real(16), target :: f_rel_native
  real(16), pointer :: f_rel_native_ptr
  real(c_long_double), pointer :: f_rel_ptr
  ! ** End of parameters **
  ! inout: f_rel 0D_NOT_real16
  if (c_associated(rel)) then
    call c_f_pointer(rel, f_rel_ptr)
    f_rel_native = f_rel_ptr
    f_rel_native_ptr => f_rel_native
  else
    f_rel_native_ptr => null()
  endif
  f_str_out = re_str_qp(rel=f_rel_native_ptr)

  ! inout: f_rel 0D_NOT_real16
  if (c_associated(rel)) then
    call c_f_pointer(rel, f_rel_ptr)
    f_rel_ptr = f_rel_native
  else
    ! f_rel unset
  endif
  ! out: f_str_out 0D_NOT_character
  call c_f_pointer(str_out, f_str_out_ptr, [len_trim(f_str_out) + 1]) ! output-only string
  call to_c_str(f_str_out, f_str_out_ptr)
end subroutine
subroutine fortran_re_str_rp (rel, str_out) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: str_out
  character(len=4096), target :: f_str_out
  character(kind=c_char), pointer :: f_str_out_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: rel  ! 0D_NOT_real
  real(c_double) :: f_rel
  real(c_double), pointer :: f_rel_ptr
  ! ** End of parameters **
  ! inout: f_rel 0D_NOT_real
  if (c_associated(rel)) then
    call c_f_pointer(rel, f_rel_ptr)
  else
    f_rel_ptr => null()
  endif
  f_str_out = re_str_rp(rel=f_rel_ptr)

  ! inout: f_rel 0D_NOT_real
  ! no output conversion for f_rel
  ! out: f_str_out 0D_NOT_character
  call c_f_pointer(str_out, f_str_out_ptr, [len_trim(f_str_out) + 1]) ! output-only string
  call to_c_str(f_str_out, f_str_out_ptr)
end subroutine
subroutine fortran_read_beam_ascii (file_name, beam, beam_init, err_flag) bind(c)

  use bmad_struct, only: beam_init_struct, beam_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: beam_init  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init
  ! ** Out parameters **
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! out: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam, f_beam)
  ! in: f_beam_init 0D_NOT_type
  if (.not. c_associated(beam_init)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam_init, f_beam_init)
  call read_beam_ascii(file_name=f_file_name, beam=f_beam, beam_init=f_beam_init, &
      err_flag=f_err_flag)

  ! out: f_beam 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_read_beam_file (file_name, beam, beam_init, err_flag, ele, &
    print_mom_shift_warning, conserve_momentum) bind(c)

  use bmad_struct, only: beam_init_struct, beam_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: beam_init  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: print_mom_shift_warning  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_mom_shift_warning
  logical, target :: f_print_mom_shift_warning_native
  logical, pointer :: f_print_mom_shift_warning_native_ptr
  logical(c_bool), pointer :: f_print_mom_shift_warning_ptr
  ! ** Out parameters **
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: conserve_momentum  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_conserve_momentum
  logical, target :: f_conserve_momentum_native
  logical, pointer :: f_conserve_momentum_native_ptr
  logical(c_bool), pointer :: f_conserve_momentum_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! out: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam, f_beam)
  ! in: f_beam_init 0D_NOT_type
  if (.not. c_associated(beam_init)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(beam_init, f_beam_init)
  ! in: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  ! in: f_print_mom_shift_warning 0D_NOT_logical
  if (c_associated(print_mom_shift_warning)) then
    call c_f_pointer(print_mom_shift_warning, f_print_mom_shift_warning_ptr)
    f_print_mom_shift_warning_native = f_print_mom_shift_warning_ptr
    f_print_mom_shift_warning_native_ptr => f_print_mom_shift_warning_native
  else
    f_print_mom_shift_warning_native_ptr => null()
  endif
  ! inout: f_conserve_momentum 0D_NOT_logical
  if (c_associated(conserve_momentum)) then
    call c_f_pointer(conserve_momentum, f_conserve_momentum_ptr)
    f_conserve_momentum_native = f_conserve_momentum_ptr
    f_conserve_momentum_native_ptr => f_conserve_momentum_native
  else
    f_conserve_momentum_native_ptr => null()
  endif
  call read_beam_file(file_name=f_file_name, beam=f_beam, beam_init=f_beam_init, &
      err_flag=f_err_flag, ele=f_ele, &
      print_mom_shift_warning=f_print_mom_shift_warning_native_ptr, &
      conserve_momentum=f_conserve_momentum_native_ptr)

  ! out: f_beam 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! inout: f_conserve_momentum 0D_NOT_logical
  if (c_associated(conserve_momentum)) then
    call c_f_pointer(conserve_momentum, f_conserve_momentum_ptr)
    f_conserve_momentum_ptr = f_conserve_momentum_native
  else
    ! f_conserve_momentum unset
  endif
end subroutine
subroutine fortran_read_binary_cartesian_map (file_name, ele, cart_map, err_flag) bind(c)

  use bmad_struct, only: cartesian_map_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: cart_map  ! 0D_NOT_type
  type(cartesian_map_struct), pointer :: f_cart_map
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_cart_map 0D_NOT_type
  if (.not. c_associated(cart_map)) return
  call c_f_pointer(cart_map, f_cart_map)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call read_binary_cartesian_map(file_name=f_file_name, ele=f_ele, cart_map=f_cart_map, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_read_binary_cylindrical_map (file_name, ele, cl_map, err_flag) bind(c)

  use bmad_struct, only: cylindrical_map_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: cl_map  ! 0D_NOT_type
  type(cylindrical_map_struct), pointer :: f_cl_map
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_cl_map 0D_NOT_type
  if (.not. c_associated(cl_map)) return
  call c_f_pointer(cl_map, f_cl_map)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call read_binary_cylindrical_map(file_name=f_file_name, ele=f_ele, cl_map=f_cl_map, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_read_binary_grid_field (file_name, ele, g_field, err_flag) bind(c)

  use bmad_struct, only: ele_struct, grid_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: g_field  ! 0D_NOT_type
  type(grid_field_struct), pointer :: f_g_field
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_g_field 0D_NOT_type
  if (.not. c_associated(g_field)) return
  call c_f_pointer(g_field, f_g_field)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call read_binary_grid_field(file_name=f_file_name, ele=f_ele, g_field=f_g_field, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_read_surface_reflection_file (file_name, surface) bind(c)

  use bmad_struct, only: photon_reflect_surface_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), value :: surface  ! 0D_NOT_type
  type(photon_reflect_surface_struct), pointer :: f_surface
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! out: f_surface 0D_NOT_type
  if (.not. c_associated(surface)) return
  call c_f_pointer(surface, f_surface)
  call read_surface_reflection_file(file_name=f_file_name, surface=f_surface)

  ! out: f_surface 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_reallocate_beam (beam, n_bunch, n_particle, extend) bind(c)

  use bmad_struct, only: beam_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_bunch  ! 0D_NOT_integer
  integer :: f_n_bunch
  type(c_ptr), intent(in), value :: n_particle  ! 0D_NOT_integer
  integer(c_int) :: f_n_particle
  integer(c_int), pointer :: f_n_particle_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: extend  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_extend
  logical, target :: f_extend_native
  logical, pointer :: f_extend_native_ptr
  logical(c_bool), pointer :: f_extend_ptr
  ! ** End of parameters **
  ! inout: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  ! in: f_n_bunch 0D_NOT_integer
  f_n_bunch = n_bunch
  ! in: f_n_particle 0D_NOT_integer
  if (c_associated(n_particle)) then
    call c_f_pointer(n_particle, f_n_particle_ptr)
  else
    f_n_particle_ptr => null()
  endif
  ! inout: f_extend 0D_NOT_logical
  if (c_associated(extend)) then
    call c_f_pointer(extend, f_extend_ptr)
    f_extend_native = f_extend_ptr
    f_extend_native_ptr => f_extend_native
  else
    f_extend_native_ptr => null()
  endif
  call reallocate_beam(beam=f_beam, n_bunch=f_n_bunch, n_particle=f_n_particle_ptr, &
      extend=f_extend_native_ptr)

  ! inout: f_extend 0D_NOT_logical
  if (c_associated(extend)) then
    call c_f_pointer(extend, f_extend_ptr)
    f_extend_ptr = f_extend_native
  else
    ! f_extend unset
  endif
end subroutine
subroutine fortran_reallocate_bp_com_const () bind(c)

  implicit none
  ! ** End of parameters **
  call reallocate_bp_com_const()

end subroutine
subroutine fortran_reallocate_bunch (bunch, n_particle, save) bind(c)

  use bmad_struct, only: bunch_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_particle  ! 0D_NOT_integer
  integer :: f_n_particle
  type(c_ptr), intent(in), value :: save  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save
  logical, target :: f_save_native
  logical, pointer :: f_save_native_ptr
  logical(c_bool), pointer :: f_save_ptr
  ! ** Out parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** End of parameters **
  ! out: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_n_particle 0D_NOT_integer
  f_n_particle = n_particle
  ! in: f_save 0D_NOT_logical
  if (c_associated(save)) then
    call c_f_pointer(save, f_save_ptr)
    f_save_native = f_save_ptr
    f_save_native_ptr => f_save_native
  else
    f_save_native_ptr => null()
  endif
  call reallocate_bunch(bunch=f_bunch, n_particle=f_n_particle, save=f_save_native_ptr)

  ! out: f_bunch 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_reallocate_control (lat, n) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_n 0D_NOT_integer
  f_n = n
  call reallocate_control(lat=f_lat, n=f_n)

end subroutine
subroutine fortran_reallocate_coord_array (coord_array, lat) bind(c)

  use bmad_struct, only: coord_array_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: coord_array
  type(coord_array_struct_container_alloc), pointer :: f_coord_array
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(coord_array))   call c_f_pointer(coord_array, f_coord_array)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call reallocate_coord_array(coord_array=f_coord_array%data, lat=f_lat)

end subroutine
subroutine fortran_reallocate_coord_lat (coord, lat, ix_branch) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: coord
  type(coord_struct_container_alloc), pointer :: f_coord
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(coord))   call c_f_pointer(coord, f_coord)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call reallocate_coord_lat(coord=f_coord%data, lat=f_lat, ix_branch=f_ix_branch_ptr)

end subroutine
subroutine fortran_reallocate_coord_n (coord, n_coord) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n_coord  ! 0D_NOT_integer
  integer :: f_n_coord
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: coord
  type(coord_struct_container_alloc), pointer :: f_coord
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(coord))   call c_f_pointer(coord, f_coord)
  ! in: f_n_coord 0D_NOT_integer
  f_n_coord = n_coord
  call reallocate_coord_n(coord=f_coord%data, n_coord=f_n_coord)

end subroutine
subroutine fortran_reallocate_expression_stack (stack, n, exact) bind(c)

  use bmad_struct, only: expression_atom_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n  ! 0D_NOT_integer
  integer :: f_n
  type(c_ptr), intent(in), value :: exact  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_exact
  logical, target :: f_exact_native
  logical, pointer :: f_exact_native_ptr
  logical(c_bool), pointer :: f_exact_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: stack
  type(expression_atom_struct_container_alloc), pointer :: f_stack
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(stack))   call c_f_pointer(stack, f_stack)
  ! in: f_n 0D_NOT_integer
  f_n = n
  ! in: f_exact 0D_NOT_logical
  if (c_associated(exact)) then
    call c_f_pointer(exact, f_exact_ptr)
    f_exact_native = f_exact_ptr
    f_exact_native_ptr => f_exact_native
  else
    f_exact_native_ptr => null()
  endif
  call reallocate_expression_stack(stack=f_stack%data, n=f_n, exact=f_exact_native_ptr)

end subroutine
subroutine fortran_rel_tracking_charge_to_mass (orbit, ref_species, rel_charge) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  integer(c_int) :: ref_species  ! 0D_NOT_integer
  integer :: f_ref_species
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: rel_charge  ! 0D_NOT_real
  real(rp) :: f_rel_charge
  real(c_double), pointer :: f_rel_charge_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ref_species 0D_NOT_integer
  f_ref_species = ref_species
  f_rel_charge = rel_tracking_charge_to_mass(orbit=f_orbit, ref_species=f_ref_species)

  ! out: f_rel_charge 0D_NOT_real
  call c_f_pointer(rel_charge, f_rel_charge_ptr)
  f_rel_charge_ptr = f_rel_charge
end subroutine
subroutine fortran_relative_mode_flip (ele1, ele2, func_retval__) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: func_retval__  ! 0D_NOT_logical
  logical :: f_func_retval__
  logical(c_bool), pointer :: f_func_retval___ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  ! ** End of parameters **
  ! inout: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  ! inout: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  f_func_retval__ = relative_mode_flip(ele1=f_ele1, ele2=f_ele2)

  ! out: f_func_retval__ 0D_NOT_logical
  call c_f_pointer(func_retval__, f_func_retval___ptr)
  f_func_retval___ptr = f_func_retval__
end subroutine
subroutine fortran_release_rad_int_cache (ix_cache) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ix_cache  ! 0D_NOT_integer
  integer(c_int) :: f_ix_cache
  integer(c_int), pointer :: f_ix_cache_ptr
  ! ** End of parameters **
  ! inout: f_ix_cache 0D_NOT_integer
  if (c_associated(ix_cache)) then
    call c_f_pointer(ix_cache, f_ix_cache_ptr)
  else
    f_ix_cache_ptr => null()
  endif
  call release_rad_int_cache(ix_cache=f_ix_cache_ptr)

  ! inout: f_ix_cache 0D_NOT_integer
  ! no output conversion for f_ix_cache
end subroutine
subroutine fortran_remove_constant_taylor (taylor_in, taylor_out, c0, &
    remove_higher_order_terms) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: taylor_in
  type(taylor_struct_container_alloc), pointer :: f_taylor_in
  logical(c_bool) :: remove_higher_order_terms  ! 0D_NOT_logical
  logical :: f_remove_higher_order_terms
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: taylor_out
  type(taylor_struct_container_alloc), pointer :: f_taylor_out
  type(c_ptr), intent(in), value :: c0
  type(real_container_alloc), pointer :: f_c0
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor_in))   call c_f_pointer(taylor_in, f_taylor_in)
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor_out))   call c_f_pointer(taylor_out, f_taylor_out)
  !! container general array (1D_ALLOC_real)
  if (c_associated(c0))   call c_f_pointer(c0, f_c0)
  ! in: f_remove_higher_order_terms 0D_NOT_logical
  f_remove_higher_order_terms = remove_higher_order_terms
  call remove_constant_taylor(taylor_in=f_taylor_in%data, taylor_out=f_taylor_out%data, &
      c0=f_c0%data, remove_higher_order_terms=f_remove_higher_order_terms)

end subroutine
subroutine fortran_remove_dead_from_bunch (bunch_in, bunch_out) bind(c)

  use bmad_struct, only: bunch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: bunch_in  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch_in
  ! ** Out parameters **
  type(c_ptr), value :: bunch_out  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch_out
  ! ** End of parameters **
  ! in: f_bunch_in 0D_NOT_type
  if (.not. c_associated(bunch_in)) return
  call c_f_pointer(bunch_in, f_bunch_in)
  ! out: f_bunch_out 0D_NOT_type
  if (.not. c_associated(bunch_out)) return
  call c_f_pointer(bunch_out, f_bunch_out)
  call remove_dead_from_bunch(bunch_in=f_bunch_in, bunch_out=f_bunch_out)

  ! out: f_bunch_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_remove_eles_from_lat (lat, check_sanity) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: check_sanity  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_check_sanity
  logical, target :: f_check_sanity_native
  logical, pointer :: f_check_sanity_native_ptr
  logical(c_bool), pointer :: f_check_sanity_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_check_sanity 0D_NOT_logical
  if (c_associated(check_sanity)) then
    call c_f_pointer(check_sanity, f_check_sanity_ptr)
    f_check_sanity_native = f_check_sanity_ptr
    f_check_sanity_native_ptr => f_check_sanity_native
  else
    f_check_sanity_native_ptr => null()
  endif
  call remove_eles_from_lat(lat=f_lat, check_sanity=f_check_sanity_native_ptr)

end subroutine
subroutine fortran_remove_lord_slave_link (lord, slave) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lord  ! 0D_NOT_type
  type(ele_struct), pointer :: f_lord
  type(c_ptr), value :: slave  ! 0D_NOT_type
  type(ele_struct), pointer :: f_slave
  ! ** End of parameters **
  ! inout: f_lord 0D_NOT_type
  if (.not. c_associated(lord)) return
  call c_f_pointer(lord, f_lord)
  ! inout: f_slave 0D_NOT_type
  if (.not. c_associated(slave)) return
  call c_f_pointer(slave, f_slave)
  call remove_lord_slave_link(lord=f_lord, slave=f_slave)

end subroutine
subroutine fortran_reverse_lat (lat_in, lat_rev, track_antiparticle) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat_in  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_in
  type(c_ptr), intent(in), value :: track_antiparticle  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_track_antiparticle
  logical, target :: f_track_antiparticle_native
  logical, pointer :: f_track_antiparticle_native_ptr
  logical(c_bool), pointer :: f_track_antiparticle_ptr
  ! ** Out parameters **
  type(c_ptr), value :: lat_rev  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_rev
  ! ** End of parameters **
  ! in: f_lat_in 0D_NOT_type
  if (.not. c_associated(lat_in)) return
  call c_f_pointer(lat_in, f_lat_in)
  ! out: f_lat_rev 0D_NOT_type
  if (.not. c_associated(lat_rev)) return
  call c_f_pointer(lat_rev, f_lat_rev)
  ! in: f_track_antiparticle 0D_NOT_logical
  if (c_associated(track_antiparticle)) then
    call c_f_pointer(track_antiparticle, f_track_antiparticle_ptr)
    f_track_antiparticle_native = f_track_antiparticle_ptr
    f_track_antiparticle_native_ptr => f_track_antiparticle_native
  else
    f_track_antiparticle_native_ptr => null()
  endif
  call reverse_lat(lat_in=f_lat_in, lat_rev=f_lat_rev, &
      track_antiparticle=f_track_antiparticle_native_ptr)

  ! out: f_lat_rev 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_rf_coupler_kick (ele, param, particle_at, phase, orbit, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  real(c_double) :: phase  ! 0D_NOT_real
  real(rp) :: f_phase
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! in: f_phase 0D_NOT_real
  f_phase = phase
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call rf_coupler_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, phase=f_phase, &
      orbit=f_orbit, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_rf_is_on (branch, ix_ele1, ix_ele2, is_on) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), intent(in), value :: ix_ele1  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele1
  integer(c_int), pointer :: f_ix_ele1_ptr
  type(c_ptr), intent(in), value :: ix_ele2  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele2
  integer(c_int), pointer :: f_ix_ele2_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_on  ! 0D_NOT_logical
  logical :: f_is_on
  logical(c_bool), pointer :: f_is_on_ptr
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_ix_ele1 0D_NOT_integer
  if (c_associated(ix_ele1)) then
    call c_f_pointer(ix_ele1, f_ix_ele1_ptr)
  else
    f_ix_ele1_ptr => null()
  endif
  ! in: f_ix_ele2 0D_NOT_integer
  if (c_associated(ix_ele2)) then
    call c_f_pointer(ix_ele2, f_ix_ele2_ptr)
  else
    f_ix_ele2_ptr => null()
  endif
  f_is_on = rf_is_on(branch=f_branch, ix_ele1=f_ix_ele1_ptr, ix_ele2=f_ix_ele2_ptr)

  ! out: f_is_on 0D_NOT_logical
  call c_f_pointer(is_on, f_is_on_ptr)
  f_is_on_ptr = f_is_on
end subroutine
subroutine fortran_rf_ref_time_offset (ele, ds, time) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: ds  ! 0D_NOT_real
  real(c_double) :: f_ds
  real(c_double), pointer :: f_ds_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: time  ! 0D_NOT_real
  real(rp) :: f_time
  real(c_double), pointer :: f_time_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_ds 0D_NOT_real
  if (c_associated(ds)) then
    call c_f_pointer(ds, f_ds_ptr)
  else
    f_ds_ptr => null()
  endif
  f_time = rf_ref_time_offset(ele=f_ele, ds=f_ds_ptr)

  ! out: f_time 0D_NOT_real
  call c_f_pointer(time, f_time_ptr)
  f_time_ptr = f_time
end subroutine
subroutine fortran_rfun (u, v, w, gam, a, b, hz, i, j, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: u  ! 0D_NOT_real
  real(c_double) :: f_u
  real(c_double), pointer :: f_u_ptr
  type(c_ptr), intent(in), value :: v  ! 0D_NOT_real
  real(c_double) :: f_v
  real(c_double), pointer :: f_v_ptr
  type(c_ptr), intent(in), value :: w  ! 0D_NOT_real
  real(c_double) :: f_w
  real(c_double), pointer :: f_w_ptr
  type(c_ptr), intent(in), value :: gam  ! 0D_NOT_real
  real(c_double) :: f_gam
  real(c_double), pointer :: f_gam_ptr
  type(c_ptr), intent(in), value :: a  ! 0D_NOT_real
  real(c_double) :: f_a
  real(c_double), pointer :: f_a_ptr
  type(c_ptr), intent(in), value :: b  ! 0D_NOT_real
  real(c_double) :: f_b
  real(c_double), pointer :: f_b_ptr
  type(c_ptr), intent(in), value :: hz  ! 0D_NOT_real
  real(c_double) :: f_hz
  real(c_double), pointer :: f_hz_ptr
  type(c_ptr), intent(in), value :: i  ! 0D_NOT_integer
  integer(c_int) :: f_i
  integer(c_int), pointer :: f_i_ptr
  type(c_ptr), intent(in), value :: j  ! 0D_NOT_integer
  integer(c_int) :: f_j
  integer(c_int), pointer :: f_j_ptr
  ! ** End of parameters **
  ! inout: f_u 0D_NOT_real
  if (c_associated(u)) then
    call c_f_pointer(u, f_u_ptr)
  else
    f_u_ptr => null()
  endif
  ! inout: f_v 0D_NOT_real
  if (c_associated(v)) then
    call c_f_pointer(v, f_v_ptr)
  else
    f_v_ptr => null()
  endif
  ! inout: f_w 0D_NOT_real
  if (c_associated(w)) then
    call c_f_pointer(w, f_w_ptr)
  else
    f_w_ptr => null()
  endif
  ! inout: f_gam 0D_NOT_real
  if (c_associated(gam)) then
    call c_f_pointer(gam, f_gam_ptr)
  else
    f_gam_ptr => null()
  endif
  ! inout: f_a 0D_NOT_real
  if (c_associated(a)) then
    call c_f_pointer(a, f_a_ptr)
  else
    f_a_ptr => null()
  endif
  ! inout: f_b 0D_NOT_real
  if (c_associated(b)) then
    call c_f_pointer(b, f_b_ptr)
  else
    f_b_ptr => null()
  endif
  ! inout: f_hz 0D_NOT_real
  if (c_associated(hz)) then
    call c_f_pointer(hz, f_hz_ptr)
  else
    f_hz_ptr => null()
  endif
  ! inout: f_i 0D_NOT_integer
  if (c_associated(i)) then
    call c_f_pointer(i, f_i_ptr)
  else
    f_i_ptr => null()
  endif
  ! inout: f_j 0D_NOT_integer
  if (c_associated(j)) then
    call c_f_pointer(j, f_j_ptr)
  else
    f_j_ptr => null()
  endif
  f_res = rfun(u=f_u_ptr, v=f_v_ptr, w=f_w_ptr, gam=f_gam_ptr, a=f_a_ptr, b=f_b_ptr, &
      hz=f_hz_ptr, i=f_i_ptr, j=f_j_ptr)

  ! inout: f_u 0D_NOT_real
  ! no output conversion for f_u
  ! inout: f_v 0D_NOT_real
  ! no output conversion for f_v
  ! inout: f_w 0D_NOT_real
  ! no output conversion for f_w
  ! inout: f_gam 0D_NOT_real
  ! no output conversion for f_gam
  ! inout: f_a 0D_NOT_real
  ! no output conversion for f_a
  ! inout: f_b 0D_NOT_real
  ! no output conversion for f_b
  ! inout: f_hz 0D_NOT_real
  ! no output conversion for f_hz
  ! inout: f_i 0D_NOT_integer
  ! no output conversion for f_i
  ! inout: f_j 0D_NOT_integer
  ! no output conversion for f_j
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_rk_adaptive_time_step (ele, param, orb, t_dir, rf_time, dt_try, dt_did, &
    dt_next, err_flag, extra_field) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct, lat_param_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: t_dir  ! 0D_NOT_integer
  integer(c_int) :: f_t_dir
  integer(c_int), pointer :: f_t_dir_ptr
  type(c_ptr), intent(in), value :: rf_time  ! 0D_NOT_real
  real(c_double) :: f_rf_time
  real(c_double), pointer :: f_rf_time_ptr
  type(c_ptr), intent(in), value :: dt_try  ! 0D_NOT_real
  real(c_double) :: f_dt_try
  real(c_double), pointer :: f_dt_try_ptr
  type(c_ptr), intent(in), value :: dt_did  ! 0D_NOT_real
  real(c_double) :: f_dt_did
  real(c_double), pointer :: f_dt_did_ptr
  type(c_ptr), intent(in), value :: dt_next  ! 0D_NOT_real
  real(c_double) :: f_dt_next
  real(c_double), pointer :: f_dt_next_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: extra_field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_extra_field
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! inout: f_t_dir 0D_NOT_integer
  if (c_associated(t_dir)) then
    call c_f_pointer(t_dir, f_t_dir_ptr)
  else
    f_t_dir_ptr => null()
  endif
  ! inout: f_rf_time 0D_NOT_real
  if (c_associated(rf_time)) then
    call c_f_pointer(rf_time, f_rf_time_ptr)
  else
    f_rf_time_ptr => null()
  endif
  ! inout: f_dt_try 0D_NOT_real
  if (c_associated(dt_try)) then
    call c_f_pointer(dt_try, f_dt_try_ptr)
  else
    f_dt_try_ptr => null()
  endif
  ! inout: f_dt_did 0D_NOT_real
  if (c_associated(dt_did)) then
    call c_f_pointer(dt_did, f_dt_did_ptr)
  else
    f_dt_did_ptr => null()
  endif
  ! inout: f_dt_next 0D_NOT_real
  if (c_associated(dt_next)) then
    call c_f_pointer(dt_next, f_dt_next_ptr)
  else
    f_dt_next_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! inout: f_extra_field 0D_NOT_type
  if (c_associated(extra_field))   call c_f_pointer(extra_field, f_extra_field)
  call rk_adaptive_time_step(ele=f_ele, param=f_param, orb=f_orb, t_dir=f_t_dir_ptr, &
      rf_time=f_rf_time_ptr, dt_try=f_dt_try_ptr, dt_did=f_dt_did_ptr, dt_next=f_dt_next_ptr, &
      err_flag=f_err_flag_native_ptr, extra_field=f_extra_field)

  ! inout: f_t_dir 0D_NOT_integer
  ! no output conversion for f_t_dir
  ! inout: f_rf_time 0D_NOT_real
  ! no output conversion for f_rf_time
  ! inout: f_dt_try 0D_NOT_real
  ! no output conversion for f_dt_try
  ! inout: f_dt_did 0D_NOT_real
  ! no output conversion for f_dt_did
  ! inout: f_dt_next 0D_NOT_real
  ! no output conversion for f_dt_next
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_rk_time_step1 (ele, param, rf_time, orb, dt, new_orb, r_err, dr_dt, &
    err_flag, print_err, extra_field) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: rf_time  ! 0D_NOT_real
  real(rp) :: f_rf_time
  real(c_double) :: dt  ! 0D_NOT_real
  real(rp) :: f_dt
  type(c_ptr), intent(in), value :: dr_dt
  real(rp) :: f_dr_dt(10)
  real(c_double), pointer :: f_dr_dt_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: r_err
  real(rp) :: f_r_err(10)
  real(c_double), pointer :: f_r_err_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), value :: new_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_new_orb
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  type(c_ptr), value :: extra_field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_extra_field
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_rf_time 0D_NOT_real
  f_rf_time = rf_time
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_dt 0D_NOT_real
  f_dt = dt
  ! inout: f_new_orb 0D_NOT_type
  if (.not. c_associated(new_orb)) return
  call c_f_pointer(new_orb, f_new_orb)
  !! general array (1D_NOT_real)
  if (c_associated(dr_dt)) then
    call c_f_pointer(dr_dt, f_dr_dt_ptr, [10])
    f_dr_dt = f_dr_dt_ptr(:)
  else
    f_dr_dt_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! inout: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  ! inout: f_extra_field 0D_NOT_type
  if (c_associated(extra_field))   call c_f_pointer(extra_field, f_extra_field)
  call rk_time_step1(ele=f_ele, param=f_param, rf_time=f_rf_time, orb=f_orb, dt=f_dt, &
      new_orb=f_new_orb, r_err=f_r_err, dr_dt=f_dr_dt, err_flag=f_err_flag_native_ptr, &
      print_err=f_print_err_native_ptr, extra_field=f_extra_field)

  ! out: f_r_err 1D_NOT_real
  if (c_associated(r_err)) then
    call c_f_pointer(r_err, f_r_err_ptr, [10])
    f_r_err_ptr = f_r_err(:)
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
  ! inout: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_ptr = f_print_err_native
  else
    ! f_print_err unset
  endif
end subroutine
subroutine fortran_rotate3 (vec, angle, rvec) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: rvec
  real(rp) :: f_rvec(3)
  real(c_double), pointer :: f_rvec_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: vec
  real(rp) :: f_vec(3)
  real(c_double), pointer :: f_vec_ptr(:)
  type(c_ptr), intent(in), value :: angle  ! 0D_NOT_real
  real(c_double) :: f_angle
  real(c_double), pointer :: f_angle_ptr
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(vec)) then
    call c_f_pointer(vec, f_vec_ptr, [3])
    f_vec = f_vec_ptr(:)
  else
    f_vec_ptr => null()
  endif
  ! inout: f_angle 0D_NOT_real
  if (c_associated(angle)) then
    call c_f_pointer(angle, f_angle_ptr)
  else
    f_angle_ptr => null()
  endif
  f_rvec = rotate3(vec=f_vec, angle=f_angle_ptr)

  ! inout: f_angle 0D_NOT_real
  ! no output conversion for f_angle
  ! out: f_rvec 1D_NOT_real
  if (c_associated(rvec)) then
    call c_f_pointer(rvec, f_rvec_ptr, [3])
    f_rvec_ptr = f_rvec(:)
  endif
end subroutine
subroutine fortran_rotate_em_field (field, w_mat, w_inv, calc_dfield, calc_potential) bind(c)

  use bmad_struct, only: em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  type(c_ptr), intent(in), value :: w_inv
  real(rp) :: f_w_inv(3,3)
  real(c_double), pointer :: f_w_inv_ptr(:)
  type(c_ptr), intent(in), value :: calc_dfield  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_dfield
  logical, target :: f_calc_dfield_native
  logical, pointer :: f_calc_dfield_native_ptr
  logical(c_bool), pointer :: f_calc_dfield_ptr
  type(c_ptr), intent(in), value :: calc_potential  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_calc_potential
  logical, target :: f_calc_potential_native
  logical, pointer :: f_calc_potential_native_ptr
  logical(c_bool), pointer :: f_calc_potential_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  ! ** End of parameters **
  ! inout: f_field 0D_NOT_type
  if (.not. c_associated(field)) return
  call c_f_pointer(field, f_field)
  !! general array (2D_NOT_real)
  if (c_associated(w_mat)) then
    call c_f_pointer(w_mat, f_w_mat_ptr, [3*3])
    call vec2mat(f_w_mat_ptr, f_w_mat)
  else
    f_w_mat_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(w_inv)) then
    call c_f_pointer(w_inv, f_w_inv_ptr, [3*3])
    call vec2mat(f_w_inv_ptr, f_w_inv)
  else
    f_w_inv_ptr => null()
  endif
  ! in: f_calc_dfield 0D_NOT_logical
  if (c_associated(calc_dfield)) then
    call c_f_pointer(calc_dfield, f_calc_dfield_ptr)
    f_calc_dfield_native = f_calc_dfield_ptr
    f_calc_dfield_native_ptr => f_calc_dfield_native
  else
    f_calc_dfield_native_ptr => null()
  endif
  ! in: f_calc_potential 0D_NOT_logical
  if (c_associated(calc_potential)) then
    call c_f_pointer(calc_potential, f_calc_potential_ptr)
    f_calc_potential_native = f_calc_potential_ptr
    f_calc_potential_native_ptr => f_calc_potential_native
  else
    f_calc_potential_native_ptr => null()
  endif
  call rotate_em_field(field=f_field, w_mat=f_w_mat, w_inv=f_w_inv, &
      calc_dfield=f_calc_dfield_native_ptr, calc_potential=f_calc_potential_native_ptr)

end subroutine
subroutine fortran_rotate_field_zx (field, theta) bind(c)

  use bmad_struct, only: em_field_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  type(c_ptr), intent(in), value :: theta  ! 0D_NOT_real
  real(c_double) :: f_theta
  real(c_double), pointer :: f_theta_ptr
  ! ** End of parameters **
  ! inout: f_field 0D_NOT_type
  if (.not. c_associated(field)) return
  call c_f_pointer(field, f_field)
  ! inout: f_theta 0D_NOT_real
  if (c_associated(theta)) then
    call c_f_pointer(theta, f_theta_ptr)
  else
    f_theta_ptr => null()
  endif
  call rotate_field_zx(field=f_field, theta=f_theta_ptr)

  ! inout: f_theta 0D_NOT_real
  ! no output conversion for f_theta
end subroutine
subroutine fortran_rotate_for_curved_surface (ele, orbit, set, rot_mat) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: set  ! 0D_NOT_logical
  logical :: f_set
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: rot_mat
  real(rp) :: f_rot_mat(3,3)
  real(c_double), pointer :: f_rot_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_set 0D_NOT_logical
  f_set = set
  !! general array (2D_NOT_real)
  if (c_associated(rot_mat)) then
    call c_f_pointer(rot_mat, f_rot_mat_ptr, [3*3])
    call vec2mat(f_rot_mat_ptr, f_rot_mat)
  else
    f_rot_mat_ptr => null()
  endif
  call rotate_for_curved_surface(ele=f_ele, orbit=f_orbit, set=f_set, rot_mat=f_rot_mat)

end subroutine
subroutine fortran_rotate_spin (rot_vec, spin, qrot) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: rot_vec
  real(rp) :: f_rot_vec(3)
  real(c_double), pointer :: f_rot_vec_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: qrot
  real(rp) :: f_qrot(0:3)
  real(c_double), pointer :: f_qrot_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: spin
  real(rp) :: f_spin(3)
  real(c_double), pointer :: f_spin_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(rot_vec)) then
    call c_f_pointer(rot_vec, f_rot_vec_ptr, [3])
    f_rot_vec = f_rot_vec_ptr(:)
  else
    f_rot_vec_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(spin)) then
    call c_f_pointer(spin, f_spin_ptr, [3])
    f_spin = f_spin_ptr(:)
  else
    f_spin_ptr => null()
  endif
  call rotate_spin(rot_vec=f_rot_vec, spin=f_spin, qrot=f_qrot)

  ! out: f_qrot 1D_NOT_real
  if (c_associated(qrot)) then
    call c_f_pointer(qrot, f_qrot_ptr, [4])
    f_qrot_ptr = f_qrot(:)
  endif
end subroutine
subroutine fortran_rotate_spin_a_step (orbit, field, ele, ds) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: ds  ! 0D_NOT_real
  real(rp) :: f_ds
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_field 0D_NOT_type
  if (.not. c_associated(field)) return
  call c_f_pointer(field, f_field)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_ds 0D_NOT_real
  f_ds = ds
  call rotate_spin_a_step(orbit=f_orbit, field=f_field, ele=f_ele, ds=f_ds)

end subroutine
subroutine fortran_rotate_spin_given_field (orbit, sign_z_vel, BL, EL, qrot) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: sign_z_vel  ! 0D_NOT_integer
  integer :: f_sign_z_vel
  type(c_ptr), intent(in), value :: BL
  real(rp) :: f_BL(3)
  real(c_double), pointer :: f_BL_ptr(:)
  type(c_ptr), intent(in), value :: EL
  real(rp) :: f_EL(3)
  real(c_double), pointer :: f_EL_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: qrot
  real(rp) :: f_qrot(0:3)
  real(c_double), pointer :: f_qrot_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_sign_z_vel 0D_NOT_integer
  f_sign_z_vel = sign_z_vel
  !! general array (1D_NOT_real)
  if (c_associated(BL)) then
    call c_f_pointer(BL, f_BL_ptr, [3])
    f_BL = f_BL_ptr(:)
  else
    f_BL_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(EL)) then
    call c_f_pointer(EL, f_EL_ptr, [3])
    f_EL = f_EL_ptr(:)
  else
    f_EL_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(qrot)) then
    call c_f_pointer(qrot, f_qrot_ptr, [4])
    f_qrot = f_qrot_ptr(:)
  else
    f_qrot_ptr => null()
  endif
  call rotate_spin_given_field(orbit=f_orbit, sign_z_vel=f_sign_z_vel, BL=f_BL, EL=f_EL, &
      qrot=f_qrot)

end subroutine
subroutine fortran_s_body_calc (orbit, ele, s_body) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: s_body  ! 0D_NOT_real
  real(rp) :: f_s_body
  real(c_double), pointer :: f_s_body_ptr
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_s_body = s_body_calc(orbit=f_orbit, ele=f_ele)

  ! out: f_s_body 0D_NOT_real
  call c_f_pointer(s_body, f_s_body_ptr)
  f_s_body_ptr = f_s_body
end subroutine
subroutine fortran_s_calc (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call s_calc(lat=f_lat)

end subroutine
subroutine fortran_sad_mult_hard_bend_edge_kick (ele, param, particle_at, orbit, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call sad_mult_hard_bend_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, &
      orbit=f_orbit, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_sad_soft_bend_edge_kick (ele, param, particle_at, orb, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call sad_soft_bend_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, orb=f_orb, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_save_a_beam_step (ele, beam, bunch_tracks, s_body, is_time_coords) bind(c)

  use bmad_struct, only: beam_struct, bunch_track_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: bunch_tracks
  type(bunch_track_struct_container_alloc), pointer :: f_bunch_tracks
  type(c_ptr), intent(in), value :: s_body  ! 0D_NOT_real
  real(c_double) :: f_s_body
  real(c_double), pointer :: f_s_body_ptr
  type(c_ptr), intent(in), value :: is_time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_time_coords
  logical, target :: f_is_time_coords_native
  logical, pointer :: f_is_time_coords_native_ptr
  logical(c_bool), pointer :: f_is_time_coords_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  !! container type array (1D_ALLOC_type)
  if (c_associated(bunch_tracks))   call c_f_pointer(bunch_tracks, f_bunch_tracks)
  ! in: f_s_body 0D_NOT_real
  if (c_associated(s_body)) then
    call c_f_pointer(s_body, f_s_body_ptr)
  else
    f_s_body_ptr => null()
  endif
  ! in: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_native = f_is_time_coords_ptr
    f_is_time_coords_native_ptr => f_is_time_coords_native
  else
    f_is_time_coords_native_ptr => null()
  endif
  call save_a_beam_step(ele=f_ele, beam=f_beam, bunch_tracks=f_bunch_tracks%data, &
      s_body=f_s_body_ptr, is_time_coords=f_is_time_coords_native_ptr)

end subroutine
subroutine fortran_save_a_bunch_step (ele, bunch, bunch_track, s_body, is_time_coords) bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  type(c_ptr), intent(in), value :: s_body  ! 0D_NOT_real
  real(c_double) :: f_s_body
  real(c_double), pointer :: f_s_body_ptr
  type(c_ptr), intent(in), value :: is_time_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_time_coords
  logical, target :: f_is_time_coords_native
  logical, pointer :: f_is_time_coords_native_ptr
  logical(c_bool), pointer :: f_is_time_coords_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  ! in: f_s_body 0D_NOT_real
  if (c_associated(s_body)) then
    call c_f_pointer(s_body, f_s_body_ptr)
  else
    f_s_body_ptr => null()
  endif
  ! in: f_is_time_coords 0D_NOT_logical
  if (c_associated(is_time_coords)) then
    call c_f_pointer(is_time_coords, f_is_time_coords_ptr)
    f_is_time_coords_native = f_is_time_coords_ptr
    f_is_time_coords_native_ptr => f_is_time_coords_native
  else
    f_is_time_coords_native_ptr => null()
  endif
  call save_a_bunch_step(ele=f_ele, bunch=f_bunch, bunch_track=f_bunch_track, &
      s_body=f_s_body_ptr, is_time_coords=f_is_time_coords_native_ptr)

end subroutine
subroutine fortran_save_a_step (track, ele, param, local_ref_frame, orb, s_rel, save_field, &
    mat6, make_matrix, rf_time, strong_beam) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, strong_beam_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  logical(c_bool) :: local_ref_frame  ! 0D_NOT_logical
  logical :: f_local_ref_frame
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  real(c_double) :: s_rel  ! 0D_NOT_real
  real(rp) :: f_s_rel
  type(c_ptr), intent(in), value :: save_field  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save_field
  logical, target :: f_save_field_native
  logical, pointer :: f_save_field_native_ptr
  logical(c_bool), pointer :: f_save_field_ptr
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  type(c_ptr), intent(in), value :: rf_time  ! 0D_NOT_real
  real(c_double) :: f_rf_time
  real(c_double), pointer :: f_rf_time_ptr
  type(c_ptr), value :: strong_beam  ! 0D_NOT_type
  type(strong_beam_struct), pointer :: f_strong_beam
  ! ** End of parameters **
  ! in: f_track 0D_NOT_type
  if (.not. c_associated(track)) return
  call c_f_pointer(track, f_track)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_local_ref_frame 0D_NOT_logical
  f_local_ref_frame = local_ref_frame
  ! in: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_s_rel 0D_NOT_real
  f_s_rel = s_rel
  ! in: f_save_field 0D_NOT_logical
  if (c_associated(save_field)) then
    call c_f_pointer(save_field, f_save_field_ptr)
    f_save_field_native = f_save_field_ptr
    f_save_field_native_ptr => f_save_field_native
  else
    f_save_field_native_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  ! in: f_rf_time 0D_NOT_real
  if (c_associated(rf_time)) then
    call c_f_pointer(rf_time, f_rf_time_ptr)
  else
    f_rf_time_ptr => null()
  endif
  ! in: f_strong_beam 0D_NOT_type
  if (c_associated(strong_beam))   call c_f_pointer(strong_beam, f_strong_beam)
  call save_a_step(track=f_track, ele=f_ele, param=f_param, local_ref_frame=f_local_ref_frame, &
      orb=f_orb, s_rel=f_s_rel, save_field=f_save_field_native_ptr, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr, rf_time=f_rf_time_ptr, strong_beam=f_strong_beam)

end subroutine
subroutine fortran_sbend_body_with_k1_map (ele, dg, b1, param, n_step, orbit, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: dg  ! 0D_NOT_real
  real(rp) :: f_dg
  real(c_double) :: b1  ! 0D_NOT_real
  real(rp) :: f_b1
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: n_step  ! 0D_NOT_integer
  integer :: f_n_step
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_dg 0D_NOT_real
  f_dg = dg
  ! in: f_b1 0D_NOT_real
  f_b1 = b1
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_n_step 0D_NOT_integer
  f_n_step = n_step
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call sbend_body_with_k1_map(ele=f_ele, dg=f_dg, b1=f_b1, param=f_param, n_step=f_n_step, &
      orbit=f_orbit, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_sc_adaptive_step (bunch, ele, include_image, t_now, dt_step, dt_next, &
    sc_field) bind(c)

  use bmad_struct, only: bunch_struct, ele_struct, em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: t_now  ! 0D_NOT_real
  real(rp) :: f_t_now
  type(c_ptr), intent(in), value :: sc_field
  type(em_field_struct_container_alloc), pointer :: f_sc_field
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: dt_next  ! 0D_NOT_real
  real(rp) :: f_dt_next
  real(c_double), pointer :: f_dt_next_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), intent(in), value :: include_image  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_image
  logical, target :: f_include_image_native
  logical, pointer :: f_include_image_native_ptr
  logical(c_bool), pointer :: f_include_image_ptr
  type(c_ptr), intent(in), value :: dt_step  ! 0D_NOT_real
  real(c_double) :: f_dt_step
  real(c_double), pointer :: f_dt_step_ptr
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_include_image 0D_NOT_logical
  if (c_associated(include_image)) then
    call c_f_pointer(include_image, f_include_image_ptr)
    f_include_image_native = f_include_image_ptr
    f_include_image_native_ptr => f_include_image_native
  else
    f_include_image_native_ptr => null()
  endif
  ! in: f_t_now 0D_NOT_real
  f_t_now = t_now
  ! inout: f_dt_step 0D_NOT_real
  if (c_associated(dt_step)) then
    call c_f_pointer(dt_step, f_dt_step_ptr)
  else
    f_dt_step_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(sc_field))   call c_f_pointer(sc_field, f_sc_field)
  call sc_adaptive_step(bunch=f_bunch, ele=f_ele, include_image=f_include_image_native_ptr, &
      t_now=f_t_now, dt_step=f_dt_step_ptr, dt_next=f_dt_next, sc_field=f_sc_field%data)

  ! inout: f_include_image 0D_NOT_logical
  if (c_associated(include_image)) then
    call c_f_pointer(include_image, f_include_image_ptr)
    f_include_image_ptr = f_include_image_native
  else
    ! f_include_image unset
  endif
  ! inout: f_dt_step 0D_NOT_real
  ! no output conversion for f_dt_step
  ! out: f_dt_next 0D_NOT_real
  call c_f_pointer(dt_next, f_dt_next_ptr)
  f_dt_next_ptr = f_dt_next
end subroutine
subroutine fortran_sc_step (bunch, ele, include_image, t_end, sc_field, n_emit) bind(c)

  use bmad_struct, only: bunch_struct, ele_struct, em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: t_end  ! 0D_NOT_real
  real(rp) :: f_t_end
  type(c_ptr), intent(in), value :: sc_field
  type(em_field_struct_container_alloc), pointer :: f_sc_field
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: n_emit  ! 0D_NOT_integer
  integer :: f_n_emit
  integer(c_int), pointer :: f_n_emit_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), intent(in), value :: include_image  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_image
  logical, target :: f_include_image_native
  logical, pointer :: f_include_image_native_ptr
  logical(c_bool), pointer :: f_include_image_ptr
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_include_image 0D_NOT_logical
  if (c_associated(include_image)) then
    call c_f_pointer(include_image, f_include_image_ptr)
    f_include_image_native = f_include_image_ptr
    f_include_image_native_ptr => f_include_image_native
  else
    f_include_image_native_ptr => null()
  endif
  ! in: f_t_end 0D_NOT_real
  f_t_end = t_end
  !! container type array (1D_ALLOC_type)
  if (c_associated(sc_field))   call c_f_pointer(sc_field, f_sc_field)
  call sc_step(bunch=f_bunch, ele=f_ele, include_image=f_include_image_native_ptr, &
      t_end=f_t_end, sc_field=f_sc_field%data, n_emit=f_n_emit)

  ! inout: f_include_image 0D_NOT_logical
  if (c_associated(include_image)) then
    call c_f_pointer(include_image, f_include_image_ptr)
    f_include_image_ptr = f_include_image_native
  else
    ! f_include_image unset
  endif
  ! out: f_n_emit 0D_NOT_integer
  ! no output conversion for f_n_emit
end subroutine
subroutine fortran_set_active_fixer (fixer, is_on, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: is_on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_is_on
  logical, target :: f_is_on_native
  logical, pointer :: f_is_on_native_ptr
  logical(c_bool), pointer :: f_is_on_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** Inout parameters **
  type(c_ptr), value :: fixer  ! 0D_NOT_type
  type(ele_struct), pointer :: f_fixer
  ! ** End of parameters **
  ! inout: f_fixer 0D_NOT_type
  if (.not. c_associated(fixer)) return
  call c_f_pointer(fixer, f_fixer)
  ! in: f_is_on 0D_NOT_logical
  if (c_associated(is_on)) then
    call c_f_pointer(is_on, f_is_on_ptr)
    f_is_on_native = f_is_on_ptr
    f_is_on_native_ptr => f_is_on_native
  else
    f_is_on_native_ptr => null()
  endif
  ! out: f_orbit 0D_NOT_type
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  call set_active_fixer(fixer=f_fixer, is_on=f_is_on_native_ptr, orbit=f_orbit)

  ! out: f_orbit 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_set_custom_attribute_name (custom_name, err_flag, custom_index) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: custom_name
  character(len=4096), target :: f_custom_name
  character(kind=c_char), pointer :: f_custom_name_ptr(:)
  type(c_ptr), intent(in), value :: custom_index  ! 0D_NOT_integer
  integer(c_int) :: f_custom_index
  integer(c_int), pointer :: f_custom_index_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_custom_name 0D_NOT_character
  if (.not. c_associated(custom_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(custom_name, f_custom_name_ptr, [huge(0)])
  call to_f_str(f_custom_name_ptr, f_custom_name)
  ! in: f_custom_index 0D_NOT_integer
  if (c_associated(custom_index)) then
    call c_f_pointer(custom_index, f_custom_index_ptr)
  else
    f_custom_index_ptr => null()
  endif
  call set_custom_attribute_name(custom_name=f_custom_name, err_flag=f_err_flag, &
      custom_index=f_custom_index_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_set_ele_attribute (ele, set_string, err_flag, err_print_flag, set_lords, &
    err_id) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: set_string
  character(len=4096), target :: f_set_string
  character(kind=c_char), pointer :: f_set_string_ptr(:)
  type(c_ptr), intent(in), value :: err_print_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_print_flag
  logical, target :: f_err_print_flag_native
  logical, pointer :: f_err_print_flag_native_ptr
  logical(c_bool), pointer :: f_err_print_flag_ptr
  type(c_ptr), intent(in), value :: set_lords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_lords
  logical, target :: f_set_lords_native
  logical, pointer :: f_set_lords_native_ptr
  logical(c_bool), pointer :: f_set_lords_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: err_id  ! 0D_NOT_integer
  integer :: f_err_id
  integer(c_int), pointer :: f_err_id_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_set_string 0D_NOT_character
  if (.not. c_associated(set_string)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(set_string, f_set_string_ptr, [huge(0)])
  call to_f_str(f_set_string_ptr, f_set_string)
  ! in: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_native = f_err_print_flag_ptr
    f_err_print_flag_native_ptr => f_err_print_flag_native
  else
    f_err_print_flag_native_ptr => null()
  endif
  ! in: f_set_lords 0D_NOT_logical
  if (c_associated(set_lords)) then
    call c_f_pointer(set_lords, f_set_lords_ptr)
    f_set_lords_native = f_set_lords_ptr
    f_set_lords_native_ptr => f_set_lords_native
  else
    f_set_lords_native_ptr => null()
  endif
  call set_ele_attribute(ele=f_ele, set_string=f_set_string, err_flag=f_err_flag, &
      err_print_flag=f_err_print_flag_native_ptr, set_lords=f_set_lords_native_ptr, &
      err_id=f_err_id)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_err_id 0D_NOT_integer
  ! no output conversion for f_err_id
end subroutine
subroutine fortran_set_ele_defaults (ele, do_allocate) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: do_allocate  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_do_allocate
  logical, target :: f_do_allocate_native
  logical, pointer :: f_do_allocate_native_ptr
  logical(c_bool), pointer :: f_do_allocate_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_do_allocate 0D_NOT_logical
  if (c_associated(do_allocate)) then
    call c_f_pointer(do_allocate, f_do_allocate_ptr)
    f_do_allocate_native = f_do_allocate_ptr
    f_do_allocate_native_ptr => f_do_allocate_native
  else
    f_do_allocate_native_ptr => null()
  endif
  call set_ele_defaults(ele=f_ele, do_allocate=f_do_allocate_native_ptr)

end subroutine
subroutine fortran_set_ele_name (ele, name) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  call set_ele_name(ele=f_ele, name=f_name)

end subroutine
subroutine fortran_set_ele_real_attribute (ele, attrib_name, value, err_flag, err_print_flag) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  real(c_double) :: value  ! 0D_NOT_real
  real(rp) :: f_value
  type(c_ptr), intent(in), value :: err_print_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_print_flag
  logical, target :: f_err_print_flag_native
  logical, pointer :: f_err_print_flag_native_ptr
  logical(c_bool), pointer :: f_err_print_flag_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! in: f_value 0D_NOT_real
  f_value = value
  ! in: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_native = f_err_print_flag_ptr
    f_err_print_flag_native_ptr => f_err_print_flag_native
  else
    f_err_print_flag_native_ptr => null()
  endif
  call set_ele_real_attribute(ele=f_ele, attrib_name=f_attrib_name, value=f_value, &
      err_flag=f_err_flag, err_print_flag=f_err_print_flag_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_set_ele_status_stale (ele, status_group, set_slaves) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: status_group  ! 0D_NOT_integer
  integer :: f_status_group
  integer(c_int), pointer :: f_status_group_ptr
  type(c_ptr), intent(in), value :: set_slaves  ! 0D_NOT_logical
  logical :: f_set_slaves
  logical(c_bool), pointer :: f_set_slaves_ptr
  ! ** End of parameters **
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call set_ele_status_stale(ele=f_ele, status_group=f_status_group, set_slaves=f_set_slaves)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_status_group 0D_NOT_integer
  call c_f_pointer(status_group, f_status_group_ptr)
  f_status_group_ptr = f_status_group
  ! out: f_set_slaves 0D_NOT_logical
  ! no output conversion for f_set_slaves
end subroutine
subroutine fortran_set_emit_from_beam_init (beam_init_in, ele, species, modes, err_flag, &
    beam_init_set) bind(c)

  use bmad_struct, only: beam_init_struct, ele_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: beam_init_in  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init_in
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: species  ! 0D_NOT_integer
  integer :: f_species
  type(c_ptr), value :: modes  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_modes
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Out parameters **
  type(c_ptr), value :: beam_init_set  ! 0D_NOT_type
  type(beam_init_struct), pointer :: f_beam_init_set
  ! ** End of parameters **
  ! in: f_beam_init_in 0D_NOT_type
  if (.not. c_associated(beam_init_in)) return
  call c_f_pointer(beam_init_in, f_beam_init_in)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_species 0D_NOT_integer
  f_species = species
  ! in: f_modes 0D_NOT_type
  if (c_associated(modes))   call c_f_pointer(modes, f_modes)
  ! in: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  f_beam_init_set = set_emit_from_beam_init(beam_init_in=f_beam_init_in, ele=f_ele, &
      species=f_species, modes=f_modes, err_flag=f_err_flag_native_ptr)

  ! out: f_beam_init_set 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_set_flags_for_changed_integer_attribute (ele, attrib, set_dependent) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: set_dependent  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_dependent
  logical, target :: f_set_dependent_native
  logical, pointer :: f_set_dependent_native_ptr
  logical(c_bool), pointer :: f_set_dependent_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: attrib  ! 0D_NOT_integer
  integer(c_int) :: f_attrib
  integer(c_int), pointer :: f_attrib_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_attrib 0D_NOT_integer
  if (c_associated(attrib)) then
    call c_f_pointer(attrib, f_attrib_ptr)
  else
    f_attrib_ptr => null()
  endif
  ! in: f_set_dependent 0D_NOT_logical
  if (c_associated(set_dependent)) then
    call c_f_pointer(set_dependent, f_set_dependent_ptr)
    f_set_dependent_native = f_set_dependent_ptr
    f_set_dependent_native_ptr => f_set_dependent_native
  else
    f_set_dependent_native_ptr => null()
  endif
  call set_flags_for_changed_integer_attribute(ele=f_ele, attrib=f_attrib_ptr, &
      set_dependent=f_set_dependent_native_ptr)

  ! inout: f_attrib 0D_NOT_integer
  ! no output conversion for f_attrib
end subroutine
subroutine fortran_set_flags_for_changed_lat_attribute (lat, set_dependent) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: set_dependent  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_dependent
  logical, target :: f_set_dependent_native
  logical, pointer :: f_set_dependent_native_ptr
  logical(c_bool), pointer :: f_set_dependent_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_set_dependent 0D_NOT_logical
  if (c_associated(set_dependent)) then
    call c_f_pointer(set_dependent, f_set_dependent_ptr)
    f_set_dependent_native = f_set_dependent_ptr
    f_set_dependent_native_ptr => f_set_dependent_native
  else
    f_set_dependent_native_ptr => null()
  endif
  call set_flags_for_changed_lat_attribute(lat=f_lat, set_dependent=f_set_dependent_native_ptr)

end subroutine
subroutine fortran_set_flags_for_changed_logical_attribute (ele, attrib, set_dependent) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: set_dependent  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_dependent
  logical, target :: f_set_dependent_native
  logical, pointer :: f_set_dependent_native_ptr
  logical(c_bool), pointer :: f_set_dependent_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: attrib  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_attrib
  logical, target :: f_attrib_native
  logical, pointer :: f_attrib_native_ptr
  logical(c_bool), pointer :: f_attrib_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_attrib 0D_NOT_logical
  if (c_associated(attrib)) then
    call c_f_pointer(attrib, f_attrib_ptr)
    f_attrib_native = f_attrib_ptr
    f_attrib_native_ptr => f_attrib_native
  else
    f_attrib_native_ptr => null()
  endif
  ! in: f_set_dependent 0D_NOT_logical
  if (c_associated(set_dependent)) then
    call c_f_pointer(set_dependent, f_set_dependent_ptr)
    f_set_dependent_native = f_set_dependent_ptr
    f_set_dependent_native_ptr => f_set_dependent_native
  else
    f_set_dependent_native_ptr => null()
  endif
  call set_flags_for_changed_logical_attribute(ele=f_ele, attrib=f_attrib_native_ptr, &
      set_dependent=f_set_dependent_native_ptr)

  ! inout: f_attrib 0D_NOT_logical
  if (c_associated(attrib)) then
    call c_f_pointer(attrib, f_attrib_ptr)
    f_attrib_ptr = f_attrib_native
  else
    ! f_attrib unset
  endif
end subroutine
subroutine fortran_set_flags_for_changed_real_attribute (ele, attrib, set_dependent) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: set_dependent  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_set_dependent
  logical, target :: f_set_dependent_native
  logical, pointer :: f_set_dependent_native_ptr
  logical(c_bool), pointer :: f_set_dependent_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: attrib  ! 0D_NOT_real
  real(c_double) :: f_attrib
  real(c_double), pointer :: f_attrib_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_attrib 0D_NOT_real
  if (c_associated(attrib)) then
    call c_f_pointer(attrib, f_attrib_ptr)
  else
    f_attrib_ptr => null()
  endif
  ! in: f_set_dependent 0D_NOT_logical
  if (c_associated(set_dependent)) then
    call c_f_pointer(set_dependent, f_set_dependent_ptr)
    f_set_dependent_native = f_set_dependent_ptr
    f_set_dependent_native_ptr => f_set_dependent_native
  else
    f_set_dependent_native_ptr => null()
  endif
  call set_flags_for_changed_real_attribute(ele=f_ele, attrib=f_attrib_ptr, &
      set_dependent=f_set_dependent_native_ptr)

  ! inout: f_attrib 0D_NOT_real
  ! no output conversion for f_attrib
end subroutine
subroutine fortran_set_fringe_on_off (fringe_at, ele_end, on_or_off) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: ele_end  ! 0D_NOT_integer
  integer :: f_ele_end
  integer(c_int) :: on_or_off  ! 0D_NOT_integer
  integer :: f_on_or_off
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: fringe_at  ! 0D_NOT_real
  real(c_double) :: f_fringe_at
  real(c_double), pointer :: f_fringe_at_ptr
  ! ** End of parameters **
  ! inout: f_fringe_at 0D_NOT_real
  if (c_associated(fringe_at)) then
    call c_f_pointer(fringe_at, f_fringe_at_ptr)
  else
    f_fringe_at_ptr => null()
  endif
  ! in: f_ele_end 0D_NOT_integer
  f_ele_end = ele_end
  ! in: f_on_or_off 0D_NOT_integer
  f_on_or_off = on_or_off
  call set_fringe_on_off(fringe_at=f_fringe_at_ptr, ele_end=f_ele_end, on_or_off=f_on_or_off)

  ! inout: f_fringe_at 0D_NOT_real
  ! no output conversion for f_fringe_at
end subroutine
subroutine fortran_set_lords_status_stale (ele, stat_group, control_bookkeeping, flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: stat_group  ! 0D_NOT_integer
  integer :: f_stat_group
  type(c_ptr), intent(in), value :: control_bookkeeping  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_control_bookkeeping
  logical, target :: f_control_bookkeeping_native
  logical, pointer :: f_control_bookkeeping_native_ptr
  logical(c_bool), pointer :: f_control_bookkeeping_ptr
  type(c_ptr), intent(in), value :: flag  ! 0D_NOT_integer
  integer(c_int) :: f_flag
  integer(c_int), pointer :: f_flag_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_stat_group 0D_NOT_integer
  f_stat_group = stat_group
  ! in: f_control_bookkeeping 0D_NOT_logical
  if (c_associated(control_bookkeeping)) then
    call c_f_pointer(control_bookkeeping, f_control_bookkeeping_ptr)
    f_control_bookkeeping_native = f_control_bookkeeping_ptr
    f_control_bookkeeping_native_ptr => f_control_bookkeeping_native
  else
    f_control_bookkeeping_native_ptr => null()
  endif
  ! in: f_flag 0D_NOT_integer
  if (c_associated(flag)) then
    call c_f_pointer(flag, f_flag_ptr)
  else
    f_flag_ptr => null()
  endif
  call set_lords_status_stale(ele=f_ele, stat_group=f_stat_group, &
      control_bookkeeping=f_control_bookkeeping_native_ptr, flag=f_flag_ptr)

end subroutine
subroutine fortran_set_on_off (key, lat, switch_, orb, use_ref_orb, ix_branch, saved_values, &
    attribute, set_val) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: key  ! 0D_NOT_integer
  integer :: f_key
  integer(c_int) :: switch_  ! 0D_NOT_integer
  integer :: f_switch
  type(c_ptr), intent(in), value :: orb
  type(coord_struct_container_alloc), pointer :: f_orb
  type(c_ptr), intent(in), value :: use_ref_orb  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_ref_orb
  logical, target :: f_use_ref_orb_native
  logical, pointer :: f_use_ref_orb_native_ptr
  logical(c_bool), pointer :: f_use_ref_orb_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: attribute
  character(len=4096), target :: f_attribute
  character(kind=c_char), pointer :: f_attribute_ptr(:)
  character(len=4096), pointer :: f_attribute_call_ptr
  type(c_ptr), intent(in), value :: set_val  ! 0D_NOT_integer
  integer(c_int) :: f_set_val
  integer(c_int), pointer :: f_set_val_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: saved_values
  type(real_container_alloc), pointer :: f_saved_values
  ! ** End of parameters **
  ! in: f_key 0D_NOT_integer
  f_key = key
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_switch 0D_NOT_integer
  f_switch = switch_
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb))   call c_f_pointer(orb, f_orb)
  ! in: f_use_ref_orb 0D_NOT_logical
  if (c_associated(use_ref_orb)) then
    call c_f_pointer(use_ref_orb, f_use_ref_orb_ptr)
    f_use_ref_orb_native = f_use_ref_orb_ptr
    f_use_ref_orb_native_ptr => f_use_ref_orb_native
  else
    f_use_ref_orb_native_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  !! container general array (1D_ALLOC_real)
  if (c_associated(saved_values))   call c_f_pointer(saved_values, f_saved_values)
  ! in: f_attribute 0D_NOT_character
  if (c_associated(attribute)) then
    call c_f_pointer(attribute, f_attribute_ptr, [huge(0)])
    call to_f_str(f_attribute_ptr, f_attribute)
    f_attribute_call_ptr => f_attribute
  else
    f_attribute_call_ptr => null()
  endif
  ! in: f_set_val 0D_NOT_integer
  if (c_associated(set_val)) then
    call c_f_pointer(set_val, f_set_val_ptr)
  else
    f_set_val_ptr => null()
  endif
  call set_on_off(key=f_key, lat=f_lat, switch=f_switch, orb=f_orb%data, &
      use_ref_orb=f_use_ref_orb_native_ptr, ix_branch=f_ix_branch_ptr, &
      saved_values=f_saved_values%data, attribute=f_attribute_call_ptr, set_val=f_set_val_ptr)

end subroutine
subroutine fortran_set_orbit_to_zero (orbit, n1, n2, ix_noset) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: n1  ! 0D_NOT_integer
  integer :: f_n1
  integer(c_int) :: n2  ! 0D_NOT_integer
  integer :: f_n2
  type(c_ptr), intent(in), value :: ix_noset  ! 0D_NOT_integer
  integer(c_int) :: f_ix_noset
  integer(c_int), pointer :: f_ix_noset_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  ! in: f_n1 0D_NOT_integer
  f_n1 = n1
  ! in: f_n2 0D_NOT_integer
  f_n2 = n2
  ! in: f_ix_noset 0D_NOT_integer
  if (c_associated(ix_noset)) then
    call c_f_pointer(ix_noset, f_ix_noset_ptr)
  else
    f_ix_noset_ptr => null()
  endif
  call set_orbit_to_zero(orbit=f_orbit%data, n1=f_n1, n2=f_n2, ix_noset=f_ix_noset_ptr)

end subroutine
subroutine fortran_set_ptc (e_tot, particle, taylor_order, integ_order, n_step, no_cavity, &
    force_init) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: e_tot  ! 0D_NOT_real
  real(c_double) :: f_e_tot
  real(c_double), pointer :: f_e_tot_ptr
  type(c_ptr), intent(in), value :: particle  ! 0D_NOT_integer
  integer(c_int) :: f_particle
  integer(c_int), pointer :: f_particle_ptr
  type(c_ptr), intent(in), value :: taylor_order  ! 0D_NOT_integer
  integer(c_int) :: f_taylor_order
  integer(c_int), pointer :: f_taylor_order_ptr
  type(c_ptr), intent(in), value :: integ_order  ! 0D_NOT_integer
  integer(c_int) :: f_integ_order
  integer(c_int), pointer :: f_integ_order_ptr
  type(c_ptr), intent(in), value :: n_step  ! 0D_NOT_integer
  integer(c_int) :: f_n_step
  integer(c_int), pointer :: f_n_step_ptr
  type(c_ptr), intent(in), value :: no_cavity  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_no_cavity
  logical, target :: f_no_cavity_native
  logical, pointer :: f_no_cavity_native_ptr
  logical(c_bool), pointer :: f_no_cavity_ptr
  type(c_ptr), intent(in), value :: force_init  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_force_init
  logical, target :: f_force_init_native
  logical, pointer :: f_force_init_native_ptr
  logical(c_bool), pointer :: f_force_init_ptr
  ! ** End of parameters **
  ! in: f_e_tot 0D_NOT_real
  if (c_associated(e_tot)) then
    call c_f_pointer(e_tot, f_e_tot_ptr)
  else
    f_e_tot_ptr => null()
  endif
  ! in: f_particle 0D_NOT_integer
  if (c_associated(particle)) then
    call c_f_pointer(particle, f_particle_ptr)
  else
    f_particle_ptr => null()
  endif
  ! in: f_taylor_order 0D_NOT_integer
  if (c_associated(taylor_order)) then
    call c_f_pointer(taylor_order, f_taylor_order_ptr)
  else
    f_taylor_order_ptr => null()
  endif
  ! in: f_integ_order 0D_NOT_integer
  if (c_associated(integ_order)) then
    call c_f_pointer(integ_order, f_integ_order_ptr)
  else
    f_integ_order_ptr => null()
  endif
  ! in: f_n_step 0D_NOT_integer
  if (c_associated(n_step)) then
    call c_f_pointer(n_step, f_n_step_ptr)
  else
    f_n_step_ptr => null()
  endif
  ! in: f_no_cavity 0D_NOT_logical
  if (c_associated(no_cavity)) then
    call c_f_pointer(no_cavity, f_no_cavity_ptr)
    f_no_cavity_native = f_no_cavity_ptr
    f_no_cavity_native_ptr => f_no_cavity_native
  else
    f_no_cavity_native_ptr => null()
  endif
  ! in: f_force_init 0D_NOT_logical
  if (c_associated(force_init)) then
    call c_f_pointer(force_init, f_force_init_ptr)
    f_force_init_native = f_force_init_ptr
    f_force_init_native_ptr => f_force_init_native
  else
    f_force_init_native_ptr => null()
  endif
  call set_ptc(e_tot=f_e_tot_ptr, particle=f_particle_ptr, taylor_order=f_taylor_order_ptr, &
      integ_order=f_integ_order_ptr, n_step=f_n_step_ptr, no_cavity=f_no_cavity_native_ptr, &
      force_init=f_force_init_native_ptr)

end subroutine
subroutine fortran_set_ptc_base_state (component, set_val, old_val) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: component
  character(len=4096), target :: f_component
  character(kind=c_char), pointer :: f_component_ptr(:)
  logical(c_bool) :: set_val  ! 0D_NOT_logical
  logical :: f_set_val
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: old_val  ! 0D_NOT_logical
  logical :: f_old_val
  logical(c_bool), pointer :: f_old_val_ptr
  ! ** End of parameters **
  ! in: f_component 0D_NOT_character
  if (.not. c_associated(component)) return
  call c_f_pointer(component, f_component_ptr, [huge(0)])
  call to_f_str(f_component_ptr, f_component)
  ! in: f_set_val 0D_NOT_logical
  f_set_val = set_val
  call set_ptc_base_state(component=f_component, set_val=f_set_val, old_val=f_old_val)

  ! out: f_old_val 0D_NOT_logical
  ! no output conversion for f_old_val
end subroutine
subroutine fortran_set_ptc_com_pointers () bind(c)

  implicit none
  ! ** End of parameters **
  call set_ptc_com_pointers()

end subroutine
subroutine fortran_set_ptc_quiet (channel, set, old_val) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: channel  ! 0D_NOT_integer
  integer :: f_channel
  logical(c_bool) :: set  ! 0D_NOT_logical
  logical :: f_set
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: old_val  ! 0D_NOT_integer
  integer(c_int) :: f_old_val
  integer(c_int), pointer :: f_old_val_ptr
  ! ** End of parameters **
  ! in: f_channel 0D_NOT_integer
  f_channel = channel
  ! in: f_set 0D_NOT_logical
  f_set = set
  ! inout: f_old_val 0D_NOT_integer
  if (c_associated(old_val)) then
    call c_f_pointer(old_val, f_old_val_ptr)
  else
    f_old_val_ptr => null()
  endif
  call set_ptc_quiet(channel=f_channel, set=f_set, old_val=f_old_val_ptr)

  ! inout: f_old_val 0D_NOT_integer
  ! no output conversion for f_old_val
end subroutine
subroutine fortran_set_ptc_verbose (on) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: on  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_on
  logical, target :: f_on_native
  logical, pointer :: f_on_native_ptr
  logical(c_bool), pointer :: f_on_ptr
  ! ** End of parameters **
  ! inout: f_on 0D_NOT_logical
  if (c_associated(on)) then
    call c_f_pointer(on, f_on_ptr)
    f_on_native = f_on_ptr
    f_on_native_ptr => f_on_native
  else
    f_on_native_ptr => null()
  endif
  call set_ptc_verbose(on=f_on_native_ptr)

  ! inout: f_on 0D_NOT_logical
  if (c_associated(on)) then
    call c_f_pointer(on, f_on_ptr)
    f_on_ptr = f_on_native
  else
    ! f_on unset
  endif
end subroutine
subroutine fortran_set_pwd_ele (lat, mode0, inductance) bind(c)

  use bmad_struct, only: lat_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: mode0  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode0
  real(c_double) :: inductance  ! 0D_NOT_real
  real(rp) :: f_inductance
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_mode0 0D_NOT_type
  if (.not. c_associated(mode0)) return
  call c_f_pointer(mode0, f_mode0)
  ! in: f_inductance 0D_NOT_real
  f_inductance = inductance
  call set_pwd_ele(lat=f_lat, mode0=f_mode0, inductance=f_inductance)

end subroutine
subroutine fortran_set_status_flags (bookkeeping_state, stat) bind(c)

  use bmad_struct, only: bookkeeping_state_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: stat  ! 0D_NOT_integer
  integer :: f_stat
  ! ** Out parameters **
  type(c_ptr), value :: bookkeeping_state  ! 0D_NOT_type
  type(bookkeeping_state_struct), pointer :: f_bookkeeping_state
  ! ** End of parameters **
  ! out: f_bookkeeping_state 0D_NOT_type
  if (.not. c_associated(bookkeeping_state)) return
  call c_f_pointer(bookkeeping_state, f_bookkeeping_state)
  ! in: f_stat 0D_NOT_integer
  f_stat = stat
  call set_status_flags(bookkeeping_state=f_bookkeeping_state, stat=f_stat)

  ! out: f_bookkeeping_state 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_set_tune (phi_a_set, phi_b_set, dk1, eles, branch, orb, print_err, ok) &
    bind(c)

  use bmad_struct, only: branch_struct, coord_struct, ele_pointer_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: phi_a_set  ! 0D_NOT_real
  real(rp) :: f_phi_a_set
  real(c_double) :: phi_b_set  ! 0D_NOT_real
  real(rp) :: f_phi_b_set
  type(c_ptr), intent(in), value :: dk1
  type(real_container_alloc), pointer :: f_dk1
  type(c_ptr), intent(in), value :: eles
  type(ele_pointer_struct_container_alloc), pointer :: f_eles
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ok  ! 0D_NOT_logical
  logical :: f_ok
  logical(c_bool), pointer :: f_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), intent(in), value :: orb
  type(coord_struct_container_alloc), pointer :: f_orb
  ! ** End of parameters **
  ! in: f_phi_a_set 0D_NOT_real
  f_phi_a_set = phi_a_set
  ! in: f_phi_b_set 0D_NOT_real
  f_phi_b_set = phi_b_set
  !! container general array (1D_ALLOC_real)
  if (c_associated(dk1))   call c_f_pointer(dk1, f_dk1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(eles))   call c_f_pointer(eles, f_eles)
  ! inout: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb))   call c_f_pointer(orb, f_orb)
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  f_ok = set_tune(phi_a_set=f_phi_a_set, phi_b_set=f_phi_b_set, dk1=f_dk1%data, &
      eles=f_eles%data, branch=f_branch, orb=f_orb%data, print_err=f_print_err_native_ptr)

  ! out: f_ok 0D_NOT_logical
  call c_f_pointer(ok, f_ok_ptr)
  f_ok_ptr = f_ok
end subroutine
subroutine fortran_set_twiss (branch, twiss_ele, ix_ele, match_deta_ds, err_flag, print_err) &
    bind(c)

  use bmad_struct, only: branch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), value :: twiss_ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_twiss_ele
  integer(c_int) :: ix_ele  ! 0D_NOT_integer
  integer :: f_ix_ele
  logical(c_bool) :: match_deta_ds  ! 0D_NOT_logical
  logical :: f_match_deta_ds
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_twiss_ele 0D_NOT_type
  if (.not. c_associated(twiss_ele)) return
  call c_f_pointer(twiss_ele, f_twiss_ele)
  ! in: f_ix_ele 0D_NOT_integer
  f_ix_ele = ix_ele
  ! in: f_match_deta_ds 0D_NOT_logical
  f_match_deta_ds = match_deta_ds
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call set_twiss(branch=f_branch, twiss_ele=f_twiss_ele, ix_ele=f_ix_ele, &
      match_deta_ds=f_match_deta_ds, err_flag=f_err_flag, print_err=f_print_err_native_ptr)

end subroutine
subroutine fortran_set_z_tune (branch, z_tune, ok, print_err) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: z_tune  ! 0D_NOT_real
  real(rp) :: f_z_tune
  type(c_ptr), intent(in), value :: print_err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_print_err
  logical, target :: f_print_err_native
  logical, pointer :: f_print_err_native_ptr
  logical(c_bool), pointer :: f_print_err_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ok  ! 0D_NOT_logical
  logical :: f_ok
  logical(c_bool), pointer :: f_ok_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** End of parameters **
  ! inout: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_z_tune 0D_NOT_real
  f_z_tune = z_tune
  ! in: f_print_err 0D_NOT_logical
  if (c_associated(print_err)) then
    call c_f_pointer(print_err, f_print_err_ptr)
    f_print_err_native = f_print_err_ptr
    f_print_err_native_ptr => f_print_err_native
  else
    f_print_err_native_ptr => null()
  endif
  call set_z_tune(branch=f_branch, z_tune=f_z_tune, ok=f_ok, print_err=f_print_err_native_ptr)

  ! out: f_ok 0D_NOT_logical
  ! no output conversion for f_ok
end subroutine
subroutine fortran_settable_dep_var_bookkeeping (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call settable_dep_var_bookkeeping(ele=f_ele)

end subroutine
subroutine fortran_setup_high_energy_space_charge_calc (calc_on, branch, n_part, mode, &
    closed_orb) bind(c)

  use bmad_struct, only: branch_struct, coord_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  logical(c_bool) :: calc_on  ! 0D_NOT_logical
  logical :: f_calc_on
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  real(c_double) :: n_part  ! 0D_NOT_real
  real(rp) :: f_n_part
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  type(c_ptr), intent(in), value :: closed_orb
  type(coord_struct_container_alloc), pointer :: f_closed_orb
  ! ** End of parameters **
  ! in: f_calc_on 0D_NOT_logical
  f_calc_on = calc_on
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_n_part 0D_NOT_real
  f_n_part = n_part
  ! in: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  !! container type array (1D_ALLOC_type)
  if (c_associated(closed_orb))   call c_f_pointer(closed_orb, f_closed_orb)
  call setup_high_energy_space_charge_calc(calc_on=f_calc_on, branch=f_branch, n_part=f_n_part, &
      mode=f_mode, closed_orb=f_closed_orb%data)

end subroutine
subroutine fortran_sigma_mat_ptc_to_bmad (sigma_mat_ptc, beta0, sigma_mat_bmad) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: sigma_mat_ptc
  real(rp) :: f_sigma_mat_ptc(6,6)
  real(c_double), pointer :: f_sigma_mat_ptc_ptr(:)
  real(c_double) :: beta0  ! 0D_NOT_real
  real(rp) :: f_beta0
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: sigma_mat_bmad
  real(rp) :: f_sigma_mat_bmad(6,6)
  real(c_double), pointer :: f_sigma_mat_bmad_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(sigma_mat_ptc)) then
    call c_f_pointer(sigma_mat_ptc, f_sigma_mat_ptc_ptr, [6*6])
    call vec2mat(f_sigma_mat_ptc_ptr, f_sigma_mat_ptc)
  else
    f_sigma_mat_ptc_ptr => null()
  endif
  ! in: f_beta0 0D_NOT_real
  f_beta0 = beta0
  call sigma_mat_ptc_to_bmad(sigma_mat_ptc=f_sigma_mat_ptc, beta0=f_beta0, &
      sigma_mat_bmad=f_sigma_mat_bmad)

  ! out: f_sigma_mat_bmad 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_sigma_mat_bmad', c_name='sigma_mat_bmad', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=1331, definition='real(rp) sigma_mat_bmad(6,6), sigma_mat_ptc(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='sigma_mat_bmad', comment='', default=None), intent='out', description='Bmad sigma matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_significant_difference (value1, value2, abs_tol, rel_tol, is_different) &
    bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: value1  ! 0D_NOT_real
  real(rp) :: f_value1
  real(c_double) :: value2  ! 0D_NOT_real
  real(rp) :: f_value2
  type(c_ptr), intent(in), value :: abs_tol  ! 0D_NOT_real
  real(c_double) :: f_abs_tol
  real(c_double), pointer :: f_abs_tol_ptr
  type(c_ptr), intent(in), value :: rel_tol  ! 0D_NOT_real
  real(c_double) :: f_rel_tol
  real(c_double), pointer :: f_rel_tol_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_different  ! 0D_NOT_logical
  logical :: f_is_different
  logical(c_bool), pointer :: f_is_different_ptr
  ! ** End of parameters **
  ! in: f_value1 0D_NOT_real
  f_value1 = value1
  ! in: f_value2 0D_NOT_real
  f_value2 = value2
  ! in: f_abs_tol 0D_NOT_real
  if (c_associated(abs_tol)) then
    call c_f_pointer(abs_tol, f_abs_tol_ptr)
  else
    f_abs_tol_ptr => null()
  endif
  ! in: f_rel_tol 0D_NOT_real
  if (c_associated(rel_tol)) then
    call c_f_pointer(rel_tol, f_rel_tol_ptr)
  else
    f_rel_tol_ptr => null()
  endif
  f_is_different = significant_difference(value1=f_value1, value2=f_value2, &
      abs_tol=f_abs_tol_ptr, rel_tol=f_rel_tol_ptr)

  ! out: f_is_different 0D_NOT_logical
  call c_f_pointer(is_different, f_is_different_ptr)
  f_is_different_ptr = f_is_different
end subroutine
subroutine fortran_skip_ele_blender (ele, skip) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: skip  ! 0D_NOT_logical
  logical :: f_skip
  logical(c_bool), pointer :: f_skip_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_skip = skip_ele_blender(ele=f_ele)

  ! out: f_skip 0D_NOT_logical
  call c_f_pointer(skip, f_skip_ptr)
  f_skip_ptr = f_skip
end subroutine
subroutine fortran_slice_lattice (lat, ele_list, error, do_bookkeeping) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ele_list
  character(len=4096), target :: f_ele_list
  character(kind=c_char), pointer :: f_ele_list_ptr(:)
  type(c_ptr), intent(in), value :: do_bookkeeping  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_do_bookkeeping
  logical, target :: f_do_bookkeeping_native
  logical, pointer :: f_do_bookkeeping_native_ptr
  logical(c_bool), pointer :: f_do_bookkeeping_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ele_list 0D_NOT_character
  if (.not. c_associated(ele_list)) return
  call c_f_pointer(ele_list, f_ele_list_ptr, [huge(0)])
  call to_f_str(f_ele_list_ptr, f_ele_list)
  ! in: f_do_bookkeeping 0D_NOT_logical
  if (c_associated(do_bookkeeping)) then
    call c_f_pointer(do_bookkeeping, f_do_bookkeeping_ptr)
    f_do_bookkeeping_native = f_do_bookkeeping_ptr
    f_do_bookkeeping_native_ptr => f_do_bookkeeping_native
  else
    f_do_bookkeeping_native_ptr => null()
  endif
  call slice_lattice(lat=f_lat, ele_list=f_ele_list, error=f_error, &
      do_bookkeeping=f_do_bookkeeping_native_ptr)

  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
end subroutine
subroutine fortran_soft_quadrupole_edge_kick (ele, param, particle_at, orbit, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  integer(c_int) :: particle_at  ! 0D_NOT_integer
  integer :: f_particle_at
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_particle_at 0D_NOT_integer
  f_particle_at = particle_at
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call soft_quadrupole_edge_kick(ele=f_ele, param=f_param, particle_at=f_particle_at, &
      orbit=f_orbit, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_sol_quad_mat6_calc (ks_in, k1_in, tilt, length, ele, orbit, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: tilt  ! 0D_NOT_real
  real(rp) :: f_tilt
  real(c_double) :: length  ! 0D_NOT_real
  real(rp) :: f_length
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: ks_in  ! 0D_NOT_real
  real(c_double) :: f_ks_in
  real(c_double), pointer :: f_ks_in_ptr
  type(c_ptr), intent(in), value :: k1_in  ! 0D_NOT_real
  real(c_double) :: f_k1_in
  real(c_double), pointer :: f_k1_in_ptr
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_ks_in 0D_NOT_real
  if (c_associated(ks_in)) then
    call c_f_pointer(ks_in, f_ks_in_ptr)
  else
    f_ks_in_ptr => null()
  endif
  ! inout: f_k1_in 0D_NOT_real
  if (c_associated(k1_in)) then
    call c_f_pointer(k1_in, f_k1_in_ptr)
  else
    f_k1_in_ptr => null()
  endif
  ! in: f_tilt 0D_NOT_real
  f_tilt = tilt
  ! in: f_length 0D_NOT_real
  f_length = length
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call sol_quad_mat6_calc(ks_in=f_ks_in_ptr, k1_in=f_k1_in_ptr, tilt=f_tilt, length=f_length, &
      ele=f_ele, orbit=f_orbit, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

  ! inout: f_ks_in 0D_NOT_real
  ! no output conversion for f_ks_in
  ! inout: f_k1_in 0D_NOT_real
  ! no output conversion for f_k1_in
end subroutine
subroutine fortran_solve_psi_adaptive (t0, t1, p0, args, p1) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: t0  ! 0D_NOT_real
  REAL(c_double) :: f_t0
  real(c_double) :: t1  ! 0D_NOT_real
  REAL(c_double) :: f_t1
  real(c_double) :: p0  ! 0D_NOT_real
  REAL(rp) :: f_p0
  type(c_ptr), intent(in), value :: args
  REAL(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: p1  ! 0D_NOT_real
  REAL(rp) :: f_p1
  real(c_double), pointer :: f_p1_ptr
  ! ** End of parameters **
  ! in: f_t0 0D_NOT_real
  f_t0 = t0
  ! in: f_t1 0D_NOT_real
  f_t1 = t1
  ! in: f_p0 0D_NOT_real
  f_p0 = p0
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  call solve_psi_adaptive(t0=f_t0, t1=f_t1, p0=f_p0, args=f_args, p1=f_p1)

  ! out: f_p1 0D_NOT_real
  call c_f_pointer(p1, f_p1_ptr)
  f_p1_ptr = f_p1
end subroutine
subroutine fortran_solve_psi_fixed_steps (t0, t1, p0, args, t, p) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: t0  ! 0D_NOT_real
  REAL(rp) :: f_t0
  real(c_double) :: t1  ! 0D_NOT_real
  REAL(rp) :: f_t1
  real(c_double) :: p0  ! 0D_NOT_real
  REAL(rp) :: f_p0
  type(c_ptr), intent(in), value :: args
  REAL(rp) :: f_args(1:8)
  real(c_double), pointer :: f_args_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: t
  type(real_container_alloc), pointer :: f_t
  type(c_ptr), intent(in), value :: p
  type(real_container_alloc), pointer :: f_p
  ! ** End of parameters **
  ! in: f_t0 0D_NOT_real
  f_t0 = t0
  ! in: f_t1 0D_NOT_real
  f_t1 = t1
  ! in: f_p0 0D_NOT_real
  f_p0 = p0
  !! general array (1D_NOT_real)
  if (c_associated(args)) then
    call c_f_pointer(args, f_args_ptr, [8])
    f_args = f_args_ptr(:)
  else
    f_args_ptr => null()
  endif
  !! container general array (1D_ALLOC_real)
  if (c_associated(t))   call c_f_pointer(t, f_t)
  !! container general array (1D_ALLOC_real)
  if (c_associated(p))   call c_f_pointer(p, f_p)
  call solve_psi_fixed_steps(t0=f_t0, t1=f_t1, p0=f_p0, args=f_args, t=f_t%data, p=f_p%data)

end subroutine
subroutine fortran_sort_complex_taylor_terms (complex_taylor_in, complex_taylor_sorted) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: complex_taylor_in  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor_in
  ! ** Out parameters **
  type(c_ptr), value :: complex_taylor_sorted  ! 0D_NOT_type
  type(complex_taylor_struct), pointer :: f_complex_taylor_sorted
  ! ** End of parameters **
  ! in: f_complex_taylor_in 0D_NOT_type
  if (.not. c_associated(complex_taylor_in)) return
  call c_f_pointer(complex_taylor_in, f_complex_taylor_in)
  ! out: f_complex_taylor_sorted 0D_NOT_type
  if (.not. c_associated(complex_taylor_sorted)) return
  call c_f_pointer(complex_taylor_sorted, f_complex_taylor_sorted)
  call sort_complex_taylor_terms(complex_taylor_in=f_complex_taylor_in, &
      complex_taylor_sorted=f_complex_taylor_sorted)

  ! out: f_complex_taylor_sorted 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_spin_dn_dpz_from_mat8 (mat_1turn, dn_dpz_partial, error, dn_dpz) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: mat_1turn
  real(rp) :: f_mat_1turn(8,8)
  real(c_double), pointer :: f_mat_1turn_ptr(:)
  type(c_ptr), intent(in), value :: dn_dpz_partial
  real(rp) :: f_dn_dpz_partial(3,3)
  real(c_double), pointer :: f_dn_dpz_partial_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  type(c_ptr), intent(in), value :: dn_dpz
  real(rp) :: f_dn_dpz(3)
  real(c_double), pointer :: f_dn_dpz_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(mat_1turn)) then
    call c_f_pointer(mat_1turn, f_mat_1turn_ptr, [8*8])
    call vec2mat(f_mat_1turn_ptr, f_mat_1turn)
  else
    f_mat_1turn_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(dn_dpz_partial)) then
    call c_f_pointer(dn_dpz_partial, f_dn_dpz_partial_ptr, [3*3])
    call vec2mat(f_dn_dpz_partial_ptr, f_dn_dpz_partial)
  else
    f_dn_dpz_partial_ptr => null()
  endif
  f_dn_dpz = spin_dn_dpz_from_mat8(mat_1turn=f_mat_1turn, dn_dpz_partial=f_dn_dpz_partial, &
      error=f_error)

  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
  ! out: f_dn_dpz 1D_NOT_real
  if (c_associated(dn_dpz)) then
    call c_f_pointer(dn_dpz, f_dn_dpz_ptr, [3])
    f_dn_dpz_ptr = f_dn_dpz(:)
  endif
end subroutine
subroutine fortran_spin_dn_dpz_from_qmap (orb_mat, q_map, dn_dpz_partial, dn_dpz_partial2, &
    error, n0, dn_dpz) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: orb_mat
  real(rp) :: f_orb_mat(6,6)
  real(c_double), pointer :: f_orb_mat_ptr(:)
  type(c_ptr), intent(in), value :: q_map
  real(rp) :: f_q_map(0:3,0:6)
  real(c_double), pointer :: f_q_map_ptr(:)
  type(c_ptr), intent(in), value :: dn_dpz_partial
  real(rp) :: f_dn_dpz_partial(3,3)
  real(c_double), pointer :: f_dn_dpz_partial_ptr(:)
  type(c_ptr), intent(in), value :: dn_dpz_partial2
  real(rp) :: f_dn_dpz_partial2(3,3)
  real(c_double), pointer :: f_dn_dpz_partial2_ptr(:)
  type(c_ptr), intent(in), value :: n0
  real(rp) :: f_n0(3)
  real(c_double), pointer :: f_n0_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  type(c_ptr), intent(in), value :: dn_dpz
  real(rp) :: f_dn_dpz(3)
  real(c_double), pointer :: f_dn_dpz_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(orb_mat)) then
    call c_f_pointer(orb_mat, f_orb_mat_ptr, [6*6])
    call vec2mat(f_orb_mat_ptr, f_orb_mat)
  else
    f_orb_mat_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(q_map)) then
    call c_f_pointer(q_map, f_q_map_ptr, [4*7])
    call vec2mat(f_q_map_ptr, f_q_map)
  else
    f_q_map_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(dn_dpz_partial)) then
    call c_f_pointer(dn_dpz_partial, f_dn_dpz_partial_ptr, [3*3])
    call vec2mat(f_dn_dpz_partial_ptr, f_dn_dpz_partial)
  else
    f_dn_dpz_partial_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(dn_dpz_partial2)) then
    call c_f_pointer(dn_dpz_partial2, f_dn_dpz_partial2_ptr, [3*3])
    call vec2mat(f_dn_dpz_partial2_ptr, f_dn_dpz_partial2)
  else
    f_dn_dpz_partial2_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(n0)) then
    call c_f_pointer(n0, f_n0_ptr, [3])
    f_n0 = f_n0_ptr(:)
  else
    f_n0_ptr => null()
  endif
  f_dn_dpz = spin_dn_dpz_from_qmap(orb_mat=f_orb_mat, q_map=f_q_map, &
      dn_dpz_partial=f_dn_dpz_partial, dn_dpz_partial2=f_dn_dpz_partial2, error=f_error, &
      n0=f_n0)

  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
  ! out: f_dn_dpz 1D_NOT_real
  if (c_associated(dn_dpz)) then
    call c_f_pointer(dn_dpz, f_dn_dpz_ptr, [3])
    f_dn_dpz_ptr = f_dn_dpz(:)
  endif
end subroutine
subroutine fortran_spin_map1_normalize (spin1) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: spin1
  real(rp) :: f_spin1(0:3,0:6)
  real(c_double), pointer :: f_spin1_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(spin1)) then
    call c_f_pointer(spin1, f_spin1_ptr, [4*7])
    call vec2mat(f_spin1_ptr, f_spin1)
  else
    f_spin1_ptr => null()
  endif
  call spin_map1_normalize(spin1=f_spin1)

end subroutine
subroutine fortran_spin_mat8_resonance_strengths (orb_evec, mat8, xi_sum, xi_diff) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: orb_evec
  complex(rp) :: f_orb_evec(6)
  complex(c_double_complex), pointer :: f_orb_evec_ptr(:)
  type(c_ptr), intent(in), value :: mat8
  real(rp) :: f_mat8(6,6)
  real(c_double), pointer :: f_mat8_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: xi_sum  ! 0D_NOT_real
  real(rp) :: f_xi_sum
  real(c_double), pointer :: f_xi_sum_ptr
  type(c_ptr), intent(in), value :: xi_diff  ! 0D_NOT_real
  real(rp) :: f_xi_diff
  real(c_double), pointer :: f_xi_diff_ptr
  ! ** End of parameters **
  !! general array (1D_NOT_complex)
  if (c_associated(orb_evec)) then
    call c_f_pointer(orb_evec, f_orb_evec_ptr, [6])
    f_orb_evec = f_orb_evec_ptr(:)
  else
    f_orb_evec_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(mat8)) then
    call c_f_pointer(mat8, f_mat8_ptr, [6*6])
    call vec2mat(f_mat8_ptr, f_mat8)
  else
    f_mat8_ptr => null()
  endif
  call spin_mat8_resonance_strengths(orb_evec=f_orb_evec, mat8=f_mat8, xi_sum=f_xi_sum, &
      xi_diff=f_xi_diff)

  ! out: f_xi_sum 0D_NOT_real
  call c_f_pointer(xi_sum, f_xi_sum_ptr)
  f_xi_sum_ptr = f_xi_sum
  ! out: f_xi_diff 0D_NOT_real
  call c_f_pointer(xi_diff, f_xi_diff_ptr)
  f_xi_diff_ptr = f_xi_diff
end subroutine
subroutine fortran_spin_mat_to_eigen (orb_mat, spin_map, orb_eval, orb_evec, n0, spin_evec, &
    error) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: orb_mat
  real(rp) :: f_orb_mat(6,6)
  real(c_double), pointer :: f_orb_mat_ptr(:)
  type(c_ptr), intent(in), value :: spin_map
  real(rp) :: f_spin_map(0:3,0:6)
  real(c_double), pointer :: f_spin_map_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: orb_eval
  complex(rp) :: f_orb_eval(6)
  complex(c_double_complex), pointer :: f_orb_eval_ptr(:)
  type(c_ptr), intent(in), value :: orb_evec
  complex(rp) :: f_orb_evec(6,6)
  complex(c_double_complex), pointer :: f_orb_evec_ptr(:)
  type(c_ptr), intent(in), value :: n0
  real(rp) :: f_n0(3)
  real(c_double), pointer :: f_n0_ptr(:)
  type(c_ptr), intent(in), value :: spin_evec
  complex(rp) :: f_spin_evec(6,3)
  complex(c_double_complex), pointer :: f_spin_evec_ptr(:)
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(orb_mat)) then
    call c_f_pointer(orb_mat, f_orb_mat_ptr, [6*6])
    call vec2mat(f_orb_mat_ptr, f_orb_mat)
  else
    f_orb_mat_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(spin_map)) then
    call c_f_pointer(spin_map, f_spin_map_ptr, [4*7])
    call vec2mat(f_spin_map_ptr, f_spin_map)
  else
    f_spin_map_ptr => null()
  endif
  call spin_mat_to_eigen(orb_mat=f_orb_mat, spin_map=f_spin_map, orb_eval=f_orb_eval, &
      orb_evec=f_orb_evec, n0=f_n0, spin_evec=f_spin_evec, error=f_error)

  ! out: f_orb_eval 1D_NOT_complex
  if (c_associated(orb_eval)) then
    call c_f_pointer(orb_eval, f_orb_eval_ptr, [6])
    f_orb_eval_ptr = f_orb_eval(:)
  endif
  ! out: f_orb_evec 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_orb_evec', c_name='orb_evec', type='complex', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=2799, definition='complex(rp) orb_eval(6), orb_evec(6,6), spin_evec(6,3)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='orb_evec', comment='', default=None), intent='out', description='Orbital eigenvectors. orb_evec(j,:) is the j^th vector.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_n0 1D_NOT_real
  if (c_associated(n0)) then
    call c_f_pointer(n0, f_n0_ptr, [3])
    f_n0_ptr = f_n0(:)
  endif
  ! out: f_spin_evec 2D_NOT_complex
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_spin_evec', c_name='spin_evec', type='complex', kind='rp', pointer_type='NOT', array=['6', '3'], init_value=None, comment='', member=StructureMember(line=2799, definition='complex(rp) orb_eval(6), orb_evec(6,6), spin_evec(6,3)', type_info=TypeInformation(type='complex', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='spin_evec', comment='', default=None), intent='out', description='Spin eigenvectors. spin_evec(j,:) is the j^th vector.', doc_data_type='complex', doc_is_optional=False)
  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
end subroutine
subroutine fortran_spin_omega (field, orbit, sign_z_vel, phase_space_coords, omega) bind(c)

  use bmad_struct, only: coord_struct, em_field_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: omega
  real(rp) :: f_omega(3)
  real(c_double), pointer :: f_omega_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: field  ! 0D_NOT_type
  type(em_field_struct), pointer :: f_field
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: sign_z_vel  ! 0D_NOT_integer
  integer(c_int) :: f_sign_z_vel
  integer(c_int), pointer :: f_sign_z_vel_ptr
  type(c_ptr), intent(in), value :: phase_space_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_phase_space_coords
  logical, target :: f_phase_space_coords_native
  logical, pointer :: f_phase_space_coords_native_ptr
  logical(c_bool), pointer :: f_phase_space_coords_ptr
  ! ** End of parameters **
  ! inout: f_field 0D_NOT_type
  if (.not. c_associated(field)) return
  call c_f_pointer(field, f_field)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! inout: f_sign_z_vel 0D_NOT_integer
  if (c_associated(sign_z_vel)) then
    call c_f_pointer(sign_z_vel, f_sign_z_vel_ptr)
  else
    f_sign_z_vel_ptr => null()
  endif
  ! inout: f_phase_space_coords 0D_NOT_logical
  if (c_associated(phase_space_coords)) then
    call c_f_pointer(phase_space_coords, f_phase_space_coords_ptr)
    f_phase_space_coords_native = f_phase_space_coords_ptr
    f_phase_space_coords_native_ptr => f_phase_space_coords_native
  else
    f_phase_space_coords_native_ptr => null()
  endif
  f_omega = spin_omega(field=f_field, orbit=f_orbit, sign_z_vel=f_sign_z_vel_ptr, &
      phase_space_coords=f_phase_space_coords_native_ptr)

  ! inout: f_sign_z_vel 0D_NOT_integer
  ! no output conversion for f_sign_z_vel
  ! inout: f_phase_space_coords 0D_NOT_logical
  if (c_associated(phase_space_coords)) then
    call c_f_pointer(phase_space_coords, f_phase_space_coords_ptr)
    f_phase_space_coords_ptr = f_phase_space_coords_native
  else
    ! f_phase_space_coords unset
  endif
  ! out: f_omega 1D_NOT_real
  if (c_associated(omega)) then
    call c_f_pointer(omega, f_omega_ptr, [3])
    f_omega_ptr = f_omega(:)
  endif
end subroutine
subroutine fortran_spin_quat_resonance_strengths (orb_evec, spin_q, xi_sum, xi_diff) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: orb_evec
  complex(rp) :: f_orb_evec(6)
  complex(c_double_complex), pointer :: f_orb_evec_ptr(:)
  type(c_ptr), intent(in), value :: spin_q
  real(rp) :: f_spin_q(0:3,0:6)
  real(c_double), pointer :: f_spin_q_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: xi_sum  ! 0D_NOT_real
  real(rp) :: f_xi_sum
  real(c_double), pointer :: f_xi_sum_ptr
  type(c_ptr), intent(in), value :: xi_diff  ! 0D_NOT_real
  real(rp) :: f_xi_diff
  real(c_double), pointer :: f_xi_diff_ptr
  ! ** End of parameters **
  !! general array (1D_NOT_complex)
  if (c_associated(orb_evec)) then
    call c_f_pointer(orb_evec, f_orb_evec_ptr, [6])
    f_orb_evec = f_orb_evec_ptr(:)
  else
    f_orb_evec_ptr => null()
  endif
  !! general array (2D_NOT_real)
  if (c_associated(spin_q)) then
    call c_f_pointer(spin_q, f_spin_q_ptr, [4*7])
    call vec2mat(f_spin_q_ptr, f_spin_q)
  else
    f_spin_q_ptr => null()
  endif
  call spin_quat_resonance_strengths(orb_evec=f_orb_evec, spin_q=f_spin_q, xi_sum=f_xi_sum, &
      xi_diff=f_xi_diff)

  ! out: f_xi_sum 0D_NOT_real
  call c_f_pointer(xi_sum, f_xi_sum_ptr)
  f_xi_sum_ptr = f_xi_sum
  ! out: f_xi_diff 0D_NOT_real
  call c_f_pointer(xi_diff, f_xi_diff_ptr)
  f_xi_diff_ptr = f_xi_diff
end subroutine
subroutine fortran_spin_taylor_to_linear (spin_taylor, normalize, dref_orb, is_on, spin_map1) &
    bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: spin_taylor
  type(taylor_struct), pointer :: f_spin_taylor(:)
  logical(c_bool) :: normalize  ! 0D_NOT_logical
  logical :: f_normalize
  type(c_ptr), intent(in), value :: dref_orb
  real(rp) :: f_dref_orb(6)
  real(c_double), pointer :: f_dref_orb_ptr(:)
  logical(c_bool) :: is_on  ! 0D_NOT_logical
  logical :: f_is_on
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: spin_map1
  real(rp) :: f_spin_map1(0:3,0:6)
  real(c_double), pointer :: f_spin_map1_ptr(:)
  ! ** End of parameters **
  !! type array (1D_NOT_type)
  call c_f_pointer(spin_taylor, f_spin_taylor, [4])
  ! in: f_normalize 0D_NOT_logical
  f_normalize = normalize
  !! general array (1D_NOT_real)
  if (c_associated(dref_orb)) then
    call c_f_pointer(dref_orb, f_dref_orb_ptr, [6])
    f_dref_orb = f_dref_orb_ptr(:)
  else
    f_dref_orb_ptr => null()
  endif
  ! in: f_is_on 0D_NOT_logical
  f_is_on = is_on
  f_spin_map1 = spin_taylor_to_linear(spin_taylor=f_spin_taylor, normalize=f_normalize, &
      dref_orb=f_dref_orb, is_on=f_is_on)

  ! out: f_spin_map1 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_spin_map1', c_name='spin_map1', type='real', kind='rp', pointer_type='NOT', array=['0:3', '0:6'], init_value=None, comment='', member=StructureMember(line=2832, definition='real(rp) dref_orb(6), spin_map1(0:3,0:6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='0:3,0:6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='spin_map1', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_spinor_to_polar (spinor, polar) bind(c)

  use bmad_struct, only: spin_polar_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: spinor
  complex(rp) :: f_spinor(2)
  complex(c_double_complex), pointer :: f_spinor_ptr(:)
  ! ** Out parameters **
  type(c_ptr), value :: polar  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_polar
  ! ** End of parameters **
  !! general array (1D_NOT_complex)
  if (c_associated(spinor)) then
    call c_f_pointer(spinor, f_spinor_ptr, [2])
    f_spinor = f_spinor_ptr(:)
  else
    f_spinor_ptr => null()
  endif
  f_polar = spinor_to_polar(spinor=f_spinor)

  ! out: f_polar 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_spinor_to_vec (spinor, vec) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: spinor
  complex(rp) :: f_spinor(2)
  complex(c_double_complex), pointer :: f_spinor_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: vec
  real(rp) :: f_vec(3)
  real(c_double), pointer :: f_vec_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_complex)
  if (c_associated(spinor)) then
    call c_f_pointer(spinor, f_spinor_ptr, [2])
    f_spinor = f_spinor_ptr(:)
  else
    f_spinor_ptr => null()
  endif
  f_vec = spinor_to_vec(spinor=f_spinor)

  ! out: f_vec 1D_NOT_real
  if (c_associated(vec)) then
    call c_f_pointer(vec, f_vec_ptr, [3])
    f_vec_ptr = f_vec(:)
  endif
end subroutine
subroutine fortran_spline_fit_orbit (start_orb, end_orb, spline_x, spline_y) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), intent(in), value :: spline_x
  real(rp) :: f_spline_x(0:3)
  real(c_double), pointer :: f_spline_x_ptr(:)
  type(c_ptr), intent(in), value :: spline_y
  real(rp) :: f_spline_y(0:3)
  real(c_double), pointer :: f_spline_y_ptr(:)
  ! ** End of parameters **
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! in: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  !! general array (1D_NOT_real)
  if (c_associated(spline_x)) then
    call c_f_pointer(spline_x, f_spline_x_ptr, [4])
    f_spline_x = f_spline_x_ptr(:)
  else
    f_spline_x_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(spline_y)) then
    call c_f_pointer(spline_y, f_spline_y_ptr, [4])
    f_spline_y = f_spline_y_ptr(:)
  else
    f_spline_y_ptr => null()
  endif
  call spline_fit_orbit(start_orb=f_start_orb, end_orb=f_end_orb, spline_x=f_spline_x, &
      spline_y=f_spline_y)

end subroutine
subroutine fortran_split_lat (lat, s_split, ix_branch, ix_split, split_done, add_suffix, &
    check_sanity, save_null_drift, err_flag, choose_max, ix_insert) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: s_split  ! 0D_NOT_real
  real(rp) :: f_s_split
  integer(c_int) :: ix_branch  ! 0D_NOT_integer
  integer :: f_ix_branch
  type(c_ptr), intent(in), value :: add_suffix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_add_suffix
  logical, target :: f_add_suffix_native
  logical, pointer :: f_add_suffix_native_ptr
  logical(c_bool), pointer :: f_add_suffix_ptr
  type(c_ptr), intent(in), value :: check_sanity  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_check_sanity
  logical, target :: f_check_sanity_native
  logical, pointer :: f_check_sanity_native_ptr
  logical(c_bool), pointer :: f_check_sanity_ptr
  type(c_ptr), intent(in), value :: save_null_drift  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_save_null_drift
  logical, target :: f_save_null_drift_native
  logical, pointer :: f_save_null_drift_native_ptr
  logical(c_bool), pointer :: f_save_null_drift_ptr
  type(c_ptr), intent(in), value :: choose_max  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_choose_max
  logical, target :: f_choose_max_native
  logical, pointer :: f_choose_max_native_ptr
  logical(c_bool), pointer :: f_choose_max_ptr
  type(c_ptr), intent(in), value :: ix_insert  ! 0D_NOT_integer
  integer(c_int) :: f_ix_insert
  integer(c_int), pointer :: f_ix_insert_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ix_split  ! 0D_NOT_integer
  integer :: f_ix_split
  integer(c_int), pointer :: f_ix_split_ptr
  type(c_ptr), intent(in), value :: split_done  ! 0D_NOT_logical
  logical :: f_split_done
  logical(c_bool), pointer :: f_split_done_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_s_split 0D_NOT_real
  f_s_split = s_split
  ! in: f_ix_branch 0D_NOT_integer
  f_ix_branch = ix_branch
  ! in: f_add_suffix 0D_NOT_logical
  if (c_associated(add_suffix)) then
    call c_f_pointer(add_suffix, f_add_suffix_ptr)
    f_add_suffix_native = f_add_suffix_ptr
    f_add_suffix_native_ptr => f_add_suffix_native
  else
    f_add_suffix_native_ptr => null()
  endif
  ! in: f_check_sanity 0D_NOT_logical
  if (c_associated(check_sanity)) then
    call c_f_pointer(check_sanity, f_check_sanity_ptr)
    f_check_sanity_native = f_check_sanity_ptr
    f_check_sanity_native_ptr => f_check_sanity_native
  else
    f_check_sanity_native_ptr => null()
  endif
  ! in: f_save_null_drift 0D_NOT_logical
  if (c_associated(save_null_drift)) then
    call c_f_pointer(save_null_drift, f_save_null_drift_ptr)
    f_save_null_drift_native = f_save_null_drift_ptr
    f_save_null_drift_native_ptr => f_save_null_drift_native
  else
    f_save_null_drift_native_ptr => null()
  endif
  ! in: f_choose_max 0D_NOT_logical
  if (c_associated(choose_max)) then
    call c_f_pointer(choose_max, f_choose_max_ptr)
    f_choose_max_native = f_choose_max_ptr
    f_choose_max_native_ptr => f_choose_max_native
  else
    f_choose_max_native_ptr => null()
  endif
  ! in: f_ix_insert 0D_NOT_integer
  if (c_associated(ix_insert)) then
    call c_f_pointer(ix_insert, f_ix_insert_ptr)
  else
    f_ix_insert_ptr => null()
  endif
  call split_lat(lat=f_lat, s_split=f_s_split, ix_branch=f_ix_branch, ix_split=f_ix_split, &
      split_done=f_split_done, add_suffix=f_add_suffix_native_ptr, &
      check_sanity=f_check_sanity_native_ptr, save_null_drift=f_save_null_drift_native_ptr, &
      err_flag=f_err_flag, choose_max=f_choose_max_native_ptr, ix_insert=f_ix_insert_ptr)

  ! out: f_ix_split 0D_NOT_integer
  call c_f_pointer(ix_split, f_ix_split_ptr)
  f_ix_split_ptr = f_ix_split
  ! out: f_split_done 0D_NOT_logical
  call c_f_pointer(split_done, f_split_done_ptr)
  f_split_done_ptr = f_split_done
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_sprint_spin_taylor_map (ele, start_orbit) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: start_orbit
  real(rp) :: f_start_orbit(6)
  real(c_double), pointer :: f_start_orbit_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! general array (1D_NOT_real)
  if (c_associated(start_orbit)) then
    call c_f_pointer(start_orbit, f_start_orbit_ptr, [6])
    f_start_orbit = f_start_orbit_ptr(:)
  else
    f_start_orbit_ptr => null()
  endif
  call sprint_spin_taylor_map(ele=f_ele, start_orbit=f_start_orbit)

end subroutine
subroutine fortran_sr_longitudinal_wake_particle (ele, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call sr_longitudinal_wake_particle(ele=f_ele, orbit=f_orbit)

end subroutine
subroutine fortran_sr_transverse_wake_particle (ele, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call sr_transverse_wake_particle(ele=f_ele, orbit=f_orbit)

end subroutine
subroutine fortran_sr_z_long_wake (ele, bunch, z_ave) bind(c)

  use bmad_struct, only: bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: z_ave  ! 0D_NOT_real
  real(rp) :: f_z_ave
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_z_ave 0D_NOT_real
  f_z_ave = z_ave
  call sr_z_long_wake(ele=f_ele, bunch=f_bunch, z_ave=f_z_ave)

end subroutine
subroutine fortran_srdt_calc (lat, srdt_sums, order, n_slices_gen_opt, n_slices_sxt_opt, &
    per_ele_out) bind(c)

  use bmad_struct, only: lat_struct
  use srdt_mod, only: summation_rdt_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  integer(c_int) :: order  ! 0D_NOT_integer
  integer :: f_order
  type(c_ptr), intent(in), value :: n_slices_gen_opt  ! 0D_NOT_integer
  integer(c_int) :: f_n_slices_gen_opt
  integer(c_int), pointer :: f_n_slices_gen_opt_ptr
  type(c_ptr), intent(in), value :: n_slices_sxt_opt  ! 0D_NOT_integer
  integer(c_int) :: f_n_slices_sxt_opt
  integer(c_int), pointer :: f_n_slices_sxt_opt_ptr
  ! ** Out parameters **
  type(c_ptr), value :: srdt_sums  ! 0D_NOT_type
  type(summation_rdt_struct), pointer :: f_srdt_sums
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: per_ele_out
  type(summation_rdt_struct_container_alloc), pointer :: f_per_ele_out
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! out: f_srdt_sums 0D_NOT_type
  if (.not. c_associated(srdt_sums)) return
  call c_f_pointer(srdt_sums, f_srdt_sums)
  ! in: f_order 0D_NOT_integer
  f_order = order
  ! in: f_n_slices_gen_opt 0D_NOT_integer
  if (c_associated(n_slices_gen_opt)) then
    call c_f_pointer(n_slices_gen_opt, f_n_slices_gen_opt_ptr)
  else
    f_n_slices_gen_opt_ptr => null()
  endif
  ! in: f_n_slices_sxt_opt 0D_NOT_integer
  if (c_associated(n_slices_sxt_opt)) then
    call c_f_pointer(n_slices_sxt_opt, f_n_slices_sxt_opt_ptr)
  else
    f_n_slices_sxt_opt_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(per_ele_out))   call c_f_pointer(per_ele_out, f_per_ele_out)
  call srdt_calc(lat=f_lat, srdt_sums=f_srdt_sums, order=f_order, &
      n_slices_gen_opt=f_n_slices_gen_opt_ptr, n_slices_sxt_opt=f_n_slices_sxt_opt_ptr, &
      per_ele_out=f_per_ele_out%data)

  ! out: f_srdt_sums 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_srdt_lsq_solution (lat, var_indexes, ls_soln, n_slices_gen_opt, &
    n_slices_sxt_opt, chrom_set_x_opt, chrom_set_y_opt, weight_in) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: var_indexes
  type(integer_container_alloc), pointer :: f_var_indexes
  type(c_ptr), intent(in), value :: n_slices_gen_opt  ! 0D_NOT_integer
  integer(c_int) :: f_n_slices_gen_opt
  integer(c_int), pointer :: f_n_slices_gen_opt_ptr
  type(c_ptr), intent(in), value :: n_slices_sxt_opt  ! 0D_NOT_integer
  integer(c_int) :: f_n_slices_sxt_opt
  integer(c_int), pointer :: f_n_slices_sxt_opt_ptr
  type(c_ptr), intent(in), value :: chrom_set_x_opt  ! 0D_NOT_real
  real(c_double) :: f_chrom_set_x_opt
  real(c_double), pointer :: f_chrom_set_x_opt_ptr
  type(c_ptr), intent(in), value :: chrom_set_y_opt  ! 0D_NOT_real
  real(c_double) :: f_chrom_set_y_opt
  real(c_double), pointer :: f_chrom_set_y_opt_ptr
  type(c_ptr), intent(in), value :: weight_in
  real(rp) :: f_weight_in(10)
  real(c_double), pointer :: f_weight_in_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ls_soln
  type(real_container_alloc), pointer :: f_ls_soln
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container general array (1D_ALLOC_integer)
  if (c_associated(var_indexes))   call c_f_pointer(var_indexes, f_var_indexes)
  !! container general array (1D_ALLOC_real)
  if (c_associated(ls_soln))   call c_f_pointer(ls_soln, f_ls_soln)
  ! in: f_n_slices_gen_opt 0D_NOT_integer
  if (c_associated(n_slices_gen_opt)) then
    call c_f_pointer(n_slices_gen_opt, f_n_slices_gen_opt_ptr)
  else
    f_n_slices_gen_opt_ptr => null()
  endif
  ! in: f_n_slices_sxt_opt 0D_NOT_integer
  if (c_associated(n_slices_sxt_opt)) then
    call c_f_pointer(n_slices_sxt_opt, f_n_slices_sxt_opt_ptr)
  else
    f_n_slices_sxt_opt_ptr => null()
  endif
  ! in: f_chrom_set_x_opt 0D_NOT_real
  if (c_associated(chrom_set_x_opt)) then
    call c_f_pointer(chrom_set_x_opt, f_chrom_set_x_opt_ptr)
  else
    f_chrom_set_x_opt_ptr => null()
  endif
  ! in: f_chrom_set_y_opt 0D_NOT_real
  if (c_associated(chrom_set_y_opt)) then
    call c_f_pointer(chrom_set_y_opt, f_chrom_set_y_opt_ptr)
  else
    f_chrom_set_y_opt_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(weight_in)) then
    call c_f_pointer(weight_in, f_weight_in_ptr, [10])
    f_weight_in = f_weight_in_ptr(:)
  else
    f_weight_in_ptr => null()
  endif
  call srdt_lsq_solution(lat=f_lat, var_indexes=f_var_indexes%data, ls_soln=f_ls_soln%data, &
      n_slices_gen_opt=f_n_slices_gen_opt_ptr, n_slices_sxt_opt=f_n_slices_sxt_opt_ptr, &
      chrom_set_x_opt=f_chrom_set_x_opt_ptr, chrom_set_y_opt=f_chrom_set_y_opt_ptr, &
      weight_in=f_weight_in)

end subroutine
subroutine fortran_start_branch_at (lat, ele_start, move_end_marker, error) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ele_start
  character(len=4096), target :: f_ele_start
  character(kind=c_char), pointer :: f_ele_start_ptr(:)
  logical(c_bool) :: move_end_marker  ! 0D_NOT_logical
  logical :: f_move_end_marker
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: error  ! 0D_NOT_logical
  logical :: f_error
  logical(c_bool), pointer :: f_error_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ele_start 0D_NOT_character
  if (.not. c_associated(ele_start)) return
  call c_f_pointer(ele_start, f_ele_start_ptr, [huge(0)])
  call to_f_str(f_ele_start_ptr, f_ele_start)
  ! in: f_move_end_marker 0D_NOT_logical
  f_move_end_marker = move_end_marker
  call start_branch_at(lat=f_lat, ele_start=f_ele_start, move_end_marker=f_move_end_marker, &
      error=f_error)

  ! out: f_error 0D_NOT_logical
  call c_f_pointer(error, f_error_ptr)
  f_error_ptr = f_error
end subroutine
subroutine fortran_stream_ele_end (physical_end, ele_orientation, stream_end) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: physical_end  ! 0D_NOT_integer
  integer :: f_physical_end
  integer(c_int) :: ele_orientation  ! 0D_NOT_integer
  integer :: f_ele_orientation
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: stream_end  ! 0D_NOT_integer
  integer :: f_stream_end
  integer(c_int), pointer :: f_stream_end_ptr
  ! ** End of parameters **
  ! in: f_physical_end 0D_NOT_integer
  f_physical_end = physical_end
  ! in: f_ele_orientation 0D_NOT_integer
  f_ele_orientation = ele_orientation
  f_stream_end = stream_ele_end(physical_end=f_physical_end, ele_orientation=f_ele_orientation)

  ! out: f_stream_end 0D_NOT_integer
  call c_f_pointer(stream_end, f_stream_end_ptr)
  f_stream_end_ptr = f_stream_end
end subroutine
subroutine fortran_string_attrib (attrib_name, ele, attrib_value) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: attrib_value
  character(len=4096), target :: f_attrib_value
  character(kind=c_char), pointer :: f_attrib_value_ptr(:)
  ! ** End of parameters **
  ! in: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) return
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call string_attrib(attrib_name=f_attrib_name, ele=f_ele, attrib_value=f_attrib_value)

  ! out: f_attrib_value 0D_NOT_character
  call c_f_pointer(attrib_value, f_attrib_value_ptr, [len_trim(f_attrib_value) + 1]) ! output-only string
  call to_c_str(f_attrib_value, f_attrib_value_ptr)
end subroutine
subroutine fortran_strong_beam_sigma_calc (ele, s_pos, sigma, bbi_const, dsigma_ds) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: s_pos  ! 0D_NOT_real
  real(rp) :: f_s_pos
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: sigma
  real(rp) :: f_sigma(2)
  real(c_double), pointer :: f_sigma_ptr(:)
  type(c_ptr), intent(in), value :: bbi_const  ! 0D_NOT_real
  real(rp) :: f_bbi_const
  real(c_double), pointer :: f_bbi_const_ptr
  type(c_ptr), intent(in), value :: dsigma_ds
  real(rp) :: f_dsigma_ds(2)
  real(c_double), pointer :: f_dsigma_ds_ptr(:)
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_s_pos 0D_NOT_real
  f_s_pos = s_pos
  call strong_beam_sigma_calc(ele=f_ele, s_pos=f_s_pos, sigma=f_sigma, bbi_const=f_bbi_const, &
      dsigma_ds=f_dsigma_ds)

  ! out: f_sigma 1D_NOT_real
  if (c_associated(sigma)) then
    call c_f_pointer(sigma, f_sigma_ptr, [2])
    f_sigma_ptr = f_sigma(:)
  endif
  ! out: f_bbi_const 0D_NOT_real
  call c_f_pointer(bbi_const, f_bbi_const_ptr)
  f_bbi_const_ptr = f_bbi_const
  ! out: f_dsigma_ds 1D_NOT_real
  if (c_associated(dsigma_ds)) then
    call c_f_pointer(dsigma_ds, f_dsigma_ds_ptr, [2])
    f_dsigma_ds_ptr = f_dsigma_ds(:)
  endif
end subroutine
subroutine fortran_strong_beam_strength (ele, strength) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: strength  ! 0D_NOT_real
  real(rp) :: f_strength
  real(c_double), pointer :: f_strength_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_strength = strong_beam_strength(ele=f_ele)

  ! out: f_strength 0D_NOT_real
  call c_f_pointer(strength, f_strength_ptr)
  f_strength_ptr = f_strength
end subroutine
subroutine fortran_surface_grid_displacement (ele, x, y, err_flag, z, dz_dxy, extend_grid) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  real(c_double) :: z  ! 0D_NOT_real
  real(rp) :: f_z
  type(c_ptr), intent(in), value :: dz_dxy
  real(rp) :: f_dz_dxy(2)
  real(c_double), pointer :: f_dz_dxy_ptr(:)
  type(c_ptr), intent(in), value :: extend_grid  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_extend_grid
  logical, target :: f_extend_grid_native
  logical, pointer :: f_extend_grid_native_ptr
  logical(c_bool), pointer :: f_extend_grid_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  ! in: f_z 0D_NOT_real
  f_z = z
  !! general array (1D_NOT_real)
  if (c_associated(dz_dxy)) then
    call c_f_pointer(dz_dxy, f_dz_dxy_ptr, [2])
    f_dz_dxy = f_dz_dxy_ptr(:)
  else
    f_dz_dxy_ptr => null()
  endif
  ! in: f_extend_grid 0D_NOT_logical
  if (c_associated(extend_grid)) then
    call c_f_pointer(extend_grid, f_extend_grid_ptr)
    f_extend_grid_native = f_extend_grid_ptr
    f_extend_grid_native_ptr => f_extend_grid_native
  else
    f_extend_grid_native_ptr => null()
  endif
  call surface_grid_displacement(ele=f_ele, x=f_x_ptr, y=f_y_ptr, err_flag=f_err_flag, z=f_z, &
      dz_dxy=f_dz_dxy, extend_grid=f_extend_grid_native_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
end subroutine
subroutine fortran_symp_lie_bmad (ele, param, orbit, track, mat6, make_matrix, offset_ele) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  type(c_ptr), intent(in), value :: offset_ele  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_offset_ele
  logical, target :: f_offset_ele_native
  logical, pointer :: f_offset_ele_native_ptr
  logical(c_bool), pointer :: f_offset_ele_ptr
  ! ** Out parameters **
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  ! in: f_offset_ele 0D_NOT_logical
  if (c_associated(offset_ele)) then
    call c_f_pointer(offset_ele, f_offset_ele_ptr)
    f_offset_ele_native = f_offset_ele_ptr
    f_offset_ele_native_ptr => f_offset_ele_native
  else
    f_offset_ele_native_ptr => null()
  endif
  call symp_lie_bmad(ele=f_ele, param=f_param, orbit=f_orbit, track=f_track, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr, offset_ele=f_offset_ele_native_ptr)

  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_t6_to_b123 (t6, abz_tunes, B1, B2, B3, err_flag) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: t6
  real(rp) :: f_t6(6,6)
  real(c_double), pointer :: f_t6_ptr(:)
  type(c_ptr), intent(in), value :: abz_tunes
  real(rp) :: f_abz_tunes(3)
  real(c_double), pointer :: f_abz_tunes_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: B1
  real(rp) :: f_B1(6,6)
  real(c_double), pointer :: f_B1_ptr(:)
  type(c_ptr), intent(in), value :: B2
  real(rp) :: f_B2(6,6)
  real(c_double), pointer :: f_B2_ptr(:)
  type(c_ptr), intent(in), value :: B3
  real(rp) :: f_B3(6,6)
  real(c_double), pointer :: f_B3_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(t6)) then
    call c_f_pointer(t6, f_t6_ptr, [6*6])
    call vec2mat(f_t6_ptr, f_t6)
  else
    f_t6_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(abz_tunes)) then
    call c_f_pointer(abz_tunes, f_abz_tunes_ptr, [3])
    f_abz_tunes = f_abz_tunes_ptr(:)
  else
    f_abz_tunes_ptr => null()
  endif
  call t6_to_b123(t6=f_t6, abz_tunes=f_abz_tunes, B1=f_B1, B2=f_B2, B3=f_B3, &
      err_flag=f_err_flag)

  ! out: f_B1 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_B1', c_name='B1', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=53, definition='real(rp) B1(6,6), B2(6,6), B3(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='B1', comment='', default=None), intent='out', description='Beta matrix associated with a-mode.', doc_data_type='float', doc_is_optional=False)
  ! out: f_B2 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_B2', c_name='B2', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=53, definition='real(rp) B1(6,6), B2(6,6), B3(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='B2', comment='', default=None), intent='out', description='Beta matrix associated with b-mode.', doc_data_type='float', doc_is_optional=False)
  ! out: f_B3 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_B3', c_name='B3', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=53, definition='real(rp) B1(6,6), B2(6,6), B3(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='B3', comment='', default=None), intent='out', description='Beta matrix associated with c-mode.', doc_data_type='float', doc_is_optional=False)
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_taper_mag_strengths (lat, ref_lat, except, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ref_lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_ref_lat
  type(c_ptr), intent(in), value :: except
  character(len=4096), target :: f_except
  character(kind=c_char), pointer :: f_except_ptr(:)
  character(len=4096), pointer :: f_except_call_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ref_lat 0D_NOT_type
  if (c_associated(ref_lat))   call c_f_pointer(ref_lat, f_ref_lat)
  ! in: f_except 0D_NOT_character
  if (c_associated(except)) then
    call c_f_pointer(except, f_except_ptr, [huge(0)])
    call to_f_str(f_except_ptr, f_except)
    f_except_call_ptr => f_except
  else
    f_except_call_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call taper_mag_strengths(lat=f_lat, ref_lat=f_ref_lat, except=f_except_call_ptr, &
      err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_target_min_max_calc (r_corner1, r_corner2, y_min, y_max, phi_min, phi_max, &
    initial) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: r_corner1
  real(rp) :: f_r_corner1(3)
  real(c_double), pointer :: f_r_corner1_ptr(:)
  type(c_ptr), intent(in), value :: r_corner2
  real(rp) :: f_r_corner2(3)
  real(c_double), pointer :: f_r_corner2_ptr(:)
  type(c_ptr), intent(in), value :: initial  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_initial
  logical, target :: f_initial_native
  logical, pointer :: f_initial_native_ptr
  logical(c_bool), pointer :: f_initial_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: y_min  ! 0D_NOT_real
  real(c_double) :: f_y_min
  real(c_double), pointer :: f_y_min_ptr
  type(c_ptr), intent(in), value :: y_max  ! 0D_NOT_real
  real(c_double) :: f_y_max
  real(c_double), pointer :: f_y_max_ptr
  type(c_ptr), intent(in), value :: phi_min  ! 0D_NOT_real
  real(c_double) :: f_phi_min
  real(c_double), pointer :: f_phi_min_ptr
  type(c_ptr), intent(in), value :: phi_max  ! 0D_NOT_real
  real(c_double) :: f_phi_max
  real(c_double), pointer :: f_phi_max_ptr
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(r_corner1)) then
    call c_f_pointer(r_corner1, f_r_corner1_ptr, [3])
    f_r_corner1 = f_r_corner1_ptr(:)
  else
    f_r_corner1_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(r_corner2)) then
    call c_f_pointer(r_corner2, f_r_corner2_ptr, [3])
    f_r_corner2 = f_r_corner2_ptr(:)
  else
    f_r_corner2_ptr => null()
  endif
  ! inout: f_y_min 0D_NOT_real
  if (c_associated(y_min)) then
    call c_f_pointer(y_min, f_y_min_ptr)
  else
    f_y_min_ptr => null()
  endif
  ! inout: f_y_max 0D_NOT_real
  if (c_associated(y_max)) then
    call c_f_pointer(y_max, f_y_max_ptr)
  else
    f_y_max_ptr => null()
  endif
  ! inout: f_phi_min 0D_NOT_real
  if (c_associated(phi_min)) then
    call c_f_pointer(phi_min, f_phi_min_ptr)
  else
    f_phi_min_ptr => null()
  endif
  ! inout: f_phi_max 0D_NOT_real
  if (c_associated(phi_max)) then
    call c_f_pointer(phi_max, f_phi_max_ptr)
  else
    f_phi_max_ptr => null()
  endif
  ! in: f_initial 0D_NOT_logical
  if (c_associated(initial)) then
    call c_f_pointer(initial, f_initial_ptr)
    f_initial_native = f_initial_ptr
    f_initial_native_ptr => f_initial_native
  else
    f_initial_native_ptr => null()
  endif
  call target_min_max_calc(r_corner1=f_r_corner1, r_corner2=f_r_corner2, y_min=f_y_min_ptr, &
      y_max=f_y_max_ptr, phi_min=f_phi_min_ptr, phi_max=f_phi_max_ptr, &
      initial=f_initial_native_ptr)

  ! inout: f_y_min 0D_NOT_real
  ! no output conversion for f_y_min
  ! inout: f_y_max 0D_NOT_real
  ! no output conversion for f_y_max
  ! inout: f_phi_min 0D_NOT_real
  ! no output conversion for f_phi_min
  ! inout: f_phi_max 0D_NOT_real
  ! no output conversion for f_phi_max
end subroutine
subroutine fortran_target_rot_mats (r_center, w_to_target, w_to_ele) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: r_center
  real(rp) :: f_r_center(3)
  real(c_double), pointer :: f_r_center_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_to_target
  real(rp) :: f_w_to_target(3,3)
  real(c_double), pointer :: f_w_to_target_ptr(:)
  type(c_ptr), intent(in), value :: w_to_ele
  real(rp) :: f_w_to_ele(3,3)
  real(c_double), pointer :: f_w_to_ele_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(r_center)) then
    call c_f_pointer(r_center, f_r_center_ptr, [3])
    f_r_center = f_r_center_ptr(:)
  else
    f_r_center_ptr => null()
  endif
  call target_rot_mats(r_center=f_r_center, w_to_target=f_w_to_target, w_to_ele=f_w_to_ele)

  ! out: f_w_to_target 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_to_target', c_name='w_to_target', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=1140, definition='real(rp) r_center(3), w_to_target(3,3), w_to_ele(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_to_target', comment='', default=None), intent='out', description='Rotation matrix from ele to target coords.', doc_data_type='float', doc_is_optional=False)
  ! out: f_w_to_ele 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_to_ele', c_name='w_to_ele', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=1140, definition='real(rp) r_center(3), w_to_target(3,3), w_to_ele(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_to_ele', comment='', default=None), intent='out', description='Rotation matrix from target to ele coords.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_taylor_equal_taylor (taylor1, taylor2) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: taylor2  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_taylor2
  ! ** Out parameters **
  type(c_ptr), value :: taylor1  ! 0D_NOT_type
  type(taylor_struct), pointer :: f_taylor1
  ! ** End of parameters **
  ! out: f_taylor1 0D_NOT_type
  if (.not. c_associated(taylor1)) return
  call c_f_pointer(taylor1, f_taylor1)
  ! in: f_taylor2 0D_NOT_type
  if (.not. c_associated(taylor2)) return
  call c_f_pointer(taylor2, f_taylor2)
  call taylor_equal_taylor(taylor1=f_taylor1, taylor2=f_taylor2)

  ! out: f_taylor1 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_taylor_inverse (taylor_in, taylor_inv, err) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: taylor_in
  type(taylor_struct_container_alloc), pointer :: f_taylor_in
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: taylor_inv
  type(taylor_struct_container_alloc), pointer :: f_taylor_inv
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor_in))   call c_f_pointer(taylor_in, f_taylor_in)
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor_inv))   call c_f_pointer(taylor_inv, f_taylor_inv)
  call taylor_inverse(taylor_in=f_taylor_in%data, taylor_inv=f_taylor_inv%data, err=f_err)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_taylor_propagate1 (orb_taylor, ele, param, err_flag, ref_in, spin_taylor) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), value :: ref_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_ref_in
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: orb_taylor
  type(taylor_struct_container_alloc), pointer :: f_orb_taylor
  type(c_ptr), intent(in), value :: spin_taylor
  type(taylor_struct_container_alloc), pointer :: f_spin_taylor
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb_taylor))   call c_f_pointer(orb_taylor, f_orb_taylor)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! in: f_ref_in 0D_NOT_type
  if (c_associated(ref_in))   call c_f_pointer(ref_in, f_ref_in)
  !! container type array (1D_ALLOC_type)
  if (c_associated(spin_taylor))   call c_f_pointer(spin_taylor, f_spin_taylor)
  call taylor_propagate1(orb_taylor=f_orb_taylor%data, ele=f_ele, param=f_param, &
      err_flag=f_err_flag, ref_in=f_ref_in, spin_taylor=f_spin_taylor%data)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_taylors_equal_taylors (taylor1, taylor2) bind(c)

  use bmad_struct, only: taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: taylor2
  type(taylor_struct_container_alloc), pointer :: f_taylor2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: taylor1
  type(taylor_struct_container_alloc), pointer :: f_taylor1
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor1))   call c_f_pointer(taylor1, f_taylor1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(taylor2))   call c_f_pointer(taylor2, f_taylor2)
  call taylors_equal_taylors(taylor1=f_taylor1%data, taylor2=f_taylor2%data)

end subroutine
subroutine fortran_tilt_coords (tilt_val, coord, mat6, make_matrix) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: tilt_val  ! 0D_NOT_real
  real(rp) :: f_tilt_val
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: coord
  type(real_container_alloc), pointer :: f_coord
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! in: f_tilt_val 0D_NOT_real
  f_tilt_val = tilt_val
  !! container general array (1D_ALLOC_real)
  if (c_associated(coord))   call c_f_pointer(coord, f_coord)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call tilt_coords(tilt_val=f_tilt_val, coord=f_coord%data, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_tilt_coords_photon (tilt_val, coord, w_mat) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: tilt_val  ! 0D_NOT_real
  real(rp) :: f_tilt_val
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: coord
  type(real_container_alloc), pointer :: f_coord
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_tilt_val 0D_NOT_real
  f_tilt_val = tilt_val
  !! container general array (1D_ALLOC_real)
  if (c_associated(coord))   call c_f_pointer(coord, f_coord)
  !! general array (2D_NOT_real)
  if (c_associated(w_mat)) then
    call c_f_pointer(w_mat, f_w_mat_ptr, [3*3])
    call vec2mat(f_w_mat_ptr, f_w_mat)
  else
    f_w_mat_ptr => null()
  endif
  call tilt_coords_photon(tilt_val=f_tilt_val, coord=f_coord%data, w_mat=f_w_mat)

end subroutine
subroutine fortran_tilt_mat6 (mat6, tilt) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: tilt  ! 0D_NOT_real
  real(rp) :: f_tilt
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_tilt 0D_NOT_real
  f_tilt = tilt
  call tilt_mat6(mat6=f_mat6, tilt=f_tilt)

end subroutine
subroutine fortran_to_eta_reading (eta_actual, ele, axis, add_noise, reading, err) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: eta_actual
  type(real_container_alloc), pointer :: f_eta_actual
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: axis  ! 0D_NOT_integer
  integer :: f_axis
  logical(c_bool) :: add_noise  ! 0D_NOT_logical
  logical :: f_add_noise
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: reading  ! 0D_NOT_real
  real(rp) :: f_reading
  real(c_double), pointer :: f_reading_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(eta_actual))   call c_f_pointer(eta_actual, f_eta_actual)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_axis 0D_NOT_integer
  f_axis = axis
  ! in: f_add_noise 0D_NOT_logical
  f_add_noise = add_noise
  call to_eta_reading(eta_actual=f_eta_actual%data, ele=f_ele, axis=f_axis, &
      add_noise=f_add_noise, reading=f_reading, err=f_err)

  ! out: f_reading 0D_NOT_real
  call c_f_pointer(reading, f_reading_ptr)
  f_reading_ptr = f_reading
  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_to_fieldmap_coords (ele, local_orb, s_body, ele_anchor_pt, r0, &
    curved_ref_frame, x, y, z, cos_ang, sin_ang, err_flag) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: local_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_local_orb
  real(c_double) :: s_body  ! 0D_NOT_real
  real(rp) :: f_s_body
  integer(c_int) :: ele_anchor_pt  ! 0D_NOT_integer
  integer :: f_ele_anchor_pt
  type(c_ptr), intent(in), value :: r0
  real(rp) :: f_r0(3)
  real(c_double), pointer :: f_r0_ptr(:)
  logical(c_bool) :: curved_ref_frame  ! 0D_NOT_logical
  logical :: f_curved_ref_frame
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(c_double) :: f_z
  real(c_double), pointer :: f_z_ptr
  type(c_ptr), intent(in), value :: cos_ang  ! 0D_NOT_real
  real(c_double) :: f_cos_ang
  real(c_double), pointer :: f_cos_ang_ptr
  type(c_ptr), intent(in), value :: sin_ang  ! 0D_NOT_real
  real(c_double) :: f_sin_ang
  real(c_double), pointer :: f_sin_ang_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_local_orb 0D_NOT_type
  if (.not. c_associated(local_orb)) return
  call c_f_pointer(local_orb, f_local_orb)
  ! in: f_s_body 0D_NOT_real
  f_s_body = s_body
  ! in: f_ele_anchor_pt 0D_NOT_integer
  f_ele_anchor_pt = ele_anchor_pt
  !! general array (1D_NOT_real)
  if (c_associated(r0)) then
    call c_f_pointer(r0, f_r0_ptr, [3])
    f_r0 = f_r0_ptr(:)
  else
    f_r0_ptr => null()
  endif
  ! in: f_curved_ref_frame 0D_NOT_logical
  f_curved_ref_frame = curved_ref_frame
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_z 0D_NOT_real
  if (c_associated(z)) then
    call c_f_pointer(z, f_z_ptr)
  else
    f_z_ptr => null()
  endif
  ! inout: f_cos_ang 0D_NOT_real
  if (c_associated(cos_ang)) then
    call c_f_pointer(cos_ang, f_cos_ang_ptr)
  else
    f_cos_ang_ptr => null()
  endif
  ! inout: f_sin_ang 0D_NOT_real
  if (c_associated(sin_ang)) then
    call c_f_pointer(sin_ang, f_sin_ang_ptr)
  else
    f_sin_ang_ptr => null()
  endif
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call to_fieldmap_coords(ele=f_ele, local_orb=f_local_orb, s_body=f_s_body, &
      ele_anchor_pt=f_ele_anchor_pt, r0=f_r0, curved_ref_frame=f_curved_ref_frame, x=f_x_ptr, &
      y=f_y_ptr, z=f_z_ptr, cos_ang=f_cos_ang_ptr, sin_ang=f_sin_ang_ptr, err_flag=f_err_flag)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_z 0D_NOT_real
  ! no output conversion for f_z
  ! inout: f_cos_ang 0D_NOT_real
  ! no output conversion for f_cos_ang
  ! inout: f_sin_ang 0D_NOT_real
  ! no output conversion for f_sin_ang
end subroutine
subroutine fortran_to_orbit_reading (orb, ele, axis, add_noise, reading, err) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: axis  ! 0D_NOT_integer
  integer :: f_axis
  logical(c_bool) :: add_noise  ! 0D_NOT_logical
  logical :: f_add_noise
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: reading  ! 0D_NOT_real
  real(rp) :: f_reading
  real(c_double), pointer :: f_reading_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_axis 0D_NOT_integer
  f_axis = axis
  ! in: f_add_noise 0D_NOT_logical
  f_add_noise = add_noise
  call to_orbit_reading(orb=f_orb, ele=f_ele, axis=f_axis, add_noise=f_add_noise, &
      reading=f_reading, err=f_err)

  ! out: f_reading 0D_NOT_real
  call c_f_pointer(reading, f_reading_ptr)
  f_reading_ptr = f_reading
  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_to_phase_and_coupling_reading (ele, add_noise, reading, err) bind(c)

  use bmad_struct, only: bpm_phase_coupling_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  logical(c_bool) :: add_noise  ! 0D_NOT_logical
  logical :: f_add_noise
  ! ** Out parameters **
  type(c_ptr), value :: reading  ! 0D_NOT_type
  type(bpm_phase_coupling_struct), pointer :: f_reading
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_add_noise 0D_NOT_logical
  f_add_noise = add_noise
  ! out: f_reading 0D_NOT_type
  if (.not. c_associated(reading)) return
  call c_f_pointer(reading, f_reading)
  call to_phase_and_coupling_reading(ele=f_ele, add_noise=f_add_noise, reading=f_reading, &
      err=f_err)

  ! out: f_reading 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_to_photon_angle_coords (orb_in, ele, orb_out) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orb_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_in
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: orb_out  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_out
  ! ** End of parameters **
  ! in: f_orb_in 0D_NOT_type
  if (.not. c_associated(orb_in)) return
  call c_f_pointer(orb_in, f_orb_in)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_orb_out = to_photon_angle_coords(orb_in=f_orb_in, ele=f_ele)

  ! out: f_orb_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_to_surface_coords (lab_orbit, ele, surface_orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lab_orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_lab_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: surface_orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_surface_orbit
  ! ** End of parameters **
  ! in: f_lab_orbit 0D_NOT_type
  if (.not. c_associated(lab_orbit)) return
  call c_f_pointer(lab_orbit, f_lab_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_surface_orbit 0D_NOT_type
  if (.not. c_associated(surface_orbit)) return
  call c_f_pointer(surface_orbit, f_surface_orbit)
  call to_surface_coords(lab_orbit=f_lab_orbit, ele=f_ele, surface_orbit=f_surface_orbit)

  ! out: f_surface_orbit 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_touschek_lifetime (mode, Tl, lat) bind(c)

  use bmad_struct, only: lat_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: mode  ! 0D_NOT_type
  TYPE(normal_modes_struct), pointer :: f_mode
  type(c_ptr), value :: lat  ! 0D_NOT_type
  TYPE(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: Tl  ! 0D_NOT_real
  REAL(rp) :: f_Tl
  real(c_double), pointer :: f_Tl_ptr
  ! ** End of parameters **
  ! in: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call touschek_lifetime(mode=f_mode, Tl=f_Tl, lat=f_lat)

  ! out: f_Tl 0D_NOT_real
  call c_f_pointer(Tl, f_Tl_ptr)
  f_Tl_ptr = f_Tl
end subroutine
subroutine fortran_touschek_rate1 (mode, rate, lat, ix, s) bind(c)

  use bmad_struct, only: lat_struct, normal_modes_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: mode  ! 0D_NOT_type
  TYPE(normal_modes_struct), pointer :: f_mode
  type(c_ptr), value :: lat  ! 0D_NOT_type
  TYPE(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix  ! 0D_NOT_integer
  integer(c_int) :: f_ix
  integer(c_int), pointer :: f_ix_ptr
  type(c_ptr), intent(in), value :: s  ! 0D_NOT_real
  real(c_double) :: f_s
  real(c_double), pointer :: f_s_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: rate  ! 0D_NOT_real
  REAL(rp) :: f_rate
  real(c_double), pointer :: f_rate_ptr
  ! ** End of parameters **
  ! in: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix 0D_NOT_integer
  if (c_associated(ix)) then
    call c_f_pointer(ix, f_ix_ptr)
  else
    f_ix_ptr => null()
  endif
  ! in: f_s 0D_NOT_real
  if (c_associated(s)) then
    call c_f_pointer(s, f_s_ptr)
  else
    f_s_ptr => null()
  endif
  call touschek_rate1(mode=f_mode, rate=f_rate, lat=f_lat, ix=f_ix_ptr, s=f_s_ptr)

  ! out: f_rate 0D_NOT_real
  call c_f_pointer(rate, f_rate_ptr)
  f_rate_ptr = f_rate
end subroutine
subroutine fortran_touschek_rate1_zap (mode, rate, lat, ix, s) bind(c)

  use bmad_struct, only: lat_struct, normal_modes_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: mode  ! 0D_NOT_type
  type(normal_modes_struct), pointer :: f_mode
  type(c_ptr), intent(in), value :: rate  ! 0D_NOT_real
  real(c_double) :: f_rate
  real(c_double), pointer :: f_rate_ptr
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix  ! 0D_NOT_integer
  integer(c_int) :: f_ix
  integer(c_int), pointer :: f_ix_ptr
  type(c_ptr), intent(in), value :: s  ! 0D_NOT_real
  real(c_double) :: f_s
  real(c_double), pointer :: f_s_ptr
  ! ** End of parameters **
  ! inout: f_mode 0D_NOT_type
  if (.not. c_associated(mode)) return
  call c_f_pointer(mode, f_mode)
  ! inout: f_rate 0D_NOT_real
  if (c_associated(rate)) then
    call c_f_pointer(rate, f_rate_ptr)
  else
    f_rate_ptr => null()
  endif
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_ix 0D_NOT_integer
  if (c_associated(ix)) then
    call c_f_pointer(ix, f_ix_ptr)
  else
    f_ix_ptr => null()
  endif
  ! inout: f_s 0D_NOT_real
  if (c_associated(s)) then
    call c_f_pointer(s, f_s_ptr)
  else
    f_s_ptr => null()
  endif
  call touschek_rate1_zap(mode=f_mode, rate=f_rate_ptr, lat=f_lat, ix=f_ix_ptr, s=f_s_ptr)

  ! inout: f_rate 0D_NOT_real
  ! no output conversion for f_rate
  ! inout: f_ix 0D_NOT_integer
  ! no output conversion for f_ix
  ! inout: f_s 0D_NOT_real
  ! no output conversion for f_s
end subroutine
subroutine fortran_track1 (start_orb, ele, param, end_orb, track, err_flag, ignore_radiation, &
    make_map1, init_to_edge) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: ignore_radiation  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_ignore_radiation
  logical, target :: f_ignore_radiation_native
  logical, pointer :: f_ignore_radiation_native_ptr
  logical(c_bool), pointer :: f_ignore_radiation_ptr
  type(c_ptr), intent(in), value :: make_map1  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_map1
  logical, target :: f_make_map1_native
  logical, pointer :: f_make_map1_native_ptr
  logical(c_bool), pointer :: f_make_map1_ptr
  type(c_ptr), intent(in), value :: init_to_edge  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_init_to_edge
  logical, target :: f_init_to_edge_native
  logical, pointer :: f_init_to_edge_native_ptr
  logical(c_bool), pointer :: f_init_to_edge_ptr
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** End of parameters **
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(start_orb, f_start_orb)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(end_orb, f_end_orb)
  ! inout: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  ! in: f_ignore_radiation 0D_NOT_logical
  if (c_associated(ignore_radiation)) then
    call c_f_pointer(ignore_radiation, f_ignore_radiation_ptr)
    f_ignore_radiation_native = f_ignore_radiation_ptr
    f_ignore_radiation_native_ptr => f_ignore_radiation_native
  else
    f_ignore_radiation_native_ptr => null()
  endif
  ! in: f_make_map1 0D_NOT_logical
  if (c_associated(make_map1)) then
    call c_f_pointer(make_map1, f_make_map1_ptr)
    f_make_map1_native = f_make_map1_ptr
    f_make_map1_native_ptr => f_make_map1_native
  else
    f_make_map1_native_ptr => null()
  endif
  ! in: f_init_to_edge 0D_NOT_logical
  if (c_associated(init_to_edge)) then
    call c_f_pointer(init_to_edge, f_init_to_edge_ptr)
    f_init_to_edge_native = f_init_to_edge_ptr
    f_init_to_edge_native_ptr => f_init_to_edge_native
  else
    f_init_to_edge_native_ptr => null()
  endif
  call track1(start_orb=f_start_orb, ele=f_ele, param=f_param, end_orb=f_end_orb, &
      track=f_track, err_flag=f_err_flag, ignore_radiation=f_ignore_radiation_native_ptr, &
      make_map1=f_make_map1_native_ptr, init_to_edge=f_init_to_edge_native_ptr)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_track1_beam (beam, ele, err, centroid, direction) bind(c)

  use bmad_struct, only: beam_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: centroid
  type(coord_struct_container_alloc), pointer :: f_centroid
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  ! ** End of parameters **
  ! inout: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container type array (1D_ALLOC_type)
  if (c_associated(centroid))   call c_f_pointer(centroid, f_centroid)
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  call track1_beam(beam=f_beam, ele=f_ele, err=f_err, centroid=f_centroid%data, &
      direction=f_direction_ptr)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track1_bmad (orbit, ele, param, err_flag, track, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track1_bmad(orbit=f_orbit, ele=f_ele, param=f_param, err_flag=f_err_flag, track=f_track, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_track1_bmad_photon (orbit, ele, param, err_flag) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  call track1_bmad_photon(orbit=f_orbit, ele=f_ele, param=f_param, err_flag=f_err_flag)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_track1_bunch (bunch, ele, err, centroid, direction, bunch_track) bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: centroid
  type(coord_struct_container_alloc), pointer :: f_centroid
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container type array (1D_ALLOC_type)
  if (c_associated(centroid))   call c_f_pointer(centroid, f_centroid)
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! inout: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  call track1_bunch(bunch=f_bunch, ele=f_ele, err=f_err, centroid=f_centroid%data, &
      direction=f_direction_ptr, bunch_track=f_bunch_track)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track1_bunch_csr (bunch, ele, centroid, err, s_start, s_end, bunch_track) &
    bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: centroid
  type(coord_struct_container_alloc), pointer :: f_centroid
  type(c_ptr), intent(in), value :: s_start  ! 0D_NOT_real
  real(c_double) :: f_s_start
  real(c_double), pointer :: f_s_start_ptr
  type(c_ptr), intent(in), value :: s_end  ! 0D_NOT_real
  real(c_double) :: f_s_end
  real(c_double), pointer :: f_s_end_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container type array (1D_ALLOC_type)
  if (c_associated(centroid))   call c_f_pointer(centroid, f_centroid)
  ! in: f_s_start 0D_NOT_real
  if (c_associated(s_start)) then
    call c_f_pointer(s_start, f_s_start_ptr)
  else
    f_s_start_ptr => null()
  endif
  ! in: f_s_end 0D_NOT_real
  if (c_associated(s_end)) then
    call c_f_pointer(s_end, f_s_end_ptr)
  else
    f_s_end_ptr => null()
  endif
  ! inout: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  call track1_bunch_csr(bunch=f_bunch, ele=f_ele, centroid=f_centroid%data, err=f_err, &
      s_start=f_s_start_ptr, s_end=f_s_end_ptr, bunch_track=f_bunch_track)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track1_bunch_csr3d (bunch, ele, centroid, err, s_start, s_end, bunch_track) &
    bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: centroid
  type(coord_struct_container_alloc), pointer :: f_centroid
  type(c_ptr), intent(in), value :: s_start  ! 0D_NOT_real
  real(c_double) :: f_s_start
  real(c_double), pointer :: f_s_start_ptr
  type(c_ptr), intent(in), value :: s_end  ! 0D_NOT_real
  real(c_double) :: f_s_end
  real(c_double), pointer :: f_s_end_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! container type array (1D_ALLOC_type)
  if (c_associated(centroid))   call c_f_pointer(centroid, f_centroid)
  ! in: f_s_start 0D_NOT_real
  if (c_associated(s_start)) then
    call c_f_pointer(s_start, f_s_start_ptr)
  else
    f_s_start_ptr => null()
  endif
  ! in: f_s_end 0D_NOT_real
  if (c_associated(s_end)) then
    call c_f_pointer(s_end, f_s_end_ptr)
  else
    f_s_end_ptr => null()
  endif
  ! inout: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  call track1_bunch_csr3d(bunch=f_bunch, ele=f_ele, centroid=f_centroid%data, err=f_err, &
      s_start=f_s_start_ptr, s_end=f_s_end_ptr, bunch_track=f_bunch_track)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track1_bunch_hom (bunch, ele, direction, bunch_track) bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! inout: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  call track1_bunch_hom(bunch=f_bunch, ele=f_ele, direction=f_direction_ptr, &
      bunch_track=f_bunch_track)

end subroutine
subroutine fortran_track1_bunch_space_charge (bunch, ele, err, track_to_same_s, bunch_track) &
    bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: track_to_same_s  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_track_to_same_s
  logical, target :: f_track_to_same_s_native
  logical, pointer :: f_track_to_same_s_native_ptr
  logical(c_bool), pointer :: f_track_to_same_s_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_track_to_same_s 0D_NOT_logical
  if (c_associated(track_to_same_s)) then
    call c_f_pointer(track_to_same_s, f_track_to_same_s_ptr)
    f_track_to_same_s_native = f_track_to_same_s_ptr
    f_track_to_same_s_native_ptr => f_track_to_same_s_native
  else
    f_track_to_same_s_native_ptr => null()
  endif
  ! inout: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  call track1_bunch_space_charge(bunch=f_bunch, ele=f_ele, err=f_err, &
      track_to_same_s=f_track_to_same_s_native_ptr, bunch_track=f_bunch_track)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track1_crystal (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_crystal(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_diffraction_plate_or_mask (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_diffraction_plate_or_mask(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_high_energy_space_charge (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_high_energy_space_charge(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_lens (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_lens(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_linear (orbit, ele, param) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  call track1_linear(orbit=f_orbit, ele=f_ele, param=f_param)

end subroutine
subroutine fortran_track1_lr_wake (bunch, ele) bind(c)

  use bmad_struct, only: bunch_struct, ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call track1_lr_wake(bunch=f_bunch, ele=f_ele)

end subroutine
subroutine fortran_track1_mad (orbit, ele, param) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  call track1_mad(orbit=f_orbit, ele=f_ele, param=f_param)

end subroutine
subroutine fortran_track1_mirror (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_mirror(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_mosaic_crystal (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_mosaic_crystal(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_multilayer_mirror (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_multilayer_mirror(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_radiation (orbit, ele, edge) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: edge  ! 0D_NOT_integer
  integer :: f_edge
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_edge 0D_NOT_integer
  f_edge = edge
  call track1_radiation(orbit=f_orbit, ele=f_ele, edge=f_edge)

end subroutine
subroutine fortran_track1_radiation_center (orbit, ele1, ele2, rad_damp, rad_fluct) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  type(c_ptr), intent(in), value :: rad_damp  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_rad_damp
  logical, target :: f_rad_damp_native
  logical, pointer :: f_rad_damp_native_ptr
  logical(c_bool), pointer :: f_rad_damp_ptr
  type(c_ptr), intent(in), value :: rad_fluct  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_rad_fluct
  logical, target :: f_rad_fluct_native
  logical, pointer :: f_rad_fluct_native_ptr
  logical(c_bool), pointer :: f_rad_fluct_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  ! in: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  ! in: f_rad_damp 0D_NOT_logical
  if (c_associated(rad_damp)) then
    call c_f_pointer(rad_damp, f_rad_damp_ptr)
    f_rad_damp_native = f_rad_damp_ptr
    f_rad_damp_native_ptr => f_rad_damp_native
  else
    f_rad_damp_native_ptr => null()
  endif
  ! in: f_rad_fluct 0D_NOT_logical
  if (c_associated(rad_fluct)) then
    call c_f_pointer(rad_fluct, f_rad_fluct_ptr)
    f_rad_fluct_native = f_rad_fluct_ptr
    f_rad_fluct_native_ptr => f_rad_fluct_native
  else
    f_rad_fluct_native_ptr => null()
  endif
  call track1_radiation_center(orbit=f_orbit, ele1=f_ele1, ele2=f_ele2, &
      rad_damp=f_rad_damp_native_ptr, rad_fluct=f_rad_fluct_native_ptr)

end subroutine
subroutine fortran_track1_runge_kutta (orbit, ele, param, err_flag, track, mat6, make_matrix) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track1_runge_kutta(orbit=f_orbit, ele=f_ele, param=f_param, err_flag=f_err_flag, &
      track=f_track, mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_track1_sample (ele, param, orbit) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  call track1_sample(ele=f_ele, param=f_param, orbit=f_orbit)

end subroutine
subroutine fortran_track1_spin (start_orb, ele, param, end_orb, make_quaternion) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  ! ** Inout parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_quaternion  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_quaternion
  logical, target :: f_make_quaternion_native
  logical, pointer :: f_make_quaternion_native_ptr
  logical(c_bool), pointer :: f_make_quaternion_ptr
  ! ** End of parameters **
  ! inout: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  ! inout: f_make_quaternion 0D_NOT_logical
  if (c_associated(make_quaternion)) then
    call c_f_pointer(make_quaternion, f_make_quaternion_ptr)
    f_make_quaternion_native = f_make_quaternion_ptr
    f_make_quaternion_native_ptr => f_make_quaternion_native
  else
    f_make_quaternion_native_ptr => null()
  endif
  call track1_spin(start_orb=f_start_orb, ele=f_ele, param=f_param, end_orb=f_end_orb, &
      make_quaternion=f_make_quaternion_native_ptr)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_make_quaternion 0D_NOT_logical
  if (c_associated(make_quaternion)) then
    call c_f_pointer(make_quaternion, f_make_quaternion_ptr)
    f_make_quaternion_ptr = f_make_quaternion_native
  else
    ! f_make_quaternion unset
  endif
end subroutine
subroutine fortran_track1_spin_integration (start_orb, ele, param, end_orb) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  ! ** Inout parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** End of parameters **
  ! inout: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  call track1_spin_integration(start_orb=f_start_orb, ele=f_ele, param=f_param, &
      end_orb=f_end_orb)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_track1_spin_taylor (start_orb, ele, param, end_orb) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  ! ** Inout parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** End of parameters **
  ! inout: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  call track1_spin_taylor(start_orb=f_start_orb, ele=f_ele, param=f_param, end_orb=f_end_orb)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_track1_sr_wake (bunch, ele) bind(c)

  use bmad_struct, only: bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call track1_sr_wake(bunch=f_bunch, ele=f_ele)

end subroutine
subroutine fortran_track1_symp_lie_ptc (orbit, ele, param, track) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  call track1_symp_lie_ptc(orbit=f_orbit, ele=f_ele, param=f_param, track=f_track)

  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_track1_taylor (orbit, ele, taylor, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: taylor
  type(taylor_struct), pointer :: f_taylor(:)
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  !! type array (1D_NOT_type)
  call c_f_pointer(taylor, f_taylor, [6])
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track1_taylor(orbit=f_orbit, ele=f_ele, taylor=f_taylor, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3324, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track1_time_runge_kutta (orbit, ele, param, err_flag, track, t_end, dt_step) &
    bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: t_end  ! 0D_NOT_real
  real(c_double) :: f_t_end
  real(c_double), pointer :: f_t_end_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: dt_step  ! 0D_NOT_real
  real(c_double) :: f_dt_step
  real(c_double), pointer :: f_dt_step_ptr
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  ! in: f_t_end 0D_NOT_real
  if (c_associated(t_end)) then
    call c_f_pointer(t_end, f_t_end_ptr)
  else
    f_t_end_ptr => null()
  endif
  ! inout: f_dt_step 0D_NOT_real
  if (c_associated(dt_step)) then
    call c_f_pointer(dt_step, f_dt_step_ptr)
  else
    f_dt_step_ptr => null()
  endif
  call track1_time_runge_kutta(orbit=f_orbit, ele=f_ele, param=f_param, err_flag=f_err_flag, &
      track=f_track, t_end=f_t_end_ptr, dt_step=f_dt_step_ptr)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! inout: f_dt_step 0D_NOT_real
  ! no output conversion for f_dt_step
end subroutine
subroutine fortran_track_a_beambeam (orbit, ele, param, track, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_beambeam(orbit=f_orbit, ele=f_ele, param=f_param, track=f_track, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=2960, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_bend (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_bend(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_track_a_bend_photon (orb, ele, length) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: length  ! 0D_NOT_real
  real(rp) :: f_length
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_length 0D_NOT_real
  f_length = length
  call track_a_bend_photon(orb=f_orb, ele=f_ele, length=f_length)

end subroutine
subroutine fortran_track_a_capillary (orb, ele) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call track_a_capillary(orb=f_orb, ele=f_ele)

end subroutine
subroutine fortran_track_a_converter (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_converter(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=2980, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_crab_cavity (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_crab_cavity(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=2990, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_drift (orb, length, mat6, make_matrix, ele_orientation, &
    include_ref_motion, time) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: length  ! 0D_NOT_real
  real(rp) :: f_length
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  type(c_ptr), intent(in), value :: ele_orientation  ! 0D_NOT_integer
  integer(c_int) :: f_ele_orientation
  integer(c_int), pointer :: f_ele_orientation_ptr
  type(c_ptr), intent(in), value :: include_ref_motion  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_ref_motion
  logical, target :: f_include_ref_motion_native
  logical, pointer :: f_include_ref_motion_native_ptr
  logical(c_bool), pointer :: f_include_ref_motion_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  type(c_ptr), intent(in), value :: time  ! 0D_NOT_real
  real(c_double) :: f_time
  real(c_double), pointer :: f_time_ptr
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_length 0D_NOT_real
  f_length = length
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  ! in: f_ele_orientation 0D_NOT_integer
  if (c_associated(ele_orientation)) then
    call c_f_pointer(ele_orientation, f_ele_orientation_ptr)
  else
    f_ele_orientation_ptr => null()
  endif
  ! in: f_include_ref_motion 0D_NOT_logical
  if (c_associated(include_ref_motion)) then
    call c_f_pointer(include_ref_motion, f_include_ref_motion_ptr)
    f_include_ref_motion_native = f_include_ref_motion_ptr
    f_include_ref_motion_native_ptr => f_include_ref_motion_native
  else
    f_include_ref_motion_native_ptr => null()
  endif
  ! inout: f_time 0D_NOT_real
  if (c_associated(time)) then
    call c_f_pointer(time, f_time_ptr)
  else
    f_time_ptr => null()
  endif
  call track_a_drift(orb=f_orb, length=f_length, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr, ele_orientation=f_ele_orientation_ptr, &
      include_ref_motion=f_include_ref_motion_native_ptr, time=f_time_ptr)

  ! inout: f_time 0D_NOT_real
  ! no output conversion for f_time
end subroutine
subroutine fortran_track_a_drift_photon (orb, length, phase_relative_to_ref) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: length  ! 0D_NOT_real
  real(rp) :: f_length
  logical(c_bool) :: phase_relative_to_ref  ! 0D_NOT_logical
  logical :: f_phase_relative_to_ref
  ! ** Inout parameters **
  type(c_ptr), value :: orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb
  ! ** End of parameters **
  ! inout: f_orb 0D_NOT_type
  if (.not. c_associated(orb)) return
  call c_f_pointer(orb, f_orb)
  ! in: f_length 0D_NOT_real
  f_length = length
  ! in: f_phase_relative_to_ref 0D_NOT_logical
  f_phase_relative_to_ref = phase_relative_to_ref
  call track_a_drift_photon(orb=f_orb, length=f_length, &
      phase_relative_to_ref=f_phase_relative_to_ref)

end subroutine
subroutine fortran_track_a_foil (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_foil(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3127, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_gkicker (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_gkicker(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_track_a_lcavity (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_lcavity(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_track_a_lcavity_old (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_lcavity_old(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_track_a_mask (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_mask(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3048, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_match (orbit, ele, param, err_flag, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_match(orbit=f_orbit, ele=f_ele, param=f_param, err_flag=f_err_flag_native_ptr, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3058, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_patch (ele, orbit, drift_to_exit, s_ent, ds_ref, track_spin, mat6, &
    make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: drift_to_exit  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_drift_to_exit
  logical, target :: f_drift_to_exit_native
  logical, pointer :: f_drift_to_exit_native_ptr
  logical(c_bool), pointer :: f_drift_to_exit_ptr
  type(c_ptr), intent(in), value :: track_spin  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_track_spin
  logical, target :: f_track_spin_native
  logical, pointer :: f_track_spin_native_ptr
  logical(c_bool), pointer :: f_track_spin_ptr
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: s_ent  ! 0D_NOT_real
  real(rp) :: f_s_ent
  real(c_double), pointer :: f_s_ent_ptr
  type(c_ptr), intent(in), value :: ds_ref  ! 0D_NOT_real
  real(rp) :: f_ds_ref
  real(c_double), pointer :: f_ds_ref_ptr
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_drift_to_exit 0D_NOT_logical
  if (c_associated(drift_to_exit)) then
    call c_f_pointer(drift_to_exit, f_drift_to_exit_ptr)
    f_drift_to_exit_native = f_drift_to_exit_ptr
    f_drift_to_exit_native_ptr => f_drift_to_exit_native
  else
    f_drift_to_exit_native_ptr => null()
  endif
  ! in: f_track_spin 0D_NOT_logical
  if (c_associated(track_spin)) then
    call c_f_pointer(track_spin, f_track_spin_ptr)
    f_track_spin_native = f_track_spin_ptr
    f_track_spin_native_ptr => f_track_spin_native
  else
    f_track_spin_native_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_patch(ele=f_ele, orbit=f_orbit, drift_to_exit=f_drift_to_exit_native_ptr, &
      s_ent=f_s_ent, ds_ref=f_ds_ref, track_spin=f_track_spin_native_ptr, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_s_ent 0D_NOT_real
  ! no output conversion for f_s_ent
  ! out: f_ds_ref 0D_NOT_real
  ! no output conversion for f_ds_ref
  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3077, definition='real(rp), optional :: mat6(6,6), s_ent, ds_ref', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_patch_photon (ele, orbit, drift_to_exit, use_z_pos) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: drift_to_exit  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_drift_to_exit
  logical, target :: f_drift_to_exit_native
  logical, pointer :: f_drift_to_exit_native_ptr
  logical(c_bool), pointer :: f_drift_to_exit_ptr
  type(c_ptr), intent(in), value :: use_z_pos  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_z_pos
  logical, target :: f_use_z_pos_native
  logical, pointer :: f_use_z_pos_native_ptr
  logical(c_bool), pointer :: f_use_z_pos_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_drift_to_exit 0D_NOT_logical
  if (c_associated(drift_to_exit)) then
    call c_f_pointer(drift_to_exit, f_drift_to_exit_ptr)
    f_drift_to_exit_native = f_drift_to_exit_ptr
    f_drift_to_exit_native_ptr => f_drift_to_exit_native
  else
    f_drift_to_exit_native_ptr => null()
  endif
  ! in: f_use_z_pos 0D_NOT_logical
  if (c_associated(use_z_pos)) then
    call c_f_pointer(use_z_pos, f_use_z_pos_ptr)
    f_use_z_pos_native = f_use_z_pos_ptr
    f_use_z_pos_native_ptr => f_use_z_pos_native
  else
    f_use_z_pos_native_ptr => null()
  endif
  call track_a_patch_photon(ele=f_ele, orbit=f_orbit, drift_to_exit=f_drift_to_exit_native_ptr, &
      use_z_pos=f_use_z_pos_native_ptr)

end subroutine
subroutine fortran_track_a_pickup (orbit, ele, param, err_flag, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_pickup(orbit=f_orbit, ele=f_ele, param=f_param, err_flag=f_err_flag_native_ptr, &
      mat6=f_mat6, make_matrix=f_make_matrix_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3068, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_quadrupole (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_quadrupole(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3087, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_rfcavity (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_rfcavity(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3097, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_sad_mult (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_sad_mult(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_track_a_sol_quad (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_sol_quad(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3117, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_thick_multipole (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  !! general array (2D_NOT_real)
  if (c_associated(mat6)) then
    call c_f_pointer(mat6, f_mat6_ptr, [6*6])
    call vec2mat(f_mat6_ptr, f_mat6)
  else
    f_mat6_ptr => null()
  endif
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_thick_multipole(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

end subroutine
subroutine fortran_track_a_wiggler (orbit, ele, param, mat6, make_matrix) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  type(c_ptr), intent(in), value :: make_matrix  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_make_matrix
  logical, target :: f_make_matrix_native
  logical, pointer :: f_make_matrix_native_ptr
  logical(c_bool), pointer :: f_make_matrix_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat6
  real(rp) :: f_mat6(6,6)
  real(c_double), pointer :: f_mat6_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_make_matrix 0D_NOT_logical
  if (c_associated(make_matrix)) then
    call c_f_pointer(make_matrix, f_make_matrix_ptr)
    f_make_matrix_native = f_make_matrix_ptr
    f_make_matrix_native_ptr => f_make_matrix_native
  else
    f_make_matrix_native_ptr => null()
  endif
  call track_a_wiggler(orbit=f_orbit, ele=f_ele, param=f_param, mat6=f_mat6, &
      make_matrix=f_make_matrix_native_ptr)

  ! out: f_mat6 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat6', c_name='mat6', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3147, definition='real(rp), optional :: mat6(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=True, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat6', comment='', default=None), intent='out', description='Transfer matrix through the element.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_track_a_zero_length_element (orbit, ele, param, err_flag, track) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(param, f_param)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  call track_a_zero_length_element(orbit=f_orbit, ele=f_ele, param=f_param, &
      err_flag=f_err_flag, track=f_track)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_track_all (lat, orbit, ix_branch, track_state, err_flag, orbit0, init_lost) &
    bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: init_lost  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_init_lost
  logical, target :: f_init_lost_native
  logical, pointer :: f_init_lost_native_ptr
  logical(c_bool), pointer :: f_init_lost_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: track_state  ! 0D_NOT_integer
  integer :: f_track_state
  integer(c_int), pointer :: f_track_state_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: orbit0
  type(coord_struct_container_alloc), pointer :: f_orbit0
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit0))   call c_f_pointer(orbit0, f_orbit0)
  ! in: f_init_lost 0D_NOT_logical
  if (c_associated(init_lost)) then
    call c_f_pointer(init_lost, f_init_lost_ptr)
    f_init_lost_native = f_init_lost_ptr
    f_init_lost_native_ptr => f_init_lost_native
  else
    f_init_lost_native_ptr => null()
  endif
  call track_all(lat=f_lat, orbit=f_orbit%data, ix_branch=f_ix_branch_ptr, &
      track_state=f_track_state, err_flag=f_err_flag, orbit0=f_orbit0%data, &
      init_lost=f_init_lost_native_ptr)

  ! out: f_track_state 0D_NOT_integer
  ! no output conversion for f_track_state
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_track_beam (lat, beam, ele1, ele2, err, centroid, direction, bunch_tracks) &
    bind(c)

  use bmad_struct, only: beam_struct, bunch_track_struct, coord_struct, ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  type(c_ptr), intent(in), value :: centroid
  type(coord_struct_container_alloc), pointer :: f_centroid
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: bunch_tracks
  type(bunch_track_struct_container_alloc), pointer :: f_bunch_tracks
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  ! in: f_ele1 0D_NOT_type
  if (c_associated(ele1))   call c_f_pointer(ele1, f_ele1)
  ! in: f_ele2 0D_NOT_type
  if (c_associated(ele2))   call c_f_pointer(ele2, f_ele2)
  !! container type array (1D_ALLOC_type)
  if (c_associated(centroid))   call c_f_pointer(centroid, f_centroid)
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(bunch_tracks))   call c_f_pointer(bunch_tracks, f_bunch_tracks)
  call track_beam(lat=f_lat, beam=f_beam, ele1=f_ele1, ele2=f_ele2, err=f_err, &
      centroid=f_centroid%data, direction=f_direction_ptr, bunch_tracks=f_bunch_tracks%data)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track_bunch (lat, bunch, ele1, ele2, err, centroid, direction, bunch_track) &
    bind(c)

  use bmad_struct, only: bunch_struct, bunch_track_struct, coord_struct, ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  type(c_ptr), intent(in), value :: centroid
  type(coord_struct_container_alloc), pointer :: f_centroid
  type(c_ptr), intent(in), value :: direction  ! 0D_NOT_integer
  integer(c_int) :: f_direction
  integer(c_int), pointer :: f_direction_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: bunch_track  ! 0D_NOT_type
  type(bunch_track_struct), pointer :: f_bunch_track
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele1 0D_NOT_type
  if (c_associated(ele1))   call c_f_pointer(ele1, f_ele1)
  ! in: f_ele2 0D_NOT_type
  if (c_associated(ele2))   call c_f_pointer(ele2, f_ele2)
  !! container type array (1D_ALLOC_type)
  if (c_associated(centroid))   call c_f_pointer(centroid, f_centroid)
  ! in: f_direction 0D_NOT_integer
  if (c_associated(direction)) then
    call c_f_pointer(direction, f_direction_ptr)
  else
    f_direction_ptr => null()
  endif
  ! inout: f_bunch_track 0D_NOT_type
  if (c_associated(bunch_track))   call c_f_pointer(bunch_track, f_bunch_track)
  call track_bunch(lat=f_lat, bunch=f_bunch, ele1=f_ele1, ele2=f_ele2, err=f_err, &
      centroid=f_centroid%data, direction=f_direction_ptr, bunch_track=f_bunch_track)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_track_bunch_time (bunch, branch, t_end, s_end, dt_step, extra_field) bind(c)

  use bmad_struct, only: branch_struct, bunch_struct, em_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  real(c_double) :: t_end  ! 0D_NOT_real
  real(rp) :: f_t_end
  real(c_double) :: s_end  ! 0D_NOT_real
  real(rp) :: f_s_end
  type(c_ptr), intent(in), value :: extra_field
  type(em_field_struct_container_alloc), pointer :: f_extra_field
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), intent(in), value :: dt_step
  type(real_container_alloc), pointer :: f_dt_step
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_t_end 0D_NOT_real
  f_t_end = t_end
  ! in: f_s_end 0D_NOT_real
  f_s_end = s_end
  !! container general array (1D_ALLOC_real)
  if (c_associated(dt_step))   call c_f_pointer(dt_step, f_dt_step)
  !! container type array (1D_ALLOC_type)
  if (c_associated(extra_field))   call c_f_pointer(extra_field, f_extra_field)
  call track_bunch_time(bunch=f_bunch, branch=f_branch, t_end=f_t_end, s_end=f_s_end, &
      dt_step=f_dt_step%data, extra_field=f_extra_field%data)

end subroutine
subroutine fortran_track_bunch_to_s (bunch, s, branch) bind(c)

  use bmad_struct, only: branch_struct, bunch_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: s  ! 0D_NOT_real
  real(rp) :: f_s
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_s 0D_NOT_real
  f_s = s
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call track_bunch_to_s(bunch=f_bunch, s=f_s, branch=f_branch)

end subroutine
subroutine fortran_track_bunch_to_t (bunch, t_target, branch) bind(c)

  use bmad_struct, only: branch_struct, bunch_struct
  implicit none
  ! ** In parameters **
  real(c_double) :: t_target  ! 0D_NOT_real
  real(rp) :: f_t_target
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  ! ** Inout parameters **
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  ! ** End of parameters **
  ! inout: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_t_target 0D_NOT_real
  f_t_target = t_target
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  call track_bunch_to_t(bunch=f_bunch, t_target=f_t_target, branch=f_branch)

end subroutine
subroutine fortran_track_complex_taylor (start_orb, complex_taylor, end_orb) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: start_orb
  type(complex_container_alloc), pointer :: f_start_orb
  type(c_ptr), intent(in), value :: complex_taylor
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: end_orb
  type(complex_container_alloc), pointer :: f_end_orb
  ! ** End of parameters **
  !! container general array (1D_ALLOC_complex)
  if (c_associated(start_orb))   call c_f_pointer(start_orb, f_start_orb)
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor))   call c_f_pointer(complex_taylor, f_complex_taylor)
  !! container general array (1D_ALLOC_complex)
  if (c_associated(end_orb))   call c_f_pointer(end_orb, f_end_orb)
  call track_complex_taylor(start_orb=f_start_orb%data, complex_taylor=f_complex_taylor%data, &
      end_orb=f_end_orb%data)

end subroutine
subroutine fortran_track_from_s_to_s (lat, s_start, s_end, orbit_start, orbit_end, all_orb, &
    ix_branch, track_state, ix_ele_end) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  real(c_double) :: s_start  ! 0D_NOT_real
  real(rp) :: f_s_start
  real(c_double) :: s_end  ! 0D_NOT_real
  real(rp) :: f_s_end
  type(c_ptr), value :: orbit_start  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit_start
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: ix_ele_end  ! 0D_NOT_integer
  integer(c_int) :: f_ix_ele_end
  integer(c_int), pointer :: f_ix_ele_end_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orbit_end  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit_end
  type(c_ptr), intent(in), value :: all_orb
  type(coord_struct_container_alloc), pointer :: f_all_orb
  type(c_ptr), intent(in), value :: track_state  ! 0D_NOT_integer
  integer :: f_track_state
  integer(c_int), pointer :: f_track_state_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_s_start 0D_NOT_real
  f_s_start = s_start
  ! in: f_s_end 0D_NOT_real
  f_s_end = s_end
  ! in: f_orbit_start 0D_NOT_type
  if (.not. c_associated(orbit_start)) return
  call c_f_pointer(orbit_start, f_orbit_start)
  ! out: f_orbit_end 0D_NOT_type
  if (.not. c_associated(orbit_end)) return
  call c_f_pointer(orbit_end, f_orbit_end)
  !! container type array (1D_ALLOC_type)
  if (c_associated(all_orb))   call c_f_pointer(all_orb, f_all_orb)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_ix_ele_end 0D_NOT_integer
  if (c_associated(ix_ele_end)) then
    call c_f_pointer(ix_ele_end, f_ix_ele_end_ptr)
  else
    f_ix_ele_end_ptr => null()
  endif
  call track_from_s_to_s(lat=f_lat, s_start=f_s_start, s_end=f_s_end, &
      orbit_start=f_orbit_start, orbit_end=f_orbit_end, all_orb=f_all_orb%data, &
      ix_branch=f_ix_branch_ptr, track_state=f_track_state, ix_ele_end=f_ix_ele_end_ptr)

  ! out: f_orbit_end 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_track_state 0D_NOT_integer
  ! no output conversion for f_track_state
end subroutine
subroutine fortran_track_many (lat, orbit, ix_start, ix_end, direction, ix_branch, track_state) &
    bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  integer(c_int) :: ix_start  ! 0D_NOT_integer
  integer :: f_ix_start
  integer(c_int) :: ix_end  ! 0D_NOT_integer
  integer :: f_ix_end
  integer(c_int) :: direction  ! 0D_NOT_integer
  integer :: f_direction
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: track_state  ! 0D_NOT_integer
  integer :: f_track_state
  integer(c_int), pointer :: f_track_state_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: orbit
  type(coord_struct_container_alloc), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  ! in: f_ix_start 0D_NOT_integer
  f_ix_start = ix_start
  ! in: f_ix_end 0D_NOT_integer
  f_ix_end = ix_end
  ! in: f_direction 0D_NOT_integer
  f_direction = direction
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call track_many(lat=f_lat, orbit=f_orbit%data, ix_start=f_ix_start, ix_end=f_ix_end, &
      direction=f_direction, ix_branch=f_ix_branch_ptr, track_state=f_track_state)

  ! out: f_track_state 0D_NOT_integer
  ! no output conversion for f_track_state
end subroutine
subroutine fortran_track_to_surface (ele, orbit, param, w_surface) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_surface
  real(rp) :: f_w_surface(3,3)
  real(c_double), pointer :: f_w_surface_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  call track_to_surface(ele=f_ele, orbit=f_orbit, param=f_param, w_surface=f_w_surface)

  ! out: f_w_surface 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_surface', c_name='w_surface', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=3208, definition='real(rp) :: w_surface(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_surface', comment='', default=None), intent='out', description='real(rp), rotation matrix to transform to surface coords.', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_track_until_dead (start_orb, lat, end_orb, track) bind(c)

  use bmad_struct, only: coord_struct, lat_struct, track_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: start_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_start_orb
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), value :: end_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_end_orb
  type(c_ptr), value :: track  ! 0D_NOT_type
  type(track_struct), pointer :: f_track
  ! ** End of parameters **
  ! in: f_start_orb 0D_NOT_type
  if (.not. c_associated(start_orb)) return
  call c_f_pointer(start_orb, f_start_orb)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! out: f_end_orb 0D_NOT_type
  if (.not. c_associated(end_orb)) return
  call c_f_pointer(end_orb, f_end_orb)
  ! out: f_track 0D_NOT_type
  if (c_associated(track))   call c_f_pointer(track, f_track)
  call track_until_dead(start_orb=f_start_orb, lat=f_lat, end_orb=f_end_orb, track=f_track)

  ! out: f_end_orb 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_track 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_tracking_rad_map_setup (ele, tollerance, ref_edge, rad_map, err_flag) &
    bind(c)

  use bmad_struct, only: ele_struct, rad_map_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  real(c_double) :: tollerance  ! 0D_NOT_real
  real(rp) :: f_tollerance
  integer(c_int) :: ref_edge  ! 0D_NOT_integer
  integer :: f_ref_edge
  ! ** Out parameters **
  type(c_ptr), value :: rad_map  ! 0D_NOT_type
  type(rad_map_struct), pointer :: f_rad_map
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_tollerance 0D_NOT_real
  f_tollerance = tollerance
  ! in: f_ref_edge 0D_NOT_integer
  f_ref_edge = ref_edge
  ! out: f_rad_map 0D_NOT_type
  if (.not. c_associated(rad_map)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(rad_map, f_rad_map)
  call tracking_rad_map_setup(ele=f_ele, tollerance=f_tollerance, ref_edge=f_ref_edge, &
      rad_map=f_rad_map, err_flag=f_err_flag)

  ! out: f_rad_map 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_transfer_ac_kick (ac_in, ac_out) bind(c)

  use bmad_struct, only: ac_kicker_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ac_in  ! 0D_PTR_type
  type(ac_kicker_struct), pointer :: f_ac_in
  ! ** Out parameters **
  type(c_ptr), value :: ac_out  ! 0D_PTR_type
  type(ac_kicker_struct), pointer :: f_ac_out
  ! ** End of parameters **
  ! in: f_ac_in 0D_PTR_type
  if (.not. c_associated(ac_in)) return
  call c_f_pointer(ac_in, f_ac_in)
  ! out: f_ac_out 0D_PTR_type
  if (.not. c_associated(ac_out)) return
  call c_f_pointer(ac_out, f_ac_out)
  call transfer_ac_kick(ac_in=f_ac_in, ac_out=f_ac_out)

  ! out: f_ac_out 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_transfer_branch (branch1, branch2) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch1  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch1
  ! ** Out parameters **
  type(c_ptr), value :: branch2  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch2
  ! ** End of parameters **
  ! in: f_branch1 0D_NOT_type
  if (.not. c_associated(branch1)) return
  call c_f_pointer(branch1, f_branch1)
  ! out: f_branch2 0D_NOT_type
  if (.not. c_associated(branch2)) return
  call c_f_pointer(branch2, f_branch2)
  call transfer_branch(branch1=f_branch1, branch2=f_branch2)

  ! out: f_branch2 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_branch_parameters (branch_in, branch_out) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch_in  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch_in
  ! ** Out parameters **
  type(c_ptr), value :: branch_out  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch_out
  ! ** End of parameters **
  ! in: f_branch_in 0D_NOT_type
  if (.not. c_associated(branch_in)) return
  call c_f_pointer(branch_in, f_branch_in)
  ! out: f_branch_out 0D_NOT_type
  if (.not. c_associated(branch_out)) return
  call c_f_pointer(branch_out, f_branch_out)
  call transfer_branch_parameters(branch_in=f_branch_in, branch_out=f_branch_out)

  ! out: f_branch_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_branches (branch1, branch2) bind(c)

  use bmad_struct, only: branch_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: branch1
  type(branch_struct_container_alloc), pointer :: f_branch1
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: branch2
  type(branch_struct_container_alloc), pointer :: f_branch2
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(branch1))   call c_f_pointer(branch1, f_branch1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(branch2))   call c_f_pointer(branch2, f_branch2)
  call transfer_branches(branch1=f_branch1%data, branch2=f_branch2%data)

end subroutine
subroutine fortran_transfer_ele (ele1, ele2, nullify_pointers) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), intent(in), value :: nullify_pointers  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_nullify_pointers
  logical, target :: f_nullify_pointers_native
  logical, pointer :: f_nullify_pointers_native_ptr
  logical(c_bool), pointer :: f_nullify_pointers_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  ! ** End of parameters **
  ! in: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  ! out: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  ! in: f_nullify_pointers 0D_NOT_logical
  if (c_associated(nullify_pointers)) then
    call c_f_pointer(nullify_pointers, f_nullify_pointers_ptr)
    f_nullify_pointers_native = f_nullify_pointers_ptr
    f_nullify_pointers_native_ptr => f_nullify_pointers_native
  else
    f_nullify_pointers_native_ptr => null()
  endif
  call transfer_ele(ele1=f_ele1, ele2=f_ele2, nullify_pointers=f_nullify_pointers_native_ptr)

  ! out: f_ele2 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_ele_taylor (ele_in, ele_out, taylor_order) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_in
  type(c_ptr), intent(in), value :: taylor_order  ! 0D_NOT_integer
  integer(c_int) :: f_taylor_order
  integer(c_int), pointer :: f_taylor_order_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ele_out  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_out
  ! ** End of parameters **
  ! in: f_ele_in 0D_NOT_type
  if (.not. c_associated(ele_in)) return
  call c_f_pointer(ele_in, f_ele_in)
  ! out: f_ele_out 0D_NOT_type
  if (.not. c_associated(ele_out)) return
  call c_f_pointer(ele_out, f_ele_out)
  ! in: f_taylor_order 0D_NOT_integer
  if (c_associated(taylor_order)) then
    call c_f_pointer(taylor_order, f_taylor_order_ptr)
  else
    f_taylor_order_ptr => null()
  endif
  call transfer_ele_taylor(ele_in=f_ele_in, ele_out=f_ele_out, taylor_order=f_taylor_order_ptr)

  ! out: f_ele_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_eles (ele1, ele2) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ele1
  type(ele_struct_container_alloc), pointer :: f_ele1
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: ele2
  type(ele_struct_container_alloc), pointer :: f_ele2
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(ele1))   call c_f_pointer(ele1, f_ele1)
  !! container type array (1D_ALLOC_type)
  if (c_associated(ele2))   call c_f_pointer(ele2, f_ele2)
  call transfer_eles(ele1=f_ele1%data, ele2=f_ele2%data)

end subroutine
subroutine fortran_transfer_fieldmap (ele_in, ele_out, who) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_in
  integer(c_int) :: who  ! 0D_NOT_integer
  integer :: f_who
  ! ** Out parameters **
  type(c_ptr), value :: ele_out  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_out
  ! ** End of parameters **
  ! in: f_ele_in 0D_NOT_type
  if (.not. c_associated(ele_in)) return
  call c_f_pointer(ele_in, f_ele_in)
  ! out: f_ele_out 0D_NOT_type
  if (.not. c_associated(ele_out)) return
  call c_f_pointer(ele_out, f_ele_out)
  ! in: f_who 0D_NOT_integer
  f_who = who
  call transfer_fieldmap(ele_in=f_ele_in, ele_out=f_ele_out, who=f_who)

  ! out: f_ele_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_fixer_params (fixer, to_stored, orbit, who, is_ok) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: fixer  ! 0D_NOT_type
  type(ele_struct), pointer :: f_fixer
  logical(c_bool) :: to_stored  ! 0D_NOT_logical
  logical :: f_to_stored
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), intent(in), value :: who
  character(len=4096), target :: f_who
  character(kind=c_char), pointer :: f_who_ptr(:)
  character(len=4096), pointer :: f_who_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_ok  ! 0D_NOT_logical
  logical :: f_is_ok
  logical(c_bool), pointer :: f_is_ok_ptr
  ! ** End of parameters **
  ! in: f_fixer 0D_NOT_type
  if (.not. c_associated(fixer)) return
  call c_f_pointer(fixer, f_fixer)
  ! in: f_to_stored 0D_NOT_logical
  f_to_stored = to_stored
  ! in: f_orbit 0D_NOT_type
  if (c_associated(orbit))   call c_f_pointer(orbit, f_orbit)
  ! in: f_who 0D_NOT_character
  if (c_associated(who)) then
    call c_f_pointer(who, f_who_ptr, [huge(0)])
    call to_f_str(f_who_ptr, f_who)
    f_who_call_ptr => f_who
  else
    f_who_call_ptr => null()
  endif
  f_is_ok = transfer_fixer_params(fixer=f_fixer, to_stored=f_to_stored, orbit=f_orbit, &
      who=f_who_call_ptr)

  ! out: f_is_ok 0D_NOT_logical
  call c_f_pointer(is_ok, f_is_ok_ptr)
  f_is_ok_ptr = f_is_ok
end subroutine
subroutine fortran_transfer_lat (lat1, lat2) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat1  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat1
  ! ** Out parameters **
  type(c_ptr), value :: lat2  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat2
  ! ** End of parameters **
  ! in: f_lat1 0D_NOT_type
  if (.not. c_associated(lat1)) return
  call c_f_pointer(lat1, f_lat1)
  ! out: f_lat2 0D_NOT_type
  if (.not. c_associated(lat2)) return
  call c_f_pointer(lat2, f_lat2)
  call transfer_lat(lat1=f_lat1, lat2=f_lat2)

  ! out: f_lat2 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_lat_parameters (lat_in, lat_out) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat_in  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_in
  ! ** Out parameters **
  type(c_ptr), value :: lat_out  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat_out
  ! ** End of parameters **
  ! in: f_lat_in 0D_NOT_type
  if (.not. c_associated(lat_in)) return
  call c_f_pointer(lat_in, f_lat_in)
  ! out: f_lat_out 0D_NOT_type
  if (.not. c_associated(lat_out)) return
  call c_f_pointer(lat_out, f_lat_out)
  call transfer_lat_parameters(lat_in=f_lat_in, lat_out=f_lat_out)

  ! out: f_lat_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_map_calc (lat, orb_map, err_flag, ix1, ix2, ref_orb, ix_branch, &
    one_turn, unit_start, concat_if_possible, spin_map) bind(c)

  use bmad_struct, only: coord_struct, lat_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix1  ! 0D_NOT_integer
  integer(c_int) :: f_ix1
  integer(c_int), pointer :: f_ix1_ptr
  type(c_ptr), intent(in), value :: ix2  ! 0D_NOT_integer
  integer(c_int) :: f_ix2
  integer(c_int), pointer :: f_ix2_ptr
  type(c_ptr), value :: ref_orb  ! 0D_NOT_type
  type(coord_struct), pointer :: f_ref_orb
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: one_turn  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_one_turn
  logical, target :: f_one_turn_native
  logical, pointer :: f_one_turn_native_ptr
  logical(c_bool), pointer :: f_one_turn_ptr
  type(c_ptr), intent(in), value :: unit_start  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_unit_start
  logical, target :: f_unit_start_native
  logical, pointer :: f_unit_start_native_ptr
  logical(c_bool), pointer :: f_unit_start_ptr
  type(c_ptr), intent(in), value :: concat_if_possible  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_concat_if_possible
  logical, target :: f_concat_if_possible_native
  logical, pointer :: f_concat_if_possible_native_ptr
  logical(c_bool), pointer :: f_concat_if_possible_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: orb_map
  type(taylor_struct_container_alloc), pointer :: f_orb_map
  type(c_ptr), intent(in), value :: spin_map
  type(taylor_struct_container_alloc), pointer :: f_spin_map
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb_map))   call c_f_pointer(orb_map, f_orb_map)
  ! in: f_ix1 0D_NOT_integer
  if (c_associated(ix1)) then
    call c_f_pointer(ix1, f_ix1_ptr)
  else
    f_ix1_ptr => null()
  endif
  ! in: f_ix2 0D_NOT_integer
  if (c_associated(ix2)) then
    call c_f_pointer(ix2, f_ix2_ptr)
  else
    f_ix2_ptr => null()
  endif
  ! in: f_ref_orb 0D_NOT_type
  if (c_associated(ref_orb))   call c_f_pointer(ref_orb, f_ref_orb)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_one_turn 0D_NOT_logical
  if (c_associated(one_turn)) then
    call c_f_pointer(one_turn, f_one_turn_ptr)
    f_one_turn_native = f_one_turn_ptr
    f_one_turn_native_ptr => f_one_turn_native
  else
    f_one_turn_native_ptr => null()
  endif
  ! in: f_unit_start 0D_NOT_logical
  if (c_associated(unit_start)) then
    call c_f_pointer(unit_start, f_unit_start_ptr)
    f_unit_start_native = f_unit_start_ptr
    f_unit_start_native_ptr => f_unit_start_native
  else
    f_unit_start_native_ptr => null()
  endif
  ! in: f_concat_if_possible 0D_NOT_logical
  if (c_associated(concat_if_possible)) then
    call c_f_pointer(concat_if_possible, f_concat_if_possible_ptr)
    f_concat_if_possible_native = f_concat_if_possible_ptr
    f_concat_if_possible_native_ptr => f_concat_if_possible_native
  else
    f_concat_if_possible_native_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(spin_map))   call c_f_pointer(spin_map, f_spin_map)
  call transfer_map_calc(lat=f_lat, orb_map=f_orb_map%data, err_flag=f_err_flag, ix1=f_ix1_ptr, &
      ix2=f_ix2_ptr, ref_orb=f_ref_orb, ix_branch=f_ix_branch_ptr, &
      one_turn=f_one_turn_native_ptr, unit_start=f_unit_start_native_ptr, &
      concat_if_possible=f_concat_if_possible_native_ptr, spin_map=f_spin_map%data)

  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_transfer_map_from_s_to_s (lat, t_map, s1, s2, ref_orb_in, ref_orb_out, &
    ix_branch, one_turn, unit_start, err_flag, concat_if_possible, spin_map) bind(c)

  use bmad_struct, only: coord_struct, lat_struct, taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: s1  ! 0D_NOT_real
  real(c_double) :: f_s1
  real(c_double), pointer :: f_s1_ptr
  type(c_ptr), intent(in), value :: s2  ! 0D_NOT_real
  real(c_double) :: f_s2
  real(c_double), pointer :: f_s2_ptr
  type(c_ptr), value :: ref_orb_in  ! 0D_NOT_type
  type(coord_struct), pointer :: f_ref_orb_in
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: one_turn  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_one_turn
  logical, target :: f_one_turn_native
  logical, pointer :: f_one_turn_native_ptr
  logical(c_bool), pointer :: f_one_turn_ptr
  type(c_ptr), intent(in), value :: unit_start  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_unit_start
  logical, target :: f_unit_start_native
  logical, pointer :: f_unit_start_native_ptr
  logical(c_bool), pointer :: f_unit_start_ptr
  type(c_ptr), intent(in), value :: concat_if_possible  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_concat_if_possible
  logical, target :: f_concat_if_possible_native
  logical, pointer :: f_concat_if_possible_native_ptr
  logical(c_bool), pointer :: f_concat_if_possible_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ref_orb_out  ! 0D_NOT_type
  type(coord_struct), pointer :: f_ref_orb_out
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: t_map
  type(taylor_struct_container_alloc), pointer :: f_t_map
  type(c_ptr), intent(in), value :: spin_map
  type(taylor_struct_container_alloc), pointer :: f_spin_map
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(t_map))   call c_f_pointer(t_map, f_t_map)
  ! in: f_s1 0D_NOT_real
  if (c_associated(s1)) then
    call c_f_pointer(s1, f_s1_ptr)
  else
    f_s1_ptr => null()
  endif
  ! in: f_s2 0D_NOT_real
  if (c_associated(s2)) then
    call c_f_pointer(s2, f_s2_ptr)
  else
    f_s2_ptr => null()
  endif
  ! in: f_ref_orb_in 0D_NOT_type
  if (c_associated(ref_orb_in))   call c_f_pointer(ref_orb_in, f_ref_orb_in)
  ! out: f_ref_orb_out 0D_NOT_type
  if (c_associated(ref_orb_out))   call c_f_pointer(ref_orb_out, f_ref_orb_out)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_one_turn 0D_NOT_logical
  if (c_associated(one_turn)) then
    call c_f_pointer(one_turn, f_one_turn_ptr)
    f_one_turn_native = f_one_turn_ptr
    f_one_turn_native_ptr => f_one_turn_native
  else
    f_one_turn_native_ptr => null()
  endif
  ! in: f_unit_start 0D_NOT_logical
  if (c_associated(unit_start)) then
    call c_f_pointer(unit_start, f_unit_start_ptr)
    f_unit_start_native = f_unit_start_ptr
    f_unit_start_native_ptr => f_unit_start_native
  else
    f_unit_start_native_ptr => null()
  endif
  ! in: f_concat_if_possible 0D_NOT_logical
  if (c_associated(concat_if_possible)) then
    call c_f_pointer(concat_if_possible, f_concat_if_possible_ptr)
    f_concat_if_possible_native = f_concat_if_possible_ptr
    f_concat_if_possible_native_ptr => f_concat_if_possible_native
  else
    f_concat_if_possible_native_ptr => null()
  endif
  !! container type array (1D_ALLOC_type)
  if (c_associated(spin_map))   call c_f_pointer(spin_map, f_spin_map)
  call transfer_map_from_s_to_s(lat=f_lat, t_map=f_t_map%data, s1=f_s1_ptr, s2=f_s2_ptr, &
      ref_orb_in=f_ref_orb_in, ref_orb_out=f_ref_orb_out, ix_branch=f_ix_branch_ptr, &
      one_turn=f_one_turn_native_ptr, unit_start=f_unit_start_native_ptr, err_flag=f_err_flag, &
      concat_if_possible=f_concat_if_possible_native_ptr, spin_map=f_spin_map%data)

  ! out: f_ref_orb_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_transfer_mat2_from_twiss (twiss1, twiss2, mat) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: twiss1  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss1
  type(c_ptr), value :: twiss2  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss2
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat
  real(rp) :: f_mat(2,2)
  real(c_double), pointer :: f_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_twiss1 0D_NOT_type
  if (.not. c_associated(twiss1)) return
  call c_f_pointer(twiss1, f_twiss1)
  ! in: f_twiss2 0D_NOT_type
  if (.not. c_associated(twiss2)) return
  call c_f_pointer(twiss2, f_twiss2)
  call transfer_mat2_from_twiss(twiss1=f_twiss1, twiss2=f_twiss2, mat=f_mat)

  ! out: f_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat', c_name='mat', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=3445, definition='real(rp) mat(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat', comment='', default=None), intent='out', description='Transfer matrix between the two points.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_transfer_mat_from_twiss (ele1, ele2, orb1, orb2, m) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  type(c_ptr), intent(in), value :: orb1
  real(rp) :: f_orb1(6)
  real(c_double), pointer :: f_orb1_ptr(:)
  type(c_ptr), intent(in), value :: orb2
  real(rp) :: f_orb2(6)
  real(c_double), pointer :: f_orb2_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: m
  real(rp) :: f_m(6,6)
  real(c_double), pointer :: f_m_ptr(:)
  ! ** End of parameters **
  ! in: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  ! in: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  !! general array (1D_NOT_real)
  if (c_associated(orb1)) then
    call c_f_pointer(orb1, f_orb1_ptr, [6])
    f_orb1 = f_orb1_ptr(:)
  else
    f_orb1_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(orb2)) then
    call c_f_pointer(orb2, f_orb2_ptr, [6])
    f_orb2 = f_orb2_ptr(:)
  else
    f_orb2_ptr => null()
  endif
  call transfer_mat_from_twiss(ele1=f_ele1, ele2=f_ele2, orb1=f_orb1, orb2=f_orb2, m=f_m)

  ! out: f_m 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_m', c_name='m', type='real', kind='rp', pointer_type='NOT', array=['6', '6'], init_value=None, comment='', member=StructureMember(line=3438, definition='real(rp) m(6,6)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='6,6', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='m', comment='', default=None), intent='out', description='Transfer matrix between the two points.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_transfer_matrix_calc (lat, xfer_mat, xfer_vec, ix1, ix2, ix_branch, &
    one_turn) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix1  ! 0D_NOT_integer
  integer(c_int) :: f_ix1
  integer(c_int), pointer :: f_ix1_ptr
  type(c_ptr), intent(in), value :: ix2  ! 0D_NOT_integer
  integer(c_int) :: f_ix2
  integer(c_int), pointer :: f_ix2_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: one_turn  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_one_turn
  logical, target :: f_one_turn_native
  logical, pointer :: f_one_turn_native_ptr
  logical(c_bool), pointer :: f_one_turn_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: xfer_mat
  real(rp) :: f_xfer_mat(6,6)
  real(c_double), pointer :: f_xfer_mat_ptr(:)
  type(c_ptr), intent(in), value :: xfer_vec
  real(rp) :: f_xfer_vec(6)
  real(c_double), pointer :: f_xfer_vec_ptr(:)
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! general array (2D_NOT_real)
  if (c_associated(xfer_mat)) then
    call c_f_pointer(xfer_mat, f_xfer_mat_ptr, [6*6])
    call vec2mat(f_xfer_mat_ptr, f_xfer_mat)
  else
    f_xfer_mat_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(xfer_vec)) then
    call c_f_pointer(xfer_vec, f_xfer_vec_ptr, [6])
    f_xfer_vec = f_xfer_vec_ptr(:)
  else
    f_xfer_vec_ptr => null()
  endif
  ! in: f_ix1 0D_NOT_integer
  if (c_associated(ix1)) then
    call c_f_pointer(ix1, f_ix1_ptr)
  else
    f_ix1_ptr => null()
  endif
  ! in: f_ix2 0D_NOT_integer
  if (c_associated(ix2)) then
    call c_f_pointer(ix2, f_ix2_ptr)
  else
    f_ix2_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_one_turn 0D_NOT_logical
  if (c_associated(one_turn)) then
    call c_f_pointer(one_turn, f_one_turn_ptr)
    f_one_turn_native = f_one_turn_ptr
    f_one_turn_native_ptr => f_one_turn_native
  else
    f_one_turn_native_ptr => null()
  endif
  call transfer_matrix_calc(lat=f_lat, xfer_mat=f_xfer_mat, xfer_vec=f_xfer_vec, ix1=f_ix1_ptr, &
      ix2=f_ix2_ptr, ix_branch=f_ix_branch_ptr, one_turn=f_one_turn_native_ptr)

end subroutine
subroutine fortran_transfer_twiss (ele_in, ele_out, reverse) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele_in  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_in
  type(c_ptr), intent(in), value :: reverse  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_reverse
  logical, target :: f_reverse_native
  logical, pointer :: f_reverse_native_ptr
  logical(c_bool), pointer :: f_reverse_ptr
  ! ** Out parameters **
  type(c_ptr), value :: ele_out  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_out
  ! ** End of parameters **
  ! in: f_ele_in 0D_NOT_type
  if (.not. c_associated(ele_in)) return
  call c_f_pointer(ele_in, f_ele_in)
  ! out: f_ele_out 0D_NOT_type
  if (.not. c_associated(ele_out)) return
  call c_f_pointer(ele_out, f_ele_out)
  ! in: f_reverse 0D_NOT_logical
  if (c_associated(reverse)) then
    call c_f_pointer(reverse, f_reverse_ptr)
    f_reverse_native = f_reverse_ptr
    f_reverse_native_ptr => f_reverse_native
  else
    f_reverse_native_ptr => null()
  endif
  call transfer_twiss(ele_in=f_ele_in, ele_out=f_ele_out, reverse=f_reverse_native_ptr)

  ! out: f_ele_out 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_transfer_wake (wake_in, wake_out) bind(c)

  use bmad_struct, only: wake_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: wake_in  ! 0D_PTR_type
  type(wake_struct), pointer :: f_wake_in
  ! ** Out parameters **
  type(c_ptr), value :: wake_out  ! 0D_PTR_type
  type(wake_struct), pointer :: f_wake_out
  ! ** End of parameters **
  ! in: f_wake_in 0D_PTR_type
  if (.not. c_associated(wake_in)) return
  call c_f_pointer(wake_in, f_wake_in)
  ! out: f_wake_out 0D_PTR_type
  if (.not. c_associated(wake_out)) return
  call c_f_pointer(wake_out, f_wake_out)
  call transfer_wake(wake_in=f_wake_in, wake_out=f_wake_out)

  ! out: f_wake_out 0D_PTR_type
  ! TODO may require output conversion? 0D_PTR_type
end subroutine
subroutine fortran_truncate_complex_taylor_to_order (complex_taylor_in, order, &
    complex_taylor_out) bind(c)

  use bmad_struct, only: complex_taylor_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: complex_taylor_in
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor_in
  integer(c_int) :: order  ! 0D_NOT_integer
  integer :: f_order
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: complex_taylor_out
  type(complex_taylor_struct_container_alloc), pointer :: f_complex_taylor_out
  ! ** End of parameters **
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor_in))   call c_f_pointer(complex_taylor_in, f_complex_taylor_in)
  ! in: f_order 0D_NOT_integer
  f_order = order
  !! container type array (1D_ALLOC_type)
  if (c_associated(complex_taylor_out))   call c_f_pointer(complex_taylor_out, f_complex_taylor_out)
  call truncate_complex_taylor_to_order(complex_taylor_in=f_complex_taylor_in%data, &
      order=f_order, complex_taylor_out=f_complex_taylor_out%data)

end subroutine
subroutine fortran_twiss1_propagate (twiss1, mat2, ele_key, length, twiss2, err) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: twiss1  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss1
  type(c_ptr), intent(in), value :: mat2
  real(rp) :: f_mat2(2,2)
  real(c_double), pointer :: f_mat2_ptr(:)
  integer(c_int) :: ele_key  ! 0D_NOT_integer
  integer :: f_ele_key
  real(c_double) :: length  ! 0D_NOT_real
  real(rp) :: f_length
  ! ** Out parameters **
  type(c_ptr), value :: twiss2  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss2
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_twiss1 0D_NOT_type
  if (.not. c_associated(twiss1)) return
  call c_f_pointer(twiss1, f_twiss1)
  !! general array (2D_NOT_real)
  if (c_associated(mat2)) then
    call c_f_pointer(mat2, f_mat2_ptr, [2*2])
    call vec2mat(f_mat2_ptr, f_mat2)
  else
    f_mat2_ptr => null()
  endif
  ! in: f_ele_key 0D_NOT_integer
  f_ele_key = ele_key
  ! in: f_length 0D_NOT_real
  f_length = length
  ! out: f_twiss2 0D_NOT_type
  if (.not. c_associated(twiss2)) return
  call c_f_pointer(twiss2, f_twiss2)
  call twiss1_propagate(twiss1=f_twiss1, mat2=f_mat2, ele_key=f_ele_key, length=f_length, &
      twiss2=f_twiss2, err=f_err)

  ! out: f_twiss2 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_twiss3_at_start (lat, err_flag, ix_branch, tune3) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: tune3
  real(rp) :: f_tune3(3)
  real(c_double), pointer :: f_tune3_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call twiss3_at_start(lat=f_lat, err_flag=f_err_flag_native_ptr, ix_branch=f_ix_branch_ptr, &
      tune3=f_tune3)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
  ! out: f_tune3 1D_NOT_real
  if (c_associated(tune3)) then
    call c_f_pointer(tune3, f_tune3_ptr, [3])
    f_tune3_ptr = f_tune3(:)
  endif
end subroutine
subroutine fortran_twiss3_from_twiss2 (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call twiss3_from_twiss2(ele=f_ele)

end subroutine
subroutine fortran_twiss3_propagate1 (ele1, ele2, err_flag) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! inout: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) return
  call c_f_pointer(ele1, f_ele1)
  ! inout: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) return
  call c_f_pointer(ele2, f_ele2)
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  call twiss3_propagate1(ele1=f_ele1, ele2=f_ele2, err_flag=f_err_flag_native_ptr)

  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_twiss3_propagate_all (lat, ix_branch) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call twiss3_propagate_all(lat=f_lat, ix_branch=f_ix_branch_ptr)

end subroutine
subroutine fortran_twiss_and_track_at_s (lat, s, ele_at_s, orb, orb_at_s, ix_branch, err, &
    use_last, compute_floor_coords) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  real(c_double) :: s  ! 0D_NOT_real
  real(rp) :: f_s
  type(c_ptr), intent(in), value :: orb
  type(coord_struct_container_alloc), pointer :: f_orb
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: use_last  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_last
  logical, target :: f_use_last_native
  logical, pointer :: f_use_last_native_ptr
  logical(c_bool), pointer :: f_use_last_ptr
  type(c_ptr), intent(in), value :: compute_floor_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_compute_floor_coords
  logical, target :: f_compute_floor_coords_native
  logical, pointer :: f_compute_floor_coords_native_ptr
  logical(c_bool), pointer :: f_compute_floor_coords_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele_at_s  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_at_s
  type(c_ptr), value :: orb_at_s  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orb_at_s
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_s 0D_NOT_real
  f_s = s
  ! inout: f_ele_at_s 0D_NOT_type
  if (c_associated(ele_at_s))   call c_f_pointer(ele_at_s, f_ele_at_s)
  !! container type array (1D_ALLOC_type)
  if (c_associated(orb))   call c_f_pointer(orb, f_orb)
  ! inout: f_orb_at_s 0D_NOT_type
  if (c_associated(orb_at_s))   call c_f_pointer(orb_at_s, f_orb_at_s)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_use_last 0D_NOT_logical
  if (c_associated(use_last)) then
    call c_f_pointer(use_last, f_use_last_ptr)
    f_use_last_native = f_use_last_ptr
    f_use_last_native_ptr => f_use_last_native
  else
    f_use_last_native_ptr => null()
  endif
  ! in: f_compute_floor_coords 0D_NOT_logical
  if (c_associated(compute_floor_coords)) then
    call c_f_pointer(compute_floor_coords, f_compute_floor_coords_ptr)
    f_compute_floor_coords_native = f_compute_floor_coords_ptr
    f_compute_floor_coords_native_ptr => f_compute_floor_coords_native
  else
    f_compute_floor_coords_native_ptr => null()
  endif
  call twiss_and_track_at_s(lat=f_lat, s=f_s, ele_at_s=f_ele_at_s, orb=f_orb%data, &
      orb_at_s=f_orb_at_s, ix_branch=f_ix_branch_ptr, err=f_err, &
      use_last=f_use_last_native_ptr, compute_floor_coords=f_compute_floor_coords_native_ptr)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_twiss_and_track_from_s_to_s (branch, orbit_start, s_end, orbit_end, &
    ele_start, ele_end, err, compute_floor_coords, compute_twiss) bind(c)

  use bmad_struct, only: branch_struct, coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), value :: orbit_start  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit_start
  real(c_double) :: s_end  ! 0D_NOT_real
  real(rp) :: f_s_end
  type(c_ptr), value :: ele_start  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_start
  type(c_ptr), intent(in), value :: compute_floor_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_compute_floor_coords
  logical, target :: f_compute_floor_coords_native
  logical, pointer :: f_compute_floor_coords_native_ptr
  logical(c_bool), pointer :: f_compute_floor_coords_ptr
  type(c_ptr), intent(in), value :: compute_twiss  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_compute_twiss
  logical, target :: f_compute_twiss_native
  logical, pointer :: f_compute_twiss_native_ptr
  logical(c_bool), pointer :: f_compute_twiss_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orbit_end  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit_end
  type(c_ptr), value :: ele_end  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_end
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_branch 0D_NOT_type
  if (.not. c_associated(branch)) return
  call c_f_pointer(branch, f_branch)
  ! in: f_orbit_start 0D_NOT_type
  if (.not. c_associated(orbit_start)) return
  call c_f_pointer(orbit_start, f_orbit_start)
  ! in: f_s_end 0D_NOT_real
  f_s_end = s_end
  ! out: f_orbit_end 0D_NOT_type
  if (.not. c_associated(orbit_end)) return
  call c_f_pointer(orbit_end, f_orbit_end)
  ! in: f_ele_start 0D_NOT_type
  if (c_associated(ele_start))   call c_f_pointer(ele_start, f_ele_start)
  ! out: f_ele_end 0D_NOT_type
  if (c_associated(ele_end))   call c_f_pointer(ele_end, f_ele_end)
  ! in: f_compute_floor_coords 0D_NOT_logical
  if (c_associated(compute_floor_coords)) then
    call c_f_pointer(compute_floor_coords, f_compute_floor_coords_ptr)
    f_compute_floor_coords_native = f_compute_floor_coords_ptr
    f_compute_floor_coords_native_ptr => f_compute_floor_coords_native
  else
    f_compute_floor_coords_native_ptr => null()
  endif
  ! in: f_compute_twiss 0D_NOT_logical
  if (c_associated(compute_twiss)) then
    call c_f_pointer(compute_twiss, f_compute_twiss_ptr)
    f_compute_twiss_native = f_compute_twiss_ptr
    f_compute_twiss_native_ptr => f_compute_twiss_native
  else
    f_compute_twiss_native_ptr => null()
  endif
  call twiss_and_track_from_s_to_s(branch=f_branch, orbit_start=f_orbit_start, s_end=f_s_end, &
      orbit_end=f_orbit_end, ele_start=f_ele_start, ele_end=f_ele_end, err=f_err, &
      compute_floor_coords=f_compute_floor_coords_native_ptr, &
      compute_twiss=f_compute_twiss_native_ptr)

  ! out: f_orbit_end 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_ele_end 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_twiss_and_track_intra_ele (ele, param, l_start, l_end, track_upstream_end, &
    track_downstream_end, orbit_start, orbit_end, ele_start, ele_end, err, &
    compute_floor_coords, compute_twiss, reuse_ele_end) bind(c)

  use bmad_struct, only: coord_struct, ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  real(c_double) :: l_start  ! 0D_NOT_real
  real(rp) :: f_l_start
  real(c_double) :: l_end  ! 0D_NOT_real
  real(rp) :: f_l_end
  logical(c_bool) :: track_upstream_end  ! 0D_NOT_logical
  logical :: f_track_upstream_end
  logical(c_bool) :: track_downstream_end  ! 0D_NOT_logical
  logical :: f_track_downstream_end
  type(c_ptr), value :: orbit_start  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit_start
  type(c_ptr), value :: ele_start  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_start
  type(c_ptr), intent(in), value :: compute_floor_coords  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_compute_floor_coords
  logical, target :: f_compute_floor_coords_native
  logical, pointer :: f_compute_floor_coords_native_ptr
  logical(c_bool), pointer :: f_compute_floor_coords_ptr
  type(c_ptr), intent(in), value :: compute_twiss  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_compute_twiss
  logical, target :: f_compute_twiss_native
  logical, pointer :: f_compute_twiss_native_ptr
  logical(c_bool), pointer :: f_compute_twiss_ptr
  type(c_ptr), intent(in), value :: reuse_ele_end  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_reuse_ele_end
  logical, target :: f_reuse_ele_end_native
  logical, pointer :: f_reuse_ele_end_native_ptr
  logical(c_bool), pointer :: f_reuse_ele_end_ptr
  ! ** Out parameters **
  type(c_ptr), value :: orbit_end  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit_end
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele_end  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele_end
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  ! in: f_l_start 0D_NOT_real
  f_l_start = l_start
  ! in: f_l_end 0D_NOT_real
  f_l_end = l_end
  ! in: f_track_upstream_end 0D_NOT_logical
  f_track_upstream_end = track_upstream_end
  ! in: f_track_downstream_end 0D_NOT_logical
  f_track_downstream_end = track_downstream_end
  ! in: f_orbit_start 0D_NOT_type
  if (c_associated(orbit_start))   call c_f_pointer(orbit_start, f_orbit_start)
  ! out: f_orbit_end 0D_NOT_type
  if (c_associated(orbit_end))   call c_f_pointer(orbit_end, f_orbit_end)
  ! in: f_ele_start 0D_NOT_type
  if (c_associated(ele_start))   call c_f_pointer(ele_start, f_ele_start)
  ! inout: f_ele_end 0D_NOT_type
  if (c_associated(ele_end))   call c_f_pointer(ele_end, f_ele_end)
  ! in: f_compute_floor_coords 0D_NOT_logical
  if (c_associated(compute_floor_coords)) then
    call c_f_pointer(compute_floor_coords, f_compute_floor_coords_ptr)
    f_compute_floor_coords_native = f_compute_floor_coords_ptr
    f_compute_floor_coords_native_ptr => f_compute_floor_coords_native
  else
    f_compute_floor_coords_native_ptr => null()
  endif
  ! in: f_compute_twiss 0D_NOT_logical
  if (c_associated(compute_twiss)) then
    call c_f_pointer(compute_twiss, f_compute_twiss_ptr)
    f_compute_twiss_native = f_compute_twiss_ptr
    f_compute_twiss_native_ptr => f_compute_twiss_native
  else
    f_compute_twiss_native_ptr => null()
  endif
  ! in: f_reuse_ele_end 0D_NOT_logical
  if (c_associated(reuse_ele_end)) then
    call c_f_pointer(reuse_ele_end, f_reuse_ele_end_ptr)
    f_reuse_ele_end_native = f_reuse_ele_end_ptr
    f_reuse_ele_end_native_ptr => f_reuse_ele_end_native
  else
    f_reuse_ele_end_native_ptr => null()
  endif
  call twiss_and_track_intra_ele(ele=f_ele, param=f_param, l_start=f_l_start, l_end=f_l_end, &
      track_upstream_end=f_track_upstream_end, track_downstream_end=f_track_downstream_end, &
      orbit_start=f_orbit_start, orbit_end=f_orbit_end, ele_start=f_ele_start, &
      ele_end=f_ele_end, err=f_err, compute_floor_coords=f_compute_floor_coords_native_ptr, &
      compute_twiss=f_compute_twiss_native_ptr, reuse_ele_end=f_reuse_ele_end_native_ptr)

  ! out: f_orbit_end 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_twiss_at_element (ele, start, end, average) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), value :: start  ! 0D_NOT_type
  type(ele_struct), pointer :: f_start
  type(c_ptr), value :: end  ! 0D_NOT_type
  type(ele_struct), pointer :: f_end
  type(c_ptr), value :: average  ! 0D_NOT_type
  type(ele_struct), pointer :: f_average
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! out: f_start 0D_NOT_type
  if (c_associated(start))   call c_f_pointer(start, f_start)
  ! out: f_end 0D_NOT_type
  if (c_associated(end))   call c_f_pointer(end, f_end)
  ! out: f_average 0D_NOT_type
  if (c_associated(average))   call c_f_pointer(average, f_average)
  call twiss_at_element(ele=f_ele, start=f_start, end=f_end, average=f_average)

  ! out: f_start 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_end 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
  ! out: f_average 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_twiss_at_start (lat, status, ix_branch, type_out) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: type_out  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_type_out
  logical, target :: f_type_out_native
  logical, pointer :: f_type_out_native_ptr
  logical(c_bool), pointer :: f_type_out_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: status  ! 0D_NOT_integer
  integer :: f_status
  integer(c_int), pointer :: f_status_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_type_out 0D_NOT_logical
  if (c_associated(type_out)) then
    call c_f_pointer(type_out, f_type_out_ptr)
    f_type_out_native = f_type_out_ptr
    f_type_out_native_ptr => f_type_out_native
  else
    f_type_out_native_ptr => null()
  endif
  call twiss_at_start(lat=f_lat, status=f_status, ix_branch=f_ix_branch_ptr, &
      type_out=f_type_out_native_ptr)

  ! out: f_status 0D_NOT_integer
  ! no output conversion for f_status
end subroutine
subroutine fortran_twiss_from_tracking (lat, ref_orb0, symp_err, err_flag, d_orb) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ref_orb0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_ref_orb0
  type(c_ptr), intent(in), value :: d_orb
  type(real_container_alloc), pointer :: f_d_orb
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: symp_err  ! 0D_NOT_real
  real(rp) :: f_symp_err
  real(c_double), pointer :: f_symp_err_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_ref_orb0 0D_NOT_type
  if (.not. c_associated(ref_orb0)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ref_orb0, f_ref_orb0)
  !! container general array (1D_ALLOC_real)
  if (c_associated(d_orb))   call c_f_pointer(d_orb, f_d_orb)
  call twiss_from_tracking(lat=f_lat, ref_orb0=f_ref_orb0, symp_err=f_symp_err, &
      err_flag=f_err_flag, d_orb=f_d_orb%data)

  ! out: f_symp_err 0D_NOT_real
  call c_f_pointer(symp_err, f_symp_err_ptr)
  f_symp_err_ptr = f_symp_err
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
end subroutine
subroutine fortran_twiss_propagate1 (ele1, ele2, err_flag, forward) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: forward  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_forward
  logical, target :: f_forward_native
  logical, pointer :: f_forward_native_ptr
  logical(c_bool), pointer :: f_forward_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: ele1  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele1
  type(c_ptr), value :: ele2  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele2
  ! ** End of parameters **
  ! inout: f_ele1 0D_NOT_type
  if (.not. c_associated(ele1)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele1, f_ele1)
  ! inout: f_ele2 0D_NOT_type
  if (.not. c_associated(ele2)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele2, f_ele2)
  ! in: f_forward 0D_NOT_logical
  if (c_associated(forward)) then
    call c_f_pointer(forward, f_forward_ptr)
    f_forward_native = f_forward_ptr
    f_forward_native_ptr => f_forward_native
  else
    f_forward_native_ptr => null()
  endif
  call twiss_propagate1(ele1=f_ele1, ele2=f_ele2, err_flag=f_err_flag, &
      forward=f_forward_native_ptr)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_twiss_propagate_all (lat, ix_branch, err_flag, ie_start, ie_end) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: ie_start  ! 0D_NOT_integer
  integer(c_int) :: f_ie_start
  integer(c_int), pointer :: f_ie_start_ptr
  type(c_ptr), intent(in), value :: ie_end  ! 0D_NOT_integer
  integer(c_int) :: f_ie_end
  integer(c_int), pointer :: f_ie_end_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! in: f_ie_start 0D_NOT_integer
  if (c_associated(ie_start)) then
    call c_f_pointer(ie_start, f_ie_start_ptr)
  else
    f_ie_start_ptr => null()
  endif
  ! in: f_ie_end 0D_NOT_integer
  if (c_associated(ie_end)) then
    call c_f_pointer(ie_end, f_ie_end_ptr)
  else
    f_ie_end_ptr => null()
  endif
  call twiss_propagate_all(lat=f_lat, ix_branch=f_ix_branch_ptr, err_flag=f_err_flag, &
      ie_start=f_ie_start_ptr, ie_end=f_ie_end_ptr)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_twiss_to_1_turn_mat (twiss, phi, mat2) bind(c)

  use bmad_struct, only: twiss_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: twiss  ! 0D_NOT_type
  type(twiss_struct), pointer :: f_twiss
  real(c_double) :: phi  ! 0D_NOT_real
  real(rp) :: f_phi
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: mat2
  real(rp) :: f_mat2(2,2)
  real(c_double), pointer :: f_mat2_ptr(:)
  ! ** End of parameters **
  ! in: f_twiss 0D_NOT_type
  if (.not. c_associated(twiss)) return
  call c_f_pointer(twiss, f_twiss)
  ! in: f_phi 0D_NOT_real
  f_phi = phi
  call twiss_to_1_turn_mat(twiss=f_twiss, phi=f_phi, mat2=f_mat2)

  ! out: f_mat2 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_mat2', c_name='mat2', type='real', kind='rp', pointer_type='NOT', array=['2', '2'], init_value=None, comment='', member=StructureMember(line=3577, definition='real(rp) phi, mat2(2,2)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='2,2', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='mat2', comment='', default=None), intent='out', description='1-turn matrix.', doc_data_type='float', doc_is_optional=False)
end subroutine
subroutine fortran_type_coord (coord) bind(c)

  use bmad_struct, only: coord_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: coord  ! 0D_NOT_type
  type(coord_struct), pointer :: f_coord
  ! ** End of parameters **
  ! in: f_coord 0D_NOT_type
  if (.not. c_associated(coord)) return
  call c_f_pointer(coord, f_coord)
  call type_coord(coord=f_coord)

end subroutine
subroutine fortran_type_expression_tree (tree, indent) bind(c)

  use bmad_struct, only: expression_tree_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: tree  ! 0D_NOT_type
  type(expression_tree_struct), pointer :: f_tree
  type(c_ptr), intent(in), value :: indent  ! 0D_NOT_integer
  integer(c_int) :: f_indent
  integer(c_int), pointer :: f_indent_ptr
  ! ** End of parameters **
  ! in: f_tree 0D_NOT_type
  if (.not. c_associated(tree)) return
  call c_f_pointer(tree, f_tree)
  ! in: f_indent 0D_NOT_integer
  if (c_associated(indent)) then
    call c_f_pointer(indent, f_indent_ptr)
  else
    f_indent_ptr => null()
  endif
  call type_expression_tree(tree=f_tree, indent=f_indent_ptr)

end subroutine
subroutine fortran_update_ele_from_fibre (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call update_ele_from_fibre(ele=f_ele)

end subroutine
subroutine fortran_update_fibre_from_ele (ele, survey_needed) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: survey_needed  ! 0D_NOT_logical
  logical :: f_survey_needed
  logical(c_bool), pointer :: f_survey_needed_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call update_fibre_from_ele(ele=f_ele, survey_needed=f_survey_needed)

  ! out: f_survey_needed 0D_NOT_logical
  call c_f_pointer(survey_needed, f_survey_needed_ptr)
  f_survey_needed_ptr = f_survey_needed
end subroutine
subroutine fortran_update_floor_angles (floor, floor0) bind(c)

  use bmad_struct, only: floor_position_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: floor0  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor0
  ! ** Inout parameters **
  type(c_ptr), value :: floor  ! 0D_NOT_type
  type(floor_position_struct), pointer :: f_floor
  ! ** End of parameters **
  ! inout: f_floor 0D_NOT_type
  if (.not. c_associated(floor)) return
  call c_f_pointer(floor, f_floor)
  ! in: f_floor0 0D_NOT_type
  if (c_associated(floor0))   call c_f_pointer(floor0, f_floor0)
  call update_floor_angles(floor=f_floor, floor0=f_floor0)

end subroutine
subroutine fortran_valid_field_calc (ele, field_calc, is_valid) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: field_calc  ! 0D_NOT_integer
  integer :: f_field_calc
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_valid  ! 0D_NOT_logical
  logical :: f_is_valid
  logical(c_bool), pointer :: f_is_valid_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_field_calc 0D_NOT_integer
  f_field_calc = field_calc
  f_is_valid = valid_field_calc(ele=f_ele, field_calc=f_field_calc)

  ! out: f_is_valid 0D_NOT_logical
  call c_f_pointer(is_valid, f_is_valid_ptr)
  f_is_valid_ptr = f_is_valid
end subroutine
subroutine fortran_valid_fringe_type (ele, fringe_type, is_valid) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: fringe_type  ! 0D_NOT_integer
  integer :: f_fringe_type
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_valid  ! 0D_NOT_logical
  logical :: f_is_valid
  logical(c_bool), pointer :: f_is_valid_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_fringe_type 0D_NOT_integer
  f_fringe_type = fringe_type
  f_is_valid = valid_fringe_type(ele=f_ele, fringe_type=f_fringe_type)

  ! out: f_is_valid 0D_NOT_logical
  call c_f_pointer(is_valid, f_is_valid_ptr)
  f_is_valid_ptr = f_is_valid
end subroutine
subroutine fortran_valid_mat6_calc_method (ele, species, mat6_calc_method, is_valid) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: species  ! 0D_NOT_integer
  integer :: f_species
  integer(c_int) :: mat6_calc_method  ! 0D_NOT_integer
  integer :: f_mat6_calc_method
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_valid  ! 0D_NOT_logical
  logical :: f_is_valid
  logical(c_bool), pointer :: f_is_valid_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_species 0D_NOT_integer
  f_species = species
  ! in: f_mat6_calc_method 0D_NOT_integer
  f_mat6_calc_method = mat6_calc_method
  f_is_valid = valid_mat6_calc_method(ele=f_ele, species=f_species, &
      mat6_calc_method=f_mat6_calc_method)

  ! out: f_is_valid 0D_NOT_logical
  call c_f_pointer(is_valid, f_is_valid_ptr)
  f_is_valid_ptr = f_is_valid
end subroutine
subroutine fortran_valid_spin_tracking_method (ele, spin_tracking_method, is_valid) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: spin_tracking_method  ! 0D_NOT_integer
  integer :: f_spin_tracking_method
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_valid  ! 0D_NOT_logical
  logical :: f_is_valid
  logical(c_bool), pointer :: f_is_valid_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_spin_tracking_method 0D_NOT_integer
  f_spin_tracking_method = spin_tracking_method
  f_is_valid = valid_spin_tracking_method(ele=f_ele, &
      spin_tracking_method=f_spin_tracking_method)

  ! out: f_is_valid 0D_NOT_logical
  call c_f_pointer(is_valid, f_is_valid_ptr)
  f_is_valid_ptr = f_is_valid
end subroutine
subroutine fortran_valid_tracking_method (ele, species, tracking_method, is_valid) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  integer(c_int) :: species  ! 0D_NOT_integer
  integer :: f_species
  integer(c_int) :: tracking_method  ! 0D_NOT_integer
  integer :: f_tracking_method
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_valid  ! 0D_NOT_logical
  logical :: f_is_valid
  logical(c_bool), pointer :: f_is_valid_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_species 0D_NOT_integer
  f_species = species
  ! in: f_tracking_method 0D_NOT_integer
  f_tracking_method = tracking_method
  f_is_valid = valid_tracking_method(ele=f_ele, species=f_species, &
      tracking_method=f_tracking_method)

  ! out: f_is_valid 0D_NOT_logical
  call c_f_pointer(is_valid, f_is_valid_ptr)
  f_is_valid_ptr = f_is_valid
end subroutine
subroutine fortran_value_of_attribute (ele, attrib_name, err_flag, err_print_flag, err_value, &
    value) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: attrib_name
  character(len=4096), target :: f_attrib_name
  character(kind=c_char), pointer :: f_attrib_name_ptr(:)
  type(c_ptr), intent(in), value :: err_print_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_print_flag
  logical, target :: f_err_print_flag_native
  logical, pointer :: f_err_print_flag_native_ptr
  logical(c_bool), pointer :: f_err_print_flag_ptr
  type(c_ptr), intent(in), value :: err_value  ! 0D_NOT_real
  real(c_double) :: f_err_value
  real(c_double), pointer :: f_err_value_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(rp) :: f_value
  real(c_double), pointer :: f_value_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_attrib_name 0D_NOT_character
  if (.not. c_associated(attrib_name)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(attrib_name, f_attrib_name_ptr, [huge(0)])
  call to_f_str(f_attrib_name_ptr, f_attrib_name)
  ! in: f_err_print_flag 0D_NOT_logical
  if (c_associated(err_print_flag)) then
    call c_f_pointer(err_print_flag, f_err_print_flag_ptr)
    f_err_print_flag_native = f_err_print_flag_ptr
    f_err_print_flag_native_ptr => f_err_print_flag_native
  else
    f_err_print_flag_native_ptr => null()
  endif
  ! in: f_err_value 0D_NOT_real
  if (c_associated(err_value)) then
    call c_f_pointer(err_value, f_err_value_ptr)
  else
    f_err_value_ptr => null()
  endif
  f_value = value_of_attribute(ele=f_ele, attrib_name=f_attrib_name, err_flag=f_err_flag, &
      err_print_flag=f_err_print_flag_native_ptr, err_value=f_err_value_ptr)

  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_value 0D_NOT_real
  call c_f_pointer(value, f_value_ptr)
  f_value_ptr = f_value
end subroutine
subroutine fortran_value_to_line (line, value, str, typ, ignore_if_zero, use_comma) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: line
  character(len=4096), target :: f_line
  character(kind=c_char), pointer :: f_line_ptr(:)
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(c_double) :: f_value
  real(c_double), pointer :: f_value_ptr
  type(c_ptr), intent(in), value :: str
  character(len=4096), target :: f_str
  character(kind=c_char), pointer :: f_str_ptr(:)
  type(c_ptr), intent(in), value :: typ
  character(len=4096), target :: f_typ
  character(kind=c_char), pointer :: f_typ_ptr(:)
  type(c_ptr), intent(in), value :: ignore_if_zero  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_ignore_if_zero
  logical, target :: f_ignore_if_zero_native
  logical, pointer :: f_ignore_if_zero_native_ptr
  logical(c_bool), pointer :: f_ignore_if_zero_ptr
  type(c_ptr), intent(in), value :: use_comma  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_comma
  logical, target :: f_use_comma_native
  logical, pointer :: f_use_comma_native_ptr
  logical(c_bool), pointer :: f_use_comma_ptr
  ! ** End of parameters **
  ! inout: f_line 0D_NOT_character
  if (.not. c_associated(line)) return
  call c_f_pointer(line, f_line_ptr, [huge(0)])
  call to_f_str(f_line_ptr, f_line)
  ! inout: f_value 0D_NOT_real
  if (c_associated(value)) then
    call c_f_pointer(value, f_value_ptr)
  else
    f_value_ptr => null()
  endif
  ! inout: f_str 0D_NOT_character
  if (.not. c_associated(str)) return
  call c_f_pointer(str, f_str_ptr, [huge(0)])
  call to_f_str(f_str_ptr, f_str)
  ! inout: f_typ 0D_NOT_character
  if (.not. c_associated(typ)) return
  call c_f_pointer(typ, f_typ_ptr, [huge(0)])
  call to_f_str(f_typ_ptr, f_typ)
  ! inout: f_ignore_if_zero 0D_NOT_logical
  if (c_associated(ignore_if_zero)) then
    call c_f_pointer(ignore_if_zero, f_ignore_if_zero_ptr)
    f_ignore_if_zero_native = f_ignore_if_zero_ptr
    f_ignore_if_zero_native_ptr => f_ignore_if_zero_native
  else
    f_ignore_if_zero_native_ptr => null()
  endif
  ! inout: f_use_comma 0D_NOT_logical
  if (c_associated(use_comma)) then
    call c_f_pointer(use_comma, f_use_comma_ptr)
    f_use_comma_native = f_use_comma_ptr
    f_use_comma_native_ptr => f_use_comma_native
  else
    f_use_comma_native_ptr => null()
  endif
  call value_to_line(line=f_line, value=f_value_ptr, str=f_str, typ=f_typ, &
      ignore_if_zero=f_ignore_if_zero_native_ptr, use_comma=f_use_comma_native_ptr)

  ! inout: f_line 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_value 0D_NOT_real
  ! no output conversion for f_value
  ! inout: f_str 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_typ 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_ignore_if_zero 0D_NOT_logical
  if (c_associated(ignore_if_zero)) then
    call c_f_pointer(ignore_if_zero, f_ignore_if_zero_ptr)
    f_ignore_if_zero_ptr = f_ignore_if_zero_native
  else
    ! f_ignore_if_zero unset
  endif
  ! inout: f_use_comma 0D_NOT_logical
  if (c_associated(use_comma)) then
    call c_f_pointer(use_comma, f_use_comma_ptr)
    f_use_comma_ptr = f_use_comma_native
  else
    ! f_use_comma unset
  endif
end subroutine
subroutine fortran_vec_to_polar (vec, phase, polar) bind(c)

  use bmad_struct, only: spin_polar_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: vec
  real(rp) :: f_vec(3)
  real(c_double), pointer :: f_vec_ptr(:)
  type(c_ptr), intent(in), value :: phase  ! 0D_NOT_real
  real(c_double) :: f_phase
  real(c_double), pointer :: f_phase_ptr
  ! ** Out parameters **
  type(c_ptr), value :: polar  ! 0D_NOT_type
  type(spin_polar_struct), pointer :: f_polar
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(vec)) then
    call c_f_pointer(vec, f_vec_ptr, [3])
    f_vec = f_vec_ptr(:)
  else
    f_vec_ptr => null()
  endif
  ! in: f_phase 0D_NOT_real
  if (c_associated(phase)) then
    call c_f_pointer(phase, f_phase_ptr)
  else
    f_phase_ptr => null()
  endif
  f_polar = vec_to_polar(vec=f_vec, phase=f_phase_ptr)

  ! out: f_polar 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_vec_to_spinor (vec, phase, spinor) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: vec
  real(rp) :: f_vec(3)
  real(c_double), pointer :: f_vec_ptr(:)
  type(c_ptr), intent(in), value :: phase  ! 0D_NOT_real
  real(c_double) :: f_phase
  real(c_double), pointer :: f_phase_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: spinor
  complex(rp) :: f_spinor(2)
  complex(c_double_complex), pointer :: f_spinor_ptr(:)
  ! ** End of parameters **
  !! general array (1D_NOT_real)
  if (c_associated(vec)) then
    call c_f_pointer(vec, f_vec_ptr, [3])
    f_vec = f_vec_ptr(:)
  else
    f_vec_ptr => null()
  endif
  ! in: f_phase 0D_NOT_real
  if (c_associated(phase)) then
    call c_f_pointer(phase, f_phase_ptr)
  else
    f_phase_ptr => null()
  endif
  f_spinor = vec_to_spinor(vec=f_vec, phase=f_phase_ptr)

  ! out: f_spinor 1D_NOT_complex
  if (c_associated(spinor)) then
    call c_f_pointer(spinor, f_spinor_ptr, [2])
    f_spinor_ptr = f_spinor(:)
  endif
end subroutine
subroutine fortran_verify_valid_name (name, ix_name, pure_name, include_wild, is_valid) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  integer(c_int) :: ix_name  ! 0D_NOT_integer
  integer :: f_ix_name
  type(c_ptr), intent(in), value :: pure_name  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_pure_name
  logical, target :: f_pure_name_native
  logical, pointer :: f_pure_name_native_ptr
  logical(c_bool), pointer :: f_pure_name_ptr
  type(c_ptr), intent(in), value :: include_wild  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_wild
  logical, target :: f_include_wild_native
  logical, pointer :: f_include_wild_native_ptr
  logical(c_bool), pointer :: f_include_wild_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: is_valid  ! 0D_NOT_logical
  logical :: f_is_valid
  logical(c_bool), pointer :: f_is_valid_ptr
  ! ** End of parameters **
  ! in: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  ! in: f_ix_name 0D_NOT_integer
  f_ix_name = ix_name
  ! in: f_pure_name 0D_NOT_logical
  if (c_associated(pure_name)) then
    call c_f_pointer(pure_name, f_pure_name_ptr)
    f_pure_name_native = f_pure_name_ptr
    f_pure_name_native_ptr => f_pure_name_native
  else
    f_pure_name_native_ptr => null()
  endif
  ! in: f_include_wild 0D_NOT_logical
  if (c_associated(include_wild)) then
    call c_f_pointer(include_wild, f_include_wild_ptr)
    f_include_wild_native = f_include_wild_ptr
    f_include_wild_native_ptr => f_include_wild_native
  else
    f_include_wild_native_ptr => null()
  endif
  f_is_valid = verify_valid_name(name=f_name, ix_name=f_ix_name, &
      pure_name=f_pure_name_native_ptr, include_wild=f_include_wild_native_ptr)

  ! out: f_is_valid 0D_NOT_logical
  call c_f_pointer(is_valid, f_is_valid_ptr)
  f_is_valid_ptr = f_is_valid
end subroutine
subroutine fortran_w_mat_for_bend_angle (angle, ref_tilt, r_vec, w_mat) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: angle  ! 0D_NOT_real
  real(rp) :: f_angle
  real(c_double) :: ref_tilt  ! 0D_NOT_real
  real(rp) :: f_ref_tilt
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: r_vec
  real(rp) :: f_r_vec(3)
  real(c_double), pointer :: f_r_vec_ptr(:)
  ! ** End of parameters **
  ! in: f_angle 0D_NOT_real
  f_angle = angle
  ! in: f_ref_tilt 0D_NOT_real
  f_ref_tilt = ref_tilt
  !! general array (1D_NOT_real)
  if (c_associated(r_vec)) then
    call c_f_pointer(r_vec, f_r_vec_ptr, [3])
    f_r_vec = f_r_vec_ptr(:)
  else
    f_r_vec_ptr => null()
  endif
  f_w_mat = w_mat_for_bend_angle(angle=f_angle, ref_tilt=f_ref_tilt, r_vec=f_r_vec)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=3719, definition='real(rp) angle, ref_tilt, w_mat(3,3), t_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_w_mat_for_tilt (tilt, return_inverse, w_mat) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: tilt  ! 0D_NOT_real
  real(rp) :: f_tilt
  type(c_ptr), intent(in), value :: return_inverse  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_return_inverse
  logical, target :: f_return_inverse_native
  logical, pointer :: f_return_inverse_native_ptr
  logical(c_bool), pointer :: f_return_inverse_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_tilt 0D_NOT_real
  f_tilt = tilt
  ! in: f_return_inverse 0D_NOT_logical
  if (c_associated(return_inverse)) then
    call c_f_pointer(return_inverse, f_return_inverse_ptr)
    f_return_inverse_native = f_return_inverse_ptr
    f_return_inverse_native_ptr => f_return_inverse_native
  else
    f_return_inverse_native_ptr => null()
  endif
  f_w_mat = w_mat_for_tilt(tilt=f_tilt, return_inverse=f_return_inverse_native_ptr)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=3743, definition='real(rp) :: w_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_w_mat_for_x_pitch (x_pitch, return_inverse, w_mat) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: x_pitch  ! 0D_NOT_real
  real(rp) :: f_x_pitch
  type(c_ptr), intent(in), value :: return_inverse  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_return_inverse
  logical, target :: f_return_inverse_native
  logical, pointer :: f_return_inverse_native_ptr
  logical(c_bool), pointer :: f_return_inverse_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_x_pitch 0D_NOT_real
  f_x_pitch = x_pitch
  ! in: f_return_inverse 0D_NOT_logical
  if (c_associated(return_inverse)) then
    call c_f_pointer(return_inverse, f_return_inverse_ptr)
    f_return_inverse_native = f_return_inverse_ptr
    f_return_inverse_native_ptr => f_return_inverse_native
  else
    f_return_inverse_native_ptr => null()
  endif
  f_w_mat = w_mat_for_x_pitch(x_pitch=f_x_pitch, return_inverse=f_return_inverse_native_ptr)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=3727, definition='real(rp) :: w_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_w_mat_for_y_pitch (y_pitch, return_inverse, w_mat) bind(c)

  implicit none
  ! ** In parameters **
  real(c_double) :: y_pitch  ! 0D_NOT_real
  real(rp) :: f_y_pitch
  type(c_ptr), intent(in), value :: return_inverse  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_return_inverse
  logical, target :: f_return_inverse_native
  logical, pointer :: f_return_inverse_native_ptr
  logical(c_bool), pointer :: f_return_inverse_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: w_mat
  real(rp) :: f_w_mat(3,3)
  real(c_double), pointer :: f_w_mat_ptr(:)
  ! ** End of parameters **
  ! in: f_y_pitch 0D_NOT_real
  f_y_pitch = y_pitch
  ! in: f_return_inverse 0D_NOT_logical
  if (c_associated(return_inverse)) then
    call c_f_pointer(return_inverse, f_return_inverse_ptr)
    f_return_inverse_native = f_return_inverse_ptr
    f_return_inverse_native_ptr => f_return_inverse_native
  else
    f_return_inverse_native_ptr => null()
  endif
  f_w_mat = w_mat_for_y_pitch(y_pitch=f_y_pitch, return_inverse=f_return_inverse_native_ptr)

  ! out: f_w_mat 2D_NOT_real
! TODO general output array 2D RoutineArg(is_component=True, f_name='f_w_mat', c_name='w_mat', type='real', kind='rp', pointer_type='NOT', array=['3', '3'], init_value=None, comment='', member=StructureMember(line=3735, definition='real(rp) :: w_mat(3,3)', type_info=TypeInformation(type='real', allocatable=False, asynchronous=False, bind=None, contiguous=False, dimension='3,3', external=False, intent=None, intrinsic=False, optional=False, parameter=False, pointer=False, private=False, protected=False, public=False, save=False, kind='rp', static=False, target=False, value=False, volatile=False, attributes=()), name='w_mat', comment='', default=None), intent='inout', description='', doc_data_type=None, doc_is_optional=False)
end subroutine
subroutine fortran_wall3d_d_radius (position, ele, ix_wall, perp, ix_section, no_wall_here, &
    origin, radius_wall, err_flag, d_radius) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: position
  type(real_container_alloc), pointer :: f_position
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: ix_wall  ! 0D_NOT_integer
  integer(c_int) :: f_ix_wall
  integer(c_int), pointer :: f_ix_wall_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: perp
  real(rp) :: f_perp(3)
  real(c_double), pointer :: f_perp_ptr(:)
  type(c_ptr), intent(in), value :: ix_section  ! 0D_NOT_integer
  integer :: f_ix_section
  integer(c_int), pointer :: f_ix_section_ptr
  type(c_ptr), intent(in), value :: no_wall_here  ! 0D_NOT_logical
  logical :: f_no_wall_here
  logical(c_bool), pointer :: f_no_wall_here_ptr
  type(c_ptr), intent(in), value :: origin
  real(rp) :: f_origin(3)
  real(c_double), pointer :: f_origin_ptr(:)
  type(c_ptr), intent(in), value :: radius_wall  ! 0D_NOT_real
  real(rp) :: f_radius_wall
  real(c_double), pointer :: f_radius_wall_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: d_radius  ! 0D_NOT_real
  real(rp) :: f_d_radius
  real(c_double), pointer :: f_d_radius_ptr
  ! ** End of parameters **
  !! container general array (1D_ALLOC_real)
  if (c_associated(position))   call c_f_pointer(position, f_position)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! in: f_ix_wall 0D_NOT_integer
  if (c_associated(ix_wall)) then
    call c_f_pointer(ix_wall, f_ix_wall_ptr)
  else
    f_ix_wall_ptr => null()
  endif
  f_d_radius = wall3d_d_radius(position=f_position%data, ele=f_ele, ix_wall=f_ix_wall_ptr, &
      perp=f_perp, ix_section=f_ix_section, no_wall_here=f_no_wall_here, origin=f_origin, &
      radius_wall=f_radius_wall, err_flag=f_err_flag)

  ! out: f_perp 1D_NOT_real
  if (c_associated(perp)) then
    call c_f_pointer(perp, f_perp_ptr, [3])
    f_perp_ptr = f_perp(:)
  endif
  ! out: f_ix_section 0D_NOT_integer
  ! no output conversion for f_ix_section
  ! out: f_no_wall_here 0D_NOT_logical
  ! no output conversion for f_no_wall_here
  ! out: f_origin 1D_NOT_real
  if (c_associated(origin)) then
    call c_f_pointer(origin, f_origin_ptr, [3])
    f_origin_ptr = f_origin(:)
  endif
  ! out: f_radius_wall 0D_NOT_real
  ! no output conversion for f_radius_wall
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
  ! out: f_d_radius 0D_NOT_real
  call c_f_pointer(d_radius, f_d_radius_ptr)
  f_d_radius_ptr = f_d_radius
end subroutine
subroutine fortran_wall3d_initializer (wall3d, err) bind(c)

  use bmad_struct, only: wall3d_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: wall3d  ! 0D_NOT_type
  type(wall3d_struct), pointer :: f_wall3d
  ! ** End of parameters **
  ! inout: f_wall3d 0D_NOT_type
  if (.not. c_associated(wall3d)) return
  call c_f_pointer(wall3d, f_wall3d)
  call wall3d_initializer(wall3d=f_wall3d, err=f_err)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_wall3d_section_initializer (section, err) bind(c)

  use bmad_struct, only: wall3d_section_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** Inout parameters **
  type(c_ptr), value :: section  ! 0D_NOT_type
  type(wall3d_section_struct), pointer :: f_section
  ! ** End of parameters **
  ! inout: f_section 0D_NOT_type
  if (.not. c_associated(section)) return
  call c_f_pointer(section, f_section)
  call wall3d_section_initializer(section=f_section, err=f_err)

  ! out: f_err 0D_NOT_logical
  call c_f_pointer(err, f_err_ptr)
  f_err_ptr = f_err
end subroutine
subroutine fortran_wall3d_to_position (orbit, ele, position) bind(c)

  use bmad_struct, only: coord_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: orbit  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: position
  real(rp) :: f_position(6)
  real(c_double), pointer :: f_position_ptr(:)
  ! ** End of parameters **
  ! in: f_orbit 0D_NOT_type
  if (.not. c_associated(orbit)) return
  call c_f_pointer(orbit, f_orbit)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  f_position = wall3d_to_position(orbit=f_orbit, ele=f_ele)

  ! out: f_position 1D_NOT_real
  if (c_associated(position)) then
    call c_f_pointer(position, f_position_ptr, [6])
    f_position_ptr = f_position(:)
  endif
end subroutine
subroutine fortran_word_to_value (word, lat, value, err_flag, ele) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: word
  character(len=4096), target :: f_word
  character(kind=c_char), pointer :: f_word_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: value  ! 0D_NOT_real
  real(c_double) :: f_value
  real(c_double), pointer :: f_value_ptr
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err_flag
  logical, target :: f_err_flag_native
  logical, pointer :: f_err_flag_native_ptr
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! inout: f_word 0D_NOT_character
  if (.not. c_associated(word)) return
  call c_f_pointer(word, f_word_ptr, [huge(0)])
  call to_f_str(f_word_ptr, f_word)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_value 0D_NOT_real
  if (c_associated(value)) then
    call c_f_pointer(value, f_value_ptr)
  else
    f_value_ptr => null()
  endif
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_native = f_err_flag_ptr
    f_err_flag_native_ptr => f_err_flag_native
  else
    f_err_flag_native_ptr => null()
  endif
  ! inout: f_ele 0D_NOT_type
  if (c_associated(ele))   call c_f_pointer(ele, f_ele)
  call word_to_value(word=f_word, lat=f_lat, value=f_value_ptr, err_flag=f_err_flag_native_ptr, &
      ele=f_ele)

  ! inout: f_word 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_value 0D_NOT_real
  ! no output conversion for f_value
  ! inout: f_err_flag 0D_NOT_logical
  if (c_associated(err_flag)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = f_err_flag_native
  else
    ! f_err_flag unset
  endif
end subroutine
subroutine fortran_write_ascii_beam_file (file_name, beam, new_file, alive_only) bind(c)

  use bmad_struct, only: beam_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: new_file  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_new_file
  logical, target :: f_new_file_native
  logical, pointer :: f_new_file_native_ptr
  logical(c_bool), pointer :: f_new_file_ptr
  type(c_ptr), intent(in), value :: alive_only  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_alive_only
  logical, target :: f_alive_only_native
  logical, pointer :: f_alive_only_native_ptr
  logical(c_bool), pointer :: f_alive_only_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  ! in: f_new_file 0D_NOT_logical
  if (c_associated(new_file)) then
    call c_f_pointer(new_file, f_new_file_ptr)
    f_new_file_native = f_new_file_ptr
    f_new_file_native_ptr => f_new_file_native
  else
    f_new_file_native_ptr => null()
  endif
  ! in: f_alive_only 0D_NOT_logical
  if (c_associated(alive_only)) then
    call c_f_pointer(alive_only, f_alive_only_ptr)
    f_alive_only_native = f_alive_only_ptr
    f_alive_only_native_ptr => f_alive_only_native
  else
    f_alive_only_native_ptr => null()
  endif
  call write_ascii_beam_file(file_name=f_file_name, beam=f_beam, &
      new_file=f_new_file_native_ptr, alive_only=f_alive_only_native_ptr)

end subroutine
subroutine fortran_write_astra_bend (iu, strength, id, d1, d2, d3, d4) bind(c)

  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: iu  ! 0D_NOT_integer
  integer(c_int) :: f_iu
  integer(c_int), pointer :: f_iu_ptr
  type(c_ptr), intent(in), value :: strength  ! 0D_NOT_real
  real(c_double) :: f_strength
  real(c_double), pointer :: f_strength_ptr
  type(c_ptr), intent(in), value :: id  ! 0D_NOT_integer
  integer(c_int) :: f_id
  integer(c_int), pointer :: f_id_ptr
  type(c_ptr), intent(in), value :: d1
  real(rp) :: f_d1(2)
  real(c_double), pointer :: f_d1_ptr(:)
  type(c_ptr), intent(in), value :: d2
  real(rp) :: f_d2(2)
  real(c_double), pointer :: f_d2_ptr(:)
  type(c_ptr), intent(in), value :: d3
  real(rp) :: f_d3(2)
  real(c_double), pointer :: f_d3_ptr(:)
  type(c_ptr), intent(in), value :: d4
  real(rp) :: f_d4(2)
  real(c_double), pointer :: f_d4_ptr(:)
  ! ** End of parameters **
  ! inout: f_iu 0D_NOT_integer
  if (c_associated(iu)) then
    call c_f_pointer(iu, f_iu_ptr)
  else
    f_iu_ptr => null()
  endif
  ! inout: f_strength 0D_NOT_real
  if (c_associated(strength)) then
    call c_f_pointer(strength, f_strength_ptr)
  else
    f_strength_ptr => null()
  endif
  ! inout: f_id 0D_NOT_integer
  if (c_associated(id)) then
    call c_f_pointer(id, f_id_ptr)
  else
    f_id_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(d1)) then
    call c_f_pointer(d1, f_d1_ptr, [2])
    f_d1 = f_d1_ptr(:)
  else
    f_d1_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(d2)) then
    call c_f_pointer(d2, f_d2_ptr, [2])
    f_d2 = f_d2_ptr(:)
  else
    f_d2_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(d3)) then
    call c_f_pointer(d3, f_d3_ptr, [2])
    f_d3 = f_d3_ptr(:)
  else
    f_d3_ptr => null()
  endif
  !! general array (1D_NOT_real)
  if (c_associated(d4)) then
    call c_f_pointer(d4, f_d4_ptr, [2])
    f_d4 = f_d4_ptr(:)
  else
    f_d4_ptr => null()
  endif
  call write_astra_bend(iu=f_iu_ptr, strength=f_strength_ptr, id=f_id_ptr, d1=f_d1, d2=f_d2, &
      d3=f_d3, d4=f_d4)

  ! inout: f_iu 0D_NOT_integer
  ! no output conversion for f_iu
  ! inout: f_strength 0D_NOT_real
  ! no output conversion for f_strength
  ! inout: f_id 0D_NOT_integer
  ! no output conversion for f_id
end subroutine
subroutine fortran_write_astra_field_grid_file (astra_file_unit, ele, maxfield, dz, err) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: astra_file_unit  ! 0D_NOT_integer
  integer :: f_astra_file_unit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: maxfield  ! 0D_NOT_real
  real(rp) :: f_maxfield
  real(c_double), pointer :: f_maxfield_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_astra_file_unit 0D_NOT_integer
  f_astra_file_unit = astra_file_unit
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  call write_astra_field_grid_file(astra_file_unit=f_astra_file_unit, ele=f_ele, &
      maxfield=f_maxfield, dz=f_dz_ptr, err=f_err)

  ! out: f_maxfield 0D_NOT_real
  call c_f_pointer(maxfield, f_maxfield_ptr)
  f_maxfield_ptr = f_maxfield
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_astra_field_grid_file_3d (base_filename, ele, maxfield, dz, err) &
    bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: base_filename
  character(len=4096), target :: f_base_filename
  character(kind=c_char), pointer :: f_base_filename_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: maxfield  ! 0D_NOT_real
  real(rp) :: f_maxfield
  real(c_double), pointer :: f_maxfield_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_base_filename 0D_NOT_character
  if (.not. c_associated(base_filename)) return
  call c_f_pointer(base_filename, f_base_filename_ptr, [huge(0)])
  call to_f_str(f_base_filename_ptr, f_base_filename)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  call write_astra_field_grid_file_3d(base_filename=f_base_filename, ele=f_ele, &
      maxfield=f_maxfield, dz=f_dz_ptr, err=f_err)

  ! out: f_maxfield 0D_NOT_real
  call c_f_pointer(maxfield, f_maxfield_ptr)
  f_maxfield_ptr = f_maxfield
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_beam_file (file_name, beam, new_file, file_format, lat, alive_only) &
    bind(c)

  use bmad_struct, only: beam_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), intent(in), value :: new_file  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_new_file
  logical, target :: f_new_file_native
  logical, pointer :: f_new_file_native_ptr
  logical(c_bool), pointer :: f_new_file_ptr
  type(c_ptr), intent(in), value :: file_format  ! 0D_NOT_integer
  integer(c_int) :: f_file_format
  integer(c_int), pointer :: f_file_format_ptr
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: alive_only  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_alive_only
  logical, target :: f_alive_only_native
  logical, pointer :: f_alive_only_native_ptr
  logical(c_bool), pointer :: f_alive_only_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  ! in: f_new_file 0D_NOT_logical
  if (c_associated(new_file)) then
    call c_f_pointer(new_file, f_new_file_ptr)
    f_new_file_native = f_new_file_ptr
    f_new_file_native_ptr => f_new_file_native
  else
    f_new_file_native_ptr => null()
  endif
  ! in: f_file_format 0D_NOT_integer
  if (c_associated(file_format)) then
    call c_f_pointer(file_format, f_file_format_ptr)
  else
    f_file_format_ptr => null()
  endif
  ! in: f_lat 0D_NOT_type
  if (c_associated(lat))   call c_f_pointer(lat, f_lat)
  ! in: f_alive_only 0D_NOT_logical
  if (c_associated(alive_only)) then
    call c_f_pointer(alive_only, f_alive_only_ptr)
    f_alive_only_native = f_alive_only_ptr
    f_alive_only_native_ptr => f_alive_only_native
  else
    f_alive_only_native_ptr => null()
  endif
  call write_beam_file(file_name=f_file_name, beam=f_beam, new_file=f_new_file_native_ptr, &
      file_format=f_file_format_ptr, lat=f_lat, alive_only=f_alive_only_native_ptr)

end subroutine
subroutine fortran_write_beam_floor_positions (file_name, beam, ele, new_file) bind(c)

  use bmad_struct, only: beam_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: beam  ! 0D_NOT_type
  type(beam_struct), pointer :: f_beam
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: new_file  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_new_file
  logical, target :: f_new_file_native
  logical, pointer :: f_new_file_native_ptr
  logical(c_bool), pointer :: f_new_file_ptr
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_beam 0D_NOT_type
  if (.not. c_associated(beam)) return
  call c_f_pointer(beam, f_beam)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_new_file 0D_NOT_logical
  if (c_associated(new_file)) then
    call c_f_pointer(new_file, f_new_file_ptr)
    f_new_file_native = f_new_file_ptr
    f_new_file_native_ptr => f_new_file_native
  else
    f_new_file_native_ptr => null()
  endif
  call write_beam_floor_positions(file_name=f_file_name, beam=f_beam, ele=f_ele, &
      new_file=f_new_file_native_ptr)

end subroutine
subroutine fortran_write_binary_cartesian_map (file_name, ele, cart_map, err_flag) bind(c)

  use bmad_struct, only: cartesian_map_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: cart_map  ! 0D_NOT_type
  type(cartesian_map_struct), pointer :: f_cart_map
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_cart_map 0D_NOT_type
  if (.not. c_associated(cart_map)) return
  call c_f_pointer(cart_map, f_cart_map)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call write_binary_cartesian_map(file_name=f_file_name, ele=f_ele, cart_map=f_cart_map, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_write_binary_cylindrical_map (file_name, ele, cl_map, err_flag) bind(c)

  use bmad_struct, only: cylindrical_map_struct, ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: cl_map  ! 0D_NOT_type
  type(cylindrical_map_struct), pointer :: f_cl_map
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_cl_map 0D_NOT_type
  if (.not. c_associated(cl_map)) return
  call c_f_pointer(cl_map, f_cl_map)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call write_binary_cylindrical_map(file_name=f_file_name, ele=f_ele, cl_map=f_cl_map, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_write_binary_grid_field (file_name, ele, g_field, err_flag) bind(c)

  use bmad_struct, only: ele_struct, grid_field_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: g_field  ! 0D_NOT_type
  type(grid_field_struct), pointer :: f_g_field
  logical(c_bool) :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  ! ** End of parameters **
  ! in: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_g_field 0D_NOT_type
  if (.not. c_associated(g_field)) return
  call c_f_pointer(g_field, f_g_field)
  ! in: f_err_flag 0D_NOT_logical
  f_err_flag = err_flag
  call write_binary_grid_field(file_name=f_file_name, ele=f_ele, g_field=f_g_field, &
      err_flag=f_err_flag)

end subroutine
subroutine fortran_write_blender_ele (iu, ele, old_format) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: iu  ! 0D_NOT_integer
  integer(c_int) :: f_iu
  integer(c_int), pointer :: f_iu_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: old_format  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_old_format
  logical, target :: f_old_format_native
  logical, pointer :: f_old_format_native_ptr
  logical(c_bool), pointer :: f_old_format_ptr
  ! ** End of parameters **
  ! inout: f_iu 0D_NOT_integer
  if (c_associated(iu)) then
    call c_f_pointer(iu, f_iu_ptr)
  else
    f_iu_ptr => null()
  endif
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_old_format 0D_NOT_logical
  if (c_associated(old_format)) then
    call c_f_pointer(old_format, f_old_format_ptr)
    f_old_format_native = f_old_format_ptr
    f_old_format_native_ptr => f_old_format_native
  else
    f_old_format_native_ptr => null()
  endif
  call write_blender_ele(iu=f_iu_ptr, ele=f_ele, old_format=f_old_format_native_ptr)

  ! inout: f_iu 0D_NOT_integer
  ! no output conversion for f_iu
  ! inout: f_old_format 0D_NOT_logical
  if (c_associated(old_format)) then
    call c_f_pointer(old_format, f_old_format_ptr)
    f_old_format_ptr = f_old_format_native
  else
    ! f_old_format unset
  endif
end subroutine
subroutine fortran_write_blender_lat_layout (file_name, lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: file_name
  character(len=4096), target :: f_file_name
  character(kind=c_char), pointer :: f_file_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_file_name 0D_NOT_character
  if (.not. c_associated(file_name)) return
  call c_f_pointer(file_name, f_file_name_ptr, [huge(0)])
  call to_f_str(f_file_name_ptr, f_file_name)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call write_blender_lat_layout(file_name=f_file_name, lat=f_lat)

  ! inout: f_file_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
end subroutine
subroutine fortran_write_bmad_lattice_file (bmad_file, lat, err, output_form, orbit0) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: bmad_file
  character(len=4096), target :: f_bmad_file
  character(kind=c_char), pointer :: f_bmad_file_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: output_form  ! 0D_NOT_integer
  integer(c_int) :: f_output_form
  integer(c_int), pointer :: f_output_form_ptr
  type(c_ptr), value :: orbit0  ! 0D_NOT_type
  type(coord_struct), pointer :: f_orbit0
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_bmad_file 0D_NOT_character
  if (.not. c_associated(bmad_file)) return
  call c_f_pointer(bmad_file, f_bmad_file_ptr, [huge(0)])
  call to_f_str(f_bmad_file_ptr, f_bmad_file)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! in: f_output_form 0D_NOT_integer
  if (c_associated(output_form)) then
    call c_f_pointer(output_form, f_output_form_ptr)
  else
    f_output_form_ptr => null()
  endif
  ! in: f_orbit0 0D_NOT_type
  if (c_associated(orbit0))   call c_f_pointer(orbit0, f_orbit0)
  call write_bmad_lattice_file(bmad_file=f_bmad_file, lat=f_lat, err=f_err, &
      output_form=f_output_form_ptr, orbit0=f_orbit0)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_gpt_field_grid_file_1d (gpt_file_unit, ele, maxfield, ref_time, dz, &
    err) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: gpt_file_unit  ! 0D_NOT_integer
  integer :: f_gpt_file_unit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: maxfield  ! 0D_NOT_real
  real(rp) :: f_maxfield
  real(c_double), pointer :: f_maxfield_ptr
  type(c_ptr), intent(in), value :: ref_time  ! 0D_NOT_real
  real(rp) :: f_ref_time
  real(c_double), pointer :: f_ref_time_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_gpt_file_unit 0D_NOT_integer
  f_gpt_file_unit = gpt_file_unit
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  call write_gpt_field_grid_file_1d(gpt_file_unit=f_gpt_file_unit, ele=f_ele, &
      maxfield=f_maxfield, ref_time=f_ref_time, dz=f_dz_ptr, err=f_err)

  ! out: f_maxfield 0D_NOT_real
  call c_f_pointer(maxfield, f_maxfield_ptr)
  f_maxfield_ptr = f_maxfield
  ! out: f_ref_time 0D_NOT_real
  call c_f_pointer(ref_time, f_ref_time_ptr)
  f_ref_time_ptr = f_ref_time
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_gpt_field_grid_file_2d (gpt_file_unit, ele, maxfield, ref_time, dr, &
    dz, r_max, err) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: gpt_file_unit  ! 0D_NOT_integer
  integer :: f_gpt_file_unit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: dr  ! 0D_NOT_real
  real(c_double) :: f_dr
  real(c_double), pointer :: f_dr_ptr
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  type(c_ptr), intent(in), value :: r_max  ! 0D_NOT_real
  real(c_double) :: f_r_max
  real(c_double), pointer :: f_r_max_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: maxfield  ! 0D_NOT_real
  real(rp) :: f_maxfield
  real(c_double), pointer :: f_maxfield_ptr
  type(c_ptr), intent(in), value :: ref_time  ! 0D_NOT_real
  real(rp) :: f_ref_time
  real(c_double), pointer :: f_ref_time_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_gpt_file_unit 0D_NOT_integer
  f_gpt_file_unit = gpt_file_unit
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_dr 0D_NOT_real
  if (c_associated(dr)) then
    call c_f_pointer(dr, f_dr_ptr)
  else
    f_dr_ptr => null()
  endif
  ! in: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  ! in: f_r_max 0D_NOT_real
  if (c_associated(r_max)) then
    call c_f_pointer(r_max, f_r_max_ptr)
  else
    f_r_max_ptr => null()
  endif
  call write_gpt_field_grid_file_2d(gpt_file_unit=f_gpt_file_unit, ele=f_ele, &
      maxfield=f_maxfield, ref_time=f_ref_time, dr=f_dr_ptr, dz=f_dz_ptr, r_max=f_r_max_ptr, &
      err=f_err)

  ! out: f_maxfield 0D_NOT_real
  call c_f_pointer(maxfield, f_maxfield_ptr)
  f_maxfield_ptr = f_maxfield
  ! out: f_ref_time 0D_NOT_real
  call c_f_pointer(ref_time, f_ref_time_ptr)
  f_ref_time_ptr = f_ref_time
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_gpt_field_grid_file_3d (base_filename, ele, maxfield, ref_time, dz, &
    err) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: base_filename
  character(len=4096), target :: f_base_filename
  character(kind=c_char), pointer :: f_base_filename_ptr(:)
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: dz  ! 0D_NOT_real
  real(c_double) :: f_dz
  real(c_double), pointer :: f_dz_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: maxfield  ! 0D_NOT_real
  real(rp) :: f_maxfield
  real(c_double), pointer :: f_maxfield_ptr
  type(c_ptr), intent(in), value :: ref_time  ! 0D_NOT_real
  real(rp) :: f_ref_time
  real(c_double), pointer :: f_ref_time_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_base_filename 0D_NOT_character
  if (.not. c_associated(base_filename)) return
  call c_f_pointer(base_filename, f_base_filename_ptr, [huge(0)])
  call to_f_str(f_base_filename_ptr, f_base_filename)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_dz 0D_NOT_real
  if (c_associated(dz)) then
    call c_f_pointer(dz, f_dz_ptr)
  else
    f_dz_ptr => null()
  endif
  call write_gpt_field_grid_file_3d(base_filename=f_base_filename, ele=f_ele, &
      maxfield=f_maxfield, ref_time=f_ref_time, dz=f_dz_ptr, err=f_err)

  ! out: f_maxfield 0D_NOT_real
  call c_f_pointer(maxfield, f_maxfield_ptr)
  f_maxfield_ptr = f_maxfield
  ! out: f_ref_time 0D_NOT_real
  call c_f_pointer(ref_time, f_ref_time_ptr)
  f_ref_time_ptr = f_ref_time
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_lat_line (line, iu, end_is_neigh, do_split, scibmad) bind(c)

  implicit none
  ! ** In parameters **
  integer(c_int) :: iu  ! 0D_NOT_integer
  integer :: f_iu
  logical(c_bool) :: end_is_neigh  ! 0D_NOT_logical
  logical :: f_end_is_neigh
  type(c_ptr), intent(in), value :: do_split  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_do_split
  logical, target :: f_do_split_native
  logical, pointer :: f_do_split_native_ptr
  logical(c_bool), pointer :: f_do_split_ptr
  type(c_ptr), intent(in), value :: scibmad  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_scibmad
  logical, target :: f_scibmad_native
  logical, pointer :: f_scibmad_native_ptr
  logical(c_bool), pointer :: f_scibmad_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: line
  character(len=4096), target :: f_line
  character(kind=c_char), pointer :: f_line_ptr(:)
  ! ** End of parameters **
  ! inout: f_line 0D_NOT_character
  if (.not. c_associated(line)) return
  call c_f_pointer(line, f_line_ptr, [huge(0)])
  call to_f_str(f_line_ptr, f_line)
  ! in: f_iu 0D_NOT_integer
  f_iu = iu
  ! in: f_end_is_neigh 0D_NOT_logical
  f_end_is_neigh = end_is_neigh
  ! in: f_do_split 0D_NOT_logical
  if (c_associated(do_split)) then
    call c_f_pointer(do_split, f_do_split_ptr)
    f_do_split_native = f_do_split_ptr
    f_do_split_native_ptr => f_do_split_native
  else
    f_do_split_native_ptr => null()
  endif
  ! in: f_scibmad 0D_NOT_logical
  if (c_associated(scibmad)) then
    call c_f_pointer(scibmad, f_scibmad_ptr)
    f_scibmad_native = f_scibmad_ptr
    f_scibmad_native_ptr => f_scibmad_native
  else
    f_scibmad_native_ptr => null()
  endif
  call write_lat_line(line=f_line, iu=f_iu, end_is_neigh=f_end_is_neigh, &
      do_split=f_do_split_native_ptr, scibmad=f_scibmad_native_ptr)

  ! inout: f_line 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
end subroutine
subroutine fortran_write_lattice_in_elegant_format (out_file_name, lat, ref_orbit, &
    use_matrix_model, include_apertures, dr12_drift_max, ix_branch, err) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: out_file_name
  character(len=4096), target :: f_out_file_name
  character(kind=c_char), pointer :: f_out_file_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ref_orbit
  type(coord_struct_container_alloc), pointer :: f_ref_orbit
  type(c_ptr), intent(in), value :: use_matrix_model  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_matrix_model
  logical, target :: f_use_matrix_model_native
  logical, pointer :: f_use_matrix_model_native_ptr
  logical(c_bool), pointer :: f_use_matrix_model_ptr
  type(c_ptr), intent(in), value :: include_apertures  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_apertures
  logical, target :: f_include_apertures_native
  logical, pointer :: f_include_apertures_native_ptr
  logical(c_bool), pointer :: f_include_apertures_ptr
  type(c_ptr), intent(in), value :: dr12_drift_max  ! 0D_NOT_real
  real(c_double) :: f_dr12_drift_max
  real(c_double), pointer :: f_dr12_drift_max_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_out_file_name 0D_NOT_character
  if (.not. c_associated(out_file_name)) return
  call c_f_pointer(out_file_name, f_out_file_name_ptr, [huge(0)])
  call to_f_str(f_out_file_name_ptr, f_out_file_name)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(ref_orbit))   call c_f_pointer(ref_orbit, f_ref_orbit)
  ! in: f_use_matrix_model 0D_NOT_logical
  if (c_associated(use_matrix_model)) then
    call c_f_pointer(use_matrix_model, f_use_matrix_model_ptr)
    f_use_matrix_model_native = f_use_matrix_model_ptr
    f_use_matrix_model_native_ptr => f_use_matrix_model_native
  else
    f_use_matrix_model_native_ptr => null()
  endif
  ! in: f_include_apertures 0D_NOT_logical
  if (c_associated(include_apertures)) then
    call c_f_pointer(include_apertures, f_include_apertures_ptr)
    f_include_apertures_native = f_include_apertures_ptr
    f_include_apertures_native_ptr => f_include_apertures_native
  else
    f_include_apertures_native_ptr => null()
  endif
  ! in: f_dr12_drift_max 0D_NOT_real
  if (c_associated(dr12_drift_max)) then
    call c_f_pointer(dr12_drift_max, f_dr12_drift_max_ptr)
  else
    f_dr12_drift_max_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call write_lattice_in_elegant_format(out_file_name=f_out_file_name, lat=f_lat, &
      ref_orbit=f_ref_orbit%data, use_matrix_model=f_use_matrix_model_native_ptr, &
      include_apertures=f_include_apertures_native_ptr, dr12_drift_max=f_dr12_drift_max_ptr, &
      ix_branch=f_ix_branch_ptr, err=f_err)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_lattice_in_foreign_format (out_type, out_file_name, lat, ref_orbit, &
    use_matrix_model, include_apertures, dr12_drift_max, ix_branch, err) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: out_type
  character(len=4096), target :: f_out_type
  character(kind=c_char), pointer :: f_out_type_ptr(:)
  type(c_ptr), intent(in), value :: out_file_name
  character(len=4096), target :: f_out_file_name
  character(kind=c_char), pointer :: f_out_file_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ref_orbit
  type(coord_struct_container_alloc), pointer :: f_ref_orbit
  type(c_ptr), intent(in), value :: use_matrix_model  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_matrix_model
  logical, target :: f_use_matrix_model_native
  logical, pointer :: f_use_matrix_model_native_ptr
  logical(c_bool), pointer :: f_use_matrix_model_ptr
  type(c_ptr), intent(in), value :: include_apertures  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_apertures
  logical, target :: f_include_apertures_native
  logical, pointer :: f_include_apertures_native_ptr
  logical(c_bool), pointer :: f_include_apertures_ptr
  type(c_ptr), intent(in), value :: dr12_drift_max  ! 0D_NOT_real
  real(c_double) :: f_dr12_drift_max
  real(c_double), pointer :: f_dr12_drift_max_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_out_type 0D_NOT_character
  if (.not. c_associated(out_type)) return
  call c_f_pointer(out_type, f_out_type_ptr, [huge(0)])
  call to_f_str(f_out_type_ptr, f_out_type)
  ! in: f_out_file_name 0D_NOT_character
  if (.not. c_associated(out_file_name)) return
  call c_f_pointer(out_file_name, f_out_file_name_ptr, [huge(0)])
  call to_f_str(f_out_file_name_ptr, f_out_file_name)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(ref_orbit))   call c_f_pointer(ref_orbit, f_ref_orbit)
  ! in: f_use_matrix_model 0D_NOT_logical
  if (c_associated(use_matrix_model)) then
    call c_f_pointer(use_matrix_model, f_use_matrix_model_ptr)
    f_use_matrix_model_native = f_use_matrix_model_ptr
    f_use_matrix_model_native_ptr => f_use_matrix_model_native
  else
    f_use_matrix_model_native_ptr => null()
  endif
  ! in: f_include_apertures 0D_NOT_logical
  if (c_associated(include_apertures)) then
    call c_f_pointer(include_apertures, f_include_apertures_ptr)
    f_include_apertures_native = f_include_apertures_ptr
    f_include_apertures_native_ptr => f_include_apertures_native
  else
    f_include_apertures_native_ptr => null()
  endif
  ! in: f_dr12_drift_max 0D_NOT_real
  if (c_associated(dr12_drift_max)) then
    call c_f_pointer(dr12_drift_max, f_dr12_drift_max_ptr)
  else
    f_dr12_drift_max_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call write_lattice_in_foreign_format(out_type=f_out_type, out_file_name=f_out_file_name, &
      lat=f_lat, ref_orbit=f_ref_orbit%data, use_matrix_model=f_use_matrix_model_native_ptr, &
      include_apertures=f_include_apertures_native_ptr, dr12_drift_max=f_dr12_drift_max_ptr, &
      ix_branch=f_ix_branch_ptr, err=f_err)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_lattice_in_mad_format (out_type, out_file_name, lat, ref_orbit, &
    use_matrix_model, include_apertures, dr12_drift_max, ix_branch, err) bind(c)

  use bmad_struct, only: coord_struct, lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: out_type
  character(len=4096), target :: f_out_type
  character(kind=c_char), pointer :: f_out_type_ptr(:)
  type(c_ptr), intent(in), value :: out_file_name
  character(len=4096), target :: f_out_file_name
  character(kind=c_char), pointer :: f_out_file_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: ref_orbit
  type(coord_struct_container_alloc), pointer :: f_ref_orbit
  type(c_ptr), intent(in), value :: use_matrix_model  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_use_matrix_model
  logical, target :: f_use_matrix_model_native
  logical, pointer :: f_use_matrix_model_native_ptr
  logical(c_bool), pointer :: f_use_matrix_model_ptr
  type(c_ptr), intent(in), value :: include_apertures  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_apertures
  logical, target :: f_include_apertures_native
  logical, pointer :: f_include_apertures_native_ptr
  logical(c_bool), pointer :: f_include_apertures_ptr
  type(c_ptr), intent(in), value :: dr12_drift_max  ! 0D_NOT_real
  real(c_double) :: f_dr12_drift_max
  real(c_double), pointer :: f_dr12_drift_max_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_out_type 0D_NOT_character
  if (.not. c_associated(out_type)) return
  call c_f_pointer(out_type, f_out_type_ptr, [huge(0)])
  call to_f_str(f_out_type_ptr, f_out_type)
  ! in: f_out_file_name 0D_NOT_character
  if (.not. c_associated(out_file_name)) return
  call c_f_pointer(out_file_name, f_out_file_name_ptr, [huge(0)])
  call to_f_str(f_out_file_name_ptr, f_out_file_name)
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  !! container type array (1D_ALLOC_type)
  if (c_associated(ref_orbit))   call c_f_pointer(ref_orbit, f_ref_orbit)
  ! in: f_use_matrix_model 0D_NOT_logical
  if (c_associated(use_matrix_model)) then
    call c_f_pointer(use_matrix_model, f_use_matrix_model_ptr)
    f_use_matrix_model_native = f_use_matrix_model_ptr
    f_use_matrix_model_native_ptr => f_use_matrix_model_native
  else
    f_use_matrix_model_native_ptr => null()
  endif
  ! in: f_include_apertures 0D_NOT_logical
  if (c_associated(include_apertures)) then
    call c_f_pointer(include_apertures, f_include_apertures_ptr)
    f_include_apertures_native = f_include_apertures_ptr
    f_include_apertures_native_ptr => f_include_apertures_native
  else
    f_include_apertures_native_ptr => null()
  endif
  ! in: f_dr12_drift_max 0D_NOT_real
  if (c_associated(dr12_drift_max)) then
    call c_f_pointer(dr12_drift_max, f_dr12_drift_max_ptr)
  else
    f_dr12_drift_max_ptr => null()
  endif
  ! in: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  call write_lattice_in_mad_format(out_type=f_out_type, out_file_name=f_out_file_name, &
      lat=f_lat, ref_orbit=f_ref_orbit%data, use_matrix_model=f_use_matrix_model_native_ptr, &
      include_apertures=f_include_apertures_native_ptr, dr12_drift_max=f_dr12_drift_max_ptr, &
      ix_branch=f_ix_branch_ptr, err=f_err)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_lattice_in_sad_format (out_file_name, lat, include_apertures, &
    ix_branch, err) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: out_file_name
  character(len=4096), target :: f_out_file_name
  character(kind=c_char), pointer :: f_out_file_name_ptr(:)
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  type(c_ptr), intent(in), value :: include_apertures  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_include_apertures
  logical, target :: f_include_apertures_native
  logical, pointer :: f_include_apertures_native_ptr
  logical(c_bool), pointer :: f_include_apertures_ptr
  type(c_ptr), intent(in), value :: ix_branch  ! 0D_NOT_integer
  integer(c_int) :: f_ix_branch
  integer(c_int), pointer :: f_ix_branch_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_err
  logical, target :: f_err_native
  logical, pointer :: f_err_native_ptr
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! inout: f_out_file_name 0D_NOT_character
  if (.not. c_associated(out_file_name)) return
  call c_f_pointer(out_file_name, f_out_file_name_ptr, [huge(0)])
  call to_f_str(f_out_file_name_ptr, f_out_file_name)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  ! inout: f_include_apertures 0D_NOT_logical
  if (c_associated(include_apertures)) then
    call c_f_pointer(include_apertures, f_include_apertures_ptr)
    f_include_apertures_native = f_include_apertures_ptr
    f_include_apertures_native_ptr => f_include_apertures_native
  else
    f_include_apertures_native_ptr => null()
  endif
  ! inout: f_ix_branch 0D_NOT_integer
  if (c_associated(ix_branch)) then
    call c_f_pointer(ix_branch, f_ix_branch_ptr)
  else
    f_ix_branch_ptr => null()
  endif
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_native = f_err_ptr
    f_err_native_ptr => f_err_native
  else
    f_err_native_ptr => null()
  endif
  call write_lattice_in_sad_format(out_file_name=f_out_file_name, lat=f_lat, &
      include_apertures=f_include_apertures_native_ptr, ix_branch=f_ix_branch_ptr, &
      err=f_err_native_ptr)

  ! inout: f_out_file_name 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_include_apertures 0D_NOT_logical
  if (c_associated(include_apertures)) then
    call c_f_pointer(include_apertures, f_include_apertures_ptr)
    f_include_apertures_ptr = f_include_apertures_native
  else
    ! f_include_apertures unset
  endif
  ! inout: f_ix_branch 0D_NOT_integer
  ! no output conversion for f_ix_branch
  ! inout: f_err 0D_NOT_logical
  if (c_associated(err)) then
    call c_f_pointer(err, f_err_ptr)
    f_err_ptr = f_err_native
  else
    ! f_err unset
  endif
end subroutine
subroutine fortran_write_lattice_in_scibmad (scibmad_file, lat, err_flag) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: scibmad_file
  character(len=4096), target :: f_scibmad_file
  character(kind=c_char), pointer :: f_scibmad_file_ptr(:)
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  ! ** End of parameters **
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(lat, f_lat)
  call write_lattice_in_scibmad(scibmad_file=f_scibmad_file, lat=f_lat, err_flag=f_err_flag)

  ! out: f_scibmad_file 0D_NOT_character
  call c_f_pointer(scibmad_file, f_scibmad_file_ptr, [len_trim(f_scibmad_file) + 1]) ! output-only string
  call to_c_str(f_scibmad_file, f_scibmad_file_ptr)
  ! out: f_err_flag 0D_NOT_logical
  ! no output conversion for f_err_flag
end subroutine
subroutine fortran_write_line_element (line, iu, ele, lat) bind(c)

  use bmad_struct, only: ele_struct, lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: line
  character(len=4096), target :: f_line
  character(kind=c_char), pointer :: f_line_ptr(:)
  type(c_ptr), intent(in), value :: iu  ! 0D_NOT_integer
  integer(c_int) :: f_iu
  integer(c_int), pointer :: f_iu_ptr
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_line 0D_NOT_character
  if (.not. c_associated(line)) return
  call c_f_pointer(line, f_line_ptr, [huge(0)])
  call to_f_str(f_line_ptr, f_line)
  ! inout: f_iu 0D_NOT_integer
  if (c_associated(iu)) then
    call c_f_pointer(iu, f_iu_ptr)
  else
    f_iu_ptr => null()
  endif
  ! inout: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call write_line_element(line=f_line, iu=f_iu_ptr, ele=f_ele, lat=f_lat)

  ! inout: f_line 0D_NOT_character
  ! TODO i/o string (max length issue; buffer overflow...)
  ! inout: f_iu 0D_NOT_integer
  ! no output conversion for f_iu
end subroutine
subroutine fortran_write_opal_field_grid_file (opal_file_unit, ele, param, maxfield, err) &
    bind(c)

  use bmad_struct, only: ele_struct, lat_param_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: opal_file_unit  ! 0D_NOT_integer
  integer :: f_opal_file_unit
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), value :: param  ! 0D_NOT_type
  type(lat_param_struct), pointer :: f_param
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: maxfield  ! 0D_NOT_real
  real(rp) :: f_maxfield
  real(c_double), pointer :: f_maxfield_ptr
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_opal_file_unit 0D_NOT_integer
  f_opal_file_unit = opal_file_unit
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_param 0D_NOT_type
  if (.not. c_associated(param)) return
  call c_f_pointer(param, f_param)
  call write_opal_field_grid_file(opal_file_unit=f_opal_file_unit, ele=f_ele, param=f_param, &
      maxfield=f_maxfield, err=f_err)

  ! out: f_maxfield 0D_NOT_real
  call c_f_pointer(maxfield, f_maxfield_ptr)
  f_maxfield_ptr = f_maxfield
  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_opal_lattice_file (opal_file_unit, lat, err) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: opal_file_unit  ! 0D_NOT_integer
  integer :: f_opal_file_unit
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_opal_file_unit 0D_NOT_integer
  f_opal_file_unit = opal_file_unit
  ! in: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call write_opal_lattice_file(opal_file_unit=f_opal_file_unit, lat=f_lat, err=f_err)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_write_time_particle_distribution (time_file_unit, bunch, ele, style, branch, &
    format, err) bind(c)

  use bmad_struct, only: branch_struct, bunch_struct, ele_struct
  implicit none
  ! ** In parameters **
  integer(c_int) :: time_file_unit  ! 0D_NOT_integer
  integer :: f_time_file_unit
  type(c_ptr), value :: bunch  ! 0D_NOT_type
  type(bunch_struct), pointer :: f_bunch
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: style
  character(len=4096), target :: f_style
  character(kind=c_char), pointer :: f_style_ptr(:)
  character(len=4096), pointer :: f_style_call_ptr
  type(c_ptr), value :: branch  ! 0D_NOT_type
  type(branch_struct), pointer :: f_branch
  type(c_ptr), intent(in), value :: format
  character(len=4096), target :: f_format
  character(kind=c_char), pointer :: f_format_ptr(:)
  character(len=4096), pointer :: f_format_call_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err  ! 0D_NOT_logical
  logical :: f_err
  logical(c_bool), pointer :: f_err_ptr
  ! ** End of parameters **
  ! in: f_time_file_unit 0D_NOT_integer
  f_time_file_unit = time_file_unit
  ! in: f_bunch 0D_NOT_type
  if (.not. c_associated(bunch)) return
  call c_f_pointer(bunch, f_bunch)
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  ! in: f_style 0D_NOT_character
  if (c_associated(style)) then
    call c_f_pointer(style, f_style_ptr, [huge(0)])
    call to_f_str(f_style_ptr, f_style)
    f_style_call_ptr => f_style
  else
    f_style_call_ptr => null()
  endif
  ! in: f_branch 0D_NOT_type
  if (c_associated(branch))   call c_f_pointer(branch, f_branch)
  ! in: f_format 0D_NOT_character
  if (c_associated(format)) then
    call c_f_pointer(format, f_format_ptr, [huge(0)])
    call to_f_str(f_format_ptr, f_format)
    f_format_call_ptr => f_format
  else
    f_format_call_ptr => null()
  endif
  call write_time_particle_distribution(time_file_unit=f_time_file_unit, bunch=f_bunch, &
      ele=f_ele, style=f_style_call_ptr, branch=f_branch, format=f_format_call_ptr, err=f_err)

  ! out: f_err 0D_NOT_logical
  ! no output conversion for f_err
end subroutine
subroutine fortran_xlafun (x, y, z, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(c_double) :: f_z
  real(c_double), pointer :: f_z_ptr
  ! ** End of parameters **
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_z 0D_NOT_real
  if (c_associated(z)) then
    call c_f_pointer(z, f_z_ptr)
  else
    f_z_ptr => null()
  endif
  f_res = xlafun(x=f_x_ptr, y=f_y_ptr, z=f_z_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_z 0D_NOT_real
  ! no output conversion for f_z
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_xraylib_nist_compound (name, indx) bind(c)

  implicit none
  ! ** In parameters **
  type(c_ptr), intent(in), value :: name
  character(len=4096), target :: f_name
  character(kind=c_char), pointer :: f_name_ptr(:)
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: indx  ! 0D_NOT_integer
  integer :: f_indx
  integer(c_int), pointer :: f_indx_ptr
  ! ** End of parameters **
  ! in: f_name 0D_NOT_character
  if (.not. c_associated(name)) return
  call c_f_pointer(name, f_name_ptr, [huge(0)])
  call to_f_str(f_name_ptr, f_name)
  f_indx = xraylib_nist_compound(name=f_name)

  ! out: f_indx 0D_NOT_integer
  call c_f_pointer(indx, f_indx_ptr)
  f_indx_ptr = f_indx
end subroutine
subroutine fortran_ylafun (x, y, z, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(c_double) :: f_z
  real(c_double), pointer :: f_z_ptr
  ! ** End of parameters **
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_z 0D_NOT_real
  if (c_associated(z)) then
    call c_f_pointer(z, f_z_ptr)
  else
    f_z_ptr => null()
  endif
  f_res = ylafun(x=f_x_ptr, y=f_y_ptr, z=f_z_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_z 0D_NOT_real
  ! no output conversion for f_z
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine
subroutine fortran_z_at_surface (ele, x, y, err_flag, extend_grid, dz_dxy, z) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** In parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  type(c_ptr), intent(in), value :: extend_grid  ! 0D_NOT_logical
  logical(c_bool), pointer :: f_extend_grid
  logical, target :: f_extend_grid_native
  logical, pointer :: f_extend_grid_native_ptr
  logical(c_bool), pointer :: f_extend_grid_ptr
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: err_flag  ! 0D_NOT_logical
  logical :: f_err_flag
  logical(c_bool), pointer :: f_err_flag_ptr
  type(c_ptr), intent(in), value :: dz_dxy
  real(rp) :: f_dz_dxy(2)
  real(c_double), pointer :: f_dz_dxy_ptr(:)
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(rp) :: f_z
  real(c_double), pointer :: f_z_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  ! ** End of parameters **
  ! in: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) then
    call c_f_pointer(err_flag, f_err_flag_ptr)
    f_err_flag_ptr = .true.
    return
  endif
  call c_f_pointer(ele, f_ele)
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! in: f_extend_grid 0D_NOT_logical
  if (c_associated(extend_grid)) then
    call c_f_pointer(extend_grid, f_extend_grid_ptr)
    f_extend_grid_native = f_extend_grid_ptr
    f_extend_grid_native_ptr => f_extend_grid_native
  else
    f_extend_grid_native_ptr => null()
  endif
  f_z = z_at_surface(ele=f_ele, x=f_x_ptr, y=f_y_ptr, err_flag=f_err_flag, &
      extend_grid=f_extend_grid_native_ptr, dz_dxy=f_dz_dxy)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! out: f_err_flag 0D_NOT_logical
  call c_f_pointer(err_flag, f_err_flag_ptr)
  f_err_flag_ptr = f_err_flag
  ! out: f_dz_dxy 1D_NOT_real
  if (c_associated(dz_dxy)) then
    call c_f_pointer(dz_dxy, f_dz_dxy_ptr, [2])
    f_dz_dxy_ptr = f_dz_dxy(:)
  endif
  ! out: f_z 0D_NOT_real
  call c_f_pointer(z, f_z_ptr)
  f_z_ptr = f_z
end subroutine
subroutine fortran_zero_ele_kicks (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call zero_ele_kicks(ele=f_ele)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_zero_ele_offsets (ele) bind(c)

  use bmad_struct, only: ele_struct
  implicit none
  ! ** Out parameters **
  type(c_ptr), value :: ele  ! 0D_NOT_type
  type(ele_struct), pointer :: f_ele
  ! ** End of parameters **
  ! out: f_ele 0D_NOT_type
  if (.not. c_associated(ele)) return
  call c_f_pointer(ele, f_ele)
  call zero_ele_offsets(ele=f_ele)

  ! out: f_ele 0D_NOT_type
  ! TODO may require output conversion? 0D_NOT_type
end subroutine
subroutine fortran_zero_lr_wakes_in_lat (lat) bind(c)

  use bmad_struct, only: lat_struct
  implicit none
  ! ** Inout parameters **
  type(c_ptr), value :: lat  ! 0D_NOT_type
  type(lat_struct), pointer :: f_lat
  ! ** End of parameters **
  ! inout: f_lat 0D_NOT_type
  if (.not. c_associated(lat)) return
  call c_f_pointer(lat, f_lat)
  call zero_lr_wakes_in_lat(lat=f_lat)

end subroutine
subroutine fortran_zlafun (x, y, z, res) bind(c)

  implicit none
  ! ** Out parameters **
  type(c_ptr), intent(in), value :: res  ! 0D_NOT_real
  real(dp) :: f_res
  real(c_double), pointer :: f_res_ptr
  ! ** Inout parameters **
  type(c_ptr), intent(in), value :: x  ! 0D_NOT_real
  real(c_double) :: f_x
  real(c_double), pointer :: f_x_ptr
  type(c_ptr), intent(in), value :: y  ! 0D_NOT_real
  real(c_double) :: f_y
  real(c_double), pointer :: f_y_ptr
  type(c_ptr), intent(in), value :: z  ! 0D_NOT_real
  real(c_double) :: f_z
  real(c_double), pointer :: f_z_ptr
  ! ** End of parameters **
  ! inout: f_x 0D_NOT_real
  if (c_associated(x)) then
    call c_f_pointer(x, f_x_ptr)
  else
    f_x_ptr => null()
  endif
  ! inout: f_y 0D_NOT_real
  if (c_associated(y)) then
    call c_f_pointer(y, f_y_ptr)
  else
    f_y_ptr => null()
  endif
  ! inout: f_z 0D_NOT_real
  if (c_associated(z)) then
    call c_f_pointer(z, f_z_ptr)
  else
    f_z_ptr => null()
  endif
  f_res = zlafun(x=f_x_ptr, y=f_y_ptr, z=f_z_ptr)

  ! inout: f_x 0D_NOT_real
  ! no output conversion for f_x
  ! inout: f_y 0D_NOT_real
  ! no output conversion for f_y
  ! inout: f_z 0D_NOT_real
  ! no output conversion for f_z
  ! out: f_res 0D_NOT_real
  call c_f_pointer(res, f_res_ptr)
  f_res_ptr = f_res
end subroutine

end module cppbmad_routines
