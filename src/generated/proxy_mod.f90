module bmad_struct_proxy_mod
  use bmad_struct
  use tao_struct
  use test_struct_defs
  use, intrinsic :: iso_c_binding

    use spline_mod, only: spline_struct
  use bmad_struct, only: ac_kicker_freq_struct, ac_kicker_struct, ac_kicker_time_struct, anormal_mode_struct, aperture_param_struct, aperture_point_struct, aperture_scan_struct, beam_init_struct, beam_struct, bmad_common_struct, bmad_normal_form_struct, bookkeeping_state_struct, bpm_phase_coupling_struct, branch_struct, bunch_params_struct, bunch_struct, bunch_track_struct, cartesian_map_struct, cartesian_map_term1_struct, cartesian_map_term_struct, complex_taylor_struct, complex_taylor_term_struct, control_ramp1_struct, control_struct, control_var1_struct, controller_struct, coord_array_struct, coord_struct, cylindrical_map_struct, cylindrical_map_term1_struct, cylindrical_map_term_struct, ele_pointer_struct, ele_struct, ellipse_beam_init_struct, em_field_struct, em_taylor_struct, em_taylor_term_struct, expression_atom_struct, expression_tree_struct, floor_position_struct, gen_grad1_struct, gen_grad_map_struct, grid_beam_init_struct, grid_field_pt1_struct, grid_field_pt_struct, grid_field_struct, high_energy_space_charge_struct, interval1_coef_struct, kv_beam_init_struct, lat_ele_loc_struct, lat_ele_order1_struct, lat_ele_order_array_struct, lat_ele_order_struct, lat_param_struct, lat_struct, linac_normal_mode_struct, mode3_struct, mode_info_struct, normal_modes_struct, photon_element_struct, photon_material_struct, photon_reflect_surface_struct, photon_reflect_table_struct, photon_target_struct, pixel_detec_struct, pixel_pt_struct, pre_tracker_struct, ptc_normal_form_struct, rad_int1_struct, rad_int_all_ele_struct, rad_int_branch_struct, rad_map_ele_struct, rad_map_struct, ramper_lord_struct, resonance_h_struct, rf_ele_struct, rf_stair_step_struct, space_charge_common_struct, spin_axis_struct, spin_orbit_map1_struct, spin_polar_struct, strong_beam_struct, surface_curvature_struct, surface_displacement_pt_struct, surface_displacement_struct, surface_h_misalign_pt_struct, surface_h_misalign_struct, surface_segmented_pt_struct, surface_segmented_struct, target_point_struct, taylor_struct, taylor_term_struct, track_point_struct, track_struct, twiss_struct, wake_lr_mode_struct, wake_lr_struct, wake_sr_mode_struct, wake_sr_struct, wake_sr_z_long_struct, wake_struct, wall3d_section_struct, wall3d_struct, wall3d_vertex_struct, xy_disp_struct
  use cubic_interpolation_mod, only: bicubic_cmplx_coef_struct, tricubic_cmplx_coef_struct
  use sim_utils_struct, only: nametable_struct
  use tao_struct, only: tao_beam_branch_struct, tao_beam_uni_struct, tao_building_wall_orientation_struct, tao_building_wall_point_struct, tao_building_wall_section_struct, tao_building_wall_struct, tao_cmd_history_struct, tao_common_struct, tao_curve_color_struct, tao_curve_orbit_struct, tao_curve_struct, tao_d1_data_struct, tao_d2_data_struct, tao_data_struct, tao_data_var_component_struct, tao_drawing_struct, tao_dynamic_aperture_struct, tao_ele_pointer_struct, tao_ele_shape_struct, tao_floor_plan_struct, tao_global_struct, tao_graph_struct, tao_histogram_struct, tao_init_struct, tao_lat_sigma_struct, tao_lattice_branch_struct, tao_lattice_struct, tao_model_branch_struct, tao_model_element_struct, tao_ping_scale_struct, tao_plot_cache_struct, tao_plot_page_struct, tao_plot_region_struct, tao_plot_struct, tao_shape_pattern_point_struct, tao_shape_pattern_struct, tao_spin_dn_dpz_struct, tao_spin_ele_struct, tao_spin_map_struct, tao_spin_polarization_struct, tao_super_universe_struct, tao_title_struct, tao_universe_calc_struct, tao_universe_pointer_struct, tao_universe_struct, tao_v1_var_struct, tao_var_slave_struct, tao_var_struct, tao_wave_kick_pt_struct, tao_wave_struct
  use srdt_mod, only: summation_rdt_struct
  use quick_plot_struct, only: qp_axis_struct, qp_legend_struct, qp_line_struct, qp_point_struct, qp_rect_struct, qp_symbol_struct
  use mad_mod, only: mad_energy_struct, mad_map_struct
  use random_mod, only: random_state_struct
  use bbu_track_mod, only: bbu_beam_struct, bbu_param_struct, bbu_stage_struct
  use test_struct_defs, only: all_encompassing_struct, test_sub_struct, test_sub_sub_struct
  
  type :: spline_struct_container_alloc
    type(spline_struct), allocatable :: data(:)
  end type spline_struct_container_alloc

  type :: spin_polar_struct_container_alloc
    type(spin_polar_struct), allocatable :: data(:)
  end type spin_polar_struct_container_alloc

  type :: ac_kicker_time_struct_container_alloc
    type(ac_kicker_time_struct), allocatable :: data(:)
  end type ac_kicker_time_struct_container_alloc

  type :: ac_kicker_freq_struct_container_alloc
    type(ac_kicker_freq_struct), allocatable :: data(:)
  end type ac_kicker_freq_struct_container_alloc

  type :: ac_kicker_struct_container_alloc
    type(ac_kicker_struct), allocatable :: data(:)
  end type ac_kicker_struct_container_alloc

  type :: interval1_coef_struct_container_alloc
    type(interval1_coef_struct), allocatable :: data(:)
  end type interval1_coef_struct_container_alloc

  type :: photon_reflect_table_struct_container_alloc
    type(photon_reflect_table_struct), allocatable :: data(:)
  end type photon_reflect_table_struct_container_alloc

  type :: photon_reflect_surface_struct_container_alloc
    type(photon_reflect_surface_struct), allocatable :: data(:)
  end type photon_reflect_surface_struct_container_alloc

  type :: coord_struct_container_alloc
    type(coord_struct), allocatable :: data(:)
  end type coord_struct_container_alloc

  type :: coord_array_struct_container_alloc
    type(coord_array_struct), allocatable :: data(:)
  end type coord_array_struct_container_alloc

  type :: bpm_phase_coupling_struct_container_alloc
    type(bpm_phase_coupling_struct), allocatable :: data(:)
  end type bpm_phase_coupling_struct_container_alloc

  type :: expression_atom_struct_container_alloc
    type(expression_atom_struct), allocatable :: data(:)
  end type expression_atom_struct_container_alloc

  type :: wake_sr_z_long_struct_container_alloc
    type(wake_sr_z_long_struct), allocatable :: data(:)
  end type wake_sr_z_long_struct_container_alloc

  type :: wake_sr_mode_struct_container_alloc
    type(wake_sr_mode_struct), allocatable :: data(:)
  end type wake_sr_mode_struct_container_alloc

  type :: wake_sr_struct_container_alloc
    type(wake_sr_struct), allocatable :: data(:)
  end type wake_sr_struct_container_alloc

  type :: wake_lr_mode_struct_container_alloc
    type(wake_lr_mode_struct), allocatable :: data(:)
  end type wake_lr_mode_struct_container_alloc

  type :: wake_lr_struct_container_alloc
    type(wake_lr_struct), allocatable :: data(:)
  end type wake_lr_struct_container_alloc

  type :: lat_ele_loc_struct_container_alloc
    type(lat_ele_loc_struct), allocatable :: data(:)
  end type lat_ele_loc_struct_container_alloc

  type :: wake_struct_container_alloc
    type(wake_struct), allocatable :: data(:)
  end type wake_struct_container_alloc

  type :: taylor_term_struct_container_alloc
    type(taylor_term_struct), allocatable :: data(:)
  end type taylor_term_struct_container_alloc

  type :: taylor_struct_container_alloc
    type(taylor_struct), allocatable :: data(:)
  end type taylor_struct_container_alloc

  type :: em_taylor_term_struct_container_alloc
    type(em_taylor_term_struct), allocatable :: data(:)
  end type em_taylor_term_struct_container_alloc

  type :: em_taylor_struct_container_alloc
    type(em_taylor_struct), allocatable :: data(:)
  end type em_taylor_struct_container_alloc

  type :: cartesian_map_term1_struct_container_alloc
    type(cartesian_map_term1_struct), allocatable :: data(:)
  end type cartesian_map_term1_struct_container_alloc

  type :: cartesian_map_term_struct_container_alloc
    type(cartesian_map_term_struct), allocatable :: data(:)
  end type cartesian_map_term_struct_container_alloc

  type :: cartesian_map_struct_container_alloc
    type(cartesian_map_struct), allocatable :: data(:)
  end type cartesian_map_struct_container_alloc

  type :: cylindrical_map_term1_struct_container_alloc
    type(cylindrical_map_term1_struct), allocatable :: data(:)
  end type cylindrical_map_term1_struct_container_alloc

  type :: cylindrical_map_term_struct_container_alloc
    type(cylindrical_map_term_struct), allocatable :: data(:)
  end type cylindrical_map_term_struct_container_alloc

  type :: cylindrical_map_struct_container_alloc
    type(cylindrical_map_struct), allocatable :: data(:)
  end type cylindrical_map_struct_container_alloc

  type :: bicubic_cmplx_coef_struct_container_alloc
    type(bicubic_cmplx_coef_struct), allocatable :: data(:)
  end type bicubic_cmplx_coef_struct_container_alloc

  type :: tricubic_cmplx_coef_struct_container_alloc
    type(tricubic_cmplx_coef_struct), allocatable :: data(:)
  end type tricubic_cmplx_coef_struct_container_alloc

  type :: grid_field_pt1_struct_container_alloc
    type(grid_field_pt1_struct), allocatable :: data(:)
  end type grid_field_pt1_struct_container_alloc

  type :: grid_field_pt_struct_container_alloc
    type(grid_field_pt_struct), allocatable :: data(:)
  end type grid_field_pt_struct_container_alloc

  type :: grid_field_struct_container_alloc
    type(grid_field_struct), allocatable :: data(:)
  end type grid_field_struct_container_alloc

  type :: floor_position_struct_container_alloc
    type(floor_position_struct), allocatable :: data(:)
  end type floor_position_struct_container_alloc

  type :: high_energy_space_charge_struct_container_alloc
    type(high_energy_space_charge_struct), allocatable :: data(:)
  end type high_energy_space_charge_struct_container_alloc

  type :: xy_disp_struct_container_alloc
    type(xy_disp_struct), allocatable :: data(:)
  end type xy_disp_struct_container_alloc

  type :: twiss_struct_container_alloc
    type(twiss_struct), allocatable :: data(:)
  end type twiss_struct_container_alloc

  type :: mode3_struct_container_alloc
    type(mode3_struct), allocatable :: data(:)
  end type mode3_struct_container_alloc

  type :: bookkeeping_state_struct_container_alloc
    type(bookkeeping_state_struct), allocatable :: data(:)
  end type bookkeeping_state_struct_container_alloc

  type :: rad_map_struct_container_alloc
    type(rad_map_struct), allocatable :: data(:)
  end type rad_map_struct_container_alloc

  type :: rad_map_ele_struct_container_alloc
    type(rad_map_ele_struct), allocatable :: data(:)
  end type rad_map_ele_struct_container_alloc

  type :: gen_grad1_struct_container_alloc
    type(gen_grad1_struct), allocatable :: data(:)
  end type gen_grad1_struct_container_alloc

  type :: gen_grad_map_struct_container_alloc
    type(gen_grad_map_struct), allocatable :: data(:)
  end type gen_grad_map_struct_container_alloc

  type :: surface_segmented_pt_struct_container_alloc
    type(surface_segmented_pt_struct), allocatable :: data(:)
  end type surface_segmented_pt_struct_container_alloc

  type :: surface_segmented_struct_container_alloc
    type(surface_segmented_struct), allocatable :: data(:)
  end type surface_segmented_struct_container_alloc

  type :: surface_h_misalign_pt_struct_container_alloc
    type(surface_h_misalign_pt_struct), allocatable :: data(:)
  end type surface_h_misalign_pt_struct_container_alloc

  type :: surface_h_misalign_struct_container_alloc
    type(surface_h_misalign_struct), allocatable :: data(:)
  end type surface_h_misalign_struct_container_alloc

  type :: surface_displacement_pt_struct_container_alloc
    type(surface_displacement_pt_struct), allocatable :: data(:)
  end type surface_displacement_pt_struct_container_alloc

  type :: surface_displacement_struct_container_alloc
    type(surface_displacement_struct), allocatable :: data(:)
  end type surface_displacement_struct_container_alloc

  type :: target_point_struct_container_alloc
    type(target_point_struct), allocatable :: data(:)
  end type target_point_struct_container_alloc

  type :: surface_curvature_struct_container_alloc
    type(surface_curvature_struct), allocatable :: data(:)
  end type surface_curvature_struct_container_alloc

  type :: photon_target_struct_container_alloc
    type(photon_target_struct), allocatable :: data(:)
  end type photon_target_struct_container_alloc

  type :: photon_material_struct_container_alloc
    type(photon_material_struct), allocatable :: data(:)
  end type photon_material_struct_container_alloc

  type :: pixel_pt_struct_container_alloc
    type(pixel_pt_struct), allocatable :: data(:)
  end type pixel_pt_struct_container_alloc

  type :: pixel_detec_struct_container_alloc
    type(pixel_detec_struct), allocatable :: data(:)
  end type pixel_detec_struct_container_alloc

  type :: photon_element_struct_container_alloc
    type(photon_element_struct), allocatable :: data(:)
  end type photon_element_struct_container_alloc

  type :: wall3d_vertex_struct_container_alloc
    type(wall3d_vertex_struct), allocatable :: data(:)
  end type wall3d_vertex_struct_container_alloc

  type :: wall3d_section_struct_container_alloc
    type(wall3d_section_struct), allocatable :: data(:)
  end type wall3d_section_struct_container_alloc

  type :: wall3d_struct_container_alloc
    type(wall3d_struct), allocatable :: data(:)
  end type wall3d_struct_container_alloc

  type :: ramper_lord_struct_container_alloc
    type(ramper_lord_struct), allocatable :: data(:)
  end type ramper_lord_struct_container_alloc

  type :: control_struct_container_alloc
    type(control_struct), allocatable :: data(:)
  end type control_struct_container_alloc

  type :: control_var1_struct_container_alloc
    type(control_var1_struct), allocatable :: data(:)
  end type control_var1_struct_container_alloc

  type :: control_ramp1_struct_container_alloc
    type(control_ramp1_struct), allocatable :: data(:)
  end type control_ramp1_struct_container_alloc

  type :: controller_struct_container_alloc
    type(controller_struct), allocatable :: data(:)
  end type controller_struct_container_alloc

  type :: ellipse_beam_init_struct_container_alloc
    type(ellipse_beam_init_struct), allocatable :: data(:)
  end type ellipse_beam_init_struct_container_alloc

  type :: kv_beam_init_struct_container_alloc
    type(kv_beam_init_struct), allocatable :: data(:)
  end type kv_beam_init_struct_container_alloc

  type :: grid_beam_init_struct_container_alloc
    type(grid_beam_init_struct), allocatable :: data(:)
  end type grid_beam_init_struct_container_alloc

  type :: beam_init_struct_container_alloc
    type(beam_init_struct), allocatable :: data(:)
  end type beam_init_struct_container_alloc

  type :: lat_param_struct_container_alloc
    type(lat_param_struct), allocatable :: data(:)
  end type lat_param_struct_container_alloc

  type :: mode_info_struct_container_alloc
    type(mode_info_struct), allocatable :: data(:)
  end type mode_info_struct_container_alloc

  type :: pre_tracker_struct_container_alloc
    type(pre_tracker_struct), allocatable :: data(:)
  end type pre_tracker_struct_container_alloc

  type :: anormal_mode_struct_container_alloc
    type(anormal_mode_struct), allocatable :: data(:)
  end type anormal_mode_struct_container_alloc

  type :: linac_normal_mode_struct_container_alloc
    type(linac_normal_mode_struct), allocatable :: data(:)
  end type linac_normal_mode_struct_container_alloc

  type :: normal_modes_struct_container_alloc
    type(normal_modes_struct), allocatable :: data(:)
  end type normal_modes_struct_container_alloc

  type :: em_field_struct_container_alloc
    type(em_field_struct), allocatable :: data(:)
  end type em_field_struct_container_alloc

  type :: strong_beam_struct_container_alloc
    type(strong_beam_struct), allocatable :: data(:)
  end type strong_beam_struct_container_alloc

  type :: track_point_struct_container_alloc
    type(track_point_struct), allocatable :: data(:)
  end type track_point_struct_container_alloc

  type :: track_struct_container_alloc
    type(track_struct), allocatable :: data(:)
  end type track_struct_container_alloc

  type :: space_charge_common_struct_container_alloc
    type(space_charge_common_struct), allocatable :: data(:)
  end type space_charge_common_struct_container_alloc

  type :: bmad_common_struct_container_alloc
    type(bmad_common_struct), allocatable :: data(:)
  end type bmad_common_struct_container_alloc

  type :: rad_int1_struct_container_alloc
    type(rad_int1_struct), allocatable :: data(:)
  end type rad_int1_struct_container_alloc

  type :: rad_int_branch_struct_container_alloc
    type(rad_int_branch_struct), allocatable :: data(:)
  end type rad_int_branch_struct_container_alloc

  type :: rad_int_all_ele_struct_container_alloc
    type(rad_int_all_ele_struct), allocatable :: data(:)
  end type rad_int_all_ele_struct_container_alloc

  type :: rf_stair_step_struct_container_alloc
    type(rf_stair_step_struct), allocatable :: data(:)
  end type rf_stair_step_struct_container_alloc

  type :: rf_ele_struct_container_alloc
    type(rf_ele_struct), allocatable :: data(:)
  end type rf_ele_struct_container_alloc

  type :: ele_struct_container_alloc
    type(ele_struct), allocatable :: data(:)
  end type ele_struct_container_alloc

  type :: complex_taylor_term_struct_container_alloc
    type(complex_taylor_term_struct), allocatable :: data(:)
  end type complex_taylor_term_struct_container_alloc

  type :: complex_taylor_struct_container_alloc
    type(complex_taylor_struct), allocatable :: data(:)
  end type complex_taylor_struct_container_alloc

  type :: branch_struct_container_alloc
    type(branch_struct), allocatable :: data(:)
  end type branch_struct_container_alloc

  type :: lat_struct_container_alloc
    type(lat_struct), allocatable :: data(:)
  end type lat_struct_container_alloc

  type :: bunch_struct_container_alloc
    type(bunch_struct), allocatable :: data(:)
  end type bunch_struct_container_alloc

  type :: bunch_params_struct_container_alloc
    type(bunch_params_struct), allocatable :: data(:)
  end type bunch_params_struct_container_alloc

  type :: beam_struct_container_alloc
    type(beam_struct), allocatable :: data(:)
  end type beam_struct_container_alloc

  type :: aperture_point_struct_container_alloc
    type(aperture_point_struct), allocatable :: data(:)
  end type aperture_point_struct_container_alloc

  type :: aperture_param_struct_container_alloc
    type(aperture_param_struct), allocatable :: data(:)
  end type aperture_param_struct_container_alloc

  type :: aperture_scan_struct_container_alloc
    type(aperture_scan_struct), allocatable :: data(:)
  end type aperture_scan_struct_container_alloc

  type :: ele_pointer_struct_container_alloc
    type(ele_pointer_struct), allocatable :: data(:)
  end type ele_pointer_struct_container_alloc

  type :: expression_tree_struct_container_alloc
    type(expression_tree_struct), allocatable :: data(:)
  end type expression_tree_struct_container_alloc

  type :: nametable_struct_container_alloc
    type(nametable_struct), allocatable :: data(:)
  end type nametable_struct_container_alloc

  type :: tao_spin_dn_dpz_struct_container_alloc
    type(tao_spin_dn_dpz_struct), allocatable :: data(:)
  end type tao_spin_dn_dpz_struct_container_alloc

  type :: resonance_h_struct_container_alloc
    type(resonance_h_struct), allocatable :: data(:)
  end type resonance_h_struct_container_alloc

  type :: spin_orbit_map1_struct_container_alloc
    type(spin_orbit_map1_struct), allocatable :: data(:)
  end type spin_orbit_map1_struct_container_alloc

  type :: spin_axis_struct_container_alloc
    type(spin_axis_struct), allocatable :: data(:)
  end type spin_axis_struct_container_alloc

  type :: ptc_normal_form_struct_container_alloc
    type(ptc_normal_form_struct), allocatable :: data(:)
  end type ptc_normal_form_struct_container_alloc

  type :: bmad_normal_form_struct_container_alloc
    type(bmad_normal_form_struct), allocatable :: data(:)
  end type bmad_normal_form_struct_container_alloc

  type :: bunch_track_struct_container_alloc
    type(bunch_track_struct), allocatable :: data(:)
  end type bunch_track_struct_container_alloc

  type :: summation_rdt_struct_container_alloc
    type(summation_rdt_struct), allocatable :: data(:)
  end type summation_rdt_struct_container_alloc

  type :: tao_ele_shape_struct_container_alloc
    type(tao_ele_shape_struct), allocatable :: data(:)
  end type tao_ele_shape_struct_container_alloc

  type :: tao_ele_pointer_struct_container_alloc
    type(tao_ele_pointer_struct), allocatable :: data(:)
  end type tao_ele_pointer_struct_container_alloc

  type :: tao_curve_struct_container_alloc
    type(tao_curve_struct), allocatable :: data(:)
  end type tao_curve_struct_container_alloc

  type :: tao_curve_color_struct_container_alloc
    type(tao_curve_color_struct), allocatable :: data(:)
  end type tao_curve_color_struct_container_alloc

  type :: tao_curve_orbit_struct_container_alloc
    type(tao_curve_orbit_struct), allocatable :: data(:)
  end type tao_curve_orbit_struct_container_alloc

  type :: tao_histogram_struct_container_alloc
    type(tao_histogram_struct), allocatable :: data(:)
  end type tao_histogram_struct_container_alloc

  type :: lat_ele_order1_struct_container_alloc
    type(lat_ele_order1_struct), allocatable :: data(:)
  end type lat_ele_order1_struct_container_alloc

  type :: lat_ele_order_array_struct_container_alloc
    type(lat_ele_order_array_struct), allocatable :: data(:)
  end type lat_ele_order_array_struct_container_alloc

  type :: tao_lat_sigma_struct_container_alloc
    type(tao_lat_sigma_struct), allocatable :: data(:)
  end type tao_lat_sigma_struct_container_alloc

  type :: tao_spin_ele_struct_container_alloc
    type(tao_spin_ele_struct), allocatable :: data(:)
  end type tao_spin_ele_struct_container_alloc

  type :: tao_plot_cache_struct_container_alloc
    type(tao_plot_cache_struct), allocatable :: data(:)
  end type tao_plot_cache_struct_container_alloc

  type :: tao_spin_polarization_struct_container_alloc
    type(tao_spin_polarization_struct), allocatable :: data(:)
  end type tao_spin_polarization_struct_container_alloc

  type :: tao_lattice_branch_struct_container_alloc
    type(tao_lattice_branch_struct), allocatable :: data(:)
  end type tao_lattice_branch_struct_container_alloc

  type :: tao_model_element_struct_container_alloc
    type(tao_model_element_struct), allocatable :: data(:)
  end type tao_model_element_struct_container_alloc

  type :: tao_beam_branch_struct_container_alloc
    type(tao_beam_branch_struct), allocatable :: data(:)
  end type tao_beam_branch_struct_container_alloc

  type :: tao_d1_data_struct_container_alloc
    type(tao_d1_data_struct), allocatable :: data(:)
  end type tao_d1_data_struct_container_alloc

  type :: tao_d2_data_struct_container_alloc
    type(tao_d2_data_struct), allocatable :: data(:)
  end type tao_d2_data_struct_container_alloc

  type :: tao_data_var_component_struct_container_alloc
    type(tao_data_var_component_struct), allocatable :: data(:)
  end type tao_data_var_component_struct_container_alloc

  type :: tao_graph_struct_container_alloc
    type(tao_graph_struct), allocatable :: data(:)
  end type tao_graph_struct_container_alloc

  type :: tao_plot_struct_container_alloc
    type(tao_plot_struct), allocatable :: data(:)
  end type tao_plot_struct_container_alloc

  type :: tao_plot_region_struct_container_alloc
    type(tao_plot_region_struct), allocatable :: data(:)
  end type tao_plot_region_struct_container_alloc

  type :: tao_universe_pointer_struct_container_alloc
    type(tao_universe_pointer_struct), allocatable :: data(:)
  end type tao_universe_pointer_struct_container_alloc

  type :: tao_super_universe_struct_container_alloc
    type(tao_super_universe_struct), allocatable :: data(:)
  end type tao_super_universe_struct_container_alloc

  type :: tao_var_struct_container_alloc
    type(tao_var_struct), allocatable :: data(:)
  end type tao_var_struct_container_alloc

  type :: tao_var_slave_struct_container_alloc
    type(tao_var_slave_struct), allocatable :: data(:)
  end type tao_var_slave_struct_container_alloc

  type :: tao_lattice_struct_container_alloc
    type(tao_lattice_struct), allocatable :: data(:)
  end type tao_lattice_struct_container_alloc

  type :: tao_beam_uni_struct_container_alloc
    type(tao_beam_uni_struct), allocatable :: data(:)
  end type tao_beam_uni_struct_container_alloc

  type :: tao_dynamic_aperture_struct_container_alloc
    type(tao_dynamic_aperture_struct), allocatable :: data(:)
  end type tao_dynamic_aperture_struct_container_alloc

  type :: tao_model_branch_struct_container_alloc
    type(tao_model_branch_struct), allocatable :: data(:)
  end type tao_model_branch_struct_container_alloc

  type :: tao_spin_map_struct_container_alloc
    type(tao_spin_map_struct), allocatable :: data(:)
  end type tao_spin_map_struct_container_alloc

  type :: tao_data_struct_container_alloc
    type(tao_data_struct), allocatable :: data(:)
  end type tao_data_struct_container_alloc

  type :: tao_ping_scale_struct_container_alloc
    type(tao_ping_scale_struct), allocatable :: data(:)
  end type tao_ping_scale_struct_container_alloc

  type :: tao_universe_calc_struct_container_alloc
    type(tao_universe_calc_struct), allocatable :: data(:)
  end type tao_universe_calc_struct_container_alloc

  type :: lat_ele_order_struct_container_alloc
    type(lat_ele_order_struct), allocatable :: data(:)
  end type lat_ele_order_struct_container_alloc

  type :: tao_title_struct_container_alloc
    type(tao_title_struct), allocatable :: data(:)
  end type tao_title_struct_container_alloc

  type :: qp_rect_struct_container_alloc
    type(qp_rect_struct), allocatable :: data(:)
  end type qp_rect_struct_container_alloc

  type :: tao_drawing_struct_container_alloc
    type(tao_drawing_struct), allocatable :: data(:)
  end type tao_drawing_struct_container_alloc

  type :: tao_shape_pattern_struct_container_alloc
    type(tao_shape_pattern_struct), allocatable :: data(:)
  end type tao_shape_pattern_struct_container_alloc

  type :: tao_shape_pattern_point_struct_container_alloc
    type(tao_shape_pattern_point_struct), allocatable :: data(:)
  end type tao_shape_pattern_point_struct_container_alloc

  type :: qp_axis_struct_container_alloc
    type(qp_axis_struct), allocatable :: data(:)
  end type qp_axis_struct_container_alloc

  type :: qp_legend_struct_container_alloc
    type(qp_legend_struct), allocatable :: data(:)
  end type qp_legend_struct_container_alloc

  type :: qp_point_struct_container_alloc
    type(qp_point_struct), allocatable :: data(:)
  end type qp_point_struct_container_alloc

  type :: qp_line_struct_container_alloc
    type(qp_line_struct), allocatable :: data(:)
  end type qp_line_struct_container_alloc

  type :: qp_symbol_struct_container_alloc
    type(qp_symbol_struct), allocatable :: data(:)
  end type qp_symbol_struct_container_alloc

  type :: tao_floor_plan_struct_container_alloc
    type(tao_floor_plan_struct), allocatable :: data(:)
  end type tao_floor_plan_struct_container_alloc

  type :: tao_v1_var_struct_container_alloc
    type(tao_v1_var_struct), allocatable :: data(:)
  end type tao_v1_var_struct_container_alloc

  type :: tao_global_struct_container_alloc
    type(tao_global_struct), allocatable :: data(:)
  end type tao_global_struct_container_alloc

  type :: tao_init_struct_container_alloc
    type(tao_init_struct), allocatable :: data(:)
  end type tao_init_struct_container_alloc

  type :: tao_common_struct_container_alloc
    type(tao_common_struct), allocatable :: data(:)
  end type tao_common_struct_container_alloc

  type :: tao_plot_page_struct_container_alloc
    type(tao_plot_page_struct), allocatable :: data(:)
  end type tao_plot_page_struct_container_alloc

  type :: tao_building_wall_struct_container_alloc
    type(tao_building_wall_struct), allocatable :: data(:)
  end type tao_building_wall_struct_container_alloc

  type :: tao_building_wall_orientation_struct_container_alloc
    type(tao_building_wall_orientation_struct), allocatable :: data(:)
  end type tao_building_wall_orientation_struct_container_alloc

  type :: tao_building_wall_section_struct_container_alloc
    type(tao_building_wall_section_struct), allocatable :: data(:)
  end type tao_building_wall_section_struct_container_alloc

  type :: tao_building_wall_point_struct_container_alloc
    type(tao_building_wall_point_struct), allocatable :: data(:)
  end type tao_building_wall_point_struct_container_alloc

  type :: tao_wave_struct_container_alloc
    type(tao_wave_struct), allocatable :: data(:)
  end type tao_wave_struct_container_alloc

  type :: tao_wave_kick_pt_struct_container_alloc
    type(tao_wave_kick_pt_struct), allocatable :: data(:)
  end type tao_wave_kick_pt_struct_container_alloc

  type :: tao_cmd_history_struct_container_alloc
    type(tao_cmd_history_struct), allocatable :: data(:)
  end type tao_cmd_history_struct_container_alloc

  type :: tao_universe_struct_container_alloc
    type(tao_universe_struct), allocatable :: data(:)
  end type tao_universe_struct_container_alloc

  type :: mad_energy_struct_container_alloc
    type(mad_energy_struct), allocatable :: data(:)
  end type mad_energy_struct_container_alloc

  type :: mad_map_struct_container_alloc
    type(mad_map_struct), allocatable :: data(:)
  end type mad_map_struct_container_alloc

  type :: random_state_struct_container_alloc
    type(random_state_struct), allocatable :: data(:)
  end type random_state_struct_container_alloc

  type :: bbu_stage_struct_container_alloc
    type(bbu_stage_struct), allocatable :: data(:)
  end type bbu_stage_struct_container_alloc

  type :: bbu_beam_struct_container_alloc
    type(bbu_beam_struct), allocatable :: data(:)
  end type bbu_beam_struct_container_alloc

  type :: bbu_param_struct_container_alloc
    type(bbu_param_struct), allocatable :: data(:)
  end type bbu_param_struct_container_alloc

  type :: all_encompassing_struct_container_alloc
    type(all_encompassing_struct), allocatable :: data(:)
  end type all_encompassing_struct_container_alloc

  type :: test_sub_struct_container_alloc
    type(test_sub_struct), allocatable :: data(:)
  end type test_sub_struct_container_alloc

  type :: test_sub_sub_struct_container_alloc
    type(test_sub_sub_struct), allocatable :: data(:)
  end type test_sub_sub_struct_container_alloc

  type :: real_container_alloc
    real(rp), allocatable :: data(:)
  end type real_container_alloc

  type :: real16_container_alloc
    real(qp), allocatable :: data(:)
  end type real16_container_alloc

  type :: integer_container_alloc
    integer, allocatable :: data(:)
  end type integer_container_alloc

  type :: integer8_container_alloc
    integer(8), allocatable :: data(:)
  end type integer8_container_alloc

  type :: logical_container_alloc
    logical, allocatable :: data(:)
  end type logical_container_alloc

  type :: complex_container_alloc
    complex(rp), allocatable :: data(:)
  end type complex_container_alloc

contains


  function allocate_real_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(real_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_real_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(real_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_real_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(real_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_real_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(real_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
            

  function allocate_real16_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(real16_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_real16_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(real16_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_real16_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(real16_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_real16_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(real16_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
            

  function allocate_integer_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(integer_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_integer_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(integer_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_integer_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(integer_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_integer_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(integer_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
            

  function allocate_integer8_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(integer8_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_integer8_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(integer8_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_integer8_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(integer8_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_integer8_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(integer8_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
            

  function allocate_logical_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(logical_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_logical_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(logical_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_logical_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(logical_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_logical_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(logical_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
            

  function allocate_complex_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(complex_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_complex_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(complex_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_complex_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(complex_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_complex_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(complex_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
            
  !! spline_struct

    function allocate_fortran_spline_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(spline_struct), pointer :: fptr
      type(spline_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_spline_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(spline_struct), pointer :: fptr
      type(spline_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_spline_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spline_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_spline_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(spline_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_spline_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(spline_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_spline_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(spline_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_spline_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(spline_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! spline_struct%x0: 0D_NOT_real

  subroutine spline_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='spline_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine spline_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='spline_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! spline_struct%y0: 0D_NOT_real

  subroutine spline_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='spline_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine spline_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='spline_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! spline_struct%x1: 0D_NOT_real

  subroutine spline_struct_get_x1(struct_obj_ptr, value_out) bind(c, name='spline_struct_get_x1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x1
  end subroutine


  subroutine spline_struct_set_x1(struct_obj_ptr, value_in) bind(c, name='spline_struct_set_x1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x1 = value_in
  end subroutine

  ! spline_struct%coef: 1D_NOT_real

  subroutine spline_struct_get_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spline_struct_get_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spline_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%coef)) then
      data_ptr = c_loc(struct_obj%coef(lbound(struct_obj%coef, 1)))
      bounds(1) = int(lbound(struct_obj%coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! spin_polar_struct

    function allocate_fortran_spin_polar_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(spin_polar_struct), pointer :: fptr
      type(spin_polar_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_spin_polar_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(spin_polar_struct), pointer :: fptr
      type(spin_polar_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_spin_polar_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spin_polar_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_spin_polar_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(spin_polar_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_spin_polar_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(spin_polar_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_spin_polar_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(spin_polar_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_spin_polar_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(spin_polar_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! spin_polar_struct%polarization: 0D_NOT_real

  subroutine spin_polar_struct_get_polarization(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%polarization
  end subroutine


  subroutine spin_polar_struct_set_polarization(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%polarization = value_in
  end subroutine

  ! spin_polar_struct%theta: 0D_NOT_real

  subroutine spin_polar_struct_get_theta(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta
  end subroutine


  subroutine spin_polar_struct_set_theta(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta = value_in
  end subroutine

  ! spin_polar_struct%phi: 0D_NOT_real

  subroutine spin_polar_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine spin_polar_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! spin_polar_struct%xi: 0D_NOT_real

  subroutine spin_polar_struct_get_xi(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_xi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%xi
  end subroutine


  subroutine spin_polar_struct_set_xi(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_xi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%xi = value_in
  end subroutine

  !! ac_kicker_time_struct

    function allocate_fortran_ac_kicker_time_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ac_kicker_time_struct), pointer :: fptr
      type(ac_kicker_time_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ac_kicker_time_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ac_kicker_time_struct), pointer :: fptr
      type(ac_kicker_time_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ac_kicker_time_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ac_kicker_time_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ac_kicker_time_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ac_kicker_time_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ac_kicker_time_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ac_kicker_time_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ac_kicker_time_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ac_kicker_time_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ac_kicker_time_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ac_kicker_time_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ac_kicker_time_struct%amp: 0D_NOT_real

  subroutine ac_kicker_time_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='ac_kicker_time_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine ac_kicker_time_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='ac_kicker_time_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! ac_kicker_time_struct%time: 0D_NOT_real

  subroutine ac_kicker_time_struct_get_time(struct_obj_ptr, value_out) bind(c, name='ac_kicker_time_struct_get_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time
  end subroutine


  subroutine ac_kicker_time_struct_set_time(struct_obj_ptr, value_in) bind(c, name='ac_kicker_time_struct_set_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time = value_in
  end subroutine

  ! ac_kicker_time_struct%spline: 0D_NOT_type

  subroutine ac_kicker_time_struct_get_spline(struct_obj_ptr, ptr_out) bind(c, name='ac_kicker_time_struct_get_spline')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spline)
  end subroutine


  subroutine ac_kicker_time_struct_set_spline(struct_obj_ptr, src_ptr) bind(c, name='ac_kicker_time_struct_set_spline')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ac_kicker_time_struct), pointer :: struct_obj
    type(spline_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spline = src_obj
  end subroutine

  !! ac_kicker_freq_struct

    function allocate_fortran_ac_kicker_freq_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ac_kicker_freq_struct), pointer :: fptr
      type(ac_kicker_freq_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ac_kicker_freq_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ac_kicker_freq_struct), pointer :: fptr
      type(ac_kicker_freq_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ac_kicker_freq_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ac_kicker_freq_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ac_kicker_freq_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ac_kicker_freq_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ac_kicker_freq_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ac_kicker_freq_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ac_kicker_freq_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ac_kicker_freq_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ac_kicker_freq_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ac_kicker_freq_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ac_kicker_freq_struct%f: 0D_NOT_real

  subroutine ac_kicker_freq_struct_get_f(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_f')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f
  end subroutine


  subroutine ac_kicker_freq_struct_set_f(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_f')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f = value_in
  end subroutine

  ! ac_kicker_freq_struct%amp: 0D_NOT_real

  subroutine ac_kicker_freq_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine ac_kicker_freq_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! ac_kicker_freq_struct%phi: 0D_NOT_real

  subroutine ac_kicker_freq_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine ac_kicker_freq_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  !! ac_kicker_struct

    function allocate_fortran_ac_kicker_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ac_kicker_struct), pointer :: fptr
      type(ac_kicker_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ac_kicker_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ac_kicker_struct), pointer :: fptr
      type(ac_kicker_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ac_kicker_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ac_kicker_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ac_kicker_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ac_kicker_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ac_kicker_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ac_kicker_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ac_kicker_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ac_kicker_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ac_kicker_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ac_kicker_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ac_kicker_struct%amp_vs_time: 1D_ALLOC_type

  subroutine ac_kicker_struct_get_amp_vs_time_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ac_kicker_struct_get_amp_vs_time_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ac_kicker_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%amp_vs_time) .and. is_contiguous(struct_obj%amp_vs_time)) then
      data_ptr = c_loc(struct_obj%amp_vs_time(lbound(struct_obj%amp_vs_time, 1)))
      bounds(1) = int(lbound(struct_obj%amp_vs_time, 1), c_int)
      bounds(2) = int(ubound(struct_obj%amp_vs_time, 1), c_int)
      
      el_size = int(storage_size(struct_obj%amp_vs_time(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ac_kicker_struct%frequency: 1D_ALLOC_type

  subroutine ac_kicker_struct_get_frequency_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ac_kicker_struct_get_frequency_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ac_kicker_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%frequency) .and. is_contiguous(struct_obj%frequency)) then
      data_ptr = c_loc(struct_obj%frequency(lbound(struct_obj%frequency, 1)))
      bounds(1) = int(lbound(struct_obj%frequency, 1), c_int)
      bounds(2) = int(ubound(struct_obj%frequency, 1), c_int)
      
      el_size = int(storage_size(struct_obj%frequency(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! interval1_coef_struct

    function allocate_fortran_interval1_coef_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(interval1_coef_struct), pointer :: fptr
      type(interval1_coef_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_interval1_coef_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(interval1_coef_struct), pointer :: fptr
      type(interval1_coef_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_interval1_coef_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(interval1_coef_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_interval1_coef_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(interval1_coef_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_interval1_coef_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(interval1_coef_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_interval1_coef_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(interval1_coef_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_interval1_coef_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(interval1_coef_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! interval1_coef_struct%c0: 0D_NOT_real

  subroutine interval1_coef_struct_get_c0(struct_obj_ptr, value_out) bind(c, name='interval1_coef_struct_get_c0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%c0
  end subroutine


  subroutine interval1_coef_struct_set_c0(struct_obj_ptr, value_in) bind(c, name='interval1_coef_struct_set_c0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%c0 = value_in
  end subroutine

  ! interval1_coef_struct%c1: 0D_NOT_real

  subroutine interval1_coef_struct_get_c1(struct_obj_ptr, value_out) bind(c, name='interval1_coef_struct_get_c1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%c1
  end subroutine


  subroutine interval1_coef_struct_set_c1(struct_obj_ptr, value_in) bind(c, name='interval1_coef_struct_set_c1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%c1 = value_in
  end subroutine

  ! interval1_coef_struct%n_exp: 0D_NOT_real

  subroutine interval1_coef_struct_get_n_exp(struct_obj_ptr, value_out) bind(c, name='interval1_coef_struct_get_n_exp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_exp
  end subroutine


  subroutine interval1_coef_struct_set_n_exp(struct_obj_ptr, value_in) bind(c, name='interval1_coef_struct_set_n_exp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_exp = value_in
  end subroutine

  !! photon_reflect_table_struct

    function allocate_fortran_photon_reflect_table_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(photon_reflect_table_struct), pointer :: fptr
      type(photon_reflect_table_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_photon_reflect_table_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(photon_reflect_table_struct), pointer :: fptr
      type(photon_reflect_table_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_photon_reflect_table_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_reflect_table_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_photon_reflect_table_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(photon_reflect_table_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_photon_reflect_table_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(photon_reflect_table_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_photon_reflect_table_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(photon_reflect_table_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_photon_reflect_table_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(photon_reflect_table_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! photon_reflect_table_struct%angle: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_angle_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_angle_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%angle) .and. is_contiguous(struct_obj%angle)) then
      data_ptr = c_loc(struct_obj%angle(lbound(struct_obj%angle, 1)))
      bounds(1) = int(lbound(struct_obj%angle, 1), c_int)
      bounds(2) = int(ubound(struct_obj%angle, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%energy: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_energy_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_energy_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%energy) .and. is_contiguous(struct_obj%energy)) then
      data_ptr = c_loc(struct_obj%energy(lbound(struct_obj%energy, 1)))
      bounds(1) = int(lbound(struct_obj%energy, 1), c_int)
      bounds(2) = int(ubound(struct_obj%energy, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%int1: 1D_ALLOC_type

  subroutine photon_reflect_table_struct_get_int1_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_reflect_table_struct_get_int1_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%int1) .and. is_contiguous(struct_obj%int1)) then
      data_ptr = c_loc(struct_obj%int1(lbound(struct_obj%int1, 1)))
      bounds(1) = int(lbound(struct_obj%int1, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int1, 1), c_int)
      
      el_size = int(storage_size(struct_obj%int1(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%p_reflect: 2D_ALLOC_real

  subroutine photon_reflect_table_struct_get_p_reflect_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_p_reflect_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%p_reflect) .and. is_contiguous(struct_obj%p_reflect)) then
      data_ptr = c_loc(struct_obj%p_reflect(lbound(struct_obj%p_reflect, 1), lbound(struct_obj%p_reflect, 2)))
      bounds(1) = int(lbound(struct_obj%p_reflect, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p_reflect, 1), c_int)
      bounds(3) = int(lbound(struct_obj%p_reflect, 2), c_int)
      bounds(4) = int(ubound(struct_obj%p_reflect, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%max_energy: 0D_NOT_real

  subroutine photon_reflect_table_struct_get_max_energy(struct_obj_ptr, value_out) bind(c, name='photon_reflect_table_struct_get_max_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(photon_reflect_table_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_energy
  end subroutine


  subroutine photon_reflect_table_struct_set_max_energy(struct_obj_ptr, value_in) bind(c, name='photon_reflect_table_struct_set_max_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(photon_reflect_table_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_energy = value_in
  end subroutine

  ! photon_reflect_table_struct%p_reflect_scratch: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_p_reflect_scratch_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_p_reflect_scratch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%p_reflect_scratch) .and. is_contiguous(struct_obj%p_reflect_scratch)) then
      data_ptr = c_loc(struct_obj%p_reflect_scratch(lbound(struct_obj%p_reflect_scratch, 1)))
      bounds(1) = int(lbound(struct_obj%p_reflect_scratch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p_reflect_scratch, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%bragg_angle: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_bragg_angle_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_bragg_angle_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%bragg_angle) .and. is_contiguous(struct_obj%bragg_angle)) then
      data_ptr = c_loc(struct_obj%bragg_angle(lbound(struct_obj%bragg_angle, 1)))
      bounds(1) = int(lbound(struct_obj%bragg_angle, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bragg_angle, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! photon_reflect_surface_struct

    function allocate_fortran_photon_reflect_surface_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(photon_reflect_surface_struct), pointer :: fptr
      type(photon_reflect_surface_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_photon_reflect_surface_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(photon_reflect_surface_struct), pointer :: fptr
      type(photon_reflect_surface_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_photon_reflect_surface_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_reflect_surface_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_photon_reflect_surface_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(photon_reflect_surface_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_photon_reflect_surface_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(photon_reflect_surface_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_photon_reflect_surface_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(photon_reflect_surface_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_photon_reflect_surface_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(photon_reflect_surface_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! photon_reflect_surface_struct%name: 0D_NOT_character

  subroutine photon_reflect_surface_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='photon_reflect_surface_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine photon_reflect_surface_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='photon_reflect_surface_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(photon_reflect_surface_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! photon_reflect_surface_struct%description: 0D_NOT_character

  subroutine photon_reflect_surface_struct_get_description_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='photon_reflect_surface_struct_get_description_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%description)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%description), c_int)
    is_allocated = .true.
  end subroutine


  subroutine photon_reflect_surface_struct_set_description(struct_obj_ptr, str_ptr, str_len) bind(c, name='photon_reflect_surface_struct_set_description')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(photon_reflect_surface_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%description = str_in ! implicitly handles padding
  end subroutine

  ! photon_reflect_surface_struct%reflectivity_file: 0D_NOT_character

  subroutine photon_reflect_surface_struct_get_reflectivity_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='photon_reflect_surface_struct_get_reflectivity_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%reflectivity_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%reflectivity_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine photon_reflect_surface_struct_set_reflectivity_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='photon_reflect_surface_struct_set_reflectivity_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(photon_reflect_surface_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%reflectivity_file = str_in ! implicitly handles padding
  end subroutine

  ! photon_reflect_surface_struct%table: 1D_ALLOC_type

  subroutine photon_reflect_surface_struct_get_table_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_reflect_surface_struct_get_table_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%table) .and. is_contiguous(struct_obj%table)) then
      data_ptr = c_loc(struct_obj%table(lbound(struct_obj%table, 1)))
      bounds(1) = int(lbound(struct_obj%table, 1), c_int)
      bounds(2) = int(ubound(struct_obj%table, 1), c_int)
      
      el_size = int(storage_size(struct_obj%table(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_surface_struct%surface_roughness_rms: 0D_NOT_real

  subroutine photon_reflect_surface_struct_get_surface_roughness_rms(struct_obj_ptr, value_out) bind(c, name='photon_reflect_surface_struct_get_surface_roughness_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%surface_roughness_rms
  end subroutine


  subroutine photon_reflect_surface_struct_set_surface_roughness_rms(struct_obj_ptr, value_in) bind(c, name='photon_reflect_surface_struct_set_surface_roughness_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%surface_roughness_rms = value_in
  end subroutine

  ! photon_reflect_surface_struct%roughness_correlation_len: 0D_NOT_real

  subroutine photon_reflect_surface_struct_get_roughness_correlation_len(struct_obj_ptr, value_out) bind(c, name='photon_reflect_surface_struct_get_roughness_correlation_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%roughness_correlation_len
  end subroutine


  subroutine photon_reflect_surface_struct_set_roughness_correlation_len(struct_obj_ptr, value_in) bind(c, name='photon_reflect_surface_struct_set_roughness_correlation_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%roughness_correlation_len = value_in
  end subroutine

  ! photon_reflect_surface_struct%ix_surface: 0D_NOT_integer

  subroutine photon_reflect_surface_struct_get_ix_surface(struct_obj_ptr, value_out) bind(c, name='photon_reflect_surface_struct_get_ix_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_surface
  end subroutine


  subroutine photon_reflect_surface_struct_set_ix_surface(struct_obj_ptr, value_in) bind(c, name='photon_reflect_surface_struct_set_ix_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_surface = value_in
  end subroutine

  !! coord_struct

    function allocate_fortran_coord_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(coord_struct), pointer :: fptr
      type(coord_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_coord_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(coord_struct), pointer :: fptr
      type(coord_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_coord_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(coord_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_coord_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(coord_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_coord_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(coord_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_coord_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(coord_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_coord_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(coord_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! coord_struct%vec: 1D_NOT_real

  subroutine coord_struct_get_vec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%vec)) then
      data_ptr = c_loc(struct_obj%vec(lbound(struct_obj%vec, 1)))
      bounds(1) = int(lbound(struct_obj%vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%s: 0D_NOT_real

  subroutine coord_struct_get_s(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine coord_struct_set_s(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! coord_struct%t: 0D_NOT_real16

  subroutine coord_struct_get_t(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_long_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t
  end subroutine


  subroutine coord_struct_set_t(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_long_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t = value_in
  end subroutine

  ! coord_struct%spin: 1D_NOT_real

  subroutine coord_struct_get_spin_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_spin_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin)) then
      data_ptr = c_loc(struct_obj%spin(lbound(struct_obj%spin, 1)))
      bounds(1) = int(lbound(struct_obj%spin, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%field: 1D_NOT_real

  subroutine coord_struct_get_field_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_field_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%field)) then
      data_ptr = c_loc(struct_obj%field(lbound(struct_obj%field, 1)))
      bounds(1) = int(lbound(struct_obj%field, 1), c_int)
      bounds(2) = int(ubound(struct_obj%field, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%phase: 1D_NOT_real

  subroutine coord_struct_get_phase_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_phase_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%phase)) then
      data_ptr = c_loc(struct_obj%phase(lbound(struct_obj%phase, 1)))
      bounds(1) = int(lbound(struct_obj%phase, 1), c_int)
      bounds(2) = int(ubound(struct_obj%phase, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%charge: 0D_NOT_real

  subroutine coord_struct_get_charge(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge
  end subroutine


  subroutine coord_struct_set_charge(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge = value_in
  end subroutine

  ! coord_struct%dt_ref: 0D_NOT_real

  subroutine coord_struct_get_dt_ref(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_dt_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dt_ref
  end subroutine


  subroutine coord_struct_set_dt_ref(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_dt_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dt_ref = value_in
  end subroutine

  ! coord_struct%r: 0D_NOT_real

  subroutine coord_struct_get_r(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%r
  end subroutine


  subroutine coord_struct_set_r(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%r = value_in
  end subroutine

  ! coord_struct%p0c: 0D_NOT_real

  subroutine coord_struct_get_p0c(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p0c
  end subroutine


  subroutine coord_struct_set_p0c(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p0c = value_in
  end subroutine

  ! coord_struct%E_potential: 0D_NOT_real

  subroutine coord_struct_get_E_potential(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_E_potential')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_potential
  end subroutine


  subroutine coord_struct_set_E_potential(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_E_potential')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_potential = value_in
  end subroutine

  ! coord_struct%beta: 0D_NOT_real

  subroutine coord_struct_get_beta(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beta
  end subroutine


  subroutine coord_struct_set_beta(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beta = value_in
  end subroutine

  ! coord_struct%ix_ele: 0D_NOT_integer

  subroutine coord_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine coord_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! coord_struct%ix_branch: 0D_NOT_integer

  subroutine coord_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine coord_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! coord_struct%ix_turn: 0D_NOT_integer

  subroutine coord_struct_get_ix_turn(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_turn
  end subroutine


  subroutine coord_struct_set_ix_turn(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_turn = value_in
  end subroutine

  ! coord_struct%ix_user: 0D_NOT_integer

  subroutine coord_struct_get_ix_user(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_user
  end subroutine


  subroutine coord_struct_set_ix_user(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_user = value_in
  end subroutine

  ! coord_struct%state: 0D_NOT_integer

  subroutine coord_struct_get_state(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%state
  end subroutine


  subroutine coord_struct_set_state(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%state = value_in
  end subroutine

  ! coord_struct%direction: 0D_NOT_integer

  subroutine coord_struct_get_direction(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_direction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%direction
  end subroutine


  subroutine coord_struct_set_direction(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_direction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%direction = value_in
  end subroutine

  ! coord_struct%time_dir: 0D_NOT_integer

  subroutine coord_struct_get_time_dir(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_time_dir')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_dir
  end subroutine


  subroutine coord_struct_set_time_dir(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_time_dir')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_dir = value_in
  end subroutine

  ! coord_struct%species: 0D_NOT_integer

  subroutine coord_struct_get_species(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%species
  end subroutine


  subroutine coord_struct_set_species(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%species = value_in
  end subroutine

  ! coord_struct%location: 0D_NOT_integer

  subroutine coord_struct_get_location(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%location
  end subroutine


  subroutine coord_struct_set_location(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%location = value_in
  end subroutine

  !! coord_array_struct

    function allocate_fortran_coord_array_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(coord_array_struct), pointer :: fptr
      type(coord_array_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_coord_array_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(coord_array_struct), pointer :: fptr
      type(coord_array_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_coord_array_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(coord_array_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_coord_array_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(coord_array_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_coord_array_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(coord_array_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_coord_array_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(coord_array_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_coord_array_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(coord_array_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! coord_array_struct%orbit: 1D_ALLOC_type

  subroutine coord_array_struct_get_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='coord_array_struct_get_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_array_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%orbit) .and. is_contiguous(struct_obj%orbit)) then
      data_ptr = c_loc(struct_obj%orbit(lbound(struct_obj%orbit, 1)))
      bounds(1) = int(lbound(struct_obj%orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit, 1), c_int)
      
      el_size = int(storage_size(struct_obj%orbit(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! bpm_phase_coupling_struct

    function allocate_fortran_bpm_phase_coupling_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bpm_phase_coupling_struct), pointer :: fptr
      type(bpm_phase_coupling_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bpm_phase_coupling_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bpm_phase_coupling_struct), pointer :: fptr
      type(bpm_phase_coupling_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bpm_phase_coupling_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bpm_phase_coupling_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bpm_phase_coupling_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bpm_phase_coupling_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bpm_phase_coupling_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bpm_phase_coupling_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bpm_phase_coupling_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bpm_phase_coupling_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bpm_phase_coupling_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bpm_phase_coupling_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bpm_phase_coupling_struct%K_22a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_22a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_22a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_22a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_22a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_22a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_22a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%K_12a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_12a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_12a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_12a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_12a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_12a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_12a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%K_11b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_11b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_11b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_11b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_11b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_11b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_11b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%K_12b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_12b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_12b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_12b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_12b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_12b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_12b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar22_a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar22_a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar22_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar22_a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar22_a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar22_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar22_a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar12_a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar12_a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar12_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar12_a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar12_a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar12_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar12_a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar11_b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar11_b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar11_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar11_b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar11_b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar11_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar11_b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar12_b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar12_b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar12_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar12_b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar12_b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar12_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar12_b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%phi_a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_phi_a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_phi_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_phi_a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_phi_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%phi_b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_phi_b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_phi_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_phi_b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_phi_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_b = value_in
  end subroutine

  !! expression_atom_struct

    function allocate_fortran_expression_atom_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(expression_atom_struct), pointer :: fptr
      type(expression_atom_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_expression_atom_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(expression_atom_struct), pointer :: fptr
      type(expression_atom_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_expression_atom_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(expression_atom_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_expression_atom_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(expression_atom_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_expression_atom_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(expression_atom_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_expression_atom_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(expression_atom_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_expression_atom_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(expression_atom_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! expression_atom_struct%name: 0D_NOT_character

  subroutine expression_atom_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='expression_atom_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine expression_atom_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='expression_atom_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(expression_atom_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! expression_atom_struct%type: 0D_NOT_integer

  subroutine expression_atom_struct_get_type(struct_obj_ptr, value_out) bind(c, name='expression_atom_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine expression_atom_struct_set_type(struct_obj_ptr, value_in) bind(c, name='expression_atom_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! expression_atom_struct%value: 0D_NOT_real

  subroutine expression_atom_struct_get_value(struct_obj_ptr, value_out) bind(c, name='expression_atom_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine expression_atom_struct_set_value(struct_obj_ptr, value_in) bind(c, name='expression_atom_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  !! wake_sr_z_long_struct

    function allocate_fortran_wake_sr_z_long_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wake_sr_z_long_struct), pointer :: fptr
      type(wake_sr_z_long_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wake_sr_z_long_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wake_sr_z_long_struct), pointer :: fptr
      type(wake_sr_z_long_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wake_sr_z_long_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_sr_z_long_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wake_sr_z_long_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wake_sr_z_long_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wake_sr_z_long_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wake_sr_z_long_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wake_sr_z_long_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wake_sr_z_long_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wake_sr_z_long_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wake_sr_z_long_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wake_sr_z_long_struct%w: 1D_ALLOC_real

  subroutine wake_sr_z_long_struct_get_w_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_w_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%w) .and. is_contiguous(struct_obj%w)) then
      data_ptr = c_loc(struct_obj%w(lbound(struct_obj%w, 1)))
      bounds(1) = int(lbound(struct_obj%w, 1), c_int)
      bounds(2) = int(ubound(struct_obj%w, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%fw: 1D_ALLOC_complex

  subroutine wake_sr_z_long_struct_get_fw_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_fw_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%fw) .and. is_contiguous(struct_obj%fw)) then
      data_ptr = c_loc(struct_obj%fw(lbound(struct_obj%fw, 1)))
      bounds(1) = int(lbound(struct_obj%fw, 1), c_int)
      bounds(2) = int(ubound(struct_obj%fw, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%fbunch: 1D_ALLOC_complex

  subroutine wake_sr_z_long_struct_get_fbunch_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_fbunch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%fbunch) .and. is_contiguous(struct_obj%fbunch)) then
      data_ptr = c_loc(struct_obj%fbunch(lbound(struct_obj%fbunch, 1)))
      bounds(1) = int(lbound(struct_obj%fbunch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%fbunch, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%w_out: 1D_ALLOC_complex

  subroutine wake_sr_z_long_struct_get_w_out_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_w_out_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%w_out) .and. is_contiguous(struct_obj%w_out)) then
      data_ptr = c_loc(struct_obj%w_out(lbound(struct_obj%w_out, 1)))
      bounds(1) = int(lbound(struct_obj%w_out, 1), c_int)
      bounds(2) = int(ubound(struct_obj%w_out, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%dz: 0D_NOT_real

  subroutine wake_sr_z_long_struct_get_dz(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz
  end subroutine


  subroutine wake_sr_z_long_struct_set_dz(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz = value_in
  end subroutine

  ! wake_sr_z_long_struct%z0: 0D_NOT_real

  subroutine wake_sr_z_long_struct_get_z0(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z0
  end subroutine


  subroutine wake_sr_z_long_struct_set_z0(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z0 = value_in
  end subroutine

  ! wake_sr_z_long_struct%smoothing_sigma: 0D_NOT_real

  subroutine wake_sr_z_long_struct_get_smoothing_sigma(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_smoothing_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%smoothing_sigma
  end subroutine


  subroutine wake_sr_z_long_struct_set_smoothing_sigma(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_smoothing_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%smoothing_sigma = value_in
  end subroutine

  ! wake_sr_z_long_struct%position_dependence: 0D_NOT_integer

  subroutine wake_sr_z_long_struct_get_position_dependence(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%position_dependence
  end subroutine


  subroutine wake_sr_z_long_struct_set_position_dependence(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%position_dependence = value_in
  end subroutine

  ! wake_sr_z_long_struct%time_based: 0D_NOT_logical

  subroutine wake_sr_z_long_struct_get_time_based(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_time_based')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_based
  end subroutine


  subroutine wake_sr_z_long_struct_set_time_based(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_time_based')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_based = value_in
  end subroutine

  !! wake_sr_mode_struct

    function allocate_fortran_wake_sr_mode_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wake_sr_mode_struct), pointer :: fptr
      type(wake_sr_mode_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wake_sr_mode_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wake_sr_mode_struct), pointer :: fptr
      type(wake_sr_mode_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wake_sr_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_sr_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wake_sr_mode_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wake_sr_mode_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wake_sr_mode_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wake_sr_mode_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wake_sr_mode_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wake_sr_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wake_sr_mode_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wake_sr_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wake_sr_mode_struct%amp: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine wake_sr_mode_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! wake_sr_mode_struct%damp: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_damp(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%damp
  end subroutine


  subroutine wake_sr_mode_struct_set_damp(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%damp = value_in
  end subroutine

  ! wake_sr_mode_struct%k: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_k(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_k')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%k
  end subroutine


  subroutine wake_sr_mode_struct_set_k(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_k')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%k = value_in
  end subroutine

  ! wake_sr_mode_struct%phi: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine wake_sr_mode_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! wake_sr_mode_struct%b_sin: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_b_sin(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_sin
  end subroutine


  subroutine wake_sr_mode_struct_set_b_sin(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_sin = value_in
  end subroutine

  ! wake_sr_mode_struct%b_cos: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_b_cos(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_cos
  end subroutine


  subroutine wake_sr_mode_struct_set_b_cos(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_cos = value_in
  end subroutine

  ! wake_sr_mode_struct%a_sin: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_a_sin(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_sin
  end subroutine


  subroutine wake_sr_mode_struct_set_a_sin(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_sin = value_in
  end subroutine

  ! wake_sr_mode_struct%a_cos: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_a_cos(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_cos
  end subroutine


  subroutine wake_sr_mode_struct_set_a_cos(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_cos = value_in
  end subroutine

  ! wake_sr_mode_struct%polarization: 0D_NOT_integer

  subroutine wake_sr_mode_struct_get_polarization(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%polarization
  end subroutine


  subroutine wake_sr_mode_struct_set_polarization(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%polarization = value_in
  end subroutine

  ! wake_sr_mode_struct%position_dependence: 0D_NOT_integer

  subroutine wake_sr_mode_struct_get_position_dependence(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%position_dependence
  end subroutine


  subroutine wake_sr_mode_struct_set_position_dependence(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%position_dependence = value_in
  end subroutine

  !! wake_sr_struct

    function allocate_fortran_wake_sr_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wake_sr_struct), pointer :: fptr
      type(wake_sr_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wake_sr_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wake_sr_struct), pointer :: fptr
      type(wake_sr_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wake_sr_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_sr_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wake_sr_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wake_sr_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wake_sr_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wake_sr_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wake_sr_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wake_sr_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wake_sr_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wake_sr_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wake_sr_struct%file: 0D_NOT_character

  subroutine wake_sr_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wake_sr_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wake_sr_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='wake_sr_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wake_sr_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! wake_sr_struct%z_long: 0D_NOT_type

  subroutine wake_sr_struct_get_z_long(struct_obj_ptr, ptr_out) bind(c, name='wake_sr_struct_get_z_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z_long)
  end subroutine


  subroutine wake_sr_struct_set_z_long(struct_obj_ptr, src_ptr) bind(c, name='wake_sr_struct_set_z_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wake_sr_struct), pointer :: struct_obj
    type(wake_sr_z_long_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z_long = src_obj
  end subroutine

  ! wake_sr_struct%long: 1D_ALLOC_type

  subroutine wake_sr_struct_get_long_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wake_sr_struct_get_long_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%long) .and. is_contiguous(struct_obj%long)) then
      data_ptr = c_loc(struct_obj%long(lbound(struct_obj%long, 1)))
      bounds(1) = int(lbound(struct_obj%long, 1), c_int)
      bounds(2) = int(ubound(struct_obj%long, 1), c_int)
      
      el_size = int(storage_size(struct_obj%long(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_struct%trans: 1D_ALLOC_type

  subroutine wake_sr_struct_get_trans_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wake_sr_struct_get_trans_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%trans) .and. is_contiguous(struct_obj%trans)) then
      data_ptr = c_loc(struct_obj%trans(lbound(struct_obj%trans, 1)))
      bounds(1) = int(lbound(struct_obj%trans, 1), c_int)
      bounds(2) = int(ubound(struct_obj%trans, 1), c_int)
      
      el_size = int(storage_size(struct_obj%trans(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_struct%z_ref_long: 0D_NOT_real

  subroutine wake_sr_struct_get_z_ref_long(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_ref_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_ref_long
  end subroutine


  subroutine wake_sr_struct_set_z_ref_long(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_ref_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_ref_long = value_in
  end subroutine

  ! wake_sr_struct%z_ref_trans: 0D_NOT_real

  subroutine wake_sr_struct_get_z_ref_trans(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_ref_trans')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_ref_trans
  end subroutine


  subroutine wake_sr_struct_set_z_ref_trans(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_ref_trans')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_ref_trans = value_in
  end subroutine

  ! wake_sr_struct%z_max: 0D_NOT_real

  subroutine wake_sr_struct_get_z_max(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_max
  end subroutine


  subroutine wake_sr_struct_set_z_max(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_max = value_in
  end subroutine

  ! wake_sr_struct%amp_scale: 0D_NOT_real

  subroutine wake_sr_struct_get_amp_scale(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp_scale
  end subroutine


  subroutine wake_sr_struct_set_amp_scale(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp_scale = value_in
  end subroutine

  ! wake_sr_struct%z_scale: 0D_NOT_real

  subroutine wake_sr_struct_get_z_scale(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_scale
  end subroutine


  subroutine wake_sr_struct_set_z_scale(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_scale = value_in
  end subroutine

  ! wake_sr_struct%scale_with_length: 0D_NOT_logical

  subroutine wake_sr_struct_get_scale_with_length(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_scale_with_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scale_with_length
  end subroutine


  subroutine wake_sr_struct_set_scale_with_length(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_scale_with_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scale_with_length = value_in
  end subroutine

  !! wake_lr_mode_struct

    function allocate_fortran_wake_lr_mode_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wake_lr_mode_struct), pointer :: fptr
      type(wake_lr_mode_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wake_lr_mode_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wake_lr_mode_struct), pointer :: fptr
      type(wake_lr_mode_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wake_lr_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_lr_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wake_lr_mode_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wake_lr_mode_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wake_lr_mode_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wake_lr_mode_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wake_lr_mode_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wake_lr_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wake_lr_mode_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wake_lr_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wake_lr_mode_struct%freq: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_freq(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_freq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq
  end subroutine


  subroutine wake_lr_mode_struct_set_freq(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_freq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq = value_in
  end subroutine

  ! wake_lr_mode_struct%freq_in: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_freq_in(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_freq_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq_in
  end subroutine


  subroutine wake_lr_mode_struct_set_freq_in(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_freq_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq_in = value_in
  end subroutine

  ! wake_lr_mode_struct%R_over_Q: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_R_over_Q(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_R_over_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%R_over_Q
  end subroutine


  subroutine wake_lr_mode_struct_set_R_over_Q(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_R_over_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%R_over_Q = value_in
  end subroutine

  ! wake_lr_mode_struct%Q: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_Q(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Q
  end subroutine


  subroutine wake_lr_mode_struct_set_Q(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Q = value_in
  end subroutine

  ! wake_lr_mode_struct%damp: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_damp(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%damp
  end subroutine


  subroutine wake_lr_mode_struct_set_damp(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%damp = value_in
  end subroutine

  ! wake_lr_mode_struct%phi: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine wake_lr_mode_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! wake_lr_mode_struct%angle: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_angle(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%angle
  end subroutine


  subroutine wake_lr_mode_struct_set_angle(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%angle = value_in
  end subroutine

  ! wake_lr_mode_struct%b_sin: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_b_sin(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_sin
  end subroutine


  subroutine wake_lr_mode_struct_set_b_sin(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_sin = value_in
  end subroutine

  ! wake_lr_mode_struct%b_cos: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_b_cos(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_cos
  end subroutine


  subroutine wake_lr_mode_struct_set_b_cos(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_cos = value_in
  end subroutine

  ! wake_lr_mode_struct%a_sin: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_a_sin(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_sin
  end subroutine


  subroutine wake_lr_mode_struct_set_a_sin(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_sin = value_in
  end subroutine

  ! wake_lr_mode_struct%a_cos: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_a_cos(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_cos
  end subroutine


  subroutine wake_lr_mode_struct_set_a_cos(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_cos = value_in
  end subroutine

  ! wake_lr_mode_struct%m: 0D_NOT_integer

  subroutine wake_lr_mode_struct_get_m(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%m
  end subroutine


  subroutine wake_lr_mode_struct_set_m(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%m = value_in
  end subroutine

  ! wake_lr_mode_struct%polarized: 0D_NOT_logical

  subroutine wake_lr_mode_struct_get_polarized(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_polarized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%polarized
  end subroutine


  subroutine wake_lr_mode_struct_set_polarized(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_polarized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%polarized = value_in
  end subroutine

  !! wake_lr_struct

    function allocate_fortran_wake_lr_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wake_lr_struct), pointer :: fptr
      type(wake_lr_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wake_lr_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wake_lr_struct), pointer :: fptr
      type(wake_lr_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wake_lr_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_lr_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wake_lr_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wake_lr_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wake_lr_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wake_lr_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wake_lr_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wake_lr_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wake_lr_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wake_lr_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wake_lr_struct%file: 0D_NOT_character

  subroutine wake_lr_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wake_lr_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wake_lr_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='wake_lr_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wake_lr_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! wake_lr_struct%mode: 1D_ALLOC_type

  subroutine wake_lr_struct_get_mode_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wake_lr_struct_get_mode_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_lr_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%mode) .and. is_contiguous(struct_obj%mode)) then
      data_ptr = c_loc(struct_obj%mode(lbound(struct_obj%mode, 1)))
      bounds(1) = int(lbound(struct_obj%mode, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mode, 1), c_int)
      
      el_size = int(storage_size(struct_obj%mode(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wake_lr_struct%t_ref: 0D_NOT_real

  subroutine wake_lr_struct_get_t_ref(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_t_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_ref
  end subroutine


  subroutine wake_lr_struct_set_t_ref(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_t_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_ref = value_in
  end subroutine

  ! wake_lr_struct%freq_spread: 0D_NOT_real

  subroutine wake_lr_struct_get_freq_spread(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_freq_spread')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq_spread
  end subroutine


  subroutine wake_lr_struct_set_freq_spread(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_freq_spread')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq_spread = value_in
  end subroutine

  ! wake_lr_struct%amp_scale: 0D_NOT_real

  subroutine wake_lr_struct_get_amp_scale(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp_scale
  end subroutine


  subroutine wake_lr_struct_set_amp_scale(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp_scale = value_in
  end subroutine

  ! wake_lr_struct%time_scale: 0D_NOT_real

  subroutine wake_lr_struct_get_time_scale(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_time_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_scale
  end subroutine


  subroutine wake_lr_struct_set_time_scale(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_time_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_scale = value_in
  end subroutine

  ! wake_lr_struct%self_wake_on: 0D_NOT_logical

  subroutine wake_lr_struct_get_self_wake_on(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_self_wake_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%self_wake_on
  end subroutine


  subroutine wake_lr_struct_set_self_wake_on(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_self_wake_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%self_wake_on = value_in
  end subroutine

  !! lat_ele_loc_struct

    function allocate_fortran_lat_ele_loc_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(lat_ele_loc_struct), pointer :: fptr
      type(lat_ele_loc_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_lat_ele_loc_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(lat_ele_loc_struct), pointer :: fptr
      type(lat_ele_loc_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_lat_ele_loc_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_loc_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_lat_ele_loc_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(lat_ele_loc_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_lat_ele_loc_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(lat_ele_loc_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_lat_ele_loc_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(lat_ele_loc_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_lat_ele_loc_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(lat_ele_loc_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! lat_ele_loc_struct%ix_ele: 0D_NOT_integer

  subroutine lat_ele_loc_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='lat_ele_loc_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine lat_ele_loc_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='lat_ele_loc_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! lat_ele_loc_struct%ix_branch: 0D_NOT_integer

  subroutine lat_ele_loc_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='lat_ele_loc_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine lat_ele_loc_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='lat_ele_loc_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  !! wake_struct

    function allocate_fortran_wake_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wake_struct), pointer :: fptr
      type(wake_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wake_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wake_struct), pointer :: fptr
      type(wake_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wake_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wake_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wake_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wake_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wake_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wake_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wake_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wake_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wake_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wake_struct%sr: 0D_NOT_type

  subroutine wake_struct_get_sr(struct_obj_ptr, ptr_out) bind(c, name='wake_struct_get_sr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wake_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%sr)
  end subroutine


  subroutine wake_struct_set_sr(struct_obj_ptr, src_ptr) bind(c, name='wake_struct_set_sr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wake_struct), pointer :: struct_obj
    type(wake_sr_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%sr = src_obj
  end subroutine

  ! wake_struct%lr: 0D_NOT_type

  subroutine wake_struct_get_lr(struct_obj_ptr, ptr_out) bind(c, name='wake_struct_get_lr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wake_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lr)
  end subroutine


  subroutine wake_struct_set_lr(struct_obj_ptr, src_ptr) bind(c, name='wake_struct_set_lr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wake_struct), pointer :: struct_obj
    type(wake_lr_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lr = src_obj
  end subroutine

  !! taylor_term_struct

    function allocate_fortran_taylor_term_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(taylor_term_struct), pointer :: fptr
      type(taylor_term_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_taylor_term_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(taylor_term_struct), pointer :: fptr
      type(taylor_term_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_taylor_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(taylor_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_taylor_term_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(taylor_term_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_taylor_term_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(taylor_term_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_taylor_term_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(taylor_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_taylor_term_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(taylor_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! taylor_term_struct%coef: 0D_NOT_real

  subroutine taylor_term_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='taylor_term_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine taylor_term_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='taylor_term_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! taylor_term_struct%expn: 1D_NOT_integer

  subroutine taylor_term_struct_get_expn_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='taylor_term_struct_get_expn_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(taylor_term_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%expn)) then
      data_ptr = c_loc(struct_obj%expn(lbound(struct_obj%expn, 1)))
      bounds(1) = int(lbound(struct_obj%expn, 1), c_int)
      bounds(2) = int(ubound(struct_obj%expn, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! taylor_struct

    function allocate_fortran_taylor_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(taylor_struct), pointer :: fptr
      type(taylor_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_taylor_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(taylor_struct), pointer :: fptr
      type(taylor_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_taylor_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(taylor_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_taylor_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(taylor_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_taylor_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(taylor_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_taylor_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(taylor_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_taylor_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(taylor_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! taylor_struct%ref: 0D_NOT_real

  subroutine taylor_struct_get_ref(struct_obj_ptr, value_out) bind(c, name='taylor_struct_get_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref
  end subroutine


  subroutine taylor_struct_set_ref(struct_obj_ptr, value_in) bind(c, name='taylor_struct_set_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref = value_in
  end subroutine

  ! taylor_struct%term: 1D_PTR_type

  subroutine taylor_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='taylor_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(taylor_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! em_taylor_term_struct

    function allocate_fortran_em_taylor_term_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(em_taylor_term_struct), pointer :: fptr
      type(em_taylor_term_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_em_taylor_term_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(em_taylor_term_struct), pointer :: fptr
      type(em_taylor_term_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_em_taylor_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(em_taylor_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_em_taylor_term_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(em_taylor_term_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_em_taylor_term_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(em_taylor_term_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_em_taylor_term_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(em_taylor_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_em_taylor_term_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(em_taylor_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! em_taylor_term_struct%coef: 0D_NOT_real

  subroutine em_taylor_term_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='em_taylor_term_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine em_taylor_term_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='em_taylor_term_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! em_taylor_term_struct%expn: 1D_NOT_integer

  subroutine em_taylor_term_struct_get_expn_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_taylor_term_struct_get_expn_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_taylor_term_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%expn)) then
      data_ptr = c_loc(struct_obj%expn(lbound(struct_obj%expn, 1)))
      bounds(1) = int(lbound(struct_obj%expn, 1), c_int)
      bounds(2) = int(ubound(struct_obj%expn, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! em_taylor_struct

    function allocate_fortran_em_taylor_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(em_taylor_struct), pointer :: fptr
      type(em_taylor_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_em_taylor_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(em_taylor_struct), pointer :: fptr
      type(em_taylor_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_em_taylor_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(em_taylor_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_em_taylor_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(em_taylor_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_em_taylor_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(em_taylor_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_em_taylor_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(em_taylor_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_em_taylor_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(em_taylor_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! em_taylor_struct%ref: 0D_NOT_real

  subroutine em_taylor_struct_get_ref(struct_obj_ptr, value_out) bind(c, name='em_taylor_struct_get_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref
  end subroutine


  subroutine em_taylor_struct_set_ref(struct_obj_ptr, value_in) bind(c, name='em_taylor_struct_set_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref = value_in
  end subroutine

  ! em_taylor_struct%term: 1D_ALLOC_type

  subroutine em_taylor_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='em_taylor_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_taylor_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! cartesian_map_term1_struct

    function allocate_fortran_cartesian_map_term1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(cartesian_map_term1_struct), pointer :: fptr
      type(cartesian_map_term1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_cartesian_map_term1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(cartesian_map_term1_struct), pointer :: fptr
      type(cartesian_map_term1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_cartesian_map_term1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cartesian_map_term1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_cartesian_map_term1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(cartesian_map_term1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_cartesian_map_term1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(cartesian_map_term1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_cartesian_map_term1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(cartesian_map_term1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_cartesian_map_term1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(cartesian_map_term1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! cartesian_map_term1_struct%coef: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine cartesian_map_term1_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! cartesian_map_term1_struct%kx: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_kx(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_kx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kx
  end subroutine


  subroutine cartesian_map_term1_struct_set_kx(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_kx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kx = value_in
  end subroutine

  ! cartesian_map_term1_struct%ky: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_ky(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_ky')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ky
  end subroutine


  subroutine cartesian_map_term1_struct_set_ky(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_ky')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ky = value_in
  end subroutine

  ! cartesian_map_term1_struct%kz: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_kz(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_kz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kz
  end subroutine


  subroutine cartesian_map_term1_struct_set_kz(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_kz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kz = value_in
  end subroutine

  ! cartesian_map_term1_struct%x0: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine cartesian_map_term1_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! cartesian_map_term1_struct%y0: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine cartesian_map_term1_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! cartesian_map_term1_struct%phi_z: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_phi_z(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_phi_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_z
  end subroutine


  subroutine cartesian_map_term1_struct_set_phi_z(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_phi_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_z = value_in
  end subroutine

  ! cartesian_map_term1_struct%family: 0D_NOT_integer

  subroutine cartesian_map_term1_struct_get_family(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_family')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%family
  end subroutine


  subroutine cartesian_map_term1_struct_set_family(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_family')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%family = value_in
  end subroutine

  ! cartesian_map_term1_struct%form: 0D_NOT_integer

  subroutine cartesian_map_term1_struct_get_form(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%form
  end subroutine


  subroutine cartesian_map_term1_struct_set_form(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%form = value_in
  end subroutine

  !! cartesian_map_term_struct

    function allocate_fortran_cartesian_map_term_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(cartesian_map_term_struct), pointer :: fptr
      type(cartesian_map_term_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_cartesian_map_term_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(cartesian_map_term_struct), pointer :: fptr
      type(cartesian_map_term_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_cartesian_map_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cartesian_map_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_cartesian_map_term_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(cartesian_map_term_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_cartesian_map_term_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(cartesian_map_term_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_cartesian_map_term_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(cartesian_map_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_cartesian_map_term_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(cartesian_map_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! cartesian_map_term_struct%file: 0D_NOT_character

  subroutine cartesian_map_term_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='cartesian_map_term_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cartesian_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine cartesian_map_term_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='cartesian_map_term_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(cartesian_map_term_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! cartesian_map_term_struct%n_link: 0D_NOT_integer

  subroutine cartesian_map_term_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine cartesian_map_term_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! cartesian_map_term_struct%term: 1D_ALLOC_type

  subroutine cartesian_map_term_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='cartesian_map_term_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cartesian_map_term_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! cartesian_map_struct

    function allocate_fortran_cartesian_map_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(cartesian_map_struct), pointer :: fptr
      type(cartesian_map_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_cartesian_map_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(cartesian_map_struct), pointer :: fptr
      type(cartesian_map_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_cartesian_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cartesian_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_cartesian_map_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(cartesian_map_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_cartesian_map_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(cartesian_map_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_cartesian_map_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(cartesian_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_cartesian_map_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(cartesian_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! cartesian_map_struct%field_scale: 0D_NOT_real

  subroutine cartesian_map_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine cartesian_map_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! cartesian_map_struct%r0: 1D_NOT_real

  subroutine cartesian_map_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='cartesian_map_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cartesian_map_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! cartesian_map_struct%master_parameter: 0D_NOT_integer

  subroutine cartesian_map_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine cartesian_map_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! cartesian_map_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine cartesian_map_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine cartesian_map_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! cartesian_map_struct%field_type: 0D_NOT_integer

  subroutine cartesian_map_struct_get_field_type(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_type
  end subroutine


  subroutine cartesian_map_struct_set_field_type(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_type = value_in
  end subroutine

  ! cartesian_map_struct%ptr: 0D_PTR_type

  subroutine cartesian_map_struct_get_ptr(struct_obj_ptr, ptr_out) bind(c, name='cartesian_map_struct_get_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      ptr_out = c_loc(struct_obj%ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine cartesian_map_struct_set_ptr(struct_obj_ptr, src_ptr) bind(c, name='cartesian_map_struct_set_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(cartesian_map_struct), pointer :: struct_obj
    type(cartesian_map_term_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ptr = src_obj
    endif
  end subroutine

  !! cylindrical_map_term1_struct

    function allocate_fortran_cylindrical_map_term1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(cylindrical_map_term1_struct), pointer :: fptr
      type(cylindrical_map_term1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_cylindrical_map_term1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(cylindrical_map_term1_struct), pointer :: fptr
      type(cylindrical_map_term1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_cylindrical_map_term1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cylindrical_map_term1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_cylindrical_map_term1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(cylindrical_map_term1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_cylindrical_map_term1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(cylindrical_map_term1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_cylindrical_map_term1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(cylindrical_map_term1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_cylindrical_map_term1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(cylindrical_map_term1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! cylindrical_map_term1_struct%e_coef: 0D_NOT_complex

  subroutine cylindrical_map_term1_struct_get_e_coef(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_term1_struct_get_e_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%e_coef
  end subroutine


  subroutine cylindrical_map_term1_struct_set_e_coef(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_term1_struct_set_e_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%e_coef = value_in
  end subroutine

  ! cylindrical_map_term1_struct%b_coef: 0D_NOT_complex

  subroutine cylindrical_map_term1_struct_get_b_coef(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_term1_struct_get_b_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_coef
  end subroutine


  subroutine cylindrical_map_term1_struct_set_b_coef(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_term1_struct_set_b_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_coef = value_in
  end subroutine

  !! cylindrical_map_term_struct

    function allocate_fortran_cylindrical_map_term_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(cylindrical_map_term_struct), pointer :: fptr
      type(cylindrical_map_term_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_cylindrical_map_term_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(cylindrical_map_term_struct), pointer :: fptr
      type(cylindrical_map_term_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_cylindrical_map_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cylindrical_map_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_cylindrical_map_term_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(cylindrical_map_term_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_cylindrical_map_term_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(cylindrical_map_term_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_cylindrical_map_term_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(cylindrical_map_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_cylindrical_map_term_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(cylindrical_map_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! cylindrical_map_term_struct%file: 0D_NOT_character

  subroutine cylindrical_map_term_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='cylindrical_map_term_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cylindrical_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine cylindrical_map_term_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='cylindrical_map_term_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(cylindrical_map_term_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! cylindrical_map_term_struct%n_link: 0D_NOT_integer

  subroutine cylindrical_map_term_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_term_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine cylindrical_map_term_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_term_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! cylindrical_map_term_struct%term: 1D_ALLOC_type

  subroutine cylindrical_map_term_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='cylindrical_map_term_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cylindrical_map_term_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! cylindrical_map_struct

    function allocate_fortran_cylindrical_map_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(cylindrical_map_struct), pointer :: fptr
      type(cylindrical_map_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_cylindrical_map_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(cylindrical_map_struct), pointer :: fptr
      type(cylindrical_map_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_cylindrical_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cylindrical_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_cylindrical_map_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(cylindrical_map_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_cylindrical_map_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(cylindrical_map_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_cylindrical_map_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(cylindrical_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_cylindrical_map_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(cylindrical_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! cylindrical_map_struct%m: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_m(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%m
  end subroutine


  subroutine cylindrical_map_struct_set_m(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%m = value_in
  end subroutine

  ! cylindrical_map_struct%harmonic: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_harmonic(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%harmonic
  end subroutine


  subroutine cylindrical_map_struct_set_harmonic(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%harmonic = value_in
  end subroutine

  ! cylindrical_map_struct%phi0_fieldmap: 0D_NOT_real

  subroutine cylindrical_map_struct_get_phi0_fieldmap(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi0_fieldmap
  end subroutine


  subroutine cylindrical_map_struct_set_phi0_fieldmap(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi0_fieldmap = value_in
  end subroutine

  ! cylindrical_map_struct%theta0_azimuth: 0D_NOT_real

  subroutine cylindrical_map_struct_get_theta0_azimuth(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_theta0_azimuth')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta0_azimuth
  end subroutine


  subroutine cylindrical_map_struct_set_theta0_azimuth(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_theta0_azimuth')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta0_azimuth = value_in
  end subroutine

  ! cylindrical_map_struct%field_scale: 0D_NOT_real

  subroutine cylindrical_map_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine cylindrical_map_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! cylindrical_map_struct%master_parameter: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine cylindrical_map_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! cylindrical_map_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine cylindrical_map_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! cylindrical_map_struct%dz: 0D_NOT_real

  subroutine cylindrical_map_struct_get_dz(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz
  end subroutine


  subroutine cylindrical_map_struct_set_dz(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz = value_in
  end subroutine

  ! cylindrical_map_struct%r0: 1D_NOT_real

  subroutine cylindrical_map_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='cylindrical_map_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cylindrical_map_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! cylindrical_map_struct%ptr: 0D_PTR_type

  subroutine cylindrical_map_struct_get_ptr(struct_obj_ptr, ptr_out) bind(c, name='cylindrical_map_struct_get_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      ptr_out = c_loc(struct_obj%ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine cylindrical_map_struct_set_ptr(struct_obj_ptr, src_ptr) bind(c, name='cylindrical_map_struct_set_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(cylindrical_map_struct), pointer :: struct_obj
    type(cylindrical_map_term_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ptr = src_obj
    endif
  end subroutine

  !! bicubic_cmplx_coef_struct

    function allocate_fortran_bicubic_cmplx_coef_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bicubic_cmplx_coef_struct), pointer :: fptr
      type(bicubic_cmplx_coef_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bicubic_cmplx_coef_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bicubic_cmplx_coef_struct), pointer :: fptr
      type(bicubic_cmplx_coef_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bicubic_cmplx_coef_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bicubic_cmplx_coef_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bicubic_cmplx_coef_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bicubic_cmplx_coef_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bicubic_cmplx_coef_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bicubic_cmplx_coef_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bicubic_cmplx_coef_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bicubic_cmplx_coef_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bicubic_cmplx_coef_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bicubic_cmplx_coef_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bicubic_cmplx_coef_struct%coef: 2D_NOT_complex

  subroutine bicubic_cmplx_coef_struct_get_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='bicubic_cmplx_coef_struct_get_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bicubic_cmplx_coef_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%coef)) then
      data_ptr = c_loc(struct_obj%coef(lbound(struct_obj%coef, 1), lbound(struct_obj%coef, 2)))
      bounds(1) = int(lbound(struct_obj%coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%coef, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bicubic_cmplx_coef_struct%i_box: 1D_NOT_integer

  subroutine bicubic_cmplx_coef_struct_get_i_box_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bicubic_cmplx_coef_struct_get_i_box_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bicubic_cmplx_coef_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%i_box)) then
      data_ptr = c_loc(struct_obj%i_box(lbound(struct_obj%i_box, 1)))
      bounds(1) = int(lbound(struct_obj%i_box, 1), c_int)
      bounds(2) = int(ubound(struct_obj%i_box, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! tricubic_cmplx_coef_struct

    function allocate_fortran_tricubic_cmplx_coef_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tricubic_cmplx_coef_struct), pointer :: fptr
      type(tricubic_cmplx_coef_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tricubic_cmplx_coef_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tricubic_cmplx_coef_struct), pointer :: fptr
      type(tricubic_cmplx_coef_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tricubic_cmplx_coef_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tricubic_cmplx_coef_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tricubic_cmplx_coef_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tricubic_cmplx_coef_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tricubic_cmplx_coef_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tricubic_cmplx_coef_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tricubic_cmplx_coef_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tricubic_cmplx_coef_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tricubic_cmplx_coef_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tricubic_cmplx_coef_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tricubic_cmplx_coef_struct%coef: 3D_NOT_complex

  subroutine tricubic_cmplx_coef_struct_get_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tricubic_cmplx_coef_struct_get_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tricubic_cmplx_coef_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%coef)) then
      data_ptr = c_loc(struct_obj%coef(lbound(struct_obj%coef, 1), lbound(struct_obj%coef, 2), lbound(struct_obj%coef, 3)))
      bounds(1) = int(lbound(struct_obj%coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%coef, 2), c_int)
      bounds(5) = int(lbound(struct_obj%coef, 3), c_int)
      bounds(6) = int(ubound(struct_obj%coef, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tricubic_cmplx_coef_struct%i_box: 1D_NOT_integer

  subroutine tricubic_cmplx_coef_struct_get_i_box_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tricubic_cmplx_coef_struct_get_i_box_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tricubic_cmplx_coef_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%i_box)) then
      data_ptr = c_loc(struct_obj%i_box(lbound(struct_obj%i_box, 1)))
      bounds(1) = int(lbound(struct_obj%i_box, 1), c_int)
      bounds(2) = int(ubound(struct_obj%i_box, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! grid_field_pt1_struct

    function allocate_fortran_grid_field_pt1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(grid_field_pt1_struct), pointer :: fptr
      type(grid_field_pt1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_grid_field_pt1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(grid_field_pt1_struct), pointer :: fptr
      type(grid_field_pt1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_grid_field_pt1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_field_pt1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_grid_field_pt1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(grid_field_pt1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_grid_field_pt1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(grid_field_pt1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_grid_field_pt1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(grid_field_pt1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_grid_field_pt1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(grid_field_pt1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! grid_field_pt1_struct%E: 1D_NOT_complex

  subroutine grid_field_pt1_struct_get_E_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_pt1_struct_get_E_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt1_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%E)) then
      data_ptr = c_loc(struct_obj%E(lbound(struct_obj%E, 1)))
      bounds(1) = int(lbound(struct_obj%E, 1), c_int)
      bounds(2) = int(ubound(struct_obj%E, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_pt1_struct%B: 1D_NOT_complex

  subroutine grid_field_pt1_struct_get_B_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_pt1_struct_get_B_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt1_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%B)) then
      data_ptr = c_loc(struct_obj%B(lbound(struct_obj%B, 1)))
      bounds(1) = int(lbound(struct_obj%B, 1), c_int)
      bounds(2) = int(ubound(struct_obj%B, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! grid_field_pt_struct

    function allocate_fortran_grid_field_pt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(grid_field_pt_struct), pointer :: fptr
      type(grid_field_pt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_grid_field_pt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(grid_field_pt_struct), pointer :: fptr
      type(grid_field_pt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_grid_field_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_field_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_grid_field_pt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(grid_field_pt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_grid_field_pt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(grid_field_pt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_grid_field_pt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(grid_field_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_grid_field_pt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(grid_field_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! grid_field_pt_struct%file: 0D_NOT_character

  subroutine grid_field_pt_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='grid_field_pt_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine grid_field_pt_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='grid_field_pt_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(grid_field_pt_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! grid_field_pt_struct%n_link: 0D_NOT_integer

  subroutine grid_field_pt_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='grid_field_pt_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine grid_field_pt_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='grid_field_pt_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! grid_field_pt_struct%pt: 3D_ALLOC_type

  subroutine grid_field_pt_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='grid_field_pt_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2), lbound(struct_obj%pt, 3)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      bounds(5) = int(lbound(struct_obj%pt, 3), c_int)
      bounds(6) = int(ubound(struct_obj%pt, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! grid_field_struct

    function allocate_fortran_grid_field_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(grid_field_struct), pointer :: fptr
      type(grid_field_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_grid_field_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(grid_field_struct), pointer :: fptr
      type(grid_field_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_grid_field_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_field_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_grid_field_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(grid_field_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_grid_field_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(grid_field_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_grid_field_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(grid_field_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_grid_field_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(grid_field_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! grid_field_struct%geometry: 0D_NOT_integer

  subroutine grid_field_struct_get_geometry(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%geometry
  end subroutine


  subroutine grid_field_struct_set_geometry(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%geometry = value_in
  end subroutine

  ! grid_field_struct%harmonic: 0D_NOT_integer

  subroutine grid_field_struct_get_harmonic(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%harmonic
  end subroutine


  subroutine grid_field_struct_set_harmonic(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%harmonic = value_in
  end subroutine

  ! grid_field_struct%phi0_fieldmap: 0D_NOT_real

  subroutine grid_field_struct_get_phi0_fieldmap(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi0_fieldmap
  end subroutine


  subroutine grid_field_struct_set_phi0_fieldmap(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi0_fieldmap = value_in
  end subroutine

  ! grid_field_struct%field_scale: 0D_NOT_real

  subroutine grid_field_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine grid_field_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! grid_field_struct%field_type: 0D_NOT_integer

  subroutine grid_field_struct_get_field_type(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_type
  end subroutine


  subroutine grid_field_struct_set_field_type(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_type = value_in
  end subroutine

  ! grid_field_struct%master_parameter: 0D_NOT_integer

  subroutine grid_field_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine grid_field_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! grid_field_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine grid_field_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine grid_field_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! grid_field_struct%interpolation_order: 0D_NOT_integer

  subroutine grid_field_struct_get_interpolation_order(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_interpolation_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%interpolation_order
  end subroutine


  subroutine grid_field_struct_set_interpolation_order(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_interpolation_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%interpolation_order = value_in
  end subroutine

  ! grid_field_struct%dr: 1D_NOT_real

  subroutine grid_field_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_struct%r0: 1D_NOT_real

  subroutine grid_field_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_struct%curved_ref_frame: 0D_NOT_logical

  subroutine grid_field_struct_get_curved_ref_frame(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%curved_ref_frame
  end subroutine


  subroutine grid_field_struct_set_curved_ref_frame(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%curved_ref_frame = value_in
  end subroutine

  ! grid_field_struct%ptr: 0D_PTR_type

  subroutine grid_field_struct_get_ptr(struct_obj_ptr, ptr_out) bind(c, name='grid_field_struct_get_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      ptr_out = c_loc(struct_obj%ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine grid_field_struct_set_ptr(struct_obj_ptr, src_ptr) bind(c, name='grid_field_struct_set_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(grid_field_struct), pointer :: struct_obj
    type(grid_field_pt_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ptr = src_obj
    endif
  end subroutine

  ! grid_field_struct%bi_coef: 3D_NOT_type

  subroutine grid_field_struct_get_bi_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='grid_field_struct_get_bi_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%bi_coef)) then
      data_ptr = c_loc(struct_obj%bi_coef(lbound(struct_obj%bi_coef, 1), lbound(struct_obj%bi_coef, 2), lbound(struct_obj%bi_coef, 3)))
      bounds(1) = int(lbound(struct_obj%bi_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bi_coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%bi_coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%bi_coef, 2), c_int)
      bounds(5) = int(lbound(struct_obj%bi_coef, 3), c_int)
      bounds(6) = int(ubound(struct_obj%bi_coef, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%bi_coef(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_struct%tri_coef: 3D_NOT_type

  subroutine grid_field_struct_get_tri_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='grid_field_struct_get_tri_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%tri_coef)) then
      data_ptr = c_loc(struct_obj%tri_coef(lbound(struct_obj%tri_coef, 1), lbound(struct_obj%tri_coef, 2), lbound(struct_obj%tri_coef, 3)))
      bounds(1) = int(lbound(struct_obj%tri_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%tri_coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%tri_coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%tri_coef, 2), c_int)
      bounds(5) = int(lbound(struct_obj%tri_coef, 3), c_int)
      bounds(6) = int(ubound(struct_obj%tri_coef, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%tri_coef(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! floor_position_struct

    function allocate_fortran_floor_position_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(floor_position_struct), pointer :: fptr
      type(floor_position_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_floor_position_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(floor_position_struct), pointer :: fptr
      type(floor_position_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_floor_position_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(floor_position_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_floor_position_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(floor_position_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_floor_position_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(floor_position_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_floor_position_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(floor_position_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_floor_position_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(floor_position_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! floor_position_struct%r: 1D_NOT_real

  subroutine floor_position_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='floor_position_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(floor_position_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! floor_position_struct%w: 2D_NOT_real

  subroutine floor_position_struct_get_w_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='floor_position_struct_get_w_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(floor_position_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%w)) then
      data_ptr = c_loc(struct_obj%w(lbound(struct_obj%w, 1), lbound(struct_obj%w, 2)))
      bounds(1) = int(lbound(struct_obj%w, 1), c_int)
      bounds(2) = int(ubound(struct_obj%w, 1), c_int)
      bounds(3) = int(lbound(struct_obj%w, 2), c_int)
      bounds(4) = int(ubound(struct_obj%w, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! floor_position_struct%theta: 0D_NOT_real

  subroutine floor_position_struct_get_theta(struct_obj_ptr, value_out) bind(c, name='floor_position_struct_get_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta
  end subroutine


  subroutine floor_position_struct_set_theta(struct_obj_ptr, value_in) bind(c, name='floor_position_struct_set_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta = value_in
  end subroutine

  ! floor_position_struct%phi: 0D_NOT_real

  subroutine floor_position_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='floor_position_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine floor_position_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='floor_position_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! floor_position_struct%psi: 0D_NOT_real

  subroutine floor_position_struct_get_psi(struct_obj_ptr, value_out) bind(c, name='floor_position_struct_get_psi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%psi
  end subroutine


  subroutine floor_position_struct_set_psi(struct_obj_ptr, value_in) bind(c, name='floor_position_struct_set_psi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%psi = value_in
  end subroutine

  !! high_energy_space_charge_struct

    function allocate_fortran_high_energy_space_charge_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(high_energy_space_charge_struct), pointer :: fptr
      type(high_energy_space_charge_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_high_energy_space_charge_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(high_energy_space_charge_struct), pointer :: fptr
      type(high_energy_space_charge_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_high_energy_space_charge_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(high_energy_space_charge_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_high_energy_space_charge_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(high_energy_space_charge_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_high_energy_space_charge_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(high_energy_space_charge_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_high_energy_space_charge_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(high_energy_space_charge_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_high_energy_space_charge_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(high_energy_space_charge_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! high_energy_space_charge_struct%closed_orb: 0D_NOT_type

  subroutine high_energy_space_charge_struct_get_closed_orb(struct_obj_ptr, ptr_out) bind(c, name='high_energy_space_charge_struct_get_closed_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%closed_orb)
  end subroutine


  subroutine high_energy_space_charge_struct_set_closed_orb(struct_obj_ptr, src_ptr) bind(c, name='high_energy_space_charge_struct_set_closed_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(high_energy_space_charge_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%closed_orb = src_obj
  end subroutine

  ! high_energy_space_charge_struct%kick_const: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_kick_const(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_kick_const')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kick_const
  end subroutine


  subroutine high_energy_space_charge_struct_set_kick_const(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_kick_const')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kick_const = value_in
  end subroutine

  ! high_energy_space_charge_struct%sig_x: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sig_x(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sig_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_x
  end subroutine


  subroutine high_energy_space_charge_struct_set_sig_x(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sig_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_x = value_in
  end subroutine

  ! high_energy_space_charge_struct%sig_y: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sig_y(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sig_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_y
  end subroutine


  subroutine high_energy_space_charge_struct_set_sig_y(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sig_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_y = value_in
  end subroutine

  ! high_energy_space_charge_struct%phi: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine high_energy_space_charge_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! high_energy_space_charge_struct%sin_phi: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sin_phi(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sin_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sin_phi
  end subroutine


  subroutine high_energy_space_charge_struct_set_sin_phi(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sin_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sin_phi = value_in
  end subroutine

  ! high_energy_space_charge_struct%cos_phi: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_cos_phi(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_cos_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cos_phi
  end subroutine


  subroutine high_energy_space_charge_struct_set_cos_phi(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_cos_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cos_phi = value_in
  end subroutine

  ! high_energy_space_charge_struct%sig_z: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sig_z(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z
  end subroutine


  subroutine high_energy_space_charge_struct_set_sig_z(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z = value_in
  end subroutine

  !! xy_disp_struct

    function allocate_fortran_xy_disp_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(xy_disp_struct), pointer :: fptr
      type(xy_disp_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_xy_disp_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(xy_disp_struct), pointer :: fptr
      type(xy_disp_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_xy_disp_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(xy_disp_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_xy_disp_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(xy_disp_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_xy_disp_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(xy_disp_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_xy_disp_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(xy_disp_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_xy_disp_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(xy_disp_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! xy_disp_struct%eta: 0D_NOT_real

  subroutine xy_disp_struct_get_eta(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eta
  end subroutine


  subroutine xy_disp_struct_set_eta(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eta = value_in
  end subroutine

  ! xy_disp_struct%etap: 0D_NOT_real

  subroutine xy_disp_struct_get_etap(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%etap
  end subroutine


  subroutine xy_disp_struct_set_etap(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%etap = value_in
  end subroutine

  ! xy_disp_struct%deta_ds: 0D_NOT_real

  subroutine xy_disp_struct_get_deta_ds(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_ds
  end subroutine


  subroutine xy_disp_struct_set_deta_ds(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_ds = value_in
  end subroutine

  ! xy_disp_struct%sigma: 0D_NOT_real

  subroutine xy_disp_struct_get_sigma(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma
  end subroutine


  subroutine xy_disp_struct_set_sigma(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma = value_in
  end subroutine

  ! xy_disp_struct%deta_dpz: 0D_NOT_real

  subroutine xy_disp_struct_get_deta_dpz(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_dpz
  end subroutine


  subroutine xy_disp_struct_set_deta_dpz(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_dpz = value_in
  end subroutine

  ! xy_disp_struct%detap_dpz: 0D_NOT_real

  subroutine xy_disp_struct_get_detap_dpz(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%detap_dpz
  end subroutine


  subroutine xy_disp_struct_set_detap_dpz(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%detap_dpz = value_in
  end subroutine

  !! twiss_struct

    function allocate_fortran_twiss_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(twiss_struct), pointer :: fptr
      type(twiss_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_twiss_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(twiss_struct), pointer :: fptr
      type(twiss_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_twiss_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(twiss_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_twiss_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(twiss_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_twiss_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(twiss_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_twiss_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(twiss_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_twiss_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(twiss_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! twiss_struct%beta: 0D_NOT_real

  subroutine twiss_struct_get_beta(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beta
  end subroutine


  subroutine twiss_struct_set_beta(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beta = value_in
  end subroutine

  ! twiss_struct%alpha: 0D_NOT_real

  subroutine twiss_struct_get_alpha(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_alpha')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%alpha
  end subroutine


  subroutine twiss_struct_set_alpha(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_alpha')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%alpha = value_in
  end subroutine

  ! twiss_struct%gamma: 0D_NOT_real

  subroutine twiss_struct_get_gamma(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_gamma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gamma
  end subroutine


  subroutine twiss_struct_set_gamma(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_gamma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gamma = value_in
  end subroutine

  ! twiss_struct%phi: 0D_NOT_real

  subroutine twiss_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine twiss_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! twiss_struct%eta: 0D_NOT_real

  subroutine twiss_struct_get_eta(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eta
  end subroutine


  subroutine twiss_struct_set_eta(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eta = value_in
  end subroutine

  ! twiss_struct%etap: 0D_NOT_real

  subroutine twiss_struct_get_etap(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%etap
  end subroutine


  subroutine twiss_struct_set_etap(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%etap = value_in
  end subroutine

  ! twiss_struct%deta_ds: 0D_NOT_real

  subroutine twiss_struct_get_deta_ds(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_ds
  end subroutine


  subroutine twiss_struct_set_deta_ds(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_ds = value_in
  end subroutine

  ! twiss_struct%sigma: 0D_NOT_real

  subroutine twiss_struct_get_sigma(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma
  end subroutine


  subroutine twiss_struct_set_sigma(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma = value_in
  end subroutine

  ! twiss_struct%sigma_p: 0D_NOT_real

  subroutine twiss_struct_get_sigma_p(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_sigma_p')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_p
  end subroutine


  subroutine twiss_struct_set_sigma_p(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_sigma_p')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_p = value_in
  end subroutine

  ! twiss_struct%emit: 0D_NOT_real

  subroutine twiss_struct_get_emit(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emit
  end subroutine


  subroutine twiss_struct_set_emit(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emit = value_in
  end subroutine

  ! twiss_struct%norm_emit: 0D_NOT_real

  subroutine twiss_struct_get_norm_emit(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%norm_emit
  end subroutine


  subroutine twiss_struct_set_norm_emit(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%norm_emit = value_in
  end subroutine

  ! twiss_struct%chrom: 0D_NOT_real

  subroutine twiss_struct_get_chrom(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom
  end subroutine


  subroutine twiss_struct_set_chrom(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom = value_in
  end subroutine

  ! twiss_struct%dbeta_dpz: 0D_NOT_real

  subroutine twiss_struct_get_dbeta_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_dbeta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dbeta_dpz
  end subroutine


  subroutine twiss_struct_set_dbeta_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_dbeta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dbeta_dpz = value_in
  end subroutine

  ! twiss_struct%dalpha_dpz: 0D_NOT_real

  subroutine twiss_struct_get_dalpha_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_dalpha_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dalpha_dpz
  end subroutine


  subroutine twiss_struct_set_dalpha_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_dalpha_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dalpha_dpz = value_in
  end subroutine

  ! twiss_struct%deta_dpz: 0D_NOT_real

  subroutine twiss_struct_get_deta_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_dpz
  end subroutine


  subroutine twiss_struct_set_deta_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_dpz = value_in
  end subroutine

  ! twiss_struct%detap_dpz: 0D_NOT_real

  subroutine twiss_struct_get_detap_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%detap_dpz
  end subroutine


  subroutine twiss_struct_set_detap_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%detap_dpz = value_in
  end subroutine

  !! mode3_struct

    function allocate_fortran_mode3_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(mode3_struct), pointer :: fptr
      type(mode3_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_mode3_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(mode3_struct), pointer :: fptr
      type(mode3_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_mode3_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(mode3_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_mode3_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(mode3_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_mode3_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(mode3_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_mode3_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(mode3_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_mode3_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(mode3_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! mode3_struct%v: 2D_NOT_real

  subroutine mode3_struct_get_v_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='mode3_struct_get_v_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(mode3_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%v)) then
      data_ptr = c_loc(struct_obj%v(lbound(struct_obj%v, 1), lbound(struct_obj%v, 2)))
      bounds(1) = int(lbound(struct_obj%v, 1), c_int)
      bounds(2) = int(ubound(struct_obj%v, 1), c_int)
      bounds(3) = int(lbound(struct_obj%v, 2), c_int)
      bounds(4) = int(ubound(struct_obj%v, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! mode3_struct%a: 0D_NOT_type

  subroutine mode3_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine mode3_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! mode3_struct%b: 0D_NOT_type

  subroutine mode3_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine mode3_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! mode3_struct%c: 0D_NOT_type

  subroutine mode3_struct_get_c(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%c)
  end subroutine


  subroutine mode3_struct_set_c(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%c = src_obj
  end subroutine

  ! mode3_struct%x: 0D_NOT_type

  subroutine mode3_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine mode3_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! mode3_struct%y: 0D_NOT_type

  subroutine mode3_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine mode3_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  !! bookkeeping_state_struct

    function allocate_fortran_bookkeeping_state_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bookkeeping_state_struct), pointer :: fptr
      type(bookkeeping_state_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bookkeeping_state_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bookkeeping_state_struct), pointer :: fptr
      type(bookkeeping_state_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bookkeeping_state_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bookkeeping_state_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bookkeeping_state_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bookkeeping_state_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bookkeeping_state_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bookkeeping_state_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bookkeeping_state_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bookkeeping_state_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bookkeeping_state_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bookkeeping_state_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bookkeeping_state_struct%attributes: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_attributes(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_attributes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%attributes
  end subroutine


  subroutine bookkeeping_state_struct_set_attributes(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_attributes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%attributes = value_in
  end subroutine

  ! bookkeeping_state_struct%control: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_control(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%control
  end subroutine


  subroutine bookkeeping_state_struct_set_control(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%control = value_in
  end subroutine

  ! bookkeeping_state_struct%floor_position: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_floor_position(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_floor_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%floor_position
  end subroutine


  subroutine bookkeeping_state_struct_set_floor_position(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_floor_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%floor_position = value_in
  end subroutine

  ! bookkeeping_state_struct%s_position: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_s_position(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_s_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_position
  end subroutine


  subroutine bookkeeping_state_struct_set_s_position(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_s_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_position = value_in
  end subroutine

  ! bookkeeping_state_struct%ref_energy: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_ref_energy(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_ref_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_energy
  end subroutine


  subroutine bookkeeping_state_struct_set_ref_energy(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_ref_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_energy = value_in
  end subroutine

  ! bookkeeping_state_struct%mat6: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_mat6(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_mat6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mat6
  end subroutine


  subroutine bookkeeping_state_struct_set_mat6(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_mat6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mat6 = value_in
  end subroutine

  ! bookkeeping_state_struct%rad_int: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_rad_int(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_rad_int')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int
  end subroutine


  subroutine bookkeeping_state_struct_set_rad_int(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_rad_int')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int = value_in
  end subroutine

  ! bookkeeping_state_struct%ptc: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_ptc(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_ptc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ptc
  end subroutine


  subroutine bookkeeping_state_struct_set_ptc(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_ptc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ptc = value_in
  end subroutine

  ! bookkeeping_state_struct%has_misalign: 0D_NOT_logical

  subroutine bookkeeping_state_struct_get_has_misalign(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_has_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%has_misalign
  end subroutine


  subroutine bookkeeping_state_struct_set_has_misalign(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_has_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%has_misalign = value_in
  end subroutine

  !! rad_map_struct

    function allocate_fortran_rad_map_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rad_map_struct), pointer :: fptr
      type(rad_map_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rad_map_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rad_map_struct), pointer :: fptr
      type(rad_map_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rad_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rad_map_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rad_map_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rad_map_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rad_map_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rad_map_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rad_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rad_map_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rad_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rad_map_struct%ref_orb: 1D_NOT_real

  subroutine rad_map_struct_get_ref_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='rad_map_struct_get_ref_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%ref_orb)) then
      data_ptr = c_loc(struct_obj%ref_orb(lbound(struct_obj%ref_orb, 1)))
      bounds(1) = int(lbound(struct_obj%ref_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ref_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%damp_dmat: 2D_NOT_real

  subroutine rad_map_struct_get_damp_dmat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='rad_map_struct_get_damp_dmat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%damp_dmat)) then
      data_ptr = c_loc(struct_obj%damp_dmat(lbound(struct_obj%damp_dmat, 1), lbound(struct_obj%damp_dmat, 2)))
      bounds(1) = int(lbound(struct_obj%damp_dmat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%damp_dmat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%damp_dmat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%damp_dmat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%xfer_damp_vec: 1D_NOT_real

  subroutine rad_map_struct_get_xfer_damp_vec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='rad_map_struct_get_xfer_damp_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%xfer_damp_vec)) then
      data_ptr = c_loc(struct_obj%xfer_damp_vec(lbound(struct_obj%xfer_damp_vec, 1)))
      bounds(1) = int(lbound(struct_obj%xfer_damp_vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%xfer_damp_vec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%xfer_damp_mat: 2D_NOT_real

  subroutine rad_map_struct_get_xfer_damp_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='rad_map_struct_get_xfer_damp_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%xfer_damp_mat)) then
      data_ptr = c_loc(struct_obj%xfer_damp_mat(lbound(struct_obj%xfer_damp_mat, 1), lbound(struct_obj%xfer_damp_mat, 2)))
      bounds(1) = int(lbound(struct_obj%xfer_damp_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%xfer_damp_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%xfer_damp_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%xfer_damp_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%stoc_mat: 2D_NOT_real

  subroutine rad_map_struct_get_stoc_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='rad_map_struct_get_stoc_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%stoc_mat)) then
      data_ptr = c_loc(struct_obj%stoc_mat(lbound(struct_obj%stoc_mat, 1), lbound(struct_obj%stoc_mat, 2)))
      bounds(1) = int(lbound(struct_obj%stoc_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stoc_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%stoc_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%stoc_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! rad_map_ele_struct

    function allocate_fortran_rad_map_ele_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rad_map_ele_struct), pointer :: fptr
      type(rad_map_ele_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rad_map_ele_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rad_map_ele_struct), pointer :: fptr
      type(rad_map_ele_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rad_map_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_map_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rad_map_ele_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rad_map_ele_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rad_map_ele_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rad_map_ele_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rad_map_ele_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rad_map_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rad_map_ele_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rad_map_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rad_map_ele_struct%rm0: 0D_NOT_type

  subroutine rad_map_ele_struct_get_rm0(struct_obj_ptr, ptr_out) bind(c, name='rad_map_ele_struct_get_rm0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rm0)
  end subroutine


  subroutine rad_map_ele_struct_set_rm0(struct_obj_ptr, src_ptr) bind(c, name='rad_map_ele_struct_set_rm0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(rad_map_ele_struct), pointer :: struct_obj
    type(rad_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rm0 = src_obj
  end subroutine

  ! rad_map_ele_struct%rm1: 0D_NOT_type

  subroutine rad_map_ele_struct_get_rm1(struct_obj_ptr, ptr_out) bind(c, name='rad_map_ele_struct_get_rm1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rm1)
  end subroutine


  subroutine rad_map_ele_struct_set_rm1(struct_obj_ptr, src_ptr) bind(c, name='rad_map_ele_struct_set_rm1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(rad_map_ele_struct), pointer :: struct_obj
    type(rad_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rm1 = src_obj
  end subroutine

  ! rad_map_ele_struct%stale: 0D_NOT_logical

  subroutine rad_map_ele_struct_get_stale(struct_obj_ptr, value_out) bind(c, name='rad_map_ele_struct_get_stale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stale
  end subroutine


  subroutine rad_map_ele_struct_set_stale(struct_obj_ptr, value_in) bind(c, name='rad_map_ele_struct_set_stale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stale = value_in
  end subroutine

  !! gen_grad1_struct

    function allocate_fortran_gen_grad1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(gen_grad1_struct), pointer :: fptr
      type(gen_grad1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_gen_grad1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(gen_grad1_struct), pointer :: fptr
      type(gen_grad1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_gen_grad1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(gen_grad1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_gen_grad1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(gen_grad1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_gen_grad1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(gen_grad1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_gen_grad1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(gen_grad1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_gen_grad1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(gen_grad1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! gen_grad1_struct%m: 0D_NOT_integer

  subroutine gen_grad1_struct_get_m(struct_obj_ptr, value_out) bind(c, name='gen_grad1_struct_get_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%m
  end subroutine


  subroutine gen_grad1_struct_set_m(struct_obj_ptr, value_in) bind(c, name='gen_grad1_struct_set_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%m = value_in
  end subroutine

  ! gen_grad1_struct%sincos: 0D_NOT_integer

  subroutine gen_grad1_struct_get_sincos(struct_obj_ptr, value_out) bind(c, name='gen_grad1_struct_get_sincos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sincos
  end subroutine


  subroutine gen_grad1_struct_set_sincos(struct_obj_ptr, value_in) bind(c, name='gen_grad1_struct_set_sincos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sincos = value_in
  end subroutine

  ! gen_grad1_struct%n_deriv_max: 0D_NOT_integer

  subroutine gen_grad1_struct_get_n_deriv_max(struct_obj_ptr, value_out) bind(c, name='gen_grad1_struct_get_n_deriv_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_deriv_max
  end subroutine


  subroutine gen_grad1_struct_set_n_deriv_max(struct_obj_ptr, value_in) bind(c, name='gen_grad1_struct_set_n_deriv_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_deriv_max = value_in
  end subroutine

  ! gen_grad1_struct%deriv: 2D_ALLOC_real

  subroutine gen_grad1_struct_get_deriv_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='gen_grad1_struct_get_deriv_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad1_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%deriv) .and. is_contiguous(struct_obj%deriv)) then
      data_ptr = c_loc(struct_obj%deriv(lbound(struct_obj%deriv, 1), lbound(struct_obj%deriv, 2)))
      bounds(1) = int(lbound(struct_obj%deriv, 1), c_int)
      bounds(2) = int(ubound(struct_obj%deriv, 1), c_int)
      bounds(3) = int(lbound(struct_obj%deriv, 2), c_int)
      bounds(4) = int(ubound(struct_obj%deriv, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! gen_grad_map_struct

    function allocate_fortran_gen_grad_map_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(gen_grad_map_struct), pointer :: fptr
      type(gen_grad_map_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_gen_grad_map_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(gen_grad_map_struct), pointer :: fptr
      type(gen_grad_map_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_gen_grad_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(gen_grad_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_gen_grad_map_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(gen_grad_map_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_gen_grad_map_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(gen_grad_map_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_gen_grad_map_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(gen_grad_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_gen_grad_map_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(gen_grad_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! gen_grad_map_struct%file: 0D_NOT_character

  subroutine gen_grad_map_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='gen_grad_map_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine gen_grad_map_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='gen_grad_map_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(gen_grad_map_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! gen_grad_map_struct%gg: 1D_ALLOC_type

  subroutine gen_grad_map_struct_get_gg_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='gen_grad_map_struct_get_gg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad_map_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%gg) .and. is_contiguous(struct_obj%gg)) then
      data_ptr = c_loc(struct_obj%gg(lbound(struct_obj%gg, 1)))
      bounds(1) = int(lbound(struct_obj%gg, 1), c_int)
      bounds(2) = int(ubound(struct_obj%gg, 1), c_int)
      
      el_size = int(storage_size(struct_obj%gg(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! gen_grad_map_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine gen_grad_map_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! gen_grad_map_struct%field_type: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_field_type(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_type
  end subroutine


  subroutine gen_grad_map_struct_set_field_type(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_type = value_in
  end subroutine

  ! gen_grad_map_struct%iz0: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_iz0(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_iz0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iz0
  end subroutine


  subroutine gen_grad_map_struct_set_iz0(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_iz0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iz0 = value_in
  end subroutine

  ! gen_grad_map_struct%iz1: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_iz1(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_iz1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iz1
  end subroutine


  subroutine gen_grad_map_struct_set_iz1(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_iz1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iz1 = value_in
  end subroutine

  ! gen_grad_map_struct%dz: 0D_NOT_real

  subroutine gen_grad_map_struct_get_dz(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz
  end subroutine


  subroutine gen_grad_map_struct_set_dz(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz = value_in
  end subroutine

  ! gen_grad_map_struct%r0: 1D_NOT_real

  subroutine gen_grad_map_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='gen_grad_map_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad_map_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! gen_grad_map_struct%field_scale: 0D_NOT_real

  subroutine gen_grad_map_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine gen_grad_map_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! gen_grad_map_struct%master_parameter: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine gen_grad_map_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! gen_grad_map_struct%curved_ref_frame: 0D_NOT_logical

  subroutine gen_grad_map_struct_get_curved_ref_frame(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%curved_ref_frame
  end subroutine


  subroutine gen_grad_map_struct_set_curved_ref_frame(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%curved_ref_frame = value_in
  end subroutine

  !! surface_segmented_pt_struct

    function allocate_fortran_surface_segmented_pt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_segmented_pt_struct), pointer :: fptr
      type(surface_segmented_pt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_segmented_pt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_segmented_pt_struct), pointer :: fptr
      type(surface_segmented_pt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_segmented_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_segmented_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_segmented_pt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_segmented_pt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_segmented_pt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_segmented_pt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_segmented_pt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_segmented_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_segmented_pt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_segmented_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_segmented_pt_struct%x0: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine surface_segmented_pt_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! surface_segmented_pt_struct%y0: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine surface_segmented_pt_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! surface_segmented_pt_struct%z0: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_z0(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z0
  end subroutine


  subroutine surface_segmented_pt_struct_set_z0(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z0 = value_in
  end subroutine

  ! surface_segmented_pt_struct%dz_dx: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_dz_dx(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dx
  end subroutine


  subroutine surface_segmented_pt_struct_set_dz_dx(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dx = value_in
  end subroutine

  ! surface_segmented_pt_struct%dz_dy: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_dz_dy(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dy
  end subroutine


  subroutine surface_segmented_pt_struct_set_dz_dy(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dy = value_in
  end subroutine

  !! surface_segmented_struct

    function allocate_fortran_surface_segmented_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_segmented_struct), pointer :: fptr
      type(surface_segmented_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_segmented_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_segmented_struct), pointer :: fptr
      type(surface_segmented_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_segmented_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_segmented_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_segmented_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_segmented_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_segmented_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_segmented_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_segmented_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_segmented_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_segmented_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_segmented_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_segmented_struct%active: 0D_NOT_logical

  subroutine surface_segmented_struct_get_active(struct_obj_ptr, value_out) bind(c, name='surface_segmented_struct_get_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_segmented_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%active
  end subroutine


  subroutine surface_segmented_struct_set_active(struct_obj_ptr, value_in) bind(c, name='surface_segmented_struct_set_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_segmented_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%active = value_in
  end subroutine

  ! surface_segmented_struct%dr: 1D_NOT_real

  subroutine surface_segmented_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_segmented_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_segmented_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_segmented_struct%r0: 1D_NOT_real

  subroutine surface_segmented_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_segmented_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_segmented_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_segmented_struct%pt: 2D_ALLOC_type

  subroutine surface_segmented_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='surface_segmented_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_segmented_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! surface_h_misalign_pt_struct

    function allocate_fortran_surface_h_misalign_pt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_h_misalign_pt_struct), pointer :: fptr
      type(surface_h_misalign_pt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_h_misalign_pt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_h_misalign_pt_struct), pointer :: fptr
      type(surface_h_misalign_pt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_h_misalign_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_h_misalign_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_h_misalign_pt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_h_misalign_pt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_h_misalign_pt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_h_misalign_pt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_h_misalign_pt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_h_misalign_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_h_misalign_pt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_h_misalign_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_h_misalign_pt_struct%x0: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%y0: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_y: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_y(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_y
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_y(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_y = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_t: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_t(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_t
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_t(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_t = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_y_rms: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_y_rms(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_y_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_y_rms
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_y_rms(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_y_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_y_rms = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_t_rms: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_t_rms(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_t_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_t_rms
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_t_rms(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_t_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_t_rms = value_in
  end subroutine

  !! surface_h_misalign_struct

    function allocate_fortran_surface_h_misalign_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_h_misalign_struct), pointer :: fptr
      type(surface_h_misalign_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_h_misalign_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_h_misalign_struct), pointer :: fptr
      type(surface_h_misalign_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_h_misalign_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_h_misalign_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_h_misalign_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_h_misalign_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_h_misalign_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_h_misalign_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_h_misalign_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_h_misalign_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_h_misalign_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_h_misalign_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_h_misalign_struct%active: 0D_NOT_logical

  subroutine surface_h_misalign_struct_get_active(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_struct_get_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_h_misalign_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%active
  end subroutine


  subroutine surface_h_misalign_struct_set_active(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_struct_set_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_h_misalign_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%active = value_in
  end subroutine

  ! surface_h_misalign_struct%dr: 1D_NOT_real

  subroutine surface_h_misalign_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_h_misalign_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_h_misalign_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_h_misalign_struct%r0: 1D_NOT_real

  subroutine surface_h_misalign_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_h_misalign_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_h_misalign_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_h_misalign_struct%pt: 2D_ALLOC_type

  subroutine surface_h_misalign_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='surface_h_misalign_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_h_misalign_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! surface_displacement_pt_struct

    function allocate_fortran_surface_displacement_pt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_displacement_pt_struct), pointer :: fptr
      type(surface_displacement_pt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_displacement_pt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_displacement_pt_struct), pointer :: fptr
      type(surface_displacement_pt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_displacement_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_displacement_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_displacement_pt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_displacement_pt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_displacement_pt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_displacement_pt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_displacement_pt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_displacement_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_displacement_pt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_displacement_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_displacement_pt_struct%x0: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine surface_displacement_pt_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! surface_displacement_pt_struct%y0: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine surface_displacement_pt_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! surface_displacement_pt_struct%z0: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_z0(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z0
  end subroutine


  subroutine surface_displacement_pt_struct_set_z0(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z0 = value_in
  end subroutine

  ! surface_displacement_pt_struct%dz_dx: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_dz_dx(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dx
  end subroutine


  subroutine surface_displacement_pt_struct_set_dz_dx(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dx = value_in
  end subroutine

  ! surface_displacement_pt_struct%dz_dy: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_dz_dy(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dy
  end subroutine


  subroutine surface_displacement_pt_struct_set_dz_dy(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dy = value_in
  end subroutine

  ! surface_displacement_pt_struct%d2z_dxdy: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_d2z_dxdy(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_d2z_dxdy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%d2z_dxdy
  end subroutine


  subroutine surface_displacement_pt_struct_set_d2z_dxdy(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_d2z_dxdy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%d2z_dxdy = value_in
  end subroutine

  !! surface_displacement_struct

    function allocate_fortran_surface_displacement_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_displacement_struct), pointer :: fptr
      type(surface_displacement_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_displacement_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_displacement_struct), pointer :: fptr
      type(surface_displacement_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_displacement_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_displacement_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_displacement_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_displacement_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_displacement_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_displacement_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_displacement_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_displacement_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_displacement_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_displacement_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_displacement_struct%active: 0D_NOT_logical

  subroutine surface_displacement_struct_get_active(struct_obj_ptr, value_out) bind(c, name='surface_displacement_struct_get_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_displacement_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%active
  end subroutine


  subroutine surface_displacement_struct_set_active(struct_obj_ptr, value_in) bind(c, name='surface_displacement_struct_set_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_displacement_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%active = value_in
  end subroutine

  ! surface_displacement_struct%dr: 1D_NOT_real

  subroutine surface_displacement_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_displacement_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_displacement_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_displacement_struct%r0: 1D_NOT_real

  subroutine surface_displacement_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_displacement_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_displacement_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_displacement_struct%pt: 2D_ALLOC_type

  subroutine surface_displacement_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='surface_displacement_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_displacement_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! target_point_struct

    function allocate_fortran_target_point_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(target_point_struct), pointer :: fptr
      type(target_point_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_target_point_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(target_point_struct), pointer :: fptr
      type(target_point_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_target_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(target_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_target_point_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(target_point_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_target_point_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(target_point_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_target_point_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(target_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_target_point_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(target_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! target_point_struct%r: 1D_NOT_real

  subroutine target_point_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='target_point_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(target_point_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! surface_curvature_struct

    function allocate_fortran_surface_curvature_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(surface_curvature_struct), pointer :: fptr
      type(surface_curvature_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_surface_curvature_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(surface_curvature_struct), pointer :: fptr
      type(surface_curvature_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_surface_curvature_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_curvature_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_surface_curvature_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(surface_curvature_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_surface_curvature_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(surface_curvature_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_surface_curvature_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(surface_curvature_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_surface_curvature_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(surface_curvature_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! surface_curvature_struct%xy: 2D_NOT_real

  subroutine surface_curvature_struct_get_xy_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='surface_curvature_struct_get_xy_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_curvature_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%xy)) then
      data_ptr = c_loc(struct_obj%xy(lbound(struct_obj%xy, 1), lbound(struct_obj%xy, 2)))
      bounds(1) = int(lbound(struct_obj%xy, 1), c_int)
      bounds(2) = int(ubound(struct_obj%xy, 1), c_int)
      bounds(3) = int(lbound(struct_obj%xy, 2), c_int)
      bounds(4) = int(ubound(struct_obj%xy, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_curvature_struct%spherical: 0D_NOT_real

  subroutine surface_curvature_struct_get_spherical(struct_obj_ptr, value_out) bind(c, name='surface_curvature_struct_get_spherical')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spherical
  end subroutine


  subroutine surface_curvature_struct_set_spherical(struct_obj_ptr, value_in) bind(c, name='surface_curvature_struct_set_spherical')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spherical = value_in
  end subroutine

  ! surface_curvature_struct%elliptical: 1D_NOT_real

  subroutine surface_curvature_struct_get_elliptical_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_curvature_struct_get_elliptical_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_curvature_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%elliptical)) then
      data_ptr = c_loc(struct_obj%elliptical(lbound(struct_obj%elliptical, 1)))
      bounds(1) = int(lbound(struct_obj%elliptical, 1), c_int)
      bounds(2) = int(ubound(struct_obj%elliptical, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_curvature_struct%has_curvature: 0D_NOT_logical

  subroutine surface_curvature_struct_get_has_curvature(struct_obj_ptr, value_out) bind(c, name='surface_curvature_struct_get_has_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%has_curvature
  end subroutine


  subroutine surface_curvature_struct_set_has_curvature(struct_obj_ptr, value_in) bind(c, name='surface_curvature_struct_set_has_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%has_curvature = value_in
  end subroutine

  !! photon_target_struct

    function allocate_fortran_photon_target_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(photon_target_struct), pointer :: fptr
      type(photon_target_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_photon_target_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(photon_target_struct), pointer :: fptr
      type(photon_target_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_photon_target_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_target_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_photon_target_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(photon_target_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_photon_target_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(photon_target_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_photon_target_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(photon_target_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_photon_target_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(photon_target_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! photon_target_struct%type: 0D_NOT_integer

  subroutine photon_target_struct_get_type(struct_obj_ptr, value_out) bind(c, name='photon_target_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine photon_target_struct_set_type(struct_obj_ptr, value_in) bind(c, name='photon_target_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! photon_target_struct%n_corner: 0D_NOT_integer

  subroutine photon_target_struct_get_n_corner(struct_obj_ptr, value_out) bind(c, name='photon_target_struct_get_n_corner')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_corner
  end subroutine


  subroutine photon_target_struct_set_n_corner(struct_obj_ptr, value_in) bind(c, name='photon_target_struct_set_n_corner')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_corner = value_in
  end subroutine

  ! photon_target_struct%ele_loc: 0D_NOT_type

  subroutine photon_target_struct_get_ele_loc(struct_obj_ptr, ptr_out) bind(c, name='photon_target_struct_get_ele_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_loc)
  end subroutine


  subroutine photon_target_struct_set_ele_loc(struct_obj_ptr, src_ptr) bind(c, name='photon_target_struct_set_ele_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_target_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_loc = src_obj
  end subroutine

  ! photon_target_struct%corner: 1D_NOT_type

  subroutine photon_target_struct_get_corner_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_target_struct_get_corner_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_target_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%corner)) then
      data_ptr = c_loc(struct_obj%corner(lbound(struct_obj%corner, 1)))
      bounds(1) = int(lbound(struct_obj%corner, 1), c_int)
      bounds(2) = int(ubound(struct_obj%corner, 1), c_int)
      
      el_size = int(storage_size(struct_obj%corner(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_target_struct%center: 0D_NOT_type

  subroutine photon_target_struct_get_center(struct_obj_ptr, ptr_out) bind(c, name='photon_target_struct_get_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%center)
  end subroutine


  subroutine photon_target_struct_set_center(struct_obj_ptr, src_ptr) bind(c, name='photon_target_struct_set_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_target_struct), pointer :: struct_obj
    type(target_point_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%center = src_obj
  end subroutine

  !! photon_material_struct

    function allocate_fortran_photon_material_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(photon_material_struct), pointer :: fptr
      type(photon_material_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_photon_material_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(photon_material_struct), pointer :: fptr
      type(photon_material_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_photon_material_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_material_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_photon_material_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(photon_material_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_photon_material_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(photon_material_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_photon_material_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(photon_material_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_photon_material_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(photon_material_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! photon_material_struct%f0_m1: 0D_NOT_complex

  subroutine photon_material_struct_get_f0_m1(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f0_m1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f0_m1
  end subroutine


  subroutine photon_material_struct_set_f0_m1(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f0_m1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f0_m1 = value_in
  end subroutine

  ! photon_material_struct%f0_m2: 0D_NOT_complex

  subroutine photon_material_struct_get_f0_m2(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f0_m2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f0_m2
  end subroutine


  subroutine photon_material_struct_set_f0_m2(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f0_m2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f0_m2 = value_in
  end subroutine

  ! photon_material_struct%f_0: 0D_NOT_complex

  subroutine photon_material_struct_get_f_0(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_0
  end subroutine


  subroutine photon_material_struct_set_f_0(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_0 = value_in
  end subroutine

  ! photon_material_struct%f_h: 0D_NOT_complex

  subroutine photon_material_struct_get_f_h(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_h')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_h
  end subroutine


  subroutine photon_material_struct_set_f_h(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_h')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_h = value_in
  end subroutine

  ! photon_material_struct%f_hbar: 0D_NOT_complex

  subroutine photon_material_struct_get_f_hbar(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_hbar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_hbar
  end subroutine


  subroutine photon_material_struct_set_f_hbar(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_hbar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_hbar = value_in
  end subroutine

  ! photon_material_struct%f_hkl: 0D_NOT_complex

  subroutine photon_material_struct_get_f_hkl(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_hkl')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_hkl
  end subroutine


  subroutine photon_material_struct_set_f_hkl(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_hkl')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_hkl = value_in
  end subroutine

  ! photon_material_struct%h_norm: 1D_NOT_real

  subroutine photon_material_struct_get_h_norm_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_material_struct_get_h_norm_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_material_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%h_norm)) then
      data_ptr = c_loc(struct_obj%h_norm(lbound(struct_obj%h_norm, 1)))
      bounds(1) = int(lbound(struct_obj%h_norm, 1), c_int)
      bounds(2) = int(ubound(struct_obj%h_norm, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_material_struct%l_ref: 1D_NOT_real

  subroutine photon_material_struct_get_l_ref_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_material_struct_get_l_ref_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_material_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%l_ref)) then
      data_ptr = c_loc(struct_obj%l_ref(lbound(struct_obj%l_ref, 1)))
      bounds(1) = int(lbound(struct_obj%l_ref, 1), c_int)
      bounds(2) = int(ubound(struct_obj%l_ref, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! pixel_pt_struct

    function allocate_fortran_pixel_pt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(pixel_pt_struct), pointer :: fptr
      type(pixel_pt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_pixel_pt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(pixel_pt_struct), pointer :: fptr
      type(pixel_pt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_pixel_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(pixel_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_pixel_pt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(pixel_pt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_pixel_pt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(pixel_pt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_pixel_pt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(pixel_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_pixel_pt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(pixel_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! pixel_pt_struct%n_photon: 0D_NOT_integer8

  subroutine pixel_pt_struct_get_n_photon(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_n_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_photon
  end subroutine


  subroutine pixel_pt_struct_set_n_photon(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_n_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_photon = value_in
  end subroutine

  ! pixel_pt_struct%E_x: 0D_NOT_complex

  subroutine pixel_pt_struct_get_E_x(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_E_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_x
  end subroutine


  subroutine pixel_pt_struct_set_E_x(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_E_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_x = value_in
  end subroutine

  ! pixel_pt_struct%E_y: 0D_NOT_complex

  subroutine pixel_pt_struct_get_E_y(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_E_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_y
  end subroutine


  subroutine pixel_pt_struct_set_E_y(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_E_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_y = value_in
  end subroutine

  ! pixel_pt_struct%intensity_x: 0D_NOT_real

  subroutine pixel_pt_struct_get_intensity_x(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_intensity_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%intensity_x
  end subroutine


  subroutine pixel_pt_struct_set_intensity_x(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_intensity_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%intensity_x = value_in
  end subroutine

  ! pixel_pt_struct%intensity_y: 0D_NOT_real

  subroutine pixel_pt_struct_get_intensity_y(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_intensity_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%intensity_y
  end subroutine


  subroutine pixel_pt_struct_set_intensity_y(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_intensity_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%intensity_y = value_in
  end subroutine

  ! pixel_pt_struct%intensity: 0D_NOT_real

  subroutine pixel_pt_struct_get_intensity(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_intensity')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%intensity
  end subroutine


  subroutine pixel_pt_struct_set_intensity(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_intensity')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%intensity = value_in
  end subroutine

  ! pixel_pt_struct%orbit: 1D_NOT_real

  subroutine pixel_pt_struct_get_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%orbit)) then
      data_ptr = c_loc(struct_obj%orbit(lbound(struct_obj%orbit, 1)))
      bounds(1) = int(lbound(struct_obj%orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_pt_struct%orbit_rms: 1D_NOT_real

  subroutine pixel_pt_struct_get_orbit_rms_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_orbit_rms_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%orbit_rms)) then
      data_ptr = c_loc(struct_obj%orbit_rms(lbound(struct_obj%orbit_rms, 1)))
      bounds(1) = int(lbound(struct_obj%orbit_rms, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit_rms, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_pt_struct%init_orbit: 1D_NOT_real

  subroutine pixel_pt_struct_get_init_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_init_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%init_orbit)) then
      data_ptr = c_loc(struct_obj%init_orbit(lbound(struct_obj%init_orbit, 1)))
      bounds(1) = int(lbound(struct_obj%init_orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%init_orbit, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_pt_struct%init_orbit_rms: 1D_NOT_real

  subroutine pixel_pt_struct_get_init_orbit_rms_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_init_orbit_rms_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%init_orbit_rms)) then
      data_ptr = c_loc(struct_obj%init_orbit_rms(lbound(struct_obj%init_orbit_rms, 1)))
      bounds(1) = int(lbound(struct_obj%init_orbit_rms, 1), c_int)
      bounds(2) = int(ubound(struct_obj%init_orbit_rms, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! pixel_detec_struct

    function allocate_fortran_pixel_detec_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(pixel_detec_struct), pointer :: fptr
      type(pixel_detec_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_pixel_detec_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(pixel_detec_struct), pointer :: fptr
      type(pixel_detec_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_pixel_detec_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(pixel_detec_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_pixel_detec_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(pixel_detec_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_pixel_detec_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(pixel_detec_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_pixel_detec_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(pixel_detec_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_pixel_detec_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(pixel_detec_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! pixel_detec_struct%dr: 1D_NOT_real

  subroutine pixel_detec_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_detec_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_detec_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_detec_struct%r0: 1D_NOT_real

  subroutine pixel_detec_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_detec_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_detec_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_detec_struct%n_track_tot: 0D_NOT_integer8

  subroutine pixel_detec_struct_get_n_track_tot(struct_obj_ptr, value_out) bind(c, name='pixel_detec_struct_get_n_track_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_track_tot
  end subroutine


  subroutine pixel_detec_struct_set_n_track_tot(struct_obj_ptr, value_in) bind(c, name='pixel_detec_struct_set_n_track_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_track_tot = value_in
  end subroutine

  ! pixel_detec_struct%n_hit_detec: 0D_NOT_integer8

  subroutine pixel_detec_struct_get_n_hit_detec(struct_obj_ptr, value_out) bind(c, name='pixel_detec_struct_get_n_hit_detec')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_hit_detec
  end subroutine


  subroutine pixel_detec_struct_set_n_hit_detec(struct_obj_ptr, value_in) bind(c, name='pixel_detec_struct_set_n_hit_detec')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_hit_detec = value_in
  end subroutine

  ! pixel_detec_struct%n_hit_pixel: 0D_NOT_integer8

  subroutine pixel_detec_struct_get_n_hit_pixel(struct_obj_ptr, value_out) bind(c, name='pixel_detec_struct_get_n_hit_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_hit_pixel
  end subroutine


  subroutine pixel_detec_struct_set_n_hit_pixel(struct_obj_ptr, value_in) bind(c, name='pixel_detec_struct_set_n_hit_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_hit_pixel = value_in
  end subroutine

  ! pixel_detec_struct%pt: 2D_ALLOC_type

  subroutine pixel_detec_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='pixel_detec_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_detec_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! photon_element_struct

    function allocate_fortran_photon_element_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(photon_element_struct), pointer :: fptr
      type(photon_element_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_photon_element_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(photon_element_struct), pointer :: fptr
      type(photon_element_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_photon_element_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_element_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_photon_element_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(photon_element_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_photon_element_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(photon_element_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_photon_element_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(photon_element_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_photon_element_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(photon_element_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! photon_element_struct%curvature: 0D_NOT_type

  subroutine photon_element_struct_get_curvature(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%curvature)
  end subroutine


  subroutine photon_element_struct_set_curvature(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_curvature_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%curvature = src_obj
  end subroutine

  ! photon_element_struct%target: 0D_NOT_type

  subroutine photon_element_struct_get_target(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_target')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%target)
  end subroutine


  subroutine photon_element_struct_set_target(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_target')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_target_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%target = src_obj
  end subroutine

  ! photon_element_struct%material: 0D_NOT_type

  subroutine photon_element_struct_get_material(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%material)
  end subroutine


  subroutine photon_element_struct_set_material(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_material_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%material = src_obj
  end subroutine

  ! photon_element_struct%segmented: 0D_NOT_type

  subroutine photon_element_struct_get_segmented(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_segmented')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%segmented)
  end subroutine


  subroutine photon_element_struct_set_segmented(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_segmented')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_segmented_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%segmented = src_obj
  end subroutine

  ! photon_element_struct%h_misalign: 0D_NOT_type

  subroutine photon_element_struct_get_h_misalign(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_h_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%h_misalign)
  end subroutine


  subroutine photon_element_struct_set_h_misalign(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_h_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_h_misalign_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%h_misalign = src_obj
  end subroutine

  ! photon_element_struct%displacement: 0D_NOT_type

  subroutine photon_element_struct_get_displacement(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_displacement')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%displacement)
  end subroutine


  subroutine photon_element_struct_set_displacement(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_displacement')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_displacement_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%displacement = src_obj
  end subroutine

  ! photon_element_struct%pixel: 0D_NOT_type

  subroutine photon_element_struct_get_pixel(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%pixel)
  end subroutine


  subroutine photon_element_struct_set_pixel(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(pixel_detec_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%pixel = src_obj
  end subroutine

  ! photon_element_struct%reflectivity_table_type: 0D_NOT_integer

  subroutine photon_element_struct_get_reflectivity_table_type(struct_obj_ptr, value_out) bind(c, name='photon_element_struct_get_reflectivity_table_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%reflectivity_table_type
  end subroutine


  subroutine photon_element_struct_set_reflectivity_table_type(struct_obj_ptr, value_in) bind(c, name='photon_element_struct_set_reflectivity_table_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%reflectivity_table_type = value_in
  end subroutine

  ! photon_element_struct%reflectivity_table_sigma: 0D_NOT_type

  subroutine photon_element_struct_get_reflectivity_table_sigma(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_reflectivity_table_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%reflectivity_table_sigma)
  end subroutine


  subroutine photon_element_struct_set_reflectivity_table_sigma(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_reflectivity_table_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_reflect_table_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%reflectivity_table_sigma = src_obj
  end subroutine

  ! photon_element_struct%reflectivity_table_pi: 0D_NOT_type

  subroutine photon_element_struct_get_reflectivity_table_pi(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_reflectivity_table_pi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%reflectivity_table_pi)
  end subroutine


  subroutine photon_element_struct_set_reflectivity_table_pi(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_reflectivity_table_pi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_reflect_table_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%reflectivity_table_pi = src_obj
  end subroutine

  ! photon_element_struct%init_energy_prob: 1D_ALLOC_type

  subroutine photon_element_struct_get_init_energy_prob_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_element_struct_get_init_energy_prob_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_element_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%init_energy_prob) .and. is_contiguous(struct_obj%init_energy_prob)) then
      data_ptr = c_loc(struct_obj%init_energy_prob(lbound(struct_obj%init_energy_prob, 1)))
      bounds(1) = int(lbound(struct_obj%init_energy_prob, 1), c_int)
      bounds(2) = int(ubound(struct_obj%init_energy_prob, 1), c_int)
      
      el_size = int(storage_size(struct_obj%init_energy_prob(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_element_struct%integrated_init_energy_prob: 1D_ALLOC_real

  subroutine photon_element_struct_get_integrated_init_energy_prob_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_element_struct_get_integrated_init_energy_prob_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_element_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%integrated_init_energy_prob) .and. is_contiguous(struct_obj%integrated_init_energy_prob)) then
      data_ptr = c_loc(struct_obj%integrated_init_energy_prob(lbound(struct_obj%integrated_init_energy_prob, 1)))
      bounds(1) = int(lbound(struct_obj%integrated_init_energy_prob, 1), c_int)
      bounds(2) = int(ubound(struct_obj%integrated_init_energy_prob, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! wall3d_vertex_struct

    function allocate_fortran_wall3d_vertex_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wall3d_vertex_struct), pointer :: fptr
      type(wall3d_vertex_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wall3d_vertex_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wall3d_vertex_struct), pointer :: fptr
      type(wall3d_vertex_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wall3d_vertex_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wall3d_vertex_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wall3d_vertex_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wall3d_vertex_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wall3d_vertex_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wall3d_vertex_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wall3d_vertex_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wall3d_vertex_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wall3d_vertex_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wall3d_vertex_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wall3d_vertex_struct%x: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_x(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine wall3d_vertex_struct_set_x(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! wall3d_vertex_struct%y: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_y(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine wall3d_vertex_struct_set_y(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! wall3d_vertex_struct%radius_x: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_radius_x(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_radius_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radius_x
  end subroutine


  subroutine wall3d_vertex_struct_set_radius_x(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_radius_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radius_x = value_in
  end subroutine

  ! wall3d_vertex_struct%radius_y: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_radius_y(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_radius_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radius_y
  end subroutine


  subroutine wall3d_vertex_struct_set_radius_y(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_radius_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radius_y = value_in
  end subroutine

  ! wall3d_vertex_struct%tilt: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_tilt(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_tilt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tilt
  end subroutine


  subroutine wall3d_vertex_struct_set_tilt(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_tilt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tilt = value_in
  end subroutine

  ! wall3d_vertex_struct%angle: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_angle(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%angle
  end subroutine


  subroutine wall3d_vertex_struct_set_angle(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%angle = value_in
  end subroutine

  ! wall3d_vertex_struct%x0: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine wall3d_vertex_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! wall3d_vertex_struct%y0: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine wall3d_vertex_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! wall3d_vertex_struct%type: 0D_NOT_integer

  subroutine wall3d_vertex_struct_get_type(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine wall3d_vertex_struct_set_type(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  !! wall3d_section_struct

    function allocate_fortran_wall3d_section_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wall3d_section_struct), pointer :: fptr
      type(wall3d_section_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wall3d_section_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wall3d_section_struct), pointer :: fptr
      type(wall3d_section_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wall3d_section_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wall3d_section_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wall3d_section_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wall3d_section_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wall3d_section_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wall3d_section_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wall3d_section_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wall3d_section_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wall3d_section_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wall3d_section_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wall3d_section_struct%name: 0D_NOT_character

  subroutine wall3d_section_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_section_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_section_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_section_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_section_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_section_struct%material: 0D_NOT_character

  subroutine wall3d_section_struct_get_material_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_section_struct_get_material_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%material)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%material), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_section_struct_set_material(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_section_struct_set_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_section_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%material = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_section_struct%v: 1D_ALLOC_type

  subroutine wall3d_section_struct_get_v_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wall3d_section_struct_get_v_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%v) .and. is_contiguous(struct_obj%v)) then
      data_ptr = c_loc(struct_obj%v(lbound(struct_obj%v, 1)))
      bounds(1) = int(lbound(struct_obj%v, 1), c_int)
      bounds(2) = int(ubound(struct_obj%v, 1), c_int)
      
      el_size = int(storage_size(struct_obj%v(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%surface: 0D_PTR_type

  subroutine wall3d_section_struct_get_surface(struct_obj_ptr, ptr_out) bind(c, name='wall3d_section_struct_get_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%surface)) then
      ptr_out = c_loc(struct_obj%surface)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine wall3d_section_struct_set_surface(struct_obj_ptr, src_ptr) bind(c, name='wall3d_section_struct_set_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wall3d_section_struct), pointer :: struct_obj
    type(photon_reflect_surface_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%surface)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%surface = src_obj
    endif
  end subroutine

  ! wall3d_section_struct%type: 0D_NOT_integer

  subroutine wall3d_section_struct_get_type(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine wall3d_section_struct_set_type(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! wall3d_section_struct%n_vertex_input: 0D_NOT_integer

  subroutine wall3d_section_struct_get_n_vertex_input(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_n_vertex_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_vertex_input
  end subroutine


  subroutine wall3d_section_struct_set_n_vertex_input(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_n_vertex_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_vertex_input = value_in
  end subroutine

  ! wall3d_section_struct%ix_ele: 0D_NOT_integer

  subroutine wall3d_section_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine wall3d_section_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! wall3d_section_struct%ix_branch: 0D_NOT_integer

  subroutine wall3d_section_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine wall3d_section_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! wall3d_section_struct%vertices_state: 0D_NOT_integer

  subroutine wall3d_section_struct_get_vertices_state(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_vertices_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%vertices_state
  end subroutine


  subroutine wall3d_section_struct_set_vertices_state(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_vertices_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%vertices_state = value_in
  end subroutine

  ! wall3d_section_struct%patch_in_region: 0D_NOT_logical

  subroutine wall3d_section_struct_get_patch_in_region(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_patch_in_region')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%patch_in_region
  end subroutine


  subroutine wall3d_section_struct_set_patch_in_region(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_patch_in_region')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%patch_in_region = value_in
  end subroutine

  ! wall3d_section_struct%thickness: 0D_NOT_real

  subroutine wall3d_section_struct_get_thickness(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%thickness
  end subroutine


  subroutine wall3d_section_struct_set_thickness(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%thickness = value_in
  end subroutine

  ! wall3d_section_struct%s: 0D_NOT_real

  subroutine wall3d_section_struct_get_s(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine wall3d_section_struct_set_s(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! wall3d_section_struct%r0: 1D_NOT_real

  subroutine wall3d_section_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%dx0_ds: 0D_NOT_real

  subroutine wall3d_section_struct_get_dx0_ds(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_dx0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dx0_ds
  end subroutine


  subroutine wall3d_section_struct_set_dx0_ds(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_dx0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dx0_ds = value_in
  end subroutine

  ! wall3d_section_struct%dy0_ds: 0D_NOT_real

  subroutine wall3d_section_struct_get_dy0_ds(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_dy0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dy0_ds
  end subroutine


  subroutine wall3d_section_struct_set_dy0_ds(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_dy0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dy0_ds = value_in
  end subroutine

  ! wall3d_section_struct%x0_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_x0_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_x0_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%x0_coef)) then
      data_ptr = c_loc(struct_obj%x0_coef(lbound(struct_obj%x0_coef, 1)))
      bounds(1) = int(lbound(struct_obj%x0_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x0_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%y0_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_y0_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_y0_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%y0_coef)) then
      data_ptr = c_loc(struct_obj%y0_coef(lbound(struct_obj%y0_coef, 1)))
      bounds(1) = int(lbound(struct_obj%y0_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y0_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%dr_ds: 0D_NOT_real

  subroutine wall3d_section_struct_get_dr_ds(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_dr_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dr_ds
  end subroutine


  subroutine wall3d_section_struct_set_dr_ds(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_dr_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dr_ds = value_in
  end subroutine

  ! wall3d_section_struct%p1_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_p1_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_p1_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%p1_coef)) then
      data_ptr = c_loc(struct_obj%p1_coef(lbound(struct_obj%p1_coef, 1)))
      bounds(1) = int(lbound(struct_obj%p1_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p1_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%p2_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_p2_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_p2_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%p2_coef)) then
      data_ptr = c_loc(struct_obj%p2_coef(lbound(struct_obj%p2_coef, 1)))
      bounds(1) = int(lbound(struct_obj%p2_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p2_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! wall3d_struct

    function allocate_fortran_wall3d_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(wall3d_struct), pointer :: fptr
      type(wall3d_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_wall3d_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(wall3d_struct), pointer :: fptr
      type(wall3d_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_wall3d_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wall3d_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_wall3d_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(wall3d_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_wall3d_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(wall3d_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_wall3d_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(wall3d_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_wall3d_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(wall3d_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! wall3d_struct%name: 0D_NOT_character

  subroutine wall3d_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_struct%type: 0D_NOT_integer

  subroutine wall3d_struct_get_type(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine wall3d_struct_set_type(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! wall3d_struct%ix_wall3d: 0D_NOT_integer

  subroutine wall3d_struct_get_ix_wall3d(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_ix_wall3d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_wall3d
  end subroutine


  subroutine wall3d_struct_set_ix_wall3d(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_ix_wall3d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_wall3d = value_in
  end subroutine

  ! wall3d_struct%n_link: 0D_NOT_integer

  subroutine wall3d_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine wall3d_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! wall3d_struct%thickness: 0D_NOT_real

  subroutine wall3d_struct_get_thickness(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%thickness
  end subroutine


  subroutine wall3d_struct_set_thickness(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%thickness = value_in
  end subroutine

  ! wall3d_struct%clear_material: 0D_NOT_character

  subroutine wall3d_struct_get_clear_material_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_struct_get_clear_material_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%clear_material)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%clear_material), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_struct_set_clear_material(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_struct_set_clear_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%clear_material = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_struct%opaque_material: 0D_NOT_character

  subroutine wall3d_struct_get_opaque_material_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_struct_get_opaque_material_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%opaque_material)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%opaque_material), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_struct_set_opaque_material(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_struct_set_opaque_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%opaque_material = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_struct%superimpose: 0D_NOT_logical

  subroutine wall3d_struct_get_superimpose(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_superimpose')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%superimpose
  end subroutine


  subroutine wall3d_struct_set_superimpose(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_superimpose')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%superimpose = value_in
  end subroutine

  ! wall3d_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine wall3d_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine wall3d_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! wall3d_struct%section: 1D_ALLOC_type

  subroutine wall3d_struct_get_section_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wall3d_struct_get_section_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%section) .and. is_contiguous(struct_obj%section)) then
      data_ptr = c_loc(struct_obj%section(lbound(struct_obj%section, 1)))
      bounds(1) = int(lbound(struct_obj%section, 1), c_int)
      bounds(2) = int(ubound(struct_obj%section, 1), c_int)
      
      el_size = int(storage_size(struct_obj%section(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! ramper_lord_struct

    function allocate_fortran_ramper_lord_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ramper_lord_struct), pointer :: fptr
      type(ramper_lord_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ramper_lord_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ramper_lord_struct), pointer :: fptr
      type(ramper_lord_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ramper_lord_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ramper_lord_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ramper_lord_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ramper_lord_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ramper_lord_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ramper_lord_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ramper_lord_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ramper_lord_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ramper_lord_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ramper_lord_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ramper_lord_struct%ix_ele: 0D_NOT_integer

  subroutine ramper_lord_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='ramper_lord_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine ramper_lord_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='ramper_lord_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! ramper_lord_struct%ix_con: 0D_NOT_integer

  subroutine ramper_lord_struct_get_ix_con(struct_obj_ptr, value_out) bind(c, name='ramper_lord_struct_get_ix_con')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_con
  end subroutine


  subroutine ramper_lord_struct_set_ix_con(struct_obj_ptr, value_in) bind(c, name='ramper_lord_struct_set_ix_con')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_con = value_in
  end subroutine

  ! ramper_lord_struct%attrib_ptr: 0D_PTR_real

  subroutine ramper_lord_struct_get_attrib_ptr(struct_obj_ptr, ptr_out) bind(c, name='ramper_lord_struct_get_attrib_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%attrib_ptr)) then
      ptr_out = c_loc(struct_obj%attrib_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ramper_lord_struct_set_attrib_ptr(struct_obj_ptr, value_in) bind(c, name='ramper_lord_struct_set_attrib_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%attrib_ptr)) then
      struct_obj%attrib_ptr = value_in
    endif
  end subroutine

  !! control_struct

    function allocate_fortran_control_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(control_struct), pointer :: fptr
      type(control_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_control_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(control_struct), pointer :: fptr
      type(control_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_control_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(control_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_control_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(control_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_control_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(control_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_control_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(control_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_control_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(control_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! control_struct%value: 0D_NOT_real

  subroutine control_struct_get_value(struct_obj_ptr, value_out) bind(c, name='control_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine control_struct_set_value(struct_obj_ptr, value_in) bind(c, name='control_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  ! control_struct%y_knot: 1D_ALLOC_real

  subroutine control_struct_get_y_knot_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='control_struct_get_y_knot_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%y_knot) .and. is_contiguous(struct_obj%y_knot)) then
      data_ptr = c_loc(struct_obj%y_knot(lbound(struct_obj%y_knot, 1)))
      bounds(1) = int(lbound(struct_obj%y_knot, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y_knot, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! control_struct%stack: 1D_ALLOC_type

  subroutine control_struct_get_stack_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='control_struct_get_stack_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%stack) .and. is_contiguous(struct_obj%stack)) then
      data_ptr = c_loc(struct_obj%stack(lbound(struct_obj%stack, 1)))
      bounds(1) = int(lbound(struct_obj%stack, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stack, 1), c_int)
      
      el_size = int(storage_size(struct_obj%stack(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! control_struct%slave: 0D_NOT_type

  subroutine control_struct_get_slave(struct_obj_ptr, ptr_out) bind(c, name='control_struct_get_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%slave)
  end subroutine


  subroutine control_struct_set_slave(struct_obj_ptr, src_ptr) bind(c, name='control_struct_set_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(control_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%slave = src_obj
  end subroutine

  ! control_struct%lord: 0D_NOT_type

  subroutine control_struct_get_lord(struct_obj_ptr, ptr_out) bind(c, name='control_struct_get_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lord)
  end subroutine


  subroutine control_struct_set_lord(struct_obj_ptr, src_ptr) bind(c, name='control_struct_set_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(control_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lord = src_obj
  end subroutine

  ! control_struct%slave_name: 0D_NOT_character

  subroutine control_struct_get_slave_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_struct_get_slave_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%slave_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%slave_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_struct_set_slave_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_struct_set_slave_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%slave_name = str_in ! implicitly handles padding
  end subroutine

  ! control_struct%attribute: 0D_NOT_character

  subroutine control_struct_get_attribute_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_struct_get_attribute_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%attribute)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%attribute), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_struct_set_attribute(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_struct_set_attribute')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%attribute = str_in ! implicitly handles padding
  end subroutine

  ! control_struct%ix_attrib: 0D_NOT_integer

  subroutine control_struct_get_ix_attrib(struct_obj_ptr, value_out) bind(c, name='control_struct_get_ix_attrib')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_attrib
  end subroutine


  subroutine control_struct_set_ix_attrib(struct_obj_ptr, value_in) bind(c, name='control_struct_set_ix_attrib')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_attrib = value_in
  end subroutine

  !! control_var1_struct

    function allocate_fortran_control_var1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(control_var1_struct), pointer :: fptr
      type(control_var1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_control_var1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(control_var1_struct), pointer :: fptr
      type(control_var1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_control_var1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(control_var1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_control_var1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(control_var1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_control_var1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(control_var1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_control_var1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(control_var1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_control_var1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(control_var1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! control_var1_struct%name: 0D_NOT_character

  subroutine control_var1_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_var1_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_var1_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_var1_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_var1_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! control_var1_struct%value: 0D_NOT_real

  subroutine control_var1_struct_get_value(struct_obj_ptr, value_out) bind(c, name='control_var1_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine control_var1_struct_set_value(struct_obj_ptr, value_in) bind(c, name='control_var1_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  ! control_var1_struct%old_value: 0D_NOT_real

  subroutine control_var1_struct_get_old_value(struct_obj_ptr, value_out) bind(c, name='control_var1_struct_get_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%old_value
  end subroutine


  subroutine control_var1_struct_set_old_value(struct_obj_ptr, value_in) bind(c, name='control_var1_struct_set_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%old_value = value_in
  end subroutine

  !! control_ramp1_struct

    function allocate_fortran_control_ramp1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(control_ramp1_struct), pointer :: fptr
      type(control_ramp1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_control_ramp1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(control_ramp1_struct), pointer :: fptr
      type(control_ramp1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_control_ramp1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(control_ramp1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_control_ramp1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(control_ramp1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_control_ramp1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(control_ramp1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_control_ramp1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(control_ramp1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_control_ramp1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(control_ramp1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! control_ramp1_struct%y_knot: 1D_ALLOC_real

  subroutine control_ramp1_struct_get_y_knot_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='control_ramp1_struct_get_y_knot_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%y_knot) .and. is_contiguous(struct_obj%y_knot)) then
      data_ptr = c_loc(struct_obj%y_knot(lbound(struct_obj%y_knot, 1)))
      bounds(1) = int(lbound(struct_obj%y_knot, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y_knot, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! control_ramp1_struct%stack: 1D_ALLOC_type

  subroutine control_ramp1_struct_get_stack_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='control_ramp1_struct_get_stack_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%stack) .and. is_contiguous(struct_obj%stack)) then
      data_ptr = c_loc(struct_obj%stack(lbound(struct_obj%stack, 1)))
      bounds(1) = int(lbound(struct_obj%stack, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stack, 1), c_int)
      
      el_size = int(storage_size(struct_obj%stack(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! control_ramp1_struct%attribute: 0D_NOT_character

  subroutine control_ramp1_struct_get_attribute_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_ramp1_struct_get_attribute_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%attribute)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%attribute), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_ramp1_struct_set_attribute(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_ramp1_struct_set_attribute')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_ramp1_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%attribute = str_in ! implicitly handles padding
  end subroutine

  ! control_ramp1_struct%slave_name: 0D_NOT_character

  subroutine control_ramp1_struct_get_slave_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_ramp1_struct_get_slave_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%slave_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%slave_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_ramp1_struct_set_slave_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_ramp1_struct_set_slave_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_ramp1_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%slave_name = str_in ! implicitly handles padding
  end subroutine

  ! control_ramp1_struct%is_controller: 0D_NOT_logical

  subroutine control_ramp1_struct_get_is_controller(struct_obj_ptr, value_out) bind(c, name='control_ramp1_struct_get_is_controller')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_controller
  end subroutine


  subroutine control_ramp1_struct_set_is_controller(struct_obj_ptr, value_in) bind(c, name='control_ramp1_struct_set_is_controller')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_controller = value_in
  end subroutine

  !! controller_struct

    function allocate_fortran_controller_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(controller_struct), pointer :: fptr
      type(controller_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_controller_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(controller_struct), pointer :: fptr
      type(controller_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_controller_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(controller_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_controller_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(controller_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_controller_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(controller_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_controller_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(controller_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_controller_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(controller_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! controller_struct%var: 1D_ALLOC_type

  subroutine controller_struct_get_var_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='controller_struct_get_var_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%var) .and. is_contiguous(struct_obj%var)) then
      data_ptr = c_loc(struct_obj%var(lbound(struct_obj%var, 1)))
      bounds(1) = int(lbound(struct_obj%var, 1), c_int)
      bounds(2) = int(ubound(struct_obj%var, 1), c_int)
      
      el_size = int(storage_size(struct_obj%var(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! controller_struct%ramp: 1D_ALLOC_type

  subroutine controller_struct_get_ramp_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='controller_struct_get_ramp_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ramp) .and. is_contiguous(struct_obj%ramp)) then
      data_ptr = c_loc(struct_obj%ramp(lbound(struct_obj%ramp, 1)))
      bounds(1) = int(lbound(struct_obj%ramp, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ramp, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ramp(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! controller_struct%ramper_lord: 1D_ALLOC_type

  subroutine controller_struct_get_ramper_lord_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='controller_struct_get_ramper_lord_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ramper_lord) .and. is_contiguous(struct_obj%ramper_lord)) then
      data_ptr = c_loc(struct_obj%ramper_lord(lbound(struct_obj%ramper_lord, 1)))
      bounds(1) = int(lbound(struct_obj%ramper_lord, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ramper_lord, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ramper_lord(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! controller_struct%x_knot: 1D_ALLOC_real

  subroutine controller_struct_get_x_knot_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='controller_struct_get_x_knot_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%x_knot) .and. is_contiguous(struct_obj%x_knot)) then
      data_ptr = c_loc(struct_obj%x_knot(lbound(struct_obj%x_knot, 1)))
      bounds(1) = int(lbound(struct_obj%x_knot, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x_knot, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! ellipse_beam_init_struct

    function allocate_fortran_ellipse_beam_init_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ellipse_beam_init_struct), pointer :: fptr
      type(ellipse_beam_init_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ellipse_beam_init_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ellipse_beam_init_struct), pointer :: fptr
      type(ellipse_beam_init_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ellipse_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ellipse_beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ellipse_beam_init_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ellipse_beam_init_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ellipse_beam_init_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ellipse_beam_init_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ellipse_beam_init_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ellipse_beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ellipse_beam_init_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ellipse_beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ellipse_beam_init_struct%part_per_ellipse: 0D_NOT_integer

  subroutine ellipse_beam_init_struct_get_part_per_ellipse(struct_obj_ptr, value_out) bind(c, name='ellipse_beam_init_struct_get_part_per_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%part_per_ellipse
  end subroutine


  subroutine ellipse_beam_init_struct_set_part_per_ellipse(struct_obj_ptr, value_in) bind(c, name='ellipse_beam_init_struct_set_part_per_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%part_per_ellipse = value_in
  end subroutine

  ! ellipse_beam_init_struct%n_ellipse: 0D_NOT_integer

  subroutine ellipse_beam_init_struct_get_n_ellipse(struct_obj_ptr, value_out) bind(c, name='ellipse_beam_init_struct_get_n_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ellipse
  end subroutine


  subroutine ellipse_beam_init_struct_set_n_ellipse(struct_obj_ptr, value_in) bind(c, name='ellipse_beam_init_struct_set_n_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ellipse = value_in
  end subroutine

  ! ellipse_beam_init_struct%sigma_cutoff: 0D_NOT_real

  subroutine ellipse_beam_init_struct_get_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='ellipse_beam_init_struct_get_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_cutoff
  end subroutine


  subroutine ellipse_beam_init_struct_set_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='ellipse_beam_init_struct_set_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_cutoff = value_in
  end subroutine

  !! kv_beam_init_struct

    function allocate_fortran_kv_beam_init_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(kv_beam_init_struct), pointer :: fptr
      type(kv_beam_init_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_kv_beam_init_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(kv_beam_init_struct), pointer :: fptr
      type(kv_beam_init_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_kv_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(kv_beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_kv_beam_init_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(kv_beam_init_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_kv_beam_init_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(kv_beam_init_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_kv_beam_init_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(kv_beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_kv_beam_init_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(kv_beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! kv_beam_init_struct%part_per_phi: 1D_NOT_integer

  subroutine kv_beam_init_struct_get_part_per_phi_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='kv_beam_init_struct_get_part_per_phi_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(kv_beam_init_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%part_per_phi)) then
      data_ptr = c_loc(struct_obj%part_per_phi(lbound(struct_obj%part_per_phi, 1)))
      bounds(1) = int(lbound(struct_obj%part_per_phi, 1), c_int)
      bounds(2) = int(ubound(struct_obj%part_per_phi, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! kv_beam_init_struct%n_I2: 0D_NOT_integer

  subroutine kv_beam_init_struct_get_n_I2(struct_obj_ptr, value_out) bind(c, name='kv_beam_init_struct_get_n_I2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_I2
  end subroutine


  subroutine kv_beam_init_struct_set_n_I2(struct_obj_ptr, value_in) bind(c, name='kv_beam_init_struct_set_n_I2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_I2 = value_in
  end subroutine

  ! kv_beam_init_struct%A: 0D_NOT_real

  subroutine kv_beam_init_struct_get_A(struct_obj_ptr, value_out) bind(c, name='kv_beam_init_struct_get_A')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%A
  end subroutine


  subroutine kv_beam_init_struct_set_A(struct_obj_ptr, value_in) bind(c, name='kv_beam_init_struct_set_A')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%A = value_in
  end subroutine

  !! grid_beam_init_struct

    function allocate_fortran_grid_beam_init_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(grid_beam_init_struct), pointer :: fptr
      type(grid_beam_init_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_grid_beam_init_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(grid_beam_init_struct), pointer :: fptr
      type(grid_beam_init_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_grid_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_grid_beam_init_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(grid_beam_init_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_grid_beam_init_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(grid_beam_init_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_grid_beam_init_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(grid_beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_grid_beam_init_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(grid_beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! grid_beam_init_struct%n_x: 0D_NOT_integer

  subroutine grid_beam_init_struct_get_n_x(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_n_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_x
  end subroutine


  subroutine grid_beam_init_struct_set_n_x(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_n_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_x = value_in
  end subroutine

  ! grid_beam_init_struct%n_px: 0D_NOT_integer

  subroutine grid_beam_init_struct_get_n_px(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_n_px')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_px
  end subroutine


  subroutine grid_beam_init_struct_set_n_px(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_n_px')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_px = value_in
  end subroutine

  ! grid_beam_init_struct%x_min: 0D_NOT_real

  subroutine grid_beam_init_struct_get_x_min(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_min
  end subroutine


  subroutine grid_beam_init_struct_set_x_min(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_min = value_in
  end subroutine

  ! grid_beam_init_struct%x_max: 0D_NOT_real

  subroutine grid_beam_init_struct_get_x_max(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_max
  end subroutine


  subroutine grid_beam_init_struct_set_x_max(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_max = value_in
  end subroutine

  ! grid_beam_init_struct%px_min: 0D_NOT_real

  subroutine grid_beam_init_struct_get_px_min(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_px_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%px_min
  end subroutine


  subroutine grid_beam_init_struct_set_px_min(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_px_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%px_min = value_in
  end subroutine

  ! grid_beam_init_struct%px_max: 0D_NOT_real

  subroutine grid_beam_init_struct_get_px_max(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_px_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%px_max
  end subroutine


  subroutine grid_beam_init_struct_set_px_max(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_px_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%px_max = value_in
  end subroutine

  !! beam_init_struct

    function allocate_fortran_beam_init_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(beam_init_struct), pointer :: fptr
      type(beam_init_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_beam_init_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(beam_init_struct), pointer :: fptr
      type(beam_init_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_beam_init_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(beam_init_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_beam_init_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(beam_init_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_beam_init_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_beam_init_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(beam_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! beam_init_struct%position_file: 0D_NOT_character

  subroutine beam_init_struct_get_position_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_position_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%position_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%position_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_position_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_position_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%position_file = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%distribution_type: 1D_NOT_character

  subroutine beam_init_struct_get_distribution_type_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='beam_init_struct_get_distribution_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true.) then
      data_ptr = c_loc(struct_obj%distribution_type(lbound(struct_obj%distribution_type, 1)))
      bounds(1) = int(lbound(struct_obj%distribution_type, 1), c_int)
      bounds(2) = int(ubound(struct_obj%distribution_type, 1), c_int)
      str_len = int(len(struct_obj%distribution_type), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%spin: 1D_NOT_real

  subroutine beam_init_struct_get_spin_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_spin_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin)) then
      data_ptr = c_loc(struct_obj%spin(lbound(struct_obj%spin, 1)))
      bounds(1) = int(lbound(struct_obj%spin, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%ellipse: 1D_NOT_type

  subroutine beam_init_struct_get_ellipse_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='beam_init_struct_get_ellipse_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%ellipse)) then
      data_ptr = c_loc(struct_obj%ellipse(lbound(struct_obj%ellipse, 1)))
      bounds(1) = int(lbound(struct_obj%ellipse, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ellipse, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ellipse(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%KV: 0D_NOT_type

  subroutine beam_init_struct_get_KV(struct_obj_ptr, ptr_out) bind(c, name='beam_init_struct_get_KV')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%KV)
  end subroutine


  subroutine beam_init_struct_set_KV(struct_obj_ptr, src_ptr) bind(c, name='beam_init_struct_set_KV')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(beam_init_struct), pointer :: struct_obj
    type(kv_beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%KV = src_obj
  end subroutine

  ! beam_init_struct%grid: 1D_NOT_type

  subroutine beam_init_struct_get_grid_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='beam_init_struct_get_grid_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%grid)) then
      data_ptr = c_loc(struct_obj%grid(lbound(struct_obj%grid, 1)))
      bounds(1) = int(lbound(struct_obj%grid, 1), c_int)
      bounds(2) = int(ubound(struct_obj%grid, 1), c_int)
      
      el_size = int(storage_size(struct_obj%grid(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%center_jitter: 1D_NOT_real

  subroutine beam_init_struct_get_center_jitter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_center_jitter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%center_jitter)) then
      data_ptr = c_loc(struct_obj%center_jitter(lbound(struct_obj%center_jitter, 1)))
      bounds(1) = int(lbound(struct_obj%center_jitter, 1), c_int)
      bounds(2) = int(ubound(struct_obj%center_jitter, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%emit_jitter: 1D_NOT_real

  subroutine beam_init_struct_get_emit_jitter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_emit_jitter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%emit_jitter)) then
      data_ptr = c_loc(struct_obj%emit_jitter(lbound(struct_obj%emit_jitter, 1)))
      bounds(1) = int(lbound(struct_obj%emit_jitter, 1), c_int)
      bounds(2) = int(ubound(struct_obj%emit_jitter, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%sig_z_jitter: 0D_NOT_real

  subroutine beam_init_struct_get_sig_z_jitter(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_z_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z_jitter
  end subroutine


  subroutine beam_init_struct_set_sig_z_jitter(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_z_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z_jitter = value_in
  end subroutine

  ! beam_init_struct%sig_pz_jitter: 0D_NOT_real

  subroutine beam_init_struct_get_sig_pz_jitter(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_pz_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_pz_jitter
  end subroutine


  subroutine beam_init_struct_set_sig_pz_jitter(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_pz_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_pz_jitter = value_in
  end subroutine

  ! beam_init_struct%n_particle: 0D_NOT_integer

  subroutine beam_init_struct_get_n_particle(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_n_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle
  end subroutine


  subroutine beam_init_struct_set_n_particle(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_n_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle = value_in
  end subroutine

  ! beam_init_struct%renorm_center: 0D_NOT_logical

  subroutine beam_init_struct_get_renorm_center(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_renorm_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%renorm_center
  end subroutine


  subroutine beam_init_struct_set_renorm_center(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_renorm_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%renorm_center = value_in
  end subroutine

  ! beam_init_struct%renorm_sigma: 0D_NOT_logical

  subroutine beam_init_struct_get_renorm_sigma(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_renorm_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%renorm_sigma
  end subroutine


  subroutine beam_init_struct_set_renorm_sigma(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_renorm_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%renorm_sigma = value_in
  end subroutine

  ! beam_init_struct%random_engine: 0D_NOT_character

  subroutine beam_init_struct_get_random_engine_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_random_engine_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%random_engine)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%random_engine), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_random_engine(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_random_engine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%random_engine = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%random_gauss_converter: 0D_NOT_character

  subroutine beam_init_struct_get_random_gauss_converter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_random_gauss_converter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%random_gauss_converter)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%random_gauss_converter), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_random_gauss_converter(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_random_gauss_converter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%random_gauss_converter = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%random_sigma_cutoff: 0D_NOT_real

  subroutine beam_init_struct_get_random_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_random_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%random_sigma_cutoff
  end subroutine


  subroutine beam_init_struct_set_random_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_random_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%random_sigma_cutoff = value_in
  end subroutine

  ! beam_init_struct%a_norm_emit: 0D_NOT_real

  subroutine beam_init_struct_get_a_norm_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_a_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_norm_emit
  end subroutine


  subroutine beam_init_struct_set_a_norm_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_a_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_norm_emit = value_in
  end subroutine

  ! beam_init_struct%b_norm_emit: 0D_NOT_real

  subroutine beam_init_struct_get_b_norm_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_b_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_norm_emit
  end subroutine


  subroutine beam_init_struct_set_b_norm_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_b_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_norm_emit = value_in
  end subroutine

  ! beam_init_struct%a_emit: 0D_NOT_real

  subroutine beam_init_struct_get_a_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_emit
  end subroutine


  subroutine beam_init_struct_set_a_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_emit = value_in
  end subroutine

  ! beam_init_struct%b_emit: 0D_NOT_real

  subroutine beam_init_struct_get_b_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_emit
  end subroutine


  subroutine beam_init_struct_set_b_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_emit = value_in
  end subroutine

  ! beam_init_struct%dPz_dz: 0D_NOT_real

  subroutine beam_init_struct_get_dPz_dz(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_dPz_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dPz_dz
  end subroutine


  subroutine beam_init_struct_set_dPz_dz(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_dPz_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dPz_dz = value_in
  end subroutine

  ! beam_init_struct%center: 1D_NOT_real

  subroutine beam_init_struct_get_center_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_center_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%center)) then
      data_ptr = c_loc(struct_obj%center(lbound(struct_obj%center, 1)))
      bounds(1) = int(lbound(struct_obj%center, 1), c_int)
      bounds(2) = int(ubound(struct_obj%center, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%t_offset: 0D_NOT_real

  subroutine beam_init_struct_get_t_offset(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_t_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_offset
  end subroutine


  subroutine beam_init_struct_set_t_offset(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_t_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_offset = value_in
  end subroutine

  ! beam_init_struct%dt_bunch: 0D_NOT_real

  subroutine beam_init_struct_get_dt_bunch(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_dt_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dt_bunch
  end subroutine


  subroutine beam_init_struct_set_dt_bunch(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_dt_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dt_bunch = value_in
  end subroutine

  ! beam_init_struct%sig_z: 0D_NOT_real

  subroutine beam_init_struct_get_sig_z(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z
  end subroutine


  subroutine beam_init_struct_set_sig_z(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z = value_in
  end subroutine

  ! beam_init_struct%sig_pz: 0D_NOT_real

  subroutine beam_init_struct_get_sig_pz(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_pz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_pz
  end subroutine


  subroutine beam_init_struct_set_sig_pz(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_pz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_pz = value_in
  end subroutine

  ! beam_init_struct%bunch_charge: 0D_NOT_real

  subroutine beam_init_struct_get_bunch_charge(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_bunch_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bunch_charge
  end subroutine


  subroutine beam_init_struct_set_bunch_charge(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_bunch_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bunch_charge = value_in
  end subroutine

  ! beam_init_struct%n_bunch: 0D_NOT_integer

  subroutine beam_init_struct_get_n_bunch(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_n_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bunch
  end subroutine


  subroutine beam_init_struct_set_n_bunch(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_n_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bunch = value_in
  end subroutine

  ! beam_init_struct%ix_turn: 0D_NOT_integer

  subroutine beam_init_struct_get_ix_turn(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_turn
  end subroutine


  subroutine beam_init_struct_set_ix_turn(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_turn = value_in
  end subroutine

  ! beam_init_struct%species: 0D_NOT_character

  subroutine beam_init_struct_get_species_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_species_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%species)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%species), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_species(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%species = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%full_6D_coupling_calc: 0D_NOT_logical

  subroutine beam_init_struct_get_full_6D_coupling_calc(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_full_6D_coupling_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%full_6D_coupling_calc
  end subroutine


  subroutine beam_init_struct_set_full_6D_coupling_calc(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_full_6D_coupling_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%full_6D_coupling_calc = value_in
  end subroutine

  ! beam_init_struct%use_particle_start: 0D_NOT_logical

  subroutine beam_init_struct_get_use_particle_start(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_use_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_particle_start
  end subroutine


  subroutine beam_init_struct_set_use_particle_start(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_use_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_particle_start = value_in
  end subroutine

  ! beam_init_struct%use_t_coords: 0D_NOT_logical

  subroutine beam_init_struct_get_use_t_coords(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_use_t_coords')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_t_coords
  end subroutine


  subroutine beam_init_struct_set_use_t_coords(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_use_t_coords')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_t_coords = value_in
  end subroutine

  ! beam_init_struct%use_z_as_t: 0D_NOT_logical

  subroutine beam_init_struct_get_use_z_as_t(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_use_z_as_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_z_as_t
  end subroutine


  subroutine beam_init_struct_set_use_z_as_t(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_use_z_as_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_z_as_t = value_in
  end subroutine

  ! beam_init_struct%file_name: 0D_NOT_character

  subroutine beam_init_struct_get_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file_name = str_in ! implicitly handles padding
  end subroutine

  !! lat_param_struct

    function allocate_fortran_lat_param_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(lat_param_struct), pointer :: fptr
      type(lat_param_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_lat_param_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(lat_param_struct), pointer :: fptr
      type(lat_param_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_lat_param_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_param_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_lat_param_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(lat_param_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_lat_param_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(lat_param_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_lat_param_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(lat_param_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_lat_param_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(lat_param_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! lat_param_struct%n_part: 0D_NOT_real

  subroutine lat_param_struct_get_n_part(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_n_part')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_part
  end subroutine


  subroutine lat_param_struct_set_n_part(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_n_part')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_part = value_in
  end subroutine

  ! lat_param_struct%total_length: 0D_NOT_real

  subroutine lat_param_struct_get_total_length(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_total_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%total_length
  end subroutine


  subroutine lat_param_struct_set_total_length(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_total_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%total_length = value_in
  end subroutine

  ! lat_param_struct%unstable_factor: 0D_NOT_real

  subroutine lat_param_struct_get_unstable_factor(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_unstable_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%unstable_factor
  end subroutine


  subroutine lat_param_struct_set_unstable_factor(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_unstable_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%unstable_factor = value_in
  end subroutine

  ! lat_param_struct%t1_with_RF: 2D_NOT_real

  subroutine lat_param_struct_get_t1_with_RF_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='lat_param_struct_get_t1_with_RF_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_param_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%t1_with_RF)) then
      data_ptr = c_loc(struct_obj%t1_with_RF(lbound(struct_obj%t1_with_RF, 1), lbound(struct_obj%t1_with_RF, 2)))
      bounds(1) = int(lbound(struct_obj%t1_with_RF, 1), c_int)
      bounds(2) = int(ubound(struct_obj%t1_with_RF, 1), c_int)
      bounds(3) = int(lbound(struct_obj%t1_with_RF, 2), c_int)
      bounds(4) = int(ubound(struct_obj%t1_with_RF, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_param_struct%t1_no_RF: 2D_NOT_real

  subroutine lat_param_struct_get_t1_no_RF_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='lat_param_struct_get_t1_no_RF_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_param_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%t1_no_RF)) then
      data_ptr = c_loc(struct_obj%t1_no_RF(lbound(struct_obj%t1_no_RF, 1), lbound(struct_obj%t1_no_RF, 2)))
      bounds(1) = int(lbound(struct_obj%t1_no_RF, 1), c_int)
      bounds(2) = int(ubound(struct_obj%t1_no_RF, 1), c_int)
      bounds(3) = int(lbound(struct_obj%t1_no_RF, 2), c_int)
      bounds(4) = int(ubound(struct_obj%t1_no_RF, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_param_struct%spin_tune: 0D_NOT_real

  subroutine lat_param_struct_get_spin_tune(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_spin_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_tune
  end subroutine


  subroutine lat_param_struct_set_spin_tune(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_spin_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_tune = value_in
  end subroutine

  ! lat_param_struct%particle: 0D_NOT_integer

  subroutine lat_param_struct_get_particle(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle
  end subroutine


  subroutine lat_param_struct_set_particle(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle = value_in
  end subroutine

  ! lat_param_struct%default_tracking_species: 0D_NOT_integer

  subroutine lat_param_struct_get_default_tracking_species(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_default_tracking_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_tracking_species
  end subroutine


  subroutine lat_param_struct_set_default_tracking_species(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_default_tracking_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_tracking_species = value_in
  end subroutine

  ! lat_param_struct%geometry: 0D_NOT_integer

  subroutine lat_param_struct_get_geometry(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%geometry
  end subroutine


  subroutine lat_param_struct_set_geometry(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%geometry = value_in
  end subroutine

  ! lat_param_struct%ixx: 0D_NOT_integer

  subroutine lat_param_struct_get_ixx(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ixx
  end subroutine


  subroutine lat_param_struct_set_ixx(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ixx = value_in
  end subroutine

  ! lat_param_struct%stable: 0D_NOT_logical

  subroutine lat_param_struct_get_stable(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stable
  end subroutine


  subroutine lat_param_struct_set_stable(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stable = value_in
  end subroutine

  ! lat_param_struct%live_branch: 0D_NOT_logical

  subroutine lat_param_struct_get_live_branch(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_live_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%live_branch
  end subroutine


  subroutine lat_param_struct_set_live_branch(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_live_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%live_branch = value_in
  end subroutine

  ! lat_param_struct%g1_integral: 0D_NOT_real

  subroutine lat_param_struct_get_g1_integral(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_g1_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%g1_integral
  end subroutine


  subroutine lat_param_struct_set_g1_integral(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_g1_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%g1_integral = value_in
  end subroutine

  ! lat_param_struct%g2_integral: 0D_NOT_real

  subroutine lat_param_struct_get_g2_integral(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_g2_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%g2_integral
  end subroutine


  subroutine lat_param_struct_set_g2_integral(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_g2_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%g2_integral = value_in
  end subroutine

  ! lat_param_struct%g3_integral: 0D_NOT_real

  subroutine lat_param_struct_get_g3_integral(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_g3_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%g3_integral
  end subroutine


  subroutine lat_param_struct_set_g3_integral(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_g3_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%g3_integral = value_in
  end subroutine

  ! lat_param_struct%bookkeeping_state: 0D_NOT_type

  subroutine lat_param_struct_get_bookkeeping_state(struct_obj_ptr, ptr_out) bind(c, name='lat_param_struct_get_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%bookkeeping_state)
  end subroutine


  subroutine lat_param_struct_set_bookkeeping_state(struct_obj_ptr, src_ptr) bind(c, name='lat_param_struct_set_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_param_struct), pointer :: struct_obj
    type(bookkeeping_state_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%bookkeeping_state = src_obj
  end subroutine

  ! lat_param_struct%beam_init: 0D_NOT_type

  subroutine lat_param_struct_get_beam_init(struct_obj_ptr, ptr_out) bind(c, name='lat_param_struct_get_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init)
  end subroutine


  subroutine lat_param_struct_set_beam_init(struct_obj_ptr, src_ptr) bind(c, name='lat_param_struct_set_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_param_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init = src_obj
  end subroutine

  !! mode_info_struct

    function allocate_fortran_mode_info_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(mode_info_struct), pointer :: fptr
      type(mode_info_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_mode_info_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(mode_info_struct), pointer :: fptr
      type(mode_info_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_mode_info_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(mode_info_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_mode_info_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(mode_info_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_mode_info_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(mode_info_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_mode_info_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(mode_info_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_mode_info_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(mode_info_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! mode_info_struct%stable: 0D_NOT_logical

  subroutine mode_info_struct_get_stable(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stable
  end subroutine


  subroutine mode_info_struct_set_stable(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stable = value_in
  end subroutine

  ! mode_info_struct%tune: 0D_NOT_real

  subroutine mode_info_struct_get_tune(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tune
  end subroutine


  subroutine mode_info_struct_set_tune(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tune = value_in
  end subroutine

  ! mode_info_struct%emit: 0D_NOT_real

  subroutine mode_info_struct_get_emit(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emit
  end subroutine


  subroutine mode_info_struct_set_emit(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emit = value_in
  end subroutine

  ! mode_info_struct%chrom: 0D_NOT_real

  subroutine mode_info_struct_get_chrom(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom
  end subroutine


  subroutine mode_info_struct_set_chrom(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom = value_in
  end subroutine

  ! mode_info_struct%sigma: 0D_NOT_real

  subroutine mode_info_struct_get_sigma(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma
  end subroutine


  subroutine mode_info_struct_set_sigma(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma = value_in
  end subroutine

  ! mode_info_struct%sigmap: 0D_NOT_real

  subroutine mode_info_struct_get_sigmap(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_sigmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigmap
  end subroutine


  subroutine mode_info_struct_set_sigmap(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_sigmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigmap = value_in
  end subroutine

  !! pre_tracker_struct

    function allocate_fortran_pre_tracker_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(pre_tracker_struct), pointer :: fptr
      type(pre_tracker_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_pre_tracker_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(pre_tracker_struct), pointer :: fptr
      type(pre_tracker_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_pre_tracker_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(pre_tracker_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_pre_tracker_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(pre_tracker_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_pre_tracker_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(pre_tracker_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_pre_tracker_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(pre_tracker_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_pre_tracker_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(pre_tracker_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! pre_tracker_struct%who: 0D_NOT_integer

  subroutine pre_tracker_struct_get_who(struct_obj_ptr, value_out) bind(c, name='pre_tracker_struct_get_who')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%who
  end subroutine


  subroutine pre_tracker_struct_set_who(struct_obj_ptr, value_in) bind(c, name='pre_tracker_struct_set_who')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%who = value_in
  end subroutine

  ! pre_tracker_struct%ix_ele_start: 0D_NOT_integer

  subroutine pre_tracker_struct_get_ix_ele_start(struct_obj_ptr, value_out) bind(c, name='pre_tracker_struct_get_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_start
  end subroutine


  subroutine pre_tracker_struct_set_ix_ele_start(struct_obj_ptr, value_in) bind(c, name='pre_tracker_struct_set_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_start = value_in
  end subroutine

  ! pre_tracker_struct%ix_ele_end: 0D_NOT_integer

  subroutine pre_tracker_struct_get_ix_ele_end(struct_obj_ptr, value_out) bind(c, name='pre_tracker_struct_get_ix_ele_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_end
  end subroutine


  subroutine pre_tracker_struct_set_ix_ele_end(struct_obj_ptr, value_in) bind(c, name='pre_tracker_struct_set_ix_ele_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_end = value_in
  end subroutine

  ! pre_tracker_struct%input_file: 0D_NOT_character

  subroutine pre_tracker_struct_get_input_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='pre_tracker_struct_get_input_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%input_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%input_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine pre_tracker_struct_set_input_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='pre_tracker_struct_set_input_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(pre_tracker_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%input_file = str_in ! implicitly handles padding
  end subroutine

  !! anormal_mode_struct

    function allocate_fortran_anormal_mode_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(anormal_mode_struct), pointer :: fptr
      type(anormal_mode_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_anormal_mode_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(anormal_mode_struct), pointer :: fptr
      type(anormal_mode_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_anormal_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(anormal_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_anormal_mode_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(anormal_mode_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_anormal_mode_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(anormal_mode_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_anormal_mode_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(anormal_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_anormal_mode_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(anormal_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! anormal_mode_struct%emittance: 0D_NOT_real

  subroutine anormal_mode_struct_get_emittance(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_emittance')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emittance
  end subroutine


  subroutine anormal_mode_struct_set_emittance(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_emittance')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emittance = value_in
  end subroutine

  ! anormal_mode_struct%emittance_no_vert: 0D_NOT_real

  subroutine anormal_mode_struct_get_emittance_no_vert(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_emittance_no_vert')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emittance_no_vert
  end subroutine


  subroutine anormal_mode_struct_set_emittance_no_vert(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_emittance_no_vert')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emittance_no_vert = value_in
  end subroutine

  ! anormal_mode_struct%synch_int: 1D_NOT_real

  subroutine anormal_mode_struct_get_synch_int_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='anormal_mode_struct_get_synch_int_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(anormal_mode_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%synch_int)) then
      data_ptr = c_loc(struct_obj%synch_int(lbound(struct_obj%synch_int, 1)))
      bounds(1) = int(lbound(struct_obj%synch_int, 1), c_int)
      bounds(2) = int(ubound(struct_obj%synch_int, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! anormal_mode_struct%j_damp: 0D_NOT_real

  subroutine anormal_mode_struct_get_j_damp(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_j_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%j_damp
  end subroutine


  subroutine anormal_mode_struct_set_j_damp(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_j_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%j_damp = value_in
  end subroutine

  ! anormal_mode_struct%alpha_damp: 0D_NOT_real

  subroutine anormal_mode_struct_get_alpha_damp(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_alpha_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%alpha_damp
  end subroutine


  subroutine anormal_mode_struct_set_alpha_damp(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_alpha_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%alpha_damp = value_in
  end subroutine

  ! anormal_mode_struct%chrom: 0D_NOT_real

  subroutine anormal_mode_struct_get_chrom(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom
  end subroutine


  subroutine anormal_mode_struct_set_chrom(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom = value_in
  end subroutine

  ! anormal_mode_struct%tune: 0D_NOT_real

  subroutine anormal_mode_struct_get_tune(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tune
  end subroutine


  subroutine anormal_mode_struct_set_tune(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tune = value_in
  end subroutine

  !! linac_normal_mode_struct

    function allocate_fortran_linac_normal_mode_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(linac_normal_mode_struct), pointer :: fptr
      type(linac_normal_mode_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_linac_normal_mode_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(linac_normal_mode_struct), pointer :: fptr
      type(linac_normal_mode_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_linac_normal_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(linac_normal_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_linac_normal_mode_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(linac_normal_mode_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_linac_normal_mode_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(linac_normal_mode_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_linac_normal_mode_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(linac_normal_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_linac_normal_mode_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(linac_normal_mode_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! linac_normal_mode_struct%i2_E4: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i2_E4(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i2_E4
  end subroutine


  subroutine linac_normal_mode_struct_set_i2_E4(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i2_E4 = value_in
  end subroutine

  ! linac_normal_mode_struct%i3_E7: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i3_E7(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i3_E7
  end subroutine


  subroutine linac_normal_mode_struct_set_i3_E7(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i3_E7 = value_in
  end subroutine

  ! linac_normal_mode_struct%i5a_E6: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i5a_E6(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5a_E6
  end subroutine


  subroutine linac_normal_mode_struct_set_i5a_E6(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5a_E6 = value_in
  end subroutine

  ! linac_normal_mode_struct%i5b_E6: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i5b_E6(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5b_E6
  end subroutine


  subroutine linac_normal_mode_struct_set_i5b_E6(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5b_E6 = value_in
  end subroutine

  ! linac_normal_mode_struct%sig_E1: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_sig_E1(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_sig_E1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_E1
  end subroutine


  subroutine linac_normal_mode_struct_set_sig_E1(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_sig_E1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_E1 = value_in
  end subroutine

  ! linac_normal_mode_struct%a_emittance_end: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_a_emittance_end(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_a_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_emittance_end
  end subroutine


  subroutine linac_normal_mode_struct_set_a_emittance_end(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_a_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_emittance_end = value_in
  end subroutine

  ! linac_normal_mode_struct%b_emittance_end: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_b_emittance_end(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_b_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_emittance_end
  end subroutine


  subroutine linac_normal_mode_struct_set_b_emittance_end(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_b_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_emittance_end = value_in
  end subroutine

  !! normal_modes_struct

    function allocate_fortran_normal_modes_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(normal_modes_struct), pointer :: fptr
      type(normal_modes_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_normal_modes_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(normal_modes_struct), pointer :: fptr
      type(normal_modes_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_normal_modes_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(normal_modes_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_normal_modes_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(normal_modes_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_normal_modes_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(normal_modes_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_normal_modes_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(normal_modes_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_normal_modes_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(normal_modes_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! normal_modes_struct%synch_int: 1D_NOT_real

  subroutine normal_modes_struct_get_synch_int_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='normal_modes_struct_get_synch_int_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(normal_modes_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%synch_int)) then
      data_ptr = c_loc(struct_obj%synch_int(lbound(struct_obj%synch_int, 1)))
      bounds(1) = int(lbound(struct_obj%synch_int, 1), c_int)
      bounds(2) = int(ubound(struct_obj%synch_int, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! normal_modes_struct%sigE_E: 0D_NOT_real

  subroutine normal_modes_struct_get_sigE_E(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_sigE_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigE_E
  end subroutine


  subroutine normal_modes_struct_set_sigE_E(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_sigE_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigE_E = value_in
  end subroutine

  ! normal_modes_struct%sig_z: 0D_NOT_real

  subroutine normal_modes_struct_get_sig_z(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z
  end subroutine


  subroutine normal_modes_struct_set_sig_z(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z = value_in
  end subroutine

  ! normal_modes_struct%e_loss: 0D_NOT_real

  subroutine normal_modes_struct_get_e_loss(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_e_loss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%e_loss
  end subroutine


  subroutine normal_modes_struct_set_e_loss(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_e_loss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%e_loss = value_in
  end subroutine

  ! normal_modes_struct%rf_voltage: 0D_NOT_real

  subroutine normal_modes_struct_get_rf_voltage(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_rf_voltage')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_voltage
  end subroutine


  subroutine normal_modes_struct_set_rf_voltage(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_rf_voltage')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_voltage = value_in
  end subroutine

  ! normal_modes_struct%pz_aperture: 0D_NOT_real

  subroutine normal_modes_struct_get_pz_aperture(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_pz_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pz_aperture
  end subroutine


  subroutine normal_modes_struct_set_pz_aperture(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_pz_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pz_aperture = value_in
  end subroutine

  ! normal_modes_struct%pz_average: 0D_NOT_real

  subroutine normal_modes_struct_get_pz_average(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_pz_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pz_average
  end subroutine


  subroutine normal_modes_struct_set_pz_average(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_pz_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pz_average = value_in
  end subroutine

  ! normal_modes_struct%momentum_compaction: 0D_NOT_real

  subroutine normal_modes_struct_get_momentum_compaction(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_momentum_compaction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%momentum_compaction
  end subroutine


  subroutine normal_modes_struct_set_momentum_compaction(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_momentum_compaction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%momentum_compaction = value_in
  end subroutine

  ! normal_modes_struct%dpz_damp: 0D_NOT_real

  subroutine normal_modes_struct_get_dpz_damp(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_dpz_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dpz_damp
  end subroutine


  subroutine normal_modes_struct_set_dpz_damp(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_dpz_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dpz_damp = value_in
  end subroutine

  ! normal_modes_struct%a: 0D_NOT_type

  subroutine normal_modes_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine normal_modes_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(anormal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! normal_modes_struct%b: 0D_NOT_type

  subroutine normal_modes_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine normal_modes_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(anormal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! normal_modes_struct%z: 0D_NOT_type

  subroutine normal_modes_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine normal_modes_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(anormal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! normal_modes_struct%lin: 0D_NOT_type

  subroutine normal_modes_struct_get_lin(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_lin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lin)
  end subroutine


  subroutine normal_modes_struct_set_lin(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_lin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(linac_normal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lin = src_obj
  end subroutine

  !! em_field_struct

    function allocate_fortran_em_field_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(em_field_struct), pointer :: fptr
      type(em_field_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_em_field_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(em_field_struct), pointer :: fptr
      type(em_field_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_em_field_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(em_field_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_em_field_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(em_field_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_em_field_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(em_field_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_em_field_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(em_field_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_em_field_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(em_field_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! em_field_struct%E: 1D_NOT_real

  subroutine em_field_struct_get_E_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_field_struct_get_E_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%E)) then
      data_ptr = c_loc(struct_obj%E(lbound(struct_obj%E, 1)))
      bounds(1) = int(lbound(struct_obj%E, 1), c_int)
      bounds(2) = int(ubound(struct_obj%E, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%B: 1D_NOT_real

  subroutine em_field_struct_get_B_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_field_struct_get_B_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%B)) then
      data_ptr = c_loc(struct_obj%B(lbound(struct_obj%B, 1)))
      bounds(1) = int(lbound(struct_obj%B, 1), c_int)
      bounds(2) = int(ubound(struct_obj%B, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%dE: 2D_NOT_real

  subroutine em_field_struct_get_dE_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='em_field_struct_get_dE_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dE)) then
      data_ptr = c_loc(struct_obj%dE(lbound(struct_obj%dE, 1), lbound(struct_obj%dE, 2)))
      bounds(1) = int(lbound(struct_obj%dE, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dE, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dE, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dE, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%dB: 2D_NOT_real

  subroutine em_field_struct_get_dB_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='em_field_struct_get_dB_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dB)) then
      data_ptr = c_loc(struct_obj%dB(lbound(struct_obj%dB, 1), lbound(struct_obj%dB, 2)))
      bounds(1) = int(lbound(struct_obj%dB, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dB, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dB, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dB, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%phi: 0D_NOT_real

  subroutine em_field_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='em_field_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine em_field_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='em_field_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! em_field_struct%phi_B: 0D_NOT_real

  subroutine em_field_struct_get_phi_B(struct_obj_ptr, value_out) bind(c, name='em_field_struct_get_phi_B')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_B
  end subroutine


  subroutine em_field_struct_set_phi_B(struct_obj_ptr, value_in) bind(c, name='em_field_struct_set_phi_B')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_B = value_in
  end subroutine

  ! em_field_struct%A: 1D_NOT_real

  subroutine em_field_struct_get_A_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_field_struct_get_A_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%A)) then
      data_ptr = c_loc(struct_obj%A(lbound(struct_obj%A, 1)))
      bounds(1) = int(lbound(struct_obj%A, 1), c_int)
      bounds(2) = int(ubound(struct_obj%A, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! strong_beam_struct

    function allocate_fortran_strong_beam_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(strong_beam_struct), pointer :: fptr
      type(strong_beam_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_strong_beam_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(strong_beam_struct), pointer :: fptr
      type(strong_beam_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_strong_beam_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(strong_beam_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_strong_beam_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(strong_beam_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_strong_beam_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(strong_beam_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_strong_beam_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(strong_beam_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_strong_beam_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(strong_beam_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! strong_beam_struct%ix_slice: 0D_NOT_integer

  subroutine strong_beam_struct_get_ix_slice(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_ix_slice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_slice
  end subroutine


  subroutine strong_beam_struct_set_ix_slice(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_ix_slice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_slice = value_in
  end subroutine

  ! strong_beam_struct%x_center: 0D_NOT_real

  subroutine strong_beam_struct_get_x_center(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_x_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_center
  end subroutine


  subroutine strong_beam_struct_set_x_center(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_x_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_center = value_in
  end subroutine

  ! strong_beam_struct%y_center: 0D_NOT_real

  subroutine strong_beam_struct_get_y_center(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_y_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_center
  end subroutine


  subroutine strong_beam_struct_set_y_center(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_y_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_center = value_in
  end subroutine

  ! strong_beam_struct%x_sigma: 0D_NOT_real

  subroutine strong_beam_struct_get_x_sigma(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_x_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_sigma
  end subroutine


  subroutine strong_beam_struct_set_x_sigma(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_x_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_sigma = value_in
  end subroutine

  ! strong_beam_struct%y_sigma: 0D_NOT_real

  subroutine strong_beam_struct_get_y_sigma(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_y_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_sigma
  end subroutine


  subroutine strong_beam_struct_set_y_sigma(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_y_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_sigma = value_in
  end subroutine

  ! strong_beam_struct%dx: 0D_NOT_real

  subroutine strong_beam_struct_get_dx(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dx
  end subroutine


  subroutine strong_beam_struct_set_dx(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dx = value_in
  end subroutine

  ! strong_beam_struct%dy: 0D_NOT_real

  subroutine strong_beam_struct_get_dy(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dy
  end subroutine


  subroutine strong_beam_struct_set_dy(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dy = value_in
  end subroutine

  !! track_point_struct

    function allocate_fortran_track_point_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(track_point_struct), pointer :: fptr
      type(track_point_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_track_point_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(track_point_struct), pointer :: fptr
      type(track_point_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_track_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(track_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_track_point_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(track_point_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_track_point_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(track_point_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_track_point_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(track_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_track_point_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(track_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! track_point_struct%s_lab: 0D_NOT_real

  subroutine track_point_struct_get_s_lab(struct_obj_ptr, value_out) bind(c, name='track_point_struct_get_s_lab')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_lab
  end subroutine


  subroutine track_point_struct_set_s_lab(struct_obj_ptr, value_in) bind(c, name='track_point_struct_set_s_lab')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_lab = value_in
  end subroutine

  ! track_point_struct%s_body: 0D_NOT_real

  subroutine track_point_struct_get_s_body(struct_obj_ptr, value_out) bind(c, name='track_point_struct_get_s_body')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_body
  end subroutine


  subroutine track_point_struct_set_s_body(struct_obj_ptr, value_in) bind(c, name='track_point_struct_set_s_body')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_body = value_in
  end subroutine

  ! track_point_struct%orb: 0D_NOT_type

  subroutine track_point_struct_get_orb(struct_obj_ptr, ptr_out) bind(c, name='track_point_struct_get_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orb)
  end subroutine


  subroutine track_point_struct_set_orb(struct_obj_ptr, src_ptr) bind(c, name='track_point_struct_set_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(track_point_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orb = src_obj
  end subroutine

  ! track_point_struct%field: 0D_NOT_type

  subroutine track_point_struct_get_field(struct_obj_ptr, ptr_out) bind(c, name='track_point_struct_get_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%field)
  end subroutine


  subroutine track_point_struct_set_field(struct_obj_ptr, src_ptr) bind(c, name='track_point_struct_set_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(track_point_struct), pointer :: struct_obj
    type(em_field_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%field = src_obj
  end subroutine

  ! track_point_struct%strong_beam: 0D_NOT_type

  subroutine track_point_struct_get_strong_beam(struct_obj_ptr, ptr_out) bind(c, name='track_point_struct_get_strong_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%strong_beam)
  end subroutine


  subroutine track_point_struct_set_strong_beam(struct_obj_ptr, src_ptr) bind(c, name='track_point_struct_set_strong_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(track_point_struct), pointer :: struct_obj
    type(strong_beam_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%strong_beam = src_obj
  end subroutine

  ! track_point_struct%vec0: 1D_NOT_real

  subroutine track_point_struct_get_vec0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='track_point_struct_get_vec0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(track_point_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%vec0)) then
      data_ptr = c_loc(struct_obj%vec0(lbound(struct_obj%vec0, 1)))
      bounds(1) = int(lbound(struct_obj%vec0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! track_point_struct%mat6: 2D_NOT_real

  subroutine track_point_struct_get_mat6_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='track_point_struct_get_mat6_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(track_point_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%mat6)) then
      data_ptr = c_loc(struct_obj%mat6(lbound(struct_obj%mat6, 1), lbound(struct_obj%mat6, 2)))
      bounds(1) = int(lbound(struct_obj%mat6, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat6, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat6, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat6, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! track_struct

    function allocate_fortran_track_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(track_struct), pointer :: fptr
      type(track_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_track_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(track_struct), pointer :: fptr
      type(track_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_track_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(track_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_track_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(track_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_track_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(track_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_track_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(track_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_track_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(track_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! track_struct%pt: 1D_ALLOC_type

  subroutine track_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='track_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(track_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      
      el_size = int(storage_size(struct_obj%pt(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! track_struct%ds_save: 0D_NOT_real

  subroutine track_struct_get_ds_save(struct_obj_ptr, value_out) bind(c, name='track_struct_get_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_save
  end subroutine


  subroutine track_struct_set_ds_save(struct_obj_ptr, value_in) bind(c, name='track_struct_set_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_save = value_in
  end subroutine

  ! track_struct%n_pt: 0D_NOT_integer

  subroutine track_struct_get_n_pt(struct_obj_ptr, value_out) bind(c, name='track_struct_get_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_pt
  end subroutine


  subroutine track_struct_set_n_pt(struct_obj_ptr, value_in) bind(c, name='track_struct_set_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_pt = value_in
  end subroutine

  ! track_struct%n_bad: 0D_NOT_integer

  subroutine track_struct_get_n_bad(struct_obj_ptr, value_out) bind(c, name='track_struct_get_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bad
  end subroutine


  subroutine track_struct_set_n_bad(struct_obj_ptr, value_in) bind(c, name='track_struct_set_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bad = value_in
  end subroutine

  ! track_struct%n_ok: 0D_NOT_integer

  subroutine track_struct_get_n_ok(struct_obj_ptr, value_out) bind(c, name='track_struct_get_n_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ok
  end subroutine


  subroutine track_struct_set_n_ok(struct_obj_ptr, value_in) bind(c, name='track_struct_set_n_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ok = value_in
  end subroutine

  !! space_charge_common_struct

    function allocate_fortran_space_charge_common_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(space_charge_common_struct), pointer :: fptr
      type(space_charge_common_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_space_charge_common_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(space_charge_common_struct), pointer :: fptr
      type(space_charge_common_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_space_charge_common_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(space_charge_common_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_space_charge_common_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(space_charge_common_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_space_charge_common_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(space_charge_common_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_space_charge_common_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(space_charge_common_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_space_charge_common_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(space_charge_common_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! space_charge_common_struct%ds_track_step: 0D_NOT_real

  subroutine space_charge_common_struct_get_ds_track_step(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_ds_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_track_step
  end subroutine


  subroutine space_charge_common_struct_set_ds_track_step(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_ds_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_track_step = value_in
  end subroutine

  ! space_charge_common_struct%dt_track_step: 0D_NOT_real

  subroutine space_charge_common_struct_get_dt_track_step(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_dt_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dt_track_step
  end subroutine


  subroutine space_charge_common_struct_set_dt_track_step(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_dt_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dt_track_step = value_in
  end subroutine

  ! space_charge_common_struct%cathode_strength_cutoff: 0D_NOT_real

  subroutine space_charge_common_struct_get_cathode_strength_cutoff(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_cathode_strength_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cathode_strength_cutoff
  end subroutine


  subroutine space_charge_common_struct_set_cathode_strength_cutoff(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_cathode_strength_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cathode_strength_cutoff = value_in
  end subroutine

  ! space_charge_common_struct%rel_tol_tracking: 0D_NOT_real

  subroutine space_charge_common_struct_get_rel_tol_tracking(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol_tracking
  end subroutine


  subroutine space_charge_common_struct_set_rel_tol_tracking(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol_tracking = value_in
  end subroutine

  ! space_charge_common_struct%abs_tol_tracking: 0D_NOT_real

  subroutine space_charge_common_struct_get_abs_tol_tracking(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_tol_tracking
  end subroutine


  subroutine space_charge_common_struct_set_abs_tol_tracking(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_tol_tracking = value_in
  end subroutine

  ! space_charge_common_struct%beam_chamber_height: 0D_NOT_real

  subroutine space_charge_common_struct_get_beam_chamber_height(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_beam_chamber_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beam_chamber_height
  end subroutine


  subroutine space_charge_common_struct_set_beam_chamber_height(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_beam_chamber_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beam_chamber_height = value_in
  end subroutine

  ! space_charge_common_struct%lsc_sigma_cutoff: 0D_NOT_real

  subroutine space_charge_common_struct_get_lsc_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_lsc_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lsc_sigma_cutoff
  end subroutine


  subroutine space_charge_common_struct_set_lsc_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_lsc_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lsc_sigma_cutoff = value_in
  end subroutine

  ! space_charge_common_struct%particle_sigma_cutoff: 0D_NOT_real

  subroutine space_charge_common_struct_get_particle_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_particle_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle_sigma_cutoff
  end subroutine


  subroutine space_charge_common_struct_set_particle_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_particle_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle_sigma_cutoff = value_in
  end subroutine

  ! space_charge_common_struct%space_charge_mesh_size: 1D_NOT_integer

  subroutine space_charge_common_struct_get_space_charge_mesh_size_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='space_charge_common_struct_get_space_charge_mesh_size_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(space_charge_common_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%space_charge_mesh_size)) then
      data_ptr = c_loc(struct_obj%space_charge_mesh_size(lbound(struct_obj%space_charge_mesh_size, 1)))
      bounds(1) = int(lbound(struct_obj%space_charge_mesh_size, 1), c_int)
      bounds(2) = int(ubound(struct_obj%space_charge_mesh_size, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! space_charge_common_struct%csr3d_mesh_size: 1D_NOT_integer

  subroutine space_charge_common_struct_get_csr3d_mesh_size_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='space_charge_common_struct_get_csr3d_mesh_size_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(space_charge_common_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%csr3d_mesh_size)) then
      data_ptr = c_loc(struct_obj%csr3d_mesh_size(lbound(struct_obj%csr3d_mesh_size, 1)))
      bounds(1) = int(lbound(struct_obj%csr3d_mesh_size, 1), c_int)
      bounds(2) = int(ubound(struct_obj%csr3d_mesh_size, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! space_charge_common_struct%n_bin: 0D_NOT_integer

  subroutine space_charge_common_struct_get_n_bin(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_n_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bin
  end subroutine


  subroutine space_charge_common_struct_set_n_bin(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_n_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bin = value_in
  end subroutine

  ! space_charge_common_struct%particle_bin_span: 0D_NOT_integer

  subroutine space_charge_common_struct_get_particle_bin_span(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_particle_bin_span')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle_bin_span
  end subroutine


  subroutine space_charge_common_struct_set_particle_bin_span(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_particle_bin_span')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle_bin_span = value_in
  end subroutine

  ! space_charge_common_struct%n_shield_images: 0D_NOT_integer

  subroutine space_charge_common_struct_get_n_shield_images(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_n_shield_images')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_shield_images
  end subroutine


  subroutine space_charge_common_struct_set_n_shield_images(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_n_shield_images')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_shield_images = value_in
  end subroutine

  ! space_charge_common_struct%sc_min_in_bin: 0D_NOT_integer

  subroutine space_charge_common_struct_get_sc_min_in_bin(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_sc_min_in_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sc_min_in_bin
  end subroutine


  subroutine space_charge_common_struct_set_sc_min_in_bin(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_sc_min_in_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sc_min_in_bin = value_in
  end subroutine

  ! space_charge_common_struct%lsc_kick_transverse_dependence: 0D_NOT_logical

  subroutine space_charge_common_struct_get_lsc_kick_transverse_dependence(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_lsc_kick_transverse_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lsc_kick_transverse_dependence
  end subroutine


  subroutine space_charge_common_struct_set_lsc_kick_transverse_dependence(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_lsc_kick_transverse_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lsc_kick_transverse_dependence = value_in
  end subroutine

  ! space_charge_common_struct%debug: 0D_NOT_logical

  subroutine space_charge_common_struct_get_debug(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%debug
  end subroutine


  subroutine space_charge_common_struct_set_debug(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%debug = value_in
  end subroutine

  ! space_charge_common_struct%diagnostic_output_file: 0D_NOT_character

  subroutine space_charge_common_struct_get_diagnostic_output_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='space_charge_common_struct_get_diagnostic_output_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%diagnostic_output_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%diagnostic_output_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine space_charge_common_struct_set_diagnostic_output_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='space_charge_common_struct_set_diagnostic_output_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(space_charge_common_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%diagnostic_output_file = str_in ! implicitly handles padding
  end subroutine

  !! bmad_common_struct

    function allocate_fortran_bmad_common_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bmad_common_struct), pointer :: fptr
      type(bmad_common_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bmad_common_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bmad_common_struct), pointer :: fptr
      type(bmad_common_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bmad_common_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bmad_common_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bmad_common_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bmad_common_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bmad_common_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bmad_common_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bmad_common_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bmad_common_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bmad_common_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bmad_common_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bmad_common_struct%max_aperture_limit: 0D_NOT_real

  subroutine bmad_common_struct_get_max_aperture_limit(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_max_aperture_limit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_aperture_limit
  end subroutine


  subroutine bmad_common_struct_set_max_aperture_limit(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_max_aperture_limit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_aperture_limit = value_in
  end subroutine

  ! bmad_common_struct%d_orb: 1D_NOT_real

  subroutine bmad_common_struct_get_d_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bmad_common_struct_get_d_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_common_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%d_orb)) then
      data_ptr = c_loc(struct_obj%d_orb(lbound(struct_obj%d_orb, 1)))
      bounds(1) = int(lbound(struct_obj%d_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_common_struct%default_ds_step: 0D_NOT_real

  subroutine bmad_common_struct_get_default_ds_step(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_default_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_ds_step
  end subroutine


  subroutine bmad_common_struct_set_default_ds_step(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_default_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_ds_step = value_in
  end subroutine

  ! bmad_common_struct%significant_length: 0D_NOT_real

  subroutine bmad_common_struct_get_significant_length(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_significant_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%significant_length
  end subroutine


  subroutine bmad_common_struct_set_significant_length(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_significant_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%significant_length = value_in
  end subroutine

  ! bmad_common_struct%rel_tol_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_rel_tol_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol_tracking
  end subroutine


  subroutine bmad_common_struct_set_rel_tol_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol_tracking = value_in
  end subroutine

  ! bmad_common_struct%abs_tol_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_abs_tol_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_tol_tracking
  end subroutine


  subroutine bmad_common_struct_set_abs_tol_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_tol_tracking = value_in
  end subroutine

  ! bmad_common_struct%rel_tol_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_rel_tol_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_rel_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_rel_tol_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_rel_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%abs_tol_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_abs_tol_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_abs_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_tol_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_abs_tol_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_abs_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_tol_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%init_ds_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_init_ds_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_init_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_ds_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_init_ds_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_init_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_ds_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%min_ds_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_min_ds_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_min_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%min_ds_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_min_ds_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_min_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%min_ds_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%fatal_ds_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_fatal_ds_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_fatal_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%fatal_ds_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_fatal_ds_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_fatal_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%fatal_ds_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%autoscale_amp_abs_tol: 0D_NOT_real

  subroutine bmad_common_struct_get_autoscale_amp_abs_tol(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_autoscale_amp_abs_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_amp_abs_tol
  end subroutine


  subroutine bmad_common_struct_set_autoscale_amp_abs_tol(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_autoscale_amp_abs_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_amp_abs_tol = value_in
  end subroutine

  ! bmad_common_struct%autoscale_amp_rel_tol: 0D_NOT_real

  subroutine bmad_common_struct_get_autoscale_amp_rel_tol(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_autoscale_amp_rel_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_amp_rel_tol
  end subroutine


  subroutine bmad_common_struct_set_autoscale_amp_rel_tol(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_autoscale_amp_rel_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_amp_rel_tol = value_in
  end subroutine

  ! bmad_common_struct%autoscale_phase_tol: 0D_NOT_real

  subroutine bmad_common_struct_get_autoscale_phase_tol(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_autoscale_phase_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_phase_tol
  end subroutine


  subroutine bmad_common_struct_set_autoscale_phase_tol(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_autoscale_phase_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_phase_tol = value_in
  end subroutine

  ! bmad_common_struct%electric_dipole_moment: 0D_NOT_real

  subroutine bmad_common_struct_get_electric_dipole_moment(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_electric_dipole_moment')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%electric_dipole_moment
  end subroutine


  subroutine bmad_common_struct_set_electric_dipole_moment(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_electric_dipole_moment')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%electric_dipole_moment = value_in
  end subroutine

  ! bmad_common_struct%synch_rad_scale: 0D_NOT_real

  subroutine bmad_common_struct_get_synch_rad_scale(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_synch_rad_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%synch_rad_scale
  end subroutine


  subroutine bmad_common_struct_set_synch_rad_scale(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_synch_rad_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%synch_rad_scale = value_in
  end subroutine

  ! bmad_common_struct%sad_eps_scale: 0D_NOT_real

  subroutine bmad_common_struct_get_sad_eps_scale(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sad_eps_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sad_eps_scale
  end subroutine


  subroutine bmad_common_struct_set_sad_eps_scale(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sad_eps_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sad_eps_scale = value_in
  end subroutine

  ! bmad_common_struct%sad_amp_max: 0D_NOT_real

  subroutine bmad_common_struct_get_sad_amp_max(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sad_amp_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sad_amp_max
  end subroutine


  subroutine bmad_common_struct_set_sad_amp_max(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sad_amp_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sad_amp_max = value_in
  end subroutine

  ! bmad_common_struct%sad_n_div_max: 0D_NOT_integer

  subroutine bmad_common_struct_get_sad_n_div_max(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sad_n_div_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sad_n_div_max
  end subroutine


  subroutine bmad_common_struct_set_sad_n_div_max(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sad_n_div_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sad_n_div_max = value_in
  end subroutine

  ! bmad_common_struct%taylor_order: 0D_NOT_integer

  subroutine bmad_common_struct_get_taylor_order(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%taylor_order
  end subroutine


  subroutine bmad_common_struct_set_taylor_order(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%taylor_order = value_in
  end subroutine

  ! bmad_common_struct%runge_kutta_order: 0D_NOT_integer

  subroutine bmad_common_struct_get_runge_kutta_order(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_runge_kutta_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%runge_kutta_order
  end subroutine


  subroutine bmad_common_struct_set_runge_kutta_order(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_runge_kutta_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%runge_kutta_order = value_in
  end subroutine

  ! bmad_common_struct%default_integ_order: 0D_NOT_integer

  subroutine bmad_common_struct_get_default_integ_order(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_default_integ_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_integ_order
  end subroutine


  subroutine bmad_common_struct_set_default_integ_order(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_default_integ_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_integ_order = value_in
  end subroutine

  ! bmad_common_struct%max_num_runge_kutta_step: 0D_NOT_integer

  subroutine bmad_common_struct_get_max_num_runge_kutta_step(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_max_num_runge_kutta_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_num_runge_kutta_step
  end subroutine


  subroutine bmad_common_struct_set_max_num_runge_kutta_step(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_max_num_runge_kutta_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_num_runge_kutta_step = value_in
  end subroutine

  ! bmad_common_struct%rf_phase_below_transition_ref: 0D_NOT_logical

  subroutine bmad_common_struct_get_rf_phase_below_transition_ref(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_rf_phase_below_transition_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_phase_below_transition_ref
  end subroutine


  subroutine bmad_common_struct_set_rf_phase_below_transition_ref(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_rf_phase_below_transition_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_phase_below_transition_ref = value_in
  end subroutine

  ! bmad_common_struct%sr_wakes_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_sr_wakes_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sr_wakes_on
  end subroutine


  subroutine bmad_common_struct_set_sr_wakes_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sr_wakes_on = value_in
  end subroutine

  ! bmad_common_struct%lr_wakes_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_lr_wakes_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_lr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lr_wakes_on
  end subroutine


  subroutine bmad_common_struct_set_lr_wakes_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_lr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lr_wakes_on = value_in
  end subroutine

  ! bmad_common_struct%auto_bookkeeper: 0D_NOT_logical

  subroutine bmad_common_struct_get_auto_bookkeeper(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_auto_bookkeeper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%auto_bookkeeper
  end subroutine


  subroutine bmad_common_struct_set_auto_bookkeeper(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_auto_bookkeeper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%auto_bookkeeper = value_in
  end subroutine

  ! bmad_common_struct%high_energy_space_charge_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_high_energy_space_charge_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_high_energy_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%high_energy_space_charge_on
  end subroutine


  subroutine bmad_common_struct_set_high_energy_space_charge_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_high_energy_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%high_energy_space_charge_on = value_in
  end subroutine

  ! bmad_common_struct%csr_and_space_charge_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_csr_and_space_charge_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_csr_and_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%csr_and_space_charge_on
  end subroutine


  subroutine bmad_common_struct_set_csr_and_space_charge_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_csr_and_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%csr_and_space_charge_on = value_in
  end subroutine

  ! bmad_common_struct%spin_tracking_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_spin_tracking_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_spin_tracking_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_tracking_on
  end subroutine


  subroutine bmad_common_struct_set_spin_tracking_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_spin_tracking_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_tracking_on = value_in
  end subroutine

  ! bmad_common_struct%spin_sokolov_ternov_flipping_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_spin_sokolov_ternov_flipping_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_spin_sokolov_ternov_flipping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_sokolov_ternov_flipping_on
  end subroutine


  subroutine bmad_common_struct_set_spin_sokolov_ternov_flipping_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_spin_sokolov_ternov_flipping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_sokolov_ternov_flipping_on = value_in
  end subroutine

  ! bmad_common_struct%radiation_damping_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_radiation_damping_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_radiation_damping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radiation_damping_on
  end subroutine


  subroutine bmad_common_struct_set_radiation_damping_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_radiation_damping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radiation_damping_on = value_in
  end subroutine

  ! bmad_common_struct%radiation_zero_average: 0D_NOT_logical

  subroutine bmad_common_struct_get_radiation_zero_average(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_radiation_zero_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radiation_zero_average
  end subroutine


  subroutine bmad_common_struct_set_radiation_zero_average(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_radiation_zero_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radiation_zero_average = value_in
  end subroutine

  ! bmad_common_struct%radiation_fluctuations_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_radiation_fluctuations_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_radiation_fluctuations_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radiation_fluctuations_on
  end subroutine


  subroutine bmad_common_struct_set_radiation_fluctuations_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_radiation_fluctuations_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radiation_fluctuations_on = value_in
  end subroutine

  ! bmad_common_struct%conserve_taylor_maps: 0D_NOT_logical

  subroutine bmad_common_struct_get_conserve_taylor_maps(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_conserve_taylor_maps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%conserve_taylor_maps
  end subroutine


  subroutine bmad_common_struct_set_conserve_taylor_maps(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_conserve_taylor_maps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%conserve_taylor_maps = value_in
  end subroutine

  ! bmad_common_struct%absolute_time_tracking: 0D_NOT_logical

  subroutine bmad_common_struct_get_absolute_time_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_absolute_time_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%absolute_time_tracking
  end subroutine


  subroutine bmad_common_struct_set_absolute_time_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_absolute_time_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%absolute_time_tracking = value_in
  end subroutine

  ! bmad_common_struct%absolute_time_ref_shift: 0D_NOT_logical

  subroutine bmad_common_struct_get_absolute_time_ref_shift(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_absolute_time_ref_shift')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%absolute_time_ref_shift
  end subroutine


  subroutine bmad_common_struct_set_absolute_time_ref_shift(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_absolute_time_ref_shift')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%absolute_time_ref_shift = value_in
  end subroutine

  ! bmad_common_struct%convert_to_kinetic_momentum: 0D_NOT_logical

  subroutine bmad_common_struct_get_convert_to_kinetic_momentum(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_convert_to_kinetic_momentum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%convert_to_kinetic_momentum
  end subroutine


  subroutine bmad_common_struct_set_convert_to_kinetic_momentum(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_convert_to_kinetic_momentum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%convert_to_kinetic_momentum = value_in
  end subroutine

  ! bmad_common_struct%normalize_twiss: 0D_NOT_logical

  subroutine bmad_common_struct_get_normalize_twiss(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_normalize_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%normalize_twiss
  end subroutine


  subroutine bmad_common_struct_set_normalize_twiss(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_normalize_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%normalize_twiss = value_in
  end subroutine

  ! bmad_common_struct%aperture_limit_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_aperture_limit_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_aperture_limit_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aperture_limit_on
  end subroutine


  subroutine bmad_common_struct_set_aperture_limit_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_aperture_limit_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aperture_limit_on = value_in
  end subroutine

  ! bmad_common_struct%spin_n0_direction_user_set: 0D_NOT_logical

  subroutine bmad_common_struct_get_spin_n0_direction_user_set(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_spin_n0_direction_user_set')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_n0_direction_user_set
  end subroutine


  subroutine bmad_common_struct_set_spin_n0_direction_user_set(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_spin_n0_direction_user_set')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_n0_direction_user_set = value_in
  end subroutine

  ! bmad_common_struct%debug: 0D_NOT_logical

  subroutine bmad_common_struct_get_debug(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%debug
  end subroutine


  subroutine bmad_common_struct_set_debug(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%debug = value_in
  end subroutine

  !! rad_int1_struct

    function allocate_fortran_rad_int1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rad_int1_struct), pointer :: fptr
      type(rad_int1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rad_int1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rad_int1_struct), pointer :: fptr
      type(rad_int1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rad_int1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_int1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rad_int1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rad_int1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rad_int1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rad_int1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rad_int1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rad_int1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rad_int1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rad_int1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rad_int1_struct%i0: 0D_NOT_real

  subroutine rad_int1_struct_get_i0(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i0
  end subroutine


  subroutine rad_int1_struct_set_i0(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i0 = value_in
  end subroutine

  ! rad_int1_struct%i1: 0D_NOT_real

  subroutine rad_int1_struct_get_i1(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i1
  end subroutine


  subroutine rad_int1_struct_set_i1(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i1 = value_in
  end subroutine

  ! rad_int1_struct%i2: 0D_NOT_real

  subroutine rad_int1_struct_get_i2(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i2
  end subroutine


  subroutine rad_int1_struct_set_i2(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i2 = value_in
  end subroutine

  ! rad_int1_struct%i3: 0D_NOT_real

  subroutine rad_int1_struct_get_i3(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i3
  end subroutine


  subroutine rad_int1_struct_set_i3(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i3 = value_in
  end subroutine

  ! rad_int1_struct%i4a: 0D_NOT_real

  subroutine rad_int1_struct_get_i4a(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i4a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i4a
  end subroutine


  subroutine rad_int1_struct_set_i4a(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i4a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i4a = value_in
  end subroutine

  ! rad_int1_struct%i4b: 0D_NOT_real

  subroutine rad_int1_struct_get_i4b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i4b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i4b
  end subroutine


  subroutine rad_int1_struct_set_i4b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i4b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i4b = value_in
  end subroutine

  ! rad_int1_struct%i4z: 0D_NOT_real

  subroutine rad_int1_struct_get_i4z(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i4z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i4z
  end subroutine


  subroutine rad_int1_struct_set_i4z(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i4z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i4z = value_in
  end subroutine

  ! rad_int1_struct%i5a: 0D_NOT_real

  subroutine rad_int1_struct_get_i5a(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i5a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5a
  end subroutine


  subroutine rad_int1_struct_set_i5a(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i5a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5a = value_in
  end subroutine

  ! rad_int1_struct%i5b: 0D_NOT_real

  subroutine rad_int1_struct_get_i5b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i5b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5b
  end subroutine


  subroutine rad_int1_struct_set_i5b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i5b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5b = value_in
  end subroutine

  ! rad_int1_struct%i6b: 0D_NOT_real

  subroutine rad_int1_struct_get_i6b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i6b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i6b
  end subroutine


  subroutine rad_int1_struct_set_i6b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i6b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i6b = value_in
  end subroutine

  ! rad_int1_struct%lin_i2_E4: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i2_E4(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i2_E4
  end subroutine


  subroutine rad_int1_struct_set_lin_i2_E4(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i2_E4 = value_in
  end subroutine

  ! rad_int1_struct%lin_i3_E7: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i3_E7(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i3_E7
  end subroutine


  subroutine rad_int1_struct_set_lin_i3_E7(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i3_E7 = value_in
  end subroutine

  ! rad_int1_struct%lin_i5a_E6: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i5a_E6(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i5a_E6
  end subroutine


  subroutine rad_int1_struct_set_lin_i5a_E6(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i5a_E6 = value_in
  end subroutine

  ! rad_int1_struct%lin_i5b_E6: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i5b_E6(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i5b_E6
  end subroutine


  subroutine rad_int1_struct_set_lin_i5b_E6(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i5b_E6 = value_in
  end subroutine

  ! rad_int1_struct%lin_norm_emit_a: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_norm_emit_a(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_norm_emit_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_norm_emit_a
  end subroutine


  subroutine rad_int1_struct_set_lin_norm_emit_a(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_norm_emit_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_norm_emit_a = value_in
  end subroutine

  ! rad_int1_struct%lin_norm_emit_b: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_norm_emit_b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_norm_emit_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_norm_emit_b
  end subroutine


  subroutine rad_int1_struct_set_lin_norm_emit_b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_norm_emit_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_norm_emit_b = value_in
  end subroutine

  ! rad_int1_struct%lin_sig_E: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_sig_E(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_sig_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_sig_E
  end subroutine


  subroutine rad_int1_struct_set_lin_sig_E(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_sig_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_sig_E = value_in
  end subroutine

  ! rad_int1_struct%n_steps: 0D_NOT_real

  subroutine rad_int1_struct_get_n_steps(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_n_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_steps
  end subroutine


  subroutine rad_int1_struct_set_n_steps(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_n_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_steps = value_in
  end subroutine

  !! rad_int_branch_struct

    function allocate_fortran_rad_int_branch_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rad_int_branch_struct), pointer :: fptr
      type(rad_int_branch_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rad_int_branch_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rad_int_branch_struct), pointer :: fptr
      type(rad_int_branch_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rad_int_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_int_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rad_int_branch_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rad_int_branch_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rad_int_branch_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rad_int_branch_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rad_int_branch_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rad_int_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rad_int_branch_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rad_int_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rad_int_branch_struct%ele: 1D_ALLOC_type

  subroutine rad_int_branch_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='rad_int_branch_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_int_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! rad_int_all_ele_struct

    function allocate_fortran_rad_int_all_ele_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rad_int_all_ele_struct), pointer :: fptr
      type(rad_int_all_ele_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rad_int_all_ele_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rad_int_all_ele_struct), pointer :: fptr
      type(rad_int_all_ele_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rad_int_all_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_int_all_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rad_int_all_ele_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rad_int_all_ele_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rad_int_all_ele_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rad_int_all_ele_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rad_int_all_ele_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rad_int_all_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rad_int_all_ele_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rad_int_all_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rad_int_all_ele_struct%branch: 1D_ALLOC_type

  subroutine rad_int_all_ele_struct_get_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='rad_int_all_ele_struct_get_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_int_all_ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%branch) .and. is_contiguous(struct_obj%branch)) then
      data_ptr = c_loc(struct_obj%branch(lbound(struct_obj%branch, 1)))
      bounds(1) = int(lbound(struct_obj%branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! rf_stair_step_struct

    function allocate_fortran_rf_stair_step_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rf_stair_step_struct), pointer :: fptr
      type(rf_stair_step_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rf_stair_step_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rf_stair_step_struct), pointer :: fptr
      type(rf_stair_step_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rf_stair_step_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rf_stair_step_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rf_stair_step_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rf_stair_step_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rf_stair_step_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rf_stair_step_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rf_stair_step_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rf_stair_step_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rf_stair_step_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rf_stair_step_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rf_stair_step_struct%E_tot0: 0D_NOT_real

  subroutine rf_stair_step_struct_get_E_tot0(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_E_tot0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_tot0
  end subroutine


  subroutine rf_stair_step_struct_set_E_tot0(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_E_tot0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_tot0 = value_in
  end subroutine

  ! rf_stair_step_struct%E_tot1: 0D_NOT_real

  subroutine rf_stair_step_struct_get_E_tot1(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_E_tot1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_tot1
  end subroutine


  subroutine rf_stair_step_struct_set_E_tot1(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_E_tot1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_tot1 = value_in
  end subroutine

  ! rf_stair_step_struct%p0c: 0D_NOT_real

  subroutine rf_stair_step_struct_get_p0c(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p0c
  end subroutine


  subroutine rf_stair_step_struct_set_p0c(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p0c = value_in
  end subroutine

  ! rf_stair_step_struct%p1c: 0D_NOT_real

  subroutine rf_stair_step_struct_get_p1c(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_p1c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p1c
  end subroutine


  subroutine rf_stair_step_struct_set_p1c(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_p1c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p1c = value_in
  end subroutine

  ! rf_stair_step_struct%scale: 0D_NOT_real

  subroutine rf_stair_step_struct_get_scale(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scale
  end subroutine


  subroutine rf_stair_step_struct_set_scale(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scale = value_in
  end subroutine

  ! rf_stair_step_struct%time: 0D_NOT_real

  subroutine rf_stair_step_struct_get_time(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time
  end subroutine


  subroutine rf_stair_step_struct_set_time(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time = value_in
  end subroutine

  ! rf_stair_step_struct%s0: 0D_NOT_real

  subroutine rf_stair_step_struct_get_s0(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_s0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s0
  end subroutine


  subroutine rf_stair_step_struct_set_s0(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_s0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s0 = value_in
  end subroutine

  ! rf_stair_step_struct%s: 0D_NOT_real

  subroutine rf_stair_step_struct_get_s(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine rf_stair_step_struct_set_s(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! rf_stair_step_struct%ix_step: 0D_NOT_integer

  subroutine rf_stair_step_struct_get_ix_step(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_ix_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_step
  end subroutine


  subroutine rf_stair_step_struct_set_ix_step(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_ix_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_step = value_in
  end subroutine

  !! rf_ele_struct

    function allocate_fortran_rf_ele_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(rf_ele_struct), pointer :: fptr
      type(rf_ele_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_rf_ele_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(rf_ele_struct), pointer :: fptr
      type(rf_ele_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_rf_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rf_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_rf_ele_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(rf_ele_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_rf_ele_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(rf_ele_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_rf_ele_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(rf_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_rf_ele_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(rf_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! rf_ele_struct%steps: 1D_ALLOC_type

  subroutine rf_ele_struct_get_steps_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='rf_ele_struct_get_steps_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rf_ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%steps) .and. is_contiguous(struct_obj%steps)) then
      data_ptr = c_loc(struct_obj%steps(lbound(struct_obj%steps, 1)))
      bounds(1) = int(lbound(struct_obj%steps, 1), c_int)
      bounds(2) = int(ubound(struct_obj%steps, 1), c_int)
      
      el_size = int(storage_size(struct_obj%steps(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! rf_ele_struct%ds_step: 0D_NOT_real

  subroutine rf_ele_struct_get_ds_step(struct_obj_ptr, value_out) bind(c, name='rf_ele_struct_get_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_step
  end subroutine


  subroutine rf_ele_struct_set_ds_step(struct_obj_ptr, value_in) bind(c, name='rf_ele_struct_set_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_step = value_in
  end subroutine

  !! ele_struct

    function allocate_fortran_ele_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ele_struct), pointer :: fptr
      type(ele_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ele_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ele_struct), pointer :: fptr
      type(ele_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ele_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ele_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ele_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ele_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ele_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ele_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ele_struct%name: 0D_NOT_character

  subroutine ele_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%type: 0D_NOT_character

  subroutine ele_struct_get_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%type = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%alias: 0D_NOT_character

  subroutine ele_struct_get_alias_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_alias_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%alias)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%alias), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_alias(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_alias')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%alias = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%component_name: 0D_NOT_character

  subroutine ele_struct_get_component_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_component_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%component_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%component_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_component_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_component_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%component_name = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%descrip: 0D_PTR_character

  subroutine ele_struct_get_descrip_info(struct_obj_ptr, data_ptr, str_len, is_allocated) &
    bind(c, name='ele_struct_get_descrip_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%descrip)) then
      data_ptr = c_loc(struct_obj%descrip)
      str_len = int(len(struct_obj%descrip), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine


  subroutine ele_struct_set_descrip(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_descrip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: temp_str

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%descrip)) deallocate(struct_obj%descrip)

    if (str_len > 0) then
        call c_f_pointer(str_ptr, temp_str)
        allocate(struct_obj%descrip, source=temp_str)
    else
        nullify(struct_obj%descrip)
    endif
  end subroutine

  ! ele_struct%a: 0D_NOT_type

  subroutine ele_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine ele_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! ele_struct%b: 0D_NOT_type

  subroutine ele_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine ele_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! ele_struct%z: 0D_NOT_type

  subroutine ele_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine ele_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! ele_struct%x: 0D_NOT_type

  subroutine ele_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine ele_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(xy_disp_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! ele_struct%y: 0D_NOT_type

  subroutine ele_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine ele_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(xy_disp_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  ! ele_struct%ac_kick: 0D_PTR_type

  subroutine ele_struct_get_ac_kick(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_ac_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ac_kick)) then
      ptr_out = c_loc(struct_obj%ac_kick)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_ac_kick(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_ac_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(ac_kicker_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ac_kick)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ac_kick = src_obj
    endif
  end subroutine

  ! ele_struct%bookkeeping_state: 0D_NOT_type

  subroutine ele_struct_get_bookkeeping_state(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%bookkeeping_state)
  end subroutine


  subroutine ele_struct_set_bookkeeping_state(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(bookkeeping_state_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%bookkeeping_state = src_obj
  end subroutine

  ! ele_struct%branch: 0D_PTR_type

  subroutine ele_struct_get_branch(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%branch)) then
      ptr_out = c_loc(struct_obj%branch)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_branch(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(branch_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%branch)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%branch = src_obj
    endif
  end subroutine

  ! ele_struct%control: 0D_PTR_type

  subroutine ele_struct_get_control(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%control)) then
      ptr_out = c_loc(struct_obj%control)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_control(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(controller_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%control)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%control = src_obj
    endif
  end subroutine

  ! ele_struct%rf: 0D_PTR_type

  subroutine ele_struct_get_rf(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_rf')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rf)) then
      ptr_out = c_loc(struct_obj%rf)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_rf(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_rf')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(rf_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rf)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%rf = src_obj
    endif
  end subroutine

  ! ele_struct%lord: 0D_PTR_type

  subroutine ele_struct_get_lord(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lord)) then
      ptr_out = c_loc(struct_obj%lord)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_lord(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lord)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%lord = src_obj
    endif
  end subroutine

  ! ele_struct%floor: 0D_NOT_type

  subroutine ele_struct_get_floor(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_floor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%floor)
  end subroutine


  subroutine ele_struct_set_floor(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_floor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(floor_position_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%floor = src_obj
  end subroutine

  ! ele_struct%high_energy_space_charge: 0D_PTR_type

  subroutine ele_struct_get_high_energy_space_charge(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_high_energy_space_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%high_energy_space_charge)) then
      ptr_out = c_loc(struct_obj%high_energy_space_charge)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_high_energy_space_charge(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_high_energy_space_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(high_energy_space_charge_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%high_energy_space_charge)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%high_energy_space_charge = src_obj
    endif
  end subroutine

  ! ele_struct%mode3: 0D_PTR_type

  subroutine ele_struct_get_mode3(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_mode3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%mode3)) then
      ptr_out = c_loc(struct_obj%mode3)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_mode3(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_mode3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(mode3_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%mode3)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%mode3 = src_obj
    endif
  end subroutine

  ! ele_struct%photon: 0D_PTR_type

  subroutine ele_struct_get_photon(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%photon)) then
      ptr_out = c_loc(struct_obj%photon)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_photon(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(photon_element_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%photon)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%photon = src_obj
    endif
  end subroutine

  ! ele_struct%rad_map: 0D_PTR_type

  subroutine ele_struct_get_rad_map(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_rad_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rad_map)) then
      ptr_out = c_loc(struct_obj%rad_map)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_rad_map(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_rad_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(rad_map_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rad_map)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%rad_map = src_obj
    endif
  end subroutine

  ! ele_struct%taylor: 1D_NOT_type

  subroutine ele_struct_get_taylor_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_taylor_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%taylor)) then
      data_ptr = c_loc(struct_obj%taylor(lbound(struct_obj%taylor, 1)))
      bounds(1) = int(lbound(struct_obj%taylor, 1), c_int)
      bounds(2) = int(ubound(struct_obj%taylor, 1), c_int)
      
      el_size = int(storage_size(struct_obj%taylor(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%spin_taylor_ref_orb_in: 1D_NOT_real

  subroutine ele_struct_get_spin_taylor_ref_orb_in_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_spin_taylor_ref_orb_in_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin_taylor_ref_orb_in)) then
      data_ptr = c_loc(struct_obj%spin_taylor_ref_orb_in(lbound(struct_obj%spin_taylor_ref_orb_in, 1)))
      bounds(1) = int(lbound(struct_obj%spin_taylor_ref_orb_in, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_taylor_ref_orb_in, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%spin_taylor: 1D_NOT_type

  subroutine ele_struct_get_spin_taylor_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_spin_taylor_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin_taylor)) then
      data_ptr = c_loc(struct_obj%spin_taylor(lbound(struct_obj%spin_taylor, 1)))
      bounds(1) = int(lbound(struct_obj%spin_taylor, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_taylor, 1), c_int)
      
      el_size = int(storage_size(struct_obj%spin_taylor(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%wake: 0D_PTR_type

  subroutine ele_struct_get_wake(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_wake')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%wake)) then
      ptr_out = c_loc(struct_obj%wake)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_wake(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_wake')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(wake_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%wake)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%wake = src_obj
    endif
  end subroutine

  ! ele_struct%wall3d: 1D_PTR_type

  subroutine ele_struct_get_wall3d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_wall3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%wall3d) .and. is_contiguous(struct_obj%wall3d)) then
      data_ptr = c_loc(struct_obj%wall3d(lbound(struct_obj%wall3d, 1)))
      bounds(1) = int(lbound(struct_obj%wall3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%wall3d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%wall3d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%cartesian_map: 1D_PTR_type

  subroutine ele_struct_get_cartesian_map_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_cartesian_map_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%cartesian_map) .and. is_contiguous(struct_obj%cartesian_map)) then
      data_ptr = c_loc(struct_obj%cartesian_map(lbound(struct_obj%cartesian_map, 1)))
      bounds(1) = int(lbound(struct_obj%cartesian_map, 1), c_int)
      bounds(2) = int(ubound(struct_obj%cartesian_map, 1), c_int)
      
      el_size = int(storage_size(struct_obj%cartesian_map(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%cylindrical_map: 1D_PTR_type

  subroutine ele_struct_get_cylindrical_map_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_cylindrical_map_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%cylindrical_map) .and. is_contiguous(struct_obj%cylindrical_map)) then
      data_ptr = c_loc(struct_obj%cylindrical_map(lbound(struct_obj%cylindrical_map, 1)))
      bounds(1) = int(lbound(struct_obj%cylindrical_map, 1), c_int)
      bounds(2) = int(ubound(struct_obj%cylindrical_map, 1), c_int)
      
      el_size = int(storage_size(struct_obj%cylindrical_map(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%gen_grad_map: 1D_PTR_type

  subroutine ele_struct_get_gen_grad_map_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_gen_grad_map_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%gen_grad_map) .and. is_contiguous(struct_obj%gen_grad_map)) then
      data_ptr = c_loc(struct_obj%gen_grad_map(lbound(struct_obj%gen_grad_map, 1)))
      bounds(1) = int(lbound(struct_obj%gen_grad_map, 1), c_int)
      bounds(2) = int(ubound(struct_obj%gen_grad_map, 1), c_int)
      
      el_size = int(storage_size(struct_obj%gen_grad_map(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%grid_field: 1D_PTR_type

  subroutine ele_struct_get_grid_field_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_grid_field_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%grid_field) .and. is_contiguous(struct_obj%grid_field)) then
      data_ptr = c_loc(struct_obj%grid_field(lbound(struct_obj%grid_field, 1)))
      bounds(1) = int(lbound(struct_obj%grid_field, 1), c_int)
      bounds(2) = int(ubound(struct_obj%grid_field, 1), c_int)
      
      el_size = int(storage_size(struct_obj%grid_field(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%map_ref_orb_in: 0D_NOT_type

  subroutine ele_struct_get_map_ref_orb_in(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_map_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%map_ref_orb_in)
  end subroutine


  subroutine ele_struct_set_map_ref_orb_in(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_map_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%map_ref_orb_in = src_obj
  end subroutine

  ! ele_struct%map_ref_orb_out: 0D_NOT_type

  subroutine ele_struct_get_map_ref_orb_out(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_map_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%map_ref_orb_out)
  end subroutine


  subroutine ele_struct_set_map_ref_orb_out(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_map_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%map_ref_orb_out = src_obj
  end subroutine

  ! ele_struct%time_ref_orb_in: 0D_NOT_type

  subroutine ele_struct_get_time_ref_orb_in(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_time_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%time_ref_orb_in)
  end subroutine


  subroutine ele_struct_set_time_ref_orb_in(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_time_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%time_ref_orb_in = src_obj
  end subroutine

  ! ele_struct%time_ref_orb_out: 0D_NOT_type

  subroutine ele_struct_get_time_ref_orb_out(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_time_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%time_ref_orb_out)
  end subroutine


  subroutine ele_struct_set_time_ref_orb_out(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_time_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%time_ref_orb_out = src_obj
  end subroutine

  ! ele_struct%value: 1D_NOT_real

  subroutine ele_struct_get_value_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_value_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%value)) then
      data_ptr = c_loc(struct_obj%value(lbound(struct_obj%value, 1)))
      bounds(1) = int(lbound(struct_obj%value, 1), c_int)
      bounds(2) = int(ubound(struct_obj%value, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%old_value: 1D_NOT_real

  subroutine ele_struct_get_old_value_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_old_value_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%old_value)) then
      data_ptr = c_loc(struct_obj%old_value(lbound(struct_obj%old_value, 1)))
      bounds(1) = int(lbound(struct_obj%old_value, 1), c_int)
      bounds(2) = int(ubound(struct_obj%old_value, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%spin_q: 2D_NOT_real

  subroutine ele_struct_get_spin_q_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_spin_q_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin_q)) then
      data_ptr = c_loc(struct_obj%spin_q(lbound(struct_obj%spin_q, 1), lbound(struct_obj%spin_q, 2)))
      bounds(1) = int(lbound(struct_obj%spin_q, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_q, 1), c_int)
      bounds(3) = int(lbound(struct_obj%spin_q, 2), c_int)
      bounds(4) = int(ubound(struct_obj%spin_q, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%vec0: 1D_NOT_real

  subroutine ele_struct_get_vec0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_vec0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%vec0)) then
      data_ptr = c_loc(struct_obj%vec0(lbound(struct_obj%vec0, 1)))
      bounds(1) = int(lbound(struct_obj%vec0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%mat6: 2D_NOT_real

  subroutine ele_struct_get_mat6_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_mat6_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%mat6)) then
      data_ptr = c_loc(struct_obj%mat6(lbound(struct_obj%mat6, 1), lbound(struct_obj%mat6, 2)))
      bounds(1) = int(lbound(struct_obj%mat6, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat6, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat6, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat6, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%c_mat: 2D_NOT_real

  subroutine ele_struct_get_c_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_c_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%c_mat)) then
      data_ptr = c_loc(struct_obj%c_mat(lbound(struct_obj%c_mat, 1), lbound(struct_obj%c_mat, 2)))
      bounds(1) = int(lbound(struct_obj%c_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%c_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%c_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%c_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%dc_mat_dpz: 2D_NOT_real

  subroutine ele_struct_get_dc_mat_dpz_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_dc_mat_dpz_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dc_mat_dpz)) then
      data_ptr = c_loc(struct_obj%dc_mat_dpz(lbound(struct_obj%dc_mat_dpz, 1), lbound(struct_obj%dc_mat_dpz, 2)))
      bounds(1) = int(lbound(struct_obj%dc_mat_dpz, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dc_mat_dpz, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dc_mat_dpz, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dc_mat_dpz, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%gamma_c: 0D_NOT_real

  subroutine ele_struct_get_gamma_c(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_gamma_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gamma_c
  end subroutine


  subroutine ele_struct_set_gamma_c(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_gamma_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gamma_c = value_in
  end subroutine

  ! ele_struct%s_start: 0D_NOT_real

  subroutine ele_struct_get_s_start(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_s_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_start
  end subroutine


  subroutine ele_struct_set_s_start(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_s_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_start = value_in
  end subroutine

  ! ele_struct%s: 0D_NOT_real

  subroutine ele_struct_get_s(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine ele_struct_set_s(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! ele_struct%ref_time: 0D_NOT_real

  subroutine ele_struct_get_ref_time(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ref_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_time
  end subroutine


  subroutine ele_struct_set_ref_time(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ref_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_time = value_in
  end subroutine

  ! ele_struct%a_pole: 1D_PTR_real

  subroutine ele_struct_get_a_pole_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_a_pole_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%a_pole) .and. is_contiguous(struct_obj%a_pole)) then
      data_ptr = c_loc(struct_obj%a_pole(lbound(struct_obj%a_pole, 1)))
      bounds(1) = int(lbound(struct_obj%a_pole, 1), c_int)
      bounds(2) = int(ubound(struct_obj%a_pole, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%b_pole: 1D_PTR_real

  subroutine ele_struct_get_b_pole_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_b_pole_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%b_pole) .and. is_contiguous(struct_obj%b_pole)) then
      data_ptr = c_loc(struct_obj%b_pole(lbound(struct_obj%b_pole, 1)))
      bounds(1) = int(lbound(struct_obj%b_pole, 1), c_int)
      bounds(2) = int(ubound(struct_obj%b_pole, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%a_pole_elec: 1D_PTR_real

  subroutine ele_struct_get_a_pole_elec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_a_pole_elec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%a_pole_elec) .and. is_contiguous(struct_obj%a_pole_elec)) then
      data_ptr = c_loc(struct_obj%a_pole_elec(lbound(struct_obj%a_pole_elec, 1)))
      bounds(1) = int(lbound(struct_obj%a_pole_elec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%a_pole_elec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%b_pole_elec: 1D_PTR_real

  subroutine ele_struct_get_b_pole_elec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_b_pole_elec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%b_pole_elec) .and. is_contiguous(struct_obj%b_pole_elec)) then
      data_ptr = c_loc(struct_obj%b_pole_elec(lbound(struct_obj%b_pole_elec, 1)))
      bounds(1) = int(lbound(struct_obj%b_pole_elec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%b_pole_elec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%custom: 1D_PTR_real

  subroutine ele_struct_get_custom_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_custom_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%custom) .and. is_contiguous(struct_obj%custom)) then
      data_ptr = c_loc(struct_obj%custom(lbound(struct_obj%custom, 1)))
      bounds(1) = int(lbound(struct_obj%custom, 1), c_int)
      bounds(2) = int(ubound(struct_obj%custom, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%r: 3D_PTR_real

  subroutine ele_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%r) .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1), lbound(struct_obj%r, 2), lbound(struct_obj%r, 3)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      bounds(3) = int(lbound(struct_obj%r, 2), c_int)
      bounds(4) = int(ubound(struct_obj%r, 2), c_int)
      bounds(5) = int(lbound(struct_obj%r, 3), c_int)
      bounds(6) = int(ubound(struct_obj%r, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%key: 0D_NOT_integer

  subroutine ele_struct_get_key(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%key
  end subroutine


  subroutine ele_struct_set_key(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%key = value_in
  end subroutine

  ! ele_struct%sub_key: 0D_NOT_integer

  subroutine ele_struct_get_sub_key(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_sub_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sub_key
  end subroutine


  subroutine ele_struct_set_sub_key(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_sub_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sub_key = value_in
  end subroutine

  ! ele_struct%ix_ele: 0D_NOT_integer

  subroutine ele_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine ele_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! ele_struct%ix_branch: 0D_NOT_integer

  subroutine ele_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine ele_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! ele_struct%lord_status: 0D_NOT_integer

  subroutine ele_struct_get_lord_status(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_lord_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lord_status
  end subroutine


  subroutine ele_struct_set_lord_status(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_lord_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lord_status = value_in
  end subroutine

  ! ele_struct%n_slave: 0D_NOT_integer

  subroutine ele_struct_get_n_slave(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_slave
  end subroutine


  subroutine ele_struct_set_n_slave(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_slave = value_in
  end subroutine

  ! ele_struct%n_slave_field: 0D_NOT_integer

  subroutine ele_struct_get_n_slave_field(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_slave_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_slave_field
  end subroutine


  subroutine ele_struct_set_n_slave_field(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_slave_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_slave_field = value_in
  end subroutine

  ! ele_struct%ix1_slave: 0D_NOT_integer

  subroutine ele_struct_get_ix1_slave(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix1_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix1_slave
  end subroutine


  subroutine ele_struct_set_ix1_slave(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix1_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix1_slave = value_in
  end subroutine

  ! ele_struct%slave_status: 0D_NOT_integer

  subroutine ele_struct_get_slave_status(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_slave_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%slave_status
  end subroutine


  subroutine ele_struct_set_slave_status(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_slave_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%slave_status = value_in
  end subroutine

  ! ele_struct%n_lord: 0D_NOT_integer

  subroutine ele_struct_get_n_lord(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_lord
  end subroutine


  subroutine ele_struct_set_n_lord(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_lord = value_in
  end subroutine

  ! ele_struct%n_lord_field: 0D_NOT_integer

  subroutine ele_struct_get_n_lord_field(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_lord_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_lord_field
  end subroutine


  subroutine ele_struct_set_n_lord_field(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_lord_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_lord_field = value_in
  end subroutine

  ! ele_struct%n_lord_ramper: 0D_NOT_integer

  subroutine ele_struct_get_n_lord_ramper(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_lord_ramper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_lord_ramper
  end subroutine


  subroutine ele_struct_set_n_lord_ramper(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_lord_ramper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_lord_ramper = value_in
  end subroutine

  ! ele_struct%ic1_lord: 0D_NOT_integer

  subroutine ele_struct_get_ic1_lord(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ic1_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ic1_lord
  end subroutine


  subroutine ele_struct_set_ic1_lord(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ic1_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ic1_lord = value_in
  end subroutine

  ! ele_struct%ix_pointer: 0D_NOT_integer

  subroutine ele_struct_get_ix_pointer(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix_pointer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_pointer
  end subroutine


  subroutine ele_struct_set_ix_pointer(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix_pointer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_pointer = value_in
  end subroutine

  ! ele_struct%ixx: 0D_NOT_integer

  subroutine ele_struct_get_ixx(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ixx
  end subroutine


  subroutine ele_struct_set_ixx(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ixx = value_in
  end subroutine

  ! ele_struct%iyy: 0D_NOT_integer

  subroutine ele_struct_get_iyy(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_iyy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iyy
  end subroutine


  subroutine ele_struct_set_iyy(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_iyy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iyy = value_in
  end subroutine

  ! ele_struct%izz: 0D_NOT_integer

  subroutine ele_struct_get_izz(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_izz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%izz
  end subroutine


  subroutine ele_struct_set_izz(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_izz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%izz = value_in
  end subroutine

  ! ele_struct%mat6_calc_method: 0D_NOT_integer

  subroutine ele_struct_get_mat6_calc_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_mat6_calc_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mat6_calc_method
  end subroutine


  subroutine ele_struct_set_mat6_calc_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_mat6_calc_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mat6_calc_method = value_in
  end subroutine

  ! ele_struct%tracking_method: 0D_NOT_integer

  subroutine ele_struct_get_tracking_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tracking_method
  end subroutine


  subroutine ele_struct_set_tracking_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tracking_method = value_in
  end subroutine

  ! ele_struct%spin_tracking_method: 0D_NOT_integer

  subroutine ele_struct_get_spin_tracking_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_spin_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_tracking_method
  end subroutine


  subroutine ele_struct_set_spin_tracking_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_spin_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_tracking_method = value_in
  end subroutine

  ! ele_struct%csr_method: 0D_NOT_integer

  subroutine ele_struct_get_csr_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_csr_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%csr_method
  end subroutine


  subroutine ele_struct_set_csr_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_csr_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%csr_method = value_in
  end subroutine

  ! ele_struct%space_charge_method: 0D_NOT_integer

  subroutine ele_struct_get_space_charge_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_space_charge_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%space_charge_method
  end subroutine


  subroutine ele_struct_set_space_charge_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_space_charge_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%space_charge_method = value_in
  end subroutine

  ! ele_struct%ptc_integration_type: 0D_NOT_integer

  subroutine ele_struct_get_ptc_integration_type(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ptc_integration_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ptc_integration_type
  end subroutine


  subroutine ele_struct_set_ptc_integration_type(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ptc_integration_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ptc_integration_type = value_in
  end subroutine

  ! ele_struct%field_calc: 0D_NOT_integer

  subroutine ele_struct_get_field_calc(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_field_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_calc
  end subroutine


  subroutine ele_struct_set_field_calc(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_field_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_calc = value_in
  end subroutine

  ! ele_struct%aperture_at: 0D_NOT_integer

  subroutine ele_struct_get_aperture_at(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_aperture_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aperture_at
  end subroutine


  subroutine ele_struct_set_aperture_at(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_aperture_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aperture_at = value_in
  end subroutine

  ! ele_struct%aperture_type: 0D_NOT_integer

  subroutine ele_struct_get_aperture_type(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_aperture_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aperture_type
  end subroutine


  subroutine ele_struct_set_aperture_type(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_aperture_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aperture_type = value_in
  end subroutine

  ! ele_struct%ref_species: 0D_NOT_integer

  subroutine ele_struct_get_ref_species(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ref_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_species
  end subroutine


  subroutine ele_struct_set_ref_species(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ref_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_species = value_in
  end subroutine

  ! ele_struct%orientation: 0D_NOT_integer

  subroutine ele_struct_get_orientation(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_orientation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%orientation
  end subroutine


  subroutine ele_struct_set_orientation(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_orientation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%orientation = value_in
  end subroutine

  ! ele_struct%symplectify: 0D_NOT_logical

  subroutine ele_struct_get_symplectify(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_symplectify')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%symplectify
  end subroutine


  subroutine ele_struct_set_symplectify(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_symplectify')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%symplectify = value_in
  end subroutine

  ! ele_struct%mode_flip: 0D_NOT_logical

  subroutine ele_struct_get_mode_flip(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_mode_flip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mode_flip
  end subroutine


  subroutine ele_struct_set_mode_flip(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_mode_flip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mode_flip = value_in
  end subroutine

  ! ele_struct%multipoles_on: 0D_NOT_logical

  subroutine ele_struct_get_multipoles_on(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_multipoles_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%multipoles_on
  end subroutine


  subroutine ele_struct_set_multipoles_on(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_multipoles_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%multipoles_on = value_in
  end subroutine

  ! ele_struct%scale_multipoles: 0D_NOT_logical

  subroutine ele_struct_get_scale_multipoles(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_scale_multipoles')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scale_multipoles
  end subroutine


  subroutine ele_struct_set_scale_multipoles(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_scale_multipoles')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scale_multipoles = value_in
  end subroutine

  ! ele_struct%taylor_map_includes_offsets: 0D_NOT_logical

  subroutine ele_struct_get_taylor_map_includes_offsets(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_taylor_map_includes_offsets')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%taylor_map_includes_offsets
  end subroutine


  subroutine ele_struct_set_taylor_map_includes_offsets(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_taylor_map_includes_offsets')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%taylor_map_includes_offsets = value_in
  end subroutine

  ! ele_struct%field_master: 0D_NOT_logical

  subroutine ele_struct_get_field_master(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_field_master')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_master
  end subroutine


  subroutine ele_struct_set_field_master(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_field_master')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_master = value_in
  end subroutine

  ! ele_struct%is_on: 0D_NOT_logical

  subroutine ele_struct_get_is_on(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_on
  end subroutine


  subroutine ele_struct_set_is_on(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_on = value_in
  end subroutine

  ! ele_struct%logic: 0D_NOT_logical

  subroutine ele_struct_get_logic(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%logic
  end subroutine


  subroutine ele_struct_set_logic(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%logic = value_in
  end subroutine

  ! ele_struct%bmad_logic: 0D_NOT_logical

  subroutine ele_struct_get_bmad_logic(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_bmad_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bmad_logic
  end subroutine


  subroutine ele_struct_set_bmad_logic(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_bmad_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bmad_logic = value_in
  end subroutine

  ! ele_struct%select: 0D_NOT_logical

  subroutine ele_struct_get_select(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_select')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%select
  end subroutine


  subroutine ele_struct_set_select(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_select')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%select = value_in
  end subroutine

  ! ele_struct%offset_moves_aperture: 0D_NOT_logical

  subroutine ele_struct_get_offset_moves_aperture(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_offset_moves_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%offset_moves_aperture
  end subroutine


  subroutine ele_struct_set_offset_moves_aperture(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_offset_moves_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%offset_moves_aperture = value_in
  end subroutine

  !! complex_taylor_term_struct

    function allocate_fortran_complex_taylor_term_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(complex_taylor_term_struct), pointer :: fptr
      type(complex_taylor_term_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_complex_taylor_term_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(complex_taylor_term_struct), pointer :: fptr
      type(complex_taylor_term_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_complex_taylor_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(complex_taylor_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_complex_taylor_term_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(complex_taylor_term_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_complex_taylor_term_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(complex_taylor_term_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_complex_taylor_term_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(complex_taylor_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_complex_taylor_term_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(complex_taylor_term_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! complex_taylor_term_struct%coef: 0D_NOT_complex

  subroutine complex_taylor_term_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='complex_taylor_term_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(complex_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine complex_taylor_term_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='complex_taylor_term_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(complex_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! complex_taylor_term_struct%expn: 1D_NOT_integer

  subroutine complex_taylor_term_struct_get_expn_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='complex_taylor_term_struct_get_expn_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(complex_taylor_term_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%expn)) then
      data_ptr = c_loc(struct_obj%expn(lbound(struct_obj%expn, 1)))
      bounds(1) = int(lbound(struct_obj%expn, 1), c_int)
      bounds(2) = int(ubound(struct_obj%expn, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! complex_taylor_struct

    function allocate_fortran_complex_taylor_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(complex_taylor_struct), pointer :: fptr
      type(complex_taylor_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_complex_taylor_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(complex_taylor_struct), pointer :: fptr
      type(complex_taylor_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_complex_taylor_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(complex_taylor_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_complex_taylor_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(complex_taylor_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_complex_taylor_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(complex_taylor_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_complex_taylor_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(complex_taylor_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_complex_taylor_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(complex_taylor_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! complex_taylor_struct%ref: 0D_NOT_complex

  subroutine complex_taylor_struct_get_ref(struct_obj_ptr, value_out) bind(c, name='complex_taylor_struct_get_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(complex_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref
  end subroutine


  subroutine complex_taylor_struct_set_ref(struct_obj_ptr, value_in) bind(c, name='complex_taylor_struct_set_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(complex_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref = value_in
  end subroutine

  ! complex_taylor_struct%term: 1D_PTR_type

  subroutine complex_taylor_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='complex_taylor_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(complex_taylor_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! branch_struct

    function allocate_fortran_branch_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(branch_struct), pointer :: fptr
      type(branch_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_branch_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(branch_struct), pointer :: fptr
      type(branch_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_branch_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(branch_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_branch_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(branch_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_branch_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_branch_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! branch_struct%name: 0D_NOT_character

  subroutine branch_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='branch_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine branch_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='branch_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(branch_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! branch_struct%ix_branch: 0D_NOT_integer

  subroutine branch_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine branch_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! branch_struct%ix_from_branch: 0D_NOT_integer

  subroutine branch_struct_get_ix_from_branch(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_from_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_from_branch
  end subroutine


  subroutine branch_struct_set_ix_from_branch(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_from_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_from_branch = value_in
  end subroutine

  ! branch_struct%ix_from_ele: 0D_NOT_integer

  subroutine branch_struct_get_ix_from_ele(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_from_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_from_ele
  end subroutine


  subroutine branch_struct_set_ix_from_ele(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_from_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_from_ele = value_in
  end subroutine

  ! branch_struct%ix_to_ele: 0D_NOT_integer

  subroutine branch_struct_get_ix_to_ele(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_to_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_to_ele
  end subroutine


  subroutine branch_struct_set_ix_to_ele(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_to_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_to_ele = value_in
  end subroutine

  ! branch_struct%ix_fixer: 0D_NOT_integer

  subroutine branch_struct_get_ix_fixer(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_fixer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_fixer
  end subroutine


  subroutine branch_struct_set_ix_fixer(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_fixer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_fixer = value_in
  end subroutine

  ! branch_struct%n_ele_track: 0D_NOT_integer

  subroutine branch_struct_get_n_ele_track(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ele_track
  end subroutine


  subroutine branch_struct_set_n_ele_track(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ele_track = value_in
  end subroutine

  ! branch_struct%n_ele_max: 0D_NOT_integer

  subroutine branch_struct_get_n_ele_max(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ele_max
  end subroutine


  subroutine branch_struct_set_n_ele_max(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ele_max = value_in
  end subroutine

  ! branch_struct%lat: 0D_PTR_type

  subroutine branch_struct_get_lat(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lat)) then
      ptr_out = c_loc(struct_obj%lat)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine branch_struct_set_lat(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lat)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%lat = src_obj
    endif
  end subroutine

  ! branch_struct%a: 0D_NOT_type

  subroutine branch_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine branch_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! branch_struct%b: 0D_NOT_type

  subroutine branch_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine branch_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! branch_struct%z: 0D_NOT_type

  subroutine branch_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine branch_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! branch_struct%ele: 1D_PTR_type

  subroutine branch_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='branch_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! branch_struct%param: 0D_NOT_type

  subroutine branch_struct_get_param(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%param)
  end subroutine


  subroutine branch_struct_set_param(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(lat_param_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%param = src_obj
  end subroutine

  ! branch_struct%particle_start: 0D_NOT_type

  subroutine branch_struct_get_particle_start(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%particle_start)
  end subroutine


  subroutine branch_struct_set_particle_start(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%particle_start = src_obj
  end subroutine

  ! branch_struct%wall3d: 1D_PTR_type

  subroutine branch_struct_get_wall3d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='branch_struct_get_wall3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%wall3d) .and. is_contiguous(struct_obj%wall3d)) then
      data_ptr = c_loc(struct_obj%wall3d(lbound(struct_obj%wall3d, 1)))
      bounds(1) = int(lbound(struct_obj%wall3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%wall3d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%wall3d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! lat_struct

    function allocate_fortran_lat_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(lat_struct), pointer :: fptr
      type(lat_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_lat_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(lat_struct), pointer :: fptr
      type(lat_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_lat_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_lat_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(lat_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_lat_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(lat_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_lat_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(lat_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_lat_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(lat_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! lat_struct%use_name: 0D_NOT_character

  subroutine lat_struct_get_use_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_use_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%use_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%use_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_use_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_use_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%use_name = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%lattice: 0D_NOT_character

  subroutine lat_struct_get_lattice_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_lattice_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%lattice)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%lattice), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_lattice(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%lattice = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%machine: 0D_NOT_character

  subroutine lat_struct_get_machine_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_machine_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%machine)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%machine), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_machine(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_machine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%machine = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%input_file_name: 0D_NOT_character

  subroutine lat_struct_get_input_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_input_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%input_file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%input_file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_input_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_input_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%input_file_name = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%title: 0D_NOT_character

  subroutine lat_struct_get_title_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_title_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%title)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%title), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_title(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%title = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%print_str: 1D_ALLOC_character

  subroutine lat_struct_get_print_str_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='lat_struct_get_print_str_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%print_str)) then
      data_ptr = c_loc(struct_obj%print_str(lbound(struct_obj%print_str, 1)))
      bounds(1) = int(lbound(struct_obj%print_str, 1), c_int)
      bounds(2) = int(ubound(struct_obj%print_str, 1), c_int)
      str_len = int(len(struct_obj%print_str), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%constant: 1D_ALLOC_type

  subroutine lat_struct_get_constant_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_constant_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%constant) .and. is_contiguous(struct_obj%constant)) then
      data_ptr = c_loc(struct_obj%constant(lbound(struct_obj%constant, 1)))
      bounds(1) = int(lbound(struct_obj%constant, 1), c_int)
      bounds(2) = int(ubound(struct_obj%constant, 1), c_int)
      
      el_size = int(storage_size(struct_obj%constant(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%a: 0D_PTR_type

  subroutine lat_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%a)) then
      ptr_out = c_loc(struct_obj%a)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%a)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%a = src_obj
    endif
  end subroutine

  ! lat_struct%b: 0D_PTR_type

  subroutine lat_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%b)) then
      ptr_out = c_loc(struct_obj%b)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%b)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%b = src_obj
    endif
  end subroutine

  ! lat_struct%z: 0D_PTR_type

  subroutine lat_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%z)) then
      ptr_out = c_loc(struct_obj%z)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%z)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%z = src_obj
    endif
  end subroutine

  ! lat_struct%param: 0D_PTR_type

  subroutine lat_struct_get_param(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%param)) then
      ptr_out = c_loc(struct_obj%param)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_param(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(lat_param_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%param)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%param = src_obj
    endif
  end subroutine

  ! lat_struct%lord_state: 0D_NOT_type

  subroutine lat_struct_get_lord_state(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_lord_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lord_state)
  end subroutine


  subroutine lat_struct_set_lord_state(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_lord_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(bookkeeping_state_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lord_state = src_obj
  end subroutine

  ! lat_struct%ele_init: 0D_NOT_type

  subroutine lat_struct_get_ele_init(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_ele_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_init)
  end subroutine


  subroutine lat_struct_set_ele_init(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_ele_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_init = src_obj
  end subroutine

  ! lat_struct%ele: 1D_PTR_type

  subroutine lat_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%branch: 1D_ALLOC_type

  subroutine lat_struct_get_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%branch) .and. is_contiguous(struct_obj%branch)) then
      data_ptr = c_loc(struct_obj%branch(lbound(struct_obj%branch, 1)))
      bounds(1) = int(lbound(struct_obj%branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%control: 1D_ALLOC_type

  subroutine lat_struct_get_control_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_control_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%control) .and. is_contiguous(struct_obj%control)) then
      data_ptr = c_loc(struct_obj%control(lbound(struct_obj%control, 1)))
      bounds(1) = int(lbound(struct_obj%control, 1), c_int)
      bounds(2) = int(ubound(struct_obj%control, 1), c_int)
      
      el_size = int(storage_size(struct_obj%control(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%particle_start: 0D_PTR_type

  subroutine lat_struct_get_particle_start(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%particle_start)) then
      ptr_out = c_loc(struct_obj%particle_start)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_particle_start(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%particle_start)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%particle_start = src_obj
    endif
  end subroutine

  ! lat_struct%beam_init: 0D_NOT_type

  subroutine lat_struct_get_beam_init(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init)
  end subroutine


  subroutine lat_struct_set_beam_init(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init = src_obj
  end subroutine

  ! lat_struct%pre_tracker: 0D_NOT_type

  subroutine lat_struct_get_pre_tracker(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_pre_tracker')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%pre_tracker)
  end subroutine


  subroutine lat_struct_set_pre_tracker(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_pre_tracker')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(pre_tracker_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%pre_tracker = src_obj
  end subroutine

  ! lat_struct%custom: 1D_ALLOC_real

  subroutine lat_struct_get_custom_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='lat_struct_get_custom_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%custom) .and. is_contiguous(struct_obj%custom)) then
      data_ptr = c_loc(struct_obj%custom(lbound(struct_obj%custom, 1)))
      bounds(1) = int(lbound(struct_obj%custom, 1), c_int)
      bounds(2) = int(ubound(struct_obj%custom, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%version: 0D_NOT_integer

  subroutine lat_struct_get_version(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_version')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%version
  end subroutine


  subroutine lat_struct_set_version(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_version')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%version = value_in
  end subroutine

  ! lat_struct%n_ele_track: 0D_PTR_integer

  subroutine lat_struct_get_n_ele_track(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_track)) then
      ptr_out = c_loc(struct_obj%n_ele_track)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_n_ele_track(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_track)) then
      struct_obj%n_ele_track = value_in
    endif
  end subroutine

  ! lat_struct%n_ele_max: 0D_PTR_integer

  subroutine lat_struct_get_n_ele_max(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_max)) then
      ptr_out = c_loc(struct_obj%n_ele_max)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_n_ele_max(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_max)) then
      struct_obj%n_ele_max = value_in
    endif
  end subroutine

  ! lat_struct%n_control_max: 0D_NOT_integer

  subroutine lat_struct_get_n_control_max(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_n_control_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_control_max
  end subroutine


  subroutine lat_struct_set_n_control_max(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_control_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_control_max = value_in
  end subroutine

  ! lat_struct%n_ic_max: 0D_NOT_integer

  subroutine lat_struct_get_n_ic_max(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_n_ic_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ic_max
  end subroutine


  subroutine lat_struct_set_n_ic_max(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_ic_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ic_max = value_in
  end subroutine

  ! lat_struct%input_taylor_order: 0D_NOT_integer

  subroutine lat_struct_get_input_taylor_order(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_input_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%input_taylor_order
  end subroutine


  subroutine lat_struct_set_input_taylor_order(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_input_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%input_taylor_order = value_in
  end subroutine

  ! lat_struct%ic: 1D_ALLOC_integer

  subroutine lat_struct_get_ic_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='lat_struct_get_ic_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ic) .and. is_contiguous(struct_obj%ic)) then
      data_ptr = c_loc(struct_obj%ic(lbound(struct_obj%ic, 1)))
      bounds(1) = int(lbound(struct_obj%ic, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ic, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%photon_type: 0D_NOT_integer

  subroutine lat_struct_get_photon_type(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_photon_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%photon_type
  end subroutine


  subroutine lat_struct_set_photon_type(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_photon_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%photon_type = value_in
  end subroutine

  ! lat_struct%creation_hash: 0D_NOT_integer

  subroutine lat_struct_get_creation_hash(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_creation_hash')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%creation_hash
  end subroutine


  subroutine lat_struct_set_creation_hash(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_creation_hash')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%creation_hash = value_in
  end subroutine

  ! lat_struct%ramper_slave_bookkeeping: 0D_NOT_integer

  subroutine lat_struct_get_ramper_slave_bookkeeping(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_ramper_slave_bookkeeping')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ramper_slave_bookkeeping
  end subroutine


  subroutine lat_struct_set_ramper_slave_bookkeeping(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_ramper_slave_bookkeeping')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ramper_slave_bookkeeping = value_in
  end subroutine

  !! bunch_struct

    function allocate_fortran_bunch_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bunch_struct), pointer :: fptr
      type(bunch_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bunch_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bunch_struct), pointer :: fptr
      type(bunch_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bunch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bunch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bunch_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bunch_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bunch_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bunch_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bunch_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bunch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bunch_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bunch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bunch_struct%particle: 1D_ALLOC_type

  subroutine bunch_struct_get_particle_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bunch_struct_get_particle_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%particle) .and. is_contiguous(struct_obj%particle)) then
      data_ptr = c_loc(struct_obj%particle(lbound(struct_obj%particle, 1)))
      bounds(1) = int(lbound(struct_obj%particle, 1), c_int)
      bounds(2) = int(ubound(struct_obj%particle, 1), c_int)
      
      el_size = int(storage_size(struct_obj%particle(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_struct%ix_z: 1D_ALLOC_integer

  subroutine bunch_struct_get_ix_z_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bunch_struct_get_ix_z_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ix_z) .and. is_contiguous(struct_obj%ix_z)) then
      data_ptr = c_loc(struct_obj%ix_z(lbound(struct_obj%ix_z, 1)))
      bounds(1) = int(lbound(struct_obj%ix_z, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ix_z, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_struct%charge_tot: 0D_NOT_real

  subroutine bunch_struct_get_charge_tot(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_tot
  end subroutine


  subroutine bunch_struct_set_charge_tot(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_tot = value_in
  end subroutine

  ! bunch_struct%charge_live: 0D_NOT_real

  subroutine bunch_struct_get_charge_live(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_live
  end subroutine


  subroutine bunch_struct_set_charge_live(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_live = value_in
  end subroutine

  ! bunch_struct%z_center: 0D_NOT_real

  subroutine bunch_struct_get_z_center(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_z_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_center
  end subroutine


  subroutine bunch_struct_set_z_center(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_z_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_center = value_in
  end subroutine

  ! bunch_struct%t_center: 0D_NOT_real

  subroutine bunch_struct_get_t_center(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_t_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_center
  end subroutine


  subroutine bunch_struct_set_t_center(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_t_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_center = value_in
  end subroutine

  ! bunch_struct%t0: 0D_NOT_real

  subroutine bunch_struct_get_t0(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_t0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t0
  end subroutine


  subroutine bunch_struct_set_t0(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_t0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t0 = value_in
  end subroutine

  ! bunch_struct%drift_between_t_and_s: 0D_NOT_logical

  subroutine bunch_struct_get_drift_between_t_and_s(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_drift_between_t_and_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%drift_between_t_and_s
  end subroutine


  subroutine bunch_struct_set_drift_between_t_and_s(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_drift_between_t_and_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%drift_between_t_and_s = value_in
  end subroutine

  ! bunch_struct%ix_ele: 0D_NOT_integer

  subroutine bunch_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine bunch_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! bunch_struct%ix_bunch: 0D_NOT_integer

  subroutine bunch_struct_get_ix_bunch(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch
  end subroutine


  subroutine bunch_struct_set_ix_bunch(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch = value_in
  end subroutine

  ! bunch_struct%ix_turn: 0D_NOT_integer

  subroutine bunch_struct_get_ix_turn(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_turn
  end subroutine


  subroutine bunch_struct_set_ix_turn(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_turn = value_in
  end subroutine

  ! bunch_struct%n_live: 0D_NOT_integer

  subroutine bunch_struct_get_n_live(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_n_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_live
  end subroutine


  subroutine bunch_struct_set_n_live(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_n_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_live = value_in
  end subroutine

  ! bunch_struct%n_good: 0D_NOT_integer

  subroutine bunch_struct_get_n_good(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_n_good')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_good
  end subroutine


  subroutine bunch_struct_set_n_good(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_n_good')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_good = value_in
  end subroutine

  ! bunch_struct%n_bad: 0D_NOT_integer

  subroutine bunch_struct_get_n_bad(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bad
  end subroutine


  subroutine bunch_struct_set_n_bad(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bad = value_in
  end subroutine

  !! bunch_params_struct

    function allocate_fortran_bunch_params_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bunch_params_struct), pointer :: fptr
      type(bunch_params_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bunch_params_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bunch_params_struct), pointer :: fptr
      type(bunch_params_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bunch_params_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bunch_params_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bunch_params_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bunch_params_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bunch_params_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bunch_params_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bunch_params_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bunch_params_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bunch_params_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bunch_params_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bunch_params_struct%centroid: 0D_NOT_type

  subroutine bunch_params_struct_get_centroid(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_centroid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%centroid)
  end subroutine


  subroutine bunch_params_struct_set_centroid(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_centroid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%centroid = src_obj
  end subroutine

  ! bunch_params_struct%x: 0D_NOT_type

  subroutine bunch_params_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine bunch_params_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! bunch_params_struct%y: 0D_NOT_type

  subroutine bunch_params_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine bunch_params_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  ! bunch_params_struct%z: 0D_NOT_type

  subroutine bunch_params_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine bunch_params_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! bunch_params_struct%a: 0D_NOT_type

  subroutine bunch_params_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine bunch_params_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! bunch_params_struct%b: 0D_NOT_type

  subroutine bunch_params_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine bunch_params_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! bunch_params_struct%c: 0D_NOT_type

  subroutine bunch_params_struct_get_c(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%c)
  end subroutine


  subroutine bunch_params_struct_set_c(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%c = src_obj
  end subroutine

  ! bunch_params_struct%sigma: 2D_NOT_real

  subroutine bunch_params_struct_get_sigma_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='bunch_params_struct_get_sigma_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_params_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%sigma)) then
      data_ptr = c_loc(struct_obj%sigma(lbound(struct_obj%sigma, 1), lbound(struct_obj%sigma, 2)))
      bounds(1) = int(lbound(struct_obj%sigma, 1), c_int)
      bounds(2) = int(ubound(struct_obj%sigma, 1), c_int)
      bounds(3) = int(lbound(struct_obj%sigma, 2), c_int)
      bounds(4) = int(ubound(struct_obj%sigma, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_params_struct%rel_max: 1D_NOT_real

  subroutine bunch_params_struct_get_rel_max_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bunch_params_struct_get_rel_max_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_params_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%rel_max)) then
      data_ptr = c_loc(struct_obj%rel_max(lbound(struct_obj%rel_max, 1)))
      bounds(1) = int(lbound(struct_obj%rel_max, 1), c_int)
      bounds(2) = int(ubound(struct_obj%rel_max, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_params_struct%rel_min: 1D_NOT_real

  subroutine bunch_params_struct_get_rel_min_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bunch_params_struct_get_rel_min_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_params_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%rel_min)) then
      data_ptr = c_loc(struct_obj%rel_min(lbound(struct_obj%rel_min, 1)))
      bounds(1) = int(lbound(struct_obj%rel_min, 1), c_int)
      bounds(2) = int(ubound(struct_obj%rel_min, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_params_struct%s: 0D_NOT_real

  subroutine bunch_params_struct_get_s(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine bunch_params_struct_set_s(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! bunch_params_struct%t: 0D_NOT_real

  subroutine bunch_params_struct_get_t(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t
  end subroutine


  subroutine bunch_params_struct_set_t(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t = value_in
  end subroutine

  ! bunch_params_struct%sigma_t: 0D_NOT_real

  subroutine bunch_params_struct_get_sigma_t(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_sigma_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_t
  end subroutine


  subroutine bunch_params_struct_set_sigma_t(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_sigma_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_t = value_in
  end subroutine

  ! bunch_params_struct%charge_live: 0D_NOT_real

  subroutine bunch_params_struct_get_charge_live(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_live
  end subroutine


  subroutine bunch_params_struct_set_charge_live(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_live = value_in
  end subroutine

  ! bunch_params_struct%charge_tot: 0D_NOT_real

  subroutine bunch_params_struct_get_charge_tot(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_tot
  end subroutine


  subroutine bunch_params_struct_set_charge_tot(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_tot = value_in
  end subroutine

  ! bunch_params_struct%n_particle_tot: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_particle_tot(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_particle_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle_tot
  end subroutine


  subroutine bunch_params_struct_set_n_particle_tot(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_particle_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle_tot = value_in
  end subroutine

  ! bunch_params_struct%n_particle_live: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_particle_live(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_particle_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle_live
  end subroutine


  subroutine bunch_params_struct_set_n_particle_live(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_particle_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle_live = value_in
  end subroutine

  ! bunch_params_struct%n_particle_lost_in_ele: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_particle_lost_in_ele(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_particle_lost_in_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle_lost_in_ele
  end subroutine


  subroutine bunch_params_struct_set_n_particle_lost_in_ele(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_particle_lost_in_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle_lost_in_ele = value_in
  end subroutine

  ! bunch_params_struct%n_good_steps: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_good_steps(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_good_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_good_steps
  end subroutine


  subroutine bunch_params_struct_set_n_good_steps(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_good_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_good_steps = value_in
  end subroutine

  ! bunch_params_struct%n_bad_steps: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_bad_steps(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_bad_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bad_steps
  end subroutine


  subroutine bunch_params_struct_set_n_bad_steps(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_bad_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bad_steps = value_in
  end subroutine

  ! bunch_params_struct%ix_ele: 0D_NOT_integer

  subroutine bunch_params_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine bunch_params_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! bunch_params_struct%location: 0D_NOT_integer

  subroutine bunch_params_struct_get_location(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%location
  end subroutine


  subroutine bunch_params_struct_set_location(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%location = value_in
  end subroutine

  ! bunch_params_struct%twiss_valid: 0D_NOT_logical

  subroutine bunch_params_struct_get_twiss_valid(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%twiss_valid
  end subroutine


  subroutine bunch_params_struct_set_twiss_valid(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%twiss_valid = value_in
  end subroutine

  !! beam_struct

    function allocate_fortran_beam_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(beam_struct), pointer :: fptr
      type(beam_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_beam_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(beam_struct), pointer :: fptr
      type(beam_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_beam_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(beam_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_beam_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(beam_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_beam_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(beam_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_beam_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(beam_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_beam_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(beam_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! beam_struct%bunch: 1D_ALLOC_type

  subroutine beam_struct_get_bunch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='beam_struct_get_bunch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%bunch) .and. is_contiguous(struct_obj%bunch)) then
      data_ptr = c_loc(struct_obj%bunch(lbound(struct_obj%bunch, 1)))
      bounds(1) = int(lbound(struct_obj%bunch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! aperture_point_struct

    function allocate_fortran_aperture_point_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(aperture_point_struct), pointer :: fptr
      type(aperture_point_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_aperture_point_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(aperture_point_struct), pointer :: fptr
      type(aperture_point_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_aperture_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(aperture_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_aperture_point_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(aperture_point_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_aperture_point_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(aperture_point_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_aperture_point_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(aperture_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_aperture_point_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(aperture_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! aperture_point_struct%x: 0D_NOT_real

  subroutine aperture_point_struct_get_x(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine aperture_point_struct_set_x(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! aperture_point_struct%y: 0D_NOT_real

  subroutine aperture_point_struct_get_y(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine aperture_point_struct_set_y(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! aperture_point_struct%plane: 0D_NOT_integer

  subroutine aperture_point_struct_get_plane(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_plane')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%plane
  end subroutine


  subroutine aperture_point_struct_set_plane(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_plane')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%plane = value_in
  end subroutine

  ! aperture_point_struct%ix_ele: 0D_NOT_integer

  subroutine aperture_point_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine aperture_point_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! aperture_point_struct%i_turn: 0D_NOT_integer

  subroutine aperture_point_struct_get_i_turn(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_i_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_turn
  end subroutine


  subroutine aperture_point_struct_set_i_turn(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_i_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_turn = value_in
  end subroutine

  !! aperture_param_struct

    function allocate_fortran_aperture_param_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(aperture_param_struct), pointer :: fptr
      type(aperture_param_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_aperture_param_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(aperture_param_struct), pointer :: fptr
      type(aperture_param_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_aperture_param_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(aperture_param_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_aperture_param_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(aperture_param_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_aperture_param_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(aperture_param_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_aperture_param_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(aperture_param_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_aperture_param_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(aperture_param_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! aperture_param_struct%min_angle: 0D_NOT_real

  subroutine aperture_param_struct_get_min_angle(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_min_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%min_angle
  end subroutine


  subroutine aperture_param_struct_set_min_angle(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_min_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%min_angle = value_in
  end subroutine

  ! aperture_param_struct%max_angle: 0D_NOT_real

  subroutine aperture_param_struct_get_max_angle(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_max_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_angle
  end subroutine


  subroutine aperture_param_struct_set_max_angle(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_max_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_angle = value_in
  end subroutine

  ! aperture_param_struct%n_angle: 0D_NOT_integer

  subroutine aperture_param_struct_get_n_angle(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_n_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_angle
  end subroutine


  subroutine aperture_param_struct_set_n_angle(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_n_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_angle = value_in
  end subroutine

  ! aperture_param_struct%n_turn: 0D_NOT_integer

  subroutine aperture_param_struct_get_n_turn(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_n_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_turn
  end subroutine


  subroutine aperture_param_struct_set_n_turn(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_n_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_turn = value_in
  end subroutine

  ! aperture_param_struct%x_init: 0D_NOT_real

  subroutine aperture_param_struct_get_x_init(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_x_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_init
  end subroutine


  subroutine aperture_param_struct_set_x_init(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_x_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_init = value_in
  end subroutine

  ! aperture_param_struct%y_init: 0D_NOT_real

  subroutine aperture_param_struct_get_y_init(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_y_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_init
  end subroutine


  subroutine aperture_param_struct_set_y_init(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_y_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_init = value_in
  end subroutine

  ! aperture_param_struct%rel_accuracy: 0D_NOT_real

  subroutine aperture_param_struct_get_rel_accuracy(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_rel_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_accuracy
  end subroutine


  subroutine aperture_param_struct_set_rel_accuracy(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_rel_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_accuracy = value_in
  end subroutine

  ! aperture_param_struct%abs_accuracy: 0D_NOT_real

  subroutine aperture_param_struct_get_abs_accuracy(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_abs_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_accuracy
  end subroutine


  subroutine aperture_param_struct_set_abs_accuracy(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_abs_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_accuracy = value_in
  end subroutine

  ! aperture_param_struct%start_ele: 0D_NOT_character

  subroutine aperture_param_struct_get_start_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='aperture_param_struct_get_start_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%start_ele)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%start_ele), c_int)
    is_allocated = .true.
  end subroutine


  subroutine aperture_param_struct_set_start_ele(struct_obj_ptr, str_ptr, str_len) bind(c, name='aperture_param_struct_set_start_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(aperture_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%start_ele = str_in ! implicitly handles padding
  end subroutine

  !! aperture_scan_struct

    function allocate_fortran_aperture_scan_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(aperture_scan_struct), pointer :: fptr
      type(aperture_scan_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_aperture_scan_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(aperture_scan_struct), pointer :: fptr
      type(aperture_scan_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_aperture_scan_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(aperture_scan_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_aperture_scan_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(aperture_scan_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_aperture_scan_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(aperture_scan_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_aperture_scan_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(aperture_scan_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_aperture_scan_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(aperture_scan_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! aperture_scan_struct%point: 1D_ALLOC_type

  subroutine aperture_scan_struct_get_point_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='aperture_scan_struct_get_point_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(aperture_scan_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%point) .and. is_contiguous(struct_obj%point)) then
      data_ptr = c_loc(struct_obj%point(lbound(struct_obj%point, 1)))
      bounds(1) = int(lbound(struct_obj%point, 1), c_int)
      bounds(2) = int(ubound(struct_obj%point, 1), c_int)
      
      el_size = int(storage_size(struct_obj%point(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! aperture_scan_struct%ref_orb: 0D_NOT_type

  subroutine aperture_scan_struct_get_ref_orb(struct_obj_ptr, ptr_out) bind(c, name='aperture_scan_struct_get_ref_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(aperture_scan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ref_orb)
  end subroutine


  subroutine aperture_scan_struct_set_ref_orb(struct_obj_ptr, src_ptr) bind(c, name='aperture_scan_struct_set_ref_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(aperture_scan_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ref_orb = src_obj
  end subroutine

  ! aperture_scan_struct%pz_start: 0D_NOT_real

  subroutine aperture_scan_struct_get_pz_start(struct_obj_ptr, value_out) bind(c, name='aperture_scan_struct_get_pz_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_scan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pz_start
  end subroutine


  subroutine aperture_scan_struct_set_pz_start(struct_obj_ptr, value_in) bind(c, name='aperture_scan_struct_set_pz_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_scan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pz_start = value_in
  end subroutine

  !! ele_pointer_struct

    function allocate_fortran_ele_pointer_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ele_pointer_struct), pointer :: fptr
      type(ele_pointer_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ele_pointer_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ele_pointer_struct), pointer :: fptr
      type(ele_pointer_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ele_pointer_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ele_pointer_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ele_pointer_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ele_pointer_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ele_pointer_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ele_pointer_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ele_pointer_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ele_pointer_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ele_pointer_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ele_pointer_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ele_pointer_struct%ele: 0D_PTR_type

  subroutine ele_pointer_struct_get_ele(struct_obj_ptr, ptr_out) bind(c, name='ele_pointer_struct_get_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele)) then
      ptr_out = c_loc(struct_obj%ele)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_pointer_struct_set_ele(struct_obj_ptr, src_ptr) bind(c, name='ele_pointer_struct_set_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_pointer_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ele = src_obj
    endif
  end subroutine

  ! ele_pointer_struct%loc: 0D_NOT_type

  subroutine ele_pointer_struct_get_loc(struct_obj_ptr, ptr_out) bind(c, name='ele_pointer_struct_get_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%loc)
  end subroutine


  subroutine ele_pointer_struct_set_loc(struct_obj_ptr, src_ptr) bind(c, name='ele_pointer_struct_set_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_pointer_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%loc = src_obj
  end subroutine

  ! ele_pointer_struct%id: 0D_NOT_integer

  subroutine ele_pointer_struct_get_id(struct_obj_ptr, value_out) bind(c, name='ele_pointer_struct_get_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%id
  end subroutine


  subroutine ele_pointer_struct_set_id(struct_obj_ptr, value_in) bind(c, name='ele_pointer_struct_set_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%id = value_in
  end subroutine

  !! expression_tree_struct

    function allocate_fortran_expression_tree_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(expression_tree_struct), pointer :: fptr
      type(expression_tree_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_expression_tree_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(expression_tree_struct), pointer :: fptr
      type(expression_tree_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_expression_tree_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(expression_tree_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_expression_tree_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(expression_tree_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_expression_tree_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(expression_tree_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_expression_tree_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(expression_tree_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_expression_tree_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(expression_tree_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! expression_tree_struct%name: 0D_NOT_character

  subroutine expression_tree_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='expression_tree_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(expression_tree_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine expression_tree_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='expression_tree_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(expression_tree_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! expression_tree_struct%type: 0D_NOT_integer

  subroutine expression_tree_struct_get_type(struct_obj_ptr, value_out) bind(c, name='expression_tree_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(expression_tree_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine expression_tree_struct_set_type(struct_obj_ptr, value_in) bind(c, name='expression_tree_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(expression_tree_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! expression_tree_struct%value: 0D_NOT_real

  subroutine expression_tree_struct_get_value(struct_obj_ptr, value_out) bind(c, name='expression_tree_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(expression_tree_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine expression_tree_struct_set_value(struct_obj_ptr, value_in) bind(c, name='expression_tree_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(expression_tree_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  ! expression_tree_struct%node: 1D_PTR_type

  subroutine expression_tree_struct_get_node_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='expression_tree_struct_get_node_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(expression_tree_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%node) .and. is_contiguous(struct_obj%node)) then
      data_ptr = c_loc(struct_obj%node(lbound(struct_obj%node, 1)))
      bounds(1) = int(lbound(struct_obj%node, 1), c_int)
      bounds(2) = int(ubound(struct_obj%node, 1), c_int)
      
      el_size = int(storage_size(struct_obj%node(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! nametable_struct

    function allocate_fortran_nametable_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(nametable_struct), pointer :: fptr
      type(nametable_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_nametable_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(nametable_struct), pointer :: fptr
      type(nametable_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_nametable_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(nametable_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_nametable_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(nametable_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_nametable_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(nametable_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_nametable_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(nametable_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_nametable_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(nametable_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! nametable_struct%name: 1D_ALLOC_character

  subroutine nametable_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='nametable_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(nametable_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%name)) then
      data_ptr = c_loc(struct_obj%name(lbound(struct_obj%name, 1)))
      bounds(1) = int(lbound(struct_obj%name, 1), c_int)
      bounds(2) = int(ubound(struct_obj%name, 1), c_int)
      str_len = int(len(struct_obj%name), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! nametable_struct%index: 1D_ALLOC_integer

  subroutine nametable_struct_get_index_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='nametable_struct_get_index_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(nametable_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%index) .and. is_contiguous(struct_obj%index)) then
      data_ptr = c_loc(struct_obj%index(lbound(struct_obj%index, 1)))
      bounds(1) = int(lbound(struct_obj%index, 1), c_int)
      bounds(2) = int(ubound(struct_obj%index, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! nametable_struct%n_min: 0D_NOT_integer

  subroutine nametable_struct_get_n_min(struct_obj_ptr, value_out) bind(c, name='nametable_struct_get_n_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(nametable_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_min
  end subroutine


  subroutine nametable_struct_set_n_min(struct_obj_ptr, value_in) bind(c, name='nametable_struct_set_n_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(nametable_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_min = value_in
  end subroutine

  ! nametable_struct%n_max: 0D_NOT_integer

  subroutine nametable_struct_get_n_max(struct_obj_ptr, value_out) bind(c, name='nametable_struct_get_n_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(nametable_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_max
  end subroutine


  subroutine nametable_struct_set_n_max(struct_obj_ptr, value_in) bind(c, name='nametable_struct_set_n_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(nametable_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_max = value_in
  end subroutine

  !! tao_spin_dn_dpz_struct

    function allocate_fortran_tao_spin_dn_dpz_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_spin_dn_dpz_struct), pointer :: fptr
      type(tao_spin_dn_dpz_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_spin_dn_dpz_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_spin_dn_dpz_struct), pointer :: fptr
      type(tao_spin_dn_dpz_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_spin_dn_dpz_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_dn_dpz_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_spin_dn_dpz_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_spin_dn_dpz_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_spin_dn_dpz_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_spin_dn_dpz_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_spin_dn_dpz_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_spin_dn_dpz_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_spin_dn_dpz_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_spin_dn_dpz_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_spin_dn_dpz_struct%vec: 1D_NOT_real

  subroutine tao_spin_dn_dpz_struct_get_vec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_dn_dpz_struct_get_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_dn_dpz_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%vec)) then
      data_ptr = c_loc(struct_obj%vec(lbound(struct_obj%vec, 1)))
      bounds(1) = int(lbound(struct_obj%vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_dn_dpz_struct%partial: 2D_NOT_real

  subroutine tao_spin_dn_dpz_struct_get_partial_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_dn_dpz_struct_get_partial_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_dn_dpz_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%partial)) then
      data_ptr = c_loc(struct_obj%partial(lbound(struct_obj%partial, 1), lbound(struct_obj%partial, 2)))
      bounds(1) = int(lbound(struct_obj%partial, 1), c_int)
      bounds(2) = int(ubound(struct_obj%partial, 1), c_int)
      bounds(3) = int(lbound(struct_obj%partial, 2), c_int)
      bounds(4) = int(ubound(struct_obj%partial, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_dn_dpz_struct%partial2: 2D_NOT_real

  subroutine tao_spin_dn_dpz_struct_get_partial2_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_dn_dpz_struct_get_partial2_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_dn_dpz_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%partial2)) then
      data_ptr = c_loc(struct_obj%partial2(lbound(struct_obj%partial2, 1), lbound(struct_obj%partial2, 2)))
      bounds(1) = int(lbound(struct_obj%partial2, 1), c_int)
      bounds(2) = int(ubound(struct_obj%partial2, 1), c_int)
      bounds(3) = int(lbound(struct_obj%partial2, 2), c_int)
      bounds(4) = int(ubound(struct_obj%partial2, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! resonance_h_struct

    function allocate_fortran_resonance_h_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(resonance_h_struct), pointer :: fptr
      type(resonance_h_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_resonance_h_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(resonance_h_struct), pointer :: fptr
      type(resonance_h_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_resonance_h_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(resonance_h_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_resonance_h_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(resonance_h_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_resonance_h_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(resonance_h_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_resonance_h_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(resonance_h_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_resonance_h_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(resonance_h_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! resonance_h_struct%id: 0D_NOT_character

  subroutine resonance_h_struct_get_id_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='resonance_h_struct_get_id_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(resonance_h_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%id)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%id), c_int)
    is_allocated = .true.
  end subroutine


  subroutine resonance_h_struct_set_id(struct_obj_ptr, str_ptr, str_len) bind(c, name='resonance_h_struct_set_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(resonance_h_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%id = str_in ! implicitly handles padding
  end subroutine

  ! resonance_h_struct%c_val: 0D_NOT_complex

  subroutine resonance_h_struct_get_c_val(struct_obj_ptr, value_out) bind(c, name='resonance_h_struct_get_c_val')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(resonance_h_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%c_val
  end subroutine


  subroutine resonance_h_struct_set_c_val(struct_obj_ptr, value_in) bind(c, name='resonance_h_struct_set_c_val')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(resonance_h_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%c_val = value_in
  end subroutine

  !! spin_orbit_map1_struct

    function allocate_fortran_spin_orbit_map1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(spin_orbit_map1_struct), pointer :: fptr
      type(spin_orbit_map1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_spin_orbit_map1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(spin_orbit_map1_struct), pointer :: fptr
      type(spin_orbit_map1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_spin_orbit_map1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spin_orbit_map1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_spin_orbit_map1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(spin_orbit_map1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_spin_orbit_map1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(spin_orbit_map1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_spin_orbit_map1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(spin_orbit_map1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_spin_orbit_map1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(spin_orbit_map1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! spin_orbit_map1_struct%orb_mat: 2D_NOT_real

  subroutine spin_orbit_map1_struct_get_orb_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='spin_orbit_map1_struct_get_orb_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_orbit_map1_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%orb_mat)) then
      data_ptr = c_loc(struct_obj%orb_mat(lbound(struct_obj%orb_mat, 1), lbound(struct_obj%orb_mat, 2)))
      bounds(1) = int(lbound(struct_obj%orb_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%orb_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%orb_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_orbit_map1_struct%vec0: 1D_NOT_real

  subroutine spin_orbit_map1_struct_get_vec0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_orbit_map1_struct_get_vec0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_orbit_map1_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%vec0)) then
      data_ptr = c_loc(struct_obj%vec0(lbound(struct_obj%vec0, 1)))
      bounds(1) = int(lbound(struct_obj%vec0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_orbit_map1_struct%spin_q: 2D_NOT_real

  subroutine spin_orbit_map1_struct_get_spin_q_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='spin_orbit_map1_struct_get_spin_q_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_orbit_map1_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin_q)) then
      data_ptr = c_loc(struct_obj%spin_q(lbound(struct_obj%spin_q, 1), lbound(struct_obj%spin_q, 2)))
      bounds(1) = int(lbound(struct_obj%spin_q, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_q, 1), c_int)
      bounds(3) = int(lbound(struct_obj%spin_q, 2), c_int)
      bounds(4) = int(ubound(struct_obj%spin_q, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! spin_axis_struct

    function allocate_fortran_spin_axis_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(spin_axis_struct), pointer :: fptr
      type(spin_axis_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_spin_axis_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(spin_axis_struct), pointer :: fptr
      type(spin_axis_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_spin_axis_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spin_axis_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_spin_axis_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(spin_axis_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_spin_axis_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(spin_axis_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_spin_axis_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(spin_axis_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_spin_axis_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(spin_axis_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! spin_axis_struct%l: 1D_NOT_real

  subroutine spin_axis_struct_get_l_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_axis_struct_get_l_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_axis_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%l)) then
      data_ptr = c_loc(struct_obj%l(lbound(struct_obj%l, 1)))
      bounds(1) = int(lbound(struct_obj%l, 1), c_int)
      bounds(2) = int(ubound(struct_obj%l, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_axis_struct%n0: 1D_NOT_real

  subroutine spin_axis_struct_get_n0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_axis_struct_get_n0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_axis_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%n0)) then
      data_ptr = c_loc(struct_obj%n0(lbound(struct_obj%n0, 1)))
      bounds(1) = int(lbound(struct_obj%n0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%n0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_axis_struct%m: 1D_NOT_real

  subroutine spin_axis_struct_get_m_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_axis_struct_get_m_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_axis_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%m)) then
      data_ptr = c_loc(struct_obj%m(lbound(struct_obj%m, 1)))
      bounds(1) = int(lbound(struct_obj%m, 1), c_int)
      bounds(2) = int(ubound(struct_obj%m, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! ptc_normal_form_struct

    function allocate_fortran_ptc_normal_form_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(ptc_normal_form_struct), pointer :: fptr
      type(ptc_normal_form_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_ptc_normal_form_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(ptc_normal_form_struct), pointer :: fptr
      type(ptc_normal_form_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_ptc_normal_form_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ptc_normal_form_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_ptc_normal_form_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(ptc_normal_form_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_ptc_normal_form_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(ptc_normal_form_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_ptc_normal_form_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(ptc_normal_form_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_ptc_normal_form_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(ptc_normal_form_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! ptc_normal_form_struct%ele_origin: 0D_PTR_type

  subroutine ptc_normal_form_struct_get_ele_origin(struct_obj_ptr, ptr_out) bind(c, name='ptc_normal_form_struct_get_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ptc_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      ptr_out = c_loc(struct_obj%ele_origin)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ptc_normal_form_struct_set_ele_origin(struct_obj_ptr, src_ptr) bind(c, name='ptc_normal_form_struct_set_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ptc_normal_form_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ele_origin = src_obj
    endif
  end subroutine

  ! ptc_normal_form_struct%orb0: 1D_NOT_real

  subroutine ptc_normal_form_struct_get_orb0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ptc_normal_form_struct_get_orb0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ptc_normal_form_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%orb0)) then
      data_ptr = c_loc(struct_obj%orb0(lbound(struct_obj%orb0, 1)))
      bounds(1) = int(lbound(struct_obj%orb0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ptc_normal_form_struct%valid_map: 0D_NOT_logical

  subroutine ptc_normal_form_struct_get_valid_map(struct_obj_ptr, value_out) bind(c, name='ptc_normal_form_struct_get_valid_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ptc_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid_map
  end subroutine


  subroutine ptc_normal_form_struct_set_valid_map(struct_obj_ptr, value_in) bind(c, name='ptc_normal_form_struct_set_valid_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ptc_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid_map = value_in
  end subroutine

  !! bmad_normal_form_struct

    function allocate_fortran_bmad_normal_form_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bmad_normal_form_struct), pointer :: fptr
      type(bmad_normal_form_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bmad_normal_form_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bmad_normal_form_struct), pointer :: fptr
      type(bmad_normal_form_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bmad_normal_form_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bmad_normal_form_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bmad_normal_form_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bmad_normal_form_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bmad_normal_form_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bmad_normal_form_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bmad_normal_form_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bmad_normal_form_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bmad_normal_form_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bmad_normal_form_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bmad_normal_form_struct%ele_origin: 0D_PTR_type

  subroutine bmad_normal_form_struct_get_ele_origin(struct_obj_ptr, ptr_out) bind(c, name='bmad_normal_form_struct_get_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bmad_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      ptr_out = c_loc(struct_obj%ele_origin)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine bmad_normal_form_struct_set_ele_origin(struct_obj_ptr, src_ptr) bind(c, name='bmad_normal_form_struct_set_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bmad_normal_form_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ele_origin = src_obj
    endif
  end subroutine

  ! bmad_normal_form_struct%M: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_M_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_M_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%M)) then
      data_ptr = c_loc(struct_obj%M(lbound(struct_obj%M, 1)))
      bounds(1) = int(lbound(struct_obj%M, 1), c_int)
      bounds(2) = int(ubound(struct_obj%M, 1), c_int)
      
      el_size = int(storage_size(struct_obj%M(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%A: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_A_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_A_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%A)) then
      data_ptr = c_loc(struct_obj%A(lbound(struct_obj%A, 1)))
      bounds(1) = int(lbound(struct_obj%A, 1), c_int)
      bounds(2) = int(ubound(struct_obj%A, 1), c_int)
      
      el_size = int(storage_size(struct_obj%A(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%A_inv: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_A_inv_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_A_inv_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%A_inv)) then
      data_ptr = c_loc(struct_obj%A_inv(lbound(struct_obj%A_inv, 1)))
      bounds(1) = int(lbound(struct_obj%A_inv, 1), c_int)
      bounds(2) = int(ubound(struct_obj%A_inv, 1), c_int)
      
      el_size = int(storage_size(struct_obj%A_inv(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%dhdj: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_dhdj_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_dhdj_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%dhdj)) then
      data_ptr = c_loc(struct_obj%dhdj(lbound(struct_obj%dhdj, 1)))
      bounds(1) = int(lbound(struct_obj%dhdj, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dhdj, 1), c_int)
      
      el_size = int(storage_size(struct_obj%dhdj(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%F: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_F_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_F_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%F)) then
      data_ptr = c_loc(struct_obj%F(lbound(struct_obj%F, 1)))
      bounds(1) = int(lbound(struct_obj%F, 1), c_int)
      bounds(2) = int(ubound(struct_obj%F, 1), c_int)
      
      el_size = int(storage_size(struct_obj%F(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%L: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_L_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_L_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%L)) then
      data_ptr = c_loc(struct_obj%L(lbound(struct_obj%L, 1)))
      bounds(1) = int(lbound(struct_obj%L, 1), c_int)
      bounds(2) = int(ubound(struct_obj%L, 1), c_int)
      
      el_size = int(storage_size(struct_obj%L(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%h: 1D_ALLOC_type

  subroutine bmad_normal_form_struct_get_h_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_h_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%h) .and. is_contiguous(struct_obj%h)) then
      data_ptr = c_loc(struct_obj%h(lbound(struct_obj%h, 1)))
      bounds(1) = int(lbound(struct_obj%h, 1), c_int)
      bounds(2) = int(ubound(struct_obj%h, 1), c_int)
      
      el_size = int(storage_size(struct_obj%h(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! bunch_track_struct

    function allocate_fortran_bunch_track_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bunch_track_struct), pointer :: fptr
      type(bunch_track_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bunch_track_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bunch_track_struct), pointer :: fptr
      type(bunch_track_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bunch_track_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bunch_track_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bunch_track_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bunch_track_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bunch_track_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bunch_track_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bunch_track_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bunch_track_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bunch_track_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bunch_track_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bunch_track_struct%pt: 1D_ALLOC_type

  subroutine bunch_track_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bunch_track_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_track_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      
      el_size = int(storage_size(struct_obj%pt(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_track_struct%ds_save: 0D_NOT_real

  subroutine bunch_track_struct_get_ds_save(struct_obj_ptr, value_out) bind(c, name='bunch_track_struct_get_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_save
  end subroutine


  subroutine bunch_track_struct_set_ds_save(struct_obj_ptr, value_in) bind(c, name='bunch_track_struct_set_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_save = value_in
  end subroutine

  ! bunch_track_struct%n_pt: 0D_NOT_integer

  subroutine bunch_track_struct_get_n_pt(struct_obj_ptr, value_out) bind(c, name='bunch_track_struct_get_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_pt
  end subroutine


  subroutine bunch_track_struct_set_n_pt(struct_obj_ptr, value_in) bind(c, name='bunch_track_struct_set_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_pt = value_in
  end subroutine

  !! summation_rdt_struct

    function allocate_fortran_summation_rdt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(summation_rdt_struct), pointer :: fptr
      type(summation_rdt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_summation_rdt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(summation_rdt_struct), pointer :: fptr
      type(summation_rdt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_summation_rdt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(summation_rdt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_summation_rdt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(summation_rdt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_summation_rdt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(summation_rdt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_summation_rdt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(summation_rdt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_summation_rdt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(summation_rdt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! summation_rdt_struct%h11001: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h11001(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h11001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h11001
  end subroutine


  subroutine summation_rdt_struct_set_h11001(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h11001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h11001 = value_in
  end subroutine

  ! summation_rdt_struct%h00111: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00111(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00111')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00111
  end subroutine


  subroutine summation_rdt_struct_set_h00111(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00111')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00111 = value_in
  end subroutine

  ! summation_rdt_struct%h20001: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20001(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20001
  end subroutine


  subroutine summation_rdt_struct_set_h20001(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20001 = value_in
  end subroutine

  ! summation_rdt_struct%h00201: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00201(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00201')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00201
  end subroutine


  subroutine summation_rdt_struct_set_h00201(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00201')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00201 = value_in
  end subroutine

  ! summation_rdt_struct%h10002: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10002(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10002')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10002
  end subroutine


  subroutine summation_rdt_struct_set_h10002(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10002')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10002 = value_in
  end subroutine

  ! summation_rdt_struct%h21000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h21000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h21000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h21000
  end subroutine


  subroutine summation_rdt_struct_set_h21000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h21000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h21000 = value_in
  end subroutine

  ! summation_rdt_struct%h30000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h30000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h30000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h30000
  end subroutine


  subroutine summation_rdt_struct_set_h30000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h30000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h30000 = value_in
  end subroutine

  ! summation_rdt_struct%h10110: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10110(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10110
  end subroutine


  subroutine summation_rdt_struct_set_h10110(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10110 = value_in
  end subroutine

  ! summation_rdt_struct%h10020: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10020(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10020
  end subroutine


  subroutine summation_rdt_struct_set_h10020(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10020 = value_in
  end subroutine

  ! summation_rdt_struct%h10200: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10200(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10200
  end subroutine


  subroutine summation_rdt_struct_set_h10200(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10200 = value_in
  end subroutine

  ! summation_rdt_struct%h31000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h31000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h31000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h31000
  end subroutine


  subroutine summation_rdt_struct_set_h31000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h31000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h31000 = value_in
  end subroutine

  ! summation_rdt_struct%h40000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h40000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h40000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h40000
  end subroutine


  subroutine summation_rdt_struct_set_h40000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h40000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h40000 = value_in
  end subroutine

  ! summation_rdt_struct%h20110: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20110(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20110
  end subroutine


  subroutine summation_rdt_struct_set_h20110(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20110 = value_in
  end subroutine

  ! summation_rdt_struct%h11200: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h11200(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h11200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h11200
  end subroutine


  subroutine summation_rdt_struct_set_h11200(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h11200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h11200 = value_in
  end subroutine

  ! summation_rdt_struct%h20020: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20020(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20020
  end subroutine


  subroutine summation_rdt_struct_set_h20020(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20020 = value_in
  end subroutine

  ! summation_rdt_struct%h20200: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20200(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20200
  end subroutine


  subroutine summation_rdt_struct_set_h20200(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20200 = value_in
  end subroutine

  ! summation_rdt_struct%h00310: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00310(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00310')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00310
  end subroutine


  subroutine summation_rdt_struct_set_h00310(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00310')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00310 = value_in
  end subroutine

  ! summation_rdt_struct%h00400: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00400(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00400')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00400
  end subroutine


  subroutine summation_rdt_struct_set_h00400(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00400')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00400 = value_in
  end subroutine

  ! summation_rdt_struct%h22000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h22000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h22000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h22000
  end subroutine


  subroutine summation_rdt_struct_set_h22000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h22000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h22000 = value_in
  end subroutine

  ! summation_rdt_struct%h00220: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00220(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00220')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00220
  end subroutine


  subroutine summation_rdt_struct_set_h00220(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00220')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00220 = value_in
  end subroutine

  ! summation_rdt_struct%h11110: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h11110(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h11110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h11110
  end subroutine


  subroutine summation_rdt_struct_set_h11110(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h11110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h11110 = value_in
  end subroutine

  !! tao_ele_shape_struct

    function allocate_fortran_tao_ele_shape_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_ele_shape_struct), pointer :: fptr
      type(tao_ele_shape_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_ele_shape_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_ele_shape_struct), pointer :: fptr
      type(tao_ele_shape_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_ele_shape_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_ele_shape_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_ele_shape_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_ele_shape_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_ele_shape_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_ele_shape_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_ele_shape_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_ele_shape_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_ele_shape_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_ele_shape_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_ele_shape_struct%ele_id: 0D_NOT_character

  subroutine tao_ele_shape_struct_get_ele_id_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_ele_shape_struct_get_ele_id_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_id)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_id), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_ele_shape_struct_set_ele_id(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_ele_shape_struct_set_ele_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_ele_shape_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_id = str_in ! implicitly handles padding
  end subroutine

  ! tao_ele_shape_struct%shape: 0D_NOT_character

  subroutine tao_ele_shape_struct_get_shape_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_ele_shape_struct_get_shape_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%shape)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%shape), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_ele_shape_struct_set_shape(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_ele_shape_struct_set_shape')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_ele_shape_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%shape = str_in ! implicitly handles padding
  end subroutine

  ! tao_ele_shape_struct%color: 0D_NOT_character

  subroutine tao_ele_shape_struct_get_color_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_ele_shape_struct_get_color_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%color)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%color), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_ele_shape_struct_set_color(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_ele_shape_struct_set_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_ele_shape_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%color = str_in ! implicitly handles padding
  end subroutine

  ! tao_ele_shape_struct%size: 0D_NOT_real

  subroutine tao_ele_shape_struct_get_size(struct_obj_ptr, value_out) bind(c, name='tao_ele_shape_struct_get_size')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%size
  end subroutine


  subroutine tao_ele_shape_struct_set_size(struct_obj_ptr, value_in) bind(c, name='tao_ele_shape_struct_set_size')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%size = value_in
  end subroutine

  ! tao_ele_shape_struct%label: 0D_NOT_character

  subroutine tao_ele_shape_struct_get_label_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_ele_shape_struct_get_label_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%label)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%label), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_ele_shape_struct_set_label(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_ele_shape_struct_set_label')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_ele_shape_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%label = str_in ! implicitly handles padding
  end subroutine

  ! tao_ele_shape_struct%draw: 0D_NOT_logical

  subroutine tao_ele_shape_struct_get_draw(struct_obj_ptr, value_out) bind(c, name='tao_ele_shape_struct_get_draw')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw
  end subroutine


  subroutine tao_ele_shape_struct_set_draw(struct_obj_ptr, value_in) bind(c, name='tao_ele_shape_struct_set_draw')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw = value_in
  end subroutine

  ! tao_ele_shape_struct%multi: 0D_NOT_logical

  subroutine tao_ele_shape_struct_get_multi(struct_obj_ptr, value_out) bind(c, name='tao_ele_shape_struct_get_multi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%multi
  end subroutine


  subroutine tao_ele_shape_struct_set_multi(struct_obj_ptr, value_in) bind(c, name='tao_ele_shape_struct_set_multi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%multi = value_in
  end subroutine

  ! tao_ele_shape_struct%line_width: 0D_NOT_integer

  subroutine tao_ele_shape_struct_get_line_width(struct_obj_ptr, value_out) bind(c, name='tao_ele_shape_struct_get_line_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%line_width
  end subroutine


  subroutine tao_ele_shape_struct_set_line_width(struct_obj_ptr, value_in) bind(c, name='tao_ele_shape_struct_set_line_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%line_width = value_in
  end subroutine

  ! tao_ele_shape_struct%offset: 0D_NOT_real

  subroutine tao_ele_shape_struct_get_offset(struct_obj_ptr, value_out) bind(c, name='tao_ele_shape_struct_get_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%offset
  end subroutine


  subroutine tao_ele_shape_struct_set_offset(struct_obj_ptr, value_in) bind(c, name='tao_ele_shape_struct_set_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%offset = value_in
  end subroutine

  ! tao_ele_shape_struct%ix_key: 0D_NOT_integer

  subroutine tao_ele_shape_struct_get_ix_key(struct_obj_ptr, value_out) bind(c, name='tao_ele_shape_struct_get_ix_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_key
  end subroutine


  subroutine tao_ele_shape_struct_set_ix_key(struct_obj_ptr, value_in) bind(c, name='tao_ele_shape_struct_set_ix_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_key = value_in
  end subroutine

  ! tao_ele_shape_struct%name_ele: 0D_NOT_character

  subroutine tao_ele_shape_struct_get_name_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_ele_shape_struct_get_name_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_shape_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name_ele)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name_ele), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_ele_shape_struct_set_name_ele(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_ele_shape_struct_set_name_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_ele_shape_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name_ele = str_in ! implicitly handles padding
  end subroutine

  ! tao_ele_shape_struct%uni: 1D_ALLOC_type

  subroutine tao_ele_shape_struct_get_uni_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_ele_shape_struct_get_uni_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_shape_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%uni) .and. is_contiguous(struct_obj%uni)) then
      data_ptr = c_loc(struct_obj%uni(lbound(struct_obj%uni, 1)))
      bounds(1) = int(lbound(struct_obj%uni, 1), c_int)
      bounds(2) = int(ubound(struct_obj%uni, 1), c_int)
      
      el_size = int(storage_size(struct_obj%uni(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_ele_pointer_struct

    function allocate_fortran_tao_ele_pointer_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_ele_pointer_struct), pointer :: fptr
      type(tao_ele_pointer_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_ele_pointer_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_ele_pointer_struct), pointer :: fptr
      type(tao_ele_pointer_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_ele_pointer_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_ele_pointer_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_ele_pointer_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_ele_pointer_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_ele_pointer_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_ele_pointer_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_ele_pointer_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_ele_pointer_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_ele_pointer_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_ele_pointer_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_ele_pointer_struct%eles: 1D_ALLOC_type

  subroutine tao_ele_pointer_struct_get_eles_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_ele_pointer_struct_get_eles_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_ele_pointer_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%eles) .and. is_contiguous(struct_obj%eles)) then
      data_ptr = c_loc(struct_obj%eles(lbound(struct_obj%eles, 1)))
      bounds(1) = int(lbound(struct_obj%eles, 1), c_int)
      bounds(2) = int(ubound(struct_obj%eles, 1), c_int)
      
      el_size = int(storage_size(struct_obj%eles(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_ele_pointer_struct%n_loc: 0D_NOT_integer

  subroutine tao_ele_pointer_struct_get_n_loc(struct_obj_ptr, value_out) bind(c, name='tao_ele_pointer_struct_get_n_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_ele_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_loc
  end subroutine


  subroutine tao_ele_pointer_struct_set_n_loc(struct_obj_ptr, value_in) bind(c, name='tao_ele_pointer_struct_set_n_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_ele_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_loc = value_in
  end subroutine

  !! tao_curve_struct

    function allocate_fortran_tao_curve_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_curve_struct), pointer :: fptr
      type(tao_curve_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_curve_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_curve_struct), pointer :: fptr
      type(tao_curve_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_curve_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_curve_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_curve_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_curve_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_curve_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_curve_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_curve_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_curve_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_curve_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_curve_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_curve_struct%name: 0D_NOT_character

  subroutine tao_curve_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%data_source: 0D_NOT_character

  subroutine tao_curve_struct_get_data_source_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_data_source_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_source)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_source), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_data_source(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_data_source')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_source = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%data_index: 0D_NOT_character

  subroutine tao_curve_struct_get_data_index_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_data_index_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_index)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_index), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_data_index(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_data_index')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_index = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%data_type_x: 0D_NOT_character

  subroutine tao_curve_struct_get_data_type_x_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_data_type_x_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_type_x)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_type_x), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_data_type_x(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_data_type_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_type_x = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%data_type: 0D_ALLOC_character

  subroutine tao_curve_struct_get_data_type_info(struct_obj_ptr, data_ptr, str_len, is_allocated) &
    bind(c, name='tao_curve_struct_get_data_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%data_type)) then
      data_ptr = c_loc(struct_obj%data_type)
      str_len = int(len(struct_obj%data_type), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine


  subroutine tao_curve_struct_set_data_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_data_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: temp_str

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%data_type)) deallocate(struct_obj%data_type)

    if (str_len > 0) then
       call c_f_pointer(str_ptr, temp_str)
       allocate(struct_obj%data_type, source=temp_str)
       struct_obj%data_type = temp_str(1:str_len)
    endif
  end subroutine

  ! tao_curve_struct%ele_ref_name: 0D_NOT_character

  subroutine tao_curve_struct_get_ele_ref_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_ele_ref_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_ref_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_ref_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_ele_ref_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_ele_ref_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_ref_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%legend_text: 0D_NOT_character

  subroutine tao_curve_struct_get_legend_text_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_legend_text_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%legend_text)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%legend_text), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_legend_text(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_legend_text')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%legend_text = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%message_text: 0D_NOT_character

  subroutine tao_curve_struct_get_message_text_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_message_text_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%message_text)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%message_text), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_message_text(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_message_text')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%message_text = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%component: 0D_NOT_character

  subroutine tao_curve_struct_get_component_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_component_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%component)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%component), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_component(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_component')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%component = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%why_invalid: 0D_NOT_character

  subroutine tao_curve_struct_get_why_invalid_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_struct_get_why_invalid_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%why_invalid)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%why_invalid), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_struct_set_why_invalid(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_struct_set_why_invalid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%why_invalid = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_struct%g: 0D_PTR_type

  subroutine tao_curve_struct_get_g(struct_obj_ptr, ptr_out) bind(c, name='tao_curve_struct_get_g')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%g)) then
      ptr_out = c_loc(struct_obj%g)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_curve_struct_set_g(struct_obj_ptr, src_ptr) bind(c, name='tao_curve_struct_set_g')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_curve_struct), pointer :: struct_obj
    type(tao_graph_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%g)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%g = src_obj
    endif
  end subroutine

  ! tao_curve_struct%hist: 0D_NOT_type

  subroutine tao_curve_struct_get_hist(struct_obj_ptr, ptr_out) bind(c, name='tao_curve_struct_get_hist')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%hist)
  end subroutine


  subroutine tao_curve_struct_set_hist(struct_obj_ptr, src_ptr) bind(c, name='tao_curve_struct_set_hist')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_curve_struct), pointer :: struct_obj
    type(tao_histogram_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%hist = src_obj
  end subroutine

  ! tao_curve_struct%z_color: 0D_NOT_type

  subroutine tao_curve_struct_get_z_color(struct_obj_ptr, ptr_out) bind(c, name='tao_curve_struct_get_z_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z_color)
  end subroutine


  subroutine tao_curve_struct_set_z_color(struct_obj_ptr, src_ptr) bind(c, name='tao_curve_struct_set_z_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_curve_struct), pointer :: struct_obj
    type(tao_curve_color_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z_color = src_obj
  end subroutine

  ! tao_curve_struct%x_line: 1D_ALLOC_real

  subroutine tao_curve_struct_get_x_line_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_x_line_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%x_line) .and. is_contiguous(struct_obj%x_line)) then
      data_ptr = c_loc(struct_obj%x_line(lbound(struct_obj%x_line, 1)))
      bounds(1) = int(lbound(struct_obj%x_line, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x_line, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%y_line: 1D_ALLOC_real

  subroutine tao_curve_struct_get_y_line_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_y_line_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%y_line) .and. is_contiguous(struct_obj%y_line)) then
      data_ptr = c_loc(struct_obj%y_line(lbound(struct_obj%y_line, 1)))
      bounds(1) = int(lbound(struct_obj%y_line, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y_line, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%y2_line: 1D_ALLOC_real

  subroutine tao_curve_struct_get_y2_line_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_y2_line_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%y2_line) .and. is_contiguous(struct_obj%y2_line)) then
      data_ptr = c_loc(struct_obj%y2_line(lbound(struct_obj%y2_line, 1)))
      bounds(1) = int(lbound(struct_obj%y2_line, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y2_line, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%ix_line: 1D_ALLOC_integer

  subroutine tao_curve_struct_get_ix_line_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_ix_line_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ix_line) .and. is_contiguous(struct_obj%ix_line)) then
      data_ptr = c_loc(struct_obj%ix_line(lbound(struct_obj%ix_line, 1)))
      bounds(1) = int(lbound(struct_obj%ix_line, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ix_line, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%x_symb: 1D_ALLOC_real

  subroutine tao_curve_struct_get_x_symb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_x_symb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%x_symb) .and. is_contiguous(struct_obj%x_symb)) then
      data_ptr = c_loc(struct_obj%x_symb(lbound(struct_obj%x_symb, 1)))
      bounds(1) = int(lbound(struct_obj%x_symb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x_symb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%y_symb: 1D_ALLOC_real

  subroutine tao_curve_struct_get_y_symb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_y_symb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%y_symb) .and. is_contiguous(struct_obj%y_symb)) then
      data_ptr = c_loc(struct_obj%y_symb(lbound(struct_obj%y_symb, 1)))
      bounds(1) = int(lbound(struct_obj%y_symb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y_symb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%z_symb: 1D_ALLOC_real

  subroutine tao_curve_struct_get_z_symb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_z_symb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%z_symb) .and. is_contiguous(struct_obj%z_symb)) then
      data_ptr = c_loc(struct_obj%z_symb(lbound(struct_obj%z_symb, 1)))
      bounds(1) = int(lbound(struct_obj%z_symb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%z_symb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%err_symb: 1D_ALLOC_real

  subroutine tao_curve_struct_get_err_symb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_err_symb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%err_symb) .and. is_contiguous(struct_obj%err_symb)) then
      data_ptr = c_loc(struct_obj%err_symb(lbound(struct_obj%err_symb, 1)))
      bounds(1) = int(lbound(struct_obj%err_symb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%err_symb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%symb_size: 1D_ALLOC_real

  subroutine tao_curve_struct_get_symb_size_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_symb_size_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%symb_size) .and. is_contiguous(struct_obj%symb_size)) then
      data_ptr = c_loc(struct_obj%symb_size(lbound(struct_obj%symb_size, 1)))
      bounds(1) = int(lbound(struct_obj%symb_size, 1), c_int)
      bounds(2) = int(ubound(struct_obj%symb_size, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%ix_symb: 1D_ALLOC_integer

  subroutine tao_curve_struct_get_ix_symb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_curve_struct_get_ix_symb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ix_symb) .and. is_contiguous(struct_obj%ix_symb)) then
      data_ptr = c_loc(struct_obj%ix_symb(lbound(struct_obj%ix_symb, 1)))
      bounds(1) = int(lbound(struct_obj%ix_symb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ix_symb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_curve_struct%y_axis_scale_factor: 0D_NOT_real

  subroutine tao_curve_struct_get_y_axis_scale_factor(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_y_axis_scale_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_axis_scale_factor
  end subroutine


  subroutine tao_curve_struct_set_y_axis_scale_factor(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_y_axis_scale_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_axis_scale_factor = value_in
  end subroutine

  ! tao_curve_struct%line: 0D_NOT_type

  subroutine tao_curve_struct_get_line(struct_obj_ptr, ptr_out) bind(c, name='tao_curve_struct_get_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%line)
  end subroutine


  subroutine tao_curve_struct_set_line(struct_obj_ptr, src_ptr) bind(c, name='tao_curve_struct_set_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_curve_struct), pointer :: struct_obj
    type(qp_line_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%line = src_obj
  end subroutine

  ! tao_curve_struct%symbol: 0D_NOT_type

  subroutine tao_curve_struct_get_symbol(struct_obj_ptr, ptr_out) bind(c, name='tao_curve_struct_get_symbol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%symbol)
  end subroutine


  subroutine tao_curve_struct_set_symbol(struct_obj_ptr, src_ptr) bind(c, name='tao_curve_struct_set_symbol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_curve_struct), pointer :: struct_obj
    type(qp_symbol_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%symbol = src_obj
  end subroutine

  ! tao_curve_struct%orbit: 0D_NOT_type

  subroutine tao_curve_struct_get_orbit(struct_obj_ptr, ptr_out) bind(c, name='tao_curve_struct_get_orbit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orbit)
  end subroutine


  subroutine tao_curve_struct_set_orbit(struct_obj_ptr, src_ptr) bind(c, name='tao_curve_struct_set_orbit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_curve_struct), pointer :: struct_obj
    type(tao_curve_orbit_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orbit = src_obj
  end subroutine

  ! tao_curve_struct%ix_universe: 0D_NOT_integer

  subroutine tao_curve_struct_get_ix_universe(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_universe
  end subroutine


  subroutine tao_curve_struct_set_ix_universe(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_universe = value_in
  end subroutine

  ! tao_curve_struct%symbol_every: 0D_NOT_integer

  subroutine tao_curve_struct_get_symbol_every(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_symbol_every')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%symbol_every
  end subroutine


  subroutine tao_curve_struct_set_symbol_every(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_symbol_every')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%symbol_every = value_in
  end subroutine

  ! tao_curve_struct%ix_branch: 0D_NOT_integer

  subroutine tao_curve_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_curve_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_curve_struct%ix_bunch: 0D_NOT_integer

  subroutine tao_curve_struct_get_ix_bunch(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch
  end subroutine


  subroutine tao_curve_struct_set_ix_bunch(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch = value_in
  end subroutine

  ! tao_curve_struct%n_turn: 0D_NOT_integer

  subroutine tao_curve_struct_get_n_turn(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_n_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_turn
  end subroutine


  subroutine tao_curve_struct_set_n_turn(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_n_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_turn = value_in
  end subroutine

  ! tao_curve_struct%use_y2: 0D_NOT_logical

  subroutine tao_curve_struct_get_use_y2(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_use_y2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_y2
  end subroutine


  subroutine tao_curve_struct_set_use_y2(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_use_y2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_y2 = value_in
  end subroutine

  ! tao_curve_struct%draw_line: 0D_NOT_logical

  subroutine tao_curve_struct_get_draw_line(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_draw_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_line
  end subroutine


  subroutine tao_curve_struct_set_draw_line(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_draw_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_line = value_in
  end subroutine

  ! tao_curve_struct%draw_symbols: 0D_NOT_logical

  subroutine tao_curve_struct_get_draw_symbols(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_draw_symbols')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_symbols
  end subroutine


  subroutine tao_curve_struct_set_draw_symbols(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_draw_symbols')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_symbols = value_in
  end subroutine

  ! tao_curve_struct%draw_symbol_index: 0D_NOT_logical

  subroutine tao_curve_struct_get_draw_symbol_index(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_draw_symbol_index')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_symbol_index
  end subroutine


  subroutine tao_curve_struct_set_draw_symbol_index(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_draw_symbol_index')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_symbol_index = value_in
  end subroutine

  ! tao_curve_struct%draw_error_bars: 0D_NOT_logical

  subroutine tao_curve_struct_get_draw_error_bars(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_draw_error_bars')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_error_bars
  end subroutine


  subroutine tao_curve_struct_set_draw_error_bars(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_draw_error_bars')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_error_bars = value_in
  end subroutine

  ! tao_curve_struct%smooth_line_calc: 0D_NOT_logical

  subroutine tao_curve_struct_get_smooth_line_calc(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_smooth_line_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%smooth_line_calc
  end subroutine


  subroutine tao_curve_struct_set_smooth_line_calc(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_smooth_line_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%smooth_line_calc = value_in
  end subroutine

  ! tao_curve_struct%valid: 0D_NOT_logical

  subroutine tao_curve_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_curve_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_curve_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_curve_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  !! tao_curve_color_struct

    function allocate_fortran_tao_curve_color_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_curve_color_struct), pointer :: fptr
      type(tao_curve_color_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_curve_color_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_curve_color_struct), pointer :: fptr
      type(tao_curve_color_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_curve_color_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_curve_color_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_curve_color_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_curve_color_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_curve_color_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_curve_color_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_curve_color_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_curve_color_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_curve_color_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_curve_color_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_curve_color_struct%data_type: 0D_NOT_character

  subroutine tao_curve_color_struct_get_data_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_curve_color_struct_get_data_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_curve_color_struct_set_data_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_curve_color_struct_set_data_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_curve_color_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_curve_color_struct%is_on: 0D_NOT_logical

  subroutine tao_curve_color_struct_get_is_on(struct_obj_ptr, value_out) bind(c, name='tao_curve_color_struct_get_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_on
  end subroutine


  subroutine tao_curve_color_struct_set_is_on(struct_obj_ptr, value_in) bind(c, name='tao_curve_color_struct_set_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_on = value_in
  end subroutine

  ! tao_curve_color_struct%min: 0D_NOT_real

  subroutine tao_curve_color_struct_get_min(struct_obj_ptr, value_out) bind(c, name='tao_curve_color_struct_get_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%min
  end subroutine


  subroutine tao_curve_color_struct_set_min(struct_obj_ptr, value_in) bind(c, name='tao_curve_color_struct_set_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%min = value_in
  end subroutine

  ! tao_curve_color_struct%max: 0D_NOT_real

  subroutine tao_curve_color_struct_get_max(struct_obj_ptr, value_out) bind(c, name='tao_curve_color_struct_get_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max
  end subroutine


  subroutine tao_curve_color_struct_set_max(struct_obj_ptr, value_in) bind(c, name='tao_curve_color_struct_set_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max = value_in
  end subroutine

  ! tao_curve_color_struct%autoscale: 0D_NOT_logical

  subroutine tao_curve_color_struct_get_autoscale(struct_obj_ptr, value_out) bind(c, name='tao_curve_color_struct_get_autoscale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale
  end subroutine


  subroutine tao_curve_color_struct_set_autoscale(struct_obj_ptr, value_in) bind(c, name='tao_curve_color_struct_set_autoscale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_curve_color_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale = value_in
  end subroutine

  !! tao_curve_orbit_struct

    function allocate_fortran_tao_curve_orbit_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_curve_orbit_struct), pointer :: fptr
      type(tao_curve_orbit_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_curve_orbit_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_curve_orbit_struct), pointer :: fptr
      type(tao_curve_orbit_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_curve_orbit_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_curve_orbit_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_curve_orbit_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_curve_orbit_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_curve_orbit_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_curve_orbit_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_curve_orbit_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_curve_orbit_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_curve_orbit_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_curve_orbit_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_curve_orbit_struct%x: 0D_NOT_real

  subroutine tao_curve_orbit_struct_get_x(struct_obj_ptr, value_out) bind(c, name='tao_curve_orbit_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_curve_orbit_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine tao_curve_orbit_struct_set_x(struct_obj_ptr, value_in) bind(c, name='tao_curve_orbit_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_curve_orbit_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! tao_curve_orbit_struct%y: 0D_NOT_real

  subroutine tao_curve_orbit_struct_get_y(struct_obj_ptr, value_out) bind(c, name='tao_curve_orbit_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_curve_orbit_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine tao_curve_orbit_struct_set_y(struct_obj_ptr, value_in) bind(c, name='tao_curve_orbit_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_curve_orbit_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! tao_curve_orbit_struct%t: 0D_NOT_real

  subroutine tao_curve_orbit_struct_get_t(struct_obj_ptr, value_out) bind(c, name='tao_curve_orbit_struct_get_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_curve_orbit_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t
  end subroutine


  subroutine tao_curve_orbit_struct_set_t(struct_obj_ptr, value_in) bind(c, name='tao_curve_orbit_struct_set_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_curve_orbit_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t = value_in
  end subroutine

  !! tao_histogram_struct

    function allocate_fortran_tao_histogram_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_histogram_struct), pointer :: fptr
      type(tao_histogram_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_histogram_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_histogram_struct), pointer :: fptr
      type(tao_histogram_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_histogram_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_histogram_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_histogram_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_histogram_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_histogram_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_histogram_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_histogram_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_histogram_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_histogram_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_histogram_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_histogram_struct%density_normalized: 0D_NOT_logical

  subroutine tao_histogram_struct_get_density_normalized(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_density_normalized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%density_normalized
  end subroutine


  subroutine tao_histogram_struct_set_density_normalized(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_density_normalized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%density_normalized = value_in
  end subroutine

  ! tao_histogram_struct%weight_by_charge: 0D_NOT_logical

  subroutine tao_histogram_struct_get_weight_by_charge(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_weight_by_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%weight_by_charge
  end subroutine


  subroutine tao_histogram_struct_set_weight_by_charge(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_weight_by_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%weight_by_charge = value_in
  end subroutine

  ! tao_histogram_struct%minimum: 0D_NOT_real

  subroutine tao_histogram_struct_get_minimum(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_minimum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%minimum
  end subroutine


  subroutine tao_histogram_struct_set_minimum(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_minimum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%minimum = value_in
  end subroutine

  ! tao_histogram_struct%maximum: 0D_NOT_real

  subroutine tao_histogram_struct_get_maximum(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_maximum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%maximum
  end subroutine


  subroutine tao_histogram_struct_set_maximum(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_maximum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%maximum = value_in
  end subroutine

  ! tao_histogram_struct%width: 0D_NOT_real

  subroutine tao_histogram_struct_get_width(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%width
  end subroutine


  subroutine tao_histogram_struct_set_width(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%width = value_in
  end subroutine

  ! tao_histogram_struct%center: 0D_NOT_real

  subroutine tao_histogram_struct_get_center(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%center
  end subroutine


  subroutine tao_histogram_struct_set_center(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%center = value_in
  end subroutine

  ! tao_histogram_struct%number: 0D_NOT_integer

  subroutine tao_histogram_struct_get_number(struct_obj_ptr, value_out) bind(c, name='tao_histogram_struct_get_number')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%number
  end subroutine


  subroutine tao_histogram_struct_set_number(struct_obj_ptr, value_in) bind(c, name='tao_histogram_struct_set_number')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_histogram_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%number = value_in
  end subroutine

  !! lat_ele_order1_struct

    function allocate_fortran_lat_ele_order1_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(lat_ele_order1_struct), pointer :: fptr
      type(lat_ele_order1_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_lat_ele_order1_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(lat_ele_order1_struct), pointer :: fptr
      type(lat_ele_order1_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_lat_ele_order1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_order1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_lat_ele_order1_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(lat_ele_order1_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_lat_ele_order1_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(lat_ele_order1_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_lat_ele_order1_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(lat_ele_order1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_lat_ele_order1_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(lat_ele_order1_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! lat_ele_order1_struct%ix_branch: 0D_NOT_integer

  subroutine lat_ele_order1_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='lat_ele_order1_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine lat_ele_order1_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='lat_ele_order1_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! lat_ele_order1_struct%ix_order: 0D_NOT_integer

  subroutine lat_ele_order1_struct_get_ix_order(struct_obj_ptr, value_out) bind(c, name='lat_ele_order1_struct_get_ix_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_order
  end subroutine


  subroutine lat_ele_order1_struct_set_ix_order(struct_obj_ptr, value_in) bind(c, name='lat_ele_order1_struct_set_ix_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_order = value_in
  end subroutine

  !! lat_ele_order_array_struct

    function allocate_fortran_lat_ele_order_array_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(lat_ele_order_array_struct), pointer :: fptr
      type(lat_ele_order_array_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_lat_ele_order_array_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(lat_ele_order_array_struct), pointer :: fptr
      type(lat_ele_order_array_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_lat_ele_order_array_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_order_array_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_lat_ele_order_array_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(lat_ele_order_array_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_lat_ele_order_array_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(lat_ele_order_array_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_lat_ele_order_array_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(lat_ele_order_array_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_lat_ele_order_array_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(lat_ele_order_array_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! lat_ele_order_array_struct%ele: 1D_ALLOC_type

  subroutine lat_ele_order_array_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_ele_order_array_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_ele_order_array_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_lat_sigma_struct

    function allocate_fortran_tao_lat_sigma_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_lat_sigma_struct), pointer :: fptr
      type(tao_lat_sigma_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_lat_sigma_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_lat_sigma_struct), pointer :: fptr
      type(tao_lat_sigma_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_lat_sigma_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_lat_sigma_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_lat_sigma_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_lat_sigma_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_lat_sigma_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_lat_sigma_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_lat_sigma_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_lat_sigma_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_lat_sigma_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_lat_sigma_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_lat_sigma_struct%mat: 2D_NOT_real

  subroutine tao_lat_sigma_struct_get_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_lat_sigma_struct_get_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lat_sigma_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%mat)) then
      data_ptr = c_loc(struct_obj%mat(lbound(struct_obj%mat, 1), lbound(struct_obj%mat, 2)))
      bounds(1) = int(lbound(struct_obj%mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! tao_spin_ele_struct

    function allocate_fortran_tao_spin_ele_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_spin_ele_struct), pointer :: fptr
      type(tao_spin_ele_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_spin_ele_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_spin_ele_struct), pointer :: fptr
      type(tao_spin_ele_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_spin_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_spin_ele_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_spin_ele_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_spin_ele_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_spin_ele_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_spin_ele_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_spin_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_spin_ele_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_spin_ele_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_spin_ele_struct%dn_dpz: 0D_NOT_type

  subroutine tao_spin_ele_struct_get_dn_dpz(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_ele_struct_get_dn_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%dn_dpz)
  end subroutine


  subroutine tao_spin_ele_struct_set_dn_dpz(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_ele_struct_set_dn_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_ele_struct), pointer :: struct_obj
    type(tao_spin_dn_dpz_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%dn_dpz = src_obj
  end subroutine

  ! tao_spin_ele_struct%orb_eigen_val: 1D_NOT_real

  subroutine tao_spin_ele_struct_get_orb_eigen_val_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_ele_struct_get_orb_eigen_val_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_ele_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%orb_eigen_val)) then
      data_ptr = c_loc(struct_obj%orb_eigen_val(lbound(struct_obj%orb_eigen_val, 1)))
      bounds(1) = int(lbound(struct_obj%orb_eigen_val, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb_eigen_val, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_ele_struct%orb_eigen_vec: 2D_NOT_real

  subroutine tao_spin_ele_struct_get_orb_eigen_vec_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_ele_struct_get_orb_eigen_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%orb_eigen_vec)) then
      data_ptr = c_loc(struct_obj%orb_eigen_vec(lbound(struct_obj%orb_eigen_vec, 1), lbound(struct_obj%orb_eigen_vec, 2)))
      bounds(1) = int(lbound(struct_obj%orb_eigen_vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb_eigen_vec, 1), c_int)
      bounds(3) = int(lbound(struct_obj%orb_eigen_vec, 2), c_int)
      bounds(4) = int(ubound(struct_obj%orb_eigen_vec, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_ele_struct%spin_eigen_vec: 2D_NOT_real

  subroutine tao_spin_ele_struct_get_spin_eigen_vec_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_ele_struct_get_spin_eigen_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%spin_eigen_vec)) then
      data_ptr = c_loc(struct_obj%spin_eigen_vec(lbound(struct_obj%spin_eigen_vec, 1), lbound(struct_obj%spin_eigen_vec, 2)))
      bounds(1) = int(lbound(struct_obj%spin_eigen_vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_eigen_vec, 1), c_int)
      bounds(3) = int(lbound(struct_obj%spin_eigen_vec, 2), c_int)
      bounds(4) = int(ubound(struct_obj%spin_eigen_vec, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_ele_struct%valid: 0D_NOT_logical

  subroutine tao_spin_ele_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_spin_ele_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_spin_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_spin_ele_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_spin_ele_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_spin_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  !! tao_plot_cache_struct

    function allocate_fortran_tao_plot_cache_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_plot_cache_struct), pointer :: fptr
      type(tao_plot_cache_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_plot_cache_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_plot_cache_struct), pointer :: fptr
      type(tao_plot_cache_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_plot_cache_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_plot_cache_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_plot_cache_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_plot_cache_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_plot_cache_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_plot_cache_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_plot_cache_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_plot_cache_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_plot_cache_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_plot_cache_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_plot_cache_struct%ele_to_s: 0D_NOT_type

  subroutine tao_plot_cache_struct_get_ele_to_s(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_cache_struct_get_ele_to_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_to_s)
  end subroutine


  subroutine tao_plot_cache_struct_set_ele_to_s(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_cache_struct_set_ele_to_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_cache_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_to_s = src_obj
  end subroutine

  ! tao_plot_cache_struct%orbit: 0D_NOT_type

  subroutine tao_plot_cache_struct_get_orbit(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_cache_struct_get_orbit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orbit)
  end subroutine


  subroutine tao_plot_cache_struct_set_orbit(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_cache_struct_set_orbit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_cache_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orbit = src_obj
  end subroutine

  ! tao_plot_cache_struct%err: 0D_NOT_logical

  subroutine tao_plot_cache_struct_get_err(struct_obj_ptr, value_out) bind(c, name='tao_plot_cache_struct_get_err')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%err
  end subroutine


  subroutine tao_plot_cache_struct_set_err(struct_obj_ptr, value_in) bind(c, name='tao_plot_cache_struct_set_err')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%err = value_in
  end subroutine

  !! tao_spin_polarization_struct

    function allocate_fortran_tao_spin_polarization_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_spin_polarization_struct), pointer :: fptr
      type(tao_spin_polarization_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_spin_polarization_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_spin_polarization_struct), pointer :: fptr
      type(tao_spin_polarization_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_spin_polarization_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_polarization_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_spin_polarization_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_spin_polarization_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_spin_polarization_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_spin_polarization_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_spin_polarization_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_spin_polarization_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_spin_polarization_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_spin_polarization_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_spin_polarization_struct%tune: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_tune(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tune
  end subroutine


  subroutine tao_spin_polarization_struct_set_tune(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tune = value_in
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_st: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_st(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_pol_limit_st')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pol_limit_st
  end subroutine


  subroutine tao_spin_polarization_struct_set_pol_limit_st(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_pol_limit_st')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pol_limit_st = value_in
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_dk: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_dk(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_pol_limit_dk')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pol_limit_dk
  end subroutine


  subroutine tao_spin_polarization_struct_set_pol_limit_dk(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_pol_limit_dk')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pol_limit_dk = value_in
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_dk_partial: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_dk_partial_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_pol_limit_dk_partial_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%pol_limit_dk_partial)) then
      data_ptr = c_loc(struct_obj%pol_limit_dk_partial(lbound(struct_obj%pol_limit_dk_partial, 1)))
      bounds(1) = int(lbound(struct_obj%pol_limit_dk_partial, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pol_limit_dk_partial, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_dk_partial2: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_dk_partial2_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_pol_limit_dk_partial2_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%pol_limit_dk_partial2)) then
      data_ptr = c_loc(struct_obj%pol_limit_dk_partial2(lbound(struct_obj%pol_limit_dk_partial2, 1)))
      bounds(1) = int(lbound(struct_obj%pol_limit_dk_partial2, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pol_limit_dk_partial2, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%pol_rate_bks: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_rate_bks(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_pol_rate_bks')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pol_rate_bks
  end subroutine


  subroutine tao_spin_polarization_struct_set_pol_rate_bks(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_pol_rate_bks')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pol_rate_bks = value_in
  end subroutine

  ! tao_spin_polarization_struct%depol_rate: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_depol_rate(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_depol_rate')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%depol_rate
  end subroutine


  subroutine tao_spin_polarization_struct_set_depol_rate(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_depol_rate')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%depol_rate = value_in
  end subroutine

  ! tao_spin_polarization_struct%depol_rate_partial: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_depol_rate_partial_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_depol_rate_partial_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%depol_rate_partial)) then
      data_ptr = c_loc(struct_obj%depol_rate_partial(lbound(struct_obj%depol_rate_partial, 1)))
      bounds(1) = int(lbound(struct_obj%depol_rate_partial, 1), c_int)
      bounds(2) = int(ubound(struct_obj%depol_rate_partial, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%depol_rate_partial2: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_depol_rate_partial2_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_depol_rate_partial2_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%depol_rate_partial2)) then
      data_ptr = c_loc(struct_obj%depol_rate_partial2(lbound(struct_obj%depol_rate_partial2, 1)))
      bounds(1) = int(lbound(struct_obj%depol_rate_partial2, 1), c_int)
      bounds(2) = int(ubound(struct_obj%depol_rate_partial2, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%integral_bn: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_bn(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_bn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_bn
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_bn(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_bn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_bn = value_in
  end subroutine

  ! tao_spin_polarization_struct%integral_bdn: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_bdn(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_bdn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_bdn
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_bdn(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_bdn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_bdn = value_in
  end subroutine

  ! tao_spin_polarization_struct%integral_1ns: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_1ns(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_1ns')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_1ns
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_1ns(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_1ns')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_1ns = value_in
  end subroutine

  ! tao_spin_polarization_struct%integral_dn2: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_dn2(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_dn2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_dn2
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_dn2(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_dn2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_dn2 = value_in
  end subroutine

  ! tao_spin_polarization_struct%valid: 0D_NOT_logical

  subroutine tao_spin_polarization_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_spin_polarization_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  ! tao_spin_polarization_struct%q_1turn: 0D_NOT_type

  subroutine tao_spin_polarization_struct_get_q_1turn(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_polarization_struct_get_q_1turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%q_1turn)
  end subroutine


  subroutine tao_spin_polarization_struct_set_q_1turn(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_polarization_struct_set_q_1turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_polarization_struct), pointer :: struct_obj
    type(spin_orbit_map1_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%q_1turn = src_obj
  end subroutine

  ! tao_spin_polarization_struct%q_ele: 1D_ALLOC_type

  subroutine tao_spin_polarization_struct_get_q_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_spin_polarization_struct_get_q_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%q_ele) .and. is_contiguous(struct_obj%q_ele)) then
      data_ptr = c_loc(struct_obj%q_ele(lbound(struct_obj%q_ele, 1)))
      bounds(1) = int(lbound(struct_obj%q_ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%q_ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%q_ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_lattice_branch_struct

    function allocate_fortran_tao_lattice_branch_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_lattice_branch_struct), pointer :: fptr
      type(tao_lattice_branch_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_lattice_branch_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_lattice_branch_struct), pointer :: fptr
      type(tao_lattice_branch_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_lattice_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_lattice_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_lattice_branch_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_lattice_branch_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_lattice_branch_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_lattice_branch_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_lattice_branch_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_lattice_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_lattice_branch_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_lattice_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_lattice_branch_struct%tao_lat: 0D_PTR_type

  subroutine tao_lattice_branch_struct_get_tao_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_tao_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%tao_lat)) then
      ptr_out = c_loc(struct_obj%tao_lat)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_lattice_branch_struct_set_tao_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_tao_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%tao_lat)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%tao_lat = src_obj
    endif
  end subroutine

  ! tao_lattice_branch_struct%lat_sigma: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_lat_sigma_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_lat_sigma_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%lat_sigma) .and. is_contiguous(struct_obj%lat_sigma)) then
      data_ptr = c_loc(struct_obj%lat_sigma(lbound(struct_obj%lat_sigma, 1)))
      bounds(1) = int(lbound(struct_obj%lat_sigma, 1), c_int)
      bounds(2) = int(ubound(struct_obj%lat_sigma, 1), c_int)
      
      el_size = int(storage_size(struct_obj%lat_sigma(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%spin_ele: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_spin_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_spin_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%spin_ele) .and. is_contiguous(struct_obj%spin_ele)) then
      data_ptr = c_loc(struct_obj%spin_ele(lbound(struct_obj%spin_ele, 1)))
      bounds(1) = int(lbound(struct_obj%spin_ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%spin_ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%bunch_params: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_bunch_params_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_bunch_params_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%bunch_params) .and. is_contiguous(struct_obj%bunch_params)) then
      data_ptr = c_loc(struct_obj%bunch_params(lbound(struct_obj%bunch_params, 1)))
      bounds(1) = int(lbound(struct_obj%bunch_params, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch_params, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch_params(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%bunch_params_comb: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_bunch_params_comb_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_bunch_params_comb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%bunch_params_comb) .and. is_contiguous(struct_obj%bunch_params_comb)) then
      data_ptr = c_loc(struct_obj%bunch_params_comb(lbound(struct_obj%bunch_params_comb, 1)))
      bounds(1) = int(lbound(struct_obj%bunch_params_comb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch_params_comb, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch_params_comb(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%orbit: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%orbit) .and. is_contiguous(struct_obj%orbit)) then
      data_ptr = c_loc(struct_obj%orbit(lbound(struct_obj%orbit, 1)))
      bounds(1) = int(lbound(struct_obj%orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit, 1), c_int)
      
      el_size = int(storage_size(struct_obj%orbit(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%plot_cache: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_plot_cache_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_plot_cache_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%plot_cache) .and. is_contiguous(struct_obj%plot_cache)) then
      data_ptr = c_loc(struct_obj%plot_cache(lbound(struct_obj%plot_cache, 1)))
      bounds(1) = int(lbound(struct_obj%plot_cache, 1), c_int)
      bounds(2) = int(ubound(struct_obj%plot_cache, 1), c_int)
      
      el_size = int(storage_size(struct_obj%plot_cache(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%spin: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_spin(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_spin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spin)
  end subroutine


  subroutine tao_lattice_branch_struct_set_spin(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_spin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(tao_spin_polarization_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spin = src_obj
  end subroutine

  ! tao_lattice_branch_struct%srdt: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_srdt(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_srdt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%srdt)
  end subroutine


  subroutine tao_lattice_branch_struct_set_srdt(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_srdt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(summation_rdt_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%srdt = src_obj
  end subroutine

  ! tao_lattice_branch_struct%orb0: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_orb0(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_orb0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orb0)
  end subroutine


  subroutine tao_lattice_branch_struct_set_orb0(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_orb0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orb0 = src_obj
  end subroutine

  ! tao_lattice_branch_struct%modes_ri: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_modes_ri(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_modes_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%modes_ri)
  end subroutine


  subroutine tao_lattice_branch_struct_set_modes_ri(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_modes_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(normal_modes_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%modes_ri = src_obj
  end subroutine

  ! tao_lattice_branch_struct%modes_6d: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_modes_6d(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_modes_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%modes_6d)
  end subroutine


  subroutine tao_lattice_branch_struct_set_modes_6d(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_modes_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(normal_modes_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%modes_6d = src_obj
  end subroutine

  ! tao_lattice_branch_struct%ptc_normal_form: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_ptc_normal_form(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_ptc_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ptc_normal_form)
  end subroutine


  subroutine tao_lattice_branch_struct_set_ptc_normal_form(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_ptc_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(ptc_normal_form_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ptc_normal_form = src_obj
  end subroutine

  ! tao_lattice_branch_struct%bmad_normal_form: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_bmad_normal_form(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_bmad_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%bmad_normal_form)
  end subroutine


  subroutine tao_lattice_branch_struct_set_bmad_normal_form(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_bmad_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(bmad_normal_form_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%bmad_normal_form = src_obj
  end subroutine

  ! tao_lattice_branch_struct%high_E_orb: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_high_E_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_high_E_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%high_E_orb) .and. is_contiguous(struct_obj%high_E_orb)) then
      data_ptr = c_loc(struct_obj%high_E_orb(lbound(struct_obj%high_E_orb, 1)))
      bounds(1) = int(lbound(struct_obj%high_E_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%high_E_orb, 1), c_int)
      
      el_size = int(storage_size(struct_obj%high_E_orb(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%low_E_orb: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_low_E_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_low_E_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%low_E_orb) .and. is_contiguous(struct_obj%low_E_orb)) then
      data_ptr = c_loc(struct_obj%low_E_orb(lbound(struct_obj%low_E_orb, 1)))
      bounds(1) = int(lbound(struct_obj%low_E_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%low_E_orb, 1), c_int)
      
      el_size = int(storage_size(struct_obj%low_E_orb(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%taylor_save: 1D_NOT_type

  subroutine tao_lattice_branch_struct_get_taylor_save_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_taylor_save_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%taylor_save)) then
      data_ptr = c_loc(struct_obj%taylor_save(lbound(struct_obj%taylor_save, 1)))
      bounds(1) = int(lbound(struct_obj%taylor_save, 1), c_int)
      bounds(2) = int(ubound(struct_obj%taylor_save, 1), c_int)
      
      el_size = int(storage_size(struct_obj%taylor_save(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%cache_x_min: 0D_NOT_real

  subroutine tao_lattice_branch_struct_get_cache_x_min(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_cache_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cache_x_min
  end subroutine


  subroutine tao_lattice_branch_struct_set_cache_x_min(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_cache_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cache_x_min = value_in
  end subroutine

  ! tao_lattice_branch_struct%cache_x_max: 0D_NOT_real

  subroutine tao_lattice_branch_struct_get_cache_x_max(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_cache_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cache_x_max
  end subroutine


  subroutine tao_lattice_branch_struct_set_cache_x_max(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_cache_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cache_x_max = value_in
  end subroutine

  ! tao_lattice_branch_struct%comb_ds_save: 0D_NOT_real

  subroutine tao_lattice_branch_struct_get_comb_ds_save(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_comb_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%comb_ds_save
  end subroutine


  subroutine tao_lattice_branch_struct_set_comb_ds_save(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_comb_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%comb_ds_save = value_in
  end subroutine

  ! tao_lattice_branch_struct%ix_ref_taylor: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_ix_ref_taylor(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_ix_ref_taylor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ref_taylor
  end subroutine


  subroutine tao_lattice_branch_struct_set_ix_ref_taylor(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_ix_ref_taylor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ref_taylor = value_in
  end subroutine

  ! tao_lattice_branch_struct%ix_ele_taylor: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_ix_ele_taylor(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_ix_ele_taylor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_taylor
  end subroutine


  subroutine tao_lattice_branch_struct_set_ix_ele_taylor(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_ix_ele_taylor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_taylor = value_in
  end subroutine

  ! tao_lattice_branch_struct%track_state: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_track_state(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_track_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%track_state
  end subroutine


  subroutine tao_lattice_branch_struct_set_track_state(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_track_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%track_state = value_in
  end subroutine

  ! tao_lattice_branch_struct%cache_n_pts: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_cache_n_pts(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_cache_n_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cache_n_pts
  end subroutine


  subroutine tao_lattice_branch_struct_set_cache_n_pts(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_cache_n_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cache_n_pts = value_in
  end subroutine

  ! tao_lattice_branch_struct%ix_rad_int_cache: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_ix_rad_int_cache(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_ix_rad_int_cache')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_rad_int_cache
  end subroutine


  subroutine tao_lattice_branch_struct_set_ix_rad_int_cache(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_ix_rad_int_cache')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_rad_int_cache = value_in
  end subroutine

  ! tao_lattice_branch_struct%has_open_match_element: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_has_open_match_element(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_has_open_match_element')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%has_open_match_element
  end subroutine


  subroutine tao_lattice_branch_struct_set_has_open_match_element(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_has_open_match_element')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%has_open_match_element = value_in
  end subroutine

  ! tao_lattice_branch_struct%plot_cache_valid: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_plot_cache_valid(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_plot_cache_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%plot_cache_valid
  end subroutine


  subroutine tao_lattice_branch_struct_set_plot_cache_valid(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_plot_cache_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%plot_cache_valid = value_in
  end subroutine

  ! tao_lattice_branch_struct%spin_map_valid: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_spin_map_valid(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_spin_map_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_map_valid
  end subroutine


  subroutine tao_lattice_branch_struct_set_spin_map_valid(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_spin_map_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_map_valid = value_in
  end subroutine

  ! tao_lattice_branch_struct%twiss_valid: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_twiss_valid(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%twiss_valid
  end subroutine


  subroutine tao_lattice_branch_struct_set_twiss_valid(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%twiss_valid = value_in
  end subroutine

  ! tao_lattice_branch_struct%mode_flip_here: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_mode_flip_here(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_mode_flip_here')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mode_flip_here
  end subroutine


  subroutine tao_lattice_branch_struct_set_mode_flip_here(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_mode_flip_here')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mode_flip_here = value_in
  end subroutine

  ! tao_lattice_branch_struct%chrom_calc_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_chrom_calc_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_chrom_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom_calc_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_chrom_calc_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_chrom_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom_calc_ok = value_in
  end subroutine

  ! tao_lattice_branch_struct%rad_int_calc_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_rad_int_calc_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_rad_int_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_calc_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_rad_int_calc_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_rad_int_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_calc_ok = value_in
  end subroutine

  ! tao_lattice_branch_struct%emit_6d_calc_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_emit_6d_calc_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_emit_6d_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emit_6d_calc_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_emit_6d_calc_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_emit_6d_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emit_6d_calc_ok = value_in
  end subroutine

  ! tao_lattice_branch_struct%sigma_track_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_sigma_track_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_sigma_track_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_track_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_sigma_track_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_sigma_track_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_track_ok = value_in
  end subroutine

  !! tao_model_element_struct

    function allocate_fortran_tao_model_element_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_model_element_struct), pointer :: fptr
      type(tao_model_element_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_model_element_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_model_element_struct), pointer :: fptr
      type(tao_model_element_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_model_element_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_model_element_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_model_element_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_model_element_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_model_element_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_model_element_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_model_element_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_model_element_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_model_element_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_model_element_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_model_element_struct%beam: 0D_NOT_type

  subroutine tao_model_element_struct_get_beam(struct_obj_ptr, ptr_out) bind(c, name='tao_model_element_struct_get_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam)
  end subroutine


  subroutine tao_model_element_struct_set_beam(struct_obj_ptr, src_ptr) bind(c, name='tao_model_element_struct_set_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_model_element_struct), pointer :: struct_obj
    type(beam_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam = src_obj
  end subroutine

  ! tao_model_element_struct%save_beam_internally: 0D_NOT_logical

  subroutine tao_model_element_struct_get_save_beam_internally(struct_obj_ptr, value_out) bind(c, name='tao_model_element_struct_get_save_beam_internally')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%save_beam_internally
  end subroutine


  subroutine tao_model_element_struct_set_save_beam_internally(struct_obj_ptr, value_in) bind(c, name='tao_model_element_struct_set_save_beam_internally')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%save_beam_internally = value_in
  end subroutine

  ! tao_model_element_struct%save_beam_to_file: 0D_NOT_logical

  subroutine tao_model_element_struct_get_save_beam_to_file(struct_obj_ptr, value_out) bind(c, name='tao_model_element_struct_get_save_beam_to_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%save_beam_to_file
  end subroutine


  subroutine tao_model_element_struct_set_save_beam_to_file(struct_obj_ptr, value_in) bind(c, name='tao_model_element_struct_set_save_beam_to_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%save_beam_to_file = value_in
  end subroutine

  !! tao_beam_branch_struct

    function allocate_fortran_tao_beam_branch_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_beam_branch_struct), pointer :: fptr
      type(tao_beam_branch_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_beam_branch_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_beam_branch_struct), pointer :: fptr
      type(tao_beam_branch_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_beam_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_beam_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_beam_branch_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_beam_branch_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_beam_branch_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_beam_branch_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_beam_branch_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_beam_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_beam_branch_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_beam_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_beam_branch_struct%beam_at_start: 0D_NOT_type

  subroutine tao_beam_branch_struct_get_beam_at_start(struct_obj_ptr, ptr_out) bind(c, name='tao_beam_branch_struct_get_beam_at_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_at_start)
  end subroutine


  subroutine tao_beam_branch_struct_set_beam_at_start(struct_obj_ptr, src_ptr) bind(c, name='tao_beam_branch_struct_set_beam_at_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_beam_branch_struct), pointer :: struct_obj
    type(beam_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_at_start = src_obj
  end subroutine

  ! tao_beam_branch_struct%beam_init: 0D_NOT_type

  subroutine tao_beam_branch_struct_get_beam_init(struct_obj_ptr, ptr_out) bind(c, name='tao_beam_branch_struct_get_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init)
  end subroutine


  subroutine tao_beam_branch_struct_set_beam_init(struct_obj_ptr, src_ptr) bind(c, name='tao_beam_branch_struct_set_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_beam_branch_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init = src_obj
  end subroutine

  ! tao_beam_branch_struct%beam_init_used: 0D_NOT_type

  subroutine tao_beam_branch_struct_get_beam_init_used(struct_obj_ptr, ptr_out) bind(c, name='tao_beam_branch_struct_get_beam_init_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init_used)
  end subroutine


  subroutine tao_beam_branch_struct_set_beam_init_used(struct_obj_ptr, src_ptr) bind(c, name='tao_beam_branch_struct_set_beam_init_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_beam_branch_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init_used = src_obj
  end subroutine

  ! tao_beam_branch_struct%init_starting_distribution: 0D_NOT_logical

  subroutine tao_beam_branch_struct_get_init_starting_distribution(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_init_starting_distribution')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_starting_distribution
  end subroutine


  subroutine tao_beam_branch_struct_set_init_starting_distribution(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_init_starting_distribution')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_starting_distribution = value_in
  end subroutine

  ! tao_beam_branch_struct%track_start: 0D_NOT_character

  subroutine tao_beam_branch_struct_get_track_start_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_branch_struct_get_track_start_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%track_start)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%track_start), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_branch_struct_set_track_start(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_branch_struct_set_track_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_branch_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%track_start = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_branch_struct%track_end: 0D_NOT_character

  subroutine tao_beam_branch_struct_get_track_end_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_branch_struct_get_track_end_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%track_end)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%track_end), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_branch_struct_set_track_end(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_branch_struct_set_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_branch_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%track_end = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_branch_struct%ix_branch: 0D_NOT_integer

  subroutine tao_beam_branch_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_beam_branch_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_beam_branch_struct%ix_track_start: 0D_NOT_integer

  subroutine tao_beam_branch_struct_get_ix_track_start(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_ix_track_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_track_start
  end subroutine


  subroutine tao_beam_branch_struct_set_ix_track_start(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_ix_track_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_track_start = value_in
  end subroutine

  ! tao_beam_branch_struct%ix_track_end: 0D_NOT_integer

  subroutine tao_beam_branch_struct_get_ix_track_end(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_ix_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_track_end
  end subroutine


  subroutine tao_beam_branch_struct_set_ix_track_end(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_ix_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_track_end = value_in
  end subroutine

  !! tao_d1_data_struct

    function allocate_fortran_tao_d1_data_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_d1_data_struct), pointer :: fptr
      type(tao_d1_data_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_d1_data_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_d1_data_struct), pointer :: fptr
      type(tao_d1_data_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_d1_data_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_d1_data_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_d1_data_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_d1_data_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_d1_data_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_d1_data_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_d1_data_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_d1_data_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_d1_data_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_d1_data_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_d1_data_struct%name: 0D_NOT_character

  subroutine tao_d1_data_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d1_data_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d1_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d1_data_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d1_data_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d1_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d1_data_struct%d2: 0D_PTR_type

  subroutine tao_d1_data_struct_get_d2(struct_obj_ptr, ptr_out) bind(c, name='tao_d1_data_struct_get_d2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_d1_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d2)) then
      ptr_out = c_loc(struct_obj%d2)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_d1_data_struct_set_d2(struct_obj_ptr, src_ptr) bind(c, name='tao_d1_data_struct_set_d2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_d1_data_struct), pointer :: struct_obj
    type(tao_d2_data_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d2)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%d2 = src_obj
    endif
  end subroutine

  ! tao_d1_data_struct%d: 1D_PTR_type

  subroutine tao_d1_data_struct_get_d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_d1_data_struct_get_d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d1_data_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%d) .and. is_contiguous(struct_obj%d)) then
      data_ptr = c_loc(struct_obj%d(lbound(struct_obj%d, 1)))
      bounds(1) = int(lbound(struct_obj%d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_d2_data_struct

    function allocate_fortran_tao_d2_data_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_d2_data_struct), pointer :: fptr
      type(tao_d2_data_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_d2_data_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_d2_data_struct), pointer :: fptr
      type(tao_d2_data_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_d2_data_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_d2_data_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_d2_data_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_d2_data_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_d2_data_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_d2_data_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_d2_data_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_d2_data_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_d2_data_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_d2_data_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_d2_data_struct%name: 0D_NOT_character

  subroutine tao_d2_data_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%data_file_name: 0D_NOT_character

  subroutine tao_d2_data_struct_get_data_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_data_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_data_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_data_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_file_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%ref_file_name: 0D_NOT_character

  subroutine tao_d2_data_struct_get_ref_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_ref_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ref_file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ref_file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_ref_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_ref_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ref_file_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%data_date: 0D_NOT_character

  subroutine tao_d2_data_struct_get_data_date_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_data_date_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_date)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_date), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_data_date(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_data_date')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_date = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%ref_date: 0D_NOT_character

  subroutine tao_d2_data_struct_get_ref_date_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_ref_date_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ref_date)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ref_date), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_ref_date(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_ref_date')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ref_date = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%descrip: 1D_NOT_character

  subroutine tao_d2_data_struct_get_descrip_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='tao_d2_data_struct_get_descrip_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true.) then
      data_ptr = c_loc(struct_obj%descrip(lbound(struct_obj%descrip, 1)))
      bounds(1) = int(lbound(struct_obj%descrip, 1), c_int)
      bounds(2) = int(ubound(struct_obj%descrip, 1), c_int)
      str_len = int(len(struct_obj%descrip), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_d2_data_struct%d1: 1D_ALLOC_type

  subroutine tao_d2_data_struct_get_d1_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_d2_data_struct_get_d1_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%d1) .and. is_contiguous(struct_obj%d1)) then
      data_ptr = c_loc(struct_obj%d1(lbound(struct_obj%d1, 1)))
      bounds(1) = int(lbound(struct_obj%d1, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d1, 1), c_int)
      
      el_size = int(storage_size(struct_obj%d1(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_d2_data_struct%ix_universe: 0D_NOT_integer

  subroutine tao_d2_data_struct_get_ix_universe(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_universe
  end subroutine


  subroutine tao_d2_data_struct_set_ix_universe(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_universe = value_in
  end subroutine

  ! tao_d2_data_struct%ix_d2_data: 0D_NOT_integer

  subroutine tao_d2_data_struct_get_ix_d2_data(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ix_d2_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_d2_data
  end subroutine


  subroutine tao_d2_data_struct_set_ix_d2_data(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ix_d2_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_d2_data = value_in
  end subroutine

  ! tao_d2_data_struct%ix_ref: 0D_NOT_integer

  subroutine tao_d2_data_struct_get_ix_ref(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ref
  end subroutine


  subroutine tao_d2_data_struct_set_ix_ref(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ref = value_in
  end subroutine

  ! tao_d2_data_struct%data_read_in: 0D_NOT_logical

  subroutine tao_d2_data_struct_get_data_read_in(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_data_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%data_read_in
  end subroutine


  subroutine tao_d2_data_struct_set_data_read_in(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_data_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%data_read_in = value_in
  end subroutine

  ! tao_d2_data_struct%ref_read_in: 0D_NOT_logical

  subroutine tao_d2_data_struct_get_ref_read_in(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ref_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_read_in
  end subroutine


  subroutine tao_d2_data_struct_set_ref_read_in(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ref_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_read_in = value_in
  end subroutine

  !! tao_data_var_component_struct

    function allocate_fortran_tao_data_var_component_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_data_var_component_struct), pointer :: fptr
      type(tao_data_var_component_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_data_var_component_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_data_var_component_struct), pointer :: fptr
      type(tao_data_var_component_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_data_var_component_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_data_var_component_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_data_var_component_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_data_var_component_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_data_var_component_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_data_var_component_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_data_var_component_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_data_var_component_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_data_var_component_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_data_var_component_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_data_var_component_struct%name: 0D_NOT_character

  subroutine tao_data_var_component_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_var_component_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_var_component_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_var_component_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_var_component_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_var_component_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_var_component_struct%sign: 0D_NOT_real

  subroutine tao_data_var_component_struct_get_sign(struct_obj_ptr, value_out) bind(c, name='tao_data_var_component_struct_get_sign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_var_component_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sign
  end subroutine


  subroutine tao_data_var_component_struct_set_sign(struct_obj_ptr, value_in) bind(c, name='tao_data_var_component_struct_set_sign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_var_component_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sign = value_in
  end subroutine

  !! tao_graph_struct

    function allocate_fortran_tao_graph_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_graph_struct), pointer :: fptr
      type(tao_graph_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_graph_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_graph_struct), pointer :: fptr
      type(tao_graph_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_graph_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_graph_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_graph_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_graph_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_graph_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_graph_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_graph_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_graph_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_graph_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_graph_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_graph_struct%name: 0D_NOT_character

  subroutine tao_graph_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_graph_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_graph_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_graph_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_graph_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_graph_struct%type: 0D_NOT_character

  subroutine tao_graph_struct_get_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_graph_struct_get_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_graph_struct_set_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_graph_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_graph_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%type = str_in ! implicitly handles padding
  end subroutine

  ! tao_graph_struct%title: 0D_NOT_character

  subroutine tao_graph_struct_get_title_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_graph_struct_get_title_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%title)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%title), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_graph_struct_set_title(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_graph_struct_set_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_graph_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%title = str_in ! implicitly handles padding
  end subroutine

  ! tao_graph_struct%title_suffix: 0D_NOT_character

  subroutine tao_graph_struct_get_title_suffix_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_graph_struct_get_title_suffix_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%title_suffix)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%title_suffix), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_graph_struct_set_title_suffix(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_graph_struct_set_title_suffix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_graph_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%title_suffix = str_in ! implicitly handles padding
  end subroutine

  ! tao_graph_struct%text_legend: 1D_NOT_character

  subroutine tao_graph_struct_get_text_legend_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='tao_graph_struct_get_text_legend_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true.) then
      data_ptr = c_loc(struct_obj%text_legend(lbound(struct_obj%text_legend, 1)))
      bounds(1) = int(lbound(struct_obj%text_legend, 1), c_int)
      bounds(2) = int(ubound(struct_obj%text_legend, 1), c_int)
      str_len = int(len(struct_obj%text_legend), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_graph_struct%text_legend_out: 1D_NOT_character

  subroutine tao_graph_struct_get_text_legend_out_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='tao_graph_struct_get_text_legend_out_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true.) then
      data_ptr = c_loc(struct_obj%text_legend_out(lbound(struct_obj%text_legend_out, 1)))
      bounds(1) = int(lbound(struct_obj%text_legend_out, 1), c_int)
      bounds(2) = int(ubound(struct_obj%text_legend_out, 1), c_int)
      str_len = int(len(struct_obj%text_legend_out), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_graph_struct%why_invalid: 0D_NOT_character

  subroutine tao_graph_struct_get_why_invalid_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_graph_struct_get_why_invalid_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%why_invalid)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%why_invalid), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_graph_struct_set_why_invalid(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_graph_struct_set_why_invalid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_graph_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%why_invalid = str_in ! implicitly handles padding
  end subroutine

  ! tao_graph_struct%curve: 1D_ALLOC_type

  subroutine tao_graph_struct_get_curve_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_graph_struct_get_curve_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%curve) .and. is_contiguous(struct_obj%curve)) then
      data_ptr = c_loc(struct_obj%curve(lbound(struct_obj%curve, 1)))
      bounds(1) = int(lbound(struct_obj%curve, 1), c_int)
      bounds(2) = int(ubound(struct_obj%curve, 1), c_int)
      
      el_size = int(storage_size(struct_obj%curve(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_graph_struct%p: 0D_PTR_type

  subroutine tao_graph_struct_get_p(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_p')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%p)) then
      ptr_out = c_loc(struct_obj%p)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_graph_struct_set_p(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_p')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(tao_plot_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%p)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%p = src_obj
    endif
  end subroutine

  ! tao_graph_struct%floor_plan: 0D_NOT_type

  subroutine tao_graph_struct_get_floor_plan(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_floor_plan')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%floor_plan)
  end subroutine


  subroutine tao_graph_struct_set_floor_plan(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_floor_plan')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(tao_floor_plan_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%floor_plan = src_obj
  end subroutine

  ! tao_graph_struct%text_legend_origin: 0D_NOT_type

  subroutine tao_graph_struct_get_text_legend_origin(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_text_legend_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%text_legend_origin)
  end subroutine


  subroutine tao_graph_struct_set_text_legend_origin(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_text_legend_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_point_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%text_legend_origin = src_obj
  end subroutine

  ! tao_graph_struct%curve_legend_origin: 0D_NOT_type

  subroutine tao_graph_struct_get_curve_legend_origin(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_curve_legend_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%curve_legend_origin)
  end subroutine


  subroutine tao_graph_struct_set_curve_legend_origin(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_curve_legend_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_point_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%curve_legend_origin = src_obj
  end subroutine

  ! tao_graph_struct%curve_legend: 0D_NOT_type

  subroutine tao_graph_struct_get_curve_legend(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_curve_legend')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%curve_legend)
  end subroutine


  subroutine tao_graph_struct_set_curve_legend(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_curve_legend')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_legend_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%curve_legend = src_obj
  end subroutine

  ! tao_graph_struct%x: 0D_NOT_type

  subroutine tao_graph_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine tao_graph_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! tao_graph_struct%y: 0D_NOT_type

  subroutine tao_graph_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine tao_graph_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  ! tao_graph_struct%x2: 0D_NOT_type

  subroutine tao_graph_struct_get_x2(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_x2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x2)
  end subroutine


  subroutine tao_graph_struct_set_x2(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_x2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x2 = src_obj
  end subroutine

  ! tao_graph_struct%y2: 0D_NOT_type

  subroutine tao_graph_struct_get_y2(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_y2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y2)
  end subroutine


  subroutine tao_graph_struct_set_y2(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_y2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y2 = src_obj
  end subroutine

  ! tao_graph_struct%margin: 0D_NOT_type

  subroutine tao_graph_struct_get_margin(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_margin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%margin)
  end subroutine


  subroutine tao_graph_struct_set_margin(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_margin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_rect_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%margin = src_obj
  end subroutine

  ! tao_graph_struct%scale_margin: 0D_NOT_type

  subroutine tao_graph_struct_get_scale_margin(struct_obj_ptr, ptr_out) bind(c, name='tao_graph_struct_get_scale_margin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%scale_margin)
  end subroutine


  subroutine tao_graph_struct_set_scale_margin(struct_obj_ptr, src_ptr) bind(c, name='tao_graph_struct_set_scale_margin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_graph_struct), pointer :: struct_obj
    type(qp_rect_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%scale_margin = src_obj
  end subroutine

  ! tao_graph_struct%x_axis_scale_factor: 0D_NOT_real

  subroutine tao_graph_struct_get_x_axis_scale_factor(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_x_axis_scale_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_axis_scale_factor
  end subroutine


  subroutine tao_graph_struct_set_x_axis_scale_factor(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_x_axis_scale_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_axis_scale_factor = value_in
  end subroutine

  ! tao_graph_struct%symbol_size_scale: 0D_NOT_real

  subroutine tao_graph_struct_get_symbol_size_scale(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_symbol_size_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%symbol_size_scale
  end subroutine


  subroutine tao_graph_struct_set_symbol_size_scale(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_symbol_size_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%symbol_size_scale = value_in
  end subroutine

  ! tao_graph_struct%box: 1D_NOT_integer

  subroutine tao_graph_struct_get_box_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_graph_struct_get_box_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_graph_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%box)) then
      data_ptr = c_loc(struct_obj%box(lbound(struct_obj%box, 1)))
      bounds(1) = int(lbound(struct_obj%box, 1), c_int)
      bounds(2) = int(ubound(struct_obj%box, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_graph_struct%ix_branch: 0D_NOT_integer

  subroutine tao_graph_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_graph_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_graph_struct%ix_universe: 0D_NOT_integer

  subroutine tao_graph_struct_get_ix_universe(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_universe
  end subroutine


  subroutine tao_graph_struct_set_ix_universe(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_universe = value_in
  end subroutine

  ! tao_graph_struct%clip: 0D_NOT_logical

  subroutine tao_graph_struct_get_clip(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_clip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%clip
  end subroutine


  subroutine tao_graph_struct_set_clip(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_clip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%clip = value_in
  end subroutine

  ! tao_graph_struct%y2_mirrors_y: 0D_NOT_logical

  subroutine tao_graph_struct_get_y2_mirrors_y(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_y2_mirrors_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y2_mirrors_y
  end subroutine


  subroutine tao_graph_struct_set_y2_mirrors_y(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_y2_mirrors_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y2_mirrors_y = value_in
  end subroutine

  ! tao_graph_struct%limited: 0D_NOT_logical

  subroutine tao_graph_struct_get_limited(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_limited')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%limited
  end subroutine


  subroutine tao_graph_struct_set_limited(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_limited')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%limited = value_in
  end subroutine

  ! tao_graph_struct%draw_axes: 0D_NOT_logical

  subroutine tao_graph_struct_get_draw_axes(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_draw_axes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_axes
  end subroutine


  subroutine tao_graph_struct_set_draw_axes(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_draw_axes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_axes = value_in
  end subroutine

  ! tao_graph_struct%draw_curve_legend: 0D_NOT_logical

  subroutine tao_graph_struct_get_draw_curve_legend(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_draw_curve_legend')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_curve_legend
  end subroutine


  subroutine tao_graph_struct_set_draw_curve_legend(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_draw_curve_legend')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_curve_legend = value_in
  end subroutine

  ! tao_graph_struct%draw_grid: 0D_NOT_logical

  subroutine tao_graph_struct_get_draw_grid(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_draw_grid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_grid
  end subroutine


  subroutine tao_graph_struct_set_draw_grid(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_draw_grid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_grid = value_in
  end subroutine

  ! tao_graph_struct%draw_title: 0D_NOT_logical

  subroutine tao_graph_struct_get_draw_title(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_draw_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_title
  end subroutine


  subroutine tao_graph_struct_set_draw_title(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_draw_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_title = value_in
  end subroutine

  ! tao_graph_struct%draw_only_good_user_data_or_vars: 0D_NOT_logical

  subroutine tao_graph_struct_get_draw_only_good_user_data_or_vars(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_draw_only_good_user_data_or_vars')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_only_good_user_data_or_vars
  end subroutine


  subroutine tao_graph_struct_set_draw_only_good_user_data_or_vars(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_draw_only_good_user_data_or_vars')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_only_good_user_data_or_vars = value_in
  end subroutine

  ! tao_graph_struct%allow_wrap_around: 0D_NOT_logical

  subroutine tao_graph_struct_get_allow_wrap_around(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_allow_wrap_around')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%allow_wrap_around
  end subroutine


  subroutine tao_graph_struct_set_allow_wrap_around(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_allow_wrap_around')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%allow_wrap_around = value_in
  end subroutine

  ! tao_graph_struct%is_valid: 0D_NOT_logical

  subroutine tao_graph_struct_get_is_valid(struct_obj_ptr, value_out) bind(c, name='tao_graph_struct_get_is_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_valid
  end subroutine


  subroutine tao_graph_struct_set_is_valid(struct_obj_ptr, value_in) bind(c, name='tao_graph_struct_set_is_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_graph_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_valid = value_in
  end subroutine

  !! tao_plot_struct

    function allocate_fortran_tao_plot_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_plot_struct), pointer :: fptr
      type(tao_plot_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_plot_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_plot_struct), pointer :: fptr
      type(tao_plot_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_plot_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_plot_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_plot_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_plot_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_plot_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_plot_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_plot_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_plot_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_plot_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_plot_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_plot_struct%name: 0D_NOT_character

  subroutine tao_plot_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_plot_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_plot_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_plot_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_plot_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_plot_struct%description: 0D_NOT_character

  subroutine tao_plot_struct_get_description_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_plot_struct_get_description_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%description)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%description), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_plot_struct_set_description(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_plot_struct_set_description')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_plot_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%description = str_in ! implicitly handles padding
  end subroutine

  ! tao_plot_struct%graph: 1D_ALLOC_type

  subroutine tao_plot_struct_get_graph_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_plot_struct_get_graph_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%graph) .and. is_contiguous(struct_obj%graph)) then
      data_ptr = c_loc(struct_obj%graph(lbound(struct_obj%graph, 1)))
      bounds(1) = int(lbound(struct_obj%graph, 1), c_int)
      bounds(2) = int(ubound(struct_obj%graph, 1), c_int)
      
      el_size = int(storage_size(struct_obj%graph(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_plot_struct%r: 0D_PTR_type

  subroutine tao_plot_struct_get_r(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_struct_get_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%r)) then
      ptr_out = c_loc(struct_obj%r)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_plot_struct_set_r(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_struct_set_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_struct), pointer :: struct_obj
    type(tao_plot_region_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%r)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%r = src_obj
    endif
  end subroutine

  ! tao_plot_struct%ix_plot: 0D_NOT_integer

  subroutine tao_plot_struct_get_ix_plot(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_ix_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_plot
  end subroutine


  subroutine tao_plot_struct_set_ix_plot(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_ix_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_plot = value_in
  end subroutine

  ! tao_plot_struct%n_curve_pts: 0D_NOT_integer

  subroutine tao_plot_struct_get_n_curve_pts(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_n_curve_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_curve_pts
  end subroutine


  subroutine tao_plot_struct_set_n_curve_pts(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_n_curve_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_curve_pts = value_in
  end subroutine

  ! tao_plot_struct%type: 0D_NOT_character

  subroutine tao_plot_struct_get_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_plot_struct_get_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_plot_struct_set_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_plot_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_plot_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%type = str_in ! implicitly handles padding
  end subroutine

  ! tao_plot_struct%x_axis_type: 0D_NOT_character

  subroutine tao_plot_struct_get_x_axis_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_plot_struct_get_x_axis_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%x_axis_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%x_axis_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_plot_struct_set_x_axis_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_plot_struct_set_x_axis_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_plot_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%x_axis_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_plot_struct%autoscale_x: 0D_NOT_logical

  subroutine tao_plot_struct_get_autoscale_x(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_autoscale_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_x
  end subroutine


  subroutine tao_plot_struct_set_autoscale_x(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_autoscale_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_x = value_in
  end subroutine

  ! tao_plot_struct%autoscale_y: 0D_NOT_logical

  subroutine tao_plot_struct_get_autoscale_y(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_autoscale_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_y
  end subroutine


  subroutine tao_plot_struct_set_autoscale_y(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_autoscale_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_y = value_in
  end subroutine

  ! tao_plot_struct%autoscale_gang_x: 0D_NOT_logical

  subroutine tao_plot_struct_get_autoscale_gang_x(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_autoscale_gang_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_gang_x
  end subroutine


  subroutine tao_plot_struct_set_autoscale_gang_x(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_autoscale_gang_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_gang_x = value_in
  end subroutine

  ! tao_plot_struct%autoscale_gang_y: 0D_NOT_logical

  subroutine tao_plot_struct_get_autoscale_gang_y(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_autoscale_gang_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_gang_y
  end subroutine


  subroutine tao_plot_struct_set_autoscale_gang_y(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_autoscale_gang_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_gang_y = value_in
  end subroutine

  ! tao_plot_struct%list_with_show_plot_command: 0D_NOT_logical

  subroutine tao_plot_struct_get_list_with_show_plot_command(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_list_with_show_plot_command')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%list_with_show_plot_command
  end subroutine


  subroutine tao_plot_struct_set_list_with_show_plot_command(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_list_with_show_plot_command')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%list_with_show_plot_command = value_in
  end subroutine

  ! tao_plot_struct%phantom: 0D_NOT_logical

  subroutine tao_plot_struct_get_phantom(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_phantom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phantom
  end subroutine


  subroutine tao_plot_struct_set_phantom(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_phantom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phantom = value_in
  end subroutine

  ! tao_plot_struct%default_plot: 0D_NOT_logical

  subroutine tao_plot_struct_get_default_plot(struct_obj_ptr, value_out) bind(c, name='tao_plot_struct_get_default_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_plot
  end subroutine


  subroutine tao_plot_struct_set_default_plot(struct_obj_ptr, value_in) bind(c, name='tao_plot_struct_set_default_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_plot = value_in
  end subroutine

  !! tao_plot_region_struct

    function allocate_fortran_tao_plot_region_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_plot_region_struct), pointer :: fptr
      type(tao_plot_region_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_plot_region_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_plot_region_struct), pointer :: fptr
      type(tao_plot_region_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_plot_region_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_plot_region_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_plot_region_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_plot_region_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_plot_region_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_plot_region_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_plot_region_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_plot_region_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_plot_region_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_plot_region_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_plot_region_struct%name: 0D_NOT_character

  subroutine tao_plot_region_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_plot_region_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_plot_region_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_plot_region_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_plot_region_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_plot_region_struct%plot: 0D_NOT_type

  subroutine tao_plot_region_struct_get_plot(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_region_struct_get_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%plot)
  end subroutine


  subroutine tao_plot_region_struct_set_plot(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_region_struct_set_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_region_struct), pointer :: struct_obj
    type(tao_plot_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%plot = src_obj
  end subroutine

  ! tao_plot_region_struct%location: 1D_NOT_real

  subroutine tao_plot_region_struct_get_location_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_plot_region_struct_get_location_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_region_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%location)) then
      data_ptr = c_loc(struct_obj%location(lbound(struct_obj%location, 1)))
      bounds(1) = int(lbound(struct_obj%location, 1), c_int)
      bounds(2) = int(ubound(struct_obj%location, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_plot_region_struct%visible: 0D_NOT_logical

  subroutine tao_plot_region_struct_get_visible(struct_obj_ptr, value_out) bind(c, name='tao_plot_region_struct_get_visible')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%visible
  end subroutine


  subroutine tao_plot_region_struct_set_visible(struct_obj_ptr, value_in) bind(c, name='tao_plot_region_struct_set_visible')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%visible = value_in
  end subroutine

  ! tao_plot_region_struct%list_with_show_plot_command: 0D_NOT_logical

  subroutine tao_plot_region_struct_get_list_with_show_plot_command(struct_obj_ptr, value_out) bind(c, name='tao_plot_region_struct_get_list_with_show_plot_command')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%list_with_show_plot_command
  end subroutine


  subroutine tao_plot_region_struct_set_list_with_show_plot_command(struct_obj_ptr, value_in) bind(c, name='tao_plot_region_struct_set_list_with_show_plot_command')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%list_with_show_plot_command = value_in
  end subroutine

  ! tao_plot_region_struct%setup_done: 0D_NOT_logical

  subroutine tao_plot_region_struct_get_setup_done(struct_obj_ptr, value_out) bind(c, name='tao_plot_region_struct_get_setup_done')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%setup_done
  end subroutine


  subroutine tao_plot_region_struct_set_setup_done(struct_obj_ptr, value_in) bind(c, name='tao_plot_region_struct_set_setup_done')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_region_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%setup_done = value_in
  end subroutine

  !! tao_universe_pointer_struct

    function allocate_fortran_tao_universe_pointer_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_universe_pointer_struct), pointer :: fptr
      type(tao_universe_pointer_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_universe_pointer_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_universe_pointer_struct), pointer :: fptr
      type(tao_universe_pointer_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_universe_pointer_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_universe_pointer_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_universe_pointer_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_universe_pointer_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_universe_pointer_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_universe_pointer_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_universe_pointer_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_universe_pointer_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_universe_pointer_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_universe_pointer_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_universe_pointer_struct%u: 0D_PTR_type

  subroutine tao_universe_pointer_struct_get_u(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_pointer_struct_get_u')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_pointer_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%u)) then
      ptr_out = c_loc(struct_obj%u)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_pointer_struct_set_u(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_pointer_struct_set_u')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_pointer_struct), pointer :: struct_obj
    type(tao_universe_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%u)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%u = src_obj
    endif
  end subroutine

  !! tao_super_universe_struct

    function allocate_fortran_tao_super_universe_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_super_universe_struct), pointer :: fptr
      type(tao_super_universe_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_super_universe_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_super_universe_struct), pointer :: fptr
      type(tao_super_universe_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_super_universe_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_super_universe_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_super_universe_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_super_universe_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_super_universe_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_super_universe_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_super_universe_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_super_universe_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_super_universe_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_super_universe_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_super_universe_struct%global: 0D_NOT_type

  subroutine tao_super_universe_struct_get_global(struct_obj_ptr, ptr_out) bind(c, name='tao_super_universe_struct_get_global')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%global)
  end subroutine


  subroutine tao_super_universe_struct_set_global(struct_obj_ptr, src_ptr) bind(c, name='tao_super_universe_struct_set_global')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_super_universe_struct), pointer :: struct_obj
    type(tao_global_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%global = src_obj
  end subroutine

  ! tao_super_universe_struct%init: 0D_NOT_type

  subroutine tao_super_universe_struct_get_init(struct_obj_ptr, ptr_out) bind(c, name='tao_super_universe_struct_get_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%init)
  end subroutine


  subroutine tao_super_universe_struct_set_init(struct_obj_ptr, src_ptr) bind(c, name='tao_super_universe_struct_set_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_super_universe_struct), pointer :: struct_obj
    type(tao_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%init = src_obj
  end subroutine

  ! tao_super_universe_struct%com: 0D_NOT_type

  subroutine tao_super_universe_struct_get_com(struct_obj_ptr, ptr_out) bind(c, name='tao_super_universe_struct_get_com')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%com)
  end subroutine


  subroutine tao_super_universe_struct_set_com(struct_obj_ptr, src_ptr) bind(c, name='tao_super_universe_struct_set_com')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_super_universe_struct), pointer :: struct_obj
    type(tao_common_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%com = src_obj
  end subroutine

  ! tao_super_universe_struct%plot_page: 0D_NOT_type

  subroutine tao_super_universe_struct_get_plot_page(struct_obj_ptr, ptr_out) bind(c, name='tao_super_universe_struct_get_plot_page')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%plot_page)
  end subroutine


  subroutine tao_super_universe_struct_set_plot_page(struct_obj_ptr, src_ptr) bind(c, name='tao_super_universe_struct_set_plot_page')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_super_universe_struct), pointer :: struct_obj
    type(tao_plot_page_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%plot_page = src_obj
  end subroutine

  ! tao_super_universe_struct%v1_var: 1D_ALLOC_type

  subroutine tao_super_universe_struct_get_v1_var_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_super_universe_struct_get_v1_var_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_super_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%v1_var) .and. is_contiguous(struct_obj%v1_var)) then
      data_ptr = c_loc(struct_obj%v1_var(lbound(struct_obj%v1_var, 1)))
      bounds(1) = int(lbound(struct_obj%v1_var, 1), c_int)
      bounds(2) = int(ubound(struct_obj%v1_var, 1), c_int)
      
      el_size = int(storage_size(struct_obj%v1_var(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_super_universe_struct%var: 1D_ALLOC_type

  subroutine tao_super_universe_struct_get_var_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_super_universe_struct_get_var_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_super_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%var) .and. is_contiguous(struct_obj%var)) then
      data_ptr = c_loc(struct_obj%var(lbound(struct_obj%var, 1)))
      bounds(1) = int(lbound(struct_obj%var, 1), c_int)
      bounds(2) = int(ubound(struct_obj%var, 1), c_int)
      
      el_size = int(storage_size(struct_obj%var(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_super_universe_struct%u: 1D_ALLOC_type

  subroutine tao_super_universe_struct_get_u_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_super_universe_struct_get_u_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_super_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%u) .and. is_contiguous(struct_obj%u)) then
      data_ptr = c_loc(struct_obj%u(lbound(struct_obj%u, 1)))
      bounds(1) = int(lbound(struct_obj%u, 1), c_int)
      bounds(2) = int(ubound(struct_obj%u, 1), c_int)
      
      el_size = int(storage_size(struct_obj%u(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_super_universe_struct%key: 1D_ALLOC_integer

  subroutine tao_super_universe_struct_get_key_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_super_universe_struct_get_key_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_super_universe_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%key) .and. is_contiguous(struct_obj%key)) then
      data_ptr = c_loc(struct_obj%key(lbound(struct_obj%key, 1)))
      bounds(1) = int(lbound(struct_obj%key, 1), c_int)
      bounds(2) = int(ubound(struct_obj%key, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_super_universe_struct%building_wall: 0D_NOT_type

  subroutine tao_super_universe_struct_get_building_wall(struct_obj_ptr, ptr_out) bind(c, name='tao_super_universe_struct_get_building_wall')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%building_wall)
  end subroutine


  subroutine tao_super_universe_struct_set_building_wall(struct_obj_ptr, src_ptr) bind(c, name='tao_super_universe_struct_set_building_wall')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_super_universe_struct), pointer :: struct_obj
    type(tao_building_wall_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%building_wall = src_obj
  end subroutine

  ! tao_super_universe_struct%wave: 0D_NOT_type

  subroutine tao_super_universe_struct_get_wave(struct_obj_ptr, ptr_out) bind(c, name='tao_super_universe_struct_get_wave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%wave)
  end subroutine


  subroutine tao_super_universe_struct_set_wave(struct_obj_ptr, src_ptr) bind(c, name='tao_super_universe_struct_set_wave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_super_universe_struct), pointer :: struct_obj
    type(tao_wave_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%wave = src_obj
  end subroutine

  ! tao_super_universe_struct%n_var_used: 0D_NOT_integer

  subroutine tao_super_universe_struct_get_n_var_used(struct_obj_ptr, value_out) bind(c, name='tao_super_universe_struct_get_n_var_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_var_used
  end subroutine


  subroutine tao_super_universe_struct_set_n_var_used(struct_obj_ptr, value_in) bind(c, name='tao_super_universe_struct_set_n_var_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_var_used = value_in
  end subroutine

  ! tao_super_universe_struct%n_v1_var_used: 0D_NOT_integer

  subroutine tao_super_universe_struct_get_n_v1_var_used(struct_obj_ptr, value_out) bind(c, name='tao_super_universe_struct_get_n_v1_var_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_v1_var_used
  end subroutine


  subroutine tao_super_universe_struct_set_n_v1_var_used(struct_obj_ptr, value_in) bind(c, name='tao_super_universe_struct_set_n_v1_var_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_v1_var_used = value_in
  end subroutine

  ! tao_super_universe_struct%history: 1D_NOT_type

  subroutine tao_super_universe_struct_get_history_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_super_universe_struct_get_history_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_super_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%history)) then
      data_ptr = c_loc(struct_obj%history(lbound(struct_obj%history, 1)))
      bounds(1) = int(lbound(struct_obj%history, 1), c_int)
      bounds(2) = int(ubound(struct_obj%history, 1), c_int)
      
      el_size = int(storage_size(struct_obj%history(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_super_universe_struct%initialized: 0D_NOT_logical

  subroutine tao_super_universe_struct_get_initialized(struct_obj_ptr, value_out) bind(c, name='tao_super_universe_struct_get_initialized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%initialized
  end subroutine


  subroutine tao_super_universe_struct_set_initialized(struct_obj_ptr, value_in) bind(c, name='tao_super_universe_struct_set_initialized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_super_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%initialized = value_in
  end subroutine

  !! tao_var_struct

    function allocate_fortran_tao_var_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_var_struct), pointer :: fptr
      type(tao_var_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_var_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_var_struct), pointer :: fptr
      type(tao_var_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_var_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_var_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_var_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_var_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_var_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_var_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_var_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_var_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_var_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_var_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_var_struct%ele_name: 0D_NOT_character

  subroutine tao_var_struct_get_ele_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_var_struct_get_ele_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_var_struct_set_ele_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_var_struct_set_ele_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_var_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_var_struct%attrib_name: 0D_NOT_character

  subroutine tao_var_struct_get_attrib_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_var_struct_get_attrib_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%attrib_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%attrib_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_var_struct_set_attrib_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_var_struct_set_attrib_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_var_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%attrib_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_var_struct%id: 0D_NOT_character

  subroutine tao_var_struct_get_id_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_var_struct_get_id_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%id)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%id), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_var_struct_set_id(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_var_struct_set_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_var_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%id = str_in ! implicitly handles padding
  end subroutine

  ! tao_var_struct%slave: 1D_ALLOC_type

  subroutine tao_var_struct_get_slave_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_var_struct_get_slave_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_var_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%slave) .and. is_contiguous(struct_obj%slave)) then
      data_ptr = c_loc(struct_obj%slave(lbound(struct_obj%slave, 1)))
      bounds(1) = int(lbound(struct_obj%slave, 1), c_int)
      bounds(2) = int(ubound(struct_obj%slave, 1), c_int)
      
      el_size = int(storage_size(struct_obj%slave(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_var_struct%ix_v1: 0D_NOT_integer

  subroutine tao_var_struct_get_ix_v1(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_ix_v1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_v1
  end subroutine


  subroutine tao_var_struct_set_ix_v1(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_ix_v1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_v1 = value_in
  end subroutine

  ! tao_var_struct%ix_var: 0D_NOT_integer

  subroutine tao_var_struct_get_ix_var(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_ix_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_var
  end subroutine


  subroutine tao_var_struct_set_ix_var(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_ix_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_var = value_in
  end subroutine

  ! tao_var_struct%ix_dvar: 0D_NOT_integer

  subroutine tao_var_struct_get_ix_dvar(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_ix_dvar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_dvar
  end subroutine


  subroutine tao_var_struct_set_ix_dvar(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_ix_dvar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_dvar = value_in
  end subroutine

  ! tao_var_struct%ix_attrib: 0D_NOT_integer

  subroutine tao_var_struct_get_ix_attrib(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_ix_attrib')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_attrib
  end subroutine


  subroutine tao_var_struct_set_ix_attrib(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_ix_attrib')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_attrib = value_in
  end subroutine

  ! tao_var_struct%ix_key_table: 0D_NOT_integer

  subroutine tao_var_struct_get_ix_key_table(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_ix_key_table')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_key_table
  end subroutine


  subroutine tao_var_struct_set_ix_key_table(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_ix_key_table')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_key_table = value_in
  end subroutine

  ! tao_var_struct%model_value: 0D_PTR_real

  subroutine tao_var_struct_get_model_value(struct_obj_ptr, ptr_out) bind(c, name='tao_var_struct_get_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model_value)) then
      ptr_out = c_loc(struct_obj%model_value)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_var_struct_set_model_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model_value)) then
      struct_obj%model_value = value_in
    endif
  end subroutine

  ! tao_var_struct%base_value: 0D_PTR_real

  subroutine tao_var_struct_get_base_value(struct_obj_ptr, ptr_out) bind(c, name='tao_var_struct_get_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base_value)) then
      ptr_out = c_loc(struct_obj%base_value)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_var_struct_set_base_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base_value)) then
      struct_obj%base_value = value_in
    endif
  end subroutine

  ! tao_var_struct%design_value: 0D_NOT_real

  subroutine tao_var_struct_get_design_value(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_design_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%design_value
  end subroutine


  subroutine tao_var_struct_set_design_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_design_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%design_value = value_in
  end subroutine

  ! tao_var_struct%scratch_value: 0D_NOT_real

  subroutine tao_var_struct_get_scratch_value(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_scratch_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scratch_value
  end subroutine


  subroutine tao_var_struct_set_scratch_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_scratch_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scratch_value = value_in
  end subroutine

  ! tao_var_struct%old_value: 0D_NOT_real

  subroutine tao_var_struct_get_old_value(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%old_value
  end subroutine


  subroutine tao_var_struct_set_old_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%old_value = value_in
  end subroutine

  ! tao_var_struct%meas_value: 0D_NOT_real

  subroutine tao_var_struct_get_meas_value(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_meas_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%meas_value
  end subroutine


  subroutine tao_var_struct_set_meas_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_meas_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%meas_value = value_in
  end subroutine

  ! tao_var_struct%ref_value: 0D_NOT_real

  subroutine tao_var_struct_get_ref_value(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_ref_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_value
  end subroutine


  subroutine tao_var_struct_set_ref_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_ref_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_value = value_in
  end subroutine

  ! tao_var_struct%correction_value: 0D_NOT_real

  subroutine tao_var_struct_get_correction_value(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_correction_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%correction_value
  end subroutine


  subroutine tao_var_struct_set_correction_value(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_correction_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%correction_value = value_in
  end subroutine

  ! tao_var_struct%high_lim: 0D_NOT_real

  subroutine tao_var_struct_get_high_lim(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_high_lim')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%high_lim
  end subroutine


  subroutine tao_var_struct_set_high_lim(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_high_lim')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%high_lim = value_in
  end subroutine

  ! tao_var_struct%low_lim: 0D_NOT_real

  subroutine tao_var_struct_get_low_lim(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_low_lim')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%low_lim
  end subroutine


  subroutine tao_var_struct_set_low_lim(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_low_lim')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%low_lim = value_in
  end subroutine

  ! tao_var_struct%step: 0D_NOT_real

  subroutine tao_var_struct_get_step(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%step
  end subroutine


  subroutine tao_var_struct_set_step(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%step = value_in
  end subroutine

  ! tao_var_struct%weight: 0D_NOT_real

  subroutine tao_var_struct_get_weight(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_weight')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%weight
  end subroutine


  subroutine tao_var_struct_set_weight(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_weight')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%weight = value_in
  end subroutine

  ! tao_var_struct%delta_merit: 0D_NOT_real

  subroutine tao_var_struct_get_delta_merit(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_delta_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%delta_merit
  end subroutine


  subroutine tao_var_struct_set_delta_merit(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_delta_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%delta_merit = value_in
  end subroutine

  ! tao_var_struct%merit: 0D_NOT_real

  subroutine tao_var_struct_get_merit(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%merit
  end subroutine


  subroutine tao_var_struct_set_merit(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%merit = value_in
  end subroutine

  ! tao_var_struct%dMerit_dVar: 0D_NOT_real

  subroutine tao_var_struct_get_dMerit_dVar(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_dMerit_dVar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dMerit_dVar
  end subroutine


  subroutine tao_var_struct_set_dMerit_dVar(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_dMerit_dVar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dMerit_dVar = value_in
  end subroutine

  ! tao_var_struct%key_val0: 0D_NOT_real

  subroutine tao_var_struct_get_key_val0(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_key_val0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%key_val0
  end subroutine


  subroutine tao_var_struct_set_key_val0(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_key_val0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%key_val0 = value_in
  end subroutine

  ! tao_var_struct%key_delta: 0D_NOT_real

  subroutine tao_var_struct_get_key_delta(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_key_delta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%key_delta
  end subroutine


  subroutine tao_var_struct_set_key_delta(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_key_delta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%key_delta = value_in
  end subroutine

  ! tao_var_struct%s: 0D_NOT_real

  subroutine tao_var_struct_get_s(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine tao_var_struct_set_s(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! tao_var_struct%extend_val: 0D_NOT_real

  subroutine tao_var_struct_get_extend_val(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_extend_val')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%extend_val
  end subroutine


  subroutine tao_var_struct_set_extend_val(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_extend_val')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%extend_val = value_in
  end subroutine

  ! tao_var_struct%merit_type: 0D_NOT_character

  subroutine tao_var_struct_get_merit_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_var_struct_get_merit_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%merit_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%merit_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_var_struct_set_merit_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_var_struct_set_merit_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_var_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%merit_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_var_struct%exists: 0D_NOT_logical

  subroutine tao_var_struct_get_exists(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_exists')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%exists
  end subroutine


  subroutine tao_var_struct_set_exists(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_exists')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%exists = value_in
  end subroutine

  ! tao_var_struct%good_var: 0D_NOT_logical

  subroutine tao_var_struct_get_good_var(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_good_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_var
  end subroutine


  subroutine tao_var_struct_set_good_var(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_good_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_var = value_in
  end subroutine

  ! tao_var_struct%good_user: 0D_NOT_logical

  subroutine tao_var_struct_get_good_user(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_good_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_user
  end subroutine


  subroutine tao_var_struct_set_good_user(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_good_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_user = value_in
  end subroutine

  ! tao_var_struct%good_opt: 0D_NOT_logical

  subroutine tao_var_struct_get_good_opt(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_good_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_opt
  end subroutine


  subroutine tao_var_struct_set_good_opt(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_good_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_opt = value_in
  end subroutine

  ! tao_var_struct%good_plot: 0D_NOT_logical

  subroutine tao_var_struct_get_good_plot(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_good_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_plot
  end subroutine


  subroutine tao_var_struct_set_good_plot(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_good_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_plot = value_in
  end subroutine

  ! tao_var_struct%useit_opt: 0D_NOT_logical

  subroutine tao_var_struct_get_useit_opt(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_useit_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%useit_opt
  end subroutine


  subroutine tao_var_struct_set_useit_opt(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_useit_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%useit_opt = value_in
  end subroutine

  ! tao_var_struct%useit_plot: 0D_NOT_logical

  subroutine tao_var_struct_get_useit_plot(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_useit_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%useit_plot
  end subroutine


  subroutine tao_var_struct_set_useit_plot(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_useit_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%useit_plot = value_in
  end subroutine

  ! tao_var_struct%key_bound: 0D_NOT_logical

  subroutine tao_var_struct_get_key_bound(struct_obj_ptr, value_out) bind(c, name='tao_var_struct_get_key_bound')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%key_bound
  end subroutine


  subroutine tao_var_struct_set_key_bound(struct_obj_ptr, value_in) bind(c, name='tao_var_struct_set_key_bound')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%key_bound = value_in
  end subroutine

  ! tao_var_struct%v1: 0D_PTR_type

  subroutine tao_var_struct_get_v1(struct_obj_ptr, ptr_out) bind(c, name='tao_var_struct_get_v1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%v1)) then
      ptr_out = c_loc(struct_obj%v1)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_var_struct_set_v1(struct_obj_ptr, src_ptr) bind(c, name='tao_var_struct_set_v1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_var_struct), pointer :: struct_obj
    type(tao_v1_var_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%v1)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%v1 = src_obj
    endif
  end subroutine

  !! tao_var_slave_struct

    function allocate_fortran_tao_var_slave_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_var_slave_struct), pointer :: fptr
      type(tao_var_slave_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_var_slave_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_var_slave_struct), pointer :: fptr
      type(tao_var_slave_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_var_slave_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_var_slave_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_var_slave_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_var_slave_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_var_slave_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_var_slave_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_var_slave_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_var_slave_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_var_slave_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_var_slave_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_var_slave_struct%ix_uni: 0D_NOT_integer

  subroutine tao_var_slave_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_var_slave_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_var_slave_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_var_slave_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_var_slave_struct%ix_branch: 0D_NOT_integer

  subroutine tao_var_slave_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_var_slave_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_var_slave_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_var_slave_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_var_slave_struct%ix_ele: 0D_NOT_integer

  subroutine tao_var_slave_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='tao_var_slave_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine tao_var_slave_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='tao_var_slave_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! tao_var_slave_struct%model_value: 0D_PTR_real

  subroutine tao_var_slave_struct_get_model_value(struct_obj_ptr, ptr_out) bind(c, name='tao_var_slave_struct_get_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model_value)) then
      ptr_out = c_loc(struct_obj%model_value)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_var_slave_struct_set_model_value(struct_obj_ptr, value_in) bind(c, name='tao_var_slave_struct_set_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model_value)) then
      struct_obj%model_value = value_in
    endif
  end subroutine

  ! tao_var_slave_struct%base_value: 0D_PTR_real

  subroutine tao_var_slave_struct_get_base_value(struct_obj_ptr, ptr_out) bind(c, name='tao_var_slave_struct_get_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base_value)) then
      ptr_out = c_loc(struct_obj%base_value)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_var_slave_struct_set_base_value(struct_obj_ptr, value_in) bind(c, name='tao_var_slave_struct_set_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_var_slave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base_value)) then
      struct_obj%base_value = value_in
    endif
  end subroutine

  !! tao_lattice_struct

    function allocate_fortran_tao_lattice_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_lattice_struct), pointer :: fptr
      type(tao_lattice_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_lattice_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_lattice_struct), pointer :: fptr
      type(tao_lattice_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_lattice_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_lattice_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_lattice_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_lattice_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_lattice_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_lattice_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_lattice_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_lattice_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_lattice_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_lattice_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_lattice_struct%name: 0D_NOT_character

  subroutine tao_lattice_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_lattice_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_lattice_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_lattice_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_lattice_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_lattice_struct%lat: 0D_NOT_type

  subroutine tao_lattice_struct_get_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lat)
  end subroutine


  subroutine tao_lattice_struct_set_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lat = src_obj
  end subroutine

  ! tao_lattice_struct%high_E_lat: 0D_NOT_type

  subroutine tao_lattice_struct_get_high_E_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_high_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%high_E_lat)
  end subroutine


  subroutine tao_lattice_struct_set_high_E_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_high_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%high_E_lat = src_obj
  end subroutine

  ! tao_lattice_struct%low_E_lat: 0D_NOT_type

  subroutine tao_lattice_struct_get_low_E_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_low_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%low_E_lat)
  end subroutine


  subroutine tao_lattice_struct_set_low_E_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_low_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%low_E_lat = src_obj
  end subroutine

  ! tao_lattice_struct%rad_int_by_ele_ri: 0D_NOT_type

  subroutine tao_lattice_struct_get_rad_int_by_ele_ri(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_rad_int_by_ele_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rad_int_by_ele_ri)
  end subroutine


  subroutine tao_lattice_struct_set_rad_int_by_ele_ri(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_rad_int_by_ele_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(rad_int_all_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rad_int_by_ele_ri = src_obj
  end subroutine

  ! tao_lattice_struct%rad_int_by_ele_6d: 0D_NOT_type

  subroutine tao_lattice_struct_get_rad_int_by_ele_6d(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_rad_int_by_ele_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rad_int_by_ele_6d)
  end subroutine


  subroutine tao_lattice_struct_set_rad_int_by_ele_6d(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_rad_int_by_ele_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(rad_int_all_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rad_int_by_ele_6d = src_obj
  end subroutine

  ! tao_lattice_struct%tao_branch: 1D_ALLOC_type

  subroutine tao_lattice_struct_get_tao_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_struct_get_tao_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%tao_branch) .and. is_contiguous(struct_obj%tao_branch)) then
      data_ptr = c_loc(struct_obj%tao_branch(lbound(struct_obj%tao_branch, 1)))
      bounds(1) = int(lbound(struct_obj%tao_branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%tao_branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%tao_branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_beam_uni_struct

    function allocate_fortran_tao_beam_uni_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_beam_uni_struct), pointer :: fptr
      type(tao_beam_uni_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_beam_uni_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_beam_uni_struct), pointer :: fptr
      type(tao_beam_uni_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_beam_uni_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_beam_uni_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_beam_uni_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_beam_uni_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_beam_uni_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_beam_uni_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_beam_uni_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_beam_uni_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_beam_uni_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_beam_uni_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_beam_uni_struct%saved_at: 0D_NOT_character

  subroutine tao_beam_uni_struct_get_saved_at_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_uni_struct_get_saved_at_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%saved_at)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%saved_at), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_uni_struct_set_saved_at(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_uni_struct_set_saved_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_uni_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%saved_at = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_uni_struct%dump_file: 0D_NOT_character

  subroutine tao_beam_uni_struct_get_dump_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_uni_struct_get_dump_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%dump_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%dump_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_uni_struct_set_dump_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_uni_struct_set_dump_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_uni_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%dump_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_uni_struct%dump_at: 0D_NOT_character

  subroutine tao_beam_uni_struct_get_dump_at_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_uni_struct_get_dump_at_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%dump_at)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%dump_at), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_uni_struct_set_dump_at(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_uni_struct_set_dump_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_uni_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%dump_at = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_uni_struct%track_beam_in_universe: 0D_NOT_logical

  subroutine tao_beam_uni_struct_get_track_beam_in_universe(struct_obj_ptr, value_out) bind(c, name='tao_beam_uni_struct_get_track_beam_in_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%track_beam_in_universe
  end subroutine


  subroutine tao_beam_uni_struct_set_track_beam_in_universe(struct_obj_ptr, value_in) bind(c, name='tao_beam_uni_struct_set_track_beam_in_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%track_beam_in_universe = value_in
  end subroutine

  ! tao_beam_uni_struct%always_reinit: 0D_NOT_logical

  subroutine tao_beam_uni_struct_get_always_reinit(struct_obj_ptr, value_out) bind(c, name='tao_beam_uni_struct_get_always_reinit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%always_reinit
  end subroutine


  subroutine tao_beam_uni_struct_set_always_reinit(struct_obj_ptr, value_in) bind(c, name='tao_beam_uni_struct_set_always_reinit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%always_reinit = value_in
  end subroutine

  !! tao_dynamic_aperture_struct

    function allocate_fortran_tao_dynamic_aperture_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_dynamic_aperture_struct), pointer :: fptr
      type(tao_dynamic_aperture_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_dynamic_aperture_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_dynamic_aperture_struct), pointer :: fptr
      type(tao_dynamic_aperture_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_dynamic_aperture_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_dynamic_aperture_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_dynamic_aperture_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_dynamic_aperture_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_dynamic_aperture_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_dynamic_aperture_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_dynamic_aperture_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_dynamic_aperture_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_dynamic_aperture_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_dynamic_aperture_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_dynamic_aperture_struct%param: 0D_NOT_type

  subroutine tao_dynamic_aperture_struct_get_param(struct_obj_ptr, ptr_out) bind(c, name='tao_dynamic_aperture_struct_get_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%param)
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_param(struct_obj_ptr, src_ptr) bind(c, name='tao_dynamic_aperture_struct_set_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    type(aperture_param_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%param = src_obj
  end subroutine

  ! tao_dynamic_aperture_struct%scan: 1D_ALLOC_type

  subroutine tao_dynamic_aperture_struct_get_scan_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_dynamic_aperture_struct_get_scan_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%scan) .and. is_contiguous(struct_obj%scan)) then
      data_ptr = c_loc(struct_obj%scan(lbound(struct_obj%scan, 1)))
      bounds(1) = int(lbound(struct_obj%scan, 1), c_int)
      bounds(2) = int(ubound(struct_obj%scan, 1), c_int)
      
      el_size = int(storage_size(struct_obj%scan(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_dynamic_aperture_struct%pz: 1D_ALLOC_real

  subroutine tao_dynamic_aperture_struct_get_pz_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_dynamic_aperture_struct_get_pz_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_dynamic_aperture_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pz) .and. is_contiguous(struct_obj%pz)) then
      data_ptr = c_loc(struct_obj%pz(lbound(struct_obj%pz, 1)))
      bounds(1) = int(lbound(struct_obj%pz, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pz, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_dynamic_aperture_struct%ellipse_scale: 0D_NOT_real

  subroutine tao_dynamic_aperture_struct_get_ellipse_scale(struct_obj_ptr, value_out) bind(c, name='tao_dynamic_aperture_struct_get_ellipse_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ellipse_scale
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_ellipse_scale(struct_obj_ptr, value_in) bind(c, name='tao_dynamic_aperture_struct_set_ellipse_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ellipse_scale = value_in
  end subroutine

  ! tao_dynamic_aperture_struct%a_emit: 0D_NOT_real

  subroutine tao_dynamic_aperture_struct_get_a_emit(struct_obj_ptr, value_out) bind(c, name='tao_dynamic_aperture_struct_get_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_emit
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_a_emit(struct_obj_ptr, value_in) bind(c, name='tao_dynamic_aperture_struct_set_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_emit = value_in
  end subroutine

  ! tao_dynamic_aperture_struct%b_emit: 0D_NOT_real

  subroutine tao_dynamic_aperture_struct_get_b_emit(struct_obj_ptr, value_out) bind(c, name='tao_dynamic_aperture_struct_get_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_emit
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_b_emit(struct_obj_ptr, value_in) bind(c, name='tao_dynamic_aperture_struct_set_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_emit = value_in
  end subroutine

  !! tao_model_branch_struct

    function allocate_fortran_tao_model_branch_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_model_branch_struct), pointer :: fptr
      type(tao_model_branch_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_model_branch_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_model_branch_struct), pointer :: fptr
      type(tao_model_branch_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_model_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_model_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_model_branch_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_model_branch_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_model_branch_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_model_branch_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_model_branch_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_model_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_model_branch_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_model_branch_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_model_branch_struct%ele: 1D_ALLOC_type

  subroutine tao_model_branch_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_model_branch_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_model_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_model_branch_struct%beam: 0D_NOT_type

  subroutine tao_model_branch_struct_get_beam(struct_obj_ptr, ptr_out) bind(c, name='tao_model_branch_struct_get_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_model_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam)
  end subroutine


  subroutine tao_model_branch_struct_set_beam(struct_obj_ptr, src_ptr) bind(c, name='tao_model_branch_struct_set_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_model_branch_struct), pointer :: struct_obj
    type(tao_beam_branch_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam = src_obj
  end subroutine

  !! tao_spin_map_struct

    function allocate_fortran_tao_spin_map_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_spin_map_struct), pointer :: fptr
      type(tao_spin_map_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_spin_map_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_spin_map_struct), pointer :: fptr
      type(tao_spin_map_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_spin_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_spin_map_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_spin_map_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_spin_map_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_spin_map_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_spin_map_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_spin_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_spin_map_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_spin_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_spin_map_struct%valid: 0D_NOT_logical

  subroutine tao_spin_map_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_spin_map_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  ! tao_spin_map_struct%map1: 0D_NOT_type

  subroutine tao_spin_map_struct_get_map1(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_map1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%map1)
  end subroutine


  subroutine tao_spin_map_struct_set_map1(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_map1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_orbit_map1_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%map1 = src_obj
  end subroutine

  ! tao_spin_map_struct%axis_input: 0D_NOT_type

  subroutine tao_spin_map_struct_get_axis_input(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_axis_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%axis_input)
  end subroutine


  subroutine tao_spin_map_struct_set_axis_input(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_axis_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%axis_input = src_obj
  end subroutine

  ! tao_spin_map_struct%axis0: 0D_NOT_type

  subroutine tao_spin_map_struct_get_axis0(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_axis0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%axis0)
  end subroutine


  subroutine tao_spin_map_struct_set_axis0(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_axis0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%axis0 = src_obj
  end subroutine

  ! tao_spin_map_struct%axis1: 0D_NOT_type

  subroutine tao_spin_map_struct_get_axis1(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_axis1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%axis1)
  end subroutine


  subroutine tao_spin_map_struct_set_axis1(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_axis1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%axis1 = src_obj
  end subroutine

  ! tao_spin_map_struct%ix_ele: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine tao_spin_map_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! tao_spin_map_struct%ix_ref: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_ref(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ref
  end subroutine


  subroutine tao_spin_map_struct_set_ix_ref(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ref = value_in
  end subroutine

  ! tao_spin_map_struct%ix_uni: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_spin_map_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_spin_map_struct%ix_branch: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_spin_map_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_spin_map_struct%mat8: 2D_NOT_real

  subroutine tao_spin_map_struct_get_mat8_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_map_struct_get_mat8_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%mat8)) then
      data_ptr = c_loc(struct_obj%mat8(lbound(struct_obj%mat8, 1), lbound(struct_obj%mat8, 2)))
      bounds(1) = int(lbound(struct_obj%mat8, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat8, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat8, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat8, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! tao_data_struct

    function allocate_fortran_tao_data_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_data_struct), pointer :: fptr
      type(tao_data_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_data_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_data_struct), pointer :: fptr
      type(tao_data_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_data_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_data_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_data_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_data_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_data_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_data_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_data_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_data_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_data_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_data_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_data_struct%ele_name: 0D_NOT_character

  subroutine tao_data_struct_get_ele_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_ele_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_ele_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_ele_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%ele_start_name: 0D_NOT_character

  subroutine tao_data_struct_get_ele_start_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_ele_start_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_start_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_start_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_ele_start_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_ele_start_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_start_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%ele_ref_name: 0D_NOT_character

  subroutine tao_data_struct_get_ele_ref_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_ele_ref_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_ref_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_ref_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_ele_ref_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_ele_ref_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_ref_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%data_type: 0D_ALLOC_character

  subroutine tao_data_struct_get_data_type_info(struct_obj_ptr, data_ptr, str_len, is_allocated) &
    bind(c, name='tao_data_struct_get_data_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%data_type)) then
      data_ptr = c_loc(struct_obj%data_type)
      str_len = int(len(struct_obj%data_type), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine


  subroutine tao_data_struct_set_data_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_data_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: temp_str

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%data_type)) deallocate(struct_obj%data_type)

    if (str_len > 0) then
       call c_f_pointer(str_ptr, temp_str)
       allocate(struct_obj%data_type, source=temp_str)
       struct_obj%data_type = temp_str(1:str_len)
    endif
  end subroutine

  ! tao_data_struct%merit_type: 0D_NOT_character

  subroutine tao_data_struct_get_merit_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_merit_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%merit_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%merit_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_merit_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_merit_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%merit_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%id: 0D_NOT_character

  subroutine tao_data_struct_get_id_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_id_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%id)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%id), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_id(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%id = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%data_source: 0D_NOT_character

  subroutine tao_data_struct_get_data_source_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_data_source_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_source)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_source), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_data_source(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_data_source')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_source = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%why_invalid: 0D_NOT_character

  subroutine tao_data_struct_get_why_invalid_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_why_invalid_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%why_invalid)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%why_invalid), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_why_invalid(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_why_invalid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%why_invalid = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%ix_uni: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_data_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_data_struct%ix_bunch: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_bunch(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch
  end subroutine


  subroutine tao_data_struct_set_ix_bunch(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch = value_in
  end subroutine

  ! tao_data_struct%ix_branch: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_data_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_data_struct%ix_ele: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine tao_data_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! tao_data_struct%ix_ele_start: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele_start(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_start
  end subroutine


  subroutine tao_data_struct_set_ix_ele_start(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_start = value_in
  end subroutine

  ! tao_data_struct%ix_ele_ref: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele_ref(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_ref
  end subroutine


  subroutine tao_data_struct_set_ix_ele_ref(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_ref = value_in
  end subroutine

  ! tao_data_struct%ix_ele_merit: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele_merit(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_merit
  end subroutine


  subroutine tao_data_struct_set_ix_ele_merit(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_merit = value_in
  end subroutine

  ! tao_data_struct%ix_d1: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_d1(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_d1
  end subroutine


  subroutine tao_data_struct_set_ix_d1(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_d1 = value_in
  end subroutine

  ! tao_data_struct%ix_data: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_data(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_data
  end subroutine


  subroutine tao_data_struct_set_ix_data(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_data = value_in
  end subroutine

  ! tao_data_struct%ix_dModel: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_dModel(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_dModel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_dModel
  end subroutine


  subroutine tao_data_struct_set_ix_dModel(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_dModel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_dModel = value_in
  end subroutine

  ! tao_data_struct%eval_point: 0D_NOT_integer

  subroutine tao_data_struct_get_eval_point(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_eval_point')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eval_point
  end subroutine


  subroutine tao_data_struct_set_eval_point(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_eval_point')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eval_point = value_in
  end subroutine

  ! tao_data_struct%meas_value: 0D_NOT_real

  subroutine tao_data_struct_get_meas_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_meas_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%meas_value
  end subroutine


  subroutine tao_data_struct_set_meas_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_meas_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%meas_value = value_in
  end subroutine

  ! tao_data_struct%ref_value: 0D_NOT_real

  subroutine tao_data_struct_get_ref_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ref_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_value
  end subroutine


  subroutine tao_data_struct_set_ref_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ref_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_value = value_in
  end subroutine

  ! tao_data_struct%model_value: 0D_NOT_real

  subroutine tao_data_struct_get_model_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%model_value
  end subroutine


  subroutine tao_data_struct_set_model_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%model_value = value_in
  end subroutine

  ! tao_data_struct%design_value: 0D_NOT_real

  subroutine tao_data_struct_get_design_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_design_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%design_value
  end subroutine


  subroutine tao_data_struct_set_design_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_design_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%design_value = value_in
  end subroutine

  ! tao_data_struct%old_value: 0D_NOT_real

  subroutine tao_data_struct_get_old_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%old_value
  end subroutine


  subroutine tao_data_struct_set_old_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%old_value = value_in
  end subroutine

  ! tao_data_struct%base_value: 0D_NOT_real

  subroutine tao_data_struct_get_base_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%base_value
  end subroutine


  subroutine tao_data_struct_set_base_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%base_value = value_in
  end subroutine

  ! tao_data_struct%error_rms: 0D_NOT_real

  subroutine tao_data_struct_get_error_rms(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_error_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%error_rms
  end subroutine


  subroutine tao_data_struct_set_error_rms(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_error_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%error_rms = value_in
  end subroutine

  ! tao_data_struct%delta_merit: 0D_NOT_real

  subroutine tao_data_struct_get_delta_merit(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_delta_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%delta_merit
  end subroutine


  subroutine tao_data_struct_set_delta_merit(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_delta_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%delta_merit = value_in
  end subroutine

  ! tao_data_struct%weight: 0D_NOT_real

  subroutine tao_data_struct_get_weight(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_weight')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%weight
  end subroutine


  subroutine tao_data_struct_set_weight(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_weight')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%weight = value_in
  end subroutine

  ! tao_data_struct%invalid_value: 0D_NOT_real

  subroutine tao_data_struct_get_invalid_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_invalid_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%invalid_value
  end subroutine


  subroutine tao_data_struct_set_invalid_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_invalid_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%invalid_value = value_in
  end subroutine

  ! tao_data_struct%merit: 0D_NOT_real

  subroutine tao_data_struct_get_merit(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%merit
  end subroutine


  subroutine tao_data_struct_set_merit(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%merit = value_in
  end subroutine

  ! tao_data_struct%s: 0D_NOT_real

  subroutine tao_data_struct_get_s(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine tao_data_struct_set_s(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! tao_data_struct%s_offset: 0D_NOT_real

  subroutine tao_data_struct_get_s_offset(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_s_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_offset
  end subroutine


  subroutine tao_data_struct_set_s_offset(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_s_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_offset = value_in
  end subroutine

  ! tao_data_struct%ref_s_offset: 0D_NOT_real

  subroutine tao_data_struct_get_ref_s_offset(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ref_s_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_s_offset
  end subroutine


  subroutine tao_data_struct_set_ref_s_offset(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ref_s_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_s_offset = value_in
  end subroutine

  ! tao_data_struct%err_message_printed: 0D_NOT_logical

  subroutine tao_data_struct_get_err_message_printed(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_err_message_printed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%err_message_printed
  end subroutine


  subroutine tao_data_struct_set_err_message_printed(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_err_message_printed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%err_message_printed = value_in
  end subroutine

  ! tao_data_struct%exists: 0D_NOT_logical

  subroutine tao_data_struct_get_exists(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_exists')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%exists
  end subroutine


  subroutine tao_data_struct_set_exists(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_exists')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%exists = value_in
  end subroutine

  ! tao_data_struct%good_model: 0D_NOT_logical

  subroutine tao_data_struct_get_good_model(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_model
  end subroutine


  subroutine tao_data_struct_set_good_model(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_model = value_in
  end subroutine

  ! tao_data_struct%good_base: 0D_NOT_logical

  subroutine tao_data_struct_get_good_base(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_base
  end subroutine


  subroutine tao_data_struct_set_good_base(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_base = value_in
  end subroutine

  ! tao_data_struct%good_design: 0D_NOT_logical

  subroutine tao_data_struct_get_good_design(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_design
  end subroutine


  subroutine tao_data_struct_set_good_design(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_design = value_in
  end subroutine

  ! tao_data_struct%good_meas: 0D_NOT_logical

  subroutine tao_data_struct_get_good_meas(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_meas
  end subroutine


  subroutine tao_data_struct_set_good_meas(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_meas = value_in
  end subroutine

  ! tao_data_struct%good_ref: 0D_NOT_logical

  subroutine tao_data_struct_get_good_ref(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_ref
  end subroutine


  subroutine tao_data_struct_set_good_ref(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_ref = value_in
  end subroutine

  ! tao_data_struct%good_user: 0D_NOT_logical

  subroutine tao_data_struct_get_good_user(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_user
  end subroutine


  subroutine tao_data_struct_set_good_user(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_user = value_in
  end subroutine

  ! tao_data_struct%good_opt: 0D_NOT_logical

  subroutine tao_data_struct_get_good_opt(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_opt
  end subroutine


  subroutine tao_data_struct_set_good_opt(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_opt = value_in
  end subroutine

  ! tao_data_struct%good_plot: 0D_NOT_logical

  subroutine tao_data_struct_get_good_plot(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_plot
  end subroutine


  subroutine tao_data_struct_set_good_plot(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_plot = value_in
  end subroutine

  ! tao_data_struct%useit_plot: 0D_NOT_logical

  subroutine tao_data_struct_get_useit_plot(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_useit_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%useit_plot
  end subroutine


  subroutine tao_data_struct_set_useit_plot(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_useit_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%useit_plot = value_in
  end subroutine

  ! tao_data_struct%useit_opt: 0D_NOT_logical

  subroutine tao_data_struct_get_useit_opt(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_useit_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%useit_opt
  end subroutine


  subroutine tao_data_struct_set_useit_opt(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_useit_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%useit_opt = value_in
  end subroutine

  ! tao_data_struct%spin_map: 0D_NOT_type

  subroutine tao_data_struct_get_spin_map(struct_obj_ptr, ptr_out) bind(c, name='tao_data_struct_get_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spin_map)
  end subroutine


  subroutine tao_data_struct_set_spin_map(struct_obj_ptr, src_ptr) bind(c, name='tao_data_struct_set_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_data_struct), pointer :: struct_obj
    type(tao_spin_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spin_map = src_obj
  end subroutine

  ! tao_data_struct%d1: 0D_PTR_type

  subroutine tao_data_struct_get_d1(struct_obj_ptr, ptr_out) bind(c, name='tao_data_struct_get_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d1)) then
      ptr_out = c_loc(struct_obj%d1)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_data_struct_set_d1(struct_obj_ptr, src_ptr) bind(c, name='tao_data_struct_set_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_data_struct), pointer :: struct_obj
    type(tao_d1_data_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d1)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%d1 = src_obj
    endif
  end subroutine

  !! tao_ping_scale_struct

    function allocate_fortran_tao_ping_scale_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_ping_scale_struct), pointer :: fptr
      type(tao_ping_scale_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_ping_scale_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_ping_scale_struct), pointer :: fptr
      type(tao_ping_scale_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_ping_scale_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_ping_scale_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_ping_scale_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_ping_scale_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_ping_scale_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_ping_scale_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_ping_scale_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_ping_scale_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_ping_scale_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_ping_scale_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_ping_scale_struct%a_mode_meas: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_a_mode_meas(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_a_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_mode_meas
  end subroutine


  subroutine tao_ping_scale_struct_set_a_mode_meas(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_a_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_mode_meas = value_in
  end subroutine

  ! tao_ping_scale_struct%a_mode_ref: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_a_mode_ref(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_a_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_mode_ref
  end subroutine


  subroutine tao_ping_scale_struct_set_a_mode_ref(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_a_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_mode_ref = value_in
  end subroutine

  ! tao_ping_scale_struct%b_mode_meas: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_b_mode_meas(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_b_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_mode_meas
  end subroutine


  subroutine tao_ping_scale_struct_set_b_mode_meas(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_b_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_mode_meas = value_in
  end subroutine

  ! tao_ping_scale_struct%b_mode_ref: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_b_mode_ref(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_b_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_mode_ref
  end subroutine


  subroutine tao_ping_scale_struct_set_b_mode_ref(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_b_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_mode_ref = value_in
  end subroutine

  !! tao_universe_calc_struct

    function allocate_fortran_tao_universe_calc_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_universe_calc_struct), pointer :: fptr
      type(tao_universe_calc_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_universe_calc_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_universe_calc_struct), pointer :: fptr
      type(tao_universe_calc_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_universe_calc_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_universe_calc_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_universe_calc_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_universe_calc_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_universe_calc_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_universe_calc_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_universe_calc_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_universe_calc_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_universe_calc_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_universe_calc_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_universe_calc_struct%srdt_for_data: 0D_NOT_integer

  subroutine tao_universe_calc_struct_get_srdt_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_srdt_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%srdt_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_srdt_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_srdt_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%srdt_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%rad_int_for_data: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_rad_int_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_rad_int_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_rad_int_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_rad_int_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%rad_int_for_plotting: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_rad_int_for_plotting(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_rad_int_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_for_plotting
  end subroutine


  subroutine tao_universe_calc_struct_set_rad_int_for_plotting(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_rad_int_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_for_plotting = value_in
  end subroutine

  ! tao_universe_calc_struct%chrom_for_data: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_chrom_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_chrom_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_chrom_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_chrom_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%chrom_for_plotting: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_chrom_for_plotting(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_chrom_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom_for_plotting
  end subroutine


  subroutine tao_universe_calc_struct_set_chrom_for_plotting(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_chrom_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom_for_plotting = value_in
  end subroutine

  ! tao_universe_calc_struct%lat_sigma_for_data: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_lat_sigma_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_lat_sigma_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lat_sigma_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_lat_sigma_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_lat_sigma_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lat_sigma_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%lat_sigma_for_plotting: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_lat_sigma_for_plotting(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_lat_sigma_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lat_sigma_for_plotting
  end subroutine


  subroutine tao_universe_calc_struct_set_lat_sigma_for_plotting(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_lat_sigma_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lat_sigma_for_plotting = value_in
  end subroutine

  ! tao_universe_calc_struct%dynamic_aperture: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_dynamic_aperture(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dynamic_aperture
  end subroutine


  subroutine tao_universe_calc_struct_set_dynamic_aperture(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dynamic_aperture = value_in
  end subroutine

  ! tao_universe_calc_struct%one_turn_map: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_one_turn_map(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_one_turn_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%one_turn_map
  end subroutine


  subroutine tao_universe_calc_struct_set_one_turn_map(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_one_turn_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%one_turn_map = value_in
  end subroutine

  ! tao_universe_calc_struct%lattice: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_lattice(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lattice
  end subroutine


  subroutine tao_universe_calc_struct_set_lattice(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lattice = value_in
  end subroutine

  ! tao_universe_calc_struct%twiss: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_twiss(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%twiss
  end subroutine


  subroutine tao_universe_calc_struct_set_twiss(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%twiss = value_in
  end subroutine

  ! tao_universe_calc_struct%track: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_track(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%track
  end subroutine


  subroutine tao_universe_calc_struct_set_track(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%track = value_in
  end subroutine

  ! tao_universe_calc_struct%spin_matrices: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_spin_matrices(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_spin_matrices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_matrices
  end subroutine


  subroutine tao_universe_calc_struct_set_spin_matrices(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_spin_matrices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_matrices = value_in
  end subroutine

  !! lat_ele_order_struct

    function allocate_fortran_lat_ele_order_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(lat_ele_order_struct), pointer :: fptr
      type(lat_ele_order_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_lat_ele_order_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(lat_ele_order_struct), pointer :: fptr
      type(lat_ele_order_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_lat_ele_order_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_order_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_lat_ele_order_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(lat_ele_order_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_lat_ele_order_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(lat_ele_order_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_lat_ele_order_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(lat_ele_order_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_lat_ele_order_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(lat_ele_order_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! lat_ele_order_struct%branch: 1D_ALLOC_type

  subroutine lat_ele_order_struct_get_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_ele_order_struct_get_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_ele_order_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%branch) .and. is_contiguous(struct_obj%branch)) then
      data_ptr = c_loc(struct_obj%branch(lbound(struct_obj%branch, 1)))
      bounds(1) = int(lbound(struct_obj%branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_title_struct

    function allocate_fortran_tao_title_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_title_struct), pointer :: fptr
      type(tao_title_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_title_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_title_struct), pointer :: fptr
      type(tao_title_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_title_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_title_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_title_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_title_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_title_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_title_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_title_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_title_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_title_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_title_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_title_struct%string: 0D_NOT_character

  subroutine tao_title_struct_get_string_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_title_struct_get_string_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%string)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%string), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_title_struct_set_string(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_title_struct_set_string')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_title_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%string = str_in ! implicitly handles padding
  end subroutine

  ! tao_title_struct%x: 0D_NOT_real

  subroutine tao_title_struct_get_x(struct_obj_ptr, value_out) bind(c, name='tao_title_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine tao_title_struct_set_x(struct_obj_ptr, value_in) bind(c, name='tao_title_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! tao_title_struct%y: 0D_NOT_real

  subroutine tao_title_struct_get_y(struct_obj_ptr, value_out) bind(c, name='tao_title_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine tao_title_struct_set_y(struct_obj_ptr, value_in) bind(c, name='tao_title_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! tao_title_struct%units: 0D_NOT_character

  subroutine tao_title_struct_get_units_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_title_struct_get_units_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%units)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%units), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_title_struct_set_units(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_title_struct_set_units')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_title_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%units = str_in ! implicitly handles padding
  end subroutine

  ! tao_title_struct%justify: 0D_NOT_character

  subroutine tao_title_struct_get_justify_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_title_struct_get_justify_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%justify)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%justify), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_title_struct_set_justify(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_title_struct_set_justify')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_title_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%justify = str_in ! implicitly handles padding
  end subroutine

  ! tao_title_struct%draw_it: 0D_NOT_logical

  subroutine tao_title_struct_get_draw_it(struct_obj_ptr, value_out) bind(c, name='tao_title_struct_get_draw_it')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_it
  end subroutine


  subroutine tao_title_struct_set_draw_it(struct_obj_ptr, value_in) bind(c, name='tao_title_struct_set_draw_it')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_title_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_it = value_in
  end subroutine

  !! qp_rect_struct

    function allocate_fortran_qp_rect_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(qp_rect_struct), pointer :: fptr
      type(qp_rect_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_qp_rect_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(qp_rect_struct), pointer :: fptr
      type(qp_rect_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_qp_rect_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(qp_rect_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_qp_rect_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(qp_rect_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_qp_rect_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(qp_rect_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_qp_rect_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(qp_rect_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_qp_rect_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(qp_rect_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! qp_rect_struct%x1: 0D_NOT_real

  subroutine qp_rect_struct_get_x1(struct_obj_ptr, value_out) bind(c, name='qp_rect_struct_get_x1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x1
  end subroutine


  subroutine qp_rect_struct_set_x1(struct_obj_ptr, value_in) bind(c, name='qp_rect_struct_set_x1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x1 = value_in
  end subroutine

  ! qp_rect_struct%x2: 0D_NOT_real

  subroutine qp_rect_struct_get_x2(struct_obj_ptr, value_out) bind(c, name='qp_rect_struct_get_x2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x2
  end subroutine


  subroutine qp_rect_struct_set_x2(struct_obj_ptr, value_in) bind(c, name='qp_rect_struct_set_x2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x2 = value_in
  end subroutine

  ! qp_rect_struct%y1: 0D_NOT_real

  subroutine qp_rect_struct_get_y1(struct_obj_ptr, value_out) bind(c, name='qp_rect_struct_get_y1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y1
  end subroutine


  subroutine qp_rect_struct_set_y1(struct_obj_ptr, value_in) bind(c, name='qp_rect_struct_set_y1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y1 = value_in
  end subroutine

  ! qp_rect_struct%y2: 0D_NOT_real

  subroutine qp_rect_struct_get_y2(struct_obj_ptr, value_out) bind(c, name='qp_rect_struct_get_y2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y2
  end subroutine


  subroutine qp_rect_struct_set_y2(struct_obj_ptr, value_in) bind(c, name='qp_rect_struct_set_y2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y2 = value_in
  end subroutine

  ! qp_rect_struct%units: 0D_NOT_character

  subroutine qp_rect_struct_get_units_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_rect_struct_get_units_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_rect_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%units)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%units), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_rect_struct_set_units(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_rect_struct_set_units')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_rect_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%units = str_in ! implicitly handles padding
  end subroutine

  !! tao_drawing_struct

    function allocate_fortran_tao_drawing_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_drawing_struct), pointer :: fptr
      type(tao_drawing_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_drawing_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_drawing_struct), pointer :: fptr
      type(tao_drawing_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_drawing_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_drawing_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_drawing_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_drawing_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_drawing_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_drawing_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_drawing_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_drawing_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_drawing_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_drawing_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_drawing_struct%ele_shape: 1D_ALLOC_type

  subroutine tao_drawing_struct_get_ele_shape_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_drawing_struct_get_ele_shape_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_drawing_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ele_shape) .and. is_contiguous(struct_obj%ele_shape)) then
      data_ptr = c_loc(struct_obj%ele_shape(lbound(struct_obj%ele_shape, 1)))
      bounds(1) = int(lbound(struct_obj%ele_shape, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele_shape, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele_shape(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_shape_pattern_struct

    function allocate_fortran_tao_shape_pattern_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_shape_pattern_struct), pointer :: fptr
      type(tao_shape_pattern_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_shape_pattern_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_shape_pattern_struct), pointer :: fptr
      type(tao_shape_pattern_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_shape_pattern_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_shape_pattern_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_shape_pattern_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_shape_pattern_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_shape_pattern_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_shape_pattern_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_shape_pattern_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_shape_pattern_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_shape_pattern_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_shape_pattern_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_shape_pattern_struct%name: 0D_NOT_character

  subroutine tao_shape_pattern_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_shape_pattern_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_shape_pattern_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_shape_pattern_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_shape_pattern_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_shape_pattern_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_shape_pattern_struct%line: 0D_NOT_type

  subroutine tao_shape_pattern_struct_get_line(struct_obj_ptr, ptr_out) bind(c, name='tao_shape_pattern_struct_get_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_shape_pattern_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%line)
  end subroutine


  subroutine tao_shape_pattern_struct_set_line(struct_obj_ptr, src_ptr) bind(c, name='tao_shape_pattern_struct_set_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_shape_pattern_struct), pointer :: struct_obj
    type(qp_line_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%line = src_obj
  end subroutine

  ! tao_shape_pattern_struct%pt: 1D_ALLOC_type

  subroutine tao_shape_pattern_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_shape_pattern_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_shape_pattern_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      
      el_size = int(storage_size(struct_obj%pt(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_shape_pattern_point_struct

    function allocate_fortran_tao_shape_pattern_point_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_shape_pattern_point_struct), pointer :: fptr
      type(tao_shape_pattern_point_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_shape_pattern_point_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_shape_pattern_point_struct), pointer :: fptr
      type(tao_shape_pattern_point_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_shape_pattern_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_shape_pattern_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_shape_pattern_point_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_shape_pattern_point_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_shape_pattern_point_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_shape_pattern_point_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_shape_pattern_point_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_shape_pattern_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_shape_pattern_point_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_shape_pattern_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_shape_pattern_point_struct%s: 0D_NOT_real

  subroutine tao_shape_pattern_point_struct_get_s(struct_obj_ptr, value_out) bind(c, name='tao_shape_pattern_point_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_shape_pattern_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine tao_shape_pattern_point_struct_set_s(struct_obj_ptr, value_in) bind(c, name='tao_shape_pattern_point_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_shape_pattern_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! tao_shape_pattern_point_struct%y: 0D_NOT_real

  subroutine tao_shape_pattern_point_struct_get_y(struct_obj_ptr, value_out) bind(c, name='tao_shape_pattern_point_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_shape_pattern_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine tao_shape_pattern_point_struct_set_y(struct_obj_ptr, value_in) bind(c, name='tao_shape_pattern_point_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_shape_pattern_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! tao_shape_pattern_point_struct%radius: 0D_NOT_real

  subroutine tao_shape_pattern_point_struct_get_radius(struct_obj_ptr, value_out) bind(c, name='tao_shape_pattern_point_struct_get_radius')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_shape_pattern_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radius
  end subroutine


  subroutine tao_shape_pattern_point_struct_set_radius(struct_obj_ptr, value_in) bind(c, name='tao_shape_pattern_point_struct_set_radius')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_shape_pattern_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radius = value_in
  end subroutine

  !! qp_axis_struct

    function allocate_fortran_qp_axis_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(qp_axis_struct), pointer :: fptr
      type(qp_axis_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_qp_axis_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(qp_axis_struct), pointer :: fptr
      type(qp_axis_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_qp_axis_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(qp_axis_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_qp_axis_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(qp_axis_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_qp_axis_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(qp_axis_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_qp_axis_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(qp_axis_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_qp_axis_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(qp_axis_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! qp_axis_struct%label: 0D_NOT_character

  subroutine qp_axis_struct_get_label_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_axis_struct_get_label_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%label)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%label), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_axis_struct_set_label(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_axis_struct_set_label')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_axis_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%label = str_in ! implicitly handles padding
  end subroutine

  ! qp_axis_struct%min: 0D_NOT_real

  subroutine qp_axis_struct_get_min(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%min
  end subroutine


  subroutine qp_axis_struct_set_min(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%min = value_in
  end subroutine

  ! qp_axis_struct%max: 0D_NOT_real

  subroutine qp_axis_struct_get_max(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max
  end subroutine


  subroutine qp_axis_struct_set_max(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max = value_in
  end subroutine

  ! qp_axis_struct%tick_min: 0D_NOT_real

  subroutine qp_axis_struct_get_tick_min(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_tick_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tick_min
  end subroutine


  subroutine qp_axis_struct_set_tick_min(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_tick_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tick_min = value_in
  end subroutine

  ! qp_axis_struct%tick_max: 0D_NOT_real

  subroutine qp_axis_struct_get_tick_max(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_tick_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tick_max
  end subroutine


  subroutine qp_axis_struct_set_tick_max(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_tick_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tick_max = value_in
  end subroutine

  ! qp_axis_struct%eval_min: 0D_NOT_real

  subroutine qp_axis_struct_get_eval_min(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_eval_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eval_min
  end subroutine


  subroutine qp_axis_struct_set_eval_min(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_eval_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eval_min = value_in
  end subroutine

  ! qp_axis_struct%eval_max: 0D_NOT_real

  subroutine qp_axis_struct_get_eval_max(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_eval_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eval_max
  end subroutine


  subroutine qp_axis_struct_set_eval_max(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_eval_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eval_max = value_in
  end subroutine

  ! qp_axis_struct%dtick: 0D_NOT_real

  subroutine qp_axis_struct_get_dtick(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_dtick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dtick
  end subroutine


  subroutine qp_axis_struct_set_dtick(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_dtick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dtick = value_in
  end subroutine

  ! qp_axis_struct%number_offset: 0D_NOT_real

  subroutine qp_axis_struct_get_number_offset(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_number_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%number_offset
  end subroutine


  subroutine qp_axis_struct_set_number_offset(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_number_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%number_offset = value_in
  end subroutine

  ! qp_axis_struct%label_offset: 0D_NOT_real

  subroutine qp_axis_struct_get_label_offset(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_label_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%label_offset
  end subroutine


  subroutine qp_axis_struct_set_label_offset(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_label_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%label_offset = value_in
  end subroutine

  ! qp_axis_struct%major_tick_len: 0D_NOT_real

  subroutine qp_axis_struct_get_major_tick_len(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_major_tick_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%major_tick_len
  end subroutine


  subroutine qp_axis_struct_set_major_tick_len(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_major_tick_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%major_tick_len = value_in
  end subroutine

  ! qp_axis_struct%minor_tick_len: 0D_NOT_real

  subroutine qp_axis_struct_get_minor_tick_len(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_minor_tick_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%minor_tick_len
  end subroutine


  subroutine qp_axis_struct_set_minor_tick_len(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_minor_tick_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%minor_tick_len = value_in
  end subroutine

  ! qp_axis_struct%label_color: 0D_NOT_character

  subroutine qp_axis_struct_get_label_color_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_axis_struct_get_label_color_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%label_color)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%label_color), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_axis_struct_set_label_color(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_axis_struct_set_label_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_axis_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%label_color = str_in ! implicitly handles padding
  end subroutine

  ! qp_axis_struct%major_div: 0D_NOT_integer

  subroutine qp_axis_struct_get_major_div(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_major_div')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%major_div
  end subroutine


  subroutine qp_axis_struct_set_major_div(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_major_div')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%major_div = value_in
  end subroutine

  ! qp_axis_struct%major_div_nominal: 0D_NOT_integer

  subroutine qp_axis_struct_get_major_div_nominal(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_major_div_nominal')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%major_div_nominal
  end subroutine


  subroutine qp_axis_struct_set_major_div_nominal(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_major_div_nominal')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%major_div_nominal = value_in
  end subroutine

  ! qp_axis_struct%minor_div: 0D_NOT_integer

  subroutine qp_axis_struct_get_minor_div(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_minor_div')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%minor_div
  end subroutine


  subroutine qp_axis_struct_set_minor_div(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_minor_div')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%minor_div = value_in
  end subroutine

  ! qp_axis_struct%minor_div_max: 0D_NOT_integer

  subroutine qp_axis_struct_get_minor_div_max(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_minor_div_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%minor_div_max
  end subroutine


  subroutine qp_axis_struct_set_minor_div_max(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_minor_div_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%minor_div_max = value_in
  end subroutine

  ! qp_axis_struct%places: 0D_NOT_integer

  subroutine qp_axis_struct_get_places(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_places')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%places
  end subroutine


  subroutine qp_axis_struct_set_places(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_places')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%places = value_in
  end subroutine

  ! qp_axis_struct%type: 0D_NOT_character

  subroutine qp_axis_struct_get_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_axis_struct_get_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_axis_struct_set_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_axis_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_axis_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%type = str_in ! implicitly handles padding
  end subroutine

  ! qp_axis_struct%bounds: 0D_NOT_character

  subroutine qp_axis_struct_get_bounds_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_axis_struct_get_bounds_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%bounds)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%bounds), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_axis_struct_set_bounds(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_axis_struct_set_bounds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_axis_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%bounds = str_in ! implicitly handles padding
  end subroutine

  ! qp_axis_struct%tick_side: 0D_NOT_integer

  subroutine qp_axis_struct_get_tick_side(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_tick_side')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tick_side
  end subroutine


  subroutine qp_axis_struct_set_tick_side(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_tick_side')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tick_side = value_in
  end subroutine

  ! qp_axis_struct%number_side: 0D_NOT_integer

  subroutine qp_axis_struct_get_number_side(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_number_side')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%number_side
  end subroutine


  subroutine qp_axis_struct_set_number_side(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_number_side')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%number_side = value_in
  end subroutine

  ! qp_axis_struct%draw_label: 0D_NOT_logical

  subroutine qp_axis_struct_get_draw_label(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_draw_label')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_label
  end subroutine


  subroutine qp_axis_struct_set_draw_label(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_draw_label')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_label = value_in
  end subroutine

  ! qp_axis_struct%draw_numbers: 0D_NOT_logical

  subroutine qp_axis_struct_get_draw_numbers(struct_obj_ptr, value_out) bind(c, name='qp_axis_struct_get_draw_numbers')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_numbers
  end subroutine


  subroutine qp_axis_struct_set_draw_numbers(struct_obj_ptr, value_in) bind(c, name='qp_axis_struct_set_draw_numbers')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(qp_axis_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_numbers = value_in
  end subroutine

  !! qp_legend_struct

    function allocate_fortran_qp_legend_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(qp_legend_struct), pointer :: fptr
      type(qp_legend_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_qp_legend_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(qp_legend_struct), pointer :: fptr
      type(qp_legend_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_qp_legend_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(qp_legend_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_qp_legend_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(qp_legend_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_qp_legend_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(qp_legend_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_qp_legend_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(qp_legend_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_qp_legend_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(qp_legend_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! qp_legend_struct%row_spacing: 0D_NOT_real

  subroutine qp_legend_struct_get_row_spacing(struct_obj_ptr, value_out) bind(c, name='qp_legend_struct_get_row_spacing')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%row_spacing
  end subroutine


  subroutine qp_legend_struct_set_row_spacing(struct_obj_ptr, value_in) bind(c, name='qp_legend_struct_set_row_spacing')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%row_spacing = value_in
  end subroutine

  ! qp_legend_struct%line_length: 0D_NOT_real

  subroutine qp_legend_struct_get_line_length(struct_obj_ptr, value_out) bind(c, name='qp_legend_struct_get_line_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%line_length
  end subroutine


  subroutine qp_legend_struct_set_line_length(struct_obj_ptr, value_in) bind(c, name='qp_legend_struct_set_line_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%line_length = value_in
  end subroutine

  ! qp_legend_struct%text_offset: 0D_NOT_real

  subroutine qp_legend_struct_get_text_offset(struct_obj_ptr, value_out) bind(c, name='qp_legend_struct_get_text_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%text_offset
  end subroutine


  subroutine qp_legend_struct_set_text_offset(struct_obj_ptr, value_in) bind(c, name='qp_legend_struct_set_text_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%text_offset = value_in
  end subroutine

  ! qp_legend_struct%draw_line: 0D_NOT_logical

  subroutine qp_legend_struct_get_draw_line(struct_obj_ptr, value_out) bind(c, name='qp_legend_struct_get_draw_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_line
  end subroutine


  subroutine qp_legend_struct_set_draw_line(struct_obj_ptr, value_in) bind(c, name='qp_legend_struct_set_draw_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_line = value_in
  end subroutine

  ! qp_legend_struct%draw_symbol: 0D_NOT_logical

  subroutine qp_legend_struct_get_draw_symbol(struct_obj_ptr, value_out) bind(c, name='qp_legend_struct_get_draw_symbol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_symbol
  end subroutine


  subroutine qp_legend_struct_set_draw_symbol(struct_obj_ptr, value_in) bind(c, name='qp_legend_struct_set_draw_symbol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_symbol = value_in
  end subroutine

  ! qp_legend_struct%draw_text: 0D_NOT_logical

  subroutine qp_legend_struct_get_draw_text(struct_obj_ptr, value_out) bind(c, name='qp_legend_struct_get_draw_text')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_text
  end subroutine


  subroutine qp_legend_struct_set_draw_text(struct_obj_ptr, value_in) bind(c, name='qp_legend_struct_set_draw_text')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(qp_legend_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_text = value_in
  end subroutine

  !! qp_point_struct

    function allocate_fortran_qp_point_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(qp_point_struct), pointer :: fptr
      type(qp_point_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_qp_point_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(qp_point_struct), pointer :: fptr
      type(qp_point_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_qp_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(qp_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_qp_point_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(qp_point_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_qp_point_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(qp_point_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_qp_point_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(qp_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_qp_point_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(qp_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! qp_point_struct%x: 0D_NOT_real

  subroutine qp_point_struct_get_x(struct_obj_ptr, value_out) bind(c, name='qp_point_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine qp_point_struct_set_x(struct_obj_ptr, value_in) bind(c, name='qp_point_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! qp_point_struct%y: 0D_NOT_real

  subroutine qp_point_struct_get_y(struct_obj_ptr, value_out) bind(c, name='qp_point_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine qp_point_struct_set_y(struct_obj_ptr, value_in) bind(c, name='qp_point_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! qp_point_struct%units: 0D_NOT_character

  subroutine qp_point_struct_get_units_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_point_struct_get_units_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%units)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%units), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_point_struct_set_units(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_point_struct_set_units')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_point_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%units = str_in ! implicitly handles padding
  end subroutine

  !! qp_line_struct

    function allocate_fortran_qp_line_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(qp_line_struct), pointer :: fptr
      type(qp_line_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_qp_line_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(qp_line_struct), pointer :: fptr
      type(qp_line_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_qp_line_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(qp_line_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_qp_line_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(qp_line_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_qp_line_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(qp_line_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_qp_line_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(qp_line_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_qp_line_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(qp_line_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! qp_line_struct%width: 0D_NOT_integer

  subroutine qp_line_struct_get_width(struct_obj_ptr, value_out) bind(c, name='qp_line_struct_get_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_line_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%width
  end subroutine


  subroutine qp_line_struct_set_width(struct_obj_ptr, value_in) bind(c, name='qp_line_struct_set_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_line_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%width = value_in
  end subroutine

  ! qp_line_struct%color: 0D_NOT_character

  subroutine qp_line_struct_get_color_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_line_struct_get_color_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_line_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%color)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%color), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_line_struct_set_color(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_line_struct_set_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_line_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%color = str_in ! implicitly handles padding
  end subroutine

  ! qp_line_struct%pattern: 0D_NOT_character

  subroutine qp_line_struct_get_pattern_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_line_struct_get_pattern_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_line_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%pattern)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%pattern), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_line_struct_set_pattern(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_line_struct_set_pattern')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_line_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%pattern = str_in ! implicitly handles padding
  end subroutine

  !! qp_symbol_struct

    function allocate_fortran_qp_symbol_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(qp_symbol_struct), pointer :: fptr
      type(qp_symbol_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_qp_symbol_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(qp_symbol_struct), pointer :: fptr
      type(qp_symbol_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_qp_symbol_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(qp_symbol_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_qp_symbol_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(qp_symbol_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_qp_symbol_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(qp_symbol_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_qp_symbol_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(qp_symbol_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_qp_symbol_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(qp_symbol_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! qp_symbol_struct%type: 0D_NOT_character

  subroutine qp_symbol_struct_get_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_symbol_struct_get_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_symbol_struct_set_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_symbol_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_symbol_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%type = str_in ! implicitly handles padding
  end subroutine

  ! qp_symbol_struct%height: 0D_NOT_real

  subroutine qp_symbol_struct_get_height(struct_obj_ptr, value_out) bind(c, name='qp_symbol_struct_get_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%height
  end subroutine


  subroutine qp_symbol_struct_set_height(struct_obj_ptr, value_in) bind(c, name='qp_symbol_struct_set_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%height = value_in
  end subroutine

  ! qp_symbol_struct%color: 0D_NOT_character

  subroutine qp_symbol_struct_get_color_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_symbol_struct_get_color_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%color)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%color), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_symbol_struct_set_color(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_symbol_struct_set_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_symbol_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%color = str_in ! implicitly handles padding
  end subroutine

  ! qp_symbol_struct%fill_pattern: 0D_NOT_character

  subroutine qp_symbol_struct_get_fill_pattern_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='qp_symbol_struct_get_fill_pattern_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%fill_pattern)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%fill_pattern), c_int)
    is_allocated = .true.
  end subroutine


  subroutine qp_symbol_struct_set_fill_pattern(struct_obj_ptr, str_ptr, str_len) bind(c, name='qp_symbol_struct_set_fill_pattern')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(qp_symbol_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%fill_pattern = str_in ! implicitly handles padding
  end subroutine

  ! qp_symbol_struct%line_width: 0D_NOT_integer

  subroutine qp_symbol_struct_get_line_width(struct_obj_ptr, value_out) bind(c, name='qp_symbol_struct_get_line_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%line_width
  end subroutine


  subroutine qp_symbol_struct_set_line_width(struct_obj_ptr, value_in) bind(c, name='qp_symbol_struct_set_line_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(qp_symbol_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%line_width = value_in
  end subroutine

  !! tao_floor_plan_struct

    function allocate_fortran_tao_floor_plan_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_floor_plan_struct), pointer :: fptr
      type(tao_floor_plan_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_floor_plan_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_floor_plan_struct), pointer :: fptr
      type(tao_floor_plan_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_floor_plan_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_floor_plan_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_floor_plan_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_floor_plan_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_floor_plan_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_floor_plan_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_floor_plan_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_floor_plan_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_floor_plan_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_floor_plan_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_floor_plan_struct%view: 0D_NOT_character

  subroutine tao_floor_plan_struct_get_view_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_floor_plan_struct_get_view_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%view)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%view), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_floor_plan_struct_set_view(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_floor_plan_struct_set_view')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_floor_plan_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%view = str_in ! implicitly handles padding
  end subroutine

  ! tao_floor_plan_struct%rotation: 0D_NOT_real

  subroutine tao_floor_plan_struct_get_rotation(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_rotation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rotation
  end subroutine


  subroutine tao_floor_plan_struct_set_rotation(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_rotation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rotation = value_in
  end subroutine

  ! tao_floor_plan_struct%correct_distortion: 0D_NOT_logical

  subroutine tao_floor_plan_struct_get_correct_distortion(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_correct_distortion')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%correct_distortion
  end subroutine


  subroutine tao_floor_plan_struct_set_correct_distortion(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_correct_distortion')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%correct_distortion = value_in
  end subroutine

  ! tao_floor_plan_struct%flip_label_side: 0D_NOT_logical

  subroutine tao_floor_plan_struct_get_flip_label_side(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_flip_label_side')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%flip_label_side
  end subroutine


  subroutine tao_floor_plan_struct_set_flip_label_side(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_flip_label_side')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%flip_label_side = value_in
  end subroutine

  ! tao_floor_plan_struct%size_is_absolute: 0D_NOT_logical

  subroutine tao_floor_plan_struct_get_size_is_absolute(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_size_is_absolute')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%size_is_absolute
  end subroutine


  subroutine tao_floor_plan_struct_set_size_is_absolute(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_size_is_absolute')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%size_is_absolute = value_in
  end subroutine

  ! tao_floor_plan_struct%draw_only_first_pass: 0D_NOT_logical

  subroutine tao_floor_plan_struct_get_draw_only_first_pass(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_draw_only_first_pass')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_only_first_pass
  end subroutine


  subroutine tao_floor_plan_struct_set_draw_only_first_pass(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_draw_only_first_pass')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_only_first_pass = value_in
  end subroutine

  ! tao_floor_plan_struct%draw_building_wall: 0D_NOT_logical

  subroutine tao_floor_plan_struct_get_draw_building_wall(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_draw_building_wall')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_building_wall
  end subroutine


  subroutine tao_floor_plan_struct_set_draw_building_wall(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_draw_building_wall')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_building_wall = value_in
  end subroutine

  ! tao_floor_plan_struct%orbit_scale: 0D_NOT_real

  subroutine tao_floor_plan_struct_get_orbit_scale(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_orbit_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%orbit_scale
  end subroutine


  subroutine tao_floor_plan_struct_set_orbit_scale(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_orbit_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%orbit_scale = value_in
  end subroutine

  ! tao_floor_plan_struct%orbit_color: 0D_NOT_character

  subroutine tao_floor_plan_struct_get_orbit_color_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_floor_plan_struct_get_orbit_color_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%orbit_color)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%orbit_color), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_floor_plan_struct_set_orbit_color(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_floor_plan_struct_set_orbit_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_floor_plan_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%orbit_color = str_in ! implicitly handles padding
  end subroutine

  ! tao_floor_plan_struct%orbit_pattern: 0D_NOT_character

  subroutine tao_floor_plan_struct_get_orbit_pattern_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_floor_plan_struct_get_orbit_pattern_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%orbit_pattern)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%orbit_pattern), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_floor_plan_struct_set_orbit_pattern(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_floor_plan_struct_set_orbit_pattern')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_floor_plan_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%orbit_pattern = str_in ! implicitly handles padding
  end subroutine

  ! tao_floor_plan_struct%orbit_lattice: 0D_NOT_character

  subroutine tao_floor_plan_struct_get_orbit_lattice_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_floor_plan_struct_get_orbit_lattice_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%orbit_lattice)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%orbit_lattice), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_floor_plan_struct_set_orbit_lattice(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_floor_plan_struct_set_orbit_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_floor_plan_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%orbit_lattice = str_in ! implicitly handles padding
  end subroutine

  ! tao_floor_plan_struct%orbit_width: 0D_NOT_integer

  subroutine tao_floor_plan_struct_get_orbit_width(struct_obj_ptr, value_out) bind(c, name='tao_floor_plan_struct_get_orbit_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%orbit_width
  end subroutine


  subroutine tao_floor_plan_struct_set_orbit_width(struct_obj_ptr, value_in) bind(c, name='tao_floor_plan_struct_set_orbit_width')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_floor_plan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%orbit_width = value_in
  end subroutine

  !! tao_v1_var_struct

    function allocate_fortran_tao_v1_var_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_v1_var_struct), pointer :: fptr
      type(tao_v1_var_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_v1_var_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_v1_var_struct), pointer :: fptr
      type(tao_v1_var_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_v1_var_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_v1_var_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_v1_var_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_v1_var_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_v1_var_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_v1_var_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_v1_var_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_v1_var_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_v1_var_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_v1_var_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_v1_var_struct%name: 0D_NOT_character

  subroutine tao_v1_var_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_v1_var_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_v1_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_v1_var_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_v1_var_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_v1_var_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_v1_var_struct%ix_v1_var: 0D_NOT_integer

  subroutine tao_v1_var_struct_get_ix_v1_var(struct_obj_ptr, value_out) bind(c, name='tao_v1_var_struct_get_ix_v1_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_v1_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_v1_var
  end subroutine


  subroutine tao_v1_var_struct_set_ix_v1_var(struct_obj_ptr, value_in) bind(c, name='tao_v1_var_struct_set_ix_v1_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_v1_var_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_v1_var = value_in
  end subroutine

  ! tao_v1_var_struct%v: 1D_PTR_type

  subroutine tao_v1_var_struct_get_v_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_v1_var_struct_get_v_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_v1_var_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%v) .and. is_contiguous(struct_obj%v)) then
      data_ptr = c_loc(struct_obj%v(lbound(struct_obj%v, 1)))
      bounds(1) = int(lbound(struct_obj%v, 1), c_int)
      bounds(2) = int(ubound(struct_obj%v, 1), c_int)
      
      el_size = int(storage_size(struct_obj%v(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_global_struct

    function allocate_fortran_tao_global_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_global_struct), pointer :: fptr
      type(tao_global_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_global_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_global_struct), pointer :: fptr
      type(tao_global_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_global_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_global_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_global_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_global_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_global_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_global_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_global_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_global_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_global_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_global_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_global_struct%beam_dead_cutoff: 0D_NOT_real

  subroutine tao_global_struct_get_beam_dead_cutoff(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_beam_dead_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beam_dead_cutoff
  end subroutine


  subroutine tao_global_struct_set_beam_dead_cutoff(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_beam_dead_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beam_dead_cutoff = value_in
  end subroutine

  ! tao_global_struct%lm_opt_deriv_reinit: 0D_NOT_real

  subroutine tao_global_struct_get_lm_opt_deriv_reinit(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_lm_opt_deriv_reinit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lm_opt_deriv_reinit
  end subroutine


  subroutine tao_global_struct_set_lm_opt_deriv_reinit(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_lm_opt_deriv_reinit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lm_opt_deriv_reinit = value_in
  end subroutine

  ! tao_global_struct%de_lm_step_ratio: 0D_NOT_real

  subroutine tao_global_struct_get_de_lm_step_ratio(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_de_lm_step_ratio')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%de_lm_step_ratio
  end subroutine


  subroutine tao_global_struct_set_de_lm_step_ratio(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_de_lm_step_ratio')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%de_lm_step_ratio = value_in
  end subroutine

  ! tao_global_struct%de_var_to_population_factor: 0D_NOT_real

  subroutine tao_global_struct_get_de_var_to_population_factor(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_de_var_to_population_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%de_var_to_population_factor
  end subroutine


  subroutine tao_global_struct_set_de_var_to_population_factor(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_de_var_to_population_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%de_var_to_population_factor = value_in
  end subroutine

  ! tao_global_struct%lmdif_eps: 0D_NOT_real

  subroutine tao_global_struct_get_lmdif_eps(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_lmdif_eps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lmdif_eps
  end subroutine


  subroutine tao_global_struct_set_lmdif_eps(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_lmdif_eps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lmdif_eps = value_in
  end subroutine

  ! tao_global_struct%lmdif_negligible_merit: 0D_NOT_real

  subroutine tao_global_struct_get_lmdif_negligible_merit(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_lmdif_negligible_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lmdif_negligible_merit
  end subroutine


  subroutine tao_global_struct_set_lmdif_negligible_merit(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_lmdif_negligible_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lmdif_negligible_merit = value_in
  end subroutine

  ! tao_global_struct%svd_cutoff: 0D_NOT_real

  subroutine tao_global_struct_get_svd_cutoff(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_svd_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%svd_cutoff
  end subroutine


  subroutine tao_global_struct_set_svd_cutoff(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_svd_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%svd_cutoff = value_in
  end subroutine

  ! tao_global_struct%unstable_penalty: 0D_NOT_real

  subroutine tao_global_struct_get_unstable_penalty(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_unstable_penalty')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%unstable_penalty
  end subroutine


  subroutine tao_global_struct_set_unstable_penalty(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_unstable_penalty')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%unstable_penalty = value_in
  end subroutine

  ! tao_global_struct%merit_stop_value: 0D_NOT_real

  subroutine tao_global_struct_get_merit_stop_value(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_merit_stop_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%merit_stop_value
  end subroutine


  subroutine tao_global_struct_set_merit_stop_value(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_merit_stop_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%merit_stop_value = value_in
  end subroutine

  ! tao_global_struct%dmerit_stop_value: 0D_NOT_real

  subroutine tao_global_struct_get_dmerit_stop_value(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_dmerit_stop_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dmerit_stop_value
  end subroutine


  subroutine tao_global_struct_set_dmerit_stop_value(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_dmerit_stop_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dmerit_stop_value = value_in
  end subroutine

  ! tao_global_struct%random_sigma_cutoff: 0D_NOT_real

  subroutine tao_global_struct_get_random_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_random_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%random_sigma_cutoff
  end subroutine


  subroutine tao_global_struct_set_random_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_random_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%random_sigma_cutoff = value_in
  end subroutine

  ! tao_global_struct%delta_e_chrom: 0D_NOT_real

  subroutine tao_global_struct_get_delta_e_chrom(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_delta_e_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%delta_e_chrom
  end subroutine


  subroutine tao_global_struct_set_delta_e_chrom(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_delta_e_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%delta_e_chrom = value_in
  end subroutine

  ! tao_global_struct%max_plot_time: 0D_NOT_real

  subroutine tao_global_struct_get_max_plot_time(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_max_plot_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_plot_time
  end subroutine


  subroutine tao_global_struct_set_max_plot_time(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_max_plot_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_plot_time = value_in
  end subroutine

  ! tao_global_struct%default_universe: 0D_NOT_integer

  subroutine tao_global_struct_get_default_universe(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_default_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_universe
  end subroutine


  subroutine tao_global_struct_set_default_universe(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_default_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_universe = value_in
  end subroutine

  ! tao_global_struct%default_branch: 0D_NOT_integer

  subroutine tao_global_struct_get_default_branch(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_default_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_branch
  end subroutine


  subroutine tao_global_struct_set_default_branch(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_default_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_branch = value_in
  end subroutine

  ! tao_global_struct%n_opti_cycles: 0D_NOT_integer

  subroutine tao_global_struct_get_n_opti_cycles(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_n_opti_cycles')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_opti_cycles
  end subroutine


  subroutine tao_global_struct_set_n_opti_cycles(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_n_opti_cycles')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_opti_cycles = value_in
  end subroutine

  ! tao_global_struct%n_opti_loops: 0D_NOT_integer

  subroutine tao_global_struct_get_n_opti_loops(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_n_opti_loops')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_opti_loops
  end subroutine


  subroutine tao_global_struct_set_n_opti_loops(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_n_opti_loops')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_opti_loops = value_in
  end subroutine

  ! tao_global_struct%n_threads: 0D_NOT_integer

  subroutine tao_global_struct_get_n_threads(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_n_threads')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_threads
  end subroutine


  subroutine tao_global_struct_set_n_threads(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_n_threads')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_threads = value_in
  end subroutine

  ! tao_global_struct%phase_units: 0D_NOT_integer

  subroutine tao_global_struct_get_phase_units(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_phase_units')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phase_units
  end subroutine


  subroutine tao_global_struct_set_phase_units(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_phase_units')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phase_units = value_in
  end subroutine

  ! tao_global_struct%bunch_to_plot: 0D_NOT_integer

  subroutine tao_global_struct_get_bunch_to_plot(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_bunch_to_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bunch_to_plot
  end subroutine


  subroutine tao_global_struct_set_bunch_to_plot(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_bunch_to_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bunch_to_plot = value_in
  end subroutine

  ! tao_global_struct%random_seed: 0D_NOT_integer

  subroutine tao_global_struct_get_random_seed(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_random_seed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%random_seed
  end subroutine


  subroutine tao_global_struct_set_random_seed(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_random_seed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%random_seed = value_in
  end subroutine

  ! tao_global_struct%n_top10_merit: 0D_NOT_integer

  subroutine tao_global_struct_get_n_top10_merit(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_n_top10_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_top10_merit
  end subroutine


  subroutine tao_global_struct_set_n_top10_merit(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_n_top10_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_top10_merit = value_in
  end subroutine

  ! tao_global_struct%srdt_gen_n_slices: 0D_NOT_integer

  subroutine tao_global_struct_get_srdt_gen_n_slices(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_srdt_gen_n_slices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%srdt_gen_n_slices
  end subroutine


  subroutine tao_global_struct_set_srdt_gen_n_slices(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_srdt_gen_n_slices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%srdt_gen_n_slices = value_in
  end subroutine

  ! tao_global_struct%datum_err_messages_max: 0D_NOT_integer

  subroutine tao_global_struct_get_datum_err_messages_max(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_datum_err_messages_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%datum_err_messages_max
  end subroutine


  subroutine tao_global_struct_set_datum_err_messages_max(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_datum_err_messages_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%datum_err_messages_max = value_in
  end subroutine

  ! tao_global_struct%srdt_sxt_n_slices: 0D_NOT_integer

  subroutine tao_global_struct_get_srdt_sxt_n_slices(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_srdt_sxt_n_slices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%srdt_sxt_n_slices
  end subroutine


  subroutine tao_global_struct_set_srdt_sxt_n_slices(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_srdt_sxt_n_slices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%srdt_sxt_n_slices = value_in
  end subroutine

  ! tao_global_struct%srdt_use_cache: 0D_NOT_logical

  subroutine tao_global_struct_get_srdt_use_cache(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_srdt_use_cache')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%srdt_use_cache
  end subroutine


  subroutine tao_global_struct_set_srdt_use_cache(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_srdt_use_cache')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%srdt_use_cache = value_in
  end subroutine

  ! tao_global_struct%quiet: 0D_NOT_character

  subroutine tao_global_struct_get_quiet_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_quiet_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%quiet)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%quiet), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_quiet(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_quiet')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%quiet = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%random_engine: 0D_NOT_character

  subroutine tao_global_struct_get_random_engine_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_random_engine_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%random_engine)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%random_engine), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_random_engine(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_random_engine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%random_engine = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%random_gauss_converter: 0D_NOT_character

  subroutine tao_global_struct_get_random_gauss_converter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_random_gauss_converter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%random_gauss_converter)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%random_gauss_converter), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_random_gauss_converter(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_random_gauss_converter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%random_gauss_converter = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%track_type: 0D_NOT_character

  subroutine tao_global_struct_get_track_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_track_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%track_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%track_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_track_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_track_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%track_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%lat_sigma_calc_uses_emit_from: 0D_NOT_character

  subroutine tao_global_struct_get_lat_sigma_calc_uses_emit_from_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_lat_sigma_calc_uses_emit_from_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%lat_sigma_calc_uses_emit_from)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%lat_sigma_calc_uses_emit_from), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_lat_sigma_calc_uses_emit_from(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_lat_sigma_calc_uses_emit_from')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%lat_sigma_calc_uses_emit_from = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%prompt_string: 0D_NOT_character

  subroutine tao_global_struct_get_prompt_string_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_prompt_string_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%prompt_string)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%prompt_string), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_prompt_string(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_prompt_string')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%prompt_string = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%prompt_color: 0D_NOT_character

  subroutine tao_global_struct_get_prompt_color_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_prompt_color_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%prompt_color)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%prompt_color), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_prompt_color(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_prompt_color')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%prompt_color = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%optimizer: 0D_NOT_character

  subroutine tao_global_struct_get_optimizer_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_optimizer_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%optimizer)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%optimizer), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_optimizer(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_optimizer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%optimizer = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%print_command: 0D_NOT_character

  subroutine tao_global_struct_get_print_command_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_print_command_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%print_command)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%print_command), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_print_command(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_print_command')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%print_command = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%var_out_file: 0D_NOT_character

  subroutine tao_global_struct_get_var_out_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_var_out_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%var_out_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%var_out_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_var_out_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_var_out_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%var_out_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%history_file: 0D_NOT_character

  subroutine tao_global_struct_get_history_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_global_struct_get_history_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%history_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%history_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_global_struct_set_history_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_global_struct_set_history_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_global_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%history_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_global_struct%beam_timer_on: 0D_NOT_logical

  subroutine tao_global_struct_get_beam_timer_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_beam_timer_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beam_timer_on
  end subroutine


  subroutine tao_global_struct_set_beam_timer_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_beam_timer_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beam_timer_on = value_in
  end subroutine

  ! tao_global_struct%box_plots: 0D_NOT_logical

  subroutine tao_global_struct_get_box_plots(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_box_plots')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%box_plots
  end subroutine


  subroutine tao_global_struct_set_box_plots(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_box_plots')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%box_plots = value_in
  end subroutine

  ! tao_global_struct%blank_line_between_commands: 0D_NOT_logical

  subroutine tao_global_struct_get_blank_line_between_commands(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_blank_line_between_commands')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%blank_line_between_commands
  end subroutine


  subroutine tao_global_struct_set_blank_line_between_commands(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_blank_line_between_commands')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%blank_line_between_commands = value_in
  end subroutine

  ! tao_global_struct%cmd_file_abort_on_error: 0D_NOT_logical

  subroutine tao_global_struct_get_cmd_file_abort_on_error(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_cmd_file_abort_on_error')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cmd_file_abort_on_error
  end subroutine


  subroutine tao_global_struct_set_cmd_file_abort_on_error(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_cmd_file_abort_on_error')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cmd_file_abort_on_error = value_in
  end subroutine

  ! tao_global_struct%concatenate_maps: 0D_NOT_logical

  subroutine tao_global_struct_get_concatenate_maps(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_concatenate_maps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%concatenate_maps
  end subroutine


  subroutine tao_global_struct_set_concatenate_maps(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_concatenate_maps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%concatenate_maps = value_in
  end subroutine

  ! tao_global_struct%derivative_recalc: 0D_NOT_logical

  subroutine tao_global_struct_get_derivative_recalc(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_derivative_recalc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%derivative_recalc
  end subroutine


  subroutine tao_global_struct_set_derivative_recalc(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_derivative_recalc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%derivative_recalc = value_in
  end subroutine

  ! tao_global_struct%derivative_uses_design: 0D_NOT_logical

  subroutine tao_global_struct_get_derivative_uses_design(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_derivative_uses_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%derivative_uses_design
  end subroutine


  subroutine tao_global_struct_set_derivative_uses_design(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_derivative_uses_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%derivative_uses_design = value_in
  end subroutine

  ! tao_global_struct%disable_smooth_line_calc: 0D_NOT_logical

  subroutine tao_global_struct_get_disable_smooth_line_calc(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_disable_smooth_line_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%disable_smooth_line_calc
  end subroutine


  subroutine tao_global_struct_set_disable_smooth_line_calc(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_disable_smooth_line_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%disable_smooth_line_calc = value_in
  end subroutine

  ! tao_global_struct%draw_curve_off_scale_warn: 0D_NOT_logical

  subroutine tao_global_struct_get_draw_curve_off_scale_warn(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_draw_curve_off_scale_warn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_curve_off_scale_warn
  end subroutine


  subroutine tao_global_struct_set_draw_curve_off_scale_warn(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_draw_curve_off_scale_warn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_curve_off_scale_warn = value_in
  end subroutine

  ! tao_global_struct%external_plotting: 0D_NOT_logical

  subroutine tao_global_struct_get_external_plotting(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_external_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%external_plotting
  end subroutine


  subroutine tao_global_struct_set_external_plotting(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_external_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%external_plotting = value_in
  end subroutine

  ! tao_global_struct%label_lattice_elements: 0D_NOT_logical

  subroutine tao_global_struct_get_label_lattice_elements(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_label_lattice_elements')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%label_lattice_elements
  end subroutine


  subroutine tao_global_struct_set_label_lattice_elements(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_label_lattice_elements')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%label_lattice_elements = value_in
  end subroutine

  ! tao_global_struct%label_keys: 0D_NOT_logical

  subroutine tao_global_struct_get_label_keys(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_label_keys')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%label_keys
  end subroutine


  subroutine tao_global_struct_set_label_keys(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_label_keys')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%label_keys = value_in
  end subroutine

  ! tao_global_struct%lattice_calc_on: 0D_NOT_logical

  subroutine tao_global_struct_get_lattice_calc_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_lattice_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lattice_calc_on
  end subroutine


  subroutine tao_global_struct_set_lattice_calc_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_lattice_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lattice_calc_on = value_in
  end subroutine

  ! tao_global_struct%only_limit_opt_vars: 0D_NOT_logical

  subroutine tao_global_struct_get_only_limit_opt_vars(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_only_limit_opt_vars')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%only_limit_opt_vars
  end subroutine


  subroutine tao_global_struct_set_only_limit_opt_vars(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_only_limit_opt_vars')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%only_limit_opt_vars = value_in
  end subroutine

  ! tao_global_struct%opt_with_ref: 0D_NOT_logical

  subroutine tao_global_struct_get_opt_with_ref(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_opt_with_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%opt_with_ref
  end subroutine


  subroutine tao_global_struct_set_opt_with_ref(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_opt_with_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%opt_with_ref = value_in
  end subroutine

  ! tao_global_struct%opt_with_base: 0D_NOT_logical

  subroutine tao_global_struct_get_opt_with_base(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_opt_with_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%opt_with_base
  end subroutine


  subroutine tao_global_struct_set_opt_with_base(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_opt_with_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%opt_with_base = value_in
  end subroutine

  ! tao_global_struct%opt_match_auto_recalc: 0D_NOT_logical

  subroutine tao_global_struct_get_opt_match_auto_recalc(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_opt_match_auto_recalc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%opt_match_auto_recalc
  end subroutine


  subroutine tao_global_struct_set_opt_match_auto_recalc(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_opt_match_auto_recalc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%opt_match_auto_recalc = value_in
  end subroutine

  ! tao_global_struct%opti_write_var_file: 0D_NOT_logical

  subroutine tao_global_struct_get_opti_write_var_file(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_opti_write_var_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%opti_write_var_file
  end subroutine


  subroutine tao_global_struct_set_opti_write_var_file(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_opti_write_var_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%opti_write_var_file = value_in
  end subroutine

  ! tao_global_struct%optimizer_allow_user_abort: 0D_NOT_logical

  subroutine tao_global_struct_get_optimizer_allow_user_abort(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_optimizer_allow_user_abort')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%optimizer_allow_user_abort
  end subroutine


  subroutine tao_global_struct_set_optimizer_allow_user_abort(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_optimizer_allow_user_abort')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%optimizer_allow_user_abort = value_in
  end subroutine

  ! tao_global_struct%optimizer_var_limit_warn: 0D_NOT_logical

  subroutine tao_global_struct_get_optimizer_var_limit_warn(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_optimizer_var_limit_warn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%optimizer_var_limit_warn
  end subroutine


  subroutine tao_global_struct_set_optimizer_var_limit_warn(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_optimizer_var_limit_warn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%optimizer_var_limit_warn = value_in
  end subroutine

  ! tao_global_struct%plot_on: 0D_NOT_logical

  subroutine tao_global_struct_get_plot_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_plot_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%plot_on
  end subroutine


  subroutine tao_global_struct_set_plot_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_plot_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%plot_on = value_in
  end subroutine

  ! tao_global_struct%rad_int_user_calc_on: 0D_NOT_logical

  subroutine tao_global_struct_get_rad_int_user_calc_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_rad_int_user_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_user_calc_on
  end subroutine


  subroutine tao_global_struct_set_rad_int_user_calc_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_rad_int_user_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_user_calc_on = value_in
  end subroutine

  ! tao_global_struct%rf_on: 0D_NOT_logical

  subroutine tao_global_struct_get_rf_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_rf_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_on
  end subroutine


  subroutine tao_global_struct_set_rf_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_rf_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_on = value_in
  end subroutine

  ! tao_global_struct%single_step: 0D_NOT_logical

  subroutine tao_global_struct_get_single_step(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_single_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%single_step
  end subroutine


  subroutine tao_global_struct_set_single_step(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_single_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%single_step = value_in
  end subroutine

  ! tao_global_struct%stop_on_error: 0D_NOT_logical

  subroutine tao_global_struct_get_stop_on_error(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_stop_on_error')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stop_on_error
  end subroutine


  subroutine tao_global_struct_set_stop_on_error(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_stop_on_error')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stop_on_error = value_in
  end subroutine

  ! tao_global_struct%svd_retreat_on_merit_increase: 0D_NOT_logical

  subroutine tao_global_struct_get_svd_retreat_on_merit_increase(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_svd_retreat_on_merit_increase')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%svd_retreat_on_merit_increase
  end subroutine


  subroutine tao_global_struct_set_svd_retreat_on_merit_increase(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_svd_retreat_on_merit_increase')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%svd_retreat_on_merit_increase = value_in
  end subroutine

  ! tao_global_struct%var_limits_on: 0D_NOT_logical

  subroutine tao_global_struct_get_var_limits_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_var_limits_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%var_limits_on
  end subroutine


  subroutine tao_global_struct_set_var_limits_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_var_limits_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%var_limits_on = value_in
  end subroutine

  ! tao_global_struct%wait_for_CR_in_single_mode: 0D_NOT_logical

  subroutine tao_global_struct_get_wait_for_CR_in_single_mode(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_wait_for_CR_in_single_mode')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%wait_for_CR_in_single_mode
  end subroutine


  subroutine tao_global_struct_set_wait_for_CR_in_single_mode(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_wait_for_CR_in_single_mode')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%wait_for_CR_in_single_mode = value_in
  end subroutine

  ! tao_global_struct%symbol_import: 0D_NOT_logical

  subroutine tao_global_struct_get_symbol_import(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_symbol_import')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%symbol_import
  end subroutine


  subroutine tao_global_struct_set_symbol_import(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_symbol_import')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%symbol_import = value_in
  end subroutine

  ! tao_global_struct%debug_on: 0D_NOT_logical

  subroutine tao_global_struct_get_debug_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_debug_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%debug_on
  end subroutine


  subroutine tao_global_struct_set_debug_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_debug_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%debug_on = value_in
  end subroutine

  ! tao_global_struct%expression_tree_on: 0D_NOT_logical

  subroutine tao_global_struct_get_expression_tree_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_expression_tree_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%expression_tree_on
  end subroutine


  subroutine tao_global_struct_set_expression_tree_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_expression_tree_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%expression_tree_on = value_in
  end subroutine

  ! tao_global_struct%verbose_on: 0D_NOT_logical

  subroutine tao_global_struct_get_verbose_on(struct_obj_ptr, value_out) bind(c, name='tao_global_struct_get_verbose_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%verbose_on
  end subroutine


  subroutine tao_global_struct_set_verbose_on(struct_obj_ptr, value_in) bind(c, name='tao_global_struct_set_verbose_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_global_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%verbose_on = value_in
  end subroutine

  !! tao_init_struct

    function allocate_fortran_tao_init_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_init_struct), pointer :: fptr
      type(tao_init_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_init_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_init_struct), pointer :: fptr
      type(tao_init_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_init_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_init_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_init_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_init_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_init_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_init_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_init_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_init_struct%parse_cmd_args: 0D_NOT_logical

  subroutine tao_init_struct_get_parse_cmd_args(struct_obj_ptr, value_out) bind(c, name='tao_init_struct_get_parse_cmd_args')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%parse_cmd_args
  end subroutine


  subroutine tao_init_struct_set_parse_cmd_args(struct_obj_ptr, value_in) bind(c, name='tao_init_struct_set_parse_cmd_args')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%parse_cmd_args = value_in
  end subroutine

  ! tao_init_struct%debug_switch: 0D_NOT_logical

  subroutine tao_init_struct_get_debug_switch(struct_obj_ptr, value_out) bind(c, name='tao_init_struct_get_debug_switch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%debug_switch
  end subroutine


  subroutine tao_init_struct_set_debug_switch(struct_obj_ptr, value_in) bind(c, name='tao_init_struct_set_debug_switch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%debug_switch = value_in
  end subroutine

  ! tao_init_struct%external_plotting_switch: 0D_NOT_logical

  subroutine tao_init_struct_get_external_plotting_switch(struct_obj_ptr, value_out) bind(c, name='tao_init_struct_get_external_plotting_switch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%external_plotting_switch
  end subroutine


  subroutine tao_init_struct_set_external_plotting_switch(struct_obj_ptr, value_in) bind(c, name='tao_init_struct_set_external_plotting_switch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%external_plotting_switch = value_in
  end subroutine

  ! tao_init_struct%init_name: 0D_NOT_character

  subroutine tao_init_struct_get_init_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_init_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%init_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%init_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_init_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_init_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%init_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_init_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_init_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_init_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_init_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_init_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_init_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_init_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_init_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_lat_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_lat_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_lat_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_lat_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_lat_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_lat_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_lat_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_lat_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_beam_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_beam_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_beam_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_beam_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_beam_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_beam_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_beam_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_beam_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_data_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_data_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_data_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_data_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_data_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_data_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_data_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_data_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_plot_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_plot_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_plot_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_plot_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_plot_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_plot_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_plot_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_plot_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_startup_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_startup_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_startup_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_startup_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_startup_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_startup_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_startup_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_startup_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_var_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_var_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_var_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_var_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_var_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_var_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_var_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_var_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_building_wall_file: 0D_NOT_character

  subroutine tao_init_struct_get_hook_building_wall_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_building_wall_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_building_wall_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_building_wall_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_building_wall_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_building_wall_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_building_wall_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%init_file_arg_path: 0D_NOT_character

  subroutine tao_init_struct_get_init_file_arg_path_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_init_file_arg_path_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%init_file_arg_path)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%init_file_arg_path), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_init_file_arg_path(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_init_file_arg_path')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%init_file_arg_path = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%lattice_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_lattice_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_lattice_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%lattice_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%lattice_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_lattice_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_lattice_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%lattice_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%hook_init_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_hook_init_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_hook_init_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%hook_init_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%hook_init_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_hook_init_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_hook_init_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%hook_init_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%init_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_init_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_init_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%init_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%init_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_init_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_init_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%init_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%beam_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_beam_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_beam_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%beam_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%beam_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_beam_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_beam_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%beam_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%beam_init_position_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_beam_init_position_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_beam_init_position_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%beam_init_position_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%beam_init_position_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_beam_init_position_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_beam_init_position_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%beam_init_position_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%command_arg: 0D_NOT_character

  subroutine tao_init_struct_get_command_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_command_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%command_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%command_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_command_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_command_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%command_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%data_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_data_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_data_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_data_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_data_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%plot_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_plot_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_plot_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%plot_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%plot_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_plot_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_plot_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%plot_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%startup_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_startup_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_startup_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%startup_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%startup_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_startup_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_startup_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%startup_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%var_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_var_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_var_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%var_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%var_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_var_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_var_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%var_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%building_wall_file_arg: 0D_NOT_character

  subroutine tao_init_struct_get_building_wall_file_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_building_wall_file_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%building_wall_file_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%building_wall_file_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_building_wall_file_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_building_wall_file_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%building_wall_file_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%geometry_arg: 0D_NOT_character

  subroutine tao_init_struct_get_geometry_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_geometry_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%geometry_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%geometry_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_geometry_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_geometry_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%geometry_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%slice_lattice_arg: 0D_NOT_character

  subroutine tao_init_struct_get_slice_lattice_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_slice_lattice_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%slice_lattice_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%slice_lattice_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_slice_lattice_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_slice_lattice_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%slice_lattice_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%start_branch_at_arg: 0D_NOT_character

  subroutine tao_init_struct_get_start_branch_at_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_start_branch_at_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%start_branch_at_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%start_branch_at_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_start_branch_at_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_start_branch_at_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%start_branch_at_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%log_startup_arg: 0D_NOT_character

  subroutine tao_init_struct_get_log_startup_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_log_startup_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%log_startup_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%log_startup_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_log_startup_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_log_startup_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%log_startup_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%no_stopping_arg: 0D_NOT_character

  subroutine tao_init_struct_get_no_stopping_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_no_stopping_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%no_stopping_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%no_stopping_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_no_stopping_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_no_stopping_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%no_stopping_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%noplot_arg: 0D_NOT_character

  subroutine tao_init_struct_get_noplot_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_noplot_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%noplot_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%noplot_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_noplot_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_noplot_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%noplot_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%no_rad_int_arg: 0D_NOT_character

  subroutine tao_init_struct_get_no_rad_int_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_no_rad_int_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%no_rad_int_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%no_rad_int_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_no_rad_int_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_no_rad_int_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%no_rad_int_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%reverse_arg: 0D_NOT_character

  subroutine tao_init_struct_get_reverse_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_reverse_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%reverse_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%reverse_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_reverse_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_reverse_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%reverse_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%debug_arg: 0D_NOT_character

  subroutine tao_init_struct_get_debug_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_debug_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%debug_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%debug_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_debug_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_debug_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%debug_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%disable_smooth_line_calc_arg: 0D_NOT_character

  subroutine tao_init_struct_get_disable_smooth_line_calc_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_disable_smooth_line_calc_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%disable_smooth_line_calc_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%disable_smooth_line_calc_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_disable_smooth_line_calc_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_disable_smooth_line_calc_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%disable_smooth_line_calc_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%rf_on_arg: 0D_NOT_character

  subroutine tao_init_struct_get_rf_on_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_rf_on_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%rf_on_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%rf_on_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_rf_on_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_rf_on_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%rf_on_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%prompt_color_arg: 0D_NOT_character

  subroutine tao_init_struct_get_prompt_color_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_prompt_color_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%prompt_color_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%prompt_color_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_prompt_color_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_prompt_color_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%prompt_color_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%quiet_arg: 0D_NOT_character

  subroutine tao_init_struct_get_quiet_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_quiet_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%quiet_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%quiet_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_quiet_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_quiet_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%quiet_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%noinit_arg: 0D_NOT_character

  subroutine tao_init_struct_get_noinit_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_noinit_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%noinit_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%noinit_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_noinit_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_noinit_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%noinit_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%nostartup_arg: 0D_NOT_character

  subroutine tao_init_struct_get_nostartup_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_nostartup_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%nostartup_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%nostartup_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_nostartup_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_nostartup_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%nostartup_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%symbol_import_arg: 0D_NOT_character

  subroutine tao_init_struct_get_symbol_import_arg_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_symbol_import_arg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%symbol_import_arg)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%symbol_import_arg), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_symbol_import_arg(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_symbol_import_arg')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%symbol_import_arg = str_in ! implicitly handles padding
  end subroutine

  ! tao_init_struct%unique_name_suffix: 0D_NOT_character

  subroutine tao_init_struct_get_unique_name_suffix_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_init_struct_get_unique_name_suffix_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%unique_name_suffix)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%unique_name_suffix), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_init_struct_set_unique_name_suffix(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_init_struct_set_unique_name_suffix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%unique_name_suffix = str_in ! implicitly handles padding
  end subroutine

  !! tao_common_struct

    function allocate_fortran_tao_common_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_common_struct), pointer :: fptr
      type(tao_common_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_common_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_common_struct), pointer :: fptr
      type(tao_common_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_common_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_common_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_common_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_common_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_common_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_common_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_common_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_common_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_common_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_common_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_common_struct%plot_place_buffer: 1D_ALLOC_type

  subroutine tao_common_struct_get_plot_place_buffer_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_common_struct_get_plot_place_buffer_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%plot_place_buffer) .and. is_contiguous(struct_obj%plot_place_buffer)) then
      data_ptr = c_loc(struct_obj%plot_place_buffer(lbound(struct_obj%plot_place_buffer, 1)))
      bounds(1) = int(lbound(struct_obj%plot_place_buffer, 1), c_int)
      bounds(2) = int(ubound(struct_obj%plot_place_buffer, 1), c_int)
      
      el_size = int(storage_size(struct_obj%plot_place_buffer(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_common_struct%covar: 2D_ALLOC_real

  subroutine tao_common_struct_get_covar_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_common_struct_get_covar_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%covar) .and. is_contiguous(struct_obj%covar)) then
      data_ptr = c_loc(struct_obj%covar(lbound(struct_obj%covar, 1), lbound(struct_obj%covar, 2)))
      bounds(1) = int(lbound(struct_obj%covar, 1), c_int)
      bounds(2) = int(ubound(struct_obj%covar, 1), c_int)
      bounds(3) = int(lbound(struct_obj%covar, 2), c_int)
      bounds(4) = int(ubound(struct_obj%covar, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_common_struct%alpha: 2D_ALLOC_real

  subroutine tao_common_struct_get_alpha_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_common_struct_get_alpha_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%alpha) .and. is_contiguous(struct_obj%alpha)) then
      data_ptr = c_loc(struct_obj%alpha(lbound(struct_obj%alpha, 1), lbound(struct_obj%alpha, 2)))
      bounds(1) = int(lbound(struct_obj%alpha, 1), c_int)
      bounds(2) = int(ubound(struct_obj%alpha, 1), c_int)
      bounds(3) = int(lbound(struct_obj%alpha, 2), c_int)
      bounds(4) = int(ubound(struct_obj%alpha, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_common_struct%dummy_target: 0D_NOT_real

  subroutine tao_common_struct_get_dummy_target(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_dummy_target')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dummy_target
  end subroutine


  subroutine tao_common_struct_set_dummy_target(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_dummy_target')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dummy_target = value_in
  end subroutine

  ! tao_common_struct%n_alias: 0D_NOT_integer

  subroutine tao_common_struct_get_n_alias(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_n_alias')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_alias
  end subroutine


  subroutine tao_common_struct_set_n_alias(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_n_alias')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_alias = value_in
  end subroutine

  ! tao_common_struct%cmd_file_level: 0D_NOT_integer

  subroutine tao_common_struct_get_cmd_file_level(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_cmd_file_level')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cmd_file_level
  end subroutine


  subroutine tao_common_struct_set_cmd_file_level(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_cmd_file_level')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cmd_file_level = value_in
  end subroutine

  ! tao_common_struct%ix_key_bank: 0D_NOT_integer

  subroutine tao_common_struct_get_ix_key_bank(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_ix_key_bank')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_key_bank
  end subroutine


  subroutine tao_common_struct_set_ix_key_bank(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_ix_key_bank')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_key_bank = value_in
  end subroutine

  ! tao_common_struct%ix_history: 0D_NOT_integer

  subroutine tao_common_struct_get_ix_history(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_ix_history')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_history
  end subroutine


  subroutine tao_common_struct_set_ix_history(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_ix_history')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_history = value_in
  end subroutine

  ! tao_common_struct%n_history: 0D_NOT_integer

  subroutine tao_common_struct_get_n_history(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_n_history')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_history
  end subroutine


  subroutine tao_common_struct_set_n_history(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_n_history')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_history = value_in
  end subroutine

  ! tao_common_struct%lev_loop: 0D_NOT_integer

  subroutine tao_common_struct_get_lev_loop(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_lev_loop')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lev_loop
  end subroutine


  subroutine tao_common_struct_set_lev_loop(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_lev_loop')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lev_loop = value_in
  end subroutine

  ! tao_common_struct%n_err_messages_printed: 0D_NOT_integer

  subroutine tao_common_struct_get_n_err_messages_printed(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_n_err_messages_printed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_err_messages_printed
  end subroutine


  subroutine tao_common_struct_set_n_err_messages_printed(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_n_err_messages_printed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_err_messages_printed = value_in
  end subroutine

  ! tao_common_struct%n_universes: 0D_NOT_integer

  subroutine tao_common_struct_get_n_universes(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_n_universes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_universes
  end subroutine


  subroutine tao_common_struct_set_n_universes(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_n_universes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_universes = value_in
  end subroutine

  ! tao_common_struct%ix_beam_track_active_element: 0D_NOT_integer

  subroutine tao_common_struct_get_ix_beam_track_active_element(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_ix_beam_track_active_element')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_beam_track_active_element
  end subroutine


  subroutine tao_common_struct_set_ix_beam_track_active_element(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_ix_beam_track_active_element')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_beam_track_active_element = value_in
  end subroutine

  ! tao_common_struct%cmd_file_paused: 0D_NOT_logical

  subroutine tao_common_struct_get_cmd_file_paused(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_cmd_file_paused')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cmd_file_paused
  end subroutine


  subroutine tao_common_struct_set_cmd_file_paused(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_cmd_file_paused')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cmd_file_paused = value_in
  end subroutine

  ! tao_common_struct%use_cmd_here: 0D_NOT_logical

  subroutine tao_common_struct_get_use_cmd_here(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_use_cmd_here')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_cmd_here
  end subroutine


  subroutine tao_common_struct_set_use_cmd_here(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_use_cmd_here')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_cmd_here = value_in
  end subroutine

  ! tao_common_struct%cmd_from_cmd_file: 0D_NOT_logical

  subroutine tao_common_struct_get_cmd_from_cmd_file(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_cmd_from_cmd_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cmd_from_cmd_file
  end subroutine


  subroutine tao_common_struct_set_cmd_from_cmd_file(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_cmd_from_cmd_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cmd_from_cmd_file = value_in
  end subroutine

  ! tao_common_struct%use_saved_beam_in_tracking: 0D_NOT_logical

  subroutine tao_common_struct_get_use_saved_beam_in_tracking(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_use_saved_beam_in_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_saved_beam_in_tracking
  end subroutine


  subroutine tao_common_struct_set_use_saved_beam_in_tracking(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_use_saved_beam_in_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_saved_beam_in_tracking = value_in
  end subroutine

  ! tao_common_struct%single_mode: 0D_NOT_logical

  subroutine tao_common_struct_get_single_mode(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_single_mode')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%single_mode
  end subroutine


  subroutine tao_common_struct_set_single_mode(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_single_mode')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%single_mode = value_in
  end subroutine

  ! tao_common_struct%combine_consecutive_elements_of_like_name: 0D_NOT_logical

  subroutine tao_common_struct_get_combine_consecutive_elements_of_like_name(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_combine_consecutive_elements_of_like_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%combine_consecutive_elements_of_like_name
  end subroutine


  subroutine tao_common_struct_set_combine_consecutive_elements_of_like_name(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_combine_consecutive_elements_of_like_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%combine_consecutive_elements_of_like_name = value_in
  end subroutine

  ! tao_common_struct%have_tracked_beam: 0D_NOT_logical

  subroutine tao_common_struct_get_have_tracked_beam(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_have_tracked_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%have_tracked_beam
  end subroutine


  subroutine tao_common_struct_set_have_tracked_beam(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_have_tracked_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%have_tracked_beam = value_in
  end subroutine

  ! tao_common_struct%init_plot_needed: 0D_NOT_logical

  subroutine tao_common_struct_get_init_plot_needed(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_init_plot_needed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_plot_needed
  end subroutine


  subroutine tao_common_struct_set_init_plot_needed(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_init_plot_needed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_plot_needed = value_in
  end subroutine

  ! tao_common_struct%init_beam: 0D_NOT_logical

  subroutine tao_common_struct_get_init_beam(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_init_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_beam
  end subroutine


  subroutine tao_common_struct_set_init_beam(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_init_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_beam = value_in
  end subroutine

  ! tao_common_struct%init_var: 0D_NOT_logical

  subroutine tao_common_struct_get_init_var(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_init_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_var
  end subroutine


  subroutine tao_common_struct_set_init_var(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_init_var')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_var = value_in
  end subroutine

  ! tao_common_struct%init_read_lat_info: 0D_NOT_logical

  subroutine tao_common_struct_get_init_read_lat_info(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_init_read_lat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_read_lat_info
  end subroutine


  subroutine tao_common_struct_set_init_read_lat_info(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_init_read_lat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_read_lat_info = value_in
  end subroutine

  ! tao_common_struct%optimizer_running: 0D_NOT_logical

  subroutine tao_common_struct_get_optimizer_running(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_optimizer_running')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%optimizer_running
  end subroutine


  subroutine tao_common_struct_set_optimizer_running(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_optimizer_running')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%optimizer_running = value_in
  end subroutine

  ! tao_common_struct%have_datums_using_expressions: 0D_NOT_logical

  subroutine tao_common_struct_get_have_datums_using_expressions(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_have_datums_using_expressions')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%have_datums_using_expressions
  end subroutine


  subroutine tao_common_struct_set_have_datums_using_expressions(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_have_datums_using_expressions')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%have_datums_using_expressions = value_in
  end subroutine

  ! tao_common_struct%print_to_terminal: 0D_NOT_logical

  subroutine tao_common_struct_get_print_to_terminal(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_print_to_terminal')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%print_to_terminal
  end subroutine


  subroutine tao_common_struct_set_print_to_terminal(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_print_to_terminal')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%print_to_terminal = value_in
  end subroutine

  ! tao_common_struct%lattice_calc_done: 0D_NOT_logical

  subroutine tao_common_struct_get_lattice_calc_done(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_lattice_calc_done')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lattice_calc_done
  end subroutine


  subroutine tao_common_struct_set_lattice_calc_done(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_lattice_calc_done')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lattice_calc_done = value_in
  end subroutine

  ! tao_common_struct%add_measurement_noise: 0D_NOT_logical

  subroutine tao_common_struct_get_add_measurement_noise(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_add_measurement_noise')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%add_measurement_noise
  end subroutine


  subroutine tao_common_struct_set_add_measurement_noise(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_add_measurement_noise')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%add_measurement_noise = value_in
  end subroutine

  ! skipped tao_common_struct%is_err_message_printed: Unsupported type: 1D_NOT_logical
  ! tao_common_struct%command_arg_has_been_executed: 0D_NOT_logical

  subroutine tao_common_struct_get_command_arg_has_been_executed(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_command_arg_has_been_executed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%command_arg_has_been_executed
  end subroutine


  subroutine tao_common_struct_set_command_arg_has_been_executed(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_command_arg_has_been_executed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%command_arg_has_been_executed = value_in
  end subroutine

  ! tao_common_struct%all_merit_weights_positive: 0D_NOT_logical

  subroutine tao_common_struct_get_all_merit_weights_positive(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_all_merit_weights_positive')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%all_merit_weights_positive
  end subroutine


  subroutine tao_common_struct_set_all_merit_weights_positive(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_all_merit_weights_positive')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%all_merit_weights_positive = value_in
  end subroutine

  ! tao_common_struct%multi_turn_orbit_is_plotted: 0D_NOT_logical

  subroutine tao_common_struct_get_multi_turn_orbit_is_plotted(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_multi_turn_orbit_is_plotted')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%multi_turn_orbit_is_plotted
  end subroutine


  subroutine tao_common_struct_set_multi_turn_orbit_is_plotted(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_multi_turn_orbit_is_plotted')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%multi_turn_orbit_is_plotted = value_in
  end subroutine

  ! tao_common_struct%force_chrom_calc: 0D_NOT_logical

  subroutine tao_common_struct_get_force_chrom_calc(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_force_chrom_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%force_chrom_calc
  end subroutine


  subroutine tao_common_struct_set_force_chrom_calc(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_force_chrom_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%force_chrom_calc = value_in
  end subroutine

  ! tao_common_struct%force_rad_int_calc: 0D_NOT_logical

  subroutine tao_common_struct_get_force_rad_int_calc(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_force_rad_int_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%force_rad_int_calc
  end subroutine


  subroutine tao_common_struct_set_force_rad_int_calc(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_force_rad_int_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%force_rad_int_calc = value_in
  end subroutine

  ! tao_common_struct%rad_int_ri_calc_on: 0D_NOT_logical

  subroutine tao_common_struct_get_rad_int_ri_calc_on(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_rad_int_ri_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_ri_calc_on
  end subroutine


  subroutine tao_common_struct_set_rad_int_ri_calc_on(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_rad_int_ri_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_ri_calc_on = value_in
  end subroutine

  ! tao_common_struct%rad_int_6d_calc_on: 0D_NOT_logical

  subroutine tao_common_struct_get_rad_int_6d_calc_on(struct_obj_ptr, value_out) bind(c, name='tao_common_struct_get_rad_int_6d_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_6d_calc_on
  end subroutine


  subroutine tao_common_struct_set_rad_int_6d_calc_on(struct_obj_ptr, value_in) bind(c, name='tao_common_struct_set_rad_int_6d_calc_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_6d_calc_on = value_in
  end subroutine

  ! tao_common_struct%valid_plot_who: 1D_NOT_character

  subroutine tao_common_struct_get_valid_plot_who_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='tao_common_struct_get_valid_plot_who_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true.) then
      data_ptr = c_loc(struct_obj%valid_plot_who(lbound(struct_obj%valid_plot_who, 1)))
      bounds(1) = int(lbound(struct_obj%valid_plot_who, 1), c_int)
      bounds(2) = int(ubound(struct_obj%valid_plot_who, 1), c_int)
      str_len = int(len(struct_obj%valid_plot_who), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_common_struct%single_mode_buffer: 0D_NOT_character

  subroutine tao_common_struct_get_single_mode_buffer_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_common_struct_get_single_mode_buffer_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%single_mode_buffer)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%single_mode_buffer), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_common_struct_set_single_mode_buffer(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_common_struct_set_single_mode_buffer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_common_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%single_mode_buffer = str_in ! implicitly handles padding
  end subroutine

  ! tao_common_struct%cmd: 0D_NOT_character

  subroutine tao_common_struct_get_cmd_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_common_struct_get_cmd_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%cmd)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%cmd), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_common_struct_set_cmd(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_common_struct_set_cmd')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_common_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%cmd = str_in ! implicitly handles padding
  end subroutine

  ! tao_common_struct%saved_cmd_line: 0D_NOT_character

  subroutine tao_common_struct_get_saved_cmd_line_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_common_struct_get_saved_cmd_line_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%saved_cmd_line)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%saved_cmd_line), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_common_struct_set_saved_cmd_line(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_common_struct_set_saved_cmd_line')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_common_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%saved_cmd_line = str_in ! implicitly handles padding
  end subroutine

  !! tao_plot_page_struct

    function allocate_fortran_tao_plot_page_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_plot_page_struct), pointer :: fptr
      type(tao_plot_page_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_plot_page_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_plot_page_struct), pointer :: fptr
      type(tao_plot_page_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_plot_page_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_plot_page_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_plot_page_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_plot_page_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_plot_page_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_plot_page_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_plot_page_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_plot_page_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_plot_page_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_plot_page_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_plot_page_struct%title: 0D_NOT_type

  subroutine tao_plot_page_struct_get_title(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_page_struct_get_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%title)
  end subroutine


  subroutine tao_plot_page_struct_set_title(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_page_struct_set_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_page_struct), pointer :: struct_obj
    type(tao_title_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%title = src_obj
  end subroutine

  ! tao_plot_page_struct%subtitle: 0D_NOT_type

  subroutine tao_plot_page_struct_get_subtitle(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_page_struct_get_subtitle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%subtitle)
  end subroutine


  subroutine tao_plot_page_struct_set_subtitle(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_page_struct_set_subtitle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_page_struct), pointer :: struct_obj
    type(tao_title_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%subtitle = src_obj
  end subroutine

  ! tao_plot_page_struct%border: 0D_NOT_type

  subroutine tao_plot_page_struct_get_border(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_page_struct_get_border')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%border)
  end subroutine


  subroutine tao_plot_page_struct_set_border(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_page_struct_set_border')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_page_struct), pointer :: struct_obj
    type(qp_rect_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%border = src_obj
  end subroutine

  ! tao_plot_page_struct%floor_plan: 0D_NOT_type

  subroutine tao_plot_page_struct_get_floor_plan(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_page_struct_get_floor_plan')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%floor_plan)
  end subroutine


  subroutine tao_plot_page_struct_set_floor_plan(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_page_struct_set_floor_plan')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_page_struct), pointer :: struct_obj
    type(tao_drawing_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%floor_plan = src_obj
  end subroutine

  ! tao_plot_page_struct%lat_layout: 0D_NOT_type

  subroutine tao_plot_page_struct_get_lat_layout(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_page_struct_get_lat_layout')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lat_layout)
  end subroutine


  subroutine tao_plot_page_struct_set_lat_layout(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_page_struct_set_lat_layout')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_page_struct), pointer :: struct_obj
    type(tao_drawing_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lat_layout = src_obj
  end subroutine

  ! tao_plot_page_struct%pattern: 1D_ALLOC_type

  subroutine tao_plot_page_struct_get_pattern_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_plot_page_struct_get_pattern_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_page_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%pattern) .and. is_contiguous(struct_obj%pattern)) then
      data_ptr = c_loc(struct_obj%pattern(lbound(struct_obj%pattern, 1)))
      bounds(1) = int(lbound(struct_obj%pattern, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pattern, 1), c_int)
      
      el_size = int(storage_size(struct_obj%pattern(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_plot_page_struct%template: 1D_ALLOC_type

  subroutine tao_plot_page_struct_get_template_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_plot_page_struct_get_template_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_page_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%template) .and. is_contiguous(struct_obj%template)) then
      data_ptr = c_loc(struct_obj%template(lbound(struct_obj%template, 1)))
      bounds(1) = int(lbound(struct_obj%template, 1), c_int)
      bounds(2) = int(ubound(struct_obj%template, 1), c_int)
      
      el_size = int(storage_size(struct_obj%template(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_plot_page_struct%region: 1D_ALLOC_type

  subroutine tao_plot_page_struct_get_region_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_plot_page_struct_get_region_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_page_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%region) .and. is_contiguous(struct_obj%region)) then
      data_ptr = c_loc(struct_obj%region(lbound(struct_obj%region, 1)))
      bounds(1) = int(lbound(struct_obj%region, 1), c_int)
      bounds(2) = int(ubound(struct_obj%region, 1), c_int)
      
      el_size = int(storage_size(struct_obj%region(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_plot_page_struct%plot_display_type: 0D_NOT_character

  subroutine tao_plot_page_struct_get_plot_display_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_plot_page_struct_get_plot_display_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%plot_display_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%plot_display_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_plot_page_struct_set_plot_display_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_plot_page_struct_set_plot_display_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_plot_page_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%plot_display_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_plot_page_struct%size: 1D_NOT_real

  subroutine tao_plot_page_struct_get_size_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_plot_page_struct_get_size_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_plot_page_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%size)) then
      data_ptr = c_loc(struct_obj%size(lbound(struct_obj%size, 1)))
      bounds(1) = int(lbound(struct_obj%size, 1), c_int)
      bounds(2) = int(ubound(struct_obj%size, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_plot_page_struct%text_height: 0D_NOT_real

  subroutine tao_plot_page_struct_get_text_height(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_text_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%text_height
  end subroutine


  subroutine tao_plot_page_struct_set_text_height(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_text_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%text_height = value_in
  end subroutine

  ! tao_plot_page_struct%main_title_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_main_title_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_main_title_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%main_title_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_main_title_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_main_title_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%main_title_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%graph_title_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_graph_title_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_graph_title_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%graph_title_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_graph_title_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_graph_title_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%graph_title_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%axis_number_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_axis_number_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_axis_number_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%axis_number_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_axis_number_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_axis_number_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%axis_number_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%axis_label_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_axis_label_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_axis_label_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%axis_label_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_axis_label_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_axis_label_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%axis_label_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%legend_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_legend_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_legend_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%legend_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_legend_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_legend_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%legend_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%key_table_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_key_table_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_key_table_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%key_table_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_key_table_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_key_table_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%key_table_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%floor_plan_shape_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_floor_plan_shape_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_floor_plan_shape_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%floor_plan_shape_scale
  end subroutine


  subroutine tao_plot_page_struct_set_floor_plan_shape_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_floor_plan_shape_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%floor_plan_shape_scale = value_in
  end subroutine

  ! tao_plot_page_struct%floor_plan_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_floor_plan_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_floor_plan_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%floor_plan_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_floor_plan_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_floor_plan_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%floor_plan_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%lat_layout_shape_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_lat_layout_shape_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_lat_layout_shape_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lat_layout_shape_scale
  end subroutine


  subroutine tao_plot_page_struct_set_lat_layout_shape_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_lat_layout_shape_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lat_layout_shape_scale = value_in
  end subroutine

  ! tao_plot_page_struct%lat_layout_text_scale: 0D_NOT_real

  subroutine tao_plot_page_struct_get_lat_layout_text_scale(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_lat_layout_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lat_layout_text_scale
  end subroutine


  subroutine tao_plot_page_struct_set_lat_layout_text_scale(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_lat_layout_text_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lat_layout_text_scale = value_in
  end subroutine

  ! tao_plot_page_struct%n_curve_pts: 0D_NOT_integer

  subroutine tao_plot_page_struct_get_n_curve_pts(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_n_curve_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_curve_pts
  end subroutine


  subroutine tao_plot_page_struct_set_n_curve_pts(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_n_curve_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_curve_pts = value_in
  end subroutine

  ! tao_plot_page_struct%id_window: 0D_NOT_integer

  subroutine tao_plot_page_struct_get_id_window(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_id_window')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%id_window
  end subroutine


  subroutine tao_plot_page_struct_set_id_window(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_id_window')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%id_window = value_in
  end subroutine

  ! tao_plot_page_struct%delete_overlapping_plots: 0D_NOT_logical

  subroutine tao_plot_page_struct_get_delete_overlapping_plots(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_delete_overlapping_plots')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%delete_overlapping_plots
  end subroutine


  subroutine tao_plot_page_struct_set_delete_overlapping_plots(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_delete_overlapping_plots')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%delete_overlapping_plots = value_in
  end subroutine

  ! tao_plot_page_struct%draw_graph_title_suffix: 0D_NOT_logical

  subroutine tao_plot_page_struct_get_draw_graph_title_suffix(struct_obj_ptr, value_out) bind(c, name='tao_plot_page_struct_get_draw_graph_title_suffix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%draw_graph_title_suffix
  end subroutine


  subroutine tao_plot_page_struct_set_draw_graph_title_suffix(struct_obj_ptr, value_in) bind(c, name='tao_plot_page_struct_set_draw_graph_title_suffix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_page_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%draw_graph_title_suffix = value_in
  end subroutine

  !! tao_building_wall_struct

    function allocate_fortran_tao_building_wall_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_building_wall_struct), pointer :: fptr
      type(tao_building_wall_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_building_wall_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_building_wall_struct), pointer :: fptr
      type(tao_building_wall_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_building_wall_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_building_wall_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_building_wall_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_building_wall_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_building_wall_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_building_wall_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_building_wall_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_building_wall_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_building_wall_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_building_wall_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_building_wall_struct%orientation: 0D_NOT_type

  subroutine tao_building_wall_struct_get_orientation(struct_obj_ptr, ptr_out) bind(c, name='tao_building_wall_struct_get_orientation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_building_wall_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orientation)
  end subroutine


  subroutine tao_building_wall_struct_set_orientation(struct_obj_ptr, src_ptr) bind(c, name='tao_building_wall_struct_set_orientation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_building_wall_struct), pointer :: struct_obj
    type(tao_building_wall_orientation_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orientation = src_obj
  end subroutine

  ! tao_building_wall_struct%section: 1D_ALLOC_type

  subroutine tao_building_wall_struct_get_section_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_building_wall_struct_get_section_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_building_wall_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%section) .and. is_contiguous(struct_obj%section)) then
      data_ptr = c_loc(struct_obj%section(lbound(struct_obj%section, 1)))
      bounds(1) = int(lbound(struct_obj%section, 1), c_int)
      bounds(2) = int(ubound(struct_obj%section, 1), c_int)
      
      el_size = int(storage_size(struct_obj%section(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_building_wall_orientation_struct

    function allocate_fortran_tao_building_wall_orientation_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_building_wall_orientation_struct), pointer :: fptr
      type(tao_building_wall_orientation_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_building_wall_orientation_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_building_wall_orientation_struct), pointer :: fptr
      type(tao_building_wall_orientation_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_building_wall_orientation_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_building_wall_orientation_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_building_wall_orientation_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_building_wall_orientation_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_building_wall_orientation_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_building_wall_orientation_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_building_wall_orientation_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_building_wall_orientation_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_building_wall_orientation_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_building_wall_orientation_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_building_wall_orientation_struct%theta: 0D_NOT_real

  subroutine tao_building_wall_orientation_struct_get_theta(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_orientation_struct_get_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_orientation_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta
  end subroutine


  subroutine tao_building_wall_orientation_struct_set_theta(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_orientation_struct_set_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_orientation_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta = value_in
  end subroutine

  ! tao_building_wall_orientation_struct%x_offset: 0D_NOT_real

  subroutine tao_building_wall_orientation_struct_get_x_offset(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_orientation_struct_get_x_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_orientation_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_offset
  end subroutine


  subroutine tao_building_wall_orientation_struct_set_x_offset(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_orientation_struct_set_x_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_orientation_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_offset = value_in
  end subroutine

  ! tao_building_wall_orientation_struct%z_offset: 0D_NOT_real

  subroutine tao_building_wall_orientation_struct_get_z_offset(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_orientation_struct_get_z_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_orientation_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_offset
  end subroutine


  subroutine tao_building_wall_orientation_struct_set_z_offset(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_orientation_struct_set_z_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_orientation_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_offset = value_in
  end subroutine

  !! tao_building_wall_section_struct

    function allocate_fortran_tao_building_wall_section_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_building_wall_section_struct), pointer :: fptr
      type(tao_building_wall_section_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_building_wall_section_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_building_wall_section_struct), pointer :: fptr
      type(tao_building_wall_section_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_building_wall_section_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_building_wall_section_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_building_wall_section_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_building_wall_section_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_building_wall_section_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_building_wall_section_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_building_wall_section_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_building_wall_section_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_building_wall_section_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_building_wall_section_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_building_wall_section_struct%name: 0D_NOT_character

  subroutine tao_building_wall_section_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_building_wall_section_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_building_wall_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_building_wall_section_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_building_wall_section_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_building_wall_section_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_building_wall_section_struct%constraint: 0D_NOT_character

  subroutine tao_building_wall_section_struct_get_constraint_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_building_wall_section_struct_get_constraint_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_building_wall_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%constraint)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%constraint), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_building_wall_section_struct_set_constraint(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_building_wall_section_struct_set_constraint')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_building_wall_section_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%constraint = str_in ! implicitly handles padding
  end subroutine

  ! tao_building_wall_section_struct%point: 1D_ALLOC_type

  subroutine tao_building_wall_section_struct_get_point_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_building_wall_section_struct_get_point_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_building_wall_section_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%point) .and. is_contiguous(struct_obj%point)) then
      data_ptr = c_loc(struct_obj%point(lbound(struct_obj%point, 1)))
      bounds(1) = int(lbound(struct_obj%point, 1), c_int)
      bounds(2) = int(ubound(struct_obj%point, 1), c_int)
      
      el_size = int(storage_size(struct_obj%point(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_building_wall_point_struct

    function allocate_fortran_tao_building_wall_point_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_building_wall_point_struct), pointer :: fptr
      type(tao_building_wall_point_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_building_wall_point_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_building_wall_point_struct), pointer :: fptr
      type(tao_building_wall_point_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_building_wall_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_building_wall_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_building_wall_point_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_building_wall_point_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_building_wall_point_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_building_wall_point_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_building_wall_point_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_building_wall_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_building_wall_point_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_building_wall_point_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_building_wall_point_struct%z: 0D_NOT_real

  subroutine tao_building_wall_point_struct_get_z(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_point_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z
  end subroutine


  subroutine tao_building_wall_point_struct_set_z(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_point_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z = value_in
  end subroutine

  ! tao_building_wall_point_struct%x: 0D_NOT_real

  subroutine tao_building_wall_point_struct_get_x(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_point_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine tao_building_wall_point_struct_set_x(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_point_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! tao_building_wall_point_struct%radius: 0D_NOT_real

  subroutine tao_building_wall_point_struct_get_radius(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_point_struct_get_radius')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radius
  end subroutine


  subroutine tao_building_wall_point_struct_set_radius(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_point_struct_set_radius')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radius = value_in
  end subroutine

  ! tao_building_wall_point_struct%z_center: 0D_NOT_real

  subroutine tao_building_wall_point_struct_get_z_center(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_point_struct_get_z_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_center
  end subroutine


  subroutine tao_building_wall_point_struct_set_z_center(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_point_struct_set_z_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_center = value_in
  end subroutine

  ! tao_building_wall_point_struct%x_center: 0D_NOT_real

  subroutine tao_building_wall_point_struct_get_x_center(struct_obj_ptr, value_out) bind(c, name='tao_building_wall_point_struct_get_x_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_center
  end subroutine


  subroutine tao_building_wall_point_struct_set_x_center(struct_obj_ptr, value_in) bind(c, name='tao_building_wall_point_struct_set_x_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_building_wall_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_center = value_in
  end subroutine

  !! tao_wave_struct

    function allocate_fortran_tao_wave_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_wave_struct), pointer :: fptr
      type(tao_wave_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_wave_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_wave_struct), pointer :: fptr
      type(tao_wave_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_wave_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_wave_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_wave_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_wave_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_wave_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_wave_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_wave_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_wave_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_wave_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_wave_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_wave_struct%data_type: 0D_NOT_character

  subroutine tao_wave_struct_get_data_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_wave_struct_get_data_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_wave_struct_set_data_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_wave_struct_set_data_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_wave_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_wave_struct%rms_rel_a: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_a(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_a
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_a(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_a = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_b: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_b(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_b
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_b(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_b = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_as: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_as(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_as')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_as
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_as(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_as')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_as = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_bs: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_bs(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_bs')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_bs
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_bs(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_bs')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_bs = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_ar: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_ar(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_ar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_ar
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_ar(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_ar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_ar = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_br: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_br(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_br')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_br
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_br(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_br')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_br = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_k: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_k(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_k')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_k
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_k(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_k')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_k = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_ks: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_ks(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_ks')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_ks
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_ks(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_ks')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_ks = value_in
  end subroutine

  ! tao_wave_struct%rms_rel_kr: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_rel_kr(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_rel_kr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_rel_kr
  end subroutine


  subroutine tao_wave_struct_set_rms_rel_kr(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_rel_kr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_rel_kr = value_in
  end subroutine

  ! tao_wave_struct%rms_phi: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_phi(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_phi
  end subroutine


  subroutine tao_wave_struct_set_rms_phi(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_phi = value_in
  end subroutine

  ! tao_wave_struct%rms_phi_s: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_phi_s(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_phi_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_phi_s
  end subroutine


  subroutine tao_wave_struct_set_rms_phi_s(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_phi_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_phi_s = value_in
  end subroutine

  ! tao_wave_struct%rms_phi_r: 0D_NOT_real

  subroutine tao_wave_struct_get_rms_phi_r(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_rms_phi_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rms_phi_r
  end subroutine


  subroutine tao_wave_struct_set_rms_phi_r(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_rms_phi_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rms_phi_r = value_in
  end subroutine

  ! tao_wave_struct%amp_ba_s: 0D_NOT_real

  subroutine tao_wave_struct_get_amp_ba_s(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_amp_ba_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp_ba_s
  end subroutine


  subroutine tao_wave_struct_set_amp_ba_s(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_amp_ba_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp_ba_s = value_in
  end subroutine

  ! tao_wave_struct%amp_ba_r: 0D_NOT_real

  subroutine tao_wave_struct_get_amp_ba_r(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_amp_ba_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp_ba_r
  end subroutine


  subroutine tao_wave_struct_set_amp_ba_r(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_amp_ba_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp_ba_r = value_in
  end subroutine

  ! tao_wave_struct%chi_a: 0D_NOT_real

  subroutine tao_wave_struct_get_chi_a(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_chi_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chi_a
  end subroutine


  subroutine tao_wave_struct_set_chi_a(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_chi_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chi_a = value_in
  end subroutine

  ! tao_wave_struct%chi_c: 0D_NOT_real

  subroutine tao_wave_struct_get_chi_c(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_chi_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chi_c
  end subroutine


  subroutine tao_wave_struct_set_chi_c(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_chi_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chi_c = value_in
  end subroutine

  ! tao_wave_struct%chi_ba: 0D_NOT_real

  subroutine tao_wave_struct_get_chi_ba(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_chi_ba')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chi_ba
  end subroutine


  subroutine tao_wave_struct_set_chi_ba(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_chi_ba')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chi_ba = value_in
  end subroutine

  ! tao_wave_struct%amp_a: 1D_NOT_real

  subroutine tao_wave_struct_get_amp_a_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_amp_a_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%amp_a)) then
      data_ptr = c_loc(struct_obj%amp_a(lbound(struct_obj%amp_a, 1)))
      bounds(1) = int(lbound(struct_obj%amp_a, 1), c_int)
      bounds(2) = int(ubound(struct_obj%amp_a, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%amp_b: 1D_NOT_real

  subroutine tao_wave_struct_get_amp_b_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_amp_b_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%amp_b)) then
      data_ptr = c_loc(struct_obj%amp_b(lbound(struct_obj%amp_b, 1)))
      bounds(1) = int(lbound(struct_obj%amp_b, 1), c_int)
      bounds(2) = int(ubound(struct_obj%amp_b, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%amp_ba: 1D_NOT_real

  subroutine tao_wave_struct_get_amp_ba_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_amp_ba_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%amp_ba)) then
      data_ptr = c_loc(struct_obj%amp_ba(lbound(struct_obj%amp_ba, 1)))
      bounds(1) = int(lbound(struct_obj%amp_ba, 1), c_int)
      bounds(2) = int(ubound(struct_obj%amp_ba, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%coef_a: 1D_NOT_real

  subroutine tao_wave_struct_get_coef_a_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_coef_a_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%coef_a)) then
      data_ptr = c_loc(struct_obj%coef_a(lbound(struct_obj%coef_a, 1)))
      bounds(1) = int(lbound(struct_obj%coef_a, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef_a, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%coef_b: 1D_NOT_real

  subroutine tao_wave_struct_get_coef_b_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_coef_b_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%coef_b)) then
      data_ptr = c_loc(struct_obj%coef_b(lbound(struct_obj%coef_b, 1)))
      bounds(1) = int(lbound(struct_obj%coef_b, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef_b, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%coef_ba: 1D_NOT_real

  subroutine tao_wave_struct_get_coef_ba_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_coef_ba_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%coef_ba)) then
      data_ptr = c_loc(struct_obj%coef_ba(lbound(struct_obj%coef_ba, 1)))
      bounds(1) = int(lbound(struct_obj%coef_ba, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef_ba, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%n_func: 0D_NOT_integer

  subroutine tao_wave_struct_get_n_func(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_n_func')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_func
  end subroutine


  subroutine tao_wave_struct_set_n_func(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_n_func')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_func = value_in
  end subroutine

  ! tao_wave_struct%ix_a1: 0D_NOT_integer

  subroutine tao_wave_struct_get_ix_a1(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_ix_a1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_a1
  end subroutine


  subroutine tao_wave_struct_set_ix_a1(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_ix_a1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_a1 = value_in
  end subroutine

  ! tao_wave_struct%ix_a2: 0D_NOT_integer

  subroutine tao_wave_struct_get_ix_a2(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_ix_a2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_a2
  end subroutine


  subroutine tao_wave_struct_set_ix_a2(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_ix_a2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_a2 = value_in
  end subroutine

  ! tao_wave_struct%ix_b1: 0D_NOT_integer

  subroutine tao_wave_struct_get_ix_b1(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_ix_b1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_b1
  end subroutine


  subroutine tao_wave_struct_set_ix_b1(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_ix_b1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_b1 = value_in
  end subroutine

  ! tao_wave_struct%ix_b2: 0D_NOT_integer

  subroutine tao_wave_struct_get_ix_b2(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_ix_b2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_b2
  end subroutine


  subroutine tao_wave_struct_set_ix_b2(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_ix_b2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_b2 = value_in
  end subroutine

  ! tao_wave_struct%i_a1: 0D_NOT_integer

  subroutine tao_wave_struct_get_i_a1(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_i_a1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_a1
  end subroutine


  subroutine tao_wave_struct_set_i_a1(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_i_a1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_a1 = value_in
  end subroutine

  ! tao_wave_struct%i_a2: 0D_NOT_integer

  subroutine tao_wave_struct_get_i_a2(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_i_a2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_a2
  end subroutine


  subroutine tao_wave_struct_set_i_a2(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_i_a2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_a2 = value_in
  end subroutine

  ! tao_wave_struct%i_b1: 0D_NOT_integer

  subroutine tao_wave_struct_get_i_b1(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_i_b1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_b1
  end subroutine


  subroutine tao_wave_struct_set_i_b1(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_i_b1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_b1 = value_in
  end subroutine

  ! tao_wave_struct%i_b2: 0D_NOT_integer

  subroutine tao_wave_struct_get_i_b2(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_i_b2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_b2
  end subroutine


  subroutine tao_wave_struct_set_i_b2(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_i_b2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_b2 = value_in
  end subroutine

  ! tao_wave_struct%n_a: 0D_NOT_integer

  subroutine tao_wave_struct_get_n_a(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_n_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_a
  end subroutine


  subroutine tao_wave_struct_set_n_a(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_n_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_a = value_in
  end subroutine

  ! tao_wave_struct%n_b: 0D_NOT_integer

  subroutine tao_wave_struct_get_n_b(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_n_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_b
  end subroutine


  subroutine tao_wave_struct_set_n_b(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_n_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_b = value_in
  end subroutine

  ! tao_wave_struct%i_curve_wrap_pt: 0D_NOT_integer

  subroutine tao_wave_struct_get_i_curve_wrap_pt(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_i_curve_wrap_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_curve_wrap_pt
  end subroutine


  subroutine tao_wave_struct_set_i_curve_wrap_pt(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_i_curve_wrap_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_curve_wrap_pt = value_in
  end subroutine

  ! tao_wave_struct%ix_data: 1D_ALLOC_integer

  subroutine tao_wave_struct_get_ix_data_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_wave_struct_get_ix_data_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ix_data) .and. is_contiguous(struct_obj%ix_data)) then
      data_ptr = c_loc(struct_obj%ix_data(lbound(struct_obj%ix_data, 1)))
      bounds(1) = int(lbound(struct_obj%ix_data, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ix_data, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%n_kick: 0D_NOT_integer

  subroutine tao_wave_struct_get_n_kick(struct_obj_ptr, value_out) bind(c, name='tao_wave_struct_get_n_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_kick
  end subroutine


  subroutine tao_wave_struct_set_n_kick(struct_obj_ptr, value_in) bind(c, name='tao_wave_struct_set_n_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_kick = value_in
  end subroutine

  ! tao_wave_struct%kick: 1D_ALLOC_type

  subroutine tao_wave_struct_get_kick_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_wave_struct_get_kick_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_wave_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%kick) .and. is_contiguous(struct_obj%kick)) then
      data_ptr = c_loc(struct_obj%kick(lbound(struct_obj%kick, 1)))
      bounds(1) = int(lbound(struct_obj%kick, 1), c_int)
      bounds(2) = int(ubound(struct_obj%kick, 1), c_int)
      
      el_size = int(storage_size(struct_obj%kick(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_wave_struct%base_graph: 0D_NOT_type

  subroutine tao_wave_struct_get_base_graph(struct_obj_ptr, ptr_out) bind(c, name='tao_wave_struct_get_base_graph')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%base_graph)
  end subroutine


  subroutine tao_wave_struct_set_base_graph(struct_obj_ptr, src_ptr) bind(c, name='tao_wave_struct_set_base_graph')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_wave_struct), pointer :: struct_obj
    type(tao_graph_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%base_graph = src_obj
  end subroutine

  ! tao_wave_struct%region: 0D_PTR_type

  subroutine tao_wave_struct_get_region(struct_obj_ptr, ptr_out) bind(c, name='tao_wave_struct_get_region')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%region)) then
      ptr_out = c_loc(struct_obj%region)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_wave_struct_set_region(struct_obj_ptr, src_ptr) bind(c, name='tao_wave_struct_set_region')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_wave_struct), pointer :: struct_obj
    type(tao_plot_region_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%region)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%region = src_obj
    endif
  end subroutine

  ! tao_wave_struct%d1_dat: 0D_PTR_type

  subroutine tao_wave_struct_get_d1_dat(struct_obj_ptr, ptr_out) bind(c, name='tao_wave_struct_get_d1_dat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_wave_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d1_dat)) then
      ptr_out = c_loc(struct_obj%d1_dat)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_wave_struct_set_d1_dat(struct_obj_ptr, src_ptr) bind(c, name='tao_wave_struct_set_d1_dat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_wave_struct), pointer :: struct_obj
    type(tao_d1_data_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d1_dat)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%d1_dat = src_obj
    endif
  end subroutine

  !! tao_wave_kick_pt_struct

    function allocate_fortran_tao_wave_kick_pt_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_wave_kick_pt_struct), pointer :: fptr
      type(tao_wave_kick_pt_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_wave_kick_pt_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_wave_kick_pt_struct), pointer :: fptr
      type(tao_wave_kick_pt_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_wave_kick_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_wave_kick_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_wave_kick_pt_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_wave_kick_pt_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_wave_kick_pt_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_wave_kick_pt_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_wave_kick_pt_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_wave_kick_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_wave_kick_pt_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_wave_kick_pt_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_wave_kick_pt_struct%phi_s: 0D_NOT_real

  subroutine tao_wave_kick_pt_struct_get_phi_s(struct_obj_ptr, value_out) bind(c, name='tao_wave_kick_pt_struct_get_phi_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_s
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_phi_s(struct_obj_ptr, value_in) bind(c, name='tao_wave_kick_pt_struct_set_phi_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_s = value_in
  end subroutine

  ! tao_wave_kick_pt_struct%phi_r: 0D_NOT_real

  subroutine tao_wave_kick_pt_struct_get_phi_r(struct_obj_ptr, value_out) bind(c, name='tao_wave_kick_pt_struct_get_phi_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_r
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_phi_r(struct_obj_ptr, value_in) bind(c, name='tao_wave_kick_pt_struct_set_phi_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_r = value_in
  end subroutine

  ! tao_wave_kick_pt_struct%phi: 0D_NOT_real

  subroutine tao_wave_kick_pt_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='tao_wave_kick_pt_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='tao_wave_kick_pt_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! tao_wave_kick_pt_struct%amp: 0D_NOT_real

  subroutine tao_wave_kick_pt_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='tao_wave_kick_pt_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='tao_wave_kick_pt_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! tao_wave_kick_pt_struct%s: 0D_NOT_real

  subroutine tao_wave_kick_pt_struct_get_s(struct_obj_ptr, value_out) bind(c, name='tao_wave_kick_pt_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_s(struct_obj_ptr, value_in) bind(c, name='tao_wave_kick_pt_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! tao_wave_kick_pt_struct%ix_dat_before_kick: 0D_NOT_integer

  subroutine tao_wave_kick_pt_struct_get_ix_dat_before_kick(struct_obj_ptr, value_out) bind(c, name='tao_wave_kick_pt_struct_get_ix_dat_before_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_dat_before_kick
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_ix_dat_before_kick(struct_obj_ptr, value_in) bind(c, name='tao_wave_kick_pt_struct_set_ix_dat_before_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_dat_before_kick = value_in
  end subroutine

  ! tao_wave_kick_pt_struct%ele: 0D_PTR_type

  subroutine tao_wave_kick_pt_struct_get_ele(struct_obj_ptr, ptr_out) bind(c, name='tao_wave_kick_pt_struct_get_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele)) then
      ptr_out = c_loc(struct_obj%ele)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_wave_kick_pt_struct_set_ele(struct_obj_ptr, src_ptr) bind(c, name='tao_wave_kick_pt_struct_set_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_wave_kick_pt_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ele = src_obj
    endif
  end subroutine

  !! tao_cmd_history_struct

    function allocate_fortran_tao_cmd_history_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_cmd_history_struct), pointer :: fptr
      type(tao_cmd_history_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_cmd_history_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_cmd_history_struct), pointer :: fptr
      type(tao_cmd_history_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_cmd_history_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_cmd_history_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_cmd_history_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_cmd_history_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_cmd_history_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_cmd_history_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_cmd_history_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_cmd_history_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_cmd_history_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_cmd_history_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_cmd_history_struct%cmd: 0D_ALLOC_character

  subroutine tao_cmd_history_struct_get_cmd_info(struct_obj_ptr, data_ptr, str_len, is_allocated) &
    bind(c, name='tao_cmd_history_struct_get_cmd_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_cmd_history_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%cmd)) then
      data_ptr = c_loc(struct_obj%cmd)
      str_len = int(len(struct_obj%cmd), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine


  subroutine tao_cmd_history_struct_set_cmd(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_cmd_history_struct_set_cmd')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_cmd_history_struct), pointer :: struct_obj
    character(len=str_len), pointer :: temp_str

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%cmd)) deallocate(struct_obj%cmd)

    if (str_len > 0) then
       call c_f_pointer(str_ptr, temp_str)
       allocate(struct_obj%cmd, source=temp_str)
       struct_obj%cmd = temp_str(1:str_len)
    endif
  end subroutine

  ! tao_cmd_history_struct%ix: 0D_NOT_integer

  subroutine tao_cmd_history_struct_get_ix(struct_obj_ptr, value_out) bind(c, name='tao_cmd_history_struct_get_ix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_cmd_history_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix
  end subroutine


  subroutine tao_cmd_history_struct_set_ix(struct_obj_ptr, value_in) bind(c, name='tao_cmd_history_struct_set_ix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_cmd_history_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix = value_in
  end subroutine

  !! tao_universe_struct

    function allocate_fortran_tao_universe_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(tao_universe_struct), pointer :: fptr
      type(tao_universe_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_tao_universe_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(tao_universe_struct), pointer :: fptr
      type(tao_universe_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_tao_universe_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_universe_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_tao_universe_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(tao_universe_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_tao_universe_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(tao_universe_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_tao_universe_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(tao_universe_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_tao_universe_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(tao_universe_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! tao_universe_struct%model: 0D_PTR_type

  subroutine tao_universe_struct_get_model(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model)) then
      ptr_out = c_loc(struct_obj%model)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_struct_set_model(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%model = src_obj
    endif
  end subroutine

  ! tao_universe_struct%design: 0D_PTR_type

  subroutine tao_universe_struct_get_design(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%design)) then
      ptr_out = c_loc(struct_obj%design)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_struct_set_design(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%design)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%design = src_obj
    endif
  end subroutine

  ! tao_universe_struct%base: 0D_PTR_type

  subroutine tao_universe_struct_get_base(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base)) then
      ptr_out = c_loc(struct_obj%base)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_struct_set_base(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%base = src_obj
    endif
  end subroutine

  ! tao_universe_struct%beam: 0D_NOT_type

  subroutine tao_universe_struct_get_beam(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam)
  end subroutine


  subroutine tao_universe_struct_set_beam(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_beam_uni_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam = src_obj
  end subroutine

  ! tao_universe_struct%dynamic_aperture: 0D_NOT_type

  subroutine tao_universe_struct_get_dynamic_aperture(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%dynamic_aperture)
  end subroutine


  subroutine tao_universe_struct_set_dynamic_aperture(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_dynamic_aperture_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%dynamic_aperture = src_obj
  end subroutine

  ! tao_universe_struct%model_branch: 1D_PTR_type

  subroutine tao_universe_struct_get_model_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_universe_struct_get_model_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%model_branch) .and. is_contiguous(struct_obj%model_branch)) then
      data_ptr = c_loc(struct_obj%model_branch(lbound(struct_obj%model_branch, 1)))
      bounds(1) = int(lbound(struct_obj%model_branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%model_branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%model_branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%d2_data: 1D_ALLOC_type

  subroutine tao_universe_struct_get_d2_data_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_universe_struct_get_d2_data_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%d2_data) .and. is_contiguous(struct_obj%d2_data)) then
      data_ptr = c_loc(struct_obj%d2_data(lbound(struct_obj%d2_data, 1)))
      bounds(1) = int(lbound(struct_obj%d2_data, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d2_data, 1), c_int)
      
      el_size = int(storage_size(struct_obj%d2_data(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%data: 1D_ALLOC_type

  subroutine tao_universe_struct_get_data_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_universe_struct_get_data_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%data) .and. is_contiguous(struct_obj%data)) then
      data_ptr = c_loc(struct_obj%data(lbound(struct_obj%data, 1)))
      bounds(1) = int(lbound(struct_obj%data, 1), c_int)
      bounds(2) = int(ubound(struct_obj%data, 1), c_int)
      
      el_size = int(storage_size(struct_obj%data(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%ping_scale: 0D_NOT_type

  subroutine tao_universe_struct_get_ping_scale(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_ping_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ping_scale)
  end subroutine


  subroutine tao_universe_struct_set_ping_scale(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_ping_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_ping_scale_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ping_scale = src_obj
  end subroutine

  ! tao_universe_struct%scratch_lat: 0D_NOT_type

  subroutine tao_universe_struct_get_scratch_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_scratch_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%scratch_lat)
  end subroutine


  subroutine tao_universe_struct_set_scratch_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_scratch_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%scratch_lat = src_obj
  end subroutine

  ! tao_universe_struct%calc: 0D_NOT_type

  subroutine tao_universe_struct_get_calc(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%calc)
  end subroutine


  subroutine tao_universe_struct_set_calc(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_universe_calc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%calc = src_obj
  end subroutine

  ! tao_universe_struct%ele_order: 0D_NOT_type

  subroutine tao_universe_struct_get_ele_order(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_ele_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_order)
  end subroutine


  subroutine tao_universe_struct_set_ele_order(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_ele_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(lat_ele_order_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_order = src_obj
  end subroutine

  ! tao_universe_struct%spin_map: 0D_NOT_type

  subroutine tao_universe_struct_get_spin_map(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spin_map)
  end subroutine


  subroutine tao_universe_struct_set_spin_map(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_spin_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spin_map = src_obj
  end subroutine

  ! tao_universe_struct%dModel_dVar: 2D_ALLOC_real

  subroutine tao_universe_struct_get_dModel_dVar_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_universe_struct_get_dModel_dVar_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%dModel_dVar) .and. is_contiguous(struct_obj%dModel_dVar)) then
      data_ptr = c_loc(struct_obj%dModel_dVar(lbound(struct_obj%dModel_dVar, 1), lbound(struct_obj%dModel_dVar, 2)))
      bounds(1) = int(lbound(struct_obj%dModel_dVar, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dModel_dVar, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dModel_dVar, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dModel_dVar, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%ix_uni: 0D_NOT_integer

  subroutine tao_universe_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_universe_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_universe_struct%n_d2_data_used: 0D_NOT_integer

  subroutine tao_universe_struct_get_n_d2_data_used(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_n_d2_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_d2_data_used
  end subroutine


  subroutine tao_universe_struct_set_n_d2_data_used(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_n_d2_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_d2_data_used = value_in
  end subroutine

  ! tao_universe_struct%n_data_used: 0D_NOT_integer

  subroutine tao_universe_struct_get_n_data_used(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_n_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_data_used
  end subroutine


  subroutine tao_universe_struct_set_n_data_used(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_n_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_data_used = value_in
  end subroutine

  ! tao_universe_struct%is_on: 0D_NOT_logical

  subroutine tao_universe_struct_get_is_on(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_on
  end subroutine


  subroutine tao_universe_struct_set_is_on(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_on = value_in
  end subroutine

  ! tao_universe_struct%design_same_as_previous: 0D_NOT_logical

  subroutine tao_universe_struct_get_design_same_as_previous(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_design_same_as_previous')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%design_same_as_previous
  end subroutine


  subroutine tao_universe_struct_set_design_same_as_previous(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_design_same_as_previous')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%design_same_as_previous = value_in
  end subroutine

  ! tao_universe_struct%picked_uni: 0D_NOT_logical

  subroutine tao_universe_struct_get_picked_uni(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_picked_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%picked_uni
  end subroutine


  subroutine tao_universe_struct_set_picked_uni(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_picked_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%picked_uni = value_in
  end subroutine

  !! mad_energy_struct

    function allocate_fortran_mad_energy_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(mad_energy_struct), pointer :: fptr
      type(mad_energy_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_mad_energy_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(mad_energy_struct), pointer :: fptr
      type(mad_energy_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_mad_energy_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(mad_energy_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_mad_energy_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(mad_energy_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_mad_energy_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(mad_energy_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_mad_energy_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(mad_energy_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_mad_energy_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(mad_energy_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! mad_energy_struct%total: 0D_NOT_real

  subroutine mad_energy_struct_get_total(struct_obj_ptr, value_out) bind(c, name='mad_energy_struct_get_total')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%total
  end subroutine


  subroutine mad_energy_struct_set_total(struct_obj_ptr, value_in) bind(c, name='mad_energy_struct_set_total')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%total = value_in
  end subroutine

  ! mad_energy_struct%beta: 0D_NOT_real

  subroutine mad_energy_struct_get_beta(struct_obj_ptr, value_out) bind(c, name='mad_energy_struct_get_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beta
  end subroutine


  subroutine mad_energy_struct_set_beta(struct_obj_ptr, value_in) bind(c, name='mad_energy_struct_set_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beta = value_in
  end subroutine

  ! mad_energy_struct%gamma: 0D_NOT_real

  subroutine mad_energy_struct_get_gamma(struct_obj_ptr, value_out) bind(c, name='mad_energy_struct_get_gamma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gamma
  end subroutine


  subroutine mad_energy_struct_set_gamma(struct_obj_ptr, value_in) bind(c, name='mad_energy_struct_set_gamma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gamma = value_in
  end subroutine

  ! mad_energy_struct%kinetic: 0D_NOT_real

  subroutine mad_energy_struct_get_kinetic(struct_obj_ptr, value_out) bind(c, name='mad_energy_struct_get_kinetic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kinetic
  end subroutine


  subroutine mad_energy_struct_set_kinetic(struct_obj_ptr, value_in) bind(c, name='mad_energy_struct_set_kinetic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kinetic = value_in
  end subroutine

  ! mad_energy_struct%p0c: 0D_NOT_real

  subroutine mad_energy_struct_get_p0c(struct_obj_ptr, value_out) bind(c, name='mad_energy_struct_get_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p0c
  end subroutine


  subroutine mad_energy_struct_set_p0c(struct_obj_ptr, value_in) bind(c, name='mad_energy_struct_set_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p0c = value_in
  end subroutine

  ! mad_energy_struct%particle: 0D_NOT_integer

  subroutine mad_energy_struct_get_particle(struct_obj_ptr, value_out) bind(c, name='mad_energy_struct_get_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle
  end subroutine


  subroutine mad_energy_struct_set_particle(struct_obj_ptr, value_in) bind(c, name='mad_energy_struct_set_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(mad_energy_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle = value_in
  end subroutine

  !! mad_map_struct

    function allocate_fortran_mad_map_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(mad_map_struct), pointer :: fptr
      type(mad_map_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_mad_map_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(mad_map_struct), pointer :: fptr
      type(mad_map_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_mad_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(mad_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_mad_map_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(mad_map_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_mad_map_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(mad_map_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_mad_map_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(mad_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_mad_map_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(mad_map_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! mad_map_struct%k: 1D_NOT_real

  subroutine mad_map_struct_get_k_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='mad_map_struct_get_k_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(mad_map_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%k)) then
      data_ptr = c_loc(struct_obj%k(lbound(struct_obj%k, 1)))
      bounds(1) = int(lbound(struct_obj%k, 1), c_int)
      bounds(2) = int(ubound(struct_obj%k, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! mad_map_struct%r: 2D_NOT_real

  subroutine mad_map_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='mad_map_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(mad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1), lbound(struct_obj%r, 2)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      bounds(3) = int(lbound(struct_obj%r, 2), c_int)
      bounds(4) = int(ubound(struct_obj%r, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! mad_map_struct%t: 3D_NOT_real

  subroutine mad_map_struct_get_t_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='mad_map_struct_get_t_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(mad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%t)) then
      data_ptr = c_loc(struct_obj%t(lbound(struct_obj%t, 1), lbound(struct_obj%t, 2), lbound(struct_obj%t, 3)))
      bounds(1) = int(lbound(struct_obj%t, 1), c_int)
      bounds(2) = int(ubound(struct_obj%t, 1), c_int)
      bounds(3) = int(lbound(struct_obj%t, 2), c_int)
      bounds(4) = int(ubound(struct_obj%t, 2), c_int)
      bounds(5) = int(lbound(struct_obj%t, 3), c_int)
      bounds(6) = int(ubound(struct_obj%t, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! random_state_struct

    function allocate_fortran_random_state_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(random_state_struct), pointer :: fptr
      type(random_state_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_random_state_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(random_state_struct), pointer :: fptr
      type(random_state_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_random_state_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(random_state_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_random_state_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(random_state_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_random_state_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(random_state_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_random_state_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(random_state_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_random_state_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(random_state_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! random_state_struct%ix: 0D_NOT_integer8

  subroutine random_state_struct_get_ix(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_ix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix
  end subroutine


  subroutine random_state_struct_set_ix(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_ix')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix = value_in
  end subroutine

  ! random_state_struct%iy: 0D_NOT_integer8

  subroutine random_state_struct_get_iy(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_iy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iy
  end subroutine


  subroutine random_state_struct_set_iy(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_iy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iy = value_in
  end subroutine

  ! random_state_struct%number_stored: 0D_NOT_logical

  subroutine random_state_struct_get_number_stored(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_number_stored')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%number_stored
  end subroutine


  subroutine random_state_struct_set_number_stored(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_number_stored')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%number_stored = value_in
  end subroutine

  ! random_state_struct%h_saved: 0D_NOT_real

  subroutine random_state_struct_get_h_saved(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_h_saved')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h_saved
  end subroutine


  subroutine random_state_struct_set_h_saved(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_h_saved')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h_saved = value_in
  end subroutine

  ! random_state_struct%engine: 0D_NOT_integer

  subroutine random_state_struct_get_engine(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_engine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%engine
  end subroutine


  subroutine random_state_struct_set_engine(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_engine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%engine = value_in
  end subroutine

  ! random_state_struct%seed: 0D_NOT_integer

  subroutine random_state_struct_get_seed(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_seed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%seed
  end subroutine


  subroutine random_state_struct_set_seed(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_seed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%seed = value_in
  end subroutine

  ! random_state_struct%am: 0D_NOT_real

  subroutine random_state_struct_get_am(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_am')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%am
  end subroutine


  subroutine random_state_struct_set_am(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_am')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%am = value_in
  end subroutine

  ! random_state_struct%gauss_converter: 0D_NOT_integer

  subroutine random_state_struct_get_gauss_converter(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_gauss_converter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gauss_converter
  end subroutine


  subroutine random_state_struct_set_gauss_converter(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_gauss_converter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gauss_converter = value_in
  end subroutine

  ! random_state_struct%gauss_sigma_cut: 0D_NOT_real

  subroutine random_state_struct_get_gauss_sigma_cut(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_gauss_sigma_cut')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gauss_sigma_cut
  end subroutine


  subroutine random_state_struct_set_gauss_sigma_cut(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_gauss_sigma_cut')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gauss_sigma_cut = value_in
  end subroutine

  ! random_state_struct%in_sobseq: 0D_NOT_integer8

  subroutine random_state_struct_get_in_sobseq(struct_obj_ptr, value_out) bind(c, name='random_state_struct_get_in_sobseq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%in_sobseq
  end subroutine


  subroutine random_state_struct_set_in_sobseq(struct_obj_ptr, value_in) bind(c, name='random_state_struct_set_in_sobseq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(random_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%in_sobseq = value_in
  end subroutine

  ! skipped random_state_struct%ix_sobseq: Unsupported type: 1D_NOT_integer8
  ! random_state_struct%x_sobseq: 1D_NOT_real

  subroutine random_state_struct_get_x_sobseq_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='random_state_struct_get_x_sobseq_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(random_state_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%x_sobseq)) then
      data_ptr = c_loc(struct_obj%x_sobseq(lbound(struct_obj%x_sobseq, 1)))
      bounds(1) = int(lbound(struct_obj%x_sobseq, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x_sobseq, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! bbu_stage_struct

    function allocate_fortran_bbu_stage_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bbu_stage_struct), pointer :: fptr
      type(bbu_stage_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bbu_stage_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bbu_stage_struct), pointer :: fptr
      type(bbu_stage_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bbu_stage_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bbu_stage_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bbu_stage_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bbu_stage_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bbu_stage_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bbu_stage_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bbu_stage_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bbu_stage_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bbu_stage_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bbu_stage_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bbu_stage_struct%ix_ele_lr_wake: 0D_NOT_integer

  subroutine bbu_stage_struct_get_ix_ele_lr_wake(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_ix_ele_lr_wake')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_lr_wake
  end subroutine


  subroutine bbu_stage_struct_set_ix_ele_lr_wake(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_ix_ele_lr_wake')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_lr_wake = value_in
  end subroutine

  ! bbu_stage_struct%ix_ele_stage_end: 0D_NOT_integer

  subroutine bbu_stage_struct_get_ix_ele_stage_end(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_ix_ele_stage_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_stage_end
  end subroutine


  subroutine bbu_stage_struct_set_ix_ele_stage_end(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_ix_ele_stage_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_stage_end = value_in
  end subroutine

  ! bbu_stage_struct%ix_pass: 0D_NOT_integer

  subroutine bbu_stage_struct_get_ix_pass(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_ix_pass')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_pass
  end subroutine


  subroutine bbu_stage_struct_set_ix_pass(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_ix_pass')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_pass = value_in
  end subroutine

  ! bbu_stage_struct%ix_stage_pass1: 0D_NOT_integer

  subroutine bbu_stage_struct_get_ix_stage_pass1(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_ix_stage_pass1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_stage_pass1
  end subroutine


  subroutine bbu_stage_struct_set_ix_stage_pass1(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_ix_stage_pass1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_stage_pass1 = value_in
  end subroutine

  ! bbu_stage_struct%ix_head_bunch: 0D_NOT_integer

  subroutine bbu_stage_struct_get_ix_head_bunch(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_ix_head_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_head_bunch
  end subroutine


  subroutine bbu_stage_struct_set_ix_head_bunch(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_ix_head_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_head_bunch = value_in
  end subroutine

  ! bbu_stage_struct%ix_hom_max: 0D_NOT_integer

  subroutine bbu_stage_struct_get_ix_hom_max(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_ix_hom_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_hom_max
  end subroutine


  subroutine bbu_stage_struct_set_ix_hom_max(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_ix_hom_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_hom_max = value_in
  end subroutine

  ! bbu_stage_struct%hom_voltage_max: 0D_NOT_real

  subroutine bbu_stage_struct_get_hom_voltage_max(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_hom_voltage_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%hom_voltage_max
  end subroutine


  subroutine bbu_stage_struct_set_hom_voltage_max(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_hom_voltage_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%hom_voltage_max = value_in
  end subroutine

  ! bbu_stage_struct%time_at_wake_ele: 0D_NOT_real

  subroutine bbu_stage_struct_get_time_at_wake_ele(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_time_at_wake_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_at_wake_ele
  end subroutine


  subroutine bbu_stage_struct_set_time_at_wake_ele(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_time_at_wake_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_at_wake_ele = value_in
  end subroutine

  ! bbu_stage_struct%ave_orb: 1D_NOT_real

  subroutine bbu_stage_struct_get_ave_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bbu_stage_struct_get_ave_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_stage_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%ave_orb)) then
      data_ptr = c_loc(struct_obj%ave_orb(lbound(struct_obj%ave_orb, 1)))
      bounds(1) = int(lbound(struct_obj%ave_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ave_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_stage_struct%rms_orb: 1D_NOT_real

  subroutine bbu_stage_struct_get_rms_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bbu_stage_struct_get_rms_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_stage_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%rms_orb)) then
      data_ptr = c_loc(struct_obj%rms_orb(lbound(struct_obj%rms_orb, 1)))
      bounds(1) = int(lbound(struct_obj%rms_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%rms_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_stage_struct%min_orb: 1D_NOT_real

  subroutine bbu_stage_struct_get_min_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bbu_stage_struct_get_min_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_stage_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%min_orb)) then
      data_ptr = c_loc(struct_obj%min_orb(lbound(struct_obj%min_orb, 1)))
      bounds(1) = int(lbound(struct_obj%min_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%min_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_stage_struct%max_orb: 1D_NOT_real

  subroutine bbu_stage_struct_get_max_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bbu_stage_struct_get_max_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_stage_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%max_orb)) then
      data_ptr = c_loc(struct_obj%max_orb(lbound(struct_obj%max_orb, 1)))
      bounds(1) = int(lbound(struct_obj%max_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%max_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_stage_struct%n_orb: 0D_NOT_integer

  subroutine bbu_stage_struct_get_n_orb(struct_obj_ptr, value_out) bind(c, name='bbu_stage_struct_get_n_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_orb
  end subroutine


  subroutine bbu_stage_struct_set_n_orb(struct_obj_ptr, value_in) bind(c, name='bbu_stage_struct_set_n_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_stage_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_orb = value_in
  end subroutine

  !! bbu_beam_struct

    function allocate_fortran_bbu_beam_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bbu_beam_struct), pointer :: fptr
      type(bbu_beam_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bbu_beam_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bbu_beam_struct), pointer :: fptr
      type(bbu_beam_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bbu_beam_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bbu_beam_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bbu_beam_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bbu_beam_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bbu_beam_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bbu_beam_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bbu_beam_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bbu_beam_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bbu_beam_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bbu_beam_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bbu_beam_struct%bunch: 1D_ALLOC_type

  subroutine bbu_beam_struct_get_bunch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bbu_beam_struct_get_bunch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_beam_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%bunch) .and. is_contiguous(struct_obj%bunch)) then
      data_ptr = c_loc(struct_obj%bunch(lbound(struct_obj%bunch, 1)))
      bounds(1) = int(lbound(struct_obj%bunch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_beam_struct%stage: 1D_ALLOC_type

  subroutine bbu_beam_struct_get_stage_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bbu_beam_struct_get_stage_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_beam_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%stage) .and. is_contiguous(struct_obj%stage)) then
      data_ptr = c_loc(struct_obj%stage(lbound(struct_obj%stage, 1)))
      bounds(1) = int(lbound(struct_obj%stage, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stage, 1), c_int)
      
      el_size = int(storage_size(struct_obj%stage(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_beam_struct%ix_ele_bunch: 1D_ALLOC_integer

  subroutine bbu_beam_struct_get_ix_ele_bunch_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bbu_beam_struct_get_ix_ele_bunch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_beam_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%ix_ele_bunch) .and. is_contiguous(struct_obj%ix_ele_bunch)) then
      data_ptr = c_loc(struct_obj%ix_ele_bunch(lbound(struct_obj%ix_ele_bunch, 1)))
      bounds(1) = int(lbound(struct_obj%ix_ele_bunch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ix_ele_bunch, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_beam_struct%ix_bunch_head: 0D_NOT_integer

  subroutine bbu_beam_struct_get_ix_bunch_head(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_ix_bunch_head')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch_head
  end subroutine


  subroutine bbu_beam_struct_set_ix_bunch_head(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_ix_bunch_head')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch_head = value_in
  end subroutine

  ! bbu_beam_struct%ix_bunch_end: 0D_NOT_integer

  subroutine bbu_beam_struct_get_ix_bunch_end(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_ix_bunch_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch_end
  end subroutine


  subroutine bbu_beam_struct_set_ix_bunch_end(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_ix_bunch_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch_end = value_in
  end subroutine

  ! bbu_beam_struct%n_bunch_in_lat: 0D_NOT_integer

  subroutine bbu_beam_struct_get_n_bunch_in_lat(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_n_bunch_in_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bunch_in_lat
  end subroutine


  subroutine bbu_beam_struct_set_n_bunch_in_lat(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_n_bunch_in_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bunch_in_lat = value_in
  end subroutine

  ! bbu_beam_struct%ix_stage_voltage_max: 0D_NOT_integer

  subroutine bbu_beam_struct_get_ix_stage_voltage_max(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_ix_stage_voltage_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_stage_voltage_max
  end subroutine


  subroutine bbu_beam_struct_set_ix_stage_voltage_max(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_ix_stage_voltage_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_stage_voltage_max = value_in
  end subroutine

  ! bbu_beam_struct%hom_voltage_max: 0D_NOT_real

  subroutine bbu_beam_struct_get_hom_voltage_max(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_hom_voltage_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%hom_voltage_max
  end subroutine


  subroutine bbu_beam_struct_set_hom_voltage_max(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_hom_voltage_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%hom_voltage_max = value_in
  end subroutine

  ! bbu_beam_struct%time_now: 0D_NOT_real

  subroutine bbu_beam_struct_get_time_now(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_time_now')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_now
  end subroutine


  subroutine bbu_beam_struct_set_time_now(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_time_now')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_now = value_in
  end subroutine

  ! bbu_beam_struct%one_turn_time: 0D_NOT_real

  subroutine bbu_beam_struct_get_one_turn_time(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_one_turn_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%one_turn_time
  end subroutine


  subroutine bbu_beam_struct_set_one_turn_time(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_one_turn_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%one_turn_time = value_in
  end subroutine

  ! bbu_beam_struct%rf_wavelength_max: 0D_NOT_real

  subroutine bbu_beam_struct_get_rf_wavelength_max(struct_obj_ptr, value_out) bind(c, name='bbu_beam_struct_get_rf_wavelength_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_wavelength_max
  end subroutine


  subroutine bbu_beam_struct_set_rf_wavelength_max(struct_obj_ptr, value_in) bind(c, name='bbu_beam_struct_set_rf_wavelength_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_wavelength_max = value_in
  end subroutine

  !! bbu_param_struct

    function allocate_fortran_bbu_param_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(bbu_param_struct), pointer :: fptr
      type(bbu_param_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_bbu_param_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(bbu_param_struct), pointer :: fptr
      type(bbu_param_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_bbu_param_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bbu_param_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_bbu_param_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(bbu_param_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_bbu_param_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(bbu_param_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_bbu_param_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(bbu_param_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_bbu_param_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(bbu_param_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! bbu_param_struct%lat_filename: 0D_NOT_character

  subroutine bbu_param_struct_get_lat_filename_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='bbu_param_struct_get_lat_filename_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%lat_filename)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%lat_filename), c_int)
    is_allocated = .true.
  end subroutine


  subroutine bbu_param_struct_set_lat_filename(struct_obj_ptr, str_ptr, str_len) bind(c, name='bbu_param_struct_set_lat_filename')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(bbu_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%lat_filename = str_in ! implicitly handles padding
  end subroutine

  ! bbu_param_struct%lat2_filename: 0D_NOT_character

  subroutine bbu_param_struct_get_lat2_filename_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='bbu_param_struct_get_lat2_filename_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%lat2_filename)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%lat2_filename), c_int)
    is_allocated = .true.
  end subroutine


  subroutine bbu_param_struct_set_lat2_filename(struct_obj_ptr, str_ptr, str_len) bind(c, name='bbu_param_struct_set_lat2_filename')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(bbu_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%lat2_filename = str_in ! implicitly handles padding
  end subroutine

  ! bbu_param_struct%bunch_by_bunch_info_file: 0D_NOT_character

  subroutine bbu_param_struct_get_bunch_by_bunch_info_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='bbu_param_struct_get_bunch_by_bunch_info_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%bunch_by_bunch_info_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%bunch_by_bunch_info_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine bbu_param_struct_set_bunch_by_bunch_info_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='bbu_param_struct_set_bunch_by_bunch_info_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(bbu_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%bunch_by_bunch_info_file = str_in ! implicitly handles padding
  end subroutine

  ! bbu_param_struct%hybridize: 0D_NOT_logical

  subroutine bbu_param_struct_get_hybridize(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_hybridize')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%hybridize
  end subroutine


  subroutine bbu_param_struct_set_hybridize(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_hybridize')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%hybridize = value_in
  end subroutine

  ! bbu_param_struct%write_digested_hybrid_lat: 0D_NOT_logical

  subroutine bbu_param_struct_get_write_digested_hybrid_lat(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_write_digested_hybrid_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%write_digested_hybrid_lat
  end subroutine


  subroutine bbu_param_struct_set_write_digested_hybrid_lat(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_write_digested_hybrid_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%write_digested_hybrid_lat = value_in
  end subroutine

  ! bbu_param_struct%write_voltage_vs_time_dat: 0D_NOT_logical

  subroutine bbu_param_struct_get_write_voltage_vs_time_dat(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_write_voltage_vs_time_dat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%write_voltage_vs_time_dat
  end subroutine


  subroutine bbu_param_struct_set_write_voltage_vs_time_dat(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_write_voltage_vs_time_dat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%write_voltage_vs_time_dat = value_in
  end subroutine

  ! bbu_param_struct%keep_overlays_and_groups: 0D_NOT_logical

  subroutine bbu_param_struct_get_keep_overlays_and_groups(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_keep_overlays_and_groups')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%keep_overlays_and_groups
  end subroutine


  subroutine bbu_param_struct_set_keep_overlays_and_groups(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_keep_overlays_and_groups')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%keep_overlays_and_groups = value_in
  end subroutine

  ! bbu_param_struct%keep_all_lcavities: 0D_NOT_logical

  subroutine bbu_param_struct_get_keep_all_lcavities(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_keep_all_lcavities')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%keep_all_lcavities
  end subroutine


  subroutine bbu_param_struct_set_keep_all_lcavities(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_keep_all_lcavities')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%keep_all_lcavities = value_in
  end subroutine

  ! bbu_param_struct%use_taylor_for_hybrids: 0D_NOT_logical

  subroutine bbu_param_struct_get_use_taylor_for_hybrids(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_use_taylor_for_hybrids')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_taylor_for_hybrids
  end subroutine


  subroutine bbu_param_struct_set_use_taylor_for_hybrids(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_use_taylor_for_hybrids')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_taylor_for_hybrids = value_in
  end subroutine

  ! bbu_param_struct%stable_orbit_anal: 0D_NOT_logical

  subroutine bbu_param_struct_get_stable_orbit_anal(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_stable_orbit_anal')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stable_orbit_anal
  end subroutine


  subroutine bbu_param_struct_set_stable_orbit_anal(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_stable_orbit_anal')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stable_orbit_anal = value_in
  end subroutine

  ! bbu_param_struct%limit_factor: 0D_NOT_real

  subroutine bbu_param_struct_get_limit_factor(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_limit_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%limit_factor
  end subroutine


  subroutine bbu_param_struct_set_limit_factor(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_limit_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%limit_factor = value_in
  end subroutine

  ! bbu_param_struct%simulation_turns_max: 0D_NOT_real

  subroutine bbu_param_struct_get_simulation_turns_max(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_simulation_turns_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%simulation_turns_max
  end subroutine


  subroutine bbu_param_struct_set_simulation_turns_max(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_simulation_turns_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%simulation_turns_max = value_in
  end subroutine

  ! bbu_param_struct%bunch_freq: 0D_NOT_real

  subroutine bbu_param_struct_get_bunch_freq(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_bunch_freq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bunch_freq
  end subroutine


  subroutine bbu_param_struct_set_bunch_freq(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_bunch_freq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bunch_freq = value_in
  end subroutine

  ! bbu_param_struct%init_particle_offset: 0D_NOT_real

  subroutine bbu_param_struct_get_init_particle_offset(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_init_particle_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_particle_offset
  end subroutine


  subroutine bbu_param_struct_set_init_particle_offset(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_init_particle_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_particle_offset = value_in
  end subroutine

  ! bbu_param_struct%current: 0D_NOT_real

  subroutine bbu_param_struct_get_current(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_current')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%current
  end subroutine


  subroutine bbu_param_struct_set_current(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_current')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%current = value_in
  end subroutine

  ! bbu_param_struct%rel_tol: 0D_NOT_real

  subroutine bbu_param_struct_get_rel_tol(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_rel_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol
  end subroutine


  subroutine bbu_param_struct_set_rel_tol(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_rel_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol = value_in
  end subroutine

  ! bbu_param_struct%drscan: 0D_NOT_logical

  subroutine bbu_param_struct_get_drscan(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_drscan')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%drscan
  end subroutine


  subroutine bbu_param_struct_set_drscan(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_drscan')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%drscan = value_in
  end subroutine

  ! bbu_param_struct%use_interpolated_threshold: 0D_NOT_logical

  subroutine bbu_param_struct_get_use_interpolated_threshold(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_use_interpolated_threshold')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_interpolated_threshold
  end subroutine


  subroutine bbu_param_struct_set_use_interpolated_threshold(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_use_interpolated_threshold')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_interpolated_threshold = value_in
  end subroutine

  ! bbu_param_struct%write_hom_info: 0D_NOT_logical

  subroutine bbu_param_struct_get_write_hom_info(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_write_hom_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%write_hom_info
  end subroutine


  subroutine bbu_param_struct_set_write_hom_info(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_write_hom_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%write_hom_info = value_in
  end subroutine

  ! bbu_param_struct%elindex: 0D_NOT_integer

  subroutine bbu_param_struct_get_elindex(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_elindex')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%elindex
  end subroutine


  subroutine bbu_param_struct_set_elindex(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_elindex')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%elindex = value_in
  end subroutine

  ! bbu_param_struct%elname: 0D_NOT_character

  subroutine bbu_param_struct_get_elname_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='bbu_param_struct_get_elname_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%elname)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%elname), c_int)
    is_allocated = .true.
  end subroutine


  subroutine bbu_param_struct_set_elname(struct_obj_ptr, str_ptr, str_len) bind(c, name='bbu_param_struct_set_elname')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(bbu_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%elname = str_in ! implicitly handles padding
  end subroutine

  ! bbu_param_struct%nstep: 0D_NOT_integer

  subroutine bbu_param_struct_get_nstep(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_nstep')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%nstep
  end subroutine


  subroutine bbu_param_struct_set_nstep(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_nstep')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%nstep = value_in
  end subroutine

  ! bbu_param_struct%begdr: 0D_NOT_real

  subroutine bbu_param_struct_get_begdr(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_begdr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%begdr
  end subroutine


  subroutine bbu_param_struct_set_begdr(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_begdr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%begdr = value_in
  end subroutine

  ! bbu_param_struct%enddr: 0D_NOT_real

  subroutine bbu_param_struct_get_enddr(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_enddr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%enddr
  end subroutine


  subroutine bbu_param_struct_set_enddr(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_enddr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%enddr = value_in
  end subroutine

  ! bbu_param_struct%nrep: 0D_NOT_integer

  subroutine bbu_param_struct_get_nrep(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_nrep')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%nrep
  end subroutine


  subroutine bbu_param_struct_set_nrep(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_nrep')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%nrep = value_in
  end subroutine

  ! bbu_param_struct%ran_seed: 0D_NOT_integer

  subroutine bbu_param_struct_get_ran_seed(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_ran_seed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ran_seed
  end subroutine


  subroutine bbu_param_struct_set_ran_seed(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_ran_seed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ran_seed = value_in
  end subroutine

  ! bbu_param_struct%hom_order_cutoff: 0D_NOT_integer

  subroutine bbu_param_struct_get_hom_order_cutoff(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_hom_order_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%hom_order_cutoff
  end subroutine


  subroutine bbu_param_struct_set_hom_order_cutoff(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_hom_order_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%hom_order_cutoff = value_in
  end subroutine

  ! bbu_param_struct%ran_gauss_sigma_cut: 0D_NOT_real

  subroutine bbu_param_struct_get_ran_gauss_sigma_cut(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_ran_gauss_sigma_cut')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ran_gauss_sigma_cut
  end subroutine


  subroutine bbu_param_struct_set_ran_gauss_sigma_cut(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_ran_gauss_sigma_cut')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ran_gauss_sigma_cut = value_in
  end subroutine

  ! bbu_param_struct%ele_track_end: 0D_NOT_character

  subroutine bbu_param_struct_get_ele_track_end_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='bbu_param_struct_get_ele_track_end_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_track_end)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_track_end), c_int)
    is_allocated = .true.
  end subroutine


  subroutine bbu_param_struct_set_ele_track_end(struct_obj_ptr, str_ptr, str_len) bind(c, name='bbu_param_struct_set_ele_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(bbu_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_track_end = str_in ! implicitly handles padding
  end subroutine

  ! bbu_param_struct%ix_ele_track_end: 0D_NOT_integer

  subroutine bbu_param_struct_get_ix_ele_track_end(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_ix_ele_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_track_end
  end subroutine


  subroutine bbu_param_struct_set_ix_ele_track_end(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_ix_ele_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_track_end = value_in
  end subroutine

  ! bbu_param_struct%regression: 0D_NOT_logical

  subroutine bbu_param_struct_get_regression(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_regression')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%regression
  end subroutine


  subroutine bbu_param_struct_set_regression(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_regression')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%regression = value_in
  end subroutine

  ! bbu_param_struct%normalize_z_to_rf: 0D_NOT_logical

  subroutine bbu_param_struct_get_normalize_z_to_rf(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_normalize_z_to_rf')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%normalize_z_to_rf
  end subroutine


  subroutine bbu_param_struct_set_normalize_z_to_rf(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_normalize_z_to_rf')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%normalize_z_to_rf = value_in
  end subroutine

  ! bbu_param_struct%ramp_on: 0D_NOT_logical

  subroutine bbu_param_struct_get_ramp_on(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_ramp_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ramp_on
  end subroutine


  subroutine bbu_param_struct_set_ramp_on(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_ramp_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ramp_on = value_in
  end subroutine

  ! bbu_param_struct%ramp_pattern: 1D_NOT_real

  subroutine bbu_param_struct_get_ramp_pattern_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bbu_param_struct_get_ramp_pattern_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bbu_param_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%ramp_pattern)) then
      data_ptr = c_loc(struct_obj%ramp_pattern(lbound(struct_obj%ramp_pattern, 1)))
      bounds(1) = int(lbound(struct_obj%ramp_pattern, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ramp_pattern, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bbu_param_struct%ramp_n_start: 0D_NOT_integer

  subroutine bbu_param_struct_get_ramp_n_start(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_ramp_n_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ramp_n_start
  end subroutine


  subroutine bbu_param_struct_set_ramp_n_start(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_ramp_n_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ramp_n_start = value_in
  end subroutine

  ! bbu_param_struct%n_ramp_pattern: 0D_NOT_integer

  subroutine bbu_param_struct_get_n_ramp_pattern(struct_obj_ptr, value_out) bind(c, name='bbu_param_struct_get_n_ramp_pattern')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ramp_pattern
  end subroutine


  subroutine bbu_param_struct_set_n_ramp_pattern(struct_obj_ptr, value_in) bind(c, name='bbu_param_struct_set_n_ramp_pattern')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bbu_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ramp_pattern = value_in
  end subroutine

  !! all_encompassing_struct

    function allocate_fortran_all_encompassing_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(all_encompassing_struct), pointer :: fptr
      type(all_encompassing_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_all_encompassing_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(all_encompassing_struct), pointer :: fptr
      type(all_encompassing_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_all_encompassing_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(all_encompassing_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_all_encompassing_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(all_encompassing_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_all_encompassing_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(all_encompassing_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_all_encompassing_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(all_encompassing_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_all_encompassing_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(all_encompassing_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! all_encompassing_struct%real_rp_0d: 0D_NOT_real

  subroutine all_encompassing_struct_get_real_rp_0d(struct_obj_ptr, value_out) bind(c, name='all_encompassing_struct_get_real_rp_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%real_rp_0d
  end subroutine


  subroutine all_encompassing_struct_set_real_rp_0d(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_real_rp_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%real_rp_0d = value_in
  end subroutine

  ! all_encompassing_struct%real_rp_1d: 1D_NOT_real

  subroutine all_encompassing_struct_get_real_rp_1d_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_1d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%real_rp_1d)) then
      data_ptr = c_loc(struct_obj%real_rp_1d(lbound(struct_obj%real_rp_1d, 1)))
      bounds(1) = int(lbound(struct_obj%real_rp_1d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_1d, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_2d: 2D_NOT_real

  subroutine all_encompassing_struct_get_real_rp_2d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_2d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%real_rp_2d)) then
      data_ptr = c_loc(struct_obj%real_rp_2d(lbound(struct_obj%real_rp_2d, 1), lbound(struct_obj%real_rp_2d, 2)))
      bounds(1) = int(lbound(struct_obj%real_rp_2d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_2d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_rp_2d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_rp_2d, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_3d: 3D_NOT_real

  subroutine all_encompassing_struct_get_real_rp_3d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%real_rp_3d)) then
      data_ptr = c_loc(struct_obj%real_rp_3d(lbound(struct_obj%real_rp_3d, 1), lbound(struct_obj%real_rp_3d, 2), lbound(struct_obj%real_rp_3d, 3)))
      bounds(1) = int(lbound(struct_obj%real_rp_3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_3d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_rp_3d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_rp_3d, 2), c_int)
      bounds(5) = int(lbound(struct_obj%real_rp_3d, 3), c_int)
      bounds(6) = int(ubound(struct_obj%real_rp_3d, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_0d_ptr: 0D_PTR_real

  subroutine all_encompassing_struct_get_real_rp_0d_ptr(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_real_rp_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%real_rp_0d_ptr)) then
      ptr_out = c_loc(struct_obj%real_rp_0d_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine all_encompassing_struct_set_real_rp_0d_ptr(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_real_rp_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%real_rp_0d_ptr)) then
      struct_obj%real_rp_0d_ptr = value_in
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_1d_ptr: 1D_PTR_real

  subroutine all_encompassing_struct_get_real_rp_1d_ptr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_1d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%real_rp_1d_ptr) .and. is_contiguous(struct_obj%real_rp_1d_ptr)) then
      data_ptr = c_loc(struct_obj%real_rp_1d_ptr(lbound(struct_obj%real_rp_1d_ptr, 1)))
      bounds(1) = int(lbound(struct_obj%real_rp_1d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_1d_ptr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_2d_ptr: 2D_PTR_real

  subroutine all_encompassing_struct_get_real_rp_2d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_2d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%real_rp_2d_ptr) .and. is_contiguous(struct_obj%real_rp_2d_ptr)) then
      data_ptr = c_loc(struct_obj%real_rp_2d_ptr(lbound(struct_obj%real_rp_2d_ptr, 1), lbound(struct_obj%real_rp_2d_ptr, 2)))
      bounds(1) = int(lbound(struct_obj%real_rp_2d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_2d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_rp_2d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_rp_2d_ptr, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_3d_ptr: 3D_PTR_real

  subroutine all_encompassing_struct_get_real_rp_3d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_3d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%real_rp_3d_ptr) .and. is_contiguous(struct_obj%real_rp_3d_ptr)) then
      data_ptr = c_loc(struct_obj%real_rp_3d_ptr(lbound(struct_obj%real_rp_3d_ptr, 1), lbound(struct_obj%real_rp_3d_ptr, 2), lbound(struct_obj%real_rp_3d_ptr, 3)))
      bounds(1) = int(lbound(struct_obj%real_rp_3d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_3d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_rp_3d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_rp_3d_ptr, 2), c_int)
      bounds(5) = int(lbound(struct_obj%real_rp_3d_ptr, 3), c_int)
      bounds(6) = int(ubound(struct_obj%real_rp_3d_ptr, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_1d_alloc: 1D_ALLOC_real

  subroutine all_encompassing_struct_get_real_rp_1d_alloc_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_1d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%real_rp_1d_alloc) .and. is_contiguous(struct_obj%real_rp_1d_alloc)) then
      data_ptr = c_loc(struct_obj%real_rp_1d_alloc(lbound(struct_obj%real_rp_1d_alloc, 1)))
      bounds(1) = int(lbound(struct_obj%real_rp_1d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_1d_alloc, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_2d_alloc: 2D_ALLOC_real

  subroutine all_encompassing_struct_get_real_rp_2d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_2d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%real_rp_2d_alloc) .and. is_contiguous(struct_obj%real_rp_2d_alloc)) then
      data_ptr = c_loc(struct_obj%real_rp_2d_alloc(lbound(struct_obj%real_rp_2d_alloc, 1), lbound(struct_obj%real_rp_2d_alloc, 2)))
      bounds(1) = int(lbound(struct_obj%real_rp_2d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_2d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_rp_2d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_rp_2d_alloc, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_rp_3d_alloc: 3D_ALLOC_real

  subroutine all_encompassing_struct_get_real_rp_3d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_rp_3d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%real_rp_3d_alloc) .and. is_contiguous(struct_obj%real_rp_3d_alloc)) then
      data_ptr = c_loc(struct_obj%real_rp_3d_alloc(lbound(struct_obj%real_rp_3d_alloc, 1), lbound(struct_obj%real_rp_3d_alloc, 2), lbound(struct_obj%real_rp_3d_alloc, 3)))
      bounds(1) = int(lbound(struct_obj%real_rp_3d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_rp_3d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_rp_3d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_rp_3d_alloc, 2), c_int)
      bounds(5) = int(lbound(struct_obj%real_rp_3d_alloc, 3), c_int)
      bounds(6) = int(ubound(struct_obj%real_rp_3d_alloc, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_0d: 0D_NOT_real

  subroutine all_encompassing_struct_get_real_dp_0d(struct_obj_ptr, value_out) bind(c, name='all_encompassing_struct_get_real_dp_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%real_dp_0d
  end subroutine


  subroutine all_encompassing_struct_set_real_dp_0d(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_real_dp_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%real_dp_0d = value_in
  end subroutine

  ! all_encompassing_struct%real_dp_1d: 1D_NOT_real

  subroutine all_encompassing_struct_get_real_dp_1d_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_1d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%real_dp_1d)) then
      data_ptr = c_loc(struct_obj%real_dp_1d(lbound(struct_obj%real_dp_1d, 1)))
      bounds(1) = int(lbound(struct_obj%real_dp_1d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_1d, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_2d: 2D_NOT_real

  subroutine all_encompassing_struct_get_real_dp_2d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_2d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%real_dp_2d)) then
      data_ptr = c_loc(struct_obj%real_dp_2d(lbound(struct_obj%real_dp_2d, 1), lbound(struct_obj%real_dp_2d, 2)))
      bounds(1) = int(lbound(struct_obj%real_dp_2d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_2d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_dp_2d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_dp_2d, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_3d: 3D_NOT_real

  subroutine all_encompassing_struct_get_real_dp_3d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%real_dp_3d)) then
      data_ptr = c_loc(struct_obj%real_dp_3d(lbound(struct_obj%real_dp_3d, 1), lbound(struct_obj%real_dp_3d, 2), lbound(struct_obj%real_dp_3d, 3)))
      bounds(1) = int(lbound(struct_obj%real_dp_3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_3d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_dp_3d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_dp_3d, 2), c_int)
      bounds(5) = int(lbound(struct_obj%real_dp_3d, 3), c_int)
      bounds(6) = int(ubound(struct_obj%real_dp_3d, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_0d_ptr: 0D_PTR_real

  subroutine all_encompassing_struct_get_real_dp_0d_ptr(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_real_dp_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%real_dp_0d_ptr)) then
      ptr_out = c_loc(struct_obj%real_dp_0d_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine all_encompassing_struct_set_real_dp_0d_ptr(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_real_dp_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%real_dp_0d_ptr)) then
      struct_obj%real_dp_0d_ptr = value_in
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_1d_ptr: 1D_PTR_real

  subroutine all_encompassing_struct_get_real_dp_1d_ptr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_1d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%real_dp_1d_ptr) .and. is_contiguous(struct_obj%real_dp_1d_ptr)) then
      data_ptr = c_loc(struct_obj%real_dp_1d_ptr(lbound(struct_obj%real_dp_1d_ptr, 1)))
      bounds(1) = int(lbound(struct_obj%real_dp_1d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_1d_ptr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_2d_ptr: 2D_PTR_real

  subroutine all_encompassing_struct_get_real_dp_2d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_2d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%real_dp_2d_ptr) .and. is_contiguous(struct_obj%real_dp_2d_ptr)) then
      data_ptr = c_loc(struct_obj%real_dp_2d_ptr(lbound(struct_obj%real_dp_2d_ptr, 1), lbound(struct_obj%real_dp_2d_ptr, 2)))
      bounds(1) = int(lbound(struct_obj%real_dp_2d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_2d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_dp_2d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_dp_2d_ptr, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_3d_ptr: 3D_PTR_real

  subroutine all_encompassing_struct_get_real_dp_3d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_3d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%real_dp_3d_ptr) .and. is_contiguous(struct_obj%real_dp_3d_ptr)) then
      data_ptr = c_loc(struct_obj%real_dp_3d_ptr(lbound(struct_obj%real_dp_3d_ptr, 1), lbound(struct_obj%real_dp_3d_ptr, 2), lbound(struct_obj%real_dp_3d_ptr, 3)))
      bounds(1) = int(lbound(struct_obj%real_dp_3d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_3d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_dp_3d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_dp_3d_ptr, 2), c_int)
      bounds(5) = int(lbound(struct_obj%real_dp_3d_ptr, 3), c_int)
      bounds(6) = int(ubound(struct_obj%real_dp_3d_ptr, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_1d_alloc: 1D_ALLOC_real

  subroutine all_encompassing_struct_get_real_dp_1d_alloc_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_1d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%real_dp_1d_alloc) .and. is_contiguous(struct_obj%real_dp_1d_alloc)) then
      data_ptr = c_loc(struct_obj%real_dp_1d_alloc(lbound(struct_obj%real_dp_1d_alloc, 1)))
      bounds(1) = int(lbound(struct_obj%real_dp_1d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_1d_alloc, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_2d_alloc: 2D_ALLOC_real

  subroutine all_encompassing_struct_get_real_dp_2d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_2d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%real_dp_2d_alloc) .and. is_contiguous(struct_obj%real_dp_2d_alloc)) then
      data_ptr = c_loc(struct_obj%real_dp_2d_alloc(lbound(struct_obj%real_dp_2d_alloc, 1), lbound(struct_obj%real_dp_2d_alloc, 2)))
      bounds(1) = int(lbound(struct_obj%real_dp_2d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_2d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_dp_2d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_dp_2d_alloc, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%real_dp_3d_alloc: 3D_ALLOC_real

  subroutine all_encompassing_struct_get_real_dp_3d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_real_dp_3d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%real_dp_3d_alloc) .and. is_contiguous(struct_obj%real_dp_3d_alloc)) then
      data_ptr = c_loc(struct_obj%real_dp_3d_alloc(lbound(struct_obj%real_dp_3d_alloc, 1), lbound(struct_obj%real_dp_3d_alloc, 2), lbound(struct_obj%real_dp_3d_alloc, 3)))
      bounds(1) = int(lbound(struct_obj%real_dp_3d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%real_dp_3d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%real_dp_3d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%real_dp_3d_alloc, 2), c_int)
      bounds(5) = int(lbound(struct_obj%real_dp_3d_alloc, 3), c_int)
      bounds(6) = int(ubound(struct_obj%real_dp_3d_alloc, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_0d: 0D_NOT_complex

  subroutine all_encompassing_struct_get_complex_dp_0d(struct_obj_ptr, value_out) bind(c, name='all_encompassing_struct_get_complex_dp_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%complex_dp_0d
  end subroutine


  subroutine all_encompassing_struct_set_complex_dp_0d(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_complex_dp_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%complex_dp_0d = value_in
  end subroutine

  ! all_encompassing_struct%complex_dp_1d: 1D_NOT_complex

  subroutine all_encompassing_struct_get_complex_dp_1d_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_1d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%complex_dp_1d)) then
      data_ptr = c_loc(struct_obj%complex_dp_1d(lbound(struct_obj%complex_dp_1d, 1)))
      bounds(1) = int(lbound(struct_obj%complex_dp_1d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_1d, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_2d: 2D_NOT_complex

  subroutine all_encompassing_struct_get_complex_dp_2d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_2d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%complex_dp_2d)) then
      data_ptr = c_loc(struct_obj%complex_dp_2d(lbound(struct_obj%complex_dp_2d, 1), lbound(struct_obj%complex_dp_2d, 2)))
      bounds(1) = int(lbound(struct_obj%complex_dp_2d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_2d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%complex_dp_2d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%complex_dp_2d, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_3d: 3D_NOT_complex

  subroutine all_encompassing_struct_get_complex_dp_3d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%complex_dp_3d)) then
      data_ptr = c_loc(struct_obj%complex_dp_3d(lbound(struct_obj%complex_dp_3d, 1), lbound(struct_obj%complex_dp_3d, 2), lbound(struct_obj%complex_dp_3d, 3)))
      bounds(1) = int(lbound(struct_obj%complex_dp_3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_3d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%complex_dp_3d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%complex_dp_3d, 2), c_int)
      bounds(5) = int(lbound(struct_obj%complex_dp_3d, 3), c_int)
      bounds(6) = int(ubound(struct_obj%complex_dp_3d, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_1d_ptr: 1D_PTR_complex

  subroutine all_encompassing_struct_get_complex_dp_1d_ptr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_1d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%complex_dp_1d_ptr) .and. is_contiguous(struct_obj%complex_dp_1d_ptr)) then
      data_ptr = c_loc(struct_obj%complex_dp_1d_ptr(lbound(struct_obj%complex_dp_1d_ptr, 1)))
      bounds(1) = int(lbound(struct_obj%complex_dp_1d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_1d_ptr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_2d_ptr: 2D_PTR_complex

  subroutine all_encompassing_struct_get_complex_dp_2d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_2d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%complex_dp_2d_ptr) .and. is_contiguous(struct_obj%complex_dp_2d_ptr)) then
      data_ptr = c_loc(struct_obj%complex_dp_2d_ptr(lbound(struct_obj%complex_dp_2d_ptr, 1), lbound(struct_obj%complex_dp_2d_ptr, 2)))
      bounds(1) = int(lbound(struct_obj%complex_dp_2d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_2d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%complex_dp_2d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%complex_dp_2d_ptr, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_3d_ptr: 3D_PTR_complex

  subroutine all_encompassing_struct_get_complex_dp_3d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_3d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%complex_dp_3d_ptr) .and. is_contiguous(struct_obj%complex_dp_3d_ptr)) then
      data_ptr = c_loc(struct_obj%complex_dp_3d_ptr(lbound(struct_obj%complex_dp_3d_ptr, 1), lbound(struct_obj%complex_dp_3d_ptr, 2), lbound(struct_obj%complex_dp_3d_ptr, 3)))
      bounds(1) = int(lbound(struct_obj%complex_dp_3d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_3d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%complex_dp_3d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%complex_dp_3d_ptr, 2), c_int)
      bounds(5) = int(lbound(struct_obj%complex_dp_3d_ptr, 3), c_int)
      bounds(6) = int(ubound(struct_obj%complex_dp_3d_ptr, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_1d_alloc: 1D_ALLOC_complex

  subroutine all_encompassing_struct_get_complex_dp_1d_alloc_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_1d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%complex_dp_1d_alloc) .and. is_contiguous(struct_obj%complex_dp_1d_alloc)) then
      data_ptr = c_loc(struct_obj%complex_dp_1d_alloc(lbound(struct_obj%complex_dp_1d_alloc, 1)))
      bounds(1) = int(lbound(struct_obj%complex_dp_1d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_1d_alloc, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_2d_alloc: 2D_ALLOC_complex

  subroutine all_encompassing_struct_get_complex_dp_2d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_2d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%complex_dp_2d_alloc) .and. is_contiguous(struct_obj%complex_dp_2d_alloc)) then
      data_ptr = c_loc(struct_obj%complex_dp_2d_alloc(lbound(struct_obj%complex_dp_2d_alloc, 1), lbound(struct_obj%complex_dp_2d_alloc, 2)))
      bounds(1) = int(lbound(struct_obj%complex_dp_2d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_2d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%complex_dp_2d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%complex_dp_2d_alloc, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%complex_dp_3d_alloc: 3D_ALLOC_complex

  subroutine all_encompassing_struct_get_complex_dp_3d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_complex_dp_3d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%complex_dp_3d_alloc) .and. is_contiguous(struct_obj%complex_dp_3d_alloc)) then
      data_ptr = c_loc(struct_obj%complex_dp_3d_alloc(lbound(struct_obj%complex_dp_3d_alloc, 1), lbound(struct_obj%complex_dp_3d_alloc, 2), lbound(struct_obj%complex_dp_3d_alloc, 3)))
      bounds(1) = int(lbound(struct_obj%complex_dp_3d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%complex_dp_3d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%complex_dp_3d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%complex_dp_3d_alloc, 2), c_int)
      bounds(5) = int(lbound(struct_obj%complex_dp_3d_alloc, 3), c_int)
      bounds(6) = int(ubound(struct_obj%complex_dp_3d_alloc, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_0d: 0D_NOT_integer

  subroutine all_encompassing_struct_get_int_0d(struct_obj_ptr, value_out) bind(c, name='all_encompassing_struct_get_int_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%int_0d
  end subroutine


  subroutine all_encompassing_struct_set_int_0d(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_int_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%int_0d = value_in
  end subroutine

  ! all_encompassing_struct%int_1d: 1D_NOT_integer

  subroutine all_encompassing_struct_get_int_1d_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_1d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%int_1d)) then
      data_ptr = c_loc(struct_obj%int_1d(lbound(struct_obj%int_1d, 1)))
      bounds(1) = int(lbound(struct_obj%int_1d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_1d, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_2d: 2D_NOT_integer

  subroutine all_encompassing_struct_get_int_2d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_2d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%int_2d)) then
      data_ptr = c_loc(struct_obj%int_2d(lbound(struct_obj%int_2d, 1), lbound(struct_obj%int_2d, 2)))
      bounds(1) = int(lbound(struct_obj%int_2d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_2d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%int_2d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%int_2d, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_3d: 3D_NOT_integer

  subroutine all_encompassing_struct_get_int_3d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%int_3d)) then
      data_ptr = c_loc(struct_obj%int_3d(lbound(struct_obj%int_3d, 1), lbound(struct_obj%int_3d, 2), lbound(struct_obj%int_3d, 3)))
      bounds(1) = int(lbound(struct_obj%int_3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_3d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%int_3d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%int_3d, 2), c_int)
      bounds(5) = int(lbound(struct_obj%int_3d, 3), c_int)
      bounds(6) = int(ubound(struct_obj%int_3d, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_0d_ptr: 0D_PTR_integer

  subroutine all_encompassing_struct_get_int_0d_ptr(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_int_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%int_0d_ptr)) then
      ptr_out = c_loc(struct_obj%int_0d_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine all_encompassing_struct_set_int_0d_ptr(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_int_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%int_0d_ptr)) then
      struct_obj%int_0d_ptr = value_in
    endif
  end subroutine

  ! all_encompassing_struct%int_1d_ptr: 1D_PTR_integer

  subroutine all_encompassing_struct_get_int_1d_ptr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_1d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%int_1d_ptr) .and. is_contiguous(struct_obj%int_1d_ptr)) then
      data_ptr = c_loc(struct_obj%int_1d_ptr(lbound(struct_obj%int_1d_ptr, 1)))
      bounds(1) = int(lbound(struct_obj%int_1d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_1d_ptr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_2d_ptr: 2D_PTR_integer

  subroutine all_encompassing_struct_get_int_2d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_2d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%int_2d_ptr) .and. is_contiguous(struct_obj%int_2d_ptr)) then
      data_ptr = c_loc(struct_obj%int_2d_ptr(lbound(struct_obj%int_2d_ptr, 1), lbound(struct_obj%int_2d_ptr, 2)))
      bounds(1) = int(lbound(struct_obj%int_2d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_2d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%int_2d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%int_2d_ptr, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_3d_ptr: 3D_PTR_integer

  subroutine all_encompassing_struct_get_int_3d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_3d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%int_3d_ptr) .and. is_contiguous(struct_obj%int_3d_ptr)) then
      data_ptr = c_loc(struct_obj%int_3d_ptr(lbound(struct_obj%int_3d_ptr, 1), lbound(struct_obj%int_3d_ptr, 2), lbound(struct_obj%int_3d_ptr, 3)))
      bounds(1) = int(lbound(struct_obj%int_3d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_3d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%int_3d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%int_3d_ptr, 2), c_int)
      bounds(5) = int(lbound(struct_obj%int_3d_ptr, 3), c_int)
      bounds(6) = int(ubound(struct_obj%int_3d_ptr, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_1d_alloc: 1D_ALLOC_integer

  subroutine all_encompassing_struct_get_int_1d_alloc_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_1d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%int_1d_alloc) .and. is_contiguous(struct_obj%int_1d_alloc)) then
      data_ptr = c_loc(struct_obj%int_1d_alloc(lbound(struct_obj%int_1d_alloc, 1)))
      bounds(1) = int(lbound(struct_obj%int_1d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_1d_alloc, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_2d_alloc: 2D_ALLOC_integer

  subroutine all_encompassing_struct_get_int_2d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_2d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%int_2d_alloc) .and. is_contiguous(struct_obj%int_2d_alloc)) then
      data_ptr = c_loc(struct_obj%int_2d_alloc(lbound(struct_obj%int_2d_alloc, 1), lbound(struct_obj%int_2d_alloc, 2)))
      bounds(1) = int(lbound(struct_obj%int_2d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_2d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%int_2d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%int_2d_alloc, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int_3d_alloc: 3D_ALLOC_integer

  subroutine all_encompassing_struct_get_int_3d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='all_encompassing_struct_get_int_3d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%int_3d_alloc) .and. is_contiguous(struct_obj%int_3d_alloc)) then
      data_ptr = c_loc(struct_obj%int_3d_alloc(lbound(struct_obj%int_3d_alloc, 1), lbound(struct_obj%int_3d_alloc, 2), lbound(struct_obj%int_3d_alloc, 3)))
      bounds(1) = int(lbound(struct_obj%int_3d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int_3d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%int_3d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%int_3d_alloc, 2), c_int)
      bounds(5) = int(lbound(struct_obj%int_3d_alloc, 3), c_int)
      bounds(6) = int(ubound(struct_obj%int_3d_alloc, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%int8_0d: 0D_NOT_integer8

  subroutine all_encompassing_struct_get_int8_0d(struct_obj_ptr, value_out) bind(c, name='all_encompassing_struct_get_int8_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%int8_0d
  end subroutine


  subroutine all_encompassing_struct_set_int8_0d(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_int8_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%int8_0d = value_in
  end subroutine

  ! skipped all_encompassing_struct%int8_1d: Unsupported type: 1D_NOT_integer8
  ! skipped all_encompassing_struct%int8_2d: Unsupported type: 2D_NOT_integer8
  ! skipped all_encompassing_struct%int8_3d: Unsupported type: 3D_NOT_integer8
  ! all_encompassing_struct%int8_0d_ptr: 0D_PTR_integer8

  subroutine all_encompassing_struct_get_int8_0d_ptr(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_int8_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%int8_0d_ptr)) then
      ptr_out = c_loc(struct_obj%int8_0d_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine all_encompassing_struct_set_int8_0d_ptr(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_int8_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%int8_0d_ptr)) then
      struct_obj%int8_0d_ptr = value_in
    endif
  end subroutine

  ! skipped all_encompassing_struct%int8_1d_ptr: Unsupported type: 1D_PTR_integer8
  ! skipped all_encompassing_struct%int8_2d_ptr: Unsupported type: 2D_PTR_integer8
  ! skipped all_encompassing_struct%int8_3d_ptr: Unsupported type: 3D_PTR_integer8
  ! skipped all_encompassing_struct%int8_1d_alloc: Unsupported type: 1D_ALLOC_integer8
  ! skipped all_encompassing_struct%int8_2d_alloc: Unsupported type: 2D_ALLOC_integer8
  ! skipped all_encompassing_struct%int8_3d_alloc: Unsupported type: 3D_ALLOC_integer8
  ! all_encompassing_struct%logical_0d: 0D_NOT_logical

  subroutine all_encompassing_struct_get_logical_0d(struct_obj_ptr, value_out) bind(c, name='all_encompassing_struct_get_logical_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%logical_0d
  end subroutine


  subroutine all_encompassing_struct_set_logical_0d(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_logical_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%logical_0d = value_in
  end subroutine

  ! skipped all_encompassing_struct%logical_1d: Unsupported type: 1D_NOT_logical
  ! skipped all_encompassing_struct%logical_2d: Unsupported type: 2D_NOT_logical
  ! skipped all_encompassing_struct%logical_3d: Unsupported type: 3D_NOT_logical
  ! all_encompassing_struct%logical_0d_ptr: 0D_PTR_logical

  subroutine all_encompassing_struct_get_logical_0d_ptr(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_logical_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%logical_0d_ptr)) then
      ptr_out = c_loc(struct_obj%logical_0d_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine all_encompassing_struct_set_logical_0d_ptr(struct_obj_ptr, value_in) bind(c, name='all_encompassing_struct_set_logical_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%logical_0d_ptr)) then
      struct_obj%logical_0d_ptr = value_in
    endif
  end subroutine

  ! all_encompassing_struct%type_0d: 0D_NOT_type

  subroutine all_encompassing_struct_get_type_0d(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_type_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%type_0d)
  end subroutine


  subroutine all_encompassing_struct_set_type_0d(struct_obj_ptr, src_ptr) bind(c, name='all_encompassing_struct_set_type_0d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(all_encompassing_struct), pointer :: struct_obj
    type(test_sub_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%type_0d = src_obj
  end subroutine

  ! all_encompassing_struct%type_1d: 1D_NOT_type

  subroutine all_encompassing_struct_get_type_1d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_1d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%type_1d)) then
      data_ptr = c_loc(struct_obj%type_1d(lbound(struct_obj%type_1d, 1)))
      bounds(1) = int(lbound(struct_obj%type_1d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_1d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%type_1d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_2d: 2D_NOT_type

  subroutine all_encompassing_struct_get_type_2d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_2d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%type_2d)) then
      data_ptr = c_loc(struct_obj%type_2d(lbound(struct_obj%type_2d, 1), lbound(struct_obj%type_2d, 2)))
      bounds(1) = int(lbound(struct_obj%type_2d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_2d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%type_2d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%type_2d, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%type_2d(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_3d: 3D_NOT_type

  subroutine all_encompassing_struct_get_type_3d_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (.true. .and. is_contiguous(struct_obj%type_3d)) then
      data_ptr = c_loc(struct_obj%type_3d(lbound(struct_obj%type_3d, 1), lbound(struct_obj%type_3d, 2), lbound(struct_obj%type_3d, 3)))
      bounds(1) = int(lbound(struct_obj%type_3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_3d, 1), c_int)
      bounds(3) = int(lbound(struct_obj%type_3d, 2), c_int)
      bounds(4) = int(ubound(struct_obj%type_3d, 2), c_int)
      bounds(5) = int(lbound(struct_obj%type_3d, 3), c_int)
      bounds(6) = int(ubound(struct_obj%type_3d, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%type_3d(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_0d_ptr: 0D_PTR_type

  subroutine all_encompassing_struct_get_type_0d_ptr(struct_obj_ptr, ptr_out) bind(c, name='all_encompassing_struct_get_type_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(all_encompassing_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%type_0d_ptr)) then
      ptr_out = c_loc(struct_obj%type_0d_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine all_encompassing_struct_set_type_0d_ptr(struct_obj_ptr, src_ptr) bind(c, name='all_encompassing_struct_set_type_0d_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(all_encompassing_struct), pointer :: struct_obj
    type(test_sub_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%type_0d_ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%type_0d_ptr = src_obj
    endif
  end subroutine

  ! all_encompassing_struct%type_1d_ptr: 1D_PTR_type

  subroutine all_encompassing_struct_get_type_1d_ptr_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_1d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%type_1d_ptr) .and. is_contiguous(struct_obj%type_1d_ptr)) then
      data_ptr = c_loc(struct_obj%type_1d_ptr(lbound(struct_obj%type_1d_ptr, 1)))
      bounds(1) = int(lbound(struct_obj%type_1d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_1d_ptr, 1), c_int)
      
      el_size = int(storage_size(struct_obj%type_1d_ptr(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_2d_ptr: 2D_PTR_type

  subroutine all_encompassing_struct_get_type_2d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_2d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%type_2d_ptr) .and. is_contiguous(struct_obj%type_2d_ptr)) then
      data_ptr = c_loc(struct_obj%type_2d_ptr(lbound(struct_obj%type_2d_ptr, 1), lbound(struct_obj%type_2d_ptr, 2)))
      bounds(1) = int(lbound(struct_obj%type_2d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_2d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%type_2d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%type_2d_ptr, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%type_2d_ptr(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_3d_ptr: 3D_PTR_type

  subroutine all_encompassing_struct_get_type_3d_ptr_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_3d_ptr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (associated(struct_obj%type_3d_ptr) .and. is_contiguous(struct_obj%type_3d_ptr)) then
      data_ptr = c_loc(struct_obj%type_3d_ptr(lbound(struct_obj%type_3d_ptr, 1), lbound(struct_obj%type_3d_ptr, 2), lbound(struct_obj%type_3d_ptr, 3)))
      bounds(1) = int(lbound(struct_obj%type_3d_ptr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_3d_ptr, 1), c_int)
      bounds(3) = int(lbound(struct_obj%type_3d_ptr, 2), c_int)
      bounds(4) = int(ubound(struct_obj%type_3d_ptr, 2), c_int)
      bounds(5) = int(lbound(struct_obj%type_3d_ptr, 3), c_int)
      bounds(6) = int(ubound(struct_obj%type_3d_ptr, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%type_3d_ptr(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_1d_alloc: 1D_ALLOC_type

  subroutine all_encompassing_struct_get_type_1d_alloc_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_1d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%type_1d_alloc) .and. is_contiguous(struct_obj%type_1d_alloc)) then
      data_ptr = c_loc(struct_obj%type_1d_alloc(lbound(struct_obj%type_1d_alloc, 1)))
      bounds(1) = int(lbound(struct_obj%type_1d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_1d_alloc, 1), c_int)
      
      el_size = int(storage_size(struct_obj%type_1d_alloc(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_2d_alloc: 2D_ALLOC_type

  subroutine all_encompassing_struct_get_type_2d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_2d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%type_2d_alloc) .and. is_contiguous(struct_obj%type_2d_alloc)) then
      data_ptr = c_loc(struct_obj%type_2d_alloc(lbound(struct_obj%type_2d_alloc, 1), lbound(struct_obj%type_2d_alloc, 2)))
      bounds(1) = int(lbound(struct_obj%type_2d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_2d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%type_2d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%type_2d_alloc, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%type_2d_alloc(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! all_encompassing_struct%type_3d_alloc: 3D_ALLOC_type

  subroutine all_encompassing_struct_get_type_3d_alloc_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='all_encompassing_struct_get_type_3d_alloc_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(all_encompassing_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size

    call c_f_pointer(struct_obj_ptr, struct_obj)

    if (allocated(struct_obj%type_3d_alloc) .and. is_contiguous(struct_obj%type_3d_alloc)) then
      data_ptr = c_loc(struct_obj%type_3d_alloc(lbound(struct_obj%type_3d_alloc, 1), lbound(struct_obj%type_3d_alloc, 2), lbound(struct_obj%type_3d_alloc, 3)))
      bounds(1) = int(lbound(struct_obj%type_3d_alloc, 1), c_int)
      bounds(2) = int(ubound(struct_obj%type_3d_alloc, 1), c_int)
      bounds(3) = int(lbound(struct_obj%type_3d_alloc, 2), c_int)
      bounds(4) = int(ubound(struct_obj%type_3d_alloc, 2), c_int)
      bounds(5) = int(lbound(struct_obj%type_3d_alloc, 3), c_int)
      bounds(6) = int(ubound(struct_obj%type_3d_alloc, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%type_3d_alloc(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! test_sub_struct

    function allocate_fortran_test_sub_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(test_sub_struct), pointer :: fptr
      type(test_sub_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_test_sub_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(test_sub_struct), pointer :: fptr
      type(test_sub_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_test_sub_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(test_sub_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_test_sub_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(test_sub_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_test_sub_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(test_sub_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_test_sub_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(test_sub_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_test_sub_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(test_sub_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! test_sub_struct%sr: 0D_NOT_type

  subroutine test_sub_struct_get_sr(struct_obj_ptr, ptr_out) bind(c, name='test_sub_struct_get_sr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(test_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%sr)
  end subroutine


  subroutine test_sub_struct_set_sr(struct_obj_ptr, src_ptr) bind(c, name='test_sub_struct_set_sr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(test_sub_struct), pointer :: struct_obj
    type(test_sub_sub_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%sr = src_obj
  end subroutine

  !! test_sub_sub_struct

    function allocate_fortran_test_sub_sub_struct(n, element_size) result(ptr) bind(c)
      implicit none
      integer(c_int), value :: n
      integer(c_size_t), intent(out) :: element_size
      type(c_ptr) :: ptr
      type(test_sub_sub_struct), pointer :: fptr
      type(test_sub_sub_struct), pointer :: fptr_array(:)

      if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
      else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
      end if
    end function

    subroutine deallocate_fortran_test_sub_sub_struct(ptr, n) bind(c)
      implicit none
      type(c_ptr), value :: ptr
      integer(c_int), value :: n
      type(test_sub_sub_struct), pointer :: fptr
      type(test_sub_sub_struct), pointer :: fptr_array(:)

      if (c_associated(ptr)) then
        if (n <= 0) then
          call c_f_pointer(ptr, fptr)
          deallocate(fptr)
        else
          call c_f_pointer(ptr, fptr_array, [n])
          deallocate(fptr_array)
        end if
      end if
    end subroutine

  subroutine copy_fortran_test_sub_sub_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(test_sub_sub_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

  function allocate_test_sub_sub_struct_container() result(ptr) bind(c)
    implicit none
    type(c_ptr) :: ptr
    type(test_sub_sub_struct_container_alloc), pointer :: ctr
    allocate(ctr)
    ptr = c_loc(ctr)
  end function

  subroutine deallocate_test_sub_sub_struct_container(ptr) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    type(test_sub_sub_struct_container_alloc), pointer :: ctr
    if (c_associated(ptr)) then
      call c_f_pointer(ptr, ctr)
      deallocate(ctr)
    end if
  end subroutine

  subroutine reallocate_test_sub_sub_struct_container_data(container_ptr, lbound_, n) bind(c)
    implicit none
    type(c_ptr), value :: container_ptr
    integer(c_int), value :: lbound_
    integer(c_size_t), value :: n
    type(test_sub_sub_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) return
    call c_f_pointer(container_ptr, ctr)

    if (n == 0) then
      if (allocated(ctr%data)) deallocate(ctr%data)
    else
      if (allocated(ctr%data)) deallocate(ctr%data)
      allocate(ctr%data(lbound_:lbound_ + n - 1))
    end if
  end subroutine

  subroutine access_test_sub_sub_struct_container(container_ptr, d_ptr, js, sz, elem_size, is_allocated) bind(c)
    use iso_c_binding
    implicit none
    type(c_ptr), value :: container_ptr
    type(c_ptr), intent(out) :: d_ptr
    integer(c_int), intent(out) :: js         ! Start index (likely 0 or 1)
    integer(c_int), intent(out) :: sz
    integer(c_size_t), intent(out) :: elem_size
    logical(c_bool), intent(out) :: is_allocated

    type(test_sub_sub_struct_container_alloc), pointer :: ctr

    if (.not. c_associated(container_ptr)) then
       is_allocated = .false.
       return
    endif

    call c_f_pointer(container_ptr, ctr)

    if (allocated(ctr%data)) then
      is_allocated = .true.
      sz = size(ctr%data)
      js = lbound(ctr%data, 1)
      ! Use intrinsic storage_size (returns bits) divided by 8 for bytes
      elem_size = storage_size(ctr%data(js)) / 8
      d_ptr = c_loc(ctr%data(js))
    else
      is_allocated = .false.
      d_ptr = c_null_ptr
      js = 0
      sz = 0
      elem_size = 0
    endif
  end subroutine
    
  ! test_sub_sub_struct%aaa: 0D_NOT_integer8

  subroutine test_sub_sub_struct_get_aaa(struct_obj_ptr, value_out) bind(c, name='test_sub_sub_struct_get_aaa')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(out) :: value_out
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aaa
  end subroutine


  subroutine test_sub_sub_struct_set_aaa(struct_obj_ptr, value_in) bind(c, name='test_sub_sub_struct_set_aaa')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int64_t), intent(in), value :: value_in
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aaa = value_in
  end subroutine

  ! test_sub_sub_struct%bbb: 0D_NOT_integer

  subroutine test_sub_sub_struct_get_bbb(struct_obj_ptr, value_out) bind(c, name='test_sub_sub_struct_get_bbb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bbb
  end subroutine


  subroutine test_sub_sub_struct_set_bbb(struct_obj_ptr, value_in) bind(c, name='test_sub_sub_struct_set_bbb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bbb = value_in
  end subroutine

  ! test_sub_sub_struct%file: 0D_NOT_character

  subroutine test_sub_sub_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='test_sub_sub_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine test_sub_sub_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='test_sub_sub_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(test_sub_sub_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! test_sub_sub_struct%t_ref: 0D_NOT_real

  subroutine test_sub_sub_struct_get_t_ref(struct_obj_ptr, value_out) bind(c, name='test_sub_sub_struct_get_t_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_ref
  end subroutine


  subroutine test_sub_sub_struct_set_t_ref(struct_obj_ptr, value_in) bind(c, name='test_sub_sub_struct_set_t_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_ref = value_in
  end subroutine

  ! test_sub_sub_struct%freq_spread: 0D_NOT_real

  subroutine test_sub_sub_struct_get_freq_spread(struct_obj_ptr, value_out) bind(c, name='test_sub_sub_struct_get_freq_spread')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq_spread
  end subroutine


  subroutine test_sub_sub_struct_set_freq_spread(struct_obj_ptr, value_in) bind(c, name='test_sub_sub_struct_set_freq_spread')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(test_sub_sub_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq_spread = value_in
  end subroutine

end module
