module bmad_struct_proxy_mod
  use bmad_struct
  use tao_struct
  use, intrinsic :: iso_c_binding
contains

  !! spline_struct

    function allocate_fortran_spline_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(spline_struct), pointer :: fptr
    type(spline_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_spline_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(spline_struct), pointer :: fptr
    type(spline_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_spline_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spline_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! spline_struct%x0: 0D_NOT_real

  subroutine spline_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='spline_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine spline_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='spline_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! spline_struct%y0: 0D_NOT_real

  subroutine spline_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='spline_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine spline_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='spline_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! spline_struct%x1: 0D_NOT_real

  subroutine spline_struct_get_x1(struct_obj_ptr, value_out) bind(c, name='spline_struct_get_x1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x1
  end subroutine


  subroutine spline_struct_set_x1(struct_obj_ptr, value_in) bind(c, name='spline_struct_set_x1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spline_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x1 = value_in
  end subroutine

  ! spline_struct%coef: 1D_NOT_real

  subroutine spline_struct_get_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spline_struct_get_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spline_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%coef)) then
      data_ptr = c_loc(struct_obj%coef(lbound(struct_obj%coef, 1)))
      bounds(1) = int(lbound(struct_obj%coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! spin_polar_struct

    function allocate_fortran_spin_polar_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(spin_polar_struct), pointer :: fptr
    type(spin_polar_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_spin_polar_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(spin_polar_struct), pointer :: fptr
    type(spin_polar_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_spin_polar_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spin_polar_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! spin_polar_struct%polarization: 0D_NOT_real

  subroutine spin_polar_struct_get_polarization(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%polarization
  end subroutine


  subroutine spin_polar_struct_set_polarization(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%polarization = value_in
  end subroutine

  ! spin_polar_struct%theta: 0D_NOT_real

  subroutine spin_polar_struct_get_theta(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta
  end subroutine


  subroutine spin_polar_struct_set_theta(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta = value_in
  end subroutine

  ! spin_polar_struct%phi: 0D_NOT_real

  subroutine spin_polar_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine spin_polar_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! spin_polar_struct%xi: 0D_NOT_real

  subroutine spin_polar_struct_get_xi(struct_obj_ptr, value_out) bind(c, name='spin_polar_struct_get_xi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%xi
  end subroutine


  subroutine spin_polar_struct_set_xi(struct_obj_ptr, value_in) bind(c, name='spin_polar_struct_set_xi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(spin_polar_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%xi = value_in
  end subroutine

  !! ac_kicker_time_struct

    function allocate_fortran_ac_kicker_time_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ac_kicker_time_struct), pointer :: fptr
    type(ac_kicker_time_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ac_kicker_time_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ac_kicker_time_struct), pointer :: fptr
    type(ac_kicker_time_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ac_kicker_time_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ac_kicker_time_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ac_kicker_time_struct%amp: 0D_NOT_real

  subroutine ac_kicker_time_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='ac_kicker_time_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine ac_kicker_time_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='ac_kicker_time_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! ac_kicker_time_struct%time: 0D_NOT_real

  subroutine ac_kicker_time_struct_get_time(struct_obj_ptr, value_out) bind(c, name='ac_kicker_time_struct_get_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time
  end subroutine


  subroutine ac_kicker_time_struct_set_time(struct_obj_ptr, value_in) bind(c, name='ac_kicker_time_struct_set_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time = value_in
  end subroutine

  ! ac_kicker_time_struct%spline: 0D_NOT_type

  subroutine ac_kicker_time_struct_get_spline(struct_obj_ptr, ptr_out) bind(c, name='ac_kicker_time_struct_get_spline')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ac_kicker_time_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spline)
  end subroutine


  subroutine ac_kicker_time_struct_set_spline(struct_obj_ptr, src_ptr) bind(c, name='ac_kicker_time_struct_set_spline')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ac_kicker_time_struct), pointer :: struct_obj
    type(spline_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spline = src_obj
  end subroutine

  !! ac_kicker_freq_struct

    function allocate_fortran_ac_kicker_freq_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ac_kicker_freq_struct), pointer :: fptr
    type(ac_kicker_freq_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ac_kicker_freq_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ac_kicker_freq_struct), pointer :: fptr
    type(ac_kicker_freq_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ac_kicker_freq_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ac_kicker_freq_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ac_kicker_freq_struct%f: 0D_NOT_real

  subroutine ac_kicker_freq_struct_get_f(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_f')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f
  end subroutine


  subroutine ac_kicker_freq_struct_set_f(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_f')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f = value_in
  end subroutine

  ! ac_kicker_freq_struct%amp: 0D_NOT_real

  subroutine ac_kicker_freq_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine ac_kicker_freq_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! ac_kicker_freq_struct%phi: 0D_NOT_real

  subroutine ac_kicker_freq_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine ac_kicker_freq_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! ac_kicker_freq_struct%rf_clock_harmonic: 0D_NOT_integer

  subroutine ac_kicker_freq_struct_get_rf_clock_harmonic(struct_obj_ptr, value_out) bind(c, name='ac_kicker_freq_struct_get_rf_clock_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_clock_harmonic
  end subroutine


  subroutine ac_kicker_freq_struct_set_rf_clock_harmonic(struct_obj_ptr, value_in) bind(c, name='ac_kicker_freq_struct_set_rf_clock_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ac_kicker_freq_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_clock_harmonic = value_in
  end subroutine

  !! ac_kicker_struct

    function allocate_fortran_ac_kicker_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ac_kicker_struct), pointer :: fptr
    type(ac_kicker_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ac_kicker_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ac_kicker_struct), pointer :: fptr
    type(ac_kicker_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ac_kicker_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ac_kicker_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ac_kicker_struct%amp_vs_time: 1D_ALLOC_type

  subroutine ac_kicker_struct_get_amp_vs_time_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ac_kicker_struct_get_amp_vs_time_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ac_kicker_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%amp_vs_time) .and. is_contiguous(struct_obj%amp_vs_time)) then
      data_ptr = c_loc(struct_obj%amp_vs_time(lbound(struct_obj%amp_vs_time, 1)))
      bounds(1) = int(lbound(struct_obj%amp_vs_time, 1), c_int)
      bounds(2) = int(ubound(struct_obj%amp_vs_time, 1), c_int)
      
      el_size = int(storage_size(struct_obj%amp_vs_time(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ac_kicker_struct%frequency: 1D_ALLOC_type

  subroutine ac_kicker_struct_get_frequency_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ac_kicker_struct_get_frequency_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ac_kicker_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%frequency) .and. is_contiguous(struct_obj%frequency)) then
      data_ptr = c_loc(struct_obj%frequency(lbound(struct_obj%frequency, 1)))
      bounds(1) = int(lbound(struct_obj%frequency, 1), c_int)
      bounds(2) = int(ubound(struct_obj%frequency, 1), c_int)
      
      el_size = int(storage_size(struct_obj%frequency(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! interval1_coef_struct

    function allocate_fortran_interval1_coef_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(interval1_coef_struct), pointer :: fptr
    type(interval1_coef_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_interval1_coef_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(interval1_coef_struct), pointer :: fptr
    type(interval1_coef_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_interval1_coef_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(interval1_coef_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! interval1_coef_struct%c0: 0D_NOT_real

  subroutine interval1_coef_struct_get_c0(struct_obj_ptr, value_out) bind(c, name='interval1_coef_struct_get_c0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%c0
  end subroutine


  subroutine interval1_coef_struct_set_c0(struct_obj_ptr, value_in) bind(c, name='interval1_coef_struct_set_c0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%c0 = value_in
  end subroutine

  ! interval1_coef_struct%c1: 0D_NOT_real

  subroutine interval1_coef_struct_get_c1(struct_obj_ptr, value_out) bind(c, name='interval1_coef_struct_get_c1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%c1
  end subroutine


  subroutine interval1_coef_struct_set_c1(struct_obj_ptr, value_in) bind(c, name='interval1_coef_struct_set_c1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%c1 = value_in
  end subroutine

  ! interval1_coef_struct%n_exp: 0D_NOT_real

  subroutine interval1_coef_struct_get_n_exp(struct_obj_ptr, value_out) bind(c, name='interval1_coef_struct_get_n_exp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_exp
  end subroutine


  subroutine interval1_coef_struct_set_n_exp(struct_obj_ptr, value_in) bind(c, name='interval1_coef_struct_set_n_exp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(interval1_coef_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_exp = value_in
  end subroutine

  !! photon_reflect_table_struct

    function allocate_fortran_photon_reflect_table_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(photon_reflect_table_struct), pointer :: fptr
    type(photon_reflect_table_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_photon_reflect_table_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(photon_reflect_table_struct), pointer :: fptr
    type(photon_reflect_table_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_photon_reflect_table_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_reflect_table_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! photon_reflect_table_struct%angle: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_angle_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_angle_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%angle) .and. is_contiguous(struct_obj%angle)) then
      data_ptr = c_loc(struct_obj%angle(lbound(struct_obj%angle, 1)))
      bounds(1) = int(lbound(struct_obj%angle, 1), c_int)
      bounds(2) = int(ubound(struct_obj%angle, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%energy: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_energy_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_energy_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%energy) .and. is_contiguous(struct_obj%energy)) then
      data_ptr = c_loc(struct_obj%energy(lbound(struct_obj%energy, 1)))
      bounds(1) = int(lbound(struct_obj%energy, 1), c_int)
      bounds(2) = int(ubound(struct_obj%energy, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%int1: 1D_ALLOC_type

  subroutine photon_reflect_table_struct_get_int1_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_reflect_table_struct_get_int1_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%int1) .and. is_contiguous(struct_obj%int1)) then
      data_ptr = c_loc(struct_obj%int1(lbound(struct_obj%int1, 1)))
      bounds(1) = int(lbound(struct_obj%int1, 1), c_int)
      bounds(2) = int(ubound(struct_obj%int1, 1), c_int)
      
      el_size = int(storage_size(struct_obj%int1(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%p_reflect: 2D_ALLOC_real

  subroutine photon_reflect_table_struct_get_p_reflect_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_p_reflect_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%p_reflect) .and. is_contiguous(struct_obj%p_reflect)) then
      data_ptr = c_loc(struct_obj%p_reflect(lbound(struct_obj%p_reflect, 1), lbound(struct_obj%p_reflect, 2)))
      bounds(1) = int(lbound(struct_obj%p_reflect, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p_reflect, 1), c_int)
      bounds(3) = int(lbound(struct_obj%p_reflect, 2), c_int)
      bounds(4) = int(ubound(struct_obj%p_reflect, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%max_energy: 0D_NOT_real

  subroutine photon_reflect_table_struct_get_max_energy(struct_obj_ptr, value_out) bind(c, name='photon_reflect_table_struct_get_max_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(photon_reflect_table_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_energy
  end subroutine


  subroutine photon_reflect_table_struct_set_max_energy(struct_obj_ptr, value_in) bind(c, name='photon_reflect_table_struct_set_max_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(photon_reflect_table_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_energy = value_in
  end subroutine

  ! photon_reflect_table_struct%p_reflect_scratch: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_p_reflect_scratch_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_p_reflect_scratch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%p_reflect_scratch) .and. is_contiguous(struct_obj%p_reflect_scratch)) then
      data_ptr = c_loc(struct_obj%p_reflect_scratch(lbound(struct_obj%p_reflect_scratch, 1)))
      bounds(1) = int(lbound(struct_obj%p_reflect_scratch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p_reflect_scratch, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_table_struct%bragg_angle: 1D_ALLOC_real

  subroutine photon_reflect_table_struct_get_bragg_angle_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_reflect_table_struct_get_bragg_angle_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_table_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%bragg_angle) .and. is_contiguous(struct_obj%bragg_angle)) then
      data_ptr = c_loc(struct_obj%bragg_angle(lbound(struct_obj%bragg_angle, 1)))
      bounds(1) = int(lbound(struct_obj%bragg_angle, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bragg_angle, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! photon_reflect_surface_struct

    function allocate_fortran_photon_reflect_surface_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(photon_reflect_surface_struct), pointer :: fptr
    type(photon_reflect_surface_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_photon_reflect_surface_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(photon_reflect_surface_struct), pointer :: fptr
    type(photon_reflect_surface_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_photon_reflect_surface_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_reflect_surface_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! photon_reflect_surface_struct%name: 0D_NOT_character

  subroutine photon_reflect_surface_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='photon_reflect_surface_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine photon_reflect_surface_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='photon_reflect_surface_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(photon_reflect_surface_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! photon_reflect_surface_struct%description: 0D_NOT_character

  subroutine photon_reflect_surface_struct_get_description_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='photon_reflect_surface_struct_get_description_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%description)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%description), c_int)
    is_allocated = .true.
  end subroutine


  subroutine photon_reflect_surface_struct_set_description(struct_obj_ptr, str_ptr, str_len) bind(c, name='photon_reflect_surface_struct_set_description')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(photon_reflect_surface_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%description = str_in ! implicitly handles padding
  end subroutine

  ! photon_reflect_surface_struct%reflectivity_file: 0D_NOT_character

  subroutine photon_reflect_surface_struct_get_reflectivity_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='photon_reflect_surface_struct_get_reflectivity_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%reflectivity_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%reflectivity_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine photon_reflect_surface_struct_set_reflectivity_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='photon_reflect_surface_struct_set_reflectivity_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(photon_reflect_surface_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%reflectivity_file = str_in ! implicitly handles padding
  end subroutine

  ! photon_reflect_surface_struct%table: 1D_ALLOC_type

  subroutine photon_reflect_surface_struct_get_table_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_reflect_surface_struct_get_table_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_reflect_surface_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%table) .and. is_contiguous(struct_obj%table)) then
      data_ptr = c_loc(struct_obj%table(lbound(struct_obj%table, 1)))
      bounds(1) = int(lbound(struct_obj%table, 1), c_int)
      bounds(2) = int(ubound(struct_obj%table, 1), c_int)
      
      el_size = int(storage_size(struct_obj%table(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_reflect_surface_struct%surface_roughness_rms: 0D_NOT_real

  subroutine photon_reflect_surface_struct_get_surface_roughness_rms(struct_obj_ptr, value_out) bind(c, name='photon_reflect_surface_struct_get_surface_roughness_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%surface_roughness_rms
  end subroutine


  subroutine photon_reflect_surface_struct_set_surface_roughness_rms(struct_obj_ptr, value_in) bind(c, name='photon_reflect_surface_struct_set_surface_roughness_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%surface_roughness_rms = value_in
  end subroutine

  ! photon_reflect_surface_struct%roughness_correlation_len: 0D_NOT_real

  subroutine photon_reflect_surface_struct_get_roughness_correlation_len(struct_obj_ptr, value_out) bind(c, name='photon_reflect_surface_struct_get_roughness_correlation_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%roughness_correlation_len
  end subroutine


  subroutine photon_reflect_surface_struct_set_roughness_correlation_len(struct_obj_ptr, value_in) bind(c, name='photon_reflect_surface_struct_set_roughness_correlation_len')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%roughness_correlation_len = value_in
  end subroutine

  ! photon_reflect_surface_struct%ix_surface: 0D_NOT_integer

  subroutine photon_reflect_surface_struct_get_ix_surface(struct_obj_ptr, value_out) bind(c, name='photon_reflect_surface_struct_get_ix_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_surface
  end subroutine


  subroutine photon_reflect_surface_struct_set_ix_surface(struct_obj_ptr, value_in) bind(c, name='photon_reflect_surface_struct_set_ix_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_reflect_surface_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_surface = value_in
  end subroutine

  !! coord_struct

    function allocate_fortran_coord_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(coord_struct), pointer :: fptr
    type(coord_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_coord_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(coord_struct), pointer :: fptr
    type(coord_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_coord_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(coord_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! coord_struct%vec: 1D_NOT_real

  subroutine coord_struct_get_vec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%vec)) then
      data_ptr = c_loc(struct_obj%vec(lbound(struct_obj%vec, 1)))
      bounds(1) = int(lbound(struct_obj%vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%s: 0D_NOT_real

  subroutine coord_struct_get_s(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine coord_struct_set_s(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! coord_struct%t: 0D_NOT_real16

  subroutine coord_struct_get_t(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_long_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t
  end subroutine


  subroutine coord_struct_set_t(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_long_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t = value_in
  end subroutine

  ! coord_struct%spin: 1D_NOT_real

  subroutine coord_struct_get_spin_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_spin_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin)) then
      data_ptr = c_loc(struct_obj%spin(lbound(struct_obj%spin, 1)))
      bounds(1) = int(lbound(struct_obj%spin, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%field: 1D_NOT_real

  subroutine coord_struct_get_field_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_field_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%field)) then
      data_ptr = c_loc(struct_obj%field(lbound(struct_obj%field, 1)))
      bounds(1) = int(lbound(struct_obj%field, 1), c_int)
      bounds(2) = int(ubound(struct_obj%field, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%phase: 1D_NOT_real

  subroutine coord_struct_get_phase_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='coord_struct_get_phase_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%phase)) then
      data_ptr = c_loc(struct_obj%phase(lbound(struct_obj%phase, 1)))
      bounds(1) = int(lbound(struct_obj%phase, 1), c_int)
      bounds(2) = int(ubound(struct_obj%phase, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! coord_struct%charge: 0D_NOT_real

  subroutine coord_struct_get_charge(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge
  end subroutine


  subroutine coord_struct_set_charge(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge = value_in
  end subroutine

  ! coord_struct%dt_ref: 0D_NOT_real

  subroutine coord_struct_get_dt_ref(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_dt_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dt_ref
  end subroutine


  subroutine coord_struct_set_dt_ref(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_dt_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dt_ref = value_in
  end subroutine

  ! coord_struct%r: 0D_NOT_real

  subroutine coord_struct_get_r(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%r
  end subroutine


  subroutine coord_struct_set_r(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_r')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%r = value_in
  end subroutine

  ! coord_struct%p0c: 0D_NOT_real

  subroutine coord_struct_get_p0c(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p0c
  end subroutine


  subroutine coord_struct_set_p0c(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p0c = value_in
  end subroutine

  ! coord_struct%E_potential: 0D_NOT_real

  subroutine coord_struct_get_E_potential(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_E_potential')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_potential
  end subroutine


  subroutine coord_struct_set_E_potential(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_E_potential')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_potential = value_in
  end subroutine

  ! coord_struct%beta: 0D_NOT_real

  subroutine coord_struct_get_beta(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beta
  end subroutine


  subroutine coord_struct_set_beta(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beta = value_in
  end subroutine

  ! coord_struct%ix_ele: 0D_NOT_integer

  subroutine coord_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine coord_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! coord_struct%ix_branch: 0D_NOT_integer

  subroutine coord_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine coord_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! coord_struct%ix_turn: 0D_NOT_integer

  subroutine coord_struct_get_ix_turn(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_turn
  end subroutine


  subroutine coord_struct_set_ix_turn(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_turn = value_in
  end subroutine

  ! coord_struct%ix_user: 0D_NOT_integer

  subroutine coord_struct_get_ix_user(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_ix_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_user
  end subroutine


  subroutine coord_struct_set_ix_user(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_ix_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_user = value_in
  end subroutine

  ! coord_struct%state: 0D_NOT_integer

  subroutine coord_struct_get_state(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%state
  end subroutine


  subroutine coord_struct_set_state(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%state = value_in
  end subroutine

  ! coord_struct%direction: 0D_NOT_integer

  subroutine coord_struct_get_direction(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_direction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%direction
  end subroutine


  subroutine coord_struct_set_direction(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_direction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%direction = value_in
  end subroutine

  ! coord_struct%time_dir: 0D_NOT_integer

  subroutine coord_struct_get_time_dir(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_time_dir')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_dir
  end subroutine


  subroutine coord_struct_set_time_dir(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_time_dir')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_dir = value_in
  end subroutine

  ! coord_struct%species: 0D_NOT_integer

  subroutine coord_struct_get_species(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%species
  end subroutine


  subroutine coord_struct_set_species(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%species = value_in
  end subroutine

  ! coord_struct%location: 0D_NOT_integer

  subroutine coord_struct_get_location(struct_obj_ptr, value_out) bind(c, name='coord_struct_get_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%location
  end subroutine


  subroutine coord_struct_set_location(struct_obj_ptr, value_in) bind(c, name='coord_struct_set_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(coord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%location = value_in
  end subroutine

  !! coord_array_struct

    function allocate_fortran_coord_array_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(coord_array_struct), pointer :: fptr
    type(coord_array_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_coord_array_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(coord_array_struct), pointer :: fptr
    type(coord_array_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_coord_array_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(coord_array_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! coord_array_struct%orbit: 1D_ALLOC_type

  subroutine coord_array_struct_get_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='coord_array_struct_get_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(coord_array_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%orbit) .and. is_contiguous(struct_obj%orbit)) then
      data_ptr = c_loc(struct_obj%orbit(lbound(struct_obj%orbit, 1)))
      bounds(1) = int(lbound(struct_obj%orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit, 1), c_int)
      
      el_size = int(storage_size(struct_obj%orbit(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! bpm_phase_coupling_struct

    function allocate_fortran_bpm_phase_coupling_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bpm_phase_coupling_struct), pointer :: fptr
    type(bpm_phase_coupling_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bpm_phase_coupling_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bpm_phase_coupling_struct), pointer :: fptr
    type(bpm_phase_coupling_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bpm_phase_coupling_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bpm_phase_coupling_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bpm_phase_coupling_struct%K_22a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_22a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_22a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_22a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_22a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_22a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_22a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%K_12a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_12a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_12a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_12a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_12a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_12a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_12a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%K_11b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_11b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_11b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_11b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_11b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_11b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_11b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%K_12b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_K_12b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_K_12b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%K_12b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_K_12b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_K_12b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%K_12b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar22_a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar22_a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar22_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar22_a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar22_a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar22_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar22_a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar12_a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar12_a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar12_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar12_a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar12_a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar12_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar12_a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar11_b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar11_b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar11_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar11_b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar11_b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar11_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar11_b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%Cbar12_b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_Cbar12_b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_Cbar12_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Cbar12_b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_Cbar12_b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_Cbar12_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Cbar12_b = value_in
  end subroutine

  ! bpm_phase_coupling_struct%phi_a: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_phi_a(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_phi_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_a
  end subroutine


  subroutine bpm_phase_coupling_struct_set_phi_a(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_phi_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_a = value_in
  end subroutine

  ! bpm_phase_coupling_struct%phi_b: 0D_NOT_real

  subroutine bpm_phase_coupling_struct_get_phi_b(struct_obj_ptr, value_out) bind(c, name='bpm_phase_coupling_struct_get_phi_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_b
  end subroutine


  subroutine bpm_phase_coupling_struct_set_phi_b(struct_obj_ptr, value_in) bind(c, name='bpm_phase_coupling_struct_set_phi_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bpm_phase_coupling_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_b = value_in
  end subroutine

  !! expression_atom_struct

    function allocate_fortran_expression_atom_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(expression_atom_struct), pointer :: fptr
    type(expression_atom_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_expression_atom_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(expression_atom_struct), pointer :: fptr
    type(expression_atom_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_expression_atom_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(expression_atom_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! expression_atom_struct%name: 0D_NOT_character

  subroutine expression_atom_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='expression_atom_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine expression_atom_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='expression_atom_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(expression_atom_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! expression_atom_struct%type: 0D_NOT_integer

  subroutine expression_atom_struct_get_type(struct_obj_ptr, value_out) bind(c, name='expression_atom_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine expression_atom_struct_set_type(struct_obj_ptr, value_in) bind(c, name='expression_atom_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! expression_atom_struct%value: 0D_NOT_real

  subroutine expression_atom_struct_get_value(struct_obj_ptr, value_out) bind(c, name='expression_atom_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine expression_atom_struct_set_value(struct_obj_ptr, value_in) bind(c, name='expression_atom_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(expression_atom_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  !! wake_sr_z_long_struct

    function allocate_fortran_wake_sr_z_long_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wake_sr_z_long_struct), pointer :: fptr
    type(wake_sr_z_long_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wake_sr_z_long_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wake_sr_z_long_struct), pointer :: fptr
    type(wake_sr_z_long_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wake_sr_z_long_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_sr_z_long_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wake_sr_z_long_struct%w: 1D_ALLOC_real

  subroutine wake_sr_z_long_struct_get_w_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_w_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%w) .and. is_contiguous(struct_obj%w)) then
      data_ptr = c_loc(struct_obj%w(lbound(struct_obj%w, 1)))
      bounds(1) = int(lbound(struct_obj%w, 1), c_int)
      bounds(2) = int(ubound(struct_obj%w, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%fw: 1D_ALLOC_complex

  subroutine wake_sr_z_long_struct_get_fw_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_fw_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%fw) .and. is_contiguous(struct_obj%fw)) then
      data_ptr = c_loc(struct_obj%fw(lbound(struct_obj%fw, 1)))
      bounds(1) = int(lbound(struct_obj%fw, 1), c_int)
      bounds(2) = int(ubound(struct_obj%fw, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%fbunch: 1D_ALLOC_complex

  subroutine wake_sr_z_long_struct_get_fbunch_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_fbunch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%fbunch) .and. is_contiguous(struct_obj%fbunch)) then
      data_ptr = c_loc(struct_obj%fbunch(lbound(struct_obj%fbunch, 1)))
      bounds(1) = int(lbound(struct_obj%fbunch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%fbunch, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%w_out: 1D_ALLOC_complex

  subroutine wake_sr_z_long_struct_get_w_out_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wake_sr_z_long_struct_get_w_out_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_z_long_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%w_out) .and. is_contiguous(struct_obj%w_out)) then
      data_ptr = c_loc(struct_obj%w_out(lbound(struct_obj%w_out, 1)))
      bounds(1) = int(lbound(struct_obj%w_out, 1), c_int)
      bounds(2) = int(ubound(struct_obj%w_out, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_z_long_struct%dz: 0D_NOT_real

  subroutine wake_sr_z_long_struct_get_dz(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz
  end subroutine


  subroutine wake_sr_z_long_struct_set_dz(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz = value_in
  end subroutine

  ! wake_sr_z_long_struct%z0: 0D_NOT_real

  subroutine wake_sr_z_long_struct_get_z0(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z0
  end subroutine


  subroutine wake_sr_z_long_struct_set_z0(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z0 = value_in
  end subroutine

  ! wake_sr_z_long_struct%smoothing_sigma: 0D_NOT_real

  subroutine wake_sr_z_long_struct_get_smoothing_sigma(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_smoothing_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%smoothing_sigma
  end subroutine


  subroutine wake_sr_z_long_struct_set_smoothing_sigma(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_smoothing_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%smoothing_sigma = value_in
  end subroutine

  ! wake_sr_z_long_struct%position_dependence: 0D_NOT_integer

  subroutine wake_sr_z_long_struct_get_position_dependence(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%position_dependence
  end subroutine


  subroutine wake_sr_z_long_struct_set_position_dependence(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%position_dependence = value_in
  end subroutine

  ! wake_sr_z_long_struct%time_based: 0D_NOT_logical

  subroutine wake_sr_z_long_struct_get_time_based(struct_obj_ptr, value_out) bind(c, name='wake_sr_z_long_struct_get_time_based')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_based
  end subroutine


  subroutine wake_sr_z_long_struct_set_time_based(struct_obj_ptr, value_in) bind(c, name='wake_sr_z_long_struct_set_time_based')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_sr_z_long_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_based = value_in
  end subroutine

  !! wake_sr_mode_struct

    function allocate_fortran_wake_sr_mode_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wake_sr_mode_struct), pointer :: fptr
    type(wake_sr_mode_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wake_sr_mode_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wake_sr_mode_struct), pointer :: fptr
    type(wake_sr_mode_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wake_sr_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_sr_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wake_sr_mode_struct%amp: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_amp(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp
  end subroutine


  subroutine wake_sr_mode_struct_set_amp(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp = value_in
  end subroutine

  ! wake_sr_mode_struct%damp: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_damp(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%damp
  end subroutine


  subroutine wake_sr_mode_struct_set_damp(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%damp = value_in
  end subroutine

  ! wake_sr_mode_struct%k: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_k(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_k')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%k
  end subroutine


  subroutine wake_sr_mode_struct_set_k(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_k')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%k = value_in
  end subroutine

  ! wake_sr_mode_struct%phi: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine wake_sr_mode_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! wake_sr_mode_struct%b_sin: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_b_sin(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_sin
  end subroutine


  subroutine wake_sr_mode_struct_set_b_sin(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_sin = value_in
  end subroutine

  ! wake_sr_mode_struct%b_cos: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_b_cos(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_cos
  end subroutine


  subroutine wake_sr_mode_struct_set_b_cos(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_cos = value_in
  end subroutine

  ! wake_sr_mode_struct%a_sin: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_a_sin(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_sin
  end subroutine


  subroutine wake_sr_mode_struct_set_a_sin(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_sin = value_in
  end subroutine

  ! wake_sr_mode_struct%a_cos: 0D_NOT_real

  subroutine wake_sr_mode_struct_get_a_cos(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_cos
  end subroutine


  subroutine wake_sr_mode_struct_set_a_cos(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_cos = value_in
  end subroutine

  ! wake_sr_mode_struct%polarization: 0D_NOT_integer

  subroutine wake_sr_mode_struct_get_polarization(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%polarization
  end subroutine


  subroutine wake_sr_mode_struct_set_polarization(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_polarization')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%polarization = value_in
  end subroutine

  ! wake_sr_mode_struct%position_dependence: 0D_NOT_integer

  subroutine wake_sr_mode_struct_get_position_dependence(struct_obj_ptr, value_out) bind(c, name='wake_sr_mode_struct_get_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%position_dependence
  end subroutine


  subroutine wake_sr_mode_struct_set_position_dependence(struct_obj_ptr, value_in) bind(c, name='wake_sr_mode_struct_set_position_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_sr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%position_dependence = value_in
  end subroutine

  !! wake_sr_struct

    function allocate_fortran_wake_sr_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wake_sr_struct), pointer :: fptr
    type(wake_sr_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wake_sr_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wake_sr_struct), pointer :: fptr
    type(wake_sr_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wake_sr_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_sr_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wake_sr_struct%file: 0D_NOT_character

  subroutine wake_sr_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wake_sr_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wake_sr_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='wake_sr_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wake_sr_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! wake_sr_struct%z_long: 0D_NOT_type

  subroutine wake_sr_struct_get_z_long(struct_obj_ptr, ptr_out) bind(c, name='wake_sr_struct_get_z_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z_long)
  end subroutine


  subroutine wake_sr_struct_set_z_long(struct_obj_ptr, src_ptr) bind(c, name='wake_sr_struct_set_z_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wake_sr_struct), pointer :: struct_obj
    type(wake_sr_z_long_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z_long = src_obj
  end subroutine

  ! wake_sr_struct%long: 1D_ALLOC_type

  subroutine wake_sr_struct_get_long_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wake_sr_struct_get_long_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%long) .and. is_contiguous(struct_obj%long)) then
      data_ptr = c_loc(struct_obj%long(lbound(struct_obj%long, 1)))
      bounds(1) = int(lbound(struct_obj%long, 1), c_int)
      bounds(2) = int(ubound(struct_obj%long, 1), c_int)
      
      el_size = int(storage_size(struct_obj%long(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_struct%trans: 1D_ALLOC_type

  subroutine wake_sr_struct_get_trans_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wake_sr_struct_get_trans_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_sr_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%trans) .and. is_contiguous(struct_obj%trans)) then
      data_ptr = c_loc(struct_obj%trans(lbound(struct_obj%trans, 1)))
      bounds(1) = int(lbound(struct_obj%trans, 1), c_int)
      bounds(2) = int(ubound(struct_obj%trans, 1), c_int)
      
      el_size = int(storage_size(struct_obj%trans(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wake_sr_struct%z_ref_long: 0D_NOT_real

  subroutine wake_sr_struct_get_z_ref_long(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_ref_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_ref_long
  end subroutine


  subroutine wake_sr_struct_set_z_ref_long(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_ref_long')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_ref_long = value_in
  end subroutine

  ! wake_sr_struct%z_ref_trans: 0D_NOT_real

  subroutine wake_sr_struct_get_z_ref_trans(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_ref_trans')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_ref_trans
  end subroutine


  subroutine wake_sr_struct_set_z_ref_trans(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_ref_trans')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_ref_trans = value_in
  end subroutine

  ! wake_sr_struct%z_max: 0D_NOT_real

  subroutine wake_sr_struct_get_z_max(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_max
  end subroutine


  subroutine wake_sr_struct_set_z_max(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_max = value_in
  end subroutine

  ! wake_sr_struct%amp_scale: 0D_NOT_real

  subroutine wake_sr_struct_get_amp_scale(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp_scale
  end subroutine


  subroutine wake_sr_struct_set_amp_scale(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp_scale = value_in
  end subroutine

  ! wake_sr_struct%z_scale: 0D_NOT_real

  subroutine wake_sr_struct_get_z_scale(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_z_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_scale
  end subroutine


  subroutine wake_sr_struct_set_z_scale(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_z_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_scale = value_in
  end subroutine

  ! wake_sr_struct%scale_with_length: 0D_NOT_logical

  subroutine wake_sr_struct_get_scale_with_length(struct_obj_ptr, value_out) bind(c, name='wake_sr_struct_get_scale_with_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scale_with_length
  end subroutine


  subroutine wake_sr_struct_set_scale_with_length(struct_obj_ptr, value_in) bind(c, name='wake_sr_struct_set_scale_with_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_sr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scale_with_length = value_in
  end subroutine

  !! wake_lr_mode_struct

    function allocate_fortran_wake_lr_mode_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wake_lr_mode_struct), pointer :: fptr
    type(wake_lr_mode_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wake_lr_mode_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wake_lr_mode_struct), pointer :: fptr
    type(wake_lr_mode_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wake_lr_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_lr_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wake_lr_mode_struct%freq: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_freq(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_freq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq
  end subroutine


  subroutine wake_lr_mode_struct_set_freq(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_freq')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq = value_in
  end subroutine

  ! wake_lr_mode_struct%freq_in: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_freq_in(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_freq_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq_in
  end subroutine


  subroutine wake_lr_mode_struct_set_freq_in(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_freq_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq_in = value_in
  end subroutine

  ! wake_lr_mode_struct%R_over_Q: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_R_over_Q(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_R_over_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%R_over_Q
  end subroutine


  subroutine wake_lr_mode_struct_set_R_over_Q(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_R_over_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%R_over_Q = value_in
  end subroutine

  ! wake_lr_mode_struct%Q: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_Q(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%Q
  end subroutine


  subroutine wake_lr_mode_struct_set_Q(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_Q')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%Q = value_in
  end subroutine

  ! wake_lr_mode_struct%damp: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_damp(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%damp
  end subroutine


  subroutine wake_lr_mode_struct_set_damp(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%damp = value_in
  end subroutine

  ! wake_lr_mode_struct%phi: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine wake_lr_mode_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! wake_lr_mode_struct%angle: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_angle(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%angle
  end subroutine


  subroutine wake_lr_mode_struct_set_angle(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%angle = value_in
  end subroutine

  ! wake_lr_mode_struct%b_sin: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_b_sin(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_sin
  end subroutine


  subroutine wake_lr_mode_struct_set_b_sin(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_b_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_sin = value_in
  end subroutine

  ! wake_lr_mode_struct%b_cos: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_b_cos(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_cos
  end subroutine


  subroutine wake_lr_mode_struct_set_b_cos(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_b_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_cos = value_in
  end subroutine

  ! wake_lr_mode_struct%a_sin: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_a_sin(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_sin
  end subroutine


  subroutine wake_lr_mode_struct_set_a_sin(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_a_sin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_sin = value_in
  end subroutine

  ! wake_lr_mode_struct%a_cos: 0D_NOT_real

  subroutine wake_lr_mode_struct_get_a_cos(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_cos
  end subroutine


  subroutine wake_lr_mode_struct_set_a_cos(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_a_cos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_cos = value_in
  end subroutine

  ! wake_lr_mode_struct%m: 0D_NOT_integer

  subroutine wake_lr_mode_struct_get_m(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%m
  end subroutine


  subroutine wake_lr_mode_struct_set_m(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%m = value_in
  end subroutine

  ! wake_lr_mode_struct%polarized: 0D_NOT_logical

  subroutine wake_lr_mode_struct_get_polarized(struct_obj_ptr, value_out) bind(c, name='wake_lr_mode_struct_get_polarized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%polarized
  end subroutine


  subroutine wake_lr_mode_struct_set_polarized(struct_obj_ptr, value_in) bind(c, name='wake_lr_mode_struct_set_polarized')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_lr_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%polarized = value_in
  end subroutine

  !! wake_lr_struct

    function allocate_fortran_wake_lr_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wake_lr_struct), pointer :: fptr
    type(wake_lr_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wake_lr_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wake_lr_struct), pointer :: fptr
    type(wake_lr_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wake_lr_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_lr_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wake_lr_struct%file: 0D_NOT_character

  subroutine wake_lr_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wake_lr_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wake_lr_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='wake_lr_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wake_lr_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! wake_lr_struct%mode: 1D_ALLOC_type

  subroutine wake_lr_struct_get_mode_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wake_lr_struct_get_mode_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wake_lr_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%mode) .and. is_contiguous(struct_obj%mode)) then
      data_ptr = c_loc(struct_obj%mode(lbound(struct_obj%mode, 1)))
      bounds(1) = int(lbound(struct_obj%mode, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mode, 1), c_int)
      
      el_size = int(storage_size(struct_obj%mode(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wake_lr_struct%t_ref: 0D_NOT_real

  subroutine wake_lr_struct_get_t_ref(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_t_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_ref
  end subroutine


  subroutine wake_lr_struct_set_t_ref(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_t_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_ref = value_in
  end subroutine

  ! wake_lr_struct%freq_spread: 0D_NOT_real

  subroutine wake_lr_struct_get_freq_spread(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_freq_spread')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%freq_spread
  end subroutine


  subroutine wake_lr_struct_set_freq_spread(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_freq_spread')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%freq_spread = value_in
  end subroutine

  ! wake_lr_struct%amp_scale: 0D_NOT_real

  subroutine wake_lr_struct_get_amp_scale(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%amp_scale
  end subroutine


  subroutine wake_lr_struct_set_amp_scale(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_amp_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%amp_scale = value_in
  end subroutine

  ! wake_lr_struct%time_scale: 0D_NOT_real

  subroutine wake_lr_struct_get_time_scale(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_time_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time_scale
  end subroutine


  subroutine wake_lr_struct_set_time_scale(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_time_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time_scale = value_in
  end subroutine

  ! wake_lr_struct%self_wake_on: 0D_NOT_logical

  subroutine wake_lr_struct_get_self_wake_on(struct_obj_ptr, value_out) bind(c, name='wake_lr_struct_get_self_wake_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%self_wake_on
  end subroutine


  subroutine wake_lr_struct_set_self_wake_on(struct_obj_ptr, value_in) bind(c, name='wake_lr_struct_set_self_wake_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wake_lr_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%self_wake_on = value_in
  end subroutine

  !! lat_ele_loc_struct

    function allocate_fortran_lat_ele_loc_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(lat_ele_loc_struct), pointer :: fptr
    type(lat_ele_loc_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_lat_ele_loc_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(lat_ele_loc_struct), pointer :: fptr
    type(lat_ele_loc_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_lat_ele_loc_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_loc_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! lat_ele_loc_struct%ix_ele: 0D_NOT_integer

  subroutine lat_ele_loc_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='lat_ele_loc_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine lat_ele_loc_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='lat_ele_loc_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! lat_ele_loc_struct%ix_branch: 0D_NOT_integer

  subroutine lat_ele_loc_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='lat_ele_loc_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine lat_ele_loc_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='lat_ele_loc_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_loc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  !! wake_struct

    function allocate_fortran_wake_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wake_struct), pointer :: fptr
    type(wake_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wake_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wake_struct), pointer :: fptr
    type(wake_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wake_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wake_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wake_struct%sr: 0D_NOT_type

  subroutine wake_struct_get_sr(struct_obj_ptr, ptr_out) bind(c, name='wake_struct_get_sr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wake_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%sr)
  end subroutine


  subroutine wake_struct_set_sr(struct_obj_ptr, src_ptr) bind(c, name='wake_struct_set_sr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wake_struct), pointer :: struct_obj
    type(wake_sr_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%sr = src_obj
  end subroutine

  ! wake_struct%lr: 0D_NOT_type

  subroutine wake_struct_get_lr(struct_obj_ptr, ptr_out) bind(c, name='wake_struct_get_lr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wake_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lr)
  end subroutine


  subroutine wake_struct_set_lr(struct_obj_ptr, src_ptr) bind(c, name='wake_struct_set_lr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wake_struct), pointer :: struct_obj
    type(wake_lr_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lr = src_obj
  end subroutine

  !! taylor_term_struct

    function allocate_fortran_taylor_term_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(taylor_term_struct), pointer :: fptr
    type(taylor_term_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_taylor_term_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(taylor_term_struct), pointer :: fptr
    type(taylor_term_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_taylor_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(taylor_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! taylor_term_struct%coef: 0D_NOT_real

  subroutine taylor_term_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='taylor_term_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine taylor_term_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='taylor_term_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! taylor_term_struct%expn: 1D_NOT_integer

  subroutine taylor_term_struct_get_expn_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='taylor_term_struct_get_expn_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(taylor_term_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%expn)) then
      data_ptr = c_loc(struct_obj%expn(lbound(struct_obj%expn, 1)))
      bounds(1) = int(lbound(struct_obj%expn, 1), c_int)
      bounds(2) = int(ubound(struct_obj%expn, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! taylor_struct

    function allocate_fortran_taylor_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(taylor_struct), pointer :: fptr
    type(taylor_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_taylor_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(taylor_struct), pointer :: fptr
    type(taylor_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_taylor_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(taylor_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! taylor_struct%ref: 0D_NOT_real

  subroutine taylor_struct_get_ref(struct_obj_ptr, value_out) bind(c, name='taylor_struct_get_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref
  end subroutine


  subroutine taylor_struct_set_ref(struct_obj_ptr, value_in) bind(c, name='taylor_struct_set_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref = value_in
  end subroutine

  ! taylor_struct%term: 1D_PTR_type

  subroutine taylor_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='taylor_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(taylor_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! em_taylor_term_struct

    function allocate_fortran_em_taylor_term_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(em_taylor_term_struct), pointer :: fptr
    type(em_taylor_term_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_em_taylor_term_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(em_taylor_term_struct), pointer :: fptr
    type(em_taylor_term_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_em_taylor_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(em_taylor_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! em_taylor_term_struct%coef: 0D_NOT_real

  subroutine em_taylor_term_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='em_taylor_term_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine em_taylor_term_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='em_taylor_term_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! em_taylor_term_struct%expn: 1D_NOT_integer

  subroutine em_taylor_term_struct_get_expn_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_taylor_term_struct_get_expn_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_taylor_term_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%expn)) then
      data_ptr = c_loc(struct_obj%expn(lbound(struct_obj%expn, 1)))
      bounds(1) = int(lbound(struct_obj%expn, 1), c_int)
      bounds(2) = int(ubound(struct_obj%expn, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! em_taylor_struct

    function allocate_fortran_em_taylor_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(em_taylor_struct), pointer :: fptr
    type(em_taylor_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_em_taylor_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(em_taylor_struct), pointer :: fptr
    type(em_taylor_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_em_taylor_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(em_taylor_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! em_taylor_struct%ref: 0D_NOT_real

  subroutine em_taylor_struct_get_ref(struct_obj_ptr, value_out) bind(c, name='em_taylor_struct_get_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref
  end subroutine


  subroutine em_taylor_struct_set_ref(struct_obj_ptr, value_in) bind(c, name='em_taylor_struct_set_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref = value_in
  end subroutine

  ! em_taylor_struct%term: 1D_ALLOC_type

  subroutine em_taylor_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='em_taylor_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_taylor_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! cartesian_map_term1_struct

    function allocate_fortran_cartesian_map_term1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(cartesian_map_term1_struct), pointer :: fptr
    type(cartesian_map_term1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_cartesian_map_term1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(cartesian_map_term1_struct), pointer :: fptr
    type(cartesian_map_term1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_cartesian_map_term1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cartesian_map_term1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! cartesian_map_term1_struct%coef: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine cartesian_map_term1_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! cartesian_map_term1_struct%kx: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_kx(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_kx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kx
  end subroutine


  subroutine cartesian_map_term1_struct_set_kx(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_kx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kx = value_in
  end subroutine

  ! cartesian_map_term1_struct%ky: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_ky(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_ky')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ky
  end subroutine


  subroutine cartesian_map_term1_struct_set_ky(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_ky')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ky = value_in
  end subroutine

  ! cartesian_map_term1_struct%kz: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_kz(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_kz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kz
  end subroutine


  subroutine cartesian_map_term1_struct_set_kz(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_kz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kz = value_in
  end subroutine

  ! cartesian_map_term1_struct%x0: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine cartesian_map_term1_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! cartesian_map_term1_struct%y0: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine cartesian_map_term1_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! cartesian_map_term1_struct%phi_z: 0D_NOT_real

  subroutine cartesian_map_term1_struct_get_phi_z(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_phi_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_z
  end subroutine


  subroutine cartesian_map_term1_struct_set_phi_z(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_phi_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_z = value_in
  end subroutine

  ! cartesian_map_term1_struct%family: 0D_NOT_integer

  subroutine cartesian_map_term1_struct_get_family(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_family')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%family
  end subroutine


  subroutine cartesian_map_term1_struct_set_family(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_family')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%family = value_in
  end subroutine

  ! cartesian_map_term1_struct%form: 0D_NOT_integer

  subroutine cartesian_map_term1_struct_get_form(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term1_struct_get_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%form
  end subroutine


  subroutine cartesian_map_term1_struct_set_form(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term1_struct_set_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%form = value_in
  end subroutine

  !! cartesian_map_term_struct

    function allocate_fortran_cartesian_map_term_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(cartesian_map_term_struct), pointer :: fptr
    type(cartesian_map_term_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_cartesian_map_term_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(cartesian_map_term_struct), pointer :: fptr
    type(cartesian_map_term_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_cartesian_map_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cartesian_map_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! cartesian_map_term_struct%file: 0D_NOT_character

  subroutine cartesian_map_term_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='cartesian_map_term_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cartesian_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine cartesian_map_term_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='cartesian_map_term_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(cartesian_map_term_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! cartesian_map_term_struct%n_link: 0D_NOT_integer

  subroutine cartesian_map_term_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='cartesian_map_term_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine cartesian_map_term_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='cartesian_map_term_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! cartesian_map_term_struct%term: 1D_ALLOC_type

  subroutine cartesian_map_term_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='cartesian_map_term_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cartesian_map_term_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! cartesian_map_struct

    function allocate_fortran_cartesian_map_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(cartesian_map_struct), pointer :: fptr
    type(cartesian_map_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_cartesian_map_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(cartesian_map_struct), pointer :: fptr
    type(cartesian_map_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_cartesian_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cartesian_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! cartesian_map_struct%field_scale: 0D_NOT_real

  subroutine cartesian_map_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine cartesian_map_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! cartesian_map_struct%r0: 1D_NOT_real

  subroutine cartesian_map_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='cartesian_map_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cartesian_map_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! cartesian_map_struct%master_parameter: 0D_NOT_integer

  subroutine cartesian_map_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine cartesian_map_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! cartesian_map_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine cartesian_map_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine cartesian_map_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! cartesian_map_struct%field_type: 0D_NOT_integer

  subroutine cartesian_map_struct_get_field_type(struct_obj_ptr, value_out) bind(c, name='cartesian_map_struct_get_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_type
  end subroutine


  subroutine cartesian_map_struct_set_field_type(struct_obj_ptr, value_in) bind(c, name='cartesian_map_struct_set_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_type = value_in
  end subroutine

  ! cartesian_map_struct%ptr: 0D_PTR_type

  subroutine cartesian_map_struct_get_ptr(struct_obj_ptr, ptr_out) bind(c, name='cartesian_map_struct_get_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(cartesian_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      ptr_out = c_loc(struct_obj%ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine cartesian_map_struct_set_ptr(struct_obj_ptr, src_ptr) bind(c, name='cartesian_map_struct_set_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(cartesian_map_struct), pointer :: struct_obj
    type(cartesian_map_term_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ptr = src_obj
    endif
  end subroutine

  !! cylindrical_map_term1_struct

    function allocate_fortran_cylindrical_map_term1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(cylindrical_map_term1_struct), pointer :: fptr
    type(cylindrical_map_term1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_cylindrical_map_term1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(cylindrical_map_term1_struct), pointer :: fptr
    type(cylindrical_map_term1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_cylindrical_map_term1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cylindrical_map_term1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! cylindrical_map_term1_struct%e_coef: 0D_NOT_complex

  subroutine cylindrical_map_term1_struct_get_e_coef(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_term1_struct_get_e_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%e_coef
  end subroutine


  subroutine cylindrical_map_term1_struct_set_e_coef(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_term1_struct_set_e_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%e_coef = value_in
  end subroutine

  ! cylindrical_map_term1_struct%b_coef: 0D_NOT_complex

  subroutine cylindrical_map_term1_struct_get_b_coef(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_term1_struct_get_b_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_coef
  end subroutine


  subroutine cylindrical_map_term1_struct_set_b_coef(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_term1_struct_set_b_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(cylindrical_map_term1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_coef = value_in
  end subroutine

  !! cylindrical_map_term_struct

    function allocate_fortran_cylindrical_map_term_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(cylindrical_map_term_struct), pointer :: fptr
    type(cylindrical_map_term_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_cylindrical_map_term_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(cylindrical_map_term_struct), pointer :: fptr
    type(cylindrical_map_term_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_cylindrical_map_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cylindrical_map_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! cylindrical_map_term_struct%file: 0D_NOT_character

  subroutine cylindrical_map_term_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='cylindrical_map_term_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cylindrical_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine cylindrical_map_term_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='cylindrical_map_term_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(cylindrical_map_term_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! cylindrical_map_term_struct%n_link: 0D_NOT_integer

  subroutine cylindrical_map_term_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_term_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine cylindrical_map_term_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_term_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! cylindrical_map_term_struct%term: 1D_ALLOC_type

  subroutine cylindrical_map_term_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='cylindrical_map_term_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cylindrical_map_term_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! cylindrical_map_struct

    function allocate_fortran_cylindrical_map_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(cylindrical_map_struct), pointer :: fptr
    type(cylindrical_map_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_cylindrical_map_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(cylindrical_map_struct), pointer :: fptr
    type(cylindrical_map_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_cylindrical_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(cylindrical_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! cylindrical_map_struct%m: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_m(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%m
  end subroutine


  subroutine cylindrical_map_struct_set_m(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%m = value_in
  end subroutine

  ! cylindrical_map_struct%harmonic: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_harmonic(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%harmonic
  end subroutine


  subroutine cylindrical_map_struct_set_harmonic(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%harmonic = value_in
  end subroutine

  ! cylindrical_map_struct%phi0_fieldmap: 0D_NOT_real

  subroutine cylindrical_map_struct_get_phi0_fieldmap(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi0_fieldmap
  end subroutine


  subroutine cylindrical_map_struct_set_phi0_fieldmap(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi0_fieldmap = value_in
  end subroutine

  ! cylindrical_map_struct%theta0_azimuth: 0D_NOT_real

  subroutine cylindrical_map_struct_get_theta0_azimuth(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_theta0_azimuth')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta0_azimuth
  end subroutine


  subroutine cylindrical_map_struct_set_theta0_azimuth(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_theta0_azimuth')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta0_azimuth = value_in
  end subroutine

  ! cylindrical_map_struct%field_scale: 0D_NOT_real

  subroutine cylindrical_map_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine cylindrical_map_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! cylindrical_map_struct%master_parameter: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine cylindrical_map_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! cylindrical_map_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine cylindrical_map_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine cylindrical_map_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! cylindrical_map_struct%dz: 0D_NOT_real

  subroutine cylindrical_map_struct_get_dz(struct_obj_ptr, value_out) bind(c, name='cylindrical_map_struct_get_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz
  end subroutine


  subroutine cylindrical_map_struct_set_dz(struct_obj_ptr, value_in) bind(c, name='cylindrical_map_struct_set_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz = value_in
  end subroutine

  ! cylindrical_map_struct%r0: 1D_NOT_real

  subroutine cylindrical_map_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='cylindrical_map_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(cylindrical_map_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! cylindrical_map_struct%ptr: 0D_PTR_type

  subroutine cylindrical_map_struct_get_ptr(struct_obj_ptr, ptr_out) bind(c, name='cylindrical_map_struct_get_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(cylindrical_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      ptr_out = c_loc(struct_obj%ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine cylindrical_map_struct_set_ptr(struct_obj_ptr, src_ptr) bind(c, name='cylindrical_map_struct_set_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(cylindrical_map_struct), pointer :: struct_obj
    type(cylindrical_map_term_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ptr = src_obj
    endif
  end subroutine

  !! bicubic_cmplx_coef_struct

    function allocate_fortran_bicubic_cmplx_coef_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bicubic_cmplx_coef_struct), pointer :: fptr
    type(bicubic_cmplx_coef_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bicubic_cmplx_coef_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bicubic_cmplx_coef_struct), pointer :: fptr
    type(bicubic_cmplx_coef_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bicubic_cmplx_coef_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bicubic_cmplx_coef_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bicubic_cmplx_coef_struct%coef: 2D_NOT_complex

  subroutine bicubic_cmplx_coef_struct_get_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='bicubic_cmplx_coef_struct_get_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bicubic_cmplx_coef_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%coef)) then
      data_ptr = c_loc(struct_obj%coef(lbound(struct_obj%coef, 1), lbound(struct_obj%coef, 2)))
      bounds(1) = int(lbound(struct_obj%coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%coef, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bicubic_cmplx_coef_struct%i_box: 1D_NOT_integer

  subroutine bicubic_cmplx_coef_struct_get_i_box_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bicubic_cmplx_coef_struct_get_i_box_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bicubic_cmplx_coef_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%i_box)) then
      data_ptr = c_loc(struct_obj%i_box(lbound(struct_obj%i_box, 1)))
      bounds(1) = int(lbound(struct_obj%i_box, 1), c_int)
      bounds(2) = int(ubound(struct_obj%i_box, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! tricubic_cmplx_coef_struct

    function allocate_fortran_tricubic_cmplx_coef_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tricubic_cmplx_coef_struct), pointer :: fptr
    type(tricubic_cmplx_coef_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tricubic_cmplx_coef_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tricubic_cmplx_coef_struct), pointer :: fptr
    type(tricubic_cmplx_coef_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tricubic_cmplx_coef_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tricubic_cmplx_coef_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tricubic_cmplx_coef_struct%coef: 3D_NOT_complex

  subroutine tricubic_cmplx_coef_struct_get_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tricubic_cmplx_coef_struct_get_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tricubic_cmplx_coef_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%coef)) then
      data_ptr = c_loc(struct_obj%coef(lbound(struct_obj%coef, 1), lbound(struct_obj%coef, 2), lbound(struct_obj%coef, 3)))
      bounds(1) = int(lbound(struct_obj%coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%coef, 2), c_int)
      bounds(5) = int(lbound(struct_obj%coef, 3), c_int)
      bounds(6) = int(ubound(struct_obj%coef, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tricubic_cmplx_coef_struct%i_box: 1D_NOT_integer

  subroutine tricubic_cmplx_coef_struct_get_i_box_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tricubic_cmplx_coef_struct_get_i_box_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tricubic_cmplx_coef_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%i_box)) then
      data_ptr = c_loc(struct_obj%i_box(lbound(struct_obj%i_box, 1)))
      bounds(1) = int(lbound(struct_obj%i_box, 1), c_int)
      bounds(2) = int(ubound(struct_obj%i_box, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! grid_field_pt1_struct

    function allocate_fortran_grid_field_pt1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(grid_field_pt1_struct), pointer :: fptr
    type(grid_field_pt1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_grid_field_pt1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(grid_field_pt1_struct), pointer :: fptr
    type(grid_field_pt1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_grid_field_pt1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_field_pt1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! grid_field_pt1_struct%E: 1D_NOT_complex

  subroutine grid_field_pt1_struct_get_E_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_pt1_struct_get_E_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt1_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%E)) then
      data_ptr = c_loc(struct_obj%E(lbound(struct_obj%E, 1)))
      bounds(1) = int(lbound(struct_obj%E, 1), c_int)
      bounds(2) = int(ubound(struct_obj%E, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_pt1_struct%B: 1D_NOT_complex

  subroutine grid_field_pt1_struct_get_B_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_pt1_struct_get_B_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt1_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%B)) then
      data_ptr = c_loc(struct_obj%B(lbound(struct_obj%B, 1)))
      bounds(1) = int(lbound(struct_obj%B, 1), c_int)
      bounds(2) = int(ubound(struct_obj%B, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! grid_field_pt_struct

    function allocate_fortran_grid_field_pt_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(grid_field_pt_struct), pointer :: fptr
    type(grid_field_pt_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_grid_field_pt_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(grid_field_pt_struct), pointer :: fptr
    type(grid_field_pt_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_grid_field_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_field_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! grid_field_pt_struct%file: 0D_NOT_character

  subroutine grid_field_pt_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='grid_field_pt_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine grid_field_pt_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='grid_field_pt_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(grid_field_pt_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! grid_field_pt_struct%n_link: 0D_NOT_integer

  subroutine grid_field_pt_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='grid_field_pt_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine grid_field_pt_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='grid_field_pt_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! grid_field_pt_struct%pt: 3D_ALLOC_type

  subroutine grid_field_pt_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='grid_field_pt_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_pt_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2), lbound(struct_obj%pt, 3)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      bounds(5) = int(lbound(struct_obj%pt, 3), c_int)
      bounds(6) = int(ubound(struct_obj%pt, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! grid_field_struct

    function allocate_fortran_grid_field_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(grid_field_struct), pointer :: fptr
    type(grid_field_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_grid_field_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(grid_field_struct), pointer :: fptr
    type(grid_field_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_grid_field_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_field_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! grid_field_struct%geometry: 0D_NOT_integer

  subroutine grid_field_struct_get_geometry(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%geometry
  end subroutine


  subroutine grid_field_struct_set_geometry(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%geometry = value_in
  end subroutine

  ! grid_field_struct%harmonic: 0D_NOT_integer

  subroutine grid_field_struct_get_harmonic(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%harmonic
  end subroutine


  subroutine grid_field_struct_set_harmonic(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_harmonic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%harmonic = value_in
  end subroutine

  ! grid_field_struct%phi0_fieldmap: 0D_NOT_real

  subroutine grid_field_struct_get_phi0_fieldmap(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi0_fieldmap
  end subroutine


  subroutine grid_field_struct_set_phi0_fieldmap(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_phi0_fieldmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi0_fieldmap = value_in
  end subroutine

  ! grid_field_struct%field_scale: 0D_NOT_real

  subroutine grid_field_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine grid_field_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! grid_field_struct%field_type: 0D_NOT_integer

  subroutine grid_field_struct_get_field_type(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_type
  end subroutine


  subroutine grid_field_struct_set_field_type(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_type = value_in
  end subroutine

  ! grid_field_struct%master_parameter: 0D_NOT_integer

  subroutine grid_field_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine grid_field_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! grid_field_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine grid_field_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine grid_field_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! grid_field_struct%interpolation_order: 0D_NOT_integer

  subroutine grid_field_struct_get_interpolation_order(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_interpolation_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%interpolation_order
  end subroutine


  subroutine grid_field_struct_set_interpolation_order(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_interpolation_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%interpolation_order = value_in
  end subroutine

  ! grid_field_struct%dr: 1D_NOT_real

  subroutine grid_field_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_struct%r0: 1D_NOT_real

  subroutine grid_field_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='grid_field_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_struct%curved_ref_frame: 0D_NOT_logical

  subroutine grid_field_struct_get_curved_ref_frame(struct_obj_ptr, value_out) bind(c, name='grid_field_struct_get_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%curved_ref_frame
  end subroutine


  subroutine grid_field_struct_set_curved_ref_frame(struct_obj_ptr, value_in) bind(c, name='grid_field_struct_set_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%curved_ref_frame = value_in
  end subroutine

  ! grid_field_struct%ptr: 0D_PTR_type

  subroutine grid_field_struct_get_ptr(struct_obj_ptr, ptr_out) bind(c, name='grid_field_struct_get_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(grid_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      ptr_out = c_loc(struct_obj%ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine grid_field_struct_set_ptr(struct_obj_ptr, src_ptr) bind(c, name='grid_field_struct_set_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(grid_field_struct), pointer :: struct_obj
    type(grid_field_pt_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ptr)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ptr = src_obj
    endif
  end subroutine

  ! grid_field_struct%bi_coef: 3D_NOT_type

  subroutine grid_field_struct_get_bi_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='grid_field_struct_get_bi_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%bi_coef)) then
      data_ptr = c_loc(struct_obj%bi_coef(lbound(struct_obj%bi_coef, 1), lbound(struct_obj%bi_coef, 2), lbound(struct_obj%bi_coef, 3)))
      bounds(1) = int(lbound(struct_obj%bi_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bi_coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%bi_coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%bi_coef, 2), c_int)
      bounds(5) = int(lbound(struct_obj%bi_coef, 3), c_int)
      bounds(6) = int(ubound(struct_obj%bi_coef, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%bi_coef(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! grid_field_struct%tri_coef: 3D_NOT_type

  subroutine grid_field_struct_get_tri_coef_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='grid_field_struct_get_tri_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(grid_field_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%tri_coef)) then
      data_ptr = c_loc(struct_obj%tri_coef(lbound(struct_obj%tri_coef, 1), lbound(struct_obj%tri_coef, 2), lbound(struct_obj%tri_coef, 3)))
      bounds(1) = int(lbound(struct_obj%tri_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%tri_coef, 1), c_int)
      bounds(3) = int(lbound(struct_obj%tri_coef, 2), c_int)
      bounds(4) = int(ubound(struct_obj%tri_coef, 2), c_int)
      bounds(5) = int(lbound(struct_obj%tri_coef, 3), c_int)
      bounds(6) = int(ubound(struct_obj%tri_coef, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      el_size = int(storage_size(struct_obj%tri_coef(bounds(1), bounds(3), bounds(5))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! floor_position_struct

    function allocate_fortran_floor_position_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(floor_position_struct), pointer :: fptr
    type(floor_position_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_floor_position_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(floor_position_struct), pointer :: fptr
    type(floor_position_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_floor_position_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(floor_position_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! floor_position_struct%r: 1D_NOT_real

  subroutine floor_position_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='floor_position_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(floor_position_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! floor_position_struct%w: 2D_NOT_real

  subroutine floor_position_struct_get_w_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='floor_position_struct_get_w_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(floor_position_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%w)) then
      data_ptr = c_loc(struct_obj%w(lbound(struct_obj%w, 1), lbound(struct_obj%w, 2)))
      bounds(1) = int(lbound(struct_obj%w, 1), c_int)
      bounds(2) = int(ubound(struct_obj%w, 1), c_int)
      bounds(3) = int(lbound(struct_obj%w, 2), c_int)
      bounds(4) = int(ubound(struct_obj%w, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! floor_position_struct%theta: 0D_NOT_real

  subroutine floor_position_struct_get_theta(struct_obj_ptr, value_out) bind(c, name='floor_position_struct_get_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%theta
  end subroutine


  subroutine floor_position_struct_set_theta(struct_obj_ptr, value_in) bind(c, name='floor_position_struct_set_theta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%theta = value_in
  end subroutine

  ! floor_position_struct%phi: 0D_NOT_real

  subroutine floor_position_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='floor_position_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine floor_position_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='floor_position_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! floor_position_struct%psi: 0D_NOT_real

  subroutine floor_position_struct_get_psi(struct_obj_ptr, value_out) bind(c, name='floor_position_struct_get_psi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%psi
  end subroutine


  subroutine floor_position_struct_set_psi(struct_obj_ptr, value_in) bind(c, name='floor_position_struct_set_psi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(floor_position_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%psi = value_in
  end subroutine

  !! high_energy_space_charge_struct

    function allocate_fortran_high_energy_space_charge_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(high_energy_space_charge_struct), pointer :: fptr
    type(high_energy_space_charge_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_high_energy_space_charge_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(high_energy_space_charge_struct), pointer :: fptr
    type(high_energy_space_charge_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_high_energy_space_charge_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(high_energy_space_charge_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! high_energy_space_charge_struct%closed_orb: 0D_NOT_type

  subroutine high_energy_space_charge_struct_get_closed_orb(struct_obj_ptr, ptr_out) bind(c, name='high_energy_space_charge_struct_get_closed_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%closed_orb)
  end subroutine


  subroutine high_energy_space_charge_struct_set_closed_orb(struct_obj_ptr, src_ptr) bind(c, name='high_energy_space_charge_struct_set_closed_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(high_energy_space_charge_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%closed_orb = src_obj
  end subroutine

  ! high_energy_space_charge_struct%kick_const: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_kick_const(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_kick_const')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%kick_const
  end subroutine


  subroutine high_energy_space_charge_struct_set_kick_const(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_kick_const')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%kick_const = value_in
  end subroutine

  ! high_energy_space_charge_struct%sig_x: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sig_x(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sig_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_x
  end subroutine


  subroutine high_energy_space_charge_struct_set_sig_x(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sig_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_x = value_in
  end subroutine

  ! high_energy_space_charge_struct%sig_y: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sig_y(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sig_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_y
  end subroutine


  subroutine high_energy_space_charge_struct_set_sig_y(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sig_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_y = value_in
  end subroutine

  ! high_energy_space_charge_struct%phi: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine high_energy_space_charge_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! high_energy_space_charge_struct%sin_phi: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sin_phi(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sin_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sin_phi
  end subroutine


  subroutine high_energy_space_charge_struct_set_sin_phi(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sin_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sin_phi = value_in
  end subroutine

  ! high_energy_space_charge_struct%cos_phi: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_cos_phi(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_cos_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cos_phi
  end subroutine


  subroutine high_energy_space_charge_struct_set_cos_phi(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_cos_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cos_phi = value_in
  end subroutine

  ! high_energy_space_charge_struct%sig_z: 0D_NOT_real

  subroutine high_energy_space_charge_struct_get_sig_z(struct_obj_ptr, value_out) bind(c, name='high_energy_space_charge_struct_get_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z
  end subroutine


  subroutine high_energy_space_charge_struct_set_sig_z(struct_obj_ptr, value_in) bind(c, name='high_energy_space_charge_struct_set_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(high_energy_space_charge_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z = value_in
  end subroutine

  !! xy_disp_struct

    function allocate_fortran_xy_disp_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(xy_disp_struct), pointer :: fptr
    type(xy_disp_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_xy_disp_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(xy_disp_struct), pointer :: fptr
    type(xy_disp_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_xy_disp_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(xy_disp_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! xy_disp_struct%eta: 0D_NOT_real

  subroutine xy_disp_struct_get_eta(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eta
  end subroutine


  subroutine xy_disp_struct_set_eta(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eta = value_in
  end subroutine

  ! xy_disp_struct%etap: 0D_NOT_real

  subroutine xy_disp_struct_get_etap(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%etap
  end subroutine


  subroutine xy_disp_struct_set_etap(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%etap = value_in
  end subroutine

  ! xy_disp_struct%deta_ds: 0D_NOT_real

  subroutine xy_disp_struct_get_deta_ds(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_ds
  end subroutine


  subroutine xy_disp_struct_set_deta_ds(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_ds = value_in
  end subroutine

  ! xy_disp_struct%sigma: 0D_NOT_real

  subroutine xy_disp_struct_get_sigma(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma
  end subroutine


  subroutine xy_disp_struct_set_sigma(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma = value_in
  end subroutine

  ! xy_disp_struct%deta_dpz: 0D_NOT_real

  subroutine xy_disp_struct_get_deta_dpz(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_dpz
  end subroutine


  subroutine xy_disp_struct_set_deta_dpz(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_dpz = value_in
  end subroutine

  ! xy_disp_struct%detap_dpz: 0D_NOT_real

  subroutine xy_disp_struct_get_detap_dpz(struct_obj_ptr, value_out) bind(c, name='xy_disp_struct_get_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%detap_dpz
  end subroutine


  subroutine xy_disp_struct_set_detap_dpz(struct_obj_ptr, value_in) bind(c, name='xy_disp_struct_set_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(xy_disp_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%detap_dpz = value_in
  end subroutine

  !! twiss_struct

    function allocate_fortran_twiss_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(twiss_struct), pointer :: fptr
    type(twiss_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_twiss_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(twiss_struct), pointer :: fptr
    type(twiss_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_twiss_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(twiss_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! twiss_struct%beta: 0D_NOT_real

  subroutine twiss_struct_get_beta(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beta
  end subroutine


  subroutine twiss_struct_set_beta(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_beta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beta = value_in
  end subroutine

  ! twiss_struct%alpha: 0D_NOT_real

  subroutine twiss_struct_get_alpha(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_alpha')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%alpha
  end subroutine


  subroutine twiss_struct_set_alpha(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_alpha')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%alpha = value_in
  end subroutine

  ! twiss_struct%gamma: 0D_NOT_real

  subroutine twiss_struct_get_gamma(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_gamma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gamma
  end subroutine


  subroutine twiss_struct_set_gamma(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_gamma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gamma = value_in
  end subroutine

  ! twiss_struct%phi: 0D_NOT_real

  subroutine twiss_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine twiss_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! twiss_struct%eta: 0D_NOT_real

  subroutine twiss_struct_get_eta(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eta
  end subroutine


  subroutine twiss_struct_set_eta(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_eta')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eta = value_in
  end subroutine

  ! twiss_struct%etap: 0D_NOT_real

  subroutine twiss_struct_get_etap(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%etap
  end subroutine


  subroutine twiss_struct_set_etap(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_etap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%etap = value_in
  end subroutine

  ! twiss_struct%deta_ds: 0D_NOT_real

  subroutine twiss_struct_get_deta_ds(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_ds
  end subroutine


  subroutine twiss_struct_set_deta_ds(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_deta_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_ds = value_in
  end subroutine

  ! twiss_struct%sigma: 0D_NOT_real

  subroutine twiss_struct_get_sigma(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma
  end subroutine


  subroutine twiss_struct_set_sigma(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma = value_in
  end subroutine

  ! twiss_struct%sigma_p: 0D_NOT_real

  subroutine twiss_struct_get_sigma_p(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_sigma_p')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_p
  end subroutine


  subroutine twiss_struct_set_sigma_p(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_sigma_p')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_p = value_in
  end subroutine

  ! twiss_struct%emit: 0D_NOT_real

  subroutine twiss_struct_get_emit(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emit
  end subroutine


  subroutine twiss_struct_set_emit(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emit = value_in
  end subroutine

  ! twiss_struct%norm_emit: 0D_NOT_real

  subroutine twiss_struct_get_norm_emit(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%norm_emit
  end subroutine


  subroutine twiss_struct_set_norm_emit(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%norm_emit = value_in
  end subroutine

  ! twiss_struct%chrom: 0D_NOT_real

  subroutine twiss_struct_get_chrom(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom
  end subroutine


  subroutine twiss_struct_set_chrom(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom = value_in
  end subroutine

  ! twiss_struct%dbeta_dpz: 0D_NOT_real

  subroutine twiss_struct_get_dbeta_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_dbeta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dbeta_dpz
  end subroutine


  subroutine twiss_struct_set_dbeta_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_dbeta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dbeta_dpz = value_in
  end subroutine

  ! twiss_struct%dalpha_dpz: 0D_NOT_real

  subroutine twiss_struct_get_dalpha_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_dalpha_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dalpha_dpz
  end subroutine


  subroutine twiss_struct_set_dalpha_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_dalpha_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dalpha_dpz = value_in
  end subroutine

  ! twiss_struct%deta_dpz: 0D_NOT_real

  subroutine twiss_struct_get_deta_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%deta_dpz
  end subroutine


  subroutine twiss_struct_set_deta_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_deta_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%deta_dpz = value_in
  end subroutine

  ! twiss_struct%detap_dpz: 0D_NOT_real

  subroutine twiss_struct_get_detap_dpz(struct_obj_ptr, value_out) bind(c, name='twiss_struct_get_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%detap_dpz
  end subroutine


  subroutine twiss_struct_set_detap_dpz(struct_obj_ptr, value_in) bind(c, name='twiss_struct_set_detap_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(twiss_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%detap_dpz = value_in
  end subroutine

  !! mode3_struct

    function allocate_fortran_mode3_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(mode3_struct), pointer :: fptr
    type(mode3_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_mode3_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(mode3_struct), pointer :: fptr
    type(mode3_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_mode3_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(mode3_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! mode3_struct%v: 2D_NOT_real

  subroutine mode3_struct_get_v_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='mode3_struct_get_v_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(mode3_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%v)) then
      data_ptr = c_loc(struct_obj%v(lbound(struct_obj%v, 1), lbound(struct_obj%v, 2)))
      bounds(1) = int(lbound(struct_obj%v, 1), c_int)
      bounds(2) = int(ubound(struct_obj%v, 1), c_int)
      bounds(3) = int(lbound(struct_obj%v, 2), c_int)
      bounds(4) = int(ubound(struct_obj%v, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! mode3_struct%a: 0D_NOT_type

  subroutine mode3_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine mode3_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! mode3_struct%b: 0D_NOT_type

  subroutine mode3_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine mode3_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! mode3_struct%c: 0D_NOT_type

  subroutine mode3_struct_get_c(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%c)
  end subroutine


  subroutine mode3_struct_set_c(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%c = src_obj
  end subroutine

  ! mode3_struct%x: 0D_NOT_type

  subroutine mode3_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine mode3_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! mode3_struct%y: 0D_NOT_type

  subroutine mode3_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='mode3_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(mode3_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine mode3_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='mode3_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(mode3_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  !! bookkeeping_state_struct

    function allocate_fortran_bookkeeping_state_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bookkeeping_state_struct), pointer :: fptr
    type(bookkeeping_state_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bookkeeping_state_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bookkeeping_state_struct), pointer :: fptr
    type(bookkeeping_state_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bookkeeping_state_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bookkeeping_state_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bookkeeping_state_struct%attributes: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_attributes(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_attributes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%attributes
  end subroutine


  subroutine bookkeeping_state_struct_set_attributes(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_attributes')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%attributes = value_in
  end subroutine

  ! bookkeeping_state_struct%control: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_control(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%control
  end subroutine


  subroutine bookkeeping_state_struct_set_control(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%control = value_in
  end subroutine

  ! bookkeeping_state_struct%floor_position: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_floor_position(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_floor_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%floor_position
  end subroutine


  subroutine bookkeeping_state_struct_set_floor_position(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_floor_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%floor_position = value_in
  end subroutine

  ! bookkeeping_state_struct%s_position: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_s_position(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_s_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_position
  end subroutine


  subroutine bookkeeping_state_struct_set_s_position(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_s_position')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_position = value_in
  end subroutine

  ! bookkeeping_state_struct%ref_energy: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_ref_energy(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_ref_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_energy
  end subroutine


  subroutine bookkeeping_state_struct_set_ref_energy(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_ref_energy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_energy = value_in
  end subroutine

  ! bookkeeping_state_struct%mat6: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_mat6(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_mat6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mat6
  end subroutine


  subroutine bookkeeping_state_struct_set_mat6(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_mat6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mat6 = value_in
  end subroutine

  ! bookkeeping_state_struct%rad_int: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_rad_int(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_rad_int')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int
  end subroutine


  subroutine bookkeeping_state_struct_set_rad_int(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_rad_int')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int = value_in
  end subroutine

  ! bookkeeping_state_struct%ptc: 0D_NOT_integer

  subroutine bookkeeping_state_struct_get_ptc(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_ptc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ptc
  end subroutine


  subroutine bookkeeping_state_struct_set_ptc(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_ptc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ptc = value_in
  end subroutine

  ! bookkeeping_state_struct%has_misalign: 0D_NOT_logical

  subroutine bookkeeping_state_struct_get_has_misalign(struct_obj_ptr, value_out) bind(c, name='bookkeeping_state_struct_get_has_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%has_misalign
  end subroutine


  subroutine bookkeeping_state_struct_set_has_misalign(struct_obj_ptr, value_in) bind(c, name='bookkeeping_state_struct_set_has_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bookkeeping_state_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%has_misalign = value_in
  end subroutine

  !! rad_map_struct

    function allocate_fortran_rad_map_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rad_map_struct), pointer :: fptr
    type(rad_map_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rad_map_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rad_map_struct), pointer :: fptr
    type(rad_map_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rad_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rad_map_struct%ref_orb: 1D_NOT_real

  subroutine rad_map_struct_get_ref_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='rad_map_struct_get_ref_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%ref_orb)) then
      data_ptr = c_loc(struct_obj%ref_orb(lbound(struct_obj%ref_orb, 1)))
      bounds(1) = int(lbound(struct_obj%ref_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ref_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%damp_dmat: 2D_NOT_real

  subroutine rad_map_struct_get_damp_dmat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='rad_map_struct_get_damp_dmat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%damp_dmat)) then
      data_ptr = c_loc(struct_obj%damp_dmat(lbound(struct_obj%damp_dmat, 1), lbound(struct_obj%damp_dmat, 2)))
      bounds(1) = int(lbound(struct_obj%damp_dmat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%damp_dmat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%damp_dmat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%damp_dmat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%xfer_damp_vec: 1D_NOT_real

  subroutine rad_map_struct_get_xfer_damp_vec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='rad_map_struct_get_xfer_damp_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%xfer_damp_vec)) then
      data_ptr = c_loc(struct_obj%xfer_damp_vec(lbound(struct_obj%xfer_damp_vec, 1)))
      bounds(1) = int(lbound(struct_obj%xfer_damp_vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%xfer_damp_vec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%xfer_damp_mat: 2D_NOT_real

  subroutine rad_map_struct_get_xfer_damp_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='rad_map_struct_get_xfer_damp_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%xfer_damp_mat)) then
      data_ptr = c_loc(struct_obj%xfer_damp_mat(lbound(struct_obj%xfer_damp_mat, 1), lbound(struct_obj%xfer_damp_mat, 2)))
      bounds(1) = int(lbound(struct_obj%xfer_damp_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%xfer_damp_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%xfer_damp_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%xfer_damp_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! rad_map_struct%stoc_mat: 2D_NOT_real

  subroutine rad_map_struct_get_stoc_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='rad_map_struct_get_stoc_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%stoc_mat)) then
      data_ptr = c_loc(struct_obj%stoc_mat(lbound(struct_obj%stoc_mat, 1), lbound(struct_obj%stoc_mat, 2)))
      bounds(1) = int(lbound(struct_obj%stoc_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stoc_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%stoc_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%stoc_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! rad_map_ele_struct

    function allocate_fortran_rad_map_ele_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rad_map_ele_struct), pointer :: fptr
    type(rad_map_ele_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rad_map_ele_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rad_map_ele_struct), pointer :: fptr
    type(rad_map_ele_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rad_map_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_map_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rad_map_ele_struct%rm0: 0D_NOT_type

  subroutine rad_map_ele_struct_get_rm0(struct_obj_ptr, ptr_out) bind(c, name='rad_map_ele_struct_get_rm0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rm0)
  end subroutine


  subroutine rad_map_ele_struct_set_rm0(struct_obj_ptr, src_ptr) bind(c, name='rad_map_ele_struct_set_rm0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(rad_map_ele_struct), pointer :: struct_obj
    type(rad_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rm0 = src_obj
  end subroutine

  ! rad_map_ele_struct%rm1: 0D_NOT_type

  subroutine rad_map_ele_struct_get_rm1(struct_obj_ptr, ptr_out) bind(c, name='rad_map_ele_struct_get_rm1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rm1)
  end subroutine


  subroutine rad_map_ele_struct_set_rm1(struct_obj_ptr, src_ptr) bind(c, name='rad_map_ele_struct_set_rm1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(rad_map_ele_struct), pointer :: struct_obj
    type(rad_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rm1 = src_obj
  end subroutine

  ! rad_map_ele_struct%stale: 0D_NOT_logical

  subroutine rad_map_ele_struct_get_stale(struct_obj_ptr, value_out) bind(c, name='rad_map_ele_struct_get_stale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stale
  end subroutine


  subroutine rad_map_ele_struct_set_stale(struct_obj_ptr, value_in) bind(c, name='rad_map_ele_struct_set_stale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(rad_map_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stale = value_in
  end subroutine

  !! gen_grad1_struct

    function allocate_fortran_gen_grad1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(gen_grad1_struct), pointer :: fptr
    type(gen_grad1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_gen_grad1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(gen_grad1_struct), pointer :: fptr
    type(gen_grad1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_gen_grad1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(gen_grad1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! gen_grad1_struct%m: 0D_NOT_integer

  subroutine gen_grad1_struct_get_m(struct_obj_ptr, value_out) bind(c, name='gen_grad1_struct_get_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%m
  end subroutine


  subroutine gen_grad1_struct_set_m(struct_obj_ptr, value_in) bind(c, name='gen_grad1_struct_set_m')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%m = value_in
  end subroutine

  ! gen_grad1_struct%sincos: 0D_NOT_integer

  subroutine gen_grad1_struct_get_sincos(struct_obj_ptr, value_out) bind(c, name='gen_grad1_struct_get_sincos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sincos
  end subroutine


  subroutine gen_grad1_struct_set_sincos(struct_obj_ptr, value_in) bind(c, name='gen_grad1_struct_set_sincos')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sincos = value_in
  end subroutine

  ! gen_grad1_struct%n_deriv_max: 0D_NOT_integer

  subroutine gen_grad1_struct_get_n_deriv_max(struct_obj_ptr, value_out) bind(c, name='gen_grad1_struct_get_n_deriv_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_deriv_max
  end subroutine


  subroutine gen_grad1_struct_set_n_deriv_max(struct_obj_ptr, value_in) bind(c, name='gen_grad1_struct_set_n_deriv_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_deriv_max = value_in
  end subroutine

  ! gen_grad1_struct%deriv: 2D_ALLOC_real

  subroutine gen_grad1_struct_get_deriv_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='gen_grad1_struct_get_deriv_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad1_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%deriv) .and. is_contiguous(struct_obj%deriv)) then
      data_ptr = c_loc(struct_obj%deriv(lbound(struct_obj%deriv, 1), lbound(struct_obj%deriv, 2)))
      bounds(1) = int(lbound(struct_obj%deriv, 1), c_int)
      bounds(2) = int(ubound(struct_obj%deriv, 1), c_int)
      bounds(3) = int(lbound(struct_obj%deriv, 2), c_int)
      bounds(4) = int(ubound(struct_obj%deriv, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! gen_grad_map_struct

    function allocate_fortran_gen_grad_map_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(gen_grad_map_struct), pointer :: fptr
    type(gen_grad_map_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_gen_grad_map_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(gen_grad_map_struct), pointer :: fptr
    type(gen_grad_map_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_gen_grad_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(gen_grad_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! gen_grad_map_struct%file: 0D_NOT_character

  subroutine gen_grad_map_struct_get_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='gen_grad_map_struct_get_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine gen_grad_map_struct_set_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='gen_grad_map_struct_set_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(gen_grad_map_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file = str_in ! implicitly handles padding
  end subroutine

  ! gen_grad_map_struct%gg: 1D_ALLOC_type

  subroutine gen_grad_map_struct_get_gg_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='gen_grad_map_struct_get_gg_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad_map_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%gg) .and. is_contiguous(struct_obj%gg)) then
      data_ptr = c_loc(struct_obj%gg(lbound(struct_obj%gg, 1)))
      bounds(1) = int(lbound(struct_obj%gg, 1), c_int)
      bounds(2) = int(ubound(struct_obj%gg, 1), c_int)
      
      el_size = int(storage_size(struct_obj%gg(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! gen_grad_map_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine gen_grad_map_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! gen_grad_map_struct%field_type: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_field_type(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_type
  end subroutine


  subroutine gen_grad_map_struct_set_field_type(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_field_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_type = value_in
  end subroutine

  ! gen_grad_map_struct%iz0: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_iz0(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_iz0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iz0
  end subroutine


  subroutine gen_grad_map_struct_set_iz0(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_iz0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iz0 = value_in
  end subroutine

  ! gen_grad_map_struct%iz1: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_iz1(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_iz1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iz1
  end subroutine


  subroutine gen_grad_map_struct_set_iz1(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_iz1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iz1 = value_in
  end subroutine

  ! gen_grad_map_struct%dz: 0D_NOT_real

  subroutine gen_grad_map_struct_get_dz(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz
  end subroutine


  subroutine gen_grad_map_struct_set_dz(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz = value_in
  end subroutine

  ! gen_grad_map_struct%r0: 1D_NOT_real

  subroutine gen_grad_map_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='gen_grad_map_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(gen_grad_map_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! gen_grad_map_struct%field_scale: 0D_NOT_real

  subroutine gen_grad_map_struct_get_field_scale(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_scale
  end subroutine


  subroutine gen_grad_map_struct_set_field_scale(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_field_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_scale = value_in
  end subroutine

  ! gen_grad_map_struct%master_parameter: 0D_NOT_integer

  subroutine gen_grad_map_struct_get_master_parameter(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%master_parameter
  end subroutine


  subroutine gen_grad_map_struct_set_master_parameter(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_master_parameter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%master_parameter = value_in
  end subroutine

  ! gen_grad_map_struct%curved_ref_frame: 0D_NOT_logical

  subroutine gen_grad_map_struct_get_curved_ref_frame(struct_obj_ptr, value_out) bind(c, name='gen_grad_map_struct_get_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%curved_ref_frame
  end subroutine


  subroutine gen_grad_map_struct_set_curved_ref_frame(struct_obj_ptr, value_in) bind(c, name='gen_grad_map_struct_set_curved_ref_frame')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(gen_grad_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%curved_ref_frame = value_in
  end subroutine

  !! surface_segmented_pt_struct

    function allocate_fortran_surface_segmented_pt_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_segmented_pt_struct), pointer :: fptr
    type(surface_segmented_pt_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_segmented_pt_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_segmented_pt_struct), pointer :: fptr
    type(surface_segmented_pt_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_segmented_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_segmented_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_segmented_pt_struct%x0: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine surface_segmented_pt_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! surface_segmented_pt_struct%y0: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine surface_segmented_pt_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! surface_segmented_pt_struct%z0: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_z0(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z0
  end subroutine


  subroutine surface_segmented_pt_struct_set_z0(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z0 = value_in
  end subroutine

  ! surface_segmented_pt_struct%dz_dx: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_dz_dx(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dx
  end subroutine


  subroutine surface_segmented_pt_struct_set_dz_dx(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dx = value_in
  end subroutine

  ! surface_segmented_pt_struct%dz_dy: 0D_NOT_real

  subroutine surface_segmented_pt_struct_get_dz_dy(struct_obj_ptr, value_out) bind(c, name='surface_segmented_pt_struct_get_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dy
  end subroutine


  subroutine surface_segmented_pt_struct_set_dz_dy(struct_obj_ptr, value_in) bind(c, name='surface_segmented_pt_struct_set_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_segmented_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dy = value_in
  end subroutine

  !! surface_segmented_struct

    function allocate_fortran_surface_segmented_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_segmented_struct), pointer :: fptr
    type(surface_segmented_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_segmented_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_segmented_struct), pointer :: fptr
    type(surface_segmented_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_segmented_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_segmented_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_segmented_struct%active: 0D_NOT_logical

  subroutine surface_segmented_struct_get_active(struct_obj_ptr, value_out) bind(c, name='surface_segmented_struct_get_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_segmented_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%active
  end subroutine


  subroutine surface_segmented_struct_set_active(struct_obj_ptr, value_in) bind(c, name='surface_segmented_struct_set_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_segmented_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%active = value_in
  end subroutine

  ! surface_segmented_struct%dr: 1D_NOT_real

  subroutine surface_segmented_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_segmented_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_segmented_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_segmented_struct%r0: 1D_NOT_real

  subroutine surface_segmented_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_segmented_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_segmented_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_segmented_struct%pt: 2D_ALLOC_type

  subroutine surface_segmented_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='surface_segmented_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_segmented_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! surface_h_misalign_pt_struct

    function allocate_fortran_surface_h_misalign_pt_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_h_misalign_pt_struct), pointer :: fptr
    type(surface_h_misalign_pt_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_h_misalign_pt_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_h_misalign_pt_struct), pointer :: fptr
    type(surface_h_misalign_pt_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_h_misalign_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_h_misalign_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_h_misalign_pt_struct%x0: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%y0: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_y: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_y(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_y
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_y(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_y = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_t: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_t(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_t
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_t(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_t = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_y_rms: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_y_rms(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_y_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_y_rms
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_y_rms(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_y_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_y_rms = value_in
  end subroutine

  ! surface_h_misalign_pt_struct%rot_t_rms: 0D_NOT_real

  subroutine surface_h_misalign_pt_struct_get_rot_t_rms(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_pt_struct_get_rot_t_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rot_t_rms
  end subroutine


  subroutine surface_h_misalign_pt_struct_set_rot_t_rms(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_pt_struct_set_rot_t_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_h_misalign_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rot_t_rms = value_in
  end subroutine

  !! surface_h_misalign_struct

    function allocate_fortran_surface_h_misalign_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_h_misalign_struct), pointer :: fptr
    type(surface_h_misalign_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_h_misalign_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_h_misalign_struct), pointer :: fptr
    type(surface_h_misalign_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_h_misalign_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_h_misalign_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_h_misalign_struct%active: 0D_NOT_logical

  subroutine surface_h_misalign_struct_get_active(struct_obj_ptr, value_out) bind(c, name='surface_h_misalign_struct_get_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_h_misalign_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%active
  end subroutine


  subroutine surface_h_misalign_struct_set_active(struct_obj_ptr, value_in) bind(c, name='surface_h_misalign_struct_set_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_h_misalign_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%active = value_in
  end subroutine

  ! surface_h_misalign_struct%dr: 1D_NOT_real

  subroutine surface_h_misalign_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_h_misalign_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_h_misalign_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_h_misalign_struct%r0: 1D_NOT_real

  subroutine surface_h_misalign_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_h_misalign_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_h_misalign_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_h_misalign_struct%pt: 2D_ALLOC_type

  subroutine surface_h_misalign_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='surface_h_misalign_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_h_misalign_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! surface_displacement_pt_struct

    function allocate_fortran_surface_displacement_pt_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_displacement_pt_struct), pointer :: fptr
    type(surface_displacement_pt_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_displacement_pt_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_displacement_pt_struct), pointer :: fptr
    type(surface_displacement_pt_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_displacement_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_displacement_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_displacement_pt_struct%x0: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine surface_displacement_pt_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! surface_displacement_pt_struct%y0: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine surface_displacement_pt_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! surface_displacement_pt_struct%z0: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_z0(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z0
  end subroutine


  subroutine surface_displacement_pt_struct_set_z0(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_z0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z0 = value_in
  end subroutine

  ! surface_displacement_pt_struct%dz_dx: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_dz_dx(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dx
  end subroutine


  subroutine surface_displacement_pt_struct_set_dz_dx(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_dz_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dx = value_in
  end subroutine

  ! surface_displacement_pt_struct%dz_dy: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_dz_dy(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dz_dy
  end subroutine


  subroutine surface_displacement_pt_struct_set_dz_dy(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_dz_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dz_dy = value_in
  end subroutine

  ! surface_displacement_pt_struct%d2z_dxdy: 0D_NOT_real

  subroutine surface_displacement_pt_struct_get_d2z_dxdy(struct_obj_ptr, value_out) bind(c, name='surface_displacement_pt_struct_get_d2z_dxdy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%d2z_dxdy
  end subroutine


  subroutine surface_displacement_pt_struct_set_d2z_dxdy(struct_obj_ptr, value_in) bind(c, name='surface_displacement_pt_struct_set_d2z_dxdy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_displacement_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%d2z_dxdy = value_in
  end subroutine

  !! surface_displacement_struct

    function allocate_fortran_surface_displacement_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_displacement_struct), pointer :: fptr
    type(surface_displacement_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_displacement_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_displacement_struct), pointer :: fptr
    type(surface_displacement_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_displacement_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_displacement_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_displacement_struct%active: 0D_NOT_logical

  subroutine surface_displacement_struct_get_active(struct_obj_ptr, value_out) bind(c, name='surface_displacement_struct_get_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_displacement_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%active
  end subroutine


  subroutine surface_displacement_struct_set_active(struct_obj_ptr, value_in) bind(c, name='surface_displacement_struct_set_active')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_displacement_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%active = value_in
  end subroutine

  ! surface_displacement_struct%dr: 1D_NOT_real

  subroutine surface_displacement_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_displacement_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_displacement_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_displacement_struct%r0: 1D_NOT_real

  subroutine surface_displacement_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_displacement_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_displacement_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_displacement_struct%pt: 2D_ALLOC_type

  subroutine surface_displacement_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='surface_displacement_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_displacement_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! target_point_struct

    function allocate_fortran_target_point_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(target_point_struct), pointer :: fptr
    type(target_point_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_target_point_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(target_point_struct), pointer :: fptr
    type(target_point_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_target_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(target_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! target_point_struct%r: 1D_NOT_real

  subroutine target_point_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='target_point_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(target_point_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! surface_curvature_struct

    function allocate_fortran_surface_curvature_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(surface_curvature_struct), pointer :: fptr
    type(surface_curvature_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_surface_curvature_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(surface_curvature_struct), pointer :: fptr
    type(surface_curvature_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_surface_curvature_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(surface_curvature_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! surface_curvature_struct%xy: 2D_NOT_real

  subroutine surface_curvature_struct_get_xy_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='surface_curvature_struct_get_xy_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_curvature_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%xy)) then
      data_ptr = c_loc(struct_obj%xy(lbound(struct_obj%xy, 1), lbound(struct_obj%xy, 2)))
      bounds(1) = int(lbound(struct_obj%xy, 1), c_int)
      bounds(2) = int(ubound(struct_obj%xy, 1), c_int)
      bounds(3) = int(lbound(struct_obj%xy, 2), c_int)
      bounds(4) = int(ubound(struct_obj%xy, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_curvature_struct%spherical: 0D_NOT_real

  subroutine surface_curvature_struct_get_spherical(struct_obj_ptr, value_out) bind(c, name='surface_curvature_struct_get_spherical')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spherical
  end subroutine


  subroutine surface_curvature_struct_set_spherical(struct_obj_ptr, value_in) bind(c, name='surface_curvature_struct_set_spherical')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spherical = value_in
  end subroutine

  ! surface_curvature_struct%elliptical: 1D_NOT_real

  subroutine surface_curvature_struct_get_elliptical_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='surface_curvature_struct_get_elliptical_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(surface_curvature_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%elliptical)) then
      data_ptr = c_loc(struct_obj%elliptical(lbound(struct_obj%elliptical, 1)))
      bounds(1) = int(lbound(struct_obj%elliptical, 1), c_int)
      bounds(2) = int(ubound(struct_obj%elliptical, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! surface_curvature_struct%has_curvature: 0D_NOT_logical

  subroutine surface_curvature_struct_get_has_curvature(struct_obj_ptr, value_out) bind(c, name='surface_curvature_struct_get_has_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%has_curvature
  end subroutine


  subroutine surface_curvature_struct_set_has_curvature(struct_obj_ptr, value_in) bind(c, name='surface_curvature_struct_set_has_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(surface_curvature_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%has_curvature = value_in
  end subroutine

  !! photon_target_struct

    function allocate_fortran_photon_target_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(photon_target_struct), pointer :: fptr
    type(photon_target_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_photon_target_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(photon_target_struct), pointer :: fptr
    type(photon_target_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_photon_target_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_target_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! photon_target_struct%type: 0D_NOT_integer

  subroutine photon_target_struct_get_type(struct_obj_ptr, value_out) bind(c, name='photon_target_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine photon_target_struct_set_type(struct_obj_ptr, value_in) bind(c, name='photon_target_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! photon_target_struct%n_corner: 0D_NOT_integer

  subroutine photon_target_struct_get_n_corner(struct_obj_ptr, value_out) bind(c, name='photon_target_struct_get_n_corner')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_corner
  end subroutine


  subroutine photon_target_struct_set_n_corner(struct_obj_ptr, value_in) bind(c, name='photon_target_struct_set_n_corner')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_corner = value_in
  end subroutine

  ! photon_target_struct%ele_loc: 0D_NOT_type

  subroutine photon_target_struct_get_ele_loc(struct_obj_ptr, ptr_out) bind(c, name='photon_target_struct_get_ele_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_loc)
  end subroutine


  subroutine photon_target_struct_set_ele_loc(struct_obj_ptr, src_ptr) bind(c, name='photon_target_struct_set_ele_loc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_target_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_loc = src_obj
  end subroutine

  ! photon_target_struct%corner: 1D_NOT_type

  subroutine photon_target_struct_get_corner_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_target_struct_get_corner_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_target_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%corner)) then
      data_ptr = c_loc(struct_obj%corner(lbound(struct_obj%corner, 1)))
      bounds(1) = int(lbound(struct_obj%corner, 1), c_int)
      bounds(2) = int(ubound(struct_obj%corner, 1), c_int)
      
      el_size = int(storage_size(struct_obj%corner(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_target_struct%center: 0D_NOT_type

  subroutine photon_target_struct_get_center(struct_obj_ptr, ptr_out) bind(c, name='photon_target_struct_get_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_target_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%center)
  end subroutine


  subroutine photon_target_struct_set_center(struct_obj_ptr, src_ptr) bind(c, name='photon_target_struct_set_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_target_struct), pointer :: struct_obj
    type(target_point_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%center = src_obj
  end subroutine

  !! photon_material_struct

    function allocate_fortran_photon_material_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(photon_material_struct), pointer :: fptr
    type(photon_material_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_photon_material_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(photon_material_struct), pointer :: fptr
    type(photon_material_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_photon_material_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_material_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! photon_material_struct%f0_m1: 0D_NOT_complex

  subroutine photon_material_struct_get_f0_m1(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f0_m1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f0_m1
  end subroutine


  subroutine photon_material_struct_set_f0_m1(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f0_m1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f0_m1 = value_in
  end subroutine

  ! photon_material_struct%f0_m2: 0D_NOT_complex

  subroutine photon_material_struct_get_f0_m2(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f0_m2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f0_m2
  end subroutine


  subroutine photon_material_struct_set_f0_m2(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f0_m2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f0_m2 = value_in
  end subroutine

  ! photon_material_struct%f_0: 0D_NOT_complex

  subroutine photon_material_struct_get_f_0(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_0
  end subroutine


  subroutine photon_material_struct_set_f_0(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_0 = value_in
  end subroutine

  ! photon_material_struct%f_h: 0D_NOT_complex

  subroutine photon_material_struct_get_f_h(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_h')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_h
  end subroutine


  subroutine photon_material_struct_set_f_h(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_h')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_h = value_in
  end subroutine

  ! photon_material_struct%f_hbar: 0D_NOT_complex

  subroutine photon_material_struct_get_f_hbar(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_hbar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_hbar
  end subroutine


  subroutine photon_material_struct_set_f_hbar(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_hbar')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_hbar = value_in
  end subroutine

  ! photon_material_struct%f_hkl: 0D_NOT_complex

  subroutine photon_material_struct_get_f_hkl(struct_obj_ptr, value_out) bind(c, name='photon_material_struct_get_f_hkl')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%f_hkl
  end subroutine


  subroutine photon_material_struct_set_f_hkl(struct_obj_ptr, value_in) bind(c, name='photon_material_struct_set_f_hkl')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(photon_material_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%f_hkl = value_in
  end subroutine

  ! photon_material_struct%h_norm: 1D_NOT_real

  subroutine photon_material_struct_get_h_norm_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_material_struct_get_h_norm_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_material_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%h_norm)) then
      data_ptr = c_loc(struct_obj%h_norm(lbound(struct_obj%h_norm, 1)))
      bounds(1) = int(lbound(struct_obj%h_norm, 1), c_int)
      bounds(2) = int(ubound(struct_obj%h_norm, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! photon_material_struct%l_ref: 1D_NOT_real

  subroutine photon_material_struct_get_l_ref_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_material_struct_get_l_ref_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_material_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%l_ref)) then
      data_ptr = c_loc(struct_obj%l_ref(lbound(struct_obj%l_ref, 1)))
      bounds(1) = int(lbound(struct_obj%l_ref, 1), c_int)
      bounds(2) = int(ubound(struct_obj%l_ref, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! pixel_pt_struct

    function allocate_fortran_pixel_pt_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(pixel_pt_struct), pointer :: fptr
    type(pixel_pt_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_pixel_pt_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(pixel_pt_struct), pointer :: fptr
    type(pixel_pt_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_pixel_pt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(pixel_pt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! pixel_pt_struct%n_photon: 0D_NOT_integer8

  subroutine pixel_pt_struct_get_n_photon(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_n_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_photon
  end subroutine


  subroutine pixel_pt_struct_set_n_photon(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_n_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_photon = value_in
  end subroutine

  ! pixel_pt_struct%E_x: 0D_NOT_complex

  subroutine pixel_pt_struct_get_E_x(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_E_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_x
  end subroutine


  subroutine pixel_pt_struct_set_E_x(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_E_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_x = value_in
  end subroutine

  ! pixel_pt_struct%E_y: 0D_NOT_complex

  subroutine pixel_pt_struct_get_E_y(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_E_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_y
  end subroutine


  subroutine pixel_pt_struct_set_E_y(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_E_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_y = value_in
  end subroutine

  ! pixel_pt_struct%intensity_x: 0D_NOT_real

  subroutine pixel_pt_struct_get_intensity_x(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_intensity_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%intensity_x
  end subroutine


  subroutine pixel_pt_struct_set_intensity_x(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_intensity_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%intensity_x = value_in
  end subroutine

  ! pixel_pt_struct%intensity_y: 0D_NOT_real

  subroutine pixel_pt_struct_get_intensity_y(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_intensity_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%intensity_y
  end subroutine


  subroutine pixel_pt_struct_set_intensity_y(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_intensity_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%intensity_y = value_in
  end subroutine

  ! pixel_pt_struct%intensity: 0D_NOT_real

  subroutine pixel_pt_struct_get_intensity(struct_obj_ptr, value_out) bind(c, name='pixel_pt_struct_get_intensity')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%intensity
  end subroutine


  subroutine pixel_pt_struct_set_intensity(struct_obj_ptr, value_in) bind(c, name='pixel_pt_struct_set_intensity')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(pixel_pt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%intensity = value_in
  end subroutine

  ! pixel_pt_struct%orbit: 1D_NOT_real

  subroutine pixel_pt_struct_get_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%orbit)) then
      data_ptr = c_loc(struct_obj%orbit(lbound(struct_obj%orbit, 1)))
      bounds(1) = int(lbound(struct_obj%orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_pt_struct%orbit_rms: 1D_NOT_real

  subroutine pixel_pt_struct_get_orbit_rms_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_orbit_rms_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%orbit_rms)) then
      data_ptr = c_loc(struct_obj%orbit_rms(lbound(struct_obj%orbit_rms, 1)))
      bounds(1) = int(lbound(struct_obj%orbit_rms, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit_rms, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_pt_struct%init_orbit: 1D_NOT_real

  subroutine pixel_pt_struct_get_init_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_init_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%init_orbit)) then
      data_ptr = c_loc(struct_obj%init_orbit(lbound(struct_obj%init_orbit, 1)))
      bounds(1) = int(lbound(struct_obj%init_orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%init_orbit, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_pt_struct%init_orbit_rms: 1D_NOT_real

  subroutine pixel_pt_struct_get_init_orbit_rms_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_pt_struct_get_init_orbit_rms_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_pt_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%init_orbit_rms)) then
      data_ptr = c_loc(struct_obj%init_orbit_rms(lbound(struct_obj%init_orbit_rms, 1)))
      bounds(1) = int(lbound(struct_obj%init_orbit_rms, 1), c_int)
      bounds(2) = int(ubound(struct_obj%init_orbit_rms, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! pixel_detec_struct

    function allocate_fortran_pixel_detec_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(pixel_detec_struct), pointer :: fptr
    type(pixel_detec_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_pixel_detec_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(pixel_detec_struct), pointer :: fptr
    type(pixel_detec_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_pixel_detec_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(pixel_detec_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! pixel_detec_struct%dr: 1D_NOT_real

  subroutine pixel_detec_struct_get_dr_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_detec_struct_get_dr_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_detec_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dr)) then
      data_ptr = c_loc(struct_obj%dr(lbound(struct_obj%dr, 1)))
      bounds(1) = int(lbound(struct_obj%dr, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dr, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_detec_struct%r0: 1D_NOT_real

  subroutine pixel_detec_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='pixel_detec_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_detec_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! pixel_detec_struct%n_track_tot: 0D_NOT_integer8

  subroutine pixel_detec_struct_get_n_track_tot(struct_obj_ptr, value_out) bind(c, name='pixel_detec_struct_get_n_track_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(out) :: value_out
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_track_tot
  end subroutine


  subroutine pixel_detec_struct_set_n_track_tot(struct_obj_ptr, value_in) bind(c, name='pixel_detec_struct_set_n_track_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(in), value :: value_in
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_track_tot = value_in
  end subroutine

  ! pixel_detec_struct%n_hit_detec: 0D_NOT_integer8

  subroutine pixel_detec_struct_get_n_hit_detec(struct_obj_ptr, value_out) bind(c, name='pixel_detec_struct_get_n_hit_detec')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(out) :: value_out
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_hit_detec
  end subroutine


  subroutine pixel_detec_struct_set_n_hit_detec(struct_obj_ptr, value_in) bind(c, name='pixel_detec_struct_set_n_hit_detec')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(in), value :: value_in
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_hit_detec = value_in
  end subroutine

  ! pixel_detec_struct%n_hit_pixel: 0D_NOT_integer8

  subroutine pixel_detec_struct_get_n_hit_pixel(struct_obj_ptr, value_out) bind(c, name='pixel_detec_struct_get_n_hit_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(out) :: value_out
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_hit_pixel
  end subroutine


  subroutine pixel_detec_struct_set_n_hit_pixel(struct_obj_ptr, value_in) bind(c, name='pixel_detec_struct_set_n_hit_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_long_long), intent(in), value :: value_in
    type(pixel_detec_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_hit_pixel = value_in
  end subroutine

  ! pixel_detec_struct%pt: 2D_ALLOC_type

  subroutine pixel_detec_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated, el_size) &
        bind(c, name='pixel_detec_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pixel_detec_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1), lbound(struct_obj%pt, 2)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      bounds(3) = int(lbound(struct_obj%pt, 2), c_int)
      bounds(4) = int(ubound(struct_obj%pt, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      el_size = int(storage_size(struct_obj%pt(bounds(1), bounds(3))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! photon_element_struct

    function allocate_fortran_photon_element_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(photon_element_struct), pointer :: fptr
    type(photon_element_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_photon_element_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(photon_element_struct), pointer :: fptr
    type(photon_element_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_photon_element_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(photon_element_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! photon_element_struct%curvature: 0D_NOT_type

  subroutine photon_element_struct_get_curvature(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%curvature)
  end subroutine


  subroutine photon_element_struct_set_curvature(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_curvature')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_curvature_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%curvature = src_obj
  end subroutine

  ! photon_element_struct%target: 0D_NOT_type

  subroutine photon_element_struct_get_target(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_target')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%target)
  end subroutine


  subroutine photon_element_struct_set_target(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_target')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_target_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%target = src_obj
  end subroutine

  ! photon_element_struct%material: 0D_NOT_type

  subroutine photon_element_struct_get_material(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%material)
  end subroutine


  subroutine photon_element_struct_set_material(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_material_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%material = src_obj
  end subroutine

  ! photon_element_struct%segmented: 0D_NOT_type

  subroutine photon_element_struct_get_segmented(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_segmented')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%segmented)
  end subroutine


  subroutine photon_element_struct_set_segmented(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_segmented')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_segmented_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%segmented = src_obj
  end subroutine

  ! photon_element_struct%h_misalign: 0D_NOT_type

  subroutine photon_element_struct_get_h_misalign(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_h_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%h_misalign)
  end subroutine


  subroutine photon_element_struct_set_h_misalign(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_h_misalign')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_h_misalign_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%h_misalign = src_obj
  end subroutine

  ! photon_element_struct%displacement: 0D_NOT_type

  subroutine photon_element_struct_get_displacement(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_displacement')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%displacement)
  end subroutine


  subroutine photon_element_struct_set_displacement(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_displacement')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(surface_displacement_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%displacement = src_obj
  end subroutine

  ! photon_element_struct%pixel: 0D_NOT_type

  subroutine photon_element_struct_get_pixel(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%pixel)
  end subroutine


  subroutine photon_element_struct_set_pixel(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_pixel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(pixel_detec_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%pixel = src_obj
  end subroutine

  ! photon_element_struct%reflectivity_table_type: 0D_NOT_integer

  subroutine photon_element_struct_get_reflectivity_table_type(struct_obj_ptr, value_out) bind(c, name='photon_element_struct_get_reflectivity_table_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%reflectivity_table_type
  end subroutine


  subroutine photon_element_struct_set_reflectivity_table_type(struct_obj_ptr, value_in) bind(c, name='photon_element_struct_set_reflectivity_table_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%reflectivity_table_type = value_in
  end subroutine

  ! photon_element_struct%reflectivity_table_sigma: 0D_NOT_type

  subroutine photon_element_struct_get_reflectivity_table_sigma(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_reflectivity_table_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%reflectivity_table_sigma)
  end subroutine


  subroutine photon_element_struct_set_reflectivity_table_sigma(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_reflectivity_table_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_reflect_table_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%reflectivity_table_sigma = src_obj
  end subroutine

  ! photon_element_struct%reflectivity_table_pi: 0D_NOT_type

  subroutine photon_element_struct_get_reflectivity_table_pi(struct_obj_ptr, ptr_out) bind(c, name='photon_element_struct_get_reflectivity_table_pi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(photon_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%reflectivity_table_pi)
  end subroutine


  subroutine photon_element_struct_set_reflectivity_table_pi(struct_obj_ptr, src_ptr) bind(c, name='photon_element_struct_set_reflectivity_table_pi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(photon_element_struct), pointer :: struct_obj
    type(photon_reflect_table_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%reflectivity_table_pi = src_obj
  end subroutine

  ! photon_element_struct%init_energy_prob: 1D_ALLOC_type

  subroutine photon_element_struct_get_init_energy_prob_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='photon_element_struct_get_init_energy_prob_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_element_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%init_energy_prob) .and. is_contiguous(struct_obj%init_energy_prob)) then
      data_ptr = c_loc(struct_obj%init_energy_prob(lbound(struct_obj%init_energy_prob, 1)))
      bounds(1) = int(lbound(struct_obj%init_energy_prob, 1), c_int)
      bounds(2) = int(ubound(struct_obj%init_energy_prob, 1), c_int)
      
      el_size = int(storage_size(struct_obj%init_energy_prob(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! photon_element_struct%integrated_init_energy_prob: 1D_ALLOC_real

  subroutine photon_element_struct_get_integrated_init_energy_prob_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='photon_element_struct_get_integrated_init_energy_prob_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(photon_element_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%integrated_init_energy_prob) .and. is_contiguous(struct_obj%integrated_init_energy_prob)) then
      data_ptr = c_loc(struct_obj%integrated_init_energy_prob(lbound(struct_obj%integrated_init_energy_prob, 1)))
      bounds(1) = int(lbound(struct_obj%integrated_init_energy_prob, 1), c_int)
      bounds(2) = int(ubound(struct_obj%integrated_init_energy_prob, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! wall3d_vertex_struct

    function allocate_fortran_wall3d_vertex_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wall3d_vertex_struct), pointer :: fptr
    type(wall3d_vertex_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wall3d_vertex_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wall3d_vertex_struct), pointer :: fptr
    type(wall3d_vertex_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wall3d_vertex_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wall3d_vertex_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wall3d_vertex_struct%x: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_x(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine wall3d_vertex_struct_set_x(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! wall3d_vertex_struct%y: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_y(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine wall3d_vertex_struct_set_y(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! wall3d_vertex_struct%radius_x: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_radius_x(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_radius_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radius_x
  end subroutine


  subroutine wall3d_vertex_struct_set_radius_x(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_radius_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radius_x = value_in
  end subroutine

  ! wall3d_vertex_struct%radius_y: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_radius_y(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_radius_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radius_y
  end subroutine


  subroutine wall3d_vertex_struct_set_radius_y(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_radius_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radius_y = value_in
  end subroutine

  ! wall3d_vertex_struct%tilt: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_tilt(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_tilt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tilt
  end subroutine


  subroutine wall3d_vertex_struct_set_tilt(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_tilt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tilt = value_in
  end subroutine

  ! wall3d_vertex_struct%angle: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_angle(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%angle
  end subroutine


  subroutine wall3d_vertex_struct_set_angle(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%angle = value_in
  end subroutine

  ! wall3d_vertex_struct%x0: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_x0(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x0
  end subroutine


  subroutine wall3d_vertex_struct_set_x0(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_x0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x0 = value_in
  end subroutine

  ! wall3d_vertex_struct%y0: 0D_NOT_real

  subroutine wall3d_vertex_struct_get_y0(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y0
  end subroutine


  subroutine wall3d_vertex_struct_set_y0(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_y0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y0 = value_in
  end subroutine

  ! wall3d_vertex_struct%type: 0D_NOT_integer

  subroutine wall3d_vertex_struct_get_type(struct_obj_ptr, value_out) bind(c, name='wall3d_vertex_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine wall3d_vertex_struct_set_type(struct_obj_ptr, value_in) bind(c, name='wall3d_vertex_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_vertex_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  !! wall3d_section_struct

    function allocate_fortran_wall3d_section_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wall3d_section_struct), pointer :: fptr
    type(wall3d_section_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wall3d_section_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wall3d_section_struct), pointer :: fptr
    type(wall3d_section_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wall3d_section_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wall3d_section_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wall3d_section_struct%name: 0D_NOT_character

  subroutine wall3d_section_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_section_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_section_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_section_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_section_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_section_struct%material: 0D_NOT_character

  subroutine wall3d_section_struct_get_material_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_section_struct_get_material_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%material)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%material), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_section_struct_set_material(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_section_struct_set_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_section_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%material = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_section_struct%v: 1D_ALLOC_type

  subroutine wall3d_section_struct_get_v_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wall3d_section_struct_get_v_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%v) .and. is_contiguous(struct_obj%v)) then
      data_ptr = c_loc(struct_obj%v(lbound(struct_obj%v, 1)))
      bounds(1) = int(lbound(struct_obj%v, 1), c_int)
      bounds(2) = int(ubound(struct_obj%v, 1), c_int)
      
      el_size = int(storage_size(struct_obj%v(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%surface: 0D_PTR_type

  subroutine wall3d_section_struct_get_surface(struct_obj_ptr, ptr_out) bind(c, name='wall3d_section_struct_get_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%surface)) then
      ptr_out = c_loc(struct_obj%surface)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine wall3d_section_struct_set_surface(struct_obj_ptr, src_ptr) bind(c, name='wall3d_section_struct_set_surface')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(wall3d_section_struct), pointer :: struct_obj
    type(photon_reflect_surface_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%surface)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%surface = src_obj
    endif
  end subroutine

  ! wall3d_section_struct%type: 0D_NOT_integer

  subroutine wall3d_section_struct_get_type(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine wall3d_section_struct_set_type(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! wall3d_section_struct%n_vertex_input: 0D_NOT_integer

  subroutine wall3d_section_struct_get_n_vertex_input(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_n_vertex_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_vertex_input
  end subroutine


  subroutine wall3d_section_struct_set_n_vertex_input(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_n_vertex_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_vertex_input = value_in
  end subroutine

  ! wall3d_section_struct%ix_ele: 0D_NOT_integer

  subroutine wall3d_section_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine wall3d_section_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! wall3d_section_struct%ix_branch: 0D_NOT_integer

  subroutine wall3d_section_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine wall3d_section_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! wall3d_section_struct%vertices_state: 0D_NOT_integer

  subroutine wall3d_section_struct_get_vertices_state(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_vertices_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%vertices_state
  end subroutine


  subroutine wall3d_section_struct_set_vertices_state(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_vertices_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%vertices_state = value_in
  end subroutine

  ! wall3d_section_struct%patch_in_region: 0D_NOT_logical

  subroutine wall3d_section_struct_get_patch_in_region(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_patch_in_region')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%patch_in_region
  end subroutine


  subroutine wall3d_section_struct_set_patch_in_region(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_patch_in_region')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%patch_in_region = value_in
  end subroutine

  ! wall3d_section_struct%thickness: 0D_NOT_real

  subroutine wall3d_section_struct_get_thickness(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%thickness
  end subroutine


  subroutine wall3d_section_struct_set_thickness(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%thickness = value_in
  end subroutine

  ! wall3d_section_struct%s: 0D_NOT_real

  subroutine wall3d_section_struct_get_s(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine wall3d_section_struct_set_s(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! wall3d_section_struct%r0: 1D_NOT_real

  subroutine wall3d_section_struct_get_r0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_r0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%r0)) then
      data_ptr = c_loc(struct_obj%r0(lbound(struct_obj%r0, 1)))
      bounds(1) = int(lbound(struct_obj%r0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%dx0_ds: 0D_NOT_real

  subroutine wall3d_section_struct_get_dx0_ds(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_dx0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dx0_ds
  end subroutine


  subroutine wall3d_section_struct_set_dx0_ds(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_dx0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dx0_ds = value_in
  end subroutine

  ! wall3d_section_struct%dy0_ds: 0D_NOT_real

  subroutine wall3d_section_struct_get_dy0_ds(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_dy0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dy0_ds
  end subroutine


  subroutine wall3d_section_struct_set_dy0_ds(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_dy0_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dy0_ds = value_in
  end subroutine

  ! wall3d_section_struct%x0_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_x0_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_x0_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%x0_coef)) then
      data_ptr = c_loc(struct_obj%x0_coef(lbound(struct_obj%x0_coef, 1)))
      bounds(1) = int(lbound(struct_obj%x0_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x0_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%y0_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_y0_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_y0_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%y0_coef)) then
      data_ptr = c_loc(struct_obj%y0_coef(lbound(struct_obj%y0_coef, 1)))
      bounds(1) = int(lbound(struct_obj%y0_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y0_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%dr_ds: 0D_NOT_real

  subroutine wall3d_section_struct_get_dr_ds(struct_obj_ptr, value_out) bind(c, name='wall3d_section_struct_get_dr_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dr_ds
  end subroutine


  subroutine wall3d_section_struct_set_dr_ds(struct_obj_ptr, value_in) bind(c, name='wall3d_section_struct_set_dr_ds')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_section_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dr_ds = value_in
  end subroutine

  ! wall3d_section_struct%p1_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_p1_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_p1_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%p1_coef)) then
      data_ptr = c_loc(struct_obj%p1_coef(lbound(struct_obj%p1_coef, 1)))
      bounds(1) = int(lbound(struct_obj%p1_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p1_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! wall3d_section_struct%p2_coef: 1D_NOT_real

  subroutine wall3d_section_struct_get_p2_coef_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='wall3d_section_struct_get_p2_coef_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_section_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%p2_coef)) then
      data_ptr = c_loc(struct_obj%p2_coef(lbound(struct_obj%p2_coef, 1)))
      bounds(1) = int(lbound(struct_obj%p2_coef, 1), c_int)
      bounds(2) = int(ubound(struct_obj%p2_coef, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! wall3d_struct

    function allocate_fortran_wall3d_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(wall3d_struct), pointer :: fptr
    type(wall3d_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_wall3d_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(wall3d_struct), pointer :: fptr
    type(wall3d_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_wall3d_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(wall3d_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! wall3d_struct%name: 0D_NOT_character

  subroutine wall3d_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_struct%type: 0D_NOT_integer

  subroutine wall3d_struct_get_type(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%type
  end subroutine


  subroutine wall3d_struct_set_type(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%type = value_in
  end subroutine

  ! wall3d_struct%ix_wall3d: 0D_NOT_integer

  subroutine wall3d_struct_get_ix_wall3d(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_ix_wall3d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_wall3d
  end subroutine


  subroutine wall3d_struct_set_ix_wall3d(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_ix_wall3d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_wall3d = value_in
  end subroutine

  ! wall3d_struct%n_link: 0D_NOT_integer

  subroutine wall3d_struct_get_n_link(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_link
  end subroutine


  subroutine wall3d_struct_set_n_link(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_n_link')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_link = value_in
  end subroutine

  ! wall3d_struct%thickness: 0D_NOT_real

  subroutine wall3d_struct_get_thickness(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%thickness
  end subroutine


  subroutine wall3d_struct_set_thickness(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_thickness')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%thickness = value_in
  end subroutine

  ! wall3d_struct%clear_material: 0D_NOT_character

  subroutine wall3d_struct_get_clear_material_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_struct_get_clear_material_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%clear_material)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%clear_material), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_struct_set_clear_material(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_struct_set_clear_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%clear_material = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_struct%opaque_material: 0D_NOT_character

  subroutine wall3d_struct_get_opaque_material_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='wall3d_struct_get_opaque_material_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%opaque_material)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%opaque_material), c_int)
    is_allocated = .true.
  end subroutine


  subroutine wall3d_struct_set_opaque_material(struct_obj_ptr, str_ptr, str_len) bind(c, name='wall3d_struct_set_opaque_material')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(wall3d_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%opaque_material = str_in ! implicitly handles padding
  end subroutine

  ! wall3d_struct%superimpose: 0D_NOT_logical

  subroutine wall3d_struct_get_superimpose(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_superimpose')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%superimpose
  end subroutine


  subroutine wall3d_struct_set_superimpose(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_superimpose')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%superimpose = value_in
  end subroutine

  ! wall3d_struct%ele_anchor_pt: 0D_NOT_integer

  subroutine wall3d_struct_get_ele_anchor_pt(struct_obj_ptr, value_out) bind(c, name='wall3d_struct_get_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ele_anchor_pt
  end subroutine


  subroutine wall3d_struct_set_ele_anchor_pt(struct_obj_ptr, value_in) bind(c, name='wall3d_struct_set_ele_anchor_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(wall3d_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ele_anchor_pt = value_in
  end subroutine

  ! wall3d_struct%section: 1D_ALLOC_type

  subroutine wall3d_struct_get_section_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='wall3d_struct_get_section_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(wall3d_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%section) .and. is_contiguous(struct_obj%section)) then
      data_ptr = c_loc(struct_obj%section(lbound(struct_obj%section, 1)))
      bounds(1) = int(lbound(struct_obj%section, 1), c_int)
      bounds(2) = int(ubound(struct_obj%section, 1), c_int)
      
      el_size = int(storage_size(struct_obj%section(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! ramper_lord_struct

    function allocate_fortran_ramper_lord_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ramper_lord_struct), pointer :: fptr
    type(ramper_lord_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ramper_lord_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ramper_lord_struct), pointer :: fptr
    type(ramper_lord_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ramper_lord_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ramper_lord_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ramper_lord_struct%ix_ele: 0D_NOT_integer

  subroutine ramper_lord_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='ramper_lord_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine ramper_lord_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='ramper_lord_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! ramper_lord_struct%ix_con: 0D_NOT_integer

  subroutine ramper_lord_struct_get_ix_con(struct_obj_ptr, value_out) bind(c, name='ramper_lord_struct_get_ix_con')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_con
  end subroutine


  subroutine ramper_lord_struct_set_ix_con(struct_obj_ptr, value_in) bind(c, name='ramper_lord_struct_set_ix_con')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_con = value_in
  end subroutine

  ! ramper_lord_struct%attrib_ptr: 0D_PTR_real

  subroutine ramper_lord_struct_get_attrib_ptr(struct_obj_ptr, ptr_out) bind(c, name='ramper_lord_struct_get_attrib_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%attrib_ptr)) then
      ptr_out = c_loc(struct_obj%attrib_ptr)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ramper_lord_struct_set_attrib_ptr(struct_obj_ptr, value_in) bind(c, name='ramper_lord_struct_set_attrib_ptr')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ramper_lord_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%attrib_ptr)) then
      struct_obj%attrib_ptr = value_in
    endif
  end subroutine

  !! control_struct

    function allocate_fortran_control_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(control_struct), pointer :: fptr
    type(control_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_control_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(control_struct), pointer :: fptr
    type(control_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_control_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(control_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! control_struct%value: 0D_NOT_real

  subroutine control_struct_get_value(struct_obj_ptr, value_out) bind(c, name='control_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine control_struct_set_value(struct_obj_ptr, value_in) bind(c, name='control_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  ! control_struct%y_knot: 1D_ALLOC_real

  subroutine control_struct_get_y_knot_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='control_struct_get_y_knot_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%y_knot) .and. is_contiguous(struct_obj%y_knot)) then
      data_ptr = c_loc(struct_obj%y_knot(lbound(struct_obj%y_knot, 1)))
      bounds(1) = int(lbound(struct_obj%y_knot, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y_knot, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! control_struct%stack: 1D_ALLOC_type

  subroutine control_struct_get_stack_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='control_struct_get_stack_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%stack) .and. is_contiguous(struct_obj%stack)) then
      data_ptr = c_loc(struct_obj%stack(lbound(struct_obj%stack, 1)))
      bounds(1) = int(lbound(struct_obj%stack, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stack, 1), c_int)
      
      el_size = int(storage_size(struct_obj%stack(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! control_struct%slave: 0D_NOT_type

  subroutine control_struct_get_slave(struct_obj_ptr, ptr_out) bind(c, name='control_struct_get_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%slave)
  end subroutine


  subroutine control_struct_set_slave(struct_obj_ptr, src_ptr) bind(c, name='control_struct_set_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(control_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%slave = src_obj
  end subroutine

  ! control_struct%lord: 0D_NOT_type

  subroutine control_struct_get_lord(struct_obj_ptr, ptr_out) bind(c, name='control_struct_get_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lord)
  end subroutine


  subroutine control_struct_set_lord(struct_obj_ptr, src_ptr) bind(c, name='control_struct_set_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(control_struct), pointer :: struct_obj
    type(lat_ele_loc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lord = src_obj
  end subroutine

  ! control_struct%slave_name: 0D_NOT_character

  subroutine control_struct_get_slave_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_struct_get_slave_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%slave_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%slave_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_struct_set_slave_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_struct_set_slave_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%slave_name = str_in ! implicitly handles padding
  end subroutine

  ! control_struct%attribute: 0D_NOT_character

  subroutine control_struct_get_attribute_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_struct_get_attribute_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%attribute)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%attribute), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_struct_set_attribute(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_struct_set_attribute')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%attribute = str_in ! implicitly handles padding
  end subroutine

  ! control_struct%ix_attrib: 0D_NOT_integer

  subroutine control_struct_get_ix_attrib(struct_obj_ptr, value_out) bind(c, name='control_struct_get_ix_attrib')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_attrib
  end subroutine


  subroutine control_struct_set_ix_attrib(struct_obj_ptr, value_in) bind(c, name='control_struct_set_ix_attrib')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(control_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_attrib = value_in
  end subroutine

  !! control_var1_struct

    function allocate_fortran_control_var1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(control_var1_struct), pointer :: fptr
    type(control_var1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_control_var1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(control_var1_struct), pointer :: fptr
    type(control_var1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_control_var1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(control_var1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! control_var1_struct%name: 0D_NOT_character

  subroutine control_var1_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_var1_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_var1_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_var1_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_var1_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! control_var1_struct%value: 0D_NOT_real

  subroutine control_var1_struct_get_value(struct_obj_ptr, value_out) bind(c, name='control_var1_struct_get_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%value
  end subroutine


  subroutine control_var1_struct_set_value(struct_obj_ptr, value_in) bind(c, name='control_var1_struct_set_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%value = value_in
  end subroutine

  ! control_var1_struct%old_value: 0D_NOT_real

  subroutine control_var1_struct_get_old_value(struct_obj_ptr, value_out) bind(c, name='control_var1_struct_get_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%old_value
  end subroutine


  subroutine control_var1_struct_set_old_value(struct_obj_ptr, value_in) bind(c, name='control_var1_struct_set_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(control_var1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%old_value = value_in
  end subroutine

  !! control_ramp1_struct

    function allocate_fortran_control_ramp1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(control_ramp1_struct), pointer :: fptr
    type(control_ramp1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_control_ramp1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(control_ramp1_struct), pointer :: fptr
    type(control_ramp1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_control_ramp1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(control_ramp1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! control_ramp1_struct%y_knot: 1D_ALLOC_real

  subroutine control_ramp1_struct_get_y_knot_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='control_ramp1_struct_get_y_knot_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%y_knot) .and. is_contiguous(struct_obj%y_knot)) then
      data_ptr = c_loc(struct_obj%y_knot(lbound(struct_obj%y_knot, 1)))
      bounds(1) = int(lbound(struct_obj%y_knot, 1), c_int)
      bounds(2) = int(ubound(struct_obj%y_knot, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! control_ramp1_struct%stack: 1D_ALLOC_type

  subroutine control_ramp1_struct_get_stack_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='control_ramp1_struct_get_stack_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%stack) .and. is_contiguous(struct_obj%stack)) then
      data_ptr = c_loc(struct_obj%stack(lbound(struct_obj%stack, 1)))
      bounds(1) = int(lbound(struct_obj%stack, 1), c_int)
      bounds(2) = int(ubound(struct_obj%stack, 1), c_int)
      
      el_size = int(storage_size(struct_obj%stack(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! control_ramp1_struct%attribute: 0D_NOT_character

  subroutine control_ramp1_struct_get_attribute_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_ramp1_struct_get_attribute_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%attribute)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%attribute), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_ramp1_struct_set_attribute(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_ramp1_struct_set_attribute')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_ramp1_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%attribute = str_in ! implicitly handles padding
  end subroutine

  ! control_ramp1_struct%slave_name: 0D_NOT_character

  subroutine control_ramp1_struct_get_slave_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='control_ramp1_struct_get_slave_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%slave_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%slave_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine control_ramp1_struct_set_slave_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='control_ramp1_struct_set_slave_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(control_ramp1_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%slave_name = str_in ! implicitly handles padding
  end subroutine

  ! control_ramp1_struct%is_controller: 0D_NOT_logical

  subroutine control_ramp1_struct_get_is_controller(struct_obj_ptr, value_out) bind(c, name='control_ramp1_struct_get_is_controller')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_controller
  end subroutine


  subroutine control_ramp1_struct_set_is_controller(struct_obj_ptr, value_in) bind(c, name='control_ramp1_struct_set_is_controller')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(control_ramp1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_controller = value_in
  end subroutine

  !! controller_struct

    function allocate_fortran_controller_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(controller_struct), pointer :: fptr
    type(controller_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_controller_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(controller_struct), pointer :: fptr
    type(controller_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_controller_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(controller_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! controller_struct%var: 1D_ALLOC_type

  subroutine controller_struct_get_var_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='controller_struct_get_var_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%var) .and. is_contiguous(struct_obj%var)) then
      data_ptr = c_loc(struct_obj%var(lbound(struct_obj%var, 1)))
      bounds(1) = int(lbound(struct_obj%var, 1), c_int)
      bounds(2) = int(ubound(struct_obj%var, 1), c_int)
      
      el_size = int(storage_size(struct_obj%var(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! controller_struct%ramp: 1D_ALLOC_type

  subroutine controller_struct_get_ramp_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='controller_struct_get_ramp_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ramp) .and. is_contiguous(struct_obj%ramp)) then
      data_ptr = c_loc(struct_obj%ramp(lbound(struct_obj%ramp, 1)))
      bounds(1) = int(lbound(struct_obj%ramp, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ramp, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ramp(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! controller_struct%ramper_lord: 1D_ALLOC_type

  subroutine controller_struct_get_ramper_lord_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='controller_struct_get_ramper_lord_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ramper_lord) .and. is_contiguous(struct_obj%ramper_lord)) then
      data_ptr = c_loc(struct_obj%ramper_lord(lbound(struct_obj%ramper_lord, 1)))
      bounds(1) = int(lbound(struct_obj%ramper_lord, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ramper_lord, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ramper_lord(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! controller_struct%x_knot: 1D_ALLOC_real

  subroutine controller_struct_get_x_knot_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='controller_struct_get_x_knot_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(controller_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%x_knot) .and. is_contiguous(struct_obj%x_knot)) then
      data_ptr = c_loc(struct_obj%x_knot(lbound(struct_obj%x_knot, 1)))
      bounds(1) = int(lbound(struct_obj%x_knot, 1), c_int)
      bounds(2) = int(ubound(struct_obj%x_knot, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! ellipse_beam_init_struct

    function allocate_fortran_ellipse_beam_init_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ellipse_beam_init_struct), pointer :: fptr
    type(ellipse_beam_init_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ellipse_beam_init_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ellipse_beam_init_struct), pointer :: fptr
    type(ellipse_beam_init_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ellipse_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ellipse_beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ellipse_beam_init_struct%part_per_ellipse: 0D_NOT_integer

  subroutine ellipse_beam_init_struct_get_part_per_ellipse(struct_obj_ptr, value_out) bind(c, name='ellipse_beam_init_struct_get_part_per_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%part_per_ellipse
  end subroutine


  subroutine ellipse_beam_init_struct_set_part_per_ellipse(struct_obj_ptr, value_in) bind(c, name='ellipse_beam_init_struct_set_part_per_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%part_per_ellipse = value_in
  end subroutine

  ! ellipse_beam_init_struct%n_ellipse: 0D_NOT_integer

  subroutine ellipse_beam_init_struct_get_n_ellipse(struct_obj_ptr, value_out) bind(c, name='ellipse_beam_init_struct_get_n_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ellipse
  end subroutine


  subroutine ellipse_beam_init_struct_set_n_ellipse(struct_obj_ptr, value_in) bind(c, name='ellipse_beam_init_struct_set_n_ellipse')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ellipse = value_in
  end subroutine

  ! ellipse_beam_init_struct%sigma_cutoff: 0D_NOT_real

  subroutine ellipse_beam_init_struct_get_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='ellipse_beam_init_struct_get_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_cutoff
  end subroutine


  subroutine ellipse_beam_init_struct_set_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='ellipse_beam_init_struct_set_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ellipse_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_cutoff = value_in
  end subroutine

  !! kv_beam_init_struct

    function allocate_fortran_kv_beam_init_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(kv_beam_init_struct), pointer :: fptr
    type(kv_beam_init_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_kv_beam_init_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(kv_beam_init_struct), pointer :: fptr
    type(kv_beam_init_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_kv_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(kv_beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! kv_beam_init_struct%part_per_phi: 1D_NOT_integer

  subroutine kv_beam_init_struct_get_part_per_phi_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='kv_beam_init_struct_get_part_per_phi_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(kv_beam_init_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%part_per_phi)) then
      data_ptr = c_loc(struct_obj%part_per_phi(lbound(struct_obj%part_per_phi, 1)))
      bounds(1) = int(lbound(struct_obj%part_per_phi, 1), c_int)
      bounds(2) = int(ubound(struct_obj%part_per_phi, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! kv_beam_init_struct%n_I2: 0D_NOT_integer

  subroutine kv_beam_init_struct_get_n_I2(struct_obj_ptr, value_out) bind(c, name='kv_beam_init_struct_get_n_I2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_I2
  end subroutine


  subroutine kv_beam_init_struct_set_n_I2(struct_obj_ptr, value_in) bind(c, name='kv_beam_init_struct_set_n_I2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_I2 = value_in
  end subroutine

  ! kv_beam_init_struct%A: 0D_NOT_real

  subroutine kv_beam_init_struct_get_A(struct_obj_ptr, value_out) bind(c, name='kv_beam_init_struct_get_A')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%A
  end subroutine


  subroutine kv_beam_init_struct_set_A(struct_obj_ptr, value_in) bind(c, name='kv_beam_init_struct_set_A')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(kv_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%A = value_in
  end subroutine

  !! grid_beam_init_struct

    function allocate_fortran_grid_beam_init_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(grid_beam_init_struct), pointer :: fptr
    type(grid_beam_init_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_grid_beam_init_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(grid_beam_init_struct), pointer :: fptr
    type(grid_beam_init_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_grid_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(grid_beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! grid_beam_init_struct%n_x: 0D_NOT_integer

  subroutine grid_beam_init_struct_get_n_x(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_n_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_x
  end subroutine


  subroutine grid_beam_init_struct_set_n_x(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_n_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_x = value_in
  end subroutine

  ! grid_beam_init_struct%n_px: 0D_NOT_integer

  subroutine grid_beam_init_struct_get_n_px(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_n_px')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_px
  end subroutine


  subroutine grid_beam_init_struct_set_n_px(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_n_px')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_px = value_in
  end subroutine

  ! grid_beam_init_struct%x_min: 0D_NOT_real

  subroutine grid_beam_init_struct_get_x_min(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_min
  end subroutine


  subroutine grid_beam_init_struct_set_x_min(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_min = value_in
  end subroutine

  ! grid_beam_init_struct%x_max: 0D_NOT_real

  subroutine grid_beam_init_struct_get_x_max(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_max
  end subroutine


  subroutine grid_beam_init_struct_set_x_max(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_max = value_in
  end subroutine

  ! grid_beam_init_struct%px_min: 0D_NOT_real

  subroutine grid_beam_init_struct_get_px_min(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_px_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%px_min
  end subroutine


  subroutine grid_beam_init_struct_set_px_min(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_px_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%px_min = value_in
  end subroutine

  ! grid_beam_init_struct%px_max: 0D_NOT_real

  subroutine grid_beam_init_struct_get_px_max(struct_obj_ptr, value_out) bind(c, name='grid_beam_init_struct_get_px_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%px_max
  end subroutine


  subroutine grid_beam_init_struct_set_px_max(struct_obj_ptr, value_in) bind(c, name='grid_beam_init_struct_set_px_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(grid_beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%px_max = value_in
  end subroutine

  !! beam_init_struct

    function allocate_fortran_beam_init_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(beam_init_struct), pointer :: fptr
    type(beam_init_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_beam_init_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(beam_init_struct), pointer :: fptr
    type(beam_init_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_beam_init_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(beam_init_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! beam_init_struct%position_file: 0D_NOT_character

  subroutine beam_init_struct_get_position_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_position_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%position_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%position_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_position_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_position_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%position_file = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%distribution_type: 1D_NOT_character

  subroutine beam_init_struct_get_distribution_type_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='beam_init_struct_get_distribution_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true.) then
      data_ptr = c_loc(struct_obj%distribution_type(lbound(struct_obj%distribution_type, 1)))
      bounds(1) = int(lbound(struct_obj%distribution_type, 1), c_int)
      bounds(2) = int(ubound(struct_obj%distribution_type, 1), c_int)
      str_len = int(len(struct_obj%distribution_type), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%spin: 1D_NOT_real

  subroutine beam_init_struct_get_spin_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_spin_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin)) then
      data_ptr = c_loc(struct_obj%spin(lbound(struct_obj%spin, 1)))
      bounds(1) = int(lbound(struct_obj%spin, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%ellipse: 1D_NOT_type

  subroutine beam_init_struct_get_ellipse_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='beam_init_struct_get_ellipse_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%ellipse)) then
      data_ptr = c_loc(struct_obj%ellipse(lbound(struct_obj%ellipse, 1)))
      bounds(1) = int(lbound(struct_obj%ellipse, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ellipse, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ellipse(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%KV: 0D_NOT_type

  subroutine beam_init_struct_get_KV(struct_obj_ptr, ptr_out) bind(c, name='beam_init_struct_get_KV')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%KV)
  end subroutine


  subroutine beam_init_struct_set_KV(struct_obj_ptr, src_ptr) bind(c, name='beam_init_struct_set_KV')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(beam_init_struct), pointer :: struct_obj
    type(kv_beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%KV = src_obj
  end subroutine

  ! beam_init_struct%grid: 1D_NOT_type

  subroutine beam_init_struct_get_grid_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='beam_init_struct_get_grid_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%grid)) then
      data_ptr = c_loc(struct_obj%grid(lbound(struct_obj%grid, 1)))
      bounds(1) = int(lbound(struct_obj%grid, 1), c_int)
      bounds(2) = int(ubound(struct_obj%grid, 1), c_int)
      
      el_size = int(storage_size(struct_obj%grid(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%center_jitter: 1D_NOT_real

  subroutine beam_init_struct_get_center_jitter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_center_jitter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%center_jitter)) then
      data_ptr = c_loc(struct_obj%center_jitter(lbound(struct_obj%center_jitter, 1)))
      bounds(1) = int(lbound(struct_obj%center_jitter, 1), c_int)
      bounds(2) = int(ubound(struct_obj%center_jitter, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%emit_jitter: 1D_NOT_real

  subroutine beam_init_struct_get_emit_jitter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_emit_jitter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%emit_jitter)) then
      data_ptr = c_loc(struct_obj%emit_jitter(lbound(struct_obj%emit_jitter, 1)))
      bounds(1) = int(lbound(struct_obj%emit_jitter, 1), c_int)
      bounds(2) = int(ubound(struct_obj%emit_jitter, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%sig_z_jitter: 0D_NOT_real

  subroutine beam_init_struct_get_sig_z_jitter(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_z_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z_jitter
  end subroutine


  subroutine beam_init_struct_set_sig_z_jitter(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_z_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z_jitter = value_in
  end subroutine

  ! beam_init_struct%sig_pz_jitter: 0D_NOT_real

  subroutine beam_init_struct_get_sig_pz_jitter(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_pz_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_pz_jitter
  end subroutine


  subroutine beam_init_struct_set_sig_pz_jitter(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_pz_jitter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_pz_jitter = value_in
  end subroutine

  ! beam_init_struct%n_particle: 0D_NOT_integer

  subroutine beam_init_struct_get_n_particle(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_n_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle
  end subroutine


  subroutine beam_init_struct_set_n_particle(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_n_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle = value_in
  end subroutine

  ! beam_init_struct%renorm_center: 0D_NOT_logical

  subroutine beam_init_struct_get_renorm_center(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_renorm_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%renorm_center
  end subroutine


  subroutine beam_init_struct_set_renorm_center(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_renorm_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%renorm_center = value_in
  end subroutine

  ! beam_init_struct%renorm_sigma: 0D_NOT_logical

  subroutine beam_init_struct_get_renorm_sigma(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_renorm_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%renorm_sigma
  end subroutine


  subroutine beam_init_struct_set_renorm_sigma(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_renorm_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%renorm_sigma = value_in
  end subroutine

  ! beam_init_struct%random_engine: 0D_NOT_character

  subroutine beam_init_struct_get_random_engine_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_random_engine_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%random_engine)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%random_engine), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_random_engine(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_random_engine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%random_engine = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%random_gauss_converter: 0D_NOT_character

  subroutine beam_init_struct_get_random_gauss_converter_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_random_gauss_converter_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%random_gauss_converter)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%random_gauss_converter), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_random_gauss_converter(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_random_gauss_converter')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%random_gauss_converter = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%random_sigma_cutoff: 0D_NOT_real

  subroutine beam_init_struct_get_random_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_random_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%random_sigma_cutoff
  end subroutine


  subroutine beam_init_struct_set_random_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_random_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%random_sigma_cutoff = value_in
  end subroutine

  ! beam_init_struct%a_norm_emit: 0D_NOT_real

  subroutine beam_init_struct_get_a_norm_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_a_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_norm_emit
  end subroutine


  subroutine beam_init_struct_set_a_norm_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_a_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_norm_emit = value_in
  end subroutine

  ! beam_init_struct%b_norm_emit: 0D_NOT_real

  subroutine beam_init_struct_get_b_norm_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_b_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_norm_emit
  end subroutine


  subroutine beam_init_struct_set_b_norm_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_b_norm_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_norm_emit = value_in
  end subroutine

  ! beam_init_struct%a_emit: 0D_NOT_real

  subroutine beam_init_struct_get_a_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_emit
  end subroutine


  subroutine beam_init_struct_set_a_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_emit = value_in
  end subroutine

  ! beam_init_struct%b_emit: 0D_NOT_real

  subroutine beam_init_struct_get_b_emit(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_emit
  end subroutine


  subroutine beam_init_struct_set_b_emit(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_emit = value_in
  end subroutine

  ! beam_init_struct%dPz_dz: 0D_NOT_real

  subroutine beam_init_struct_get_dPz_dz(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_dPz_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dPz_dz
  end subroutine


  subroutine beam_init_struct_set_dPz_dz(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_dPz_dz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dPz_dz = value_in
  end subroutine

  ! beam_init_struct%center: 1D_NOT_real

  subroutine beam_init_struct_get_center_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='beam_init_struct_get_center_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%center)) then
      data_ptr = c_loc(struct_obj%center(lbound(struct_obj%center, 1)))
      bounds(1) = int(lbound(struct_obj%center, 1), c_int)
      bounds(2) = int(ubound(struct_obj%center, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! beam_init_struct%t_offset: 0D_NOT_real

  subroutine beam_init_struct_get_t_offset(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_t_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_offset
  end subroutine


  subroutine beam_init_struct_set_t_offset(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_t_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_offset = value_in
  end subroutine

  ! beam_init_struct%dt_bunch: 0D_NOT_real

  subroutine beam_init_struct_get_dt_bunch(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_dt_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dt_bunch
  end subroutine


  subroutine beam_init_struct_set_dt_bunch(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_dt_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dt_bunch = value_in
  end subroutine

  ! beam_init_struct%sig_z: 0D_NOT_real

  subroutine beam_init_struct_get_sig_z(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z
  end subroutine


  subroutine beam_init_struct_set_sig_z(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z = value_in
  end subroutine

  ! beam_init_struct%sig_pz: 0D_NOT_real

  subroutine beam_init_struct_get_sig_pz(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_sig_pz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_pz
  end subroutine


  subroutine beam_init_struct_set_sig_pz(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_sig_pz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_pz = value_in
  end subroutine

  ! beam_init_struct%bunch_charge: 0D_NOT_real

  subroutine beam_init_struct_get_bunch_charge(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_bunch_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bunch_charge
  end subroutine


  subroutine beam_init_struct_set_bunch_charge(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_bunch_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bunch_charge = value_in
  end subroutine

  ! beam_init_struct%n_bunch: 0D_NOT_integer

  subroutine beam_init_struct_get_n_bunch(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_n_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bunch
  end subroutine


  subroutine beam_init_struct_set_n_bunch(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_n_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bunch = value_in
  end subroutine

  ! beam_init_struct%ix_turn: 0D_NOT_integer

  subroutine beam_init_struct_get_ix_turn(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_turn
  end subroutine


  subroutine beam_init_struct_set_ix_turn(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_turn = value_in
  end subroutine

  ! beam_init_struct%species: 0D_NOT_character

  subroutine beam_init_struct_get_species_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_species_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%species)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%species), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_species(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%species = str_in ! implicitly handles padding
  end subroutine

  ! beam_init_struct%full_6D_coupling_calc: 0D_NOT_logical

  subroutine beam_init_struct_get_full_6D_coupling_calc(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_full_6D_coupling_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%full_6D_coupling_calc
  end subroutine


  subroutine beam_init_struct_set_full_6D_coupling_calc(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_full_6D_coupling_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%full_6D_coupling_calc = value_in
  end subroutine

  ! beam_init_struct%use_particle_start: 0D_NOT_logical

  subroutine beam_init_struct_get_use_particle_start(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_use_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_particle_start
  end subroutine


  subroutine beam_init_struct_set_use_particle_start(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_use_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_particle_start = value_in
  end subroutine

  ! beam_init_struct%use_t_coords: 0D_NOT_logical

  subroutine beam_init_struct_get_use_t_coords(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_use_t_coords')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_t_coords
  end subroutine


  subroutine beam_init_struct_set_use_t_coords(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_use_t_coords')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_t_coords = value_in
  end subroutine

  ! beam_init_struct%use_z_as_t: 0D_NOT_logical

  subroutine beam_init_struct_get_use_z_as_t(struct_obj_ptr, value_out) bind(c, name='beam_init_struct_get_use_z_as_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%use_z_as_t
  end subroutine


  subroutine beam_init_struct_set_use_z_as_t(struct_obj_ptr, value_in) bind(c, name='beam_init_struct_set_use_z_as_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%use_z_as_t = value_in
  end subroutine

  ! beam_init_struct%file_name: 0D_NOT_character

  subroutine beam_init_struct_get_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='beam_init_struct_get_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_init_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine beam_init_struct_set_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='beam_init_struct_set_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(beam_init_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%file_name = str_in ! implicitly handles padding
  end subroutine

  !! lat_param_struct

    function allocate_fortran_lat_param_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(lat_param_struct), pointer :: fptr
    type(lat_param_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_lat_param_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(lat_param_struct), pointer :: fptr
    type(lat_param_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_lat_param_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_param_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! lat_param_struct%n_part: 0D_NOT_real

  subroutine lat_param_struct_get_n_part(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_n_part')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_part
  end subroutine


  subroutine lat_param_struct_set_n_part(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_n_part')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_part = value_in
  end subroutine

  ! lat_param_struct%total_length: 0D_NOT_real

  subroutine lat_param_struct_get_total_length(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_total_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%total_length
  end subroutine


  subroutine lat_param_struct_set_total_length(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_total_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%total_length = value_in
  end subroutine

  ! lat_param_struct%unstable_factor: 0D_NOT_real

  subroutine lat_param_struct_get_unstable_factor(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_unstable_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%unstable_factor
  end subroutine


  subroutine lat_param_struct_set_unstable_factor(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_unstable_factor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%unstable_factor = value_in
  end subroutine

  ! lat_param_struct%t1_with_RF: 2D_NOT_real

  subroutine lat_param_struct_get_t1_with_RF_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='lat_param_struct_get_t1_with_RF_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_param_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%t1_with_RF)) then
      data_ptr = c_loc(struct_obj%t1_with_RF(lbound(struct_obj%t1_with_RF, 1), lbound(struct_obj%t1_with_RF, 2)))
      bounds(1) = int(lbound(struct_obj%t1_with_RF, 1), c_int)
      bounds(2) = int(ubound(struct_obj%t1_with_RF, 1), c_int)
      bounds(3) = int(lbound(struct_obj%t1_with_RF, 2), c_int)
      bounds(4) = int(ubound(struct_obj%t1_with_RF, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_param_struct%t1_no_RF: 2D_NOT_real

  subroutine lat_param_struct_get_t1_no_RF_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='lat_param_struct_get_t1_no_RF_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_param_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%t1_no_RF)) then
      data_ptr = c_loc(struct_obj%t1_no_RF(lbound(struct_obj%t1_no_RF, 1), lbound(struct_obj%t1_no_RF, 2)))
      bounds(1) = int(lbound(struct_obj%t1_no_RF, 1), c_int)
      bounds(2) = int(ubound(struct_obj%t1_no_RF, 1), c_int)
      bounds(3) = int(lbound(struct_obj%t1_no_RF, 2), c_int)
      bounds(4) = int(ubound(struct_obj%t1_no_RF, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_param_struct%spin_tune: 0D_NOT_real

  subroutine lat_param_struct_get_spin_tune(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_spin_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_tune
  end subroutine


  subroutine lat_param_struct_set_spin_tune(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_spin_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_tune = value_in
  end subroutine

  ! lat_param_struct%particle: 0D_NOT_integer

  subroutine lat_param_struct_get_particle(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle
  end subroutine


  subroutine lat_param_struct_set_particle(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_particle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle = value_in
  end subroutine

  ! lat_param_struct%default_tracking_species: 0D_NOT_integer

  subroutine lat_param_struct_get_default_tracking_species(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_default_tracking_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_tracking_species
  end subroutine


  subroutine lat_param_struct_set_default_tracking_species(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_default_tracking_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_tracking_species = value_in
  end subroutine

  ! lat_param_struct%geometry: 0D_NOT_integer

  subroutine lat_param_struct_get_geometry(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%geometry
  end subroutine


  subroutine lat_param_struct_set_geometry(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_geometry')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%geometry = value_in
  end subroutine

  ! lat_param_struct%ixx: 0D_NOT_integer

  subroutine lat_param_struct_get_ixx(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ixx
  end subroutine


  subroutine lat_param_struct_set_ixx(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ixx = value_in
  end subroutine

  ! lat_param_struct%stable: 0D_NOT_logical

  subroutine lat_param_struct_get_stable(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stable
  end subroutine


  subroutine lat_param_struct_set_stable(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stable = value_in
  end subroutine

  ! lat_param_struct%live_branch: 0D_NOT_logical

  subroutine lat_param_struct_get_live_branch(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_live_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%live_branch
  end subroutine


  subroutine lat_param_struct_set_live_branch(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_live_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%live_branch = value_in
  end subroutine

  ! lat_param_struct%g1_integral: 0D_NOT_real

  subroutine lat_param_struct_get_g1_integral(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_g1_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%g1_integral
  end subroutine


  subroutine lat_param_struct_set_g1_integral(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_g1_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%g1_integral = value_in
  end subroutine

  ! lat_param_struct%g2_integral: 0D_NOT_real

  subroutine lat_param_struct_get_g2_integral(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_g2_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%g2_integral
  end subroutine


  subroutine lat_param_struct_set_g2_integral(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_g2_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%g2_integral = value_in
  end subroutine

  ! lat_param_struct%g3_integral: 0D_NOT_real

  subroutine lat_param_struct_get_g3_integral(struct_obj_ptr, value_out) bind(c, name='lat_param_struct_get_g3_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%g3_integral
  end subroutine


  subroutine lat_param_struct_set_g3_integral(struct_obj_ptr, value_in) bind(c, name='lat_param_struct_set_g3_integral')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%g3_integral = value_in
  end subroutine

  ! lat_param_struct%bookkeeping_state: 0D_NOT_type

  subroutine lat_param_struct_get_bookkeeping_state(struct_obj_ptr, ptr_out) bind(c, name='lat_param_struct_get_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%bookkeeping_state)
  end subroutine


  subroutine lat_param_struct_set_bookkeeping_state(struct_obj_ptr, src_ptr) bind(c, name='lat_param_struct_set_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_param_struct), pointer :: struct_obj
    type(bookkeeping_state_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%bookkeeping_state = src_obj
  end subroutine

  ! lat_param_struct%beam_init: 0D_NOT_type

  subroutine lat_param_struct_get_beam_init(struct_obj_ptr, ptr_out) bind(c, name='lat_param_struct_get_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init)
  end subroutine


  subroutine lat_param_struct_set_beam_init(struct_obj_ptr, src_ptr) bind(c, name='lat_param_struct_set_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_param_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init = src_obj
  end subroutine

  !! mode_info_struct

    function allocate_fortran_mode_info_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(mode_info_struct), pointer :: fptr
    type(mode_info_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_mode_info_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(mode_info_struct), pointer :: fptr
    type(mode_info_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_mode_info_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(mode_info_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! mode_info_struct%stable: 0D_NOT_logical

  subroutine mode_info_struct_get_stable(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%stable
  end subroutine


  subroutine mode_info_struct_set_stable(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_stable')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%stable = value_in
  end subroutine

  ! mode_info_struct%tune: 0D_NOT_real

  subroutine mode_info_struct_get_tune(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tune
  end subroutine


  subroutine mode_info_struct_set_tune(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tune = value_in
  end subroutine

  ! mode_info_struct%emit: 0D_NOT_real

  subroutine mode_info_struct_get_emit(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emit
  end subroutine


  subroutine mode_info_struct_set_emit(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emit = value_in
  end subroutine

  ! mode_info_struct%chrom: 0D_NOT_real

  subroutine mode_info_struct_get_chrom(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom
  end subroutine


  subroutine mode_info_struct_set_chrom(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom = value_in
  end subroutine

  ! mode_info_struct%sigma: 0D_NOT_real

  subroutine mode_info_struct_get_sigma(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma
  end subroutine


  subroutine mode_info_struct_set_sigma(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma = value_in
  end subroutine

  ! mode_info_struct%sigmap: 0D_NOT_real

  subroutine mode_info_struct_get_sigmap(struct_obj_ptr, value_out) bind(c, name='mode_info_struct_get_sigmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigmap
  end subroutine


  subroutine mode_info_struct_set_sigmap(struct_obj_ptr, value_in) bind(c, name='mode_info_struct_set_sigmap')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(mode_info_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigmap = value_in
  end subroutine

  !! pre_tracker_struct

    function allocate_fortran_pre_tracker_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(pre_tracker_struct), pointer :: fptr
    type(pre_tracker_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_pre_tracker_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(pre_tracker_struct), pointer :: fptr
    type(pre_tracker_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_pre_tracker_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(pre_tracker_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! pre_tracker_struct%who: 0D_NOT_integer

  subroutine pre_tracker_struct_get_who(struct_obj_ptr, value_out) bind(c, name='pre_tracker_struct_get_who')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%who
  end subroutine


  subroutine pre_tracker_struct_set_who(struct_obj_ptr, value_in) bind(c, name='pre_tracker_struct_set_who')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%who = value_in
  end subroutine

  ! pre_tracker_struct%ix_ele_start: 0D_NOT_integer

  subroutine pre_tracker_struct_get_ix_ele_start(struct_obj_ptr, value_out) bind(c, name='pre_tracker_struct_get_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_start
  end subroutine


  subroutine pre_tracker_struct_set_ix_ele_start(struct_obj_ptr, value_in) bind(c, name='pre_tracker_struct_set_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_start = value_in
  end subroutine

  ! pre_tracker_struct%ix_ele_end: 0D_NOT_integer

  subroutine pre_tracker_struct_get_ix_ele_end(struct_obj_ptr, value_out) bind(c, name='pre_tracker_struct_get_ix_ele_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_end
  end subroutine


  subroutine pre_tracker_struct_set_ix_ele_end(struct_obj_ptr, value_in) bind(c, name='pre_tracker_struct_set_ix_ele_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_end = value_in
  end subroutine

  ! pre_tracker_struct%input_file: 0D_NOT_character

  subroutine pre_tracker_struct_get_input_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='pre_tracker_struct_get_input_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(pre_tracker_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%input_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%input_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine pre_tracker_struct_set_input_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='pre_tracker_struct_set_input_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(pre_tracker_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%input_file = str_in ! implicitly handles padding
  end subroutine

  !! anormal_mode_struct

    function allocate_fortran_anormal_mode_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(anormal_mode_struct), pointer :: fptr
    type(anormal_mode_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_anormal_mode_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(anormal_mode_struct), pointer :: fptr
    type(anormal_mode_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_anormal_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(anormal_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! anormal_mode_struct%emittance: 0D_NOT_real

  subroutine anormal_mode_struct_get_emittance(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_emittance')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emittance
  end subroutine


  subroutine anormal_mode_struct_set_emittance(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_emittance')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emittance = value_in
  end subroutine

  ! anormal_mode_struct%emittance_no_vert: 0D_NOT_real

  subroutine anormal_mode_struct_get_emittance_no_vert(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_emittance_no_vert')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emittance_no_vert
  end subroutine


  subroutine anormal_mode_struct_set_emittance_no_vert(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_emittance_no_vert')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emittance_no_vert = value_in
  end subroutine

  ! anormal_mode_struct%synch_int: 1D_NOT_real

  subroutine anormal_mode_struct_get_synch_int_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='anormal_mode_struct_get_synch_int_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(anormal_mode_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%synch_int)) then
      data_ptr = c_loc(struct_obj%synch_int(lbound(struct_obj%synch_int, 1)))
      bounds(1) = int(lbound(struct_obj%synch_int, 1), c_int)
      bounds(2) = int(ubound(struct_obj%synch_int, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! anormal_mode_struct%j_damp: 0D_NOT_real

  subroutine anormal_mode_struct_get_j_damp(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_j_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%j_damp
  end subroutine


  subroutine anormal_mode_struct_set_j_damp(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_j_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%j_damp = value_in
  end subroutine

  ! anormal_mode_struct%alpha_damp: 0D_NOT_real

  subroutine anormal_mode_struct_get_alpha_damp(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_alpha_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%alpha_damp
  end subroutine


  subroutine anormal_mode_struct_set_alpha_damp(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_alpha_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%alpha_damp = value_in
  end subroutine

  ! anormal_mode_struct%chrom: 0D_NOT_real

  subroutine anormal_mode_struct_get_chrom(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom
  end subroutine


  subroutine anormal_mode_struct_set_chrom(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_chrom')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom = value_in
  end subroutine

  ! anormal_mode_struct%tune: 0D_NOT_real

  subroutine anormal_mode_struct_get_tune(struct_obj_ptr, value_out) bind(c, name='anormal_mode_struct_get_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tune
  end subroutine


  subroutine anormal_mode_struct_set_tune(struct_obj_ptr, value_in) bind(c, name='anormal_mode_struct_set_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(anormal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tune = value_in
  end subroutine

  !! linac_normal_mode_struct

    function allocate_fortran_linac_normal_mode_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(linac_normal_mode_struct), pointer :: fptr
    type(linac_normal_mode_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_linac_normal_mode_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(linac_normal_mode_struct), pointer :: fptr
    type(linac_normal_mode_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_linac_normal_mode_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(linac_normal_mode_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! linac_normal_mode_struct%i2_E4: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i2_E4(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i2_E4
  end subroutine


  subroutine linac_normal_mode_struct_set_i2_E4(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i2_E4 = value_in
  end subroutine

  ! linac_normal_mode_struct%i3_E7: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i3_E7(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i3_E7
  end subroutine


  subroutine linac_normal_mode_struct_set_i3_E7(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i3_E7 = value_in
  end subroutine

  ! linac_normal_mode_struct%i5a_E6: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i5a_E6(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5a_E6
  end subroutine


  subroutine linac_normal_mode_struct_set_i5a_E6(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5a_E6 = value_in
  end subroutine

  ! linac_normal_mode_struct%i5b_E6: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_i5b_E6(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5b_E6
  end subroutine


  subroutine linac_normal_mode_struct_set_i5b_E6(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5b_E6 = value_in
  end subroutine

  ! linac_normal_mode_struct%sig_E1: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_sig_E1(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_sig_E1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_E1
  end subroutine


  subroutine linac_normal_mode_struct_set_sig_E1(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_sig_E1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_E1 = value_in
  end subroutine

  ! linac_normal_mode_struct%a_emittance_end: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_a_emittance_end(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_a_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_emittance_end
  end subroutine


  subroutine linac_normal_mode_struct_set_a_emittance_end(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_a_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_emittance_end = value_in
  end subroutine

  ! linac_normal_mode_struct%b_emittance_end: 0D_NOT_real

  subroutine linac_normal_mode_struct_get_b_emittance_end(struct_obj_ptr, value_out) bind(c, name='linac_normal_mode_struct_get_b_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_emittance_end
  end subroutine


  subroutine linac_normal_mode_struct_set_b_emittance_end(struct_obj_ptr, value_in) bind(c, name='linac_normal_mode_struct_set_b_emittance_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(linac_normal_mode_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_emittance_end = value_in
  end subroutine

  !! normal_modes_struct

    function allocate_fortran_normal_modes_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(normal_modes_struct), pointer :: fptr
    type(normal_modes_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_normal_modes_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(normal_modes_struct), pointer :: fptr
    type(normal_modes_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_normal_modes_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(normal_modes_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! normal_modes_struct%synch_int: 1D_NOT_real

  subroutine normal_modes_struct_get_synch_int_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='normal_modes_struct_get_synch_int_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(normal_modes_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%synch_int)) then
      data_ptr = c_loc(struct_obj%synch_int(lbound(struct_obj%synch_int, 1)))
      bounds(1) = int(lbound(struct_obj%synch_int, 1), c_int)
      bounds(2) = int(ubound(struct_obj%synch_int, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! normal_modes_struct%sigE_E: 0D_NOT_real

  subroutine normal_modes_struct_get_sigE_E(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_sigE_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigE_E
  end subroutine


  subroutine normal_modes_struct_set_sigE_E(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_sigE_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigE_E = value_in
  end subroutine

  ! normal_modes_struct%sig_z: 0D_NOT_real

  subroutine normal_modes_struct_get_sig_z(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sig_z
  end subroutine


  subroutine normal_modes_struct_set_sig_z(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_sig_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sig_z = value_in
  end subroutine

  ! normal_modes_struct%e_loss: 0D_NOT_real

  subroutine normal_modes_struct_get_e_loss(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_e_loss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%e_loss
  end subroutine


  subroutine normal_modes_struct_set_e_loss(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_e_loss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%e_loss = value_in
  end subroutine

  ! normal_modes_struct%rf_voltage: 0D_NOT_real

  subroutine normal_modes_struct_get_rf_voltage(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_rf_voltage')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_voltage
  end subroutine


  subroutine normal_modes_struct_set_rf_voltage(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_rf_voltage')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_voltage = value_in
  end subroutine

  ! normal_modes_struct%pz_aperture: 0D_NOT_real

  subroutine normal_modes_struct_get_pz_aperture(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_pz_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pz_aperture
  end subroutine


  subroutine normal_modes_struct_set_pz_aperture(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_pz_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pz_aperture = value_in
  end subroutine

  ! normal_modes_struct%pz_average: 0D_NOT_real

  subroutine normal_modes_struct_get_pz_average(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_pz_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pz_average
  end subroutine


  subroutine normal_modes_struct_set_pz_average(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_pz_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pz_average = value_in
  end subroutine

  ! normal_modes_struct%momentum_compaction: 0D_NOT_real

  subroutine normal_modes_struct_get_momentum_compaction(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_momentum_compaction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%momentum_compaction
  end subroutine


  subroutine normal_modes_struct_set_momentum_compaction(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_momentum_compaction')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%momentum_compaction = value_in
  end subroutine

  ! normal_modes_struct%dpz_damp: 0D_NOT_real

  subroutine normal_modes_struct_get_dpz_damp(struct_obj_ptr, value_out) bind(c, name='normal_modes_struct_get_dpz_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dpz_damp
  end subroutine


  subroutine normal_modes_struct_set_dpz_damp(struct_obj_ptr, value_in) bind(c, name='normal_modes_struct_set_dpz_damp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dpz_damp = value_in
  end subroutine

  ! normal_modes_struct%a: 0D_NOT_type

  subroutine normal_modes_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine normal_modes_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(anormal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! normal_modes_struct%b: 0D_NOT_type

  subroutine normal_modes_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine normal_modes_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(anormal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! normal_modes_struct%z: 0D_NOT_type

  subroutine normal_modes_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine normal_modes_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(anormal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! normal_modes_struct%lin: 0D_NOT_type

  subroutine normal_modes_struct_get_lin(struct_obj_ptr, ptr_out) bind(c, name='normal_modes_struct_get_lin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(normal_modes_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lin)
  end subroutine


  subroutine normal_modes_struct_set_lin(struct_obj_ptr, src_ptr) bind(c, name='normal_modes_struct_set_lin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(normal_modes_struct), pointer :: struct_obj
    type(linac_normal_mode_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lin = src_obj
  end subroutine

  !! em_field_struct

    function allocate_fortran_em_field_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(em_field_struct), pointer :: fptr
    type(em_field_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_em_field_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(em_field_struct), pointer :: fptr
    type(em_field_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_em_field_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(em_field_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! em_field_struct%E: 1D_NOT_real

  subroutine em_field_struct_get_E_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_field_struct_get_E_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%E)) then
      data_ptr = c_loc(struct_obj%E(lbound(struct_obj%E, 1)))
      bounds(1) = int(lbound(struct_obj%E, 1), c_int)
      bounds(2) = int(ubound(struct_obj%E, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%B: 1D_NOT_real

  subroutine em_field_struct_get_B_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_field_struct_get_B_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%B)) then
      data_ptr = c_loc(struct_obj%B(lbound(struct_obj%B, 1)))
      bounds(1) = int(lbound(struct_obj%B, 1), c_int)
      bounds(2) = int(ubound(struct_obj%B, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%dE: 2D_NOT_real

  subroutine em_field_struct_get_dE_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='em_field_struct_get_dE_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dE)) then
      data_ptr = c_loc(struct_obj%dE(lbound(struct_obj%dE, 1), lbound(struct_obj%dE, 2)))
      bounds(1) = int(lbound(struct_obj%dE, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dE, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dE, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dE, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%dB: 2D_NOT_real

  subroutine em_field_struct_get_dB_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='em_field_struct_get_dB_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dB)) then
      data_ptr = c_loc(struct_obj%dB(lbound(struct_obj%dB, 1), lbound(struct_obj%dB, 2)))
      bounds(1) = int(lbound(struct_obj%dB, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dB, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dB, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dB, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! em_field_struct%phi: 0D_NOT_real

  subroutine em_field_struct_get_phi(struct_obj_ptr, value_out) bind(c, name='em_field_struct_get_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi
  end subroutine


  subroutine em_field_struct_set_phi(struct_obj_ptr, value_in) bind(c, name='em_field_struct_set_phi')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi = value_in
  end subroutine

  ! em_field_struct%phi_B: 0D_NOT_real

  subroutine em_field_struct_get_phi_B(struct_obj_ptr, value_out) bind(c, name='em_field_struct_get_phi_B')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%phi_B
  end subroutine


  subroutine em_field_struct_set_phi_B(struct_obj_ptr, value_in) bind(c, name='em_field_struct_set_phi_B')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(em_field_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%phi_B = value_in
  end subroutine

  ! em_field_struct%A: 1D_NOT_real

  subroutine em_field_struct_get_A_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='em_field_struct_get_A_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(em_field_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%A)) then
      data_ptr = c_loc(struct_obj%A(lbound(struct_obj%A, 1)))
      bounds(1) = int(lbound(struct_obj%A, 1), c_int)
      bounds(2) = int(ubound(struct_obj%A, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! strong_beam_struct

    function allocate_fortran_strong_beam_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(strong_beam_struct), pointer :: fptr
    type(strong_beam_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_strong_beam_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(strong_beam_struct), pointer :: fptr
    type(strong_beam_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_strong_beam_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(strong_beam_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! strong_beam_struct%ix_slice: 0D_NOT_integer

  subroutine strong_beam_struct_get_ix_slice(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_ix_slice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_slice
  end subroutine


  subroutine strong_beam_struct_set_ix_slice(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_ix_slice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_slice = value_in
  end subroutine

  ! strong_beam_struct%x_center: 0D_NOT_real

  subroutine strong_beam_struct_get_x_center(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_x_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_center
  end subroutine


  subroutine strong_beam_struct_set_x_center(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_x_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_center = value_in
  end subroutine

  ! strong_beam_struct%y_center: 0D_NOT_real

  subroutine strong_beam_struct_get_y_center(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_y_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_center
  end subroutine


  subroutine strong_beam_struct_set_y_center(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_y_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_center = value_in
  end subroutine

  ! strong_beam_struct%x_sigma: 0D_NOT_real

  subroutine strong_beam_struct_get_x_sigma(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_x_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_sigma
  end subroutine


  subroutine strong_beam_struct_set_x_sigma(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_x_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_sigma = value_in
  end subroutine

  ! strong_beam_struct%y_sigma: 0D_NOT_real

  subroutine strong_beam_struct_get_y_sigma(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_y_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_sigma
  end subroutine


  subroutine strong_beam_struct_set_y_sigma(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_y_sigma')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_sigma = value_in
  end subroutine

  ! strong_beam_struct%dx: 0D_NOT_real

  subroutine strong_beam_struct_get_dx(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dx
  end subroutine


  subroutine strong_beam_struct_set_dx(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_dx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dx = value_in
  end subroutine

  ! strong_beam_struct%dy: 0D_NOT_real

  subroutine strong_beam_struct_get_dy(struct_obj_ptr, value_out) bind(c, name='strong_beam_struct_get_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dy
  end subroutine


  subroutine strong_beam_struct_set_dy(struct_obj_ptr, value_in) bind(c, name='strong_beam_struct_set_dy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(strong_beam_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dy = value_in
  end subroutine

  !! track_point_struct

    function allocate_fortran_track_point_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(track_point_struct), pointer :: fptr
    type(track_point_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_track_point_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(track_point_struct), pointer :: fptr
    type(track_point_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_track_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(track_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! track_point_struct%s_lab: 0D_NOT_real

  subroutine track_point_struct_get_s_lab(struct_obj_ptr, value_out) bind(c, name='track_point_struct_get_s_lab')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_lab
  end subroutine


  subroutine track_point_struct_set_s_lab(struct_obj_ptr, value_in) bind(c, name='track_point_struct_set_s_lab')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_lab = value_in
  end subroutine

  ! track_point_struct%s_body: 0D_NOT_real

  subroutine track_point_struct_get_s_body(struct_obj_ptr, value_out) bind(c, name='track_point_struct_get_s_body')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_body
  end subroutine


  subroutine track_point_struct_set_s_body(struct_obj_ptr, value_in) bind(c, name='track_point_struct_set_s_body')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_body = value_in
  end subroutine

  ! track_point_struct%orb: 0D_NOT_type

  subroutine track_point_struct_get_orb(struct_obj_ptr, ptr_out) bind(c, name='track_point_struct_get_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orb)
  end subroutine


  subroutine track_point_struct_set_orb(struct_obj_ptr, src_ptr) bind(c, name='track_point_struct_set_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(track_point_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orb = src_obj
  end subroutine

  ! track_point_struct%field: 0D_NOT_type

  subroutine track_point_struct_get_field(struct_obj_ptr, ptr_out) bind(c, name='track_point_struct_get_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%field)
  end subroutine


  subroutine track_point_struct_set_field(struct_obj_ptr, src_ptr) bind(c, name='track_point_struct_set_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(track_point_struct), pointer :: struct_obj
    type(em_field_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%field = src_obj
  end subroutine

  ! track_point_struct%strong_beam: 0D_NOT_type

  subroutine track_point_struct_get_strong_beam(struct_obj_ptr, ptr_out) bind(c, name='track_point_struct_get_strong_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(track_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%strong_beam)
  end subroutine


  subroutine track_point_struct_set_strong_beam(struct_obj_ptr, src_ptr) bind(c, name='track_point_struct_set_strong_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(track_point_struct), pointer :: struct_obj
    type(strong_beam_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%strong_beam = src_obj
  end subroutine

  ! track_point_struct%vec0: 1D_NOT_real

  subroutine track_point_struct_get_vec0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='track_point_struct_get_vec0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(track_point_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%vec0)) then
      data_ptr = c_loc(struct_obj%vec0(lbound(struct_obj%vec0, 1)))
      bounds(1) = int(lbound(struct_obj%vec0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! track_point_struct%mat6: 2D_NOT_real

  subroutine track_point_struct_get_mat6_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='track_point_struct_get_mat6_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(track_point_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%mat6)) then
      data_ptr = c_loc(struct_obj%mat6(lbound(struct_obj%mat6, 1), lbound(struct_obj%mat6, 2)))
      bounds(1) = int(lbound(struct_obj%mat6, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat6, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat6, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat6, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! track_struct

    function allocate_fortran_track_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(track_struct), pointer :: fptr
    type(track_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_track_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(track_struct), pointer :: fptr
    type(track_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_track_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(track_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! track_struct%pt: 1D_ALLOC_type

  subroutine track_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='track_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(track_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      
      el_size = int(storage_size(struct_obj%pt(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! track_struct%ds_save: 0D_NOT_real

  subroutine track_struct_get_ds_save(struct_obj_ptr, value_out) bind(c, name='track_struct_get_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_save
  end subroutine


  subroutine track_struct_set_ds_save(struct_obj_ptr, value_in) bind(c, name='track_struct_set_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_save = value_in
  end subroutine

  ! track_struct%n_pt: 0D_NOT_integer

  subroutine track_struct_get_n_pt(struct_obj_ptr, value_out) bind(c, name='track_struct_get_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_pt
  end subroutine


  subroutine track_struct_set_n_pt(struct_obj_ptr, value_in) bind(c, name='track_struct_set_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_pt = value_in
  end subroutine

  ! track_struct%n_bad: 0D_NOT_integer

  subroutine track_struct_get_n_bad(struct_obj_ptr, value_out) bind(c, name='track_struct_get_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bad
  end subroutine


  subroutine track_struct_set_n_bad(struct_obj_ptr, value_in) bind(c, name='track_struct_set_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bad = value_in
  end subroutine

  ! track_struct%n_ok: 0D_NOT_integer

  subroutine track_struct_get_n_ok(struct_obj_ptr, value_out) bind(c, name='track_struct_get_n_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ok
  end subroutine


  subroutine track_struct_set_n_ok(struct_obj_ptr, value_in) bind(c, name='track_struct_set_n_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ok = value_in
  end subroutine

  !! space_charge_common_struct

    function allocate_fortran_space_charge_common_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(space_charge_common_struct), pointer :: fptr
    type(space_charge_common_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_space_charge_common_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(space_charge_common_struct), pointer :: fptr
    type(space_charge_common_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_space_charge_common_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(space_charge_common_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! space_charge_common_struct%ds_track_step: 0D_NOT_real

  subroutine space_charge_common_struct_get_ds_track_step(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_ds_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_track_step
  end subroutine


  subroutine space_charge_common_struct_set_ds_track_step(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_ds_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_track_step = value_in
  end subroutine

  ! space_charge_common_struct%dt_track_step: 0D_NOT_real

  subroutine space_charge_common_struct_get_dt_track_step(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_dt_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dt_track_step
  end subroutine


  subroutine space_charge_common_struct_set_dt_track_step(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_dt_track_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dt_track_step = value_in
  end subroutine

  ! space_charge_common_struct%cathode_strength_cutoff: 0D_NOT_real

  subroutine space_charge_common_struct_get_cathode_strength_cutoff(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_cathode_strength_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cathode_strength_cutoff
  end subroutine


  subroutine space_charge_common_struct_set_cathode_strength_cutoff(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_cathode_strength_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cathode_strength_cutoff = value_in
  end subroutine

  ! space_charge_common_struct%rel_tol_tracking: 0D_NOT_real

  subroutine space_charge_common_struct_get_rel_tol_tracking(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol_tracking
  end subroutine


  subroutine space_charge_common_struct_set_rel_tol_tracking(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol_tracking = value_in
  end subroutine

  ! space_charge_common_struct%abs_tol_tracking: 0D_NOT_real

  subroutine space_charge_common_struct_get_abs_tol_tracking(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_tol_tracking
  end subroutine


  subroutine space_charge_common_struct_set_abs_tol_tracking(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_tol_tracking = value_in
  end subroutine

  ! space_charge_common_struct%beam_chamber_height: 0D_NOT_real

  subroutine space_charge_common_struct_get_beam_chamber_height(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_beam_chamber_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%beam_chamber_height
  end subroutine


  subroutine space_charge_common_struct_set_beam_chamber_height(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_beam_chamber_height')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%beam_chamber_height = value_in
  end subroutine

  ! space_charge_common_struct%lsc_sigma_cutoff: 0D_NOT_real

  subroutine space_charge_common_struct_get_lsc_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_lsc_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lsc_sigma_cutoff
  end subroutine


  subroutine space_charge_common_struct_set_lsc_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_lsc_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lsc_sigma_cutoff = value_in
  end subroutine

  ! space_charge_common_struct%particle_sigma_cutoff: 0D_NOT_real

  subroutine space_charge_common_struct_get_particle_sigma_cutoff(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_particle_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle_sigma_cutoff
  end subroutine


  subroutine space_charge_common_struct_set_particle_sigma_cutoff(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_particle_sigma_cutoff')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle_sigma_cutoff = value_in
  end subroutine

  ! space_charge_common_struct%space_charge_mesh_size: 1D_NOT_integer

  subroutine space_charge_common_struct_get_space_charge_mesh_size_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='space_charge_common_struct_get_space_charge_mesh_size_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(space_charge_common_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%space_charge_mesh_size)) then
      data_ptr = c_loc(struct_obj%space_charge_mesh_size(lbound(struct_obj%space_charge_mesh_size, 1)))
      bounds(1) = int(lbound(struct_obj%space_charge_mesh_size, 1), c_int)
      bounds(2) = int(ubound(struct_obj%space_charge_mesh_size, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! space_charge_common_struct%csr3d_mesh_size: 1D_NOT_integer

  subroutine space_charge_common_struct_get_csr3d_mesh_size_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='space_charge_common_struct_get_csr3d_mesh_size_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(space_charge_common_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%csr3d_mesh_size)) then
      data_ptr = c_loc(struct_obj%csr3d_mesh_size(lbound(struct_obj%csr3d_mesh_size, 1)))
      bounds(1) = int(lbound(struct_obj%csr3d_mesh_size, 1), c_int)
      bounds(2) = int(ubound(struct_obj%csr3d_mesh_size, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! space_charge_common_struct%n_bin: 0D_NOT_integer

  subroutine space_charge_common_struct_get_n_bin(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_n_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bin
  end subroutine


  subroutine space_charge_common_struct_set_n_bin(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_n_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bin = value_in
  end subroutine

  ! space_charge_common_struct%particle_bin_span: 0D_NOT_integer

  subroutine space_charge_common_struct_get_particle_bin_span(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_particle_bin_span')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%particle_bin_span
  end subroutine


  subroutine space_charge_common_struct_set_particle_bin_span(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_particle_bin_span')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%particle_bin_span = value_in
  end subroutine

  ! space_charge_common_struct%n_shield_images: 0D_NOT_integer

  subroutine space_charge_common_struct_get_n_shield_images(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_n_shield_images')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_shield_images
  end subroutine


  subroutine space_charge_common_struct_set_n_shield_images(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_n_shield_images')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_shield_images = value_in
  end subroutine

  ! space_charge_common_struct%sc_min_in_bin: 0D_NOT_integer

  subroutine space_charge_common_struct_get_sc_min_in_bin(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_sc_min_in_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sc_min_in_bin
  end subroutine


  subroutine space_charge_common_struct_set_sc_min_in_bin(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_sc_min_in_bin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sc_min_in_bin = value_in
  end subroutine

  ! space_charge_common_struct%lsc_kick_transverse_dependence: 0D_NOT_logical

  subroutine space_charge_common_struct_get_lsc_kick_transverse_dependence(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_lsc_kick_transverse_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lsc_kick_transverse_dependence
  end subroutine


  subroutine space_charge_common_struct_set_lsc_kick_transverse_dependence(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_lsc_kick_transverse_dependence')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lsc_kick_transverse_dependence = value_in
  end subroutine

  ! space_charge_common_struct%debug: 0D_NOT_logical

  subroutine space_charge_common_struct_get_debug(struct_obj_ptr, value_out) bind(c, name='space_charge_common_struct_get_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%debug
  end subroutine


  subroutine space_charge_common_struct_set_debug(struct_obj_ptr, value_in) bind(c, name='space_charge_common_struct_set_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%debug = value_in
  end subroutine

  ! space_charge_common_struct%diagnostic_output_file: 0D_NOT_character

  subroutine space_charge_common_struct_get_diagnostic_output_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='space_charge_common_struct_get_diagnostic_output_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(space_charge_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%diagnostic_output_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%diagnostic_output_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine space_charge_common_struct_set_diagnostic_output_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='space_charge_common_struct_set_diagnostic_output_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(space_charge_common_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%diagnostic_output_file = str_in ! implicitly handles padding
  end subroutine

  !! bmad_common_struct

    function allocate_fortran_bmad_common_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bmad_common_struct), pointer :: fptr
    type(bmad_common_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bmad_common_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bmad_common_struct), pointer :: fptr
    type(bmad_common_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bmad_common_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bmad_common_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bmad_common_struct%max_aperture_limit: 0D_NOT_real

  subroutine bmad_common_struct_get_max_aperture_limit(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_max_aperture_limit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_aperture_limit
  end subroutine


  subroutine bmad_common_struct_set_max_aperture_limit(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_max_aperture_limit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_aperture_limit = value_in
  end subroutine

  ! bmad_common_struct%d_orb: 1D_NOT_real

  subroutine bmad_common_struct_get_d_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bmad_common_struct_get_d_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_common_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%d_orb)) then
      data_ptr = c_loc(struct_obj%d_orb(lbound(struct_obj%d_orb, 1)))
      bounds(1) = int(lbound(struct_obj%d_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d_orb, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_common_struct%default_ds_step: 0D_NOT_real

  subroutine bmad_common_struct_get_default_ds_step(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_default_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_ds_step
  end subroutine


  subroutine bmad_common_struct_set_default_ds_step(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_default_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_ds_step = value_in
  end subroutine

  ! bmad_common_struct%significant_length: 0D_NOT_real

  subroutine bmad_common_struct_get_significant_length(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_significant_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%significant_length
  end subroutine


  subroutine bmad_common_struct_set_significant_length(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_significant_length')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%significant_length = value_in
  end subroutine

  ! bmad_common_struct%rel_tol_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_rel_tol_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol_tracking
  end subroutine


  subroutine bmad_common_struct_set_rel_tol_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_rel_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol_tracking = value_in
  end subroutine

  ! bmad_common_struct%abs_tol_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_abs_tol_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_tol_tracking
  end subroutine


  subroutine bmad_common_struct_set_abs_tol_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_abs_tol_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_tol_tracking = value_in
  end subroutine

  ! bmad_common_struct%rel_tol_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_rel_tol_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_rel_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_tol_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_rel_tol_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_rel_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_tol_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%abs_tol_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_abs_tol_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_abs_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_tol_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_abs_tol_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_abs_tol_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_tol_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%init_ds_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_init_ds_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_init_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_ds_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_init_ds_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_init_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_ds_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%min_ds_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_min_ds_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_min_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%min_ds_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_min_ds_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_min_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%min_ds_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%fatal_ds_adaptive_tracking: 0D_NOT_real

  subroutine bmad_common_struct_get_fatal_ds_adaptive_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_fatal_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%fatal_ds_adaptive_tracking
  end subroutine


  subroutine bmad_common_struct_set_fatal_ds_adaptive_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_fatal_ds_adaptive_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%fatal_ds_adaptive_tracking = value_in
  end subroutine

  ! bmad_common_struct%autoscale_amp_abs_tol: 0D_NOT_real

  subroutine bmad_common_struct_get_autoscale_amp_abs_tol(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_autoscale_amp_abs_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_amp_abs_tol
  end subroutine


  subroutine bmad_common_struct_set_autoscale_amp_abs_tol(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_autoscale_amp_abs_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_amp_abs_tol = value_in
  end subroutine

  ! bmad_common_struct%autoscale_amp_rel_tol: 0D_NOT_real

  subroutine bmad_common_struct_get_autoscale_amp_rel_tol(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_autoscale_amp_rel_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_amp_rel_tol
  end subroutine


  subroutine bmad_common_struct_set_autoscale_amp_rel_tol(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_autoscale_amp_rel_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_amp_rel_tol = value_in
  end subroutine

  ! bmad_common_struct%autoscale_phase_tol: 0D_NOT_real

  subroutine bmad_common_struct_get_autoscale_phase_tol(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_autoscale_phase_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%autoscale_phase_tol
  end subroutine


  subroutine bmad_common_struct_set_autoscale_phase_tol(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_autoscale_phase_tol')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%autoscale_phase_tol = value_in
  end subroutine

  ! bmad_common_struct%electric_dipole_moment: 0D_NOT_real

  subroutine bmad_common_struct_get_electric_dipole_moment(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_electric_dipole_moment')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%electric_dipole_moment
  end subroutine


  subroutine bmad_common_struct_set_electric_dipole_moment(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_electric_dipole_moment')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%electric_dipole_moment = value_in
  end subroutine

  ! bmad_common_struct%synch_rad_scale: 0D_NOT_real

  subroutine bmad_common_struct_get_synch_rad_scale(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_synch_rad_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%synch_rad_scale
  end subroutine


  subroutine bmad_common_struct_set_synch_rad_scale(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_synch_rad_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%synch_rad_scale = value_in
  end subroutine

  ! bmad_common_struct%sad_eps_scale: 0D_NOT_real

  subroutine bmad_common_struct_get_sad_eps_scale(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sad_eps_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sad_eps_scale
  end subroutine


  subroutine bmad_common_struct_set_sad_eps_scale(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sad_eps_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sad_eps_scale = value_in
  end subroutine

  ! bmad_common_struct%sad_amp_max: 0D_NOT_real

  subroutine bmad_common_struct_get_sad_amp_max(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sad_amp_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sad_amp_max
  end subroutine


  subroutine bmad_common_struct_set_sad_amp_max(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sad_amp_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sad_amp_max = value_in
  end subroutine

  ! bmad_common_struct%sad_n_div_max: 0D_NOT_integer

  subroutine bmad_common_struct_get_sad_n_div_max(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sad_n_div_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sad_n_div_max
  end subroutine


  subroutine bmad_common_struct_set_sad_n_div_max(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sad_n_div_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sad_n_div_max = value_in
  end subroutine

  ! bmad_common_struct%taylor_order: 0D_NOT_integer

  subroutine bmad_common_struct_get_taylor_order(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%taylor_order
  end subroutine


  subroutine bmad_common_struct_set_taylor_order(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%taylor_order = value_in
  end subroutine

  ! bmad_common_struct%runge_kutta_order: 0D_NOT_integer

  subroutine bmad_common_struct_get_runge_kutta_order(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_runge_kutta_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%runge_kutta_order
  end subroutine


  subroutine bmad_common_struct_set_runge_kutta_order(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_runge_kutta_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%runge_kutta_order = value_in
  end subroutine

  ! bmad_common_struct%default_integ_order: 0D_NOT_integer

  subroutine bmad_common_struct_get_default_integ_order(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_default_integ_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%default_integ_order
  end subroutine


  subroutine bmad_common_struct_set_default_integ_order(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_default_integ_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%default_integ_order = value_in
  end subroutine

  ! bmad_common_struct%max_num_runge_kutta_step: 0D_NOT_integer

  subroutine bmad_common_struct_get_max_num_runge_kutta_step(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_max_num_runge_kutta_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_num_runge_kutta_step
  end subroutine


  subroutine bmad_common_struct_set_max_num_runge_kutta_step(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_max_num_runge_kutta_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_num_runge_kutta_step = value_in
  end subroutine

  ! bmad_common_struct%rf_phase_below_transition_ref: 0D_NOT_logical

  subroutine bmad_common_struct_get_rf_phase_below_transition_ref(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_rf_phase_below_transition_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rf_phase_below_transition_ref
  end subroutine


  subroutine bmad_common_struct_set_rf_phase_below_transition_ref(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_rf_phase_below_transition_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rf_phase_below_transition_ref = value_in
  end subroutine

  ! bmad_common_struct%sr_wakes_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_sr_wakes_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_sr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sr_wakes_on
  end subroutine


  subroutine bmad_common_struct_set_sr_wakes_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_sr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sr_wakes_on = value_in
  end subroutine

  ! bmad_common_struct%lr_wakes_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_lr_wakes_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_lr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lr_wakes_on
  end subroutine


  subroutine bmad_common_struct_set_lr_wakes_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_lr_wakes_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lr_wakes_on = value_in
  end subroutine

  ! bmad_common_struct%auto_bookkeeper: 0D_NOT_logical

  subroutine bmad_common_struct_get_auto_bookkeeper(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_auto_bookkeeper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%auto_bookkeeper
  end subroutine


  subroutine bmad_common_struct_set_auto_bookkeeper(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_auto_bookkeeper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%auto_bookkeeper = value_in
  end subroutine

  ! bmad_common_struct%high_energy_space_charge_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_high_energy_space_charge_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_high_energy_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%high_energy_space_charge_on
  end subroutine


  subroutine bmad_common_struct_set_high_energy_space_charge_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_high_energy_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%high_energy_space_charge_on = value_in
  end subroutine

  ! bmad_common_struct%csr_and_space_charge_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_csr_and_space_charge_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_csr_and_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%csr_and_space_charge_on
  end subroutine


  subroutine bmad_common_struct_set_csr_and_space_charge_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_csr_and_space_charge_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%csr_and_space_charge_on = value_in
  end subroutine

  ! bmad_common_struct%spin_tracking_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_spin_tracking_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_spin_tracking_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_tracking_on
  end subroutine


  subroutine bmad_common_struct_set_spin_tracking_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_spin_tracking_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_tracking_on = value_in
  end subroutine

  ! bmad_common_struct%spin_sokolov_ternov_flipping_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_spin_sokolov_ternov_flipping_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_spin_sokolov_ternov_flipping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_sokolov_ternov_flipping_on
  end subroutine


  subroutine bmad_common_struct_set_spin_sokolov_ternov_flipping_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_spin_sokolov_ternov_flipping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_sokolov_ternov_flipping_on = value_in
  end subroutine

  ! bmad_common_struct%radiation_damping_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_radiation_damping_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_radiation_damping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radiation_damping_on
  end subroutine


  subroutine bmad_common_struct_set_radiation_damping_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_radiation_damping_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radiation_damping_on = value_in
  end subroutine

  ! bmad_common_struct%radiation_zero_average: 0D_NOT_logical

  subroutine bmad_common_struct_get_radiation_zero_average(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_radiation_zero_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radiation_zero_average
  end subroutine


  subroutine bmad_common_struct_set_radiation_zero_average(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_radiation_zero_average')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radiation_zero_average = value_in
  end subroutine

  ! bmad_common_struct%radiation_fluctuations_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_radiation_fluctuations_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_radiation_fluctuations_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%radiation_fluctuations_on
  end subroutine


  subroutine bmad_common_struct_set_radiation_fluctuations_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_radiation_fluctuations_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%radiation_fluctuations_on = value_in
  end subroutine

  ! bmad_common_struct%conserve_taylor_maps: 0D_NOT_logical

  subroutine bmad_common_struct_get_conserve_taylor_maps(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_conserve_taylor_maps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%conserve_taylor_maps
  end subroutine


  subroutine bmad_common_struct_set_conserve_taylor_maps(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_conserve_taylor_maps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%conserve_taylor_maps = value_in
  end subroutine

  ! bmad_common_struct%absolute_time_tracking: 0D_NOT_logical

  subroutine bmad_common_struct_get_absolute_time_tracking(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_absolute_time_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%absolute_time_tracking
  end subroutine


  subroutine bmad_common_struct_set_absolute_time_tracking(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_absolute_time_tracking')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%absolute_time_tracking = value_in
  end subroutine

  ! bmad_common_struct%absolute_time_ref_shift: 0D_NOT_logical

  subroutine bmad_common_struct_get_absolute_time_ref_shift(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_absolute_time_ref_shift')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%absolute_time_ref_shift
  end subroutine


  subroutine bmad_common_struct_set_absolute_time_ref_shift(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_absolute_time_ref_shift')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%absolute_time_ref_shift = value_in
  end subroutine

  ! bmad_common_struct%convert_to_kinetic_momentum: 0D_NOT_logical

  subroutine bmad_common_struct_get_convert_to_kinetic_momentum(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_convert_to_kinetic_momentum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%convert_to_kinetic_momentum
  end subroutine


  subroutine bmad_common_struct_set_convert_to_kinetic_momentum(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_convert_to_kinetic_momentum')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%convert_to_kinetic_momentum = value_in
  end subroutine

  ! bmad_common_struct%normalize_twiss: 0D_NOT_logical

  subroutine bmad_common_struct_get_normalize_twiss(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_normalize_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%normalize_twiss
  end subroutine


  subroutine bmad_common_struct_set_normalize_twiss(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_normalize_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%normalize_twiss = value_in
  end subroutine

  ! bmad_common_struct%aperture_limit_on: 0D_NOT_logical

  subroutine bmad_common_struct_get_aperture_limit_on(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_aperture_limit_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aperture_limit_on
  end subroutine


  subroutine bmad_common_struct_set_aperture_limit_on(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_aperture_limit_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aperture_limit_on = value_in
  end subroutine

  ! bmad_common_struct%spin_n0_direction_user_set: 0D_NOT_logical

  subroutine bmad_common_struct_get_spin_n0_direction_user_set(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_spin_n0_direction_user_set')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_n0_direction_user_set
  end subroutine


  subroutine bmad_common_struct_set_spin_n0_direction_user_set(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_spin_n0_direction_user_set')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_n0_direction_user_set = value_in
  end subroutine

  ! bmad_common_struct%debug: 0D_NOT_logical

  subroutine bmad_common_struct_get_debug(struct_obj_ptr, value_out) bind(c, name='bmad_common_struct_get_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%debug
  end subroutine


  subroutine bmad_common_struct_set_debug(struct_obj_ptr, value_in) bind(c, name='bmad_common_struct_set_debug')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bmad_common_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%debug = value_in
  end subroutine

  !! rad_int1_struct

    function allocate_fortran_rad_int1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rad_int1_struct), pointer :: fptr
    type(rad_int1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rad_int1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rad_int1_struct), pointer :: fptr
    type(rad_int1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rad_int1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_int1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rad_int1_struct%i0: 0D_NOT_real

  subroutine rad_int1_struct_get_i0(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i0
  end subroutine


  subroutine rad_int1_struct_set_i0(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i0 = value_in
  end subroutine

  ! rad_int1_struct%i1: 0D_NOT_real

  subroutine rad_int1_struct_get_i1(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i1
  end subroutine


  subroutine rad_int1_struct_set_i1(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i1 = value_in
  end subroutine

  ! rad_int1_struct%i2: 0D_NOT_real

  subroutine rad_int1_struct_get_i2(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i2
  end subroutine


  subroutine rad_int1_struct_set_i2(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i2 = value_in
  end subroutine

  ! rad_int1_struct%i3: 0D_NOT_real

  subroutine rad_int1_struct_get_i3(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i3
  end subroutine


  subroutine rad_int1_struct_set_i3(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i3 = value_in
  end subroutine

  ! rad_int1_struct%i4a: 0D_NOT_real

  subroutine rad_int1_struct_get_i4a(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i4a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i4a
  end subroutine


  subroutine rad_int1_struct_set_i4a(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i4a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i4a = value_in
  end subroutine

  ! rad_int1_struct%i4b: 0D_NOT_real

  subroutine rad_int1_struct_get_i4b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i4b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i4b
  end subroutine


  subroutine rad_int1_struct_set_i4b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i4b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i4b = value_in
  end subroutine

  ! rad_int1_struct%i4z: 0D_NOT_real

  subroutine rad_int1_struct_get_i4z(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i4z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i4z
  end subroutine


  subroutine rad_int1_struct_set_i4z(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i4z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i4z = value_in
  end subroutine

  ! rad_int1_struct%i5a: 0D_NOT_real

  subroutine rad_int1_struct_get_i5a(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i5a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5a
  end subroutine


  subroutine rad_int1_struct_set_i5a(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i5a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5a = value_in
  end subroutine

  ! rad_int1_struct%i5b: 0D_NOT_real

  subroutine rad_int1_struct_get_i5b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i5b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i5b
  end subroutine


  subroutine rad_int1_struct_set_i5b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i5b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i5b = value_in
  end subroutine

  ! rad_int1_struct%i6b: 0D_NOT_real

  subroutine rad_int1_struct_get_i6b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_i6b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i6b
  end subroutine


  subroutine rad_int1_struct_set_i6b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_i6b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i6b = value_in
  end subroutine

  ! rad_int1_struct%lin_i2_E4: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i2_E4(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i2_E4
  end subroutine


  subroutine rad_int1_struct_set_lin_i2_E4(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i2_E4')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i2_E4 = value_in
  end subroutine

  ! rad_int1_struct%lin_i3_E7: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i3_E7(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i3_E7
  end subroutine


  subroutine rad_int1_struct_set_lin_i3_E7(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i3_E7')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i3_E7 = value_in
  end subroutine

  ! rad_int1_struct%lin_i5a_E6: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i5a_E6(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i5a_E6
  end subroutine


  subroutine rad_int1_struct_set_lin_i5a_E6(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i5a_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i5a_E6 = value_in
  end subroutine

  ! rad_int1_struct%lin_i5b_E6: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_i5b_E6(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_i5b_E6
  end subroutine


  subroutine rad_int1_struct_set_lin_i5b_E6(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_i5b_E6')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_i5b_E6 = value_in
  end subroutine

  ! rad_int1_struct%lin_norm_emit_a: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_norm_emit_a(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_norm_emit_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_norm_emit_a
  end subroutine


  subroutine rad_int1_struct_set_lin_norm_emit_a(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_norm_emit_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_norm_emit_a = value_in
  end subroutine

  ! rad_int1_struct%lin_norm_emit_b: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_norm_emit_b(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_norm_emit_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_norm_emit_b
  end subroutine


  subroutine rad_int1_struct_set_lin_norm_emit_b(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_norm_emit_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_norm_emit_b = value_in
  end subroutine

  ! rad_int1_struct%lin_sig_E: 0D_NOT_real

  subroutine rad_int1_struct_get_lin_sig_E(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_lin_sig_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lin_sig_E
  end subroutine


  subroutine rad_int1_struct_set_lin_sig_E(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_lin_sig_E')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lin_sig_E = value_in
  end subroutine

  ! rad_int1_struct%n_steps: 0D_NOT_real

  subroutine rad_int1_struct_get_n_steps(struct_obj_ptr, value_out) bind(c, name='rad_int1_struct_get_n_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_steps
  end subroutine


  subroutine rad_int1_struct_set_n_steps(struct_obj_ptr, value_in) bind(c, name='rad_int1_struct_set_n_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rad_int1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_steps = value_in
  end subroutine

  !! rad_int_branch_struct

    function allocate_fortran_rad_int_branch_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rad_int_branch_struct), pointer :: fptr
    type(rad_int_branch_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rad_int_branch_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rad_int_branch_struct), pointer :: fptr
    type(rad_int_branch_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rad_int_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_int_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rad_int_branch_struct%ele: 1D_ALLOC_type

  subroutine rad_int_branch_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='rad_int_branch_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_int_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! rad_int_all_ele_struct

    function allocate_fortran_rad_int_all_ele_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rad_int_all_ele_struct), pointer :: fptr
    type(rad_int_all_ele_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rad_int_all_ele_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rad_int_all_ele_struct), pointer :: fptr
    type(rad_int_all_ele_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rad_int_all_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rad_int_all_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rad_int_all_ele_struct%branch: 1D_ALLOC_type

  subroutine rad_int_all_ele_struct_get_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='rad_int_all_ele_struct_get_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rad_int_all_ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%branch) .and. is_contiguous(struct_obj%branch)) then
      data_ptr = c_loc(struct_obj%branch(lbound(struct_obj%branch, 1)))
      bounds(1) = int(lbound(struct_obj%branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! rf_stair_step_struct

    function allocate_fortran_rf_stair_step_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rf_stair_step_struct), pointer :: fptr
    type(rf_stair_step_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rf_stair_step_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rf_stair_step_struct), pointer :: fptr
    type(rf_stair_step_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rf_stair_step_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rf_stair_step_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rf_stair_step_struct%E_tot0: 0D_NOT_real

  subroutine rf_stair_step_struct_get_E_tot0(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_E_tot0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_tot0
  end subroutine


  subroutine rf_stair_step_struct_set_E_tot0(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_E_tot0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_tot0 = value_in
  end subroutine

  ! rf_stair_step_struct%E_tot1: 0D_NOT_real

  subroutine rf_stair_step_struct_get_E_tot1(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_E_tot1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%E_tot1
  end subroutine


  subroutine rf_stair_step_struct_set_E_tot1(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_E_tot1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%E_tot1 = value_in
  end subroutine

  ! rf_stair_step_struct%p0c: 0D_NOT_real

  subroutine rf_stair_step_struct_get_p0c(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p0c
  end subroutine


  subroutine rf_stair_step_struct_set_p0c(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_p0c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p0c = value_in
  end subroutine

  ! rf_stair_step_struct%p1c: 0D_NOT_real

  subroutine rf_stair_step_struct_get_p1c(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_p1c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%p1c
  end subroutine


  subroutine rf_stair_step_struct_set_p1c(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_p1c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%p1c = value_in
  end subroutine

  ! rf_stair_step_struct%dE_amp: 0D_NOT_real

  subroutine rf_stair_step_struct_get_dE_amp(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_dE_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dE_amp
  end subroutine


  subroutine rf_stair_step_struct_set_dE_amp(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_dE_amp')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dE_amp = value_in
  end subroutine

  ! rf_stair_step_struct%scale: 0D_NOT_real

  subroutine rf_stair_step_struct_get_scale(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scale
  end subroutine


  subroutine rf_stair_step_struct_set_scale(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scale = value_in
  end subroutine

  ! rf_stair_step_struct%time: 0D_NOT_real

  subroutine rf_stair_step_struct_get_time(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%time
  end subroutine


  subroutine rf_stair_step_struct_set_time(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%time = value_in
  end subroutine

  ! rf_stair_step_struct%s: 0D_NOT_real

  subroutine rf_stair_step_struct_get_s(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine rf_stair_step_struct_set_s(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! rf_stair_step_struct%ix_step: 0D_NOT_integer

  subroutine rf_stair_step_struct_get_ix_step(struct_obj_ptr, value_out) bind(c, name='rf_stair_step_struct_get_ix_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_step
  end subroutine


  subroutine rf_stair_step_struct_set_ix_step(struct_obj_ptr, value_in) bind(c, name='rf_stair_step_struct_set_ix_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(rf_stair_step_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_step = value_in
  end subroutine

  !! rf_ele_struct

    function allocate_fortran_rf_ele_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(rf_ele_struct), pointer :: fptr
    type(rf_ele_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_rf_ele_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(rf_ele_struct), pointer :: fptr
    type(rf_ele_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_rf_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(rf_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! rf_ele_struct%steps: 1D_ALLOC_type

  subroutine rf_ele_struct_get_steps_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='rf_ele_struct_get_steps_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(rf_ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%steps) .and. is_contiguous(struct_obj%steps)) then
      data_ptr = c_loc(struct_obj%steps(lbound(struct_obj%steps, 1)))
      bounds(1) = int(lbound(struct_obj%steps, 1), c_int)
      bounds(2) = int(ubound(struct_obj%steps, 1), c_int)
      
      el_size = int(storage_size(struct_obj%steps(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! rf_ele_struct%ds_step: 0D_NOT_real

  subroutine rf_ele_struct_get_ds_step(struct_obj_ptr, value_out) bind(c, name='rf_ele_struct_get_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(rf_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_step
  end subroutine


  subroutine rf_ele_struct_set_ds_step(struct_obj_ptr, value_in) bind(c, name='rf_ele_struct_set_ds_step')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(rf_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_step = value_in
  end subroutine

  !! ele_struct

    function allocate_fortran_ele_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ele_struct), pointer :: fptr
    type(ele_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ele_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ele_struct), pointer :: fptr
    type(ele_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ele_struct%name: 0D_NOT_character

  subroutine ele_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%type: 0D_NOT_character

  subroutine ele_struct_get_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%type = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%alias: 0D_NOT_character

  subroutine ele_struct_get_alias_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_alias_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%alias)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%alias), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_alias(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_alias')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%alias = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%component_name: 0D_NOT_character

  subroutine ele_struct_get_component_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='ele_struct_get_component_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%component_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%component_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine ele_struct_set_component_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_component_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%component_name = str_in ! implicitly handles padding
  end subroutine

  ! ele_struct%descrip: 0D_PTR_character

  subroutine ele_struct_get_descrip_info(struct_obj_ptr, data_ptr, str_len, is_allocated) &
    bind(c, name='ele_struct_get_descrip_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%descrip)) then
      data_ptr = c_loc(struct_obj%descrip)
      str_len = int(len(struct_obj%descrip), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine


  subroutine ele_struct_set_descrip(struct_obj_ptr, str_ptr, str_len) bind(c, name='ele_struct_set_descrip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(ele_struct), pointer :: struct_obj
    character(len=str_len), pointer :: temp_str
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%descrip)) deallocate(struct_obj%descrip)
    
    if (str_len > 0) then
        call c_f_pointer(str_ptr, temp_str)
        allocate(struct_obj%descrip, source=temp_str)
    else
        nullify(struct_obj%descrip)
    endif
  end subroutine

  ! ele_struct%a: 0D_NOT_type

  subroutine ele_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine ele_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! ele_struct%b: 0D_NOT_type

  subroutine ele_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine ele_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! ele_struct%z: 0D_NOT_type

  subroutine ele_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine ele_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! ele_struct%x: 0D_NOT_type

  subroutine ele_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine ele_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(xy_disp_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! ele_struct%y: 0D_NOT_type

  subroutine ele_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine ele_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(xy_disp_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  ! ele_struct%ac_kick: 0D_PTR_type

  subroutine ele_struct_get_ac_kick(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_ac_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ac_kick)) then
      ptr_out = c_loc(struct_obj%ac_kick)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_ac_kick(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_ac_kick')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(ac_kicker_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ac_kick)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ac_kick = src_obj
    endif
  end subroutine

  ! ele_struct%bookkeeping_state: 0D_NOT_type

  subroutine ele_struct_get_bookkeeping_state(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%bookkeeping_state)
  end subroutine


  subroutine ele_struct_set_bookkeeping_state(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_bookkeeping_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(bookkeeping_state_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%bookkeeping_state = src_obj
  end subroutine

  ! ele_struct%branch: 0D_PTR_type

  subroutine ele_struct_get_branch(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%branch)) then
      ptr_out = c_loc(struct_obj%branch)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_branch(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(branch_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%branch)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%branch = src_obj
    endif
  end subroutine

  ! ele_struct%control: 0D_PTR_type

  subroutine ele_struct_get_control(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%control)) then
      ptr_out = c_loc(struct_obj%control)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_control(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_control')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(controller_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%control)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%control = src_obj
    endif
  end subroutine

  ! ele_struct%rf: 0D_PTR_type

  subroutine ele_struct_get_rf(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_rf')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rf)) then
      ptr_out = c_loc(struct_obj%rf)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_rf(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_rf')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(rf_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rf)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%rf = src_obj
    endif
  end subroutine

  ! ele_struct%lord: 0D_PTR_type

  subroutine ele_struct_get_lord(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lord)) then
      ptr_out = c_loc(struct_obj%lord)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_lord(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lord)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%lord = src_obj
    endif
  end subroutine

  ! ele_struct%floor: 0D_NOT_type

  subroutine ele_struct_get_floor(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_floor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%floor)
  end subroutine


  subroutine ele_struct_set_floor(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_floor')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(floor_position_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%floor = src_obj
  end subroutine

  ! ele_struct%high_energy_space_charge: 0D_PTR_type

  subroutine ele_struct_get_high_energy_space_charge(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_high_energy_space_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%high_energy_space_charge)) then
      ptr_out = c_loc(struct_obj%high_energy_space_charge)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_high_energy_space_charge(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_high_energy_space_charge')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(high_energy_space_charge_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%high_energy_space_charge)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%high_energy_space_charge = src_obj
    endif
  end subroutine

  ! ele_struct%mode3: 0D_PTR_type

  subroutine ele_struct_get_mode3(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_mode3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%mode3)) then
      ptr_out = c_loc(struct_obj%mode3)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_mode3(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_mode3')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(mode3_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%mode3)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%mode3 = src_obj
    endif
  end subroutine

  ! ele_struct%photon: 0D_PTR_type

  subroutine ele_struct_get_photon(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%photon)) then
      ptr_out = c_loc(struct_obj%photon)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_photon(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_photon')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(photon_element_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%photon)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%photon = src_obj
    endif
  end subroutine

  ! ele_struct%rad_map: 0D_PTR_type

  subroutine ele_struct_get_rad_map(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_rad_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rad_map)) then
      ptr_out = c_loc(struct_obj%rad_map)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_rad_map(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_rad_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(rad_map_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%rad_map)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%rad_map = src_obj
    endif
  end subroutine

  ! ele_struct%taylor: 1D_NOT_type

  subroutine ele_struct_get_taylor_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_taylor_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%taylor)) then
      data_ptr = c_loc(struct_obj%taylor(lbound(struct_obj%taylor, 1)))
      bounds(1) = int(lbound(struct_obj%taylor, 1), c_int)
      bounds(2) = int(ubound(struct_obj%taylor, 1), c_int)
      
      el_size = int(storage_size(struct_obj%taylor(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%spin_taylor_ref_orb_in: 1D_NOT_real

  subroutine ele_struct_get_spin_taylor_ref_orb_in_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_spin_taylor_ref_orb_in_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin_taylor_ref_orb_in)) then
      data_ptr = c_loc(struct_obj%spin_taylor_ref_orb_in(lbound(struct_obj%spin_taylor_ref_orb_in, 1)))
      bounds(1) = int(lbound(struct_obj%spin_taylor_ref_orb_in, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_taylor_ref_orb_in, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%spin_taylor: 1D_NOT_type

  subroutine ele_struct_get_spin_taylor_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_spin_taylor_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin_taylor)) then
      data_ptr = c_loc(struct_obj%spin_taylor(lbound(struct_obj%spin_taylor, 1)))
      bounds(1) = int(lbound(struct_obj%spin_taylor, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_taylor, 1), c_int)
      
      el_size = int(storage_size(struct_obj%spin_taylor(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%wake: 0D_PTR_type

  subroutine ele_struct_get_wake(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_wake')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%wake)) then
      ptr_out = c_loc(struct_obj%wake)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ele_struct_set_wake(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_wake')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(wake_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%wake)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%wake = src_obj
    endif
  end subroutine

  ! ele_struct%wall3d: 1D_PTR_type

  subroutine ele_struct_get_wall3d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_wall3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%wall3d) .and. is_contiguous(struct_obj%wall3d)) then
      data_ptr = c_loc(struct_obj%wall3d(lbound(struct_obj%wall3d, 1)))
      bounds(1) = int(lbound(struct_obj%wall3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%wall3d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%wall3d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%cartesian_map: 1D_PTR_type

  subroutine ele_struct_get_cartesian_map_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_cartesian_map_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%cartesian_map) .and. is_contiguous(struct_obj%cartesian_map)) then
      data_ptr = c_loc(struct_obj%cartesian_map(lbound(struct_obj%cartesian_map, 1)))
      bounds(1) = int(lbound(struct_obj%cartesian_map, 1), c_int)
      bounds(2) = int(ubound(struct_obj%cartesian_map, 1), c_int)
      
      el_size = int(storage_size(struct_obj%cartesian_map(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%cylindrical_map: 1D_PTR_type

  subroutine ele_struct_get_cylindrical_map_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_cylindrical_map_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%cylindrical_map) .and. is_contiguous(struct_obj%cylindrical_map)) then
      data_ptr = c_loc(struct_obj%cylindrical_map(lbound(struct_obj%cylindrical_map, 1)))
      bounds(1) = int(lbound(struct_obj%cylindrical_map, 1), c_int)
      bounds(2) = int(ubound(struct_obj%cylindrical_map, 1), c_int)
      
      el_size = int(storage_size(struct_obj%cylindrical_map(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%gen_grad_map: 1D_PTR_type

  subroutine ele_struct_get_gen_grad_map_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_gen_grad_map_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%gen_grad_map) .and. is_contiguous(struct_obj%gen_grad_map)) then
      data_ptr = c_loc(struct_obj%gen_grad_map(lbound(struct_obj%gen_grad_map, 1)))
      bounds(1) = int(lbound(struct_obj%gen_grad_map, 1), c_int)
      bounds(2) = int(ubound(struct_obj%gen_grad_map, 1), c_int)
      
      el_size = int(storage_size(struct_obj%gen_grad_map(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%grid_field: 1D_PTR_type

  subroutine ele_struct_get_grid_field_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='ele_struct_get_grid_field_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%grid_field) .and. is_contiguous(struct_obj%grid_field)) then
      data_ptr = c_loc(struct_obj%grid_field(lbound(struct_obj%grid_field, 1)))
      bounds(1) = int(lbound(struct_obj%grid_field, 1), c_int)
      bounds(2) = int(ubound(struct_obj%grid_field, 1), c_int)
      
      el_size = int(storage_size(struct_obj%grid_field(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%map_ref_orb_in: 0D_NOT_type

  subroutine ele_struct_get_map_ref_orb_in(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_map_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%map_ref_orb_in)
  end subroutine


  subroutine ele_struct_set_map_ref_orb_in(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_map_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%map_ref_orb_in = src_obj
  end subroutine

  ! ele_struct%map_ref_orb_out: 0D_NOT_type

  subroutine ele_struct_get_map_ref_orb_out(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_map_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%map_ref_orb_out)
  end subroutine


  subroutine ele_struct_set_map_ref_orb_out(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_map_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%map_ref_orb_out = src_obj
  end subroutine

  ! ele_struct%time_ref_orb_in: 0D_NOT_type

  subroutine ele_struct_get_time_ref_orb_in(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_time_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%time_ref_orb_in)
  end subroutine


  subroutine ele_struct_set_time_ref_orb_in(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_time_ref_orb_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%time_ref_orb_in = src_obj
  end subroutine

  ! ele_struct%time_ref_orb_out: 0D_NOT_type

  subroutine ele_struct_get_time_ref_orb_out(struct_obj_ptr, ptr_out) bind(c, name='ele_struct_get_time_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%time_ref_orb_out)
  end subroutine


  subroutine ele_struct_set_time_ref_orb_out(struct_obj_ptr, src_ptr) bind(c, name='ele_struct_set_time_ref_orb_out')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ele_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%time_ref_orb_out = src_obj
  end subroutine

  ! ele_struct%value: 1D_NOT_real

  subroutine ele_struct_get_value_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_value_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%value)) then
      data_ptr = c_loc(struct_obj%value(lbound(struct_obj%value, 1)))
      bounds(1) = int(lbound(struct_obj%value, 1), c_int)
      bounds(2) = int(ubound(struct_obj%value, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%old_value: 1D_NOT_real

  subroutine ele_struct_get_old_value_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_old_value_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%old_value)) then
      data_ptr = c_loc(struct_obj%old_value(lbound(struct_obj%old_value, 1)))
      bounds(1) = int(lbound(struct_obj%old_value, 1), c_int)
      bounds(2) = int(ubound(struct_obj%old_value, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%spin_q: 2D_NOT_real

  subroutine ele_struct_get_spin_q_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_spin_q_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin_q)) then
      data_ptr = c_loc(struct_obj%spin_q(lbound(struct_obj%spin_q, 1), lbound(struct_obj%spin_q, 2)))
      bounds(1) = int(lbound(struct_obj%spin_q, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_q, 1), c_int)
      bounds(3) = int(lbound(struct_obj%spin_q, 2), c_int)
      bounds(4) = int(ubound(struct_obj%spin_q, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%vec0: 1D_NOT_real

  subroutine ele_struct_get_vec0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_vec0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%vec0)) then
      data_ptr = c_loc(struct_obj%vec0(lbound(struct_obj%vec0, 1)))
      bounds(1) = int(lbound(struct_obj%vec0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%mat6: 2D_NOT_real

  subroutine ele_struct_get_mat6_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_mat6_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%mat6)) then
      data_ptr = c_loc(struct_obj%mat6(lbound(struct_obj%mat6, 1), lbound(struct_obj%mat6, 2)))
      bounds(1) = int(lbound(struct_obj%mat6, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat6, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat6, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat6, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%c_mat: 2D_NOT_real

  subroutine ele_struct_get_c_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_c_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%c_mat)) then
      data_ptr = c_loc(struct_obj%c_mat(lbound(struct_obj%c_mat, 1), lbound(struct_obj%c_mat, 2)))
      bounds(1) = int(lbound(struct_obj%c_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%c_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%c_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%c_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%gamma_c: 0D_NOT_real

  subroutine ele_struct_get_gamma_c(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_gamma_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%gamma_c
  end subroutine


  subroutine ele_struct_set_gamma_c(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_gamma_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%gamma_c = value_in
  end subroutine

  ! ele_struct%s_start: 0D_NOT_real

  subroutine ele_struct_get_s_start(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_s_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_start
  end subroutine


  subroutine ele_struct_set_s_start(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_s_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_start = value_in
  end subroutine

  ! ele_struct%s: 0D_NOT_real

  subroutine ele_struct_get_s(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine ele_struct_set_s(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! ele_struct%ref_time: 0D_NOT_real

  subroutine ele_struct_get_ref_time(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ref_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_time
  end subroutine


  subroutine ele_struct_set_ref_time(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ref_time')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_time = value_in
  end subroutine

  ! ele_struct%a_pole: 1D_PTR_real

  subroutine ele_struct_get_a_pole_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_a_pole_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%a_pole) .and. is_contiguous(struct_obj%a_pole)) then
      data_ptr = c_loc(struct_obj%a_pole(lbound(struct_obj%a_pole, 1)))
      bounds(1) = int(lbound(struct_obj%a_pole, 1), c_int)
      bounds(2) = int(ubound(struct_obj%a_pole, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%b_pole: 1D_PTR_real

  subroutine ele_struct_get_b_pole_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_b_pole_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%b_pole) .and. is_contiguous(struct_obj%b_pole)) then
      data_ptr = c_loc(struct_obj%b_pole(lbound(struct_obj%b_pole, 1)))
      bounds(1) = int(lbound(struct_obj%b_pole, 1), c_int)
      bounds(2) = int(ubound(struct_obj%b_pole, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%a_pole_elec: 1D_PTR_real

  subroutine ele_struct_get_a_pole_elec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_a_pole_elec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%a_pole_elec) .and. is_contiguous(struct_obj%a_pole_elec)) then
      data_ptr = c_loc(struct_obj%a_pole_elec(lbound(struct_obj%a_pole_elec, 1)))
      bounds(1) = int(lbound(struct_obj%a_pole_elec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%a_pole_elec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%b_pole_elec: 1D_PTR_real

  subroutine ele_struct_get_b_pole_elec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_b_pole_elec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%b_pole_elec) .and. is_contiguous(struct_obj%b_pole_elec)) then
      data_ptr = c_loc(struct_obj%b_pole_elec(lbound(struct_obj%b_pole_elec, 1)))
      bounds(1) = int(lbound(struct_obj%b_pole_elec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%b_pole_elec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%custom: 1D_PTR_real

  subroutine ele_struct_get_custom_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ele_struct_get_custom_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%custom) .and. is_contiguous(struct_obj%custom)) then
      data_ptr = c_loc(struct_obj%custom(lbound(struct_obj%custom, 1)))
      bounds(1) = int(lbound(struct_obj%custom, 1), c_int)
      bounds(2) = int(ubound(struct_obj%custom, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%r: 3D_PTR_real

  subroutine ele_struct_get_r_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='ele_struct_get_r_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(6), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ele_struct), pointer :: struct_obj
    integer(c_int), dimension(3), intent(out) :: strides
    integer :: d1, d2
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%r) .and. is_contiguous(struct_obj%r)) then
      data_ptr = c_loc(struct_obj%r(lbound(struct_obj%r, 1), lbound(struct_obj%r, 2), lbound(struct_obj%r, 3)))
      bounds(1) = int(lbound(struct_obj%r, 1), c_int)
      bounds(2) = int(ubound(struct_obj%r, 1), c_int)
      bounds(3) = int(lbound(struct_obj%r, 2), c_int)
      bounds(4) = int(ubound(struct_obj%r, 2), c_int)
      bounds(5) = int(lbound(struct_obj%r, 3), c_int)
      bounds(6) = int(ubound(struct_obj%r, 3), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      d2 = bounds(4) - bounds(3) + 1
      strides(2) = d1
      strides(3) = d1 * d2
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ele_struct%key: 0D_NOT_integer

  subroutine ele_struct_get_key(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%key
  end subroutine


  subroutine ele_struct_set_key(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%key = value_in
  end subroutine

  ! ele_struct%sub_key: 0D_NOT_integer

  subroutine ele_struct_get_sub_key(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_sub_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sub_key
  end subroutine


  subroutine ele_struct_set_sub_key(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_sub_key')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sub_key = value_in
  end subroutine

  ! ele_struct%ix_ele: 0D_NOT_integer

  subroutine ele_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine ele_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! ele_struct%ix_branch: 0D_NOT_integer

  subroutine ele_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine ele_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! ele_struct%lord_status: 0D_NOT_integer

  subroutine ele_struct_get_lord_status(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_lord_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lord_status
  end subroutine


  subroutine ele_struct_set_lord_status(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_lord_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lord_status = value_in
  end subroutine

  ! ele_struct%n_slave: 0D_NOT_integer

  subroutine ele_struct_get_n_slave(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_slave
  end subroutine


  subroutine ele_struct_set_n_slave(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_slave = value_in
  end subroutine

  ! ele_struct%n_slave_field: 0D_NOT_integer

  subroutine ele_struct_get_n_slave_field(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_slave_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_slave_field
  end subroutine


  subroutine ele_struct_set_n_slave_field(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_slave_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_slave_field = value_in
  end subroutine

  ! ele_struct%ix1_slave: 0D_NOT_integer

  subroutine ele_struct_get_ix1_slave(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix1_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix1_slave
  end subroutine


  subroutine ele_struct_set_ix1_slave(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix1_slave')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix1_slave = value_in
  end subroutine

  ! ele_struct%slave_status: 0D_NOT_integer

  subroutine ele_struct_get_slave_status(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_slave_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%slave_status
  end subroutine


  subroutine ele_struct_set_slave_status(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_slave_status')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%slave_status = value_in
  end subroutine

  ! ele_struct%n_lord: 0D_NOT_integer

  subroutine ele_struct_get_n_lord(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_lord
  end subroutine


  subroutine ele_struct_set_n_lord(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_lord = value_in
  end subroutine

  ! ele_struct%n_lord_field: 0D_NOT_integer

  subroutine ele_struct_get_n_lord_field(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_lord_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_lord_field
  end subroutine


  subroutine ele_struct_set_n_lord_field(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_lord_field')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_lord_field = value_in
  end subroutine

  ! ele_struct%n_lord_ramper: 0D_NOT_integer

  subroutine ele_struct_get_n_lord_ramper(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_n_lord_ramper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_lord_ramper
  end subroutine


  subroutine ele_struct_set_n_lord_ramper(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_n_lord_ramper')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_lord_ramper = value_in
  end subroutine

  ! ele_struct%ic1_lord: 0D_NOT_integer

  subroutine ele_struct_get_ic1_lord(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ic1_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ic1_lord
  end subroutine


  subroutine ele_struct_set_ic1_lord(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ic1_lord')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ic1_lord = value_in
  end subroutine

  ! ele_struct%ix_pointer: 0D_NOT_integer

  subroutine ele_struct_get_ix_pointer(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ix_pointer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_pointer
  end subroutine


  subroutine ele_struct_set_ix_pointer(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ix_pointer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_pointer = value_in
  end subroutine

  ! ele_struct%ixx: 0D_NOT_integer

  subroutine ele_struct_get_ixx(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ixx
  end subroutine


  subroutine ele_struct_set_ixx(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ixx')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ixx = value_in
  end subroutine

  ! ele_struct%iyy: 0D_NOT_integer

  subroutine ele_struct_get_iyy(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_iyy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%iyy
  end subroutine


  subroutine ele_struct_set_iyy(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_iyy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%iyy = value_in
  end subroutine

  ! ele_struct%izz: 0D_NOT_integer

  subroutine ele_struct_get_izz(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_izz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%izz
  end subroutine


  subroutine ele_struct_set_izz(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_izz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%izz = value_in
  end subroutine

  ! ele_struct%mat6_calc_method: 0D_NOT_integer

  subroutine ele_struct_get_mat6_calc_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_mat6_calc_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mat6_calc_method
  end subroutine


  subroutine ele_struct_set_mat6_calc_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_mat6_calc_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mat6_calc_method = value_in
  end subroutine

  ! ele_struct%tracking_method: 0D_NOT_integer

  subroutine ele_struct_get_tracking_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tracking_method
  end subroutine


  subroutine ele_struct_set_tracking_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tracking_method = value_in
  end subroutine

  ! ele_struct%spin_tracking_method: 0D_NOT_integer

  subroutine ele_struct_get_spin_tracking_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_spin_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_tracking_method
  end subroutine


  subroutine ele_struct_set_spin_tracking_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_spin_tracking_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_tracking_method = value_in
  end subroutine

  ! ele_struct%csr_method: 0D_NOT_integer

  subroutine ele_struct_get_csr_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_csr_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%csr_method
  end subroutine


  subroutine ele_struct_set_csr_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_csr_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%csr_method = value_in
  end subroutine

  ! ele_struct%space_charge_method: 0D_NOT_integer

  subroutine ele_struct_get_space_charge_method(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_space_charge_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%space_charge_method
  end subroutine


  subroutine ele_struct_set_space_charge_method(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_space_charge_method')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%space_charge_method = value_in
  end subroutine

  ! ele_struct%ptc_integration_type: 0D_NOT_integer

  subroutine ele_struct_get_ptc_integration_type(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ptc_integration_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ptc_integration_type
  end subroutine


  subroutine ele_struct_set_ptc_integration_type(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ptc_integration_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ptc_integration_type = value_in
  end subroutine

  ! ele_struct%field_calc: 0D_NOT_integer

  subroutine ele_struct_get_field_calc(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_field_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_calc
  end subroutine


  subroutine ele_struct_set_field_calc(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_field_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_calc = value_in
  end subroutine

  ! ele_struct%aperture_at: 0D_NOT_integer

  subroutine ele_struct_get_aperture_at(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_aperture_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aperture_at
  end subroutine


  subroutine ele_struct_set_aperture_at(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_aperture_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aperture_at = value_in
  end subroutine

  ! ele_struct%aperture_type: 0D_NOT_integer

  subroutine ele_struct_get_aperture_type(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_aperture_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%aperture_type
  end subroutine


  subroutine ele_struct_set_aperture_type(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_aperture_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%aperture_type = value_in
  end subroutine

  ! ele_struct%ref_species: 0D_NOT_integer

  subroutine ele_struct_get_ref_species(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_ref_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_species
  end subroutine


  subroutine ele_struct_set_ref_species(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_ref_species')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_species = value_in
  end subroutine

  ! ele_struct%orientation: 0D_NOT_integer

  subroutine ele_struct_get_orientation(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_orientation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%orientation
  end subroutine


  subroutine ele_struct_set_orientation(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_orientation')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%orientation = value_in
  end subroutine

  ! ele_struct%symplectify: 0D_NOT_logical

  subroutine ele_struct_get_symplectify(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_symplectify')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%symplectify
  end subroutine


  subroutine ele_struct_set_symplectify(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_symplectify')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%symplectify = value_in
  end subroutine

  ! ele_struct%mode_flip: 0D_NOT_logical

  subroutine ele_struct_get_mode_flip(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_mode_flip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mode_flip
  end subroutine


  subroutine ele_struct_set_mode_flip(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_mode_flip')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mode_flip = value_in
  end subroutine

  ! ele_struct%multipoles_on: 0D_NOT_logical

  subroutine ele_struct_get_multipoles_on(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_multipoles_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%multipoles_on
  end subroutine


  subroutine ele_struct_set_multipoles_on(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_multipoles_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%multipoles_on = value_in
  end subroutine

  ! ele_struct%scale_multipoles: 0D_NOT_logical

  subroutine ele_struct_get_scale_multipoles(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_scale_multipoles')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%scale_multipoles
  end subroutine


  subroutine ele_struct_set_scale_multipoles(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_scale_multipoles')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%scale_multipoles = value_in
  end subroutine

  ! ele_struct%taylor_map_includes_offsets: 0D_NOT_logical

  subroutine ele_struct_get_taylor_map_includes_offsets(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_taylor_map_includes_offsets')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%taylor_map_includes_offsets
  end subroutine


  subroutine ele_struct_set_taylor_map_includes_offsets(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_taylor_map_includes_offsets')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%taylor_map_includes_offsets = value_in
  end subroutine

  ! ele_struct%field_master: 0D_NOT_logical

  subroutine ele_struct_get_field_master(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_field_master')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%field_master
  end subroutine


  subroutine ele_struct_set_field_master(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_field_master')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%field_master = value_in
  end subroutine

  ! ele_struct%is_on: 0D_NOT_logical

  subroutine ele_struct_get_is_on(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_on
  end subroutine


  subroutine ele_struct_set_is_on(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_on = value_in
  end subroutine

  ! ele_struct%logic: 0D_NOT_logical

  subroutine ele_struct_get_logic(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%logic
  end subroutine


  subroutine ele_struct_set_logic(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%logic = value_in
  end subroutine

  ! ele_struct%bmad_logic: 0D_NOT_logical

  subroutine ele_struct_get_bmad_logic(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_bmad_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%bmad_logic
  end subroutine


  subroutine ele_struct_set_bmad_logic(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_bmad_logic')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%bmad_logic = value_in
  end subroutine

  ! ele_struct%select: 0D_NOT_logical

  subroutine ele_struct_get_select(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_select')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%select
  end subroutine


  subroutine ele_struct_set_select(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_select')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%select = value_in
  end subroutine

  ! ele_struct%offset_moves_aperture: 0D_NOT_logical

  subroutine ele_struct_get_offset_moves_aperture(struct_obj_ptr, value_out) bind(c, name='ele_struct_get_offset_moves_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%offset_moves_aperture
  end subroutine


  subroutine ele_struct_set_offset_moves_aperture(struct_obj_ptr, value_in) bind(c, name='ele_struct_set_offset_moves_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%offset_moves_aperture = value_in
  end subroutine

  !! complex_taylor_term_struct

    function allocate_fortran_complex_taylor_term_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(complex_taylor_term_struct), pointer :: fptr
    type(complex_taylor_term_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_complex_taylor_term_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(complex_taylor_term_struct), pointer :: fptr
    type(complex_taylor_term_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_complex_taylor_term_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(complex_taylor_term_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! complex_taylor_term_struct%coef: 0D_NOT_complex

  subroutine complex_taylor_term_struct_get_coef(struct_obj_ptr, value_out) bind(c, name='complex_taylor_term_struct_get_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(complex_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%coef
  end subroutine


  subroutine complex_taylor_term_struct_set_coef(struct_obj_ptr, value_in) bind(c, name='complex_taylor_term_struct_set_coef')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(complex_taylor_term_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%coef = value_in
  end subroutine

  ! complex_taylor_term_struct%expn: 1D_NOT_integer

  subroutine complex_taylor_term_struct_get_expn_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='complex_taylor_term_struct_get_expn_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(complex_taylor_term_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%expn)) then
      data_ptr = c_loc(struct_obj%expn(lbound(struct_obj%expn, 1)))
      bounds(1) = int(lbound(struct_obj%expn, 1), c_int)
      bounds(2) = int(ubound(struct_obj%expn, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! complex_taylor_struct

    function allocate_fortran_complex_taylor_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(complex_taylor_struct), pointer :: fptr
    type(complex_taylor_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_complex_taylor_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(complex_taylor_struct), pointer :: fptr
    type(complex_taylor_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_complex_taylor_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(complex_taylor_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! complex_taylor_struct%ref: 0D_NOT_complex

  subroutine complex_taylor_struct_get_ref(struct_obj_ptr, value_out) bind(c, name='complex_taylor_struct_get_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(complex_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref
  end subroutine


  subroutine complex_taylor_struct_set_ref(struct_obj_ptr, value_in) bind(c, name='complex_taylor_struct_set_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(complex_taylor_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref = value_in
  end subroutine

  ! complex_taylor_struct%term: 1D_PTR_type

  subroutine complex_taylor_struct_get_term_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='complex_taylor_struct_get_term_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(complex_taylor_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%term) .and. is_contiguous(struct_obj%term)) then
      data_ptr = c_loc(struct_obj%term(lbound(struct_obj%term, 1)))
      bounds(1) = int(lbound(struct_obj%term, 1), c_int)
      bounds(2) = int(ubound(struct_obj%term, 1), c_int)
      
      el_size = int(storage_size(struct_obj%term(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! branch_struct

    function allocate_fortran_branch_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(branch_struct), pointer :: fptr
    type(branch_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_branch_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(branch_struct), pointer :: fptr
    type(branch_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! branch_struct%name: 0D_NOT_character

  subroutine branch_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='branch_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine branch_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='branch_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(branch_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! branch_struct%ix_branch: 0D_NOT_integer

  subroutine branch_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine branch_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! branch_struct%ix_from_branch: 0D_NOT_integer

  subroutine branch_struct_get_ix_from_branch(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_from_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_from_branch
  end subroutine


  subroutine branch_struct_set_ix_from_branch(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_from_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_from_branch = value_in
  end subroutine

  ! branch_struct%ix_from_ele: 0D_NOT_integer

  subroutine branch_struct_get_ix_from_ele(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_from_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_from_ele
  end subroutine


  subroutine branch_struct_set_ix_from_ele(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_from_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_from_ele = value_in
  end subroutine

  ! branch_struct%ix_to_ele: 0D_NOT_integer

  subroutine branch_struct_get_ix_to_ele(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_to_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_to_ele
  end subroutine


  subroutine branch_struct_set_ix_to_ele(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_to_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_to_ele = value_in
  end subroutine

  ! branch_struct%ix_fixer: 0D_NOT_integer

  subroutine branch_struct_get_ix_fixer(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_ix_fixer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_fixer
  end subroutine


  subroutine branch_struct_set_ix_fixer(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_ix_fixer')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_fixer = value_in
  end subroutine

  ! branch_struct%n_ele_track: 0D_NOT_integer

  subroutine branch_struct_get_n_ele_track(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ele_track
  end subroutine


  subroutine branch_struct_set_n_ele_track(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ele_track = value_in
  end subroutine

  ! branch_struct%n_ele_max: 0D_NOT_integer

  subroutine branch_struct_get_n_ele_max(struct_obj_ptr, value_out) bind(c, name='branch_struct_get_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ele_max
  end subroutine


  subroutine branch_struct_set_n_ele_max(struct_obj_ptr, value_in) bind(c, name='branch_struct_set_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ele_max = value_in
  end subroutine

  ! branch_struct%lat: 0D_PTR_type

  subroutine branch_struct_get_lat(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lat)) then
      ptr_out = c_loc(struct_obj%lat)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine branch_struct_set_lat(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%lat)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%lat = src_obj
    endif
  end subroutine

  ! branch_struct%a: 0D_NOT_type

  subroutine branch_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine branch_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! branch_struct%b: 0D_NOT_type

  subroutine branch_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine branch_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! branch_struct%z: 0D_NOT_type

  subroutine branch_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine branch_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! branch_struct%ele: 1D_PTR_type

  subroutine branch_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='branch_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! branch_struct%param: 0D_NOT_type

  subroutine branch_struct_get_param(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%param)
  end subroutine


  subroutine branch_struct_set_param(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(lat_param_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%param = src_obj
  end subroutine

  ! branch_struct%particle_start: 0D_NOT_type

  subroutine branch_struct_get_particle_start(struct_obj_ptr, ptr_out) bind(c, name='branch_struct_get_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%particle_start)
  end subroutine


  subroutine branch_struct_set_particle_start(struct_obj_ptr, src_ptr) bind(c, name='branch_struct_set_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(branch_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%particle_start = src_obj
  end subroutine

  ! branch_struct%wall3d: 1D_PTR_type

  subroutine branch_struct_get_wall3d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='branch_struct_get_wall3d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%wall3d) .and. is_contiguous(struct_obj%wall3d)) then
      data_ptr = c_loc(struct_obj%wall3d(lbound(struct_obj%wall3d, 1)))
      bounds(1) = int(lbound(struct_obj%wall3d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%wall3d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%wall3d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! lat_struct

    function allocate_fortran_lat_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(lat_struct), pointer :: fptr
    type(lat_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_lat_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(lat_struct), pointer :: fptr
    type(lat_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_lat_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! lat_struct%use_name: 0D_NOT_character

  subroutine lat_struct_get_use_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_use_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%use_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%use_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_use_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_use_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%use_name = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%lattice: 0D_NOT_character

  subroutine lat_struct_get_lattice_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_lattice_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%lattice)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%lattice), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_lattice(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%lattice = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%machine: 0D_NOT_character

  subroutine lat_struct_get_machine_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_machine_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%machine)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%machine), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_machine(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_machine')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%machine = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%input_file_name: 0D_NOT_character

  subroutine lat_struct_get_input_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_input_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%input_file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%input_file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_input_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_input_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%input_file_name = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%title: 0D_NOT_character

  subroutine lat_struct_get_title_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='lat_struct_get_title_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%title)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%title), c_int)
    is_allocated = .true.
  end subroutine


  subroutine lat_struct_set_title(struct_obj_ptr, str_ptr, str_len) bind(c, name='lat_struct_set_title')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(lat_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%title = str_in ! implicitly handles padding
  end subroutine

  ! lat_struct%print_str: 1D_ALLOC_character

  subroutine lat_struct_get_print_str_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='lat_struct_get_print_str_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%print_str)) then
      data_ptr = c_loc(struct_obj%print_str(lbound(struct_obj%print_str, 1)))
      bounds(1) = int(lbound(struct_obj%print_str, 1), c_int)
      bounds(2) = int(ubound(struct_obj%print_str, 1), c_int)
      str_len = int(len(struct_obj%print_str), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%constant: 1D_ALLOC_type

  subroutine lat_struct_get_constant_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_constant_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%constant) .and. is_contiguous(struct_obj%constant)) then
      data_ptr = c_loc(struct_obj%constant(lbound(struct_obj%constant, 1)))
      bounds(1) = int(lbound(struct_obj%constant, 1), c_int)
      bounds(2) = int(ubound(struct_obj%constant, 1), c_int)
      
      el_size = int(storage_size(struct_obj%constant(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%a: 0D_PTR_type

  subroutine lat_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%a)) then
      ptr_out = c_loc(struct_obj%a)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%a)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%a = src_obj
    endif
  end subroutine

  ! lat_struct%b: 0D_PTR_type

  subroutine lat_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%b)) then
      ptr_out = c_loc(struct_obj%b)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%b)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%b = src_obj
    endif
  end subroutine

  ! lat_struct%z: 0D_PTR_type

  subroutine lat_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%z)) then
      ptr_out = c_loc(struct_obj%z)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(mode_info_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%z)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%z = src_obj
    endif
  end subroutine

  ! lat_struct%param: 0D_PTR_type

  subroutine lat_struct_get_param(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%param)) then
      ptr_out = c_loc(struct_obj%param)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_param(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(lat_param_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%param)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%param = src_obj
    endif
  end subroutine

  ! lat_struct%lord_state: 0D_NOT_type

  subroutine lat_struct_get_lord_state(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_lord_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lord_state)
  end subroutine


  subroutine lat_struct_set_lord_state(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_lord_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(bookkeeping_state_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lord_state = src_obj
  end subroutine

  ! lat_struct%ele_init: 0D_NOT_type

  subroutine lat_struct_get_ele_init(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_ele_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_init)
  end subroutine


  subroutine lat_struct_set_ele_init(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_ele_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_init = src_obj
  end subroutine

  ! lat_struct%ele: 1D_PTR_type

  subroutine lat_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%branch: 1D_ALLOC_type

  subroutine lat_struct_get_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%branch) .and. is_contiguous(struct_obj%branch)) then
      data_ptr = c_loc(struct_obj%branch(lbound(struct_obj%branch, 1)))
      bounds(1) = int(lbound(struct_obj%branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%control: 1D_ALLOC_type

  subroutine lat_struct_get_control_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_struct_get_control_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%control) .and. is_contiguous(struct_obj%control)) then
      data_ptr = c_loc(struct_obj%control(lbound(struct_obj%control, 1)))
      bounds(1) = int(lbound(struct_obj%control, 1), c_int)
      bounds(2) = int(ubound(struct_obj%control, 1), c_int)
      
      el_size = int(storage_size(struct_obj%control(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%particle_start: 0D_PTR_type

  subroutine lat_struct_get_particle_start(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%particle_start)) then
      ptr_out = c_loc(struct_obj%particle_start)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_particle_start(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_particle_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%particle_start)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%particle_start = src_obj
    endif
  end subroutine

  ! lat_struct%beam_init: 0D_NOT_type

  subroutine lat_struct_get_beam_init(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init)
  end subroutine


  subroutine lat_struct_set_beam_init(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init = src_obj
  end subroutine

  ! lat_struct%pre_tracker: 0D_NOT_type

  subroutine lat_struct_get_pre_tracker(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_pre_tracker')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%pre_tracker)
  end subroutine


  subroutine lat_struct_set_pre_tracker(struct_obj_ptr, src_ptr) bind(c, name='lat_struct_set_pre_tracker')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(lat_struct), pointer :: struct_obj
    type(pre_tracker_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%pre_tracker = src_obj
  end subroutine

  ! lat_struct%custom: 1D_ALLOC_real

  subroutine lat_struct_get_custom_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='lat_struct_get_custom_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%custom) .and. is_contiguous(struct_obj%custom)) then
      data_ptr = c_loc(struct_obj%custom(lbound(struct_obj%custom, 1)))
      bounds(1) = int(lbound(struct_obj%custom, 1), c_int)
      bounds(2) = int(ubound(struct_obj%custom, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%version: 0D_NOT_integer

  subroutine lat_struct_get_version(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_version')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%version
  end subroutine


  subroutine lat_struct_set_version(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_version')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%version = value_in
  end subroutine

  ! lat_struct%n_ele_track: 0D_PTR_integer

  subroutine lat_struct_get_n_ele_track(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_track)) then
      ptr_out = c_loc(struct_obj%n_ele_track)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_n_ele_track(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_ele_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_track)) then
      struct_obj%n_ele_track = value_in
    endif
  end subroutine

  ! lat_struct%n_ele_max: 0D_PTR_integer

  subroutine lat_struct_get_n_ele_max(struct_obj_ptr, ptr_out) bind(c, name='lat_struct_get_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_max)) then
      ptr_out = c_loc(struct_obj%n_ele_max)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine lat_struct_set_n_ele_max(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_ele_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%n_ele_max)) then
      struct_obj%n_ele_max = value_in
    endif
  end subroutine

  ! lat_struct%n_control_max: 0D_NOT_integer

  subroutine lat_struct_get_n_control_max(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_n_control_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_control_max
  end subroutine


  subroutine lat_struct_set_n_control_max(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_control_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_control_max = value_in
  end subroutine

  ! lat_struct%n_ic_max: 0D_NOT_integer

  subroutine lat_struct_get_n_ic_max(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_n_ic_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_ic_max
  end subroutine


  subroutine lat_struct_set_n_ic_max(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_n_ic_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_ic_max = value_in
  end subroutine

  ! lat_struct%input_taylor_order: 0D_NOT_integer

  subroutine lat_struct_get_input_taylor_order(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_input_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%input_taylor_order
  end subroutine


  subroutine lat_struct_set_input_taylor_order(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_input_taylor_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%input_taylor_order = value_in
  end subroutine

  ! lat_struct%ic: 1D_ALLOC_integer

  subroutine lat_struct_get_ic_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='lat_struct_get_ic_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ic) .and. is_contiguous(struct_obj%ic)) then
      data_ptr = c_loc(struct_obj%ic(lbound(struct_obj%ic, 1)))
      bounds(1) = int(lbound(struct_obj%ic, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ic, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! lat_struct%photon_type: 0D_NOT_integer

  subroutine lat_struct_get_photon_type(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_photon_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%photon_type
  end subroutine


  subroutine lat_struct_set_photon_type(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_photon_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%photon_type = value_in
  end subroutine

  ! lat_struct%creation_hash: 0D_NOT_integer

  subroutine lat_struct_get_creation_hash(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_creation_hash')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%creation_hash
  end subroutine


  subroutine lat_struct_set_creation_hash(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_creation_hash')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%creation_hash = value_in
  end subroutine

  ! lat_struct%ramper_slave_bookkeeping: 0D_NOT_integer

  subroutine lat_struct_get_ramper_slave_bookkeeping(struct_obj_ptr, value_out) bind(c, name='lat_struct_get_ramper_slave_bookkeeping')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ramper_slave_bookkeeping
  end subroutine


  subroutine lat_struct_set_ramper_slave_bookkeeping(struct_obj_ptr, value_in) bind(c, name='lat_struct_set_ramper_slave_bookkeeping')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ramper_slave_bookkeeping = value_in
  end subroutine

  !! bunch_struct

    function allocate_fortran_bunch_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bunch_struct), pointer :: fptr
    type(bunch_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bunch_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bunch_struct), pointer :: fptr
    type(bunch_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bunch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bunch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bunch_struct%particle: 1D_ALLOC_type

  subroutine bunch_struct_get_particle_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bunch_struct_get_particle_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%particle) .and. is_contiguous(struct_obj%particle)) then
      data_ptr = c_loc(struct_obj%particle(lbound(struct_obj%particle, 1)))
      bounds(1) = int(lbound(struct_obj%particle, 1), c_int)
      bounds(2) = int(ubound(struct_obj%particle, 1), c_int)
      
      el_size = int(storage_size(struct_obj%particle(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_struct%ix_z: 1D_ALLOC_integer

  subroutine bunch_struct_get_ix_z_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bunch_struct_get_ix_z_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ix_z) .and. is_contiguous(struct_obj%ix_z)) then
      data_ptr = c_loc(struct_obj%ix_z(lbound(struct_obj%ix_z, 1)))
      bounds(1) = int(lbound(struct_obj%ix_z, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ix_z, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_struct%charge_tot: 0D_NOT_real

  subroutine bunch_struct_get_charge_tot(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_tot
  end subroutine


  subroutine bunch_struct_set_charge_tot(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_tot = value_in
  end subroutine

  ! bunch_struct%charge_live: 0D_NOT_real

  subroutine bunch_struct_get_charge_live(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_live
  end subroutine


  subroutine bunch_struct_set_charge_live(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_live = value_in
  end subroutine

  ! bunch_struct%z_center: 0D_NOT_real

  subroutine bunch_struct_get_z_center(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_z_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%z_center
  end subroutine


  subroutine bunch_struct_set_z_center(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_z_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%z_center = value_in
  end subroutine

  ! bunch_struct%t_center: 0D_NOT_real

  subroutine bunch_struct_get_t_center(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_t_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t_center
  end subroutine


  subroutine bunch_struct_set_t_center(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_t_center')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t_center = value_in
  end subroutine

  ! bunch_struct%t0: 0D_NOT_real

  subroutine bunch_struct_get_t0(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_t0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t0
  end subroutine


  subroutine bunch_struct_set_t0(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_t0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t0 = value_in
  end subroutine

  ! bunch_struct%drift_between_t_and_s: 0D_NOT_logical

  subroutine bunch_struct_get_drift_between_t_and_s(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_drift_between_t_and_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%drift_between_t_and_s
  end subroutine


  subroutine bunch_struct_set_drift_between_t_and_s(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_drift_between_t_and_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%drift_between_t_and_s = value_in
  end subroutine

  ! bunch_struct%ix_ele: 0D_NOT_integer

  subroutine bunch_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine bunch_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! bunch_struct%ix_bunch: 0D_NOT_integer

  subroutine bunch_struct_get_ix_bunch(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch
  end subroutine


  subroutine bunch_struct_set_ix_bunch(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch = value_in
  end subroutine

  ! bunch_struct%ix_turn: 0D_NOT_integer

  subroutine bunch_struct_get_ix_turn(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_turn
  end subroutine


  subroutine bunch_struct_set_ix_turn(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_ix_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_turn = value_in
  end subroutine

  ! bunch_struct%n_live: 0D_NOT_integer

  subroutine bunch_struct_get_n_live(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_n_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_live
  end subroutine


  subroutine bunch_struct_set_n_live(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_n_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_live = value_in
  end subroutine

  ! bunch_struct%n_good: 0D_NOT_integer

  subroutine bunch_struct_get_n_good(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_n_good')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_good
  end subroutine


  subroutine bunch_struct_set_n_good(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_n_good')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_good = value_in
  end subroutine

  ! bunch_struct%n_bad: 0D_NOT_integer

  subroutine bunch_struct_get_n_bad(struct_obj_ptr, value_out) bind(c, name='bunch_struct_get_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bad
  end subroutine


  subroutine bunch_struct_set_n_bad(struct_obj_ptr, value_in) bind(c, name='bunch_struct_set_n_bad')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bad = value_in
  end subroutine

  !! bunch_params_struct

    function allocate_fortran_bunch_params_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bunch_params_struct), pointer :: fptr
    type(bunch_params_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bunch_params_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bunch_params_struct), pointer :: fptr
    type(bunch_params_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bunch_params_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bunch_params_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bunch_params_struct%centroid: 0D_NOT_type

  subroutine bunch_params_struct_get_centroid(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_centroid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%centroid)
  end subroutine


  subroutine bunch_params_struct_set_centroid(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_centroid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%centroid = src_obj
  end subroutine

  ! bunch_params_struct%x: 0D_NOT_type

  subroutine bunch_params_struct_get_x(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%x)
  end subroutine


  subroutine bunch_params_struct_set_x(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%x = src_obj
  end subroutine

  ! bunch_params_struct%y: 0D_NOT_type

  subroutine bunch_params_struct_get_y(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%y)
  end subroutine


  subroutine bunch_params_struct_set_y(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%y = src_obj
  end subroutine

  ! bunch_params_struct%z: 0D_NOT_type

  subroutine bunch_params_struct_get_z(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%z)
  end subroutine


  subroutine bunch_params_struct_set_z(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_z')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%z = src_obj
  end subroutine

  ! bunch_params_struct%a: 0D_NOT_type

  subroutine bunch_params_struct_get_a(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%a)
  end subroutine


  subroutine bunch_params_struct_set_a(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_a')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%a = src_obj
  end subroutine

  ! bunch_params_struct%b: 0D_NOT_type

  subroutine bunch_params_struct_get_b(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%b)
  end subroutine


  subroutine bunch_params_struct_set_b(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_b')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%b = src_obj
  end subroutine

  ! bunch_params_struct%c: 0D_NOT_type

  subroutine bunch_params_struct_get_c(struct_obj_ptr, ptr_out) bind(c, name='bunch_params_struct_get_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%c)
  end subroutine


  subroutine bunch_params_struct_set_c(struct_obj_ptr, src_ptr) bind(c, name='bunch_params_struct_set_c')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bunch_params_struct), pointer :: struct_obj
    type(twiss_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%c = src_obj
  end subroutine

  ! bunch_params_struct%sigma: 2D_NOT_real

  subroutine bunch_params_struct_get_sigma_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='bunch_params_struct_get_sigma_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_params_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%sigma)) then
      data_ptr = c_loc(struct_obj%sigma(lbound(struct_obj%sigma, 1), lbound(struct_obj%sigma, 2)))
      bounds(1) = int(lbound(struct_obj%sigma, 1), c_int)
      bounds(2) = int(ubound(struct_obj%sigma, 1), c_int)
      bounds(3) = int(lbound(struct_obj%sigma, 2), c_int)
      bounds(4) = int(ubound(struct_obj%sigma, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_params_struct%rel_max: 1D_NOT_real

  subroutine bunch_params_struct_get_rel_max_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bunch_params_struct_get_rel_max_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_params_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%rel_max)) then
      data_ptr = c_loc(struct_obj%rel_max(lbound(struct_obj%rel_max, 1)))
      bounds(1) = int(lbound(struct_obj%rel_max, 1), c_int)
      bounds(2) = int(ubound(struct_obj%rel_max, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_params_struct%rel_min: 1D_NOT_real

  subroutine bunch_params_struct_get_rel_min_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='bunch_params_struct_get_rel_min_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_params_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%rel_min)) then
      data_ptr = c_loc(struct_obj%rel_min(lbound(struct_obj%rel_min, 1)))
      bounds(1) = int(lbound(struct_obj%rel_min, 1), c_int)
      bounds(2) = int(ubound(struct_obj%rel_min, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_params_struct%s: 0D_NOT_real

  subroutine bunch_params_struct_get_s(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine bunch_params_struct_set_s(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! bunch_params_struct%t: 0D_NOT_real

  subroutine bunch_params_struct_get_t(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%t
  end subroutine


  subroutine bunch_params_struct_set_t(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%t = value_in
  end subroutine

  ! bunch_params_struct%sigma_t: 0D_NOT_real

  subroutine bunch_params_struct_get_sigma_t(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_sigma_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_t
  end subroutine


  subroutine bunch_params_struct_set_sigma_t(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_sigma_t')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_t = value_in
  end subroutine

  ! bunch_params_struct%charge_live: 0D_NOT_real

  subroutine bunch_params_struct_get_charge_live(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_live
  end subroutine


  subroutine bunch_params_struct_set_charge_live(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_charge_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_live = value_in
  end subroutine

  ! bunch_params_struct%charge_tot: 0D_NOT_real

  subroutine bunch_params_struct_get_charge_tot(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%charge_tot
  end subroutine


  subroutine bunch_params_struct_set_charge_tot(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_charge_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%charge_tot = value_in
  end subroutine

  ! bunch_params_struct%n_particle_tot: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_particle_tot(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_particle_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle_tot
  end subroutine


  subroutine bunch_params_struct_set_n_particle_tot(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_particle_tot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle_tot = value_in
  end subroutine

  ! bunch_params_struct%n_particle_live: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_particle_live(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_particle_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle_live
  end subroutine


  subroutine bunch_params_struct_set_n_particle_live(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_particle_live')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle_live = value_in
  end subroutine

  ! bunch_params_struct%n_particle_lost_in_ele: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_particle_lost_in_ele(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_particle_lost_in_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_particle_lost_in_ele
  end subroutine


  subroutine bunch_params_struct_set_n_particle_lost_in_ele(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_particle_lost_in_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_particle_lost_in_ele = value_in
  end subroutine

  ! bunch_params_struct%n_good_steps: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_good_steps(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_good_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_good_steps
  end subroutine


  subroutine bunch_params_struct_set_n_good_steps(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_good_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_good_steps = value_in
  end subroutine

  ! bunch_params_struct%n_bad_steps: 0D_NOT_integer

  subroutine bunch_params_struct_get_n_bad_steps(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_n_bad_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_bad_steps
  end subroutine


  subroutine bunch_params_struct_set_n_bad_steps(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_n_bad_steps')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_bad_steps = value_in
  end subroutine

  ! bunch_params_struct%ix_ele: 0D_NOT_integer

  subroutine bunch_params_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine bunch_params_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! bunch_params_struct%location: 0D_NOT_integer

  subroutine bunch_params_struct_get_location(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%location
  end subroutine


  subroutine bunch_params_struct_set_location(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_location')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%location = value_in
  end subroutine

  ! bunch_params_struct%twiss_valid: 0D_NOT_logical

  subroutine bunch_params_struct_get_twiss_valid(struct_obj_ptr, value_out) bind(c, name='bunch_params_struct_get_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%twiss_valid
  end subroutine


  subroutine bunch_params_struct_set_twiss_valid(struct_obj_ptr, value_in) bind(c, name='bunch_params_struct_set_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(bunch_params_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%twiss_valid = value_in
  end subroutine

  !! beam_struct

    function allocate_fortran_beam_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(beam_struct), pointer :: fptr
    type(beam_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_beam_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(beam_struct), pointer :: fptr
    type(beam_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_beam_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(beam_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! beam_struct%bunch: 1D_ALLOC_type

  subroutine beam_struct_get_bunch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='beam_struct_get_bunch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(beam_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%bunch) .and. is_contiguous(struct_obj%bunch)) then
      data_ptr = c_loc(struct_obj%bunch(lbound(struct_obj%bunch, 1)))
      bounds(1) = int(lbound(struct_obj%bunch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! aperture_point_struct

    function allocate_fortran_aperture_point_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(aperture_point_struct), pointer :: fptr
    type(aperture_point_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_aperture_point_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(aperture_point_struct), pointer :: fptr
    type(aperture_point_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_aperture_point_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(aperture_point_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! aperture_point_struct%x: 0D_NOT_real

  subroutine aperture_point_struct_get_x(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x
  end subroutine


  subroutine aperture_point_struct_set_x(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_x')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x = value_in
  end subroutine

  ! aperture_point_struct%y: 0D_NOT_real

  subroutine aperture_point_struct_get_y(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y
  end subroutine


  subroutine aperture_point_struct_set_y(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_y')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y = value_in
  end subroutine

  ! aperture_point_struct%plane: 0D_NOT_integer

  subroutine aperture_point_struct_get_plane(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_plane')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%plane
  end subroutine


  subroutine aperture_point_struct_set_plane(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_plane')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%plane = value_in
  end subroutine

  ! aperture_point_struct%ix_ele: 0D_NOT_integer

  subroutine aperture_point_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine aperture_point_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! aperture_point_struct%i_turn: 0D_NOT_integer

  subroutine aperture_point_struct_get_i_turn(struct_obj_ptr, value_out) bind(c, name='aperture_point_struct_get_i_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%i_turn
  end subroutine


  subroutine aperture_point_struct_set_i_turn(struct_obj_ptr, value_in) bind(c, name='aperture_point_struct_set_i_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_point_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%i_turn = value_in
  end subroutine

  !! aperture_param_struct

    function allocate_fortran_aperture_param_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(aperture_param_struct), pointer :: fptr
    type(aperture_param_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_aperture_param_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(aperture_param_struct), pointer :: fptr
    type(aperture_param_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_aperture_param_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(aperture_param_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! aperture_param_struct%min_angle: 0D_NOT_real

  subroutine aperture_param_struct_get_min_angle(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_min_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%min_angle
  end subroutine


  subroutine aperture_param_struct_set_min_angle(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_min_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%min_angle = value_in
  end subroutine

  ! aperture_param_struct%max_angle: 0D_NOT_real

  subroutine aperture_param_struct_get_max_angle(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_max_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%max_angle
  end subroutine


  subroutine aperture_param_struct_set_max_angle(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_max_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%max_angle = value_in
  end subroutine

  ! aperture_param_struct%n_angle: 0D_NOT_integer

  subroutine aperture_param_struct_get_n_angle(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_n_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_angle
  end subroutine


  subroutine aperture_param_struct_set_n_angle(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_n_angle')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_angle = value_in
  end subroutine

  ! aperture_param_struct%n_turn: 0D_NOT_integer

  subroutine aperture_param_struct_get_n_turn(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_n_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_turn
  end subroutine


  subroutine aperture_param_struct_set_n_turn(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_n_turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_turn = value_in
  end subroutine

  ! aperture_param_struct%x_init: 0D_NOT_real

  subroutine aperture_param_struct_get_x_init(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_x_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%x_init
  end subroutine


  subroutine aperture_param_struct_set_x_init(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_x_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%x_init = value_in
  end subroutine

  ! aperture_param_struct%y_init: 0D_NOT_real

  subroutine aperture_param_struct_get_y_init(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_y_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%y_init
  end subroutine


  subroutine aperture_param_struct_set_y_init(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_y_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%y_init = value_in
  end subroutine

  ! aperture_param_struct%rel_accuracy: 0D_NOT_real

  subroutine aperture_param_struct_get_rel_accuracy(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_rel_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rel_accuracy
  end subroutine


  subroutine aperture_param_struct_set_rel_accuracy(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_rel_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rel_accuracy = value_in
  end subroutine

  ! aperture_param_struct%abs_accuracy: 0D_NOT_real

  subroutine aperture_param_struct_get_abs_accuracy(struct_obj_ptr, value_out) bind(c, name='aperture_param_struct_get_abs_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%abs_accuracy
  end subroutine


  subroutine aperture_param_struct_set_abs_accuracy(struct_obj_ptr, value_in) bind(c, name='aperture_param_struct_set_abs_accuracy')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%abs_accuracy = value_in
  end subroutine

  ! aperture_param_struct%start_ele: 0D_NOT_character

  subroutine aperture_param_struct_get_start_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='aperture_param_struct_get_start_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(aperture_param_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%start_ele)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%start_ele), c_int)
    is_allocated = .true.
  end subroutine


  subroutine aperture_param_struct_set_start_ele(struct_obj_ptr, str_ptr, str_len) bind(c, name='aperture_param_struct_set_start_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(aperture_param_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%start_ele = str_in ! implicitly handles padding
  end subroutine

  !! aperture_scan_struct

    function allocate_fortran_aperture_scan_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(aperture_scan_struct), pointer :: fptr
    type(aperture_scan_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_aperture_scan_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(aperture_scan_struct), pointer :: fptr
    type(aperture_scan_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_aperture_scan_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(aperture_scan_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! aperture_scan_struct%point: 1D_ALLOC_type

  subroutine aperture_scan_struct_get_point_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='aperture_scan_struct_get_point_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(aperture_scan_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%point) .and. is_contiguous(struct_obj%point)) then
      data_ptr = c_loc(struct_obj%point(lbound(struct_obj%point, 1)))
      bounds(1) = int(lbound(struct_obj%point, 1), c_int)
      bounds(2) = int(ubound(struct_obj%point, 1), c_int)
      
      el_size = int(storage_size(struct_obj%point(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! aperture_scan_struct%ref_orb: 0D_NOT_type

  subroutine aperture_scan_struct_get_ref_orb(struct_obj_ptr, ptr_out) bind(c, name='aperture_scan_struct_get_ref_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(aperture_scan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ref_orb)
  end subroutine


  subroutine aperture_scan_struct_set_ref_orb(struct_obj_ptr, src_ptr) bind(c, name='aperture_scan_struct_set_ref_orb')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(aperture_scan_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ref_orb = src_obj
  end subroutine

  ! aperture_scan_struct%pz_start: 0D_NOT_real

  subroutine aperture_scan_struct_get_pz_start(struct_obj_ptr, value_out) bind(c, name='aperture_scan_struct_get_pz_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(aperture_scan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pz_start
  end subroutine


  subroutine aperture_scan_struct_set_pz_start(struct_obj_ptr, value_in) bind(c, name='aperture_scan_struct_set_pz_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(aperture_scan_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pz_start = value_in
  end subroutine

  !! tao_spin_dn_dpz_struct

    function allocate_fortran_tao_spin_dn_dpz_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_spin_dn_dpz_struct), pointer :: fptr
    type(tao_spin_dn_dpz_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_spin_dn_dpz_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_spin_dn_dpz_struct), pointer :: fptr
    type(tao_spin_dn_dpz_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_spin_dn_dpz_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_dn_dpz_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_spin_dn_dpz_struct%vec: 1D_NOT_real

  subroutine tao_spin_dn_dpz_struct_get_vec_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_dn_dpz_struct_get_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_dn_dpz_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%vec)) then
      data_ptr = c_loc(struct_obj%vec(lbound(struct_obj%vec, 1)))
      bounds(1) = int(lbound(struct_obj%vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_dn_dpz_struct%partial: 2D_NOT_real

  subroutine tao_spin_dn_dpz_struct_get_partial_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_dn_dpz_struct_get_partial_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_dn_dpz_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%partial)) then
      data_ptr = c_loc(struct_obj%partial(lbound(struct_obj%partial, 1), lbound(struct_obj%partial, 2)))
      bounds(1) = int(lbound(struct_obj%partial, 1), c_int)
      bounds(2) = int(ubound(struct_obj%partial, 1), c_int)
      bounds(3) = int(lbound(struct_obj%partial, 2), c_int)
      bounds(4) = int(ubound(struct_obj%partial, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_dn_dpz_struct%partial2: 2D_NOT_real

  subroutine tao_spin_dn_dpz_struct_get_partial2_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_dn_dpz_struct_get_partial2_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_dn_dpz_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%partial2)) then
      data_ptr = c_loc(struct_obj%partial2(lbound(struct_obj%partial2, 1), lbound(struct_obj%partial2, 2)))
      bounds(1) = int(lbound(struct_obj%partial2, 1), c_int)
      bounds(2) = int(ubound(struct_obj%partial2, 1), c_int)
      bounds(3) = int(lbound(struct_obj%partial2, 2), c_int)
      bounds(4) = int(ubound(struct_obj%partial2, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! resonance_h_struct

    function allocate_fortran_resonance_h_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(resonance_h_struct), pointer :: fptr
    type(resonance_h_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_resonance_h_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(resonance_h_struct), pointer :: fptr
    type(resonance_h_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_resonance_h_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(resonance_h_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! resonance_h_struct%id: 0D_NOT_character

  subroutine resonance_h_struct_get_id_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='resonance_h_struct_get_id_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(resonance_h_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%id)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%id), c_int)
    is_allocated = .true.
  end subroutine


  subroutine resonance_h_struct_set_id(struct_obj_ptr, str_ptr, str_len) bind(c, name='resonance_h_struct_set_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(resonance_h_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%id = str_in ! implicitly handles padding
  end subroutine

  ! resonance_h_struct%c_val: 0D_NOT_complex

  subroutine resonance_h_struct_get_c_val(struct_obj_ptr, value_out) bind(c, name='resonance_h_struct_get_c_val')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(resonance_h_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%c_val
  end subroutine


  subroutine resonance_h_struct_set_c_val(struct_obj_ptr, value_in) bind(c, name='resonance_h_struct_set_c_val')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(resonance_h_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%c_val = value_in
  end subroutine

  !! spin_orbit_map1_struct

    function allocate_fortran_spin_orbit_map1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(spin_orbit_map1_struct), pointer :: fptr
    type(spin_orbit_map1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_spin_orbit_map1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(spin_orbit_map1_struct), pointer :: fptr
    type(spin_orbit_map1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_spin_orbit_map1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spin_orbit_map1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! spin_orbit_map1_struct%orb_mat: 2D_NOT_real

  subroutine spin_orbit_map1_struct_get_orb_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='spin_orbit_map1_struct_get_orb_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_orbit_map1_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%orb_mat)) then
      data_ptr = c_loc(struct_obj%orb_mat(lbound(struct_obj%orb_mat, 1), lbound(struct_obj%orb_mat, 2)))
      bounds(1) = int(lbound(struct_obj%orb_mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb_mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%orb_mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%orb_mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_orbit_map1_struct%vec0: 1D_NOT_real

  subroutine spin_orbit_map1_struct_get_vec0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_orbit_map1_struct_get_vec0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_orbit_map1_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%vec0)) then
      data_ptr = c_loc(struct_obj%vec0(lbound(struct_obj%vec0, 1)))
      bounds(1) = int(lbound(struct_obj%vec0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%vec0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_orbit_map1_struct%spin_q: 2D_NOT_real

  subroutine spin_orbit_map1_struct_get_spin_q_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='spin_orbit_map1_struct_get_spin_q_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_orbit_map1_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin_q)) then
      data_ptr = c_loc(struct_obj%spin_q(lbound(struct_obj%spin_q, 1), lbound(struct_obj%spin_q, 2)))
      bounds(1) = int(lbound(struct_obj%spin_q, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_q, 1), c_int)
      bounds(3) = int(lbound(struct_obj%spin_q, 2), c_int)
      bounds(4) = int(ubound(struct_obj%spin_q, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! spin_axis_struct

    function allocate_fortran_spin_axis_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(spin_axis_struct), pointer :: fptr
    type(spin_axis_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_spin_axis_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(spin_axis_struct), pointer :: fptr
    type(spin_axis_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_spin_axis_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(spin_axis_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! spin_axis_struct%l: 1D_NOT_real

  subroutine spin_axis_struct_get_l_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_axis_struct_get_l_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_axis_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%l)) then
      data_ptr = c_loc(struct_obj%l(lbound(struct_obj%l, 1)))
      bounds(1) = int(lbound(struct_obj%l, 1), c_int)
      bounds(2) = int(ubound(struct_obj%l, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_axis_struct%n0: 1D_NOT_real

  subroutine spin_axis_struct_get_n0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_axis_struct_get_n0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_axis_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%n0)) then
      data_ptr = c_loc(struct_obj%n0(lbound(struct_obj%n0, 1)))
      bounds(1) = int(lbound(struct_obj%n0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%n0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! spin_axis_struct%m: 1D_NOT_real

  subroutine spin_axis_struct_get_m_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='spin_axis_struct_get_m_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(spin_axis_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%m)) then
      data_ptr = c_loc(struct_obj%m(lbound(struct_obj%m, 1)))
      bounds(1) = int(lbound(struct_obj%m, 1), c_int)
      bounds(2) = int(ubound(struct_obj%m, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! ptc_normal_form_struct

    function allocate_fortran_ptc_normal_form_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(ptc_normal_form_struct), pointer :: fptr
    type(ptc_normal_form_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_ptc_normal_form_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(ptc_normal_form_struct), pointer :: fptr
    type(ptc_normal_form_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_ptc_normal_form_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(ptc_normal_form_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! ptc_normal_form_struct%ele_origin: 0D_PTR_type

  subroutine ptc_normal_form_struct_get_ele_origin(struct_obj_ptr, ptr_out) bind(c, name='ptc_normal_form_struct_get_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(ptc_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      ptr_out = c_loc(struct_obj%ele_origin)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine ptc_normal_form_struct_set_ele_origin(struct_obj_ptr, src_ptr) bind(c, name='ptc_normal_form_struct_set_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(ptc_normal_form_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ele_origin = src_obj
    endif
  end subroutine

  ! ptc_normal_form_struct%orb0: 1D_NOT_real

  subroutine ptc_normal_form_struct_get_orb0_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='ptc_normal_form_struct_get_orb0_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(ptc_normal_form_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%orb0)) then
      data_ptr = c_loc(struct_obj%orb0(lbound(struct_obj%orb0, 1)))
      bounds(1) = int(lbound(struct_obj%orb0, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb0, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! ptc_normal_form_struct%valid_map: 0D_NOT_logical

  subroutine ptc_normal_form_struct_get_valid_map(struct_obj_ptr, value_out) bind(c, name='ptc_normal_form_struct_get_valid_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(ptc_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid_map
  end subroutine


  subroutine ptc_normal_form_struct_set_valid_map(struct_obj_ptr, value_in) bind(c, name='ptc_normal_form_struct_set_valid_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(ptc_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid_map = value_in
  end subroutine

  !! bmad_normal_form_struct

    function allocate_fortran_bmad_normal_form_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bmad_normal_form_struct), pointer :: fptr
    type(bmad_normal_form_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bmad_normal_form_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bmad_normal_form_struct), pointer :: fptr
    type(bmad_normal_form_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bmad_normal_form_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bmad_normal_form_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bmad_normal_form_struct%ele_origin: 0D_PTR_type

  subroutine bmad_normal_form_struct_get_ele_origin(struct_obj_ptr, ptr_out) bind(c, name='bmad_normal_form_struct_get_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(bmad_normal_form_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      ptr_out = c_loc(struct_obj%ele_origin)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine bmad_normal_form_struct_set_ele_origin(struct_obj_ptr, src_ptr) bind(c, name='bmad_normal_form_struct_set_ele_origin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(bmad_normal_form_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%ele_origin)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%ele_origin = src_obj
    endif
  end subroutine

  ! bmad_normal_form_struct%M: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_M_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_M_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%M)) then
      data_ptr = c_loc(struct_obj%M(lbound(struct_obj%M, 1)))
      bounds(1) = int(lbound(struct_obj%M, 1), c_int)
      bounds(2) = int(ubound(struct_obj%M, 1), c_int)
      
      el_size = int(storage_size(struct_obj%M(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%A: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_A_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_A_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%A)) then
      data_ptr = c_loc(struct_obj%A(lbound(struct_obj%A, 1)))
      bounds(1) = int(lbound(struct_obj%A, 1), c_int)
      bounds(2) = int(ubound(struct_obj%A, 1), c_int)
      
      el_size = int(storage_size(struct_obj%A(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%A_inv: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_A_inv_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_A_inv_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%A_inv)) then
      data_ptr = c_loc(struct_obj%A_inv(lbound(struct_obj%A_inv, 1)))
      bounds(1) = int(lbound(struct_obj%A_inv, 1), c_int)
      bounds(2) = int(ubound(struct_obj%A_inv, 1), c_int)
      
      el_size = int(storage_size(struct_obj%A_inv(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%dhdj: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_dhdj_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_dhdj_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%dhdj)) then
      data_ptr = c_loc(struct_obj%dhdj(lbound(struct_obj%dhdj, 1)))
      bounds(1) = int(lbound(struct_obj%dhdj, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dhdj, 1), c_int)
      
      el_size = int(storage_size(struct_obj%dhdj(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%F: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_F_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_F_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%F)) then
      data_ptr = c_loc(struct_obj%F(lbound(struct_obj%F, 1)))
      bounds(1) = int(lbound(struct_obj%F, 1), c_int)
      bounds(2) = int(ubound(struct_obj%F, 1), c_int)
      
      el_size = int(storage_size(struct_obj%F(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%L: 1D_NOT_type

  subroutine bmad_normal_form_struct_get_L_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_L_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%L)) then
      data_ptr = c_loc(struct_obj%L(lbound(struct_obj%L, 1)))
      bounds(1) = int(lbound(struct_obj%L, 1), c_int)
      bounds(2) = int(ubound(struct_obj%L, 1), c_int)
      
      el_size = int(storage_size(struct_obj%L(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bmad_normal_form_struct%h: 1D_ALLOC_type

  subroutine bmad_normal_form_struct_get_h_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bmad_normal_form_struct_get_h_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bmad_normal_form_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%h) .and. is_contiguous(struct_obj%h)) then
      data_ptr = c_loc(struct_obj%h(lbound(struct_obj%h, 1)))
      bounds(1) = int(lbound(struct_obj%h, 1), c_int)
      bounds(2) = int(ubound(struct_obj%h, 1), c_int)
      
      el_size = int(storage_size(struct_obj%h(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! bunch_track_struct

    function allocate_fortran_bunch_track_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(bunch_track_struct), pointer :: fptr
    type(bunch_track_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_bunch_track_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(bunch_track_struct), pointer :: fptr
    type(bunch_track_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_bunch_track_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(bunch_track_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! bunch_track_struct%pt: 1D_ALLOC_type

  subroutine bunch_track_struct_get_pt_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='bunch_track_struct_get_pt_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(bunch_track_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pt) .and. is_contiguous(struct_obj%pt)) then
      data_ptr = c_loc(struct_obj%pt(lbound(struct_obj%pt, 1)))
      bounds(1) = int(lbound(struct_obj%pt, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pt, 1), c_int)
      
      el_size = int(storage_size(struct_obj%pt(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! bunch_track_struct%ds_save: 0D_NOT_real

  subroutine bunch_track_struct_get_ds_save(struct_obj_ptr, value_out) bind(c, name='bunch_track_struct_get_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ds_save
  end subroutine


  subroutine bunch_track_struct_set_ds_save(struct_obj_ptr, value_in) bind(c, name='bunch_track_struct_set_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ds_save = value_in
  end subroutine

  ! bunch_track_struct%n_pt: 0D_NOT_integer

  subroutine bunch_track_struct_get_n_pt(struct_obj_ptr, value_out) bind(c, name='bunch_track_struct_get_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_pt
  end subroutine


  subroutine bunch_track_struct_set_n_pt(struct_obj_ptr, value_in) bind(c, name='bunch_track_struct_set_n_pt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(bunch_track_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_pt = value_in
  end subroutine

  !! summation_rdt_struct

    function allocate_fortran_summation_rdt_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(summation_rdt_struct), pointer :: fptr
    type(summation_rdt_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_summation_rdt_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(summation_rdt_struct), pointer :: fptr
    type(summation_rdt_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_summation_rdt_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(summation_rdt_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! summation_rdt_struct%h11001: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h11001(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h11001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h11001
  end subroutine


  subroutine summation_rdt_struct_set_h11001(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h11001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h11001 = value_in
  end subroutine

  ! summation_rdt_struct%h00111: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00111(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00111')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00111
  end subroutine


  subroutine summation_rdt_struct_set_h00111(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00111')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00111 = value_in
  end subroutine

  ! summation_rdt_struct%h20001: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20001(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20001
  end subroutine


  subroutine summation_rdt_struct_set_h20001(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20001')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20001 = value_in
  end subroutine

  ! summation_rdt_struct%h00201: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00201(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00201')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00201
  end subroutine


  subroutine summation_rdt_struct_set_h00201(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00201')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00201 = value_in
  end subroutine

  ! summation_rdt_struct%h10002: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10002(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10002')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10002
  end subroutine


  subroutine summation_rdt_struct_set_h10002(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10002')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10002 = value_in
  end subroutine

  ! summation_rdt_struct%h21000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h21000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h21000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h21000
  end subroutine


  subroutine summation_rdt_struct_set_h21000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h21000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h21000 = value_in
  end subroutine

  ! summation_rdt_struct%h30000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h30000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h30000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h30000
  end subroutine


  subroutine summation_rdt_struct_set_h30000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h30000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h30000 = value_in
  end subroutine

  ! summation_rdt_struct%h10110: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10110(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10110
  end subroutine


  subroutine summation_rdt_struct_set_h10110(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10110 = value_in
  end subroutine

  ! summation_rdt_struct%h10020: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10020(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10020
  end subroutine


  subroutine summation_rdt_struct_set_h10020(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10020 = value_in
  end subroutine

  ! summation_rdt_struct%h10200: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h10200(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h10200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h10200
  end subroutine


  subroutine summation_rdt_struct_set_h10200(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h10200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h10200 = value_in
  end subroutine

  ! summation_rdt_struct%h31000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h31000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h31000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h31000
  end subroutine


  subroutine summation_rdt_struct_set_h31000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h31000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h31000 = value_in
  end subroutine

  ! summation_rdt_struct%h40000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h40000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h40000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h40000
  end subroutine


  subroutine summation_rdt_struct_set_h40000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h40000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h40000 = value_in
  end subroutine

  ! summation_rdt_struct%h20110: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20110(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20110
  end subroutine


  subroutine summation_rdt_struct_set_h20110(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20110 = value_in
  end subroutine

  ! summation_rdt_struct%h11200: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h11200(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h11200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h11200
  end subroutine


  subroutine summation_rdt_struct_set_h11200(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h11200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h11200 = value_in
  end subroutine

  ! summation_rdt_struct%h20020: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20020(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20020
  end subroutine


  subroutine summation_rdt_struct_set_h20020(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20020')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20020 = value_in
  end subroutine

  ! summation_rdt_struct%h20200: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h20200(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h20200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h20200
  end subroutine


  subroutine summation_rdt_struct_set_h20200(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h20200')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h20200 = value_in
  end subroutine

  ! summation_rdt_struct%h00310: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00310(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00310')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00310
  end subroutine


  subroutine summation_rdt_struct_set_h00310(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00310')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00310 = value_in
  end subroutine

  ! summation_rdt_struct%h00400: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00400(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00400')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00400
  end subroutine


  subroutine summation_rdt_struct_set_h00400(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00400')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00400 = value_in
  end subroutine

  ! summation_rdt_struct%h22000: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h22000(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h22000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h22000
  end subroutine


  subroutine summation_rdt_struct_set_h22000(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h22000')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h22000 = value_in
  end subroutine

  ! summation_rdt_struct%h00220: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h00220(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h00220')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h00220
  end subroutine


  subroutine summation_rdt_struct_set_h00220(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h00220')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h00220 = value_in
  end subroutine

  ! summation_rdt_struct%h11110: 0D_NOT_complex

  subroutine summation_rdt_struct_get_h11110(struct_obj_ptr, value_out) bind(c, name='summation_rdt_struct_get_h11110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(out) :: value_out
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%h11110
  end subroutine


  subroutine summation_rdt_struct_set_h11110(struct_obj_ptr, value_in) bind(c, name='summation_rdt_struct_set_h11110')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    complex(c_double_complex), intent(in), value :: value_in
    type(summation_rdt_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%h11110 = value_in
  end subroutine

  !! lat_ele_order1_struct

    function allocate_fortran_lat_ele_order1_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(lat_ele_order1_struct), pointer :: fptr
    type(lat_ele_order1_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_lat_ele_order1_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(lat_ele_order1_struct), pointer :: fptr
    type(lat_ele_order1_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_lat_ele_order1_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_order1_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! lat_ele_order1_struct%ix_branch: 0D_NOT_integer

  subroutine lat_ele_order1_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='lat_ele_order1_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine lat_ele_order1_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='lat_ele_order1_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! lat_ele_order1_struct%ix_order: 0D_NOT_integer

  subroutine lat_ele_order1_struct_get_ix_order(struct_obj_ptr, value_out) bind(c, name='lat_ele_order1_struct_get_ix_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_order
  end subroutine


  subroutine lat_ele_order1_struct_set_ix_order(struct_obj_ptr, value_in) bind(c, name='lat_ele_order1_struct_set_ix_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(lat_ele_order1_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_order = value_in
  end subroutine

  !! lat_ele_order_array_struct

    function allocate_fortran_lat_ele_order_array_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(lat_ele_order_array_struct), pointer :: fptr
    type(lat_ele_order_array_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_lat_ele_order_array_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(lat_ele_order_array_struct), pointer :: fptr
    type(lat_ele_order_array_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_lat_ele_order_array_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_order_array_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! lat_ele_order_array_struct%ele: 1D_ALLOC_type

  subroutine lat_ele_order_array_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_ele_order_array_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_ele_order_array_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_lat_sigma_struct

    function allocate_fortran_tao_lat_sigma_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_lat_sigma_struct), pointer :: fptr
    type(tao_lat_sigma_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_lat_sigma_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_lat_sigma_struct), pointer :: fptr
    type(tao_lat_sigma_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_lat_sigma_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_lat_sigma_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_lat_sigma_struct%mat: 2D_NOT_real

  subroutine tao_lat_sigma_struct_get_mat_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_lat_sigma_struct_get_mat_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lat_sigma_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%mat)) then
      data_ptr = c_loc(struct_obj%mat(lbound(struct_obj%mat, 1), lbound(struct_obj%mat, 2)))
      bounds(1) = int(lbound(struct_obj%mat, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! tao_spin_ele_struct

    function allocate_fortran_tao_spin_ele_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_spin_ele_struct), pointer :: fptr
    type(tao_spin_ele_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_spin_ele_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_spin_ele_struct), pointer :: fptr
    type(tao_spin_ele_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_spin_ele_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_ele_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_spin_ele_struct%dn_dpz: 0D_NOT_type

  subroutine tao_spin_ele_struct_get_dn_dpz(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_ele_struct_get_dn_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%dn_dpz)
  end subroutine


  subroutine tao_spin_ele_struct_set_dn_dpz(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_ele_struct_set_dn_dpz')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_ele_struct), pointer :: struct_obj
    type(tao_spin_dn_dpz_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%dn_dpz = src_obj
  end subroutine

  ! tao_spin_ele_struct%orb_eigen_val: 1D_NOT_real

  subroutine tao_spin_ele_struct_get_orb_eigen_val_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_ele_struct_get_orb_eigen_val_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_ele_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%orb_eigen_val)) then
      data_ptr = c_loc(struct_obj%orb_eigen_val(lbound(struct_obj%orb_eigen_val, 1)))
      bounds(1) = int(lbound(struct_obj%orb_eigen_val, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb_eigen_val, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_ele_struct%orb_eigen_vec: 2D_NOT_real

  subroutine tao_spin_ele_struct_get_orb_eigen_vec_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_ele_struct_get_orb_eigen_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%orb_eigen_vec)) then
      data_ptr = c_loc(struct_obj%orb_eigen_vec(lbound(struct_obj%orb_eigen_vec, 1), lbound(struct_obj%orb_eigen_vec, 2)))
      bounds(1) = int(lbound(struct_obj%orb_eigen_vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orb_eigen_vec, 1), c_int)
      bounds(3) = int(lbound(struct_obj%orb_eigen_vec, 2), c_int)
      bounds(4) = int(ubound(struct_obj%orb_eigen_vec, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_ele_struct%spin_eigen_vec: 2D_NOT_real

  subroutine tao_spin_ele_struct_get_spin_eigen_vec_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_ele_struct_get_spin_eigen_vec_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_ele_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%spin_eigen_vec)) then
      data_ptr = c_loc(struct_obj%spin_eigen_vec(lbound(struct_obj%spin_eigen_vec, 1), lbound(struct_obj%spin_eigen_vec, 2)))
      bounds(1) = int(lbound(struct_obj%spin_eigen_vec, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_eigen_vec, 1), c_int)
      bounds(3) = int(lbound(struct_obj%spin_eigen_vec, 2), c_int)
      bounds(4) = int(ubound(struct_obj%spin_eigen_vec, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_ele_struct%valid: 0D_NOT_logical

  subroutine tao_spin_ele_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_spin_ele_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_spin_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_spin_ele_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_spin_ele_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_spin_ele_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  !! tao_plot_cache_struct

    function allocate_fortran_tao_plot_cache_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_plot_cache_struct), pointer :: fptr
    type(tao_plot_cache_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_plot_cache_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_plot_cache_struct), pointer :: fptr
    type(tao_plot_cache_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_plot_cache_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_plot_cache_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_plot_cache_struct%ele_to_s: 0D_NOT_type

  subroutine tao_plot_cache_struct_get_ele_to_s(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_cache_struct_get_ele_to_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_to_s)
  end subroutine


  subroutine tao_plot_cache_struct_set_ele_to_s(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_cache_struct_set_ele_to_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_cache_struct), pointer :: struct_obj
    type(ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_to_s = src_obj
  end subroutine

  ! tao_plot_cache_struct%orbit: 0D_NOT_type

  subroutine tao_plot_cache_struct_get_orbit(struct_obj_ptr, ptr_out) bind(c, name='tao_plot_cache_struct_get_orbit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orbit)
  end subroutine


  subroutine tao_plot_cache_struct_set_orbit(struct_obj_ptr, src_ptr) bind(c, name='tao_plot_cache_struct_set_orbit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_plot_cache_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orbit = src_obj
  end subroutine

  ! tao_plot_cache_struct%err: 0D_NOT_logical

  subroutine tao_plot_cache_struct_get_err(struct_obj_ptr, value_out) bind(c, name='tao_plot_cache_struct_get_err')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%err
  end subroutine


  subroutine tao_plot_cache_struct_set_err(struct_obj_ptr, value_in) bind(c, name='tao_plot_cache_struct_set_err')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_plot_cache_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%err = value_in
  end subroutine

  !! tao_spin_polarization_struct

    function allocate_fortran_tao_spin_polarization_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_spin_polarization_struct), pointer :: fptr
    type(tao_spin_polarization_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_spin_polarization_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_spin_polarization_struct), pointer :: fptr
    type(tao_spin_polarization_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_spin_polarization_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_polarization_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_spin_polarization_struct%tune: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_tune(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%tune
  end subroutine


  subroutine tao_spin_polarization_struct_set_tune(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_tune')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%tune = value_in
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_st: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_st(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_pol_limit_st')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pol_limit_st
  end subroutine


  subroutine tao_spin_polarization_struct_set_pol_limit_st(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_pol_limit_st')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pol_limit_st = value_in
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_dk: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_dk(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_pol_limit_dk')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pol_limit_dk
  end subroutine


  subroutine tao_spin_polarization_struct_set_pol_limit_dk(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_pol_limit_dk')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pol_limit_dk = value_in
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_dk_partial: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_dk_partial_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_pol_limit_dk_partial_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%pol_limit_dk_partial)) then
      data_ptr = c_loc(struct_obj%pol_limit_dk_partial(lbound(struct_obj%pol_limit_dk_partial, 1)))
      bounds(1) = int(lbound(struct_obj%pol_limit_dk_partial, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pol_limit_dk_partial, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%pol_limit_dk_partial2: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_limit_dk_partial2_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_pol_limit_dk_partial2_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%pol_limit_dk_partial2)) then
      data_ptr = c_loc(struct_obj%pol_limit_dk_partial2(lbound(struct_obj%pol_limit_dk_partial2, 1)))
      bounds(1) = int(lbound(struct_obj%pol_limit_dk_partial2, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pol_limit_dk_partial2, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%pol_rate_bks: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_pol_rate_bks(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_pol_rate_bks')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%pol_rate_bks
  end subroutine


  subroutine tao_spin_polarization_struct_set_pol_rate_bks(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_pol_rate_bks')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%pol_rate_bks = value_in
  end subroutine

  ! tao_spin_polarization_struct%depol_rate: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_depol_rate(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_depol_rate')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%depol_rate
  end subroutine


  subroutine tao_spin_polarization_struct_set_depol_rate(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_depol_rate')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%depol_rate = value_in
  end subroutine

  ! tao_spin_polarization_struct%depol_rate_partial: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_depol_rate_partial_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_depol_rate_partial_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%depol_rate_partial)) then
      data_ptr = c_loc(struct_obj%depol_rate_partial(lbound(struct_obj%depol_rate_partial, 1)))
      bounds(1) = int(lbound(struct_obj%depol_rate_partial, 1), c_int)
      bounds(2) = int(ubound(struct_obj%depol_rate_partial, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%depol_rate_partial2: 1D_NOT_real

  subroutine tao_spin_polarization_struct_get_depol_rate_partial2_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_spin_polarization_struct_get_depol_rate_partial2_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%depol_rate_partial2)) then
      data_ptr = c_loc(struct_obj%depol_rate_partial2(lbound(struct_obj%depol_rate_partial2, 1)))
      bounds(1) = int(lbound(struct_obj%depol_rate_partial2, 1), c_int)
      bounds(2) = int(ubound(struct_obj%depol_rate_partial2, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_spin_polarization_struct%integral_bn: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_bn(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_bn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_bn
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_bn(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_bn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_bn = value_in
  end subroutine

  ! tao_spin_polarization_struct%integral_bdn: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_bdn(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_bdn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_bdn
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_bdn(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_bdn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_bdn = value_in
  end subroutine

  ! tao_spin_polarization_struct%integral_1ns: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_1ns(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_1ns')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_1ns
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_1ns(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_1ns')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_1ns = value_in
  end subroutine

  ! tao_spin_polarization_struct%integral_dn2: 0D_NOT_real

  subroutine tao_spin_polarization_struct_get_integral_dn2(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_integral_dn2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%integral_dn2
  end subroutine


  subroutine tao_spin_polarization_struct_set_integral_dn2(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_integral_dn2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%integral_dn2 = value_in
  end subroutine

  ! tao_spin_polarization_struct%valid: 0D_NOT_logical

  subroutine tao_spin_polarization_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_spin_polarization_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_spin_polarization_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_spin_polarization_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  ! tao_spin_polarization_struct%q_1turn: 0D_NOT_type

  subroutine tao_spin_polarization_struct_get_q_1turn(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_polarization_struct_get_q_1turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_polarization_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%q_1turn)
  end subroutine


  subroutine tao_spin_polarization_struct_set_q_1turn(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_polarization_struct_set_q_1turn')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_polarization_struct), pointer :: struct_obj
    type(spin_orbit_map1_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%q_1turn = src_obj
  end subroutine

  ! tao_spin_polarization_struct%q_ele: 1D_ALLOC_type

  subroutine tao_spin_polarization_struct_get_q_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_spin_polarization_struct_get_q_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_polarization_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%q_ele) .and. is_contiguous(struct_obj%q_ele)) then
      data_ptr = c_loc(struct_obj%q_ele(lbound(struct_obj%q_ele, 1)))
      bounds(1) = int(lbound(struct_obj%q_ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%q_ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%q_ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_lattice_branch_struct

    function allocate_fortran_tao_lattice_branch_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_lattice_branch_struct), pointer :: fptr
    type(tao_lattice_branch_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_lattice_branch_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_lattice_branch_struct), pointer :: fptr
    type(tao_lattice_branch_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_lattice_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_lattice_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_lattice_branch_struct%tao_lat: 0D_PTR_type

  subroutine tao_lattice_branch_struct_get_tao_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_tao_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%tao_lat)) then
      ptr_out = c_loc(struct_obj%tao_lat)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_lattice_branch_struct_set_tao_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_tao_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%tao_lat)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%tao_lat = src_obj
    endif
  end subroutine

  ! tao_lattice_branch_struct%lat_sigma: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_lat_sigma_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_lat_sigma_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%lat_sigma) .and. is_contiguous(struct_obj%lat_sigma)) then
      data_ptr = c_loc(struct_obj%lat_sigma(lbound(struct_obj%lat_sigma, 1)))
      bounds(1) = int(lbound(struct_obj%lat_sigma, 1), c_int)
      bounds(2) = int(ubound(struct_obj%lat_sigma, 1), c_int)
      
      el_size = int(storage_size(struct_obj%lat_sigma(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%spin_ele: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_spin_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_spin_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%spin_ele) .and. is_contiguous(struct_obj%spin_ele)) then
      data_ptr = c_loc(struct_obj%spin_ele(lbound(struct_obj%spin_ele, 1)))
      bounds(1) = int(lbound(struct_obj%spin_ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%spin_ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%spin_ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%bunch_params: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_bunch_params_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_bunch_params_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%bunch_params) .and. is_contiguous(struct_obj%bunch_params)) then
      data_ptr = c_loc(struct_obj%bunch_params(lbound(struct_obj%bunch_params, 1)))
      bounds(1) = int(lbound(struct_obj%bunch_params, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch_params, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch_params(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%bunch_params_comb: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_bunch_params_comb_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_bunch_params_comb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%bunch_params_comb) .and. is_contiguous(struct_obj%bunch_params_comb)) then
      data_ptr = c_loc(struct_obj%bunch_params_comb(lbound(struct_obj%bunch_params_comb, 1)))
      bounds(1) = int(lbound(struct_obj%bunch_params_comb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%bunch_params_comb, 1), c_int)
      
      el_size = int(storage_size(struct_obj%bunch_params_comb(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%orbit: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_orbit_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_orbit_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%orbit) .and. is_contiguous(struct_obj%orbit)) then
      data_ptr = c_loc(struct_obj%orbit(lbound(struct_obj%orbit, 1)))
      bounds(1) = int(lbound(struct_obj%orbit, 1), c_int)
      bounds(2) = int(ubound(struct_obj%orbit, 1), c_int)
      
      el_size = int(storage_size(struct_obj%orbit(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%plot_cache: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_plot_cache_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_plot_cache_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%plot_cache) .and. is_contiguous(struct_obj%plot_cache)) then
      data_ptr = c_loc(struct_obj%plot_cache(lbound(struct_obj%plot_cache, 1)))
      bounds(1) = int(lbound(struct_obj%plot_cache, 1), c_int)
      bounds(2) = int(ubound(struct_obj%plot_cache, 1), c_int)
      
      el_size = int(storage_size(struct_obj%plot_cache(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%spin: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_spin(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_spin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spin)
  end subroutine


  subroutine tao_lattice_branch_struct_set_spin(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_spin')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(tao_spin_polarization_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spin = src_obj
  end subroutine

  ! tao_lattice_branch_struct%srdt: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_srdt(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_srdt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%srdt)
  end subroutine


  subroutine tao_lattice_branch_struct_set_srdt(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_srdt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(summation_rdt_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%srdt = src_obj
  end subroutine

  ! tao_lattice_branch_struct%orb0: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_orb0(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_orb0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%orb0)
  end subroutine


  subroutine tao_lattice_branch_struct_set_orb0(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_orb0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(coord_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%orb0 = src_obj
  end subroutine

  ! tao_lattice_branch_struct%modes_ri: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_modes_ri(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_modes_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%modes_ri)
  end subroutine


  subroutine tao_lattice_branch_struct_set_modes_ri(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_modes_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(normal_modes_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%modes_ri = src_obj
  end subroutine

  ! tao_lattice_branch_struct%modes_6d: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_modes_6d(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_modes_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%modes_6d)
  end subroutine


  subroutine tao_lattice_branch_struct_set_modes_6d(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_modes_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(normal_modes_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%modes_6d = src_obj
  end subroutine

  ! tao_lattice_branch_struct%ptc_normal_form: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_ptc_normal_form(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_ptc_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ptc_normal_form)
  end subroutine


  subroutine tao_lattice_branch_struct_set_ptc_normal_form(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_ptc_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(ptc_normal_form_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ptc_normal_form = src_obj
  end subroutine

  ! tao_lattice_branch_struct%bmad_normal_form: 0D_NOT_type

  subroutine tao_lattice_branch_struct_get_bmad_normal_form(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_branch_struct_get_bmad_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%bmad_normal_form)
  end subroutine


  subroutine tao_lattice_branch_struct_set_bmad_normal_form(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_branch_struct_set_bmad_normal_form')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_branch_struct), pointer :: struct_obj
    type(bmad_normal_form_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%bmad_normal_form = src_obj
  end subroutine

  ! tao_lattice_branch_struct%high_E_orb: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_high_E_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_high_E_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%high_E_orb) .and. is_contiguous(struct_obj%high_E_orb)) then
      data_ptr = c_loc(struct_obj%high_E_orb(lbound(struct_obj%high_E_orb, 1)))
      bounds(1) = int(lbound(struct_obj%high_E_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%high_E_orb, 1), c_int)
      
      el_size = int(storage_size(struct_obj%high_E_orb(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%low_E_orb: 1D_ALLOC_type

  subroutine tao_lattice_branch_struct_get_low_E_orb_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_branch_struct_get_low_E_orb_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%low_E_orb) .and. is_contiguous(struct_obj%low_E_orb)) then
      data_ptr = c_loc(struct_obj%low_E_orb(lbound(struct_obj%low_E_orb, 1)))
      bounds(1) = int(lbound(struct_obj%low_E_orb, 1), c_int)
      bounds(2) = int(ubound(struct_obj%low_E_orb, 1), c_int)
      
      el_size = int(storage_size(struct_obj%low_E_orb(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_lattice_branch_struct%cache_x_min: 0D_NOT_real

  subroutine tao_lattice_branch_struct_get_cache_x_min(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_cache_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cache_x_min
  end subroutine


  subroutine tao_lattice_branch_struct_set_cache_x_min(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_cache_x_min')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cache_x_min = value_in
  end subroutine

  ! tao_lattice_branch_struct%cache_x_max: 0D_NOT_real

  subroutine tao_lattice_branch_struct_get_cache_x_max(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_cache_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cache_x_max
  end subroutine


  subroutine tao_lattice_branch_struct_set_cache_x_max(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_cache_x_max')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cache_x_max = value_in
  end subroutine

  ! tao_lattice_branch_struct%comb_ds_save: 0D_NOT_real

  subroutine tao_lattice_branch_struct_get_comb_ds_save(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_comb_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%comb_ds_save
  end subroutine


  subroutine tao_lattice_branch_struct_set_comb_ds_save(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_comb_ds_save')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%comb_ds_save = value_in
  end subroutine

  ! tao_lattice_branch_struct%track_state: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_track_state(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_track_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%track_state
  end subroutine


  subroutine tao_lattice_branch_struct_set_track_state(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_track_state')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%track_state = value_in
  end subroutine

  ! tao_lattice_branch_struct%cache_n_pts: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_cache_n_pts(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_cache_n_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%cache_n_pts
  end subroutine


  subroutine tao_lattice_branch_struct_set_cache_n_pts(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_cache_n_pts')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%cache_n_pts = value_in
  end subroutine

  ! tao_lattice_branch_struct%ix_rad_int_cache: 0D_NOT_integer

  subroutine tao_lattice_branch_struct_get_ix_rad_int_cache(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_ix_rad_int_cache')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_rad_int_cache
  end subroutine


  subroutine tao_lattice_branch_struct_set_ix_rad_int_cache(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_ix_rad_int_cache')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_rad_int_cache = value_in
  end subroutine

  ! tao_lattice_branch_struct%has_open_match_element: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_has_open_match_element(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_has_open_match_element')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%has_open_match_element
  end subroutine


  subroutine tao_lattice_branch_struct_set_has_open_match_element(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_has_open_match_element')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%has_open_match_element = value_in
  end subroutine

  ! tao_lattice_branch_struct%plot_cache_valid: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_plot_cache_valid(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_plot_cache_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%plot_cache_valid
  end subroutine


  subroutine tao_lattice_branch_struct_set_plot_cache_valid(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_plot_cache_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%plot_cache_valid = value_in
  end subroutine

  ! tao_lattice_branch_struct%spin_map_valid: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_spin_map_valid(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_spin_map_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_map_valid
  end subroutine


  subroutine tao_lattice_branch_struct_set_spin_map_valid(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_spin_map_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_map_valid = value_in
  end subroutine

  ! tao_lattice_branch_struct%twiss_valid: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_twiss_valid(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%twiss_valid
  end subroutine


  subroutine tao_lattice_branch_struct_set_twiss_valid(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_twiss_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%twiss_valid = value_in
  end subroutine

  ! tao_lattice_branch_struct%mode_flip_here: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_mode_flip_here(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_mode_flip_here')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%mode_flip_here
  end subroutine


  subroutine tao_lattice_branch_struct_set_mode_flip_here(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_mode_flip_here')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%mode_flip_here = value_in
  end subroutine

  ! tao_lattice_branch_struct%chrom_calc_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_chrom_calc_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_chrom_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom_calc_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_chrom_calc_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_chrom_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom_calc_ok = value_in
  end subroutine

  ! tao_lattice_branch_struct%rad_int_calc_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_rad_int_calc_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_rad_int_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_calc_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_rad_int_calc_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_rad_int_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_calc_ok = value_in
  end subroutine

  ! tao_lattice_branch_struct%emit_6d_calc_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_emit_6d_calc_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_emit_6d_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%emit_6d_calc_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_emit_6d_calc_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_emit_6d_calc_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%emit_6d_calc_ok = value_in
  end subroutine

  ! tao_lattice_branch_struct%sigma_track_ok: 0D_NOT_logical

  subroutine tao_lattice_branch_struct_get_sigma_track_ok(struct_obj_ptr, value_out) bind(c, name='tao_lattice_branch_struct_get_sigma_track_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%sigma_track_ok
  end subroutine


  subroutine tao_lattice_branch_struct_set_sigma_track_ok(struct_obj_ptr, value_in) bind(c, name='tao_lattice_branch_struct_set_sigma_track_ok')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_lattice_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%sigma_track_ok = value_in
  end subroutine

  !! tao_model_element_struct

    function allocate_fortran_tao_model_element_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_model_element_struct), pointer :: fptr
    type(tao_model_element_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_model_element_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_model_element_struct), pointer :: fptr
    type(tao_model_element_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_model_element_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_model_element_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_model_element_struct%beam: 0D_NOT_type

  subroutine tao_model_element_struct_get_beam(struct_obj_ptr, ptr_out) bind(c, name='tao_model_element_struct_get_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam)
  end subroutine


  subroutine tao_model_element_struct_set_beam(struct_obj_ptr, src_ptr) bind(c, name='tao_model_element_struct_set_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_model_element_struct), pointer :: struct_obj
    type(beam_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam = src_obj
  end subroutine

  ! tao_model_element_struct%save_beam_internally: 0D_NOT_logical

  subroutine tao_model_element_struct_get_save_beam_internally(struct_obj_ptr, value_out) bind(c, name='tao_model_element_struct_get_save_beam_internally')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%save_beam_internally
  end subroutine


  subroutine tao_model_element_struct_set_save_beam_internally(struct_obj_ptr, value_in) bind(c, name='tao_model_element_struct_set_save_beam_internally')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%save_beam_internally = value_in
  end subroutine

  ! tao_model_element_struct%save_beam_to_file: 0D_NOT_logical

  subroutine tao_model_element_struct_get_save_beam_to_file(struct_obj_ptr, value_out) bind(c, name='tao_model_element_struct_get_save_beam_to_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%save_beam_to_file
  end subroutine


  subroutine tao_model_element_struct_set_save_beam_to_file(struct_obj_ptr, value_in) bind(c, name='tao_model_element_struct_set_save_beam_to_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_model_element_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%save_beam_to_file = value_in
  end subroutine

  !! tao_beam_branch_struct

    function allocate_fortran_tao_beam_branch_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_beam_branch_struct), pointer :: fptr
    type(tao_beam_branch_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_beam_branch_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_beam_branch_struct), pointer :: fptr
    type(tao_beam_branch_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_beam_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_beam_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_beam_branch_struct%beam_at_start: 0D_NOT_type

  subroutine tao_beam_branch_struct_get_beam_at_start(struct_obj_ptr, ptr_out) bind(c, name='tao_beam_branch_struct_get_beam_at_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_at_start)
  end subroutine


  subroutine tao_beam_branch_struct_set_beam_at_start(struct_obj_ptr, src_ptr) bind(c, name='tao_beam_branch_struct_set_beam_at_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_beam_branch_struct), pointer :: struct_obj
    type(beam_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_at_start = src_obj
  end subroutine

  ! tao_beam_branch_struct%beam_init: 0D_NOT_type

  subroutine tao_beam_branch_struct_get_beam_init(struct_obj_ptr, ptr_out) bind(c, name='tao_beam_branch_struct_get_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init)
  end subroutine


  subroutine tao_beam_branch_struct_set_beam_init(struct_obj_ptr, src_ptr) bind(c, name='tao_beam_branch_struct_set_beam_init')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_beam_branch_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init = src_obj
  end subroutine

  ! tao_beam_branch_struct%beam_init_used: 0D_NOT_type

  subroutine tao_beam_branch_struct_get_beam_init_used(struct_obj_ptr, ptr_out) bind(c, name='tao_beam_branch_struct_get_beam_init_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam_init_used)
  end subroutine


  subroutine tao_beam_branch_struct_set_beam_init_used(struct_obj_ptr, src_ptr) bind(c, name='tao_beam_branch_struct_set_beam_init_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_beam_branch_struct), pointer :: struct_obj
    type(beam_init_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam_init_used = src_obj
  end subroutine

  ! tao_beam_branch_struct%init_starting_distribution: 0D_NOT_logical

  subroutine tao_beam_branch_struct_get_init_starting_distribution(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_init_starting_distribution')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%init_starting_distribution
  end subroutine


  subroutine tao_beam_branch_struct_set_init_starting_distribution(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_init_starting_distribution')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%init_starting_distribution = value_in
  end subroutine

  ! tao_beam_branch_struct%track_start: 0D_NOT_character

  subroutine tao_beam_branch_struct_get_track_start_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_branch_struct_get_track_start_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%track_start)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%track_start), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_branch_struct_set_track_start(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_branch_struct_set_track_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_branch_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%track_start = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_branch_struct%track_end: 0D_NOT_character

  subroutine tao_beam_branch_struct_get_track_end_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_branch_struct_get_track_end_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%track_end)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%track_end), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_branch_struct_set_track_end(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_branch_struct_set_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_branch_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%track_end = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_branch_struct%ix_branch: 0D_NOT_integer

  subroutine tao_beam_branch_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_beam_branch_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_beam_branch_struct%ix_track_start: 0D_NOT_integer

  subroutine tao_beam_branch_struct_get_ix_track_start(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_ix_track_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_track_start
  end subroutine


  subroutine tao_beam_branch_struct_set_ix_track_start(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_ix_track_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_track_start = value_in
  end subroutine

  ! tao_beam_branch_struct%ix_track_end: 0D_NOT_integer

  subroutine tao_beam_branch_struct_get_ix_track_end(struct_obj_ptr, value_out) bind(c, name='tao_beam_branch_struct_get_ix_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_track_end
  end subroutine


  subroutine tao_beam_branch_struct_set_ix_track_end(struct_obj_ptr, value_in) bind(c, name='tao_beam_branch_struct_set_ix_track_end')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_beam_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_track_end = value_in
  end subroutine

  !! tao_d1_data_struct

    function allocate_fortran_tao_d1_data_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_d1_data_struct), pointer :: fptr
    type(tao_d1_data_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_d1_data_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_d1_data_struct), pointer :: fptr
    type(tao_d1_data_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_d1_data_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_d1_data_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_d1_data_struct%name: 0D_NOT_character

  subroutine tao_d1_data_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d1_data_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d1_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d1_data_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d1_data_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d1_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d1_data_struct%d2: 0D_PTR_type

  subroutine tao_d1_data_struct_get_d2(struct_obj_ptr, ptr_out) bind(c, name='tao_d1_data_struct_get_d2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_d1_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d2)) then
      ptr_out = c_loc(struct_obj%d2)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_d1_data_struct_set_d2(struct_obj_ptr, src_ptr) bind(c, name='tao_d1_data_struct_set_d2')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_d1_data_struct), pointer :: struct_obj
    type(tao_d2_data_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d2)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%d2 = src_obj
    endif
  end subroutine

  ! tao_d1_data_struct%d: 1D_PTR_type

  subroutine tao_d1_data_struct_get_d_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_d1_data_struct_get_d_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d1_data_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%d) .and. is_contiguous(struct_obj%d)) then
      data_ptr = c_loc(struct_obj%d(lbound(struct_obj%d, 1)))
      bounds(1) = int(lbound(struct_obj%d, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d, 1), c_int)
      
      el_size = int(storage_size(struct_obj%d(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_lattice_struct

    function allocate_fortran_tao_lattice_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_lattice_struct), pointer :: fptr
    type(tao_lattice_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_lattice_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_lattice_struct), pointer :: fptr
    type(tao_lattice_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_lattice_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_lattice_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_lattice_struct%name: 0D_NOT_character

  subroutine tao_lattice_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_lattice_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_lattice_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_lattice_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_lattice_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_lattice_struct%lat: 0D_NOT_type

  subroutine tao_lattice_struct_get_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%lat)
  end subroutine


  subroutine tao_lattice_struct_set_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%lat = src_obj
  end subroutine

  ! tao_lattice_struct%high_E_lat: 0D_NOT_type

  subroutine tao_lattice_struct_get_high_E_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_high_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%high_E_lat)
  end subroutine


  subroutine tao_lattice_struct_set_high_E_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_high_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%high_E_lat = src_obj
  end subroutine

  ! tao_lattice_struct%low_E_lat: 0D_NOT_type

  subroutine tao_lattice_struct_get_low_E_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_low_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%low_E_lat)
  end subroutine


  subroutine tao_lattice_struct_set_low_E_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_low_E_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%low_E_lat = src_obj
  end subroutine

  ! tao_lattice_struct%rad_int_by_ele_ri: 0D_NOT_type

  subroutine tao_lattice_struct_get_rad_int_by_ele_ri(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_rad_int_by_ele_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rad_int_by_ele_ri)
  end subroutine


  subroutine tao_lattice_struct_set_rad_int_by_ele_ri(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_rad_int_by_ele_ri')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(rad_int_all_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rad_int_by_ele_ri = src_obj
  end subroutine

  ! tao_lattice_struct%rad_int_by_ele_6d: 0D_NOT_type

  subroutine tao_lattice_struct_get_rad_int_by_ele_6d(struct_obj_ptr, ptr_out) bind(c, name='tao_lattice_struct_get_rad_int_by_ele_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_lattice_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%rad_int_by_ele_6d)
  end subroutine


  subroutine tao_lattice_struct_set_rad_int_by_ele_6d(struct_obj_ptr, src_ptr) bind(c, name='tao_lattice_struct_set_rad_int_by_ele_6d')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_lattice_struct), pointer :: struct_obj
    type(rad_int_all_ele_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%rad_int_by_ele_6d = src_obj
  end subroutine

  ! tao_lattice_struct%tao_branch: 1D_ALLOC_type

  subroutine tao_lattice_struct_get_tao_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_lattice_struct_get_tao_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_lattice_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%tao_branch) .and. is_contiguous(struct_obj%tao_branch)) then
      data_ptr = c_loc(struct_obj%tao_branch(lbound(struct_obj%tao_branch, 1)))
      bounds(1) = int(lbound(struct_obj%tao_branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%tao_branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%tao_branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_beam_uni_struct

    function allocate_fortran_tao_beam_uni_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_beam_uni_struct), pointer :: fptr
    type(tao_beam_uni_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_beam_uni_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_beam_uni_struct), pointer :: fptr
    type(tao_beam_uni_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_beam_uni_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_beam_uni_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_beam_uni_struct%saved_at: 0D_NOT_character

  subroutine tao_beam_uni_struct_get_saved_at_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_uni_struct_get_saved_at_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%saved_at)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%saved_at), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_uni_struct_set_saved_at(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_uni_struct_set_saved_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_uni_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%saved_at = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_uni_struct%dump_file: 0D_NOT_character

  subroutine tao_beam_uni_struct_get_dump_file_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_uni_struct_get_dump_file_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%dump_file)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%dump_file), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_uni_struct_set_dump_file(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_uni_struct_set_dump_file')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_uni_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%dump_file = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_uni_struct%dump_at: 0D_NOT_character

  subroutine tao_beam_uni_struct_get_dump_at_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_beam_uni_struct_get_dump_at_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%dump_at)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%dump_at), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_beam_uni_struct_set_dump_at(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_beam_uni_struct_set_dump_at')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_beam_uni_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%dump_at = str_in ! implicitly handles padding
  end subroutine

  ! tao_beam_uni_struct%track_beam_in_universe: 0D_NOT_logical

  subroutine tao_beam_uni_struct_get_track_beam_in_universe(struct_obj_ptr, value_out) bind(c, name='tao_beam_uni_struct_get_track_beam_in_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%track_beam_in_universe
  end subroutine


  subroutine tao_beam_uni_struct_set_track_beam_in_universe(struct_obj_ptr, value_in) bind(c, name='tao_beam_uni_struct_set_track_beam_in_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%track_beam_in_universe = value_in
  end subroutine

  ! tao_beam_uni_struct%always_reinit: 0D_NOT_logical

  subroutine tao_beam_uni_struct_get_always_reinit(struct_obj_ptr, value_out) bind(c, name='tao_beam_uni_struct_get_always_reinit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%always_reinit
  end subroutine


  subroutine tao_beam_uni_struct_set_always_reinit(struct_obj_ptr, value_in) bind(c, name='tao_beam_uni_struct_set_always_reinit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_beam_uni_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%always_reinit = value_in
  end subroutine

  !! tao_dynamic_aperture_struct

    function allocate_fortran_tao_dynamic_aperture_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_dynamic_aperture_struct), pointer :: fptr
    type(tao_dynamic_aperture_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_dynamic_aperture_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_dynamic_aperture_struct), pointer :: fptr
    type(tao_dynamic_aperture_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_dynamic_aperture_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_dynamic_aperture_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_dynamic_aperture_struct%param: 0D_NOT_type

  subroutine tao_dynamic_aperture_struct_get_param(struct_obj_ptr, ptr_out) bind(c, name='tao_dynamic_aperture_struct_get_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%param)
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_param(struct_obj_ptr, src_ptr) bind(c, name='tao_dynamic_aperture_struct_set_param')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    type(aperture_param_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%param = src_obj
  end subroutine

  ! tao_dynamic_aperture_struct%scan: 1D_ALLOC_type

  subroutine tao_dynamic_aperture_struct_get_scan_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_dynamic_aperture_struct_get_scan_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%scan) .and. is_contiguous(struct_obj%scan)) then
      data_ptr = c_loc(struct_obj%scan(lbound(struct_obj%scan, 1)))
      bounds(1) = int(lbound(struct_obj%scan, 1), c_int)
      bounds(2) = int(ubound(struct_obj%scan, 1), c_int)
      
      el_size = int(storage_size(struct_obj%scan(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_dynamic_aperture_struct%pz: 1D_ALLOC_real

  subroutine tao_dynamic_aperture_struct_get_pz_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
        bind(c, name='tao_dynamic_aperture_struct_get_pz_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%pz) .and. is_contiguous(struct_obj%pz)) then
      data_ptr = c_loc(struct_obj%pz(lbound(struct_obj%pz, 1)))
      bounds(1) = int(lbound(struct_obj%pz, 1), c_int)
      bounds(2) = int(ubound(struct_obj%pz, 1), c_int)
      
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_dynamic_aperture_struct%ellipse_scale: 0D_NOT_real

  subroutine tao_dynamic_aperture_struct_get_ellipse_scale(struct_obj_ptr, value_out) bind(c, name='tao_dynamic_aperture_struct_get_ellipse_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ellipse_scale
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_ellipse_scale(struct_obj_ptr, value_in) bind(c, name='tao_dynamic_aperture_struct_set_ellipse_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ellipse_scale = value_in
  end subroutine

  ! tao_dynamic_aperture_struct%a_emit: 0D_NOT_real

  subroutine tao_dynamic_aperture_struct_get_a_emit(struct_obj_ptr, value_out) bind(c, name='tao_dynamic_aperture_struct_get_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_emit
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_a_emit(struct_obj_ptr, value_in) bind(c, name='tao_dynamic_aperture_struct_set_a_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_emit = value_in
  end subroutine

  ! tao_dynamic_aperture_struct%b_emit: 0D_NOT_real

  subroutine tao_dynamic_aperture_struct_get_b_emit(struct_obj_ptr, value_out) bind(c, name='tao_dynamic_aperture_struct_get_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_emit
  end subroutine


  subroutine tao_dynamic_aperture_struct_set_b_emit(struct_obj_ptr, value_in) bind(c, name='tao_dynamic_aperture_struct_set_b_emit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_dynamic_aperture_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_emit = value_in
  end subroutine

  !! tao_model_branch_struct

    function allocate_fortran_tao_model_branch_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_model_branch_struct), pointer :: fptr
    type(tao_model_branch_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_model_branch_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_model_branch_struct), pointer :: fptr
    type(tao_model_branch_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_model_branch_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_model_branch_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_model_branch_struct%ele: 1D_ALLOC_type

  subroutine tao_model_branch_struct_get_ele_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_model_branch_struct_get_ele_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_model_branch_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%ele) .and. is_contiguous(struct_obj%ele)) then
      data_ptr = c_loc(struct_obj%ele(lbound(struct_obj%ele, 1)))
      bounds(1) = int(lbound(struct_obj%ele, 1), c_int)
      bounds(2) = int(ubound(struct_obj%ele, 1), c_int)
      
      el_size = int(storage_size(struct_obj%ele(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_model_branch_struct%beam: 0D_NOT_type

  subroutine tao_model_branch_struct_get_beam(struct_obj_ptr, ptr_out) bind(c, name='tao_model_branch_struct_get_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_model_branch_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam)
  end subroutine


  subroutine tao_model_branch_struct_set_beam(struct_obj_ptr, src_ptr) bind(c, name='tao_model_branch_struct_set_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_model_branch_struct), pointer :: struct_obj
    type(tao_beam_branch_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam = src_obj
  end subroutine

  !! tao_d2_data_struct

    function allocate_fortran_tao_d2_data_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_d2_data_struct), pointer :: fptr
    type(tao_d2_data_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_d2_data_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_d2_data_struct), pointer :: fptr
    type(tao_d2_data_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_d2_data_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_d2_data_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_d2_data_struct%name: 0D_NOT_character

  subroutine tao_d2_data_struct_get_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%data_file_name: 0D_NOT_character

  subroutine tao_d2_data_struct_get_data_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_data_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_data_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_data_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_file_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%ref_file_name: 0D_NOT_character

  subroutine tao_d2_data_struct_get_ref_file_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_ref_file_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ref_file_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ref_file_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_ref_file_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_ref_file_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ref_file_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%data_date: 0D_NOT_character

  subroutine tao_d2_data_struct_get_data_date_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_data_date_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_date)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_date), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_data_date(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_data_date')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_date = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%ref_date: 0D_NOT_character

  subroutine tao_d2_data_struct_get_ref_date_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_d2_data_struct_get_ref_date_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ref_date)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ref_date), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_d2_data_struct_set_ref_date(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_d2_data_struct_set_ref_date')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_d2_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ref_date = str_in ! implicitly handles padding
  end subroutine

  ! tao_d2_data_struct%descrip: 1D_NOT_character

  subroutine tao_d2_data_struct_get_descrip_info(struct_obj_ptr, data_ptr, bounds, str_len, is_allocated) &
      bind(c, name='tao_d2_data_struct_get_descrip_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true.) then
      data_ptr = c_loc(struct_obj%descrip(lbound(struct_obj%descrip, 1)))
      bounds(1) = int(lbound(struct_obj%descrip, 1), c_int)
      bounds(2) = int(ubound(struct_obj%descrip, 1), c_int)
      str_len = int(len(struct_obj%descrip), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_d2_data_struct%d1: 1D_ALLOC_type

  subroutine tao_d2_data_struct_get_d1_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_d2_data_struct_get_d1_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_d2_data_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%d1) .and. is_contiguous(struct_obj%d1)) then
      data_ptr = c_loc(struct_obj%d1(lbound(struct_obj%d1, 1)))
      bounds(1) = int(lbound(struct_obj%d1, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d1, 1), c_int)
      
      el_size = int(storage_size(struct_obj%d1(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_d2_data_struct%ix_universe: 0D_NOT_integer

  subroutine tao_d2_data_struct_get_ix_universe(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_universe
  end subroutine


  subroutine tao_d2_data_struct_set_ix_universe(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ix_universe')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_universe = value_in
  end subroutine

  ! tao_d2_data_struct%ix_d2_data: 0D_NOT_integer

  subroutine tao_d2_data_struct_get_ix_d2_data(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ix_d2_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_d2_data
  end subroutine


  subroutine tao_d2_data_struct_set_ix_d2_data(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ix_d2_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_d2_data = value_in
  end subroutine

  ! tao_d2_data_struct%ix_ref: 0D_NOT_integer

  subroutine tao_d2_data_struct_get_ix_ref(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ref
  end subroutine


  subroutine tao_d2_data_struct_set_ix_ref(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ref = value_in
  end subroutine

  ! tao_d2_data_struct%data_read_in: 0D_NOT_logical

  subroutine tao_d2_data_struct_get_data_read_in(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_data_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%data_read_in
  end subroutine


  subroutine tao_d2_data_struct_set_data_read_in(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_data_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%data_read_in = value_in
  end subroutine

  ! tao_d2_data_struct%ref_read_in: 0D_NOT_logical

  subroutine tao_d2_data_struct_get_ref_read_in(struct_obj_ptr, value_out) bind(c, name='tao_d2_data_struct_get_ref_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_read_in
  end subroutine


  subroutine tao_d2_data_struct_set_ref_read_in(struct_obj_ptr, value_in) bind(c, name='tao_d2_data_struct_set_ref_read_in')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_d2_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_read_in = value_in
  end subroutine

  !! tao_spin_map_struct

    function allocate_fortran_tao_spin_map_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_spin_map_struct), pointer :: fptr
    type(tao_spin_map_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_spin_map_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_spin_map_struct), pointer :: fptr
    type(tao_spin_map_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_spin_map_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_spin_map_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_spin_map_struct%valid: 0D_NOT_logical

  subroutine tao_spin_map_struct_get_valid(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%valid
  end subroutine


  subroutine tao_spin_map_struct_set_valid(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_valid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%valid = value_in
  end subroutine

  ! tao_spin_map_struct%map1: 0D_NOT_type

  subroutine tao_spin_map_struct_get_map1(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_map1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%map1)
  end subroutine


  subroutine tao_spin_map_struct_set_map1(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_map1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_orbit_map1_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%map1 = src_obj
  end subroutine

  ! tao_spin_map_struct%axis_input: 0D_NOT_type

  subroutine tao_spin_map_struct_get_axis_input(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_axis_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%axis_input)
  end subroutine


  subroutine tao_spin_map_struct_set_axis_input(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_axis_input')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%axis_input = src_obj
  end subroutine

  ! tao_spin_map_struct%axis0: 0D_NOT_type

  subroutine tao_spin_map_struct_get_axis0(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_axis0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%axis0)
  end subroutine


  subroutine tao_spin_map_struct_set_axis0(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_axis0')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%axis0 = src_obj
  end subroutine

  ! tao_spin_map_struct%axis1: 0D_NOT_type

  subroutine tao_spin_map_struct_get_axis1(struct_obj_ptr, ptr_out) bind(c, name='tao_spin_map_struct_get_axis1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%axis1)
  end subroutine


  subroutine tao_spin_map_struct_set_axis1(struct_obj_ptr, src_ptr) bind(c, name='tao_spin_map_struct_set_axis1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_spin_map_struct), pointer :: struct_obj
    type(spin_axis_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%axis1 = src_obj
  end subroutine

  ! tao_spin_map_struct%ix_ele: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine tao_spin_map_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! tao_spin_map_struct%ix_ref: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_ref(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ref
  end subroutine


  subroutine tao_spin_map_struct_set_ix_ref(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ref = value_in
  end subroutine

  ! tao_spin_map_struct%ix_uni: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_spin_map_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_spin_map_struct%ix_branch: 0D_NOT_integer

  subroutine tao_spin_map_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_spin_map_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_spin_map_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_spin_map_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_spin_map_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_spin_map_struct%mat8: 2D_NOT_real

  subroutine tao_spin_map_struct_get_mat8_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_spin_map_struct_get_mat8_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_spin_map_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (.true. .and. is_contiguous(struct_obj%mat8)) then
      data_ptr = c_loc(struct_obj%mat8(lbound(struct_obj%mat8, 1), lbound(struct_obj%mat8, 2)))
      bounds(1) = int(lbound(struct_obj%mat8, 1), c_int)
      bounds(2) = int(ubound(struct_obj%mat8, 1), c_int)
      bounds(3) = int(lbound(struct_obj%mat8, 2), c_int)
      bounds(4) = int(ubound(struct_obj%mat8, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  !! tao_data_struct

    function allocate_fortran_tao_data_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_data_struct), pointer :: fptr
    type(tao_data_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_data_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_data_struct), pointer :: fptr
    type(tao_data_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_data_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_data_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_data_struct%ele_name: 0D_NOT_character

  subroutine tao_data_struct_get_ele_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_ele_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_ele_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_ele_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%ele_start_name: 0D_NOT_character

  subroutine tao_data_struct_get_ele_start_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_ele_start_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_start_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_start_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_ele_start_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_ele_start_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_start_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%ele_ref_name: 0D_NOT_character

  subroutine tao_data_struct_get_ele_ref_name_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_ele_ref_name_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%ele_ref_name)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%ele_ref_name), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_ele_ref_name(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_ele_ref_name')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%ele_ref_name = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%data_type: 0D_ALLOC_character

  subroutine tao_data_struct_get_data_type_info(struct_obj_ptr, data_ptr, str_len, is_allocated) &
    bind(c, name='tao_data_struct_get_data_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), intent(out) :: str_len
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%data_type)) then
      data_ptr = c_loc(struct_obj%data_type)
      str_len = int(len(struct_obj%data_type), c_int)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      str_len = 0
      is_allocated = .false.
    endif
  end subroutine


  subroutine tao_data_struct_set_data_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_data_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: temp_str
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%data_type)) deallocate(struct_obj%data_type)
    
    if (str_len > 0) then
       call c_f_pointer(str_ptr, temp_str)
       allocate(struct_obj%data_type, source=temp_str)
       struct_obj%data_type = temp_str(1:str_len)
    endif
  end subroutine

  ! tao_data_struct%merit_type: 0D_NOT_character

  subroutine tao_data_struct_get_merit_type_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_merit_type_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%merit_type)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%merit_type), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_merit_type(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_merit_type')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%merit_type = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%id: 0D_NOT_character

  subroutine tao_data_struct_get_id_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_id_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%id)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%id), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_id(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_id')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%id = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%data_source: 0D_NOT_character

  subroutine tao_data_struct_get_data_source_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_data_source_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%data_source)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%data_source), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_data_source(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_data_source')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%data_source = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%why_invalid: 0D_NOT_character

  subroutine tao_data_struct_get_why_invalid_info(struct_obj_ptr, data_ptr, bounds, is_allocated) &
    bind(c, name='tao_data_struct_get_why_invalid_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    data_ptr = c_loc(struct_obj%why_invalid)
    bounds(1) = 1_c_int
    bounds(2) = int(len_trim(struct_obj%why_invalid), c_int)
    is_allocated = .true.
  end subroutine


  subroutine tao_data_struct_set_why_invalid(struct_obj_ptr, str_ptr, str_len) bind(c, name='tao_data_struct_set_why_invalid')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: str_ptr
    integer(c_int), intent(in), value :: str_len
    type(tao_data_struct), pointer :: struct_obj
    character(len=str_len), pointer :: str_in
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(str_ptr, str_in)
    struct_obj%why_invalid = str_in ! implicitly handles padding
  end subroutine

  ! tao_data_struct%ix_uni: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_data_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_data_struct%ix_bunch: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_bunch(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_bunch
  end subroutine


  subroutine tao_data_struct_set_ix_bunch(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_bunch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_bunch = value_in
  end subroutine

  ! tao_data_struct%ix_branch: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_branch(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_branch
  end subroutine


  subroutine tao_data_struct_set_ix_branch(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_branch')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_branch = value_in
  end subroutine

  ! tao_data_struct%ix_ele: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele
  end subroutine


  subroutine tao_data_struct_set_ix_ele(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele = value_in
  end subroutine

  ! tao_data_struct%ix_ele_start: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele_start(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_start
  end subroutine


  subroutine tao_data_struct_set_ix_ele_start(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele_start')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_start = value_in
  end subroutine

  ! tao_data_struct%ix_ele_ref: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele_ref(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_ref
  end subroutine


  subroutine tao_data_struct_set_ix_ele_ref(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_ref = value_in
  end subroutine

  ! tao_data_struct%ix_ele_merit: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_ele_merit(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_ele_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_ele_merit
  end subroutine


  subroutine tao_data_struct_set_ix_ele_merit(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_ele_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_ele_merit = value_in
  end subroutine

  ! tao_data_struct%ix_d1: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_d1(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_d1
  end subroutine


  subroutine tao_data_struct_set_ix_d1(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_d1 = value_in
  end subroutine

  ! tao_data_struct%ix_data: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_data(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_data
  end subroutine


  subroutine tao_data_struct_set_ix_data(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_data = value_in
  end subroutine

  ! tao_data_struct%ix_dModel: 0D_NOT_integer

  subroutine tao_data_struct_get_ix_dModel(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ix_dModel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_dModel
  end subroutine


  subroutine tao_data_struct_set_ix_dModel(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ix_dModel')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_dModel = value_in
  end subroutine

  ! tao_data_struct%eval_point: 0D_NOT_integer

  subroutine tao_data_struct_get_eval_point(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_eval_point')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%eval_point
  end subroutine


  subroutine tao_data_struct_set_eval_point(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_eval_point')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%eval_point = value_in
  end subroutine

  ! tao_data_struct%meas_value: 0D_NOT_real

  subroutine tao_data_struct_get_meas_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_meas_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%meas_value
  end subroutine


  subroutine tao_data_struct_set_meas_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_meas_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%meas_value = value_in
  end subroutine

  ! tao_data_struct%ref_value: 0D_NOT_real

  subroutine tao_data_struct_get_ref_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_ref_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ref_value
  end subroutine


  subroutine tao_data_struct_set_ref_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_ref_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ref_value = value_in
  end subroutine

  ! tao_data_struct%model_value: 0D_NOT_real

  subroutine tao_data_struct_get_model_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%model_value
  end subroutine


  subroutine tao_data_struct_set_model_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_model_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%model_value = value_in
  end subroutine

  ! tao_data_struct%design_value: 0D_NOT_real

  subroutine tao_data_struct_get_design_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_design_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%design_value
  end subroutine


  subroutine tao_data_struct_set_design_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_design_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%design_value = value_in
  end subroutine

  ! tao_data_struct%old_value: 0D_NOT_real

  subroutine tao_data_struct_get_old_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%old_value
  end subroutine


  subroutine tao_data_struct_set_old_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_old_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%old_value = value_in
  end subroutine

  ! tao_data_struct%base_value: 0D_NOT_real

  subroutine tao_data_struct_get_base_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%base_value
  end subroutine


  subroutine tao_data_struct_set_base_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_base_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%base_value = value_in
  end subroutine

  ! tao_data_struct%error_rms: 0D_NOT_real

  subroutine tao_data_struct_get_error_rms(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_error_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%error_rms
  end subroutine


  subroutine tao_data_struct_set_error_rms(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_error_rms')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%error_rms = value_in
  end subroutine

  ! tao_data_struct%delta_merit: 0D_NOT_real

  subroutine tao_data_struct_get_delta_merit(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_delta_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%delta_merit
  end subroutine


  subroutine tao_data_struct_set_delta_merit(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_delta_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%delta_merit = value_in
  end subroutine

  ! tao_data_struct%weight: 0D_NOT_real

  subroutine tao_data_struct_get_weight(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_weight')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%weight
  end subroutine


  subroutine tao_data_struct_set_weight(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_weight')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%weight = value_in
  end subroutine

  ! tao_data_struct%invalid_value: 0D_NOT_real

  subroutine tao_data_struct_get_invalid_value(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_invalid_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%invalid_value
  end subroutine


  subroutine tao_data_struct_set_invalid_value(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_invalid_value')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%invalid_value = value_in
  end subroutine

  ! tao_data_struct%merit: 0D_NOT_real

  subroutine tao_data_struct_get_merit(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%merit
  end subroutine


  subroutine tao_data_struct_set_merit(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_merit')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%merit = value_in
  end subroutine

  ! tao_data_struct%s: 0D_NOT_real

  subroutine tao_data_struct_get_s(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s
  end subroutine


  subroutine tao_data_struct_set_s(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_s')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s = value_in
  end subroutine

  ! tao_data_struct%s_offset: 0D_NOT_real

  subroutine tao_data_struct_get_s_offset(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_s_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%s_offset
  end subroutine


  subroutine tao_data_struct_set_s_offset(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_s_offset')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%s_offset = value_in
  end subroutine

  ! tao_data_struct%err_message_printed: 0D_NOT_logical

  subroutine tao_data_struct_get_err_message_printed(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_err_message_printed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%err_message_printed
  end subroutine


  subroutine tao_data_struct_set_err_message_printed(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_err_message_printed')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%err_message_printed = value_in
  end subroutine

  ! tao_data_struct%exists: 0D_NOT_logical

  subroutine tao_data_struct_get_exists(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_exists')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%exists
  end subroutine


  subroutine tao_data_struct_set_exists(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_exists')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%exists = value_in
  end subroutine

  ! tao_data_struct%good_model: 0D_NOT_logical

  subroutine tao_data_struct_get_good_model(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_model
  end subroutine


  subroutine tao_data_struct_set_good_model(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_model = value_in
  end subroutine

  ! tao_data_struct%good_base: 0D_NOT_logical

  subroutine tao_data_struct_get_good_base(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_base
  end subroutine


  subroutine tao_data_struct_set_good_base(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_base = value_in
  end subroutine

  ! tao_data_struct%good_design: 0D_NOT_logical

  subroutine tao_data_struct_get_good_design(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_design
  end subroutine


  subroutine tao_data_struct_set_good_design(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_design = value_in
  end subroutine

  ! tao_data_struct%good_meas: 0D_NOT_logical

  subroutine tao_data_struct_get_good_meas(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_meas
  end subroutine


  subroutine tao_data_struct_set_good_meas(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_meas = value_in
  end subroutine

  ! tao_data_struct%good_ref: 0D_NOT_logical

  subroutine tao_data_struct_get_good_ref(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_ref
  end subroutine


  subroutine tao_data_struct_set_good_ref(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_ref = value_in
  end subroutine

  ! tao_data_struct%good_user: 0D_NOT_logical

  subroutine tao_data_struct_get_good_user(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_user
  end subroutine


  subroutine tao_data_struct_set_good_user(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_user')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_user = value_in
  end subroutine

  ! tao_data_struct%good_opt: 0D_NOT_logical

  subroutine tao_data_struct_get_good_opt(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_opt
  end subroutine


  subroutine tao_data_struct_set_good_opt(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_opt = value_in
  end subroutine

  ! tao_data_struct%good_plot: 0D_NOT_logical

  subroutine tao_data_struct_get_good_plot(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_good_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%good_plot
  end subroutine


  subroutine tao_data_struct_set_good_plot(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_good_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%good_plot = value_in
  end subroutine

  ! tao_data_struct%useit_plot: 0D_NOT_logical

  subroutine tao_data_struct_get_useit_plot(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_useit_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%useit_plot
  end subroutine


  subroutine tao_data_struct_set_useit_plot(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_useit_plot')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%useit_plot = value_in
  end subroutine

  ! tao_data_struct%useit_opt: 0D_NOT_logical

  subroutine tao_data_struct_get_useit_opt(struct_obj_ptr, value_out) bind(c, name='tao_data_struct_get_useit_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%useit_opt
  end subroutine


  subroutine tao_data_struct_set_useit_opt(struct_obj_ptr, value_in) bind(c, name='tao_data_struct_set_useit_opt')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%useit_opt = value_in
  end subroutine

  ! tao_data_struct%spin_map: 0D_NOT_type

  subroutine tao_data_struct_get_spin_map(struct_obj_ptr, ptr_out) bind(c, name='tao_data_struct_get_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spin_map)
  end subroutine


  subroutine tao_data_struct_set_spin_map(struct_obj_ptr, src_ptr) bind(c, name='tao_data_struct_set_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_data_struct), pointer :: struct_obj
    type(tao_spin_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spin_map = src_obj
  end subroutine

  ! tao_data_struct%d1: 0D_PTR_type

  subroutine tao_data_struct_get_d1(struct_obj_ptr, ptr_out) bind(c, name='tao_data_struct_get_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_data_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d1)) then
      ptr_out = c_loc(struct_obj%d1)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_data_struct_set_d1(struct_obj_ptr, src_ptr) bind(c, name='tao_data_struct_set_d1')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_data_struct), pointer :: struct_obj
    type(tao_d1_data_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%d1)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%d1 = src_obj
    endif
  end subroutine

  !! tao_ping_scale_struct

    function allocate_fortran_tao_ping_scale_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_ping_scale_struct), pointer :: fptr
    type(tao_ping_scale_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_ping_scale_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_ping_scale_struct), pointer :: fptr
    type(tao_ping_scale_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_ping_scale_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_ping_scale_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_ping_scale_struct%a_mode_meas: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_a_mode_meas(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_a_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_mode_meas
  end subroutine


  subroutine tao_ping_scale_struct_set_a_mode_meas(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_a_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_mode_meas = value_in
  end subroutine

  ! tao_ping_scale_struct%a_mode_ref: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_a_mode_ref(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_a_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%a_mode_ref
  end subroutine


  subroutine tao_ping_scale_struct_set_a_mode_ref(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_a_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%a_mode_ref = value_in
  end subroutine

  ! tao_ping_scale_struct%b_mode_meas: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_b_mode_meas(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_b_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_mode_meas
  end subroutine


  subroutine tao_ping_scale_struct_set_b_mode_meas(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_b_mode_meas')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_mode_meas = value_in
  end subroutine

  ! tao_ping_scale_struct%b_mode_ref: 0D_NOT_real

  subroutine tao_ping_scale_struct_get_b_mode_ref(struct_obj_ptr, value_out) bind(c, name='tao_ping_scale_struct_get_b_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(out) :: value_out
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%b_mode_ref
  end subroutine


  subroutine tao_ping_scale_struct_set_b_mode_ref(struct_obj_ptr, value_in) bind(c, name='tao_ping_scale_struct_set_b_mode_ref')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    real(c_double), intent(in), value :: value_in
    type(tao_ping_scale_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%b_mode_ref = value_in
  end subroutine

  !! tao_universe_calc_struct

    function allocate_fortran_tao_universe_calc_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_universe_calc_struct), pointer :: fptr
    type(tao_universe_calc_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_universe_calc_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_universe_calc_struct), pointer :: fptr
    type(tao_universe_calc_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_universe_calc_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_universe_calc_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_universe_calc_struct%srdt_for_data: 0D_NOT_integer

  subroutine tao_universe_calc_struct_get_srdt_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_srdt_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%srdt_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_srdt_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_srdt_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%srdt_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%rad_int_for_data: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_rad_int_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_rad_int_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_rad_int_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_rad_int_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%rad_int_for_plotting: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_rad_int_for_plotting(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_rad_int_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%rad_int_for_plotting
  end subroutine


  subroutine tao_universe_calc_struct_set_rad_int_for_plotting(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_rad_int_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%rad_int_for_plotting = value_in
  end subroutine

  ! tao_universe_calc_struct%chrom_for_data: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_chrom_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_chrom_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_chrom_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_chrom_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%chrom_for_plotting: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_chrom_for_plotting(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_chrom_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%chrom_for_plotting
  end subroutine


  subroutine tao_universe_calc_struct_set_chrom_for_plotting(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_chrom_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%chrom_for_plotting = value_in
  end subroutine

  ! tao_universe_calc_struct%lat_sigma_for_data: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_lat_sigma_for_data(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_lat_sigma_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lat_sigma_for_data
  end subroutine


  subroutine tao_universe_calc_struct_set_lat_sigma_for_data(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_lat_sigma_for_data')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lat_sigma_for_data = value_in
  end subroutine

  ! tao_universe_calc_struct%lat_sigma_for_plotting: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_lat_sigma_for_plotting(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_lat_sigma_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lat_sigma_for_plotting
  end subroutine


  subroutine tao_universe_calc_struct_set_lat_sigma_for_plotting(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_lat_sigma_for_plotting')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lat_sigma_for_plotting = value_in
  end subroutine

  ! tao_universe_calc_struct%dynamic_aperture: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_dynamic_aperture(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%dynamic_aperture
  end subroutine


  subroutine tao_universe_calc_struct_set_dynamic_aperture(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%dynamic_aperture = value_in
  end subroutine

  ! tao_universe_calc_struct%one_turn_map: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_one_turn_map(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_one_turn_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%one_turn_map
  end subroutine


  subroutine tao_universe_calc_struct_set_one_turn_map(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_one_turn_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%one_turn_map = value_in
  end subroutine

  ! tao_universe_calc_struct%lattice: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_lattice(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%lattice
  end subroutine


  subroutine tao_universe_calc_struct_set_lattice(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_lattice')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%lattice = value_in
  end subroutine

  ! tao_universe_calc_struct%twiss: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_twiss(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%twiss
  end subroutine


  subroutine tao_universe_calc_struct_set_twiss(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_twiss')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%twiss = value_in
  end subroutine

  ! tao_universe_calc_struct%track: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_track(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%track
  end subroutine


  subroutine tao_universe_calc_struct_set_track(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_track')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%track = value_in
  end subroutine

  ! tao_universe_calc_struct%spin_matrices: 0D_NOT_logical

  subroutine tao_universe_calc_struct_get_spin_matrices(struct_obj_ptr, value_out) bind(c, name='tao_universe_calc_struct_get_spin_matrices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%spin_matrices
  end subroutine


  subroutine tao_universe_calc_struct_set_spin_matrices(struct_obj_ptr, value_in) bind(c, name='tao_universe_calc_struct_set_spin_matrices')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_calc_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%spin_matrices = value_in
  end subroutine

  !! lat_ele_order_struct

    function allocate_fortran_lat_ele_order_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(lat_ele_order_struct), pointer :: fptr
    type(lat_ele_order_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_lat_ele_order_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(lat_ele_order_struct), pointer :: fptr
    type(lat_ele_order_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_lat_ele_order_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(lat_ele_order_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! lat_ele_order_struct%branch: 1D_ALLOC_type

  subroutine lat_ele_order_struct_get_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='lat_ele_order_struct_get_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(lat_ele_order_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%branch) .and. is_contiguous(struct_obj%branch)) then
      data_ptr = c_loc(struct_obj%branch(lbound(struct_obj%branch, 1)))
      bounds(1) = int(lbound(struct_obj%branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  !! tao_universe_struct

    function allocate_fortran_tao_universe_struct(n, element_size) result(ptr) bind(c)
    implicit none
    integer(c_int), value :: n
    integer(c_size_t), intent(out) :: element_size
    type(c_ptr) :: ptr
    type(tao_universe_struct), pointer :: fptr
    type(tao_universe_struct), pointer :: fptr_array(:)

    if (n <= 0) then
        allocate(fptr)
        ptr = c_loc(fptr)
        element_size = int(storage_size(fptr) / 8, c_size_t)
    else
        allocate(fptr_array(n))
        ptr = c_loc(fptr_array)
        element_size = int(storage_size(fptr_array(1)) / 8, c_size_t)
    end if
    end function

    subroutine deallocate_fortran_tao_universe_struct(ptr, n) bind(c)
    implicit none
    type(c_ptr), value :: ptr
    integer(c_int), value :: n
    type(tao_universe_struct), pointer :: fptr
    type(tao_universe_struct), pointer :: fptr_array(:)

    if (c_associated(ptr)) then
        if (n <= 0) then
        call c_f_pointer(ptr, fptr)
        deallocate(fptr)
        else
        call c_f_pointer(ptr, fptr_array, [n])
        deallocate(fptr_array)
        end if
    end if
    end subroutine

  subroutine copy_fortran_tao_universe_struct(src_ptr, dst_ptr) bind(c)
    implicit none
    type(c_ptr), value :: src_ptr, dst_ptr
    type(tao_universe_struct), pointer :: src, dst

    if (c_associated(src_ptr) .and. c_associated(dst_ptr)) then
      call c_f_pointer(src_ptr, src)
      call c_f_pointer(dst_ptr, dst)
      dst = src  ! Fortran derived type assignment
    end if
  end subroutine

        
  ! tao_universe_struct%model: 0D_PTR_type

  subroutine tao_universe_struct_get_model(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model)) then
      ptr_out = c_loc(struct_obj%model)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_struct_set_model(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_model')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%model)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%model = src_obj
    endif
  end subroutine

  ! tao_universe_struct%design: 0D_PTR_type

  subroutine tao_universe_struct_get_design(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%design)) then
      ptr_out = c_loc(struct_obj%design)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_struct_set_design(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_design')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%design)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%design = src_obj
    endif
  end subroutine

  ! tao_universe_struct%base: 0D_PTR_type

  subroutine tao_universe_struct_get_base(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base)) then
      ptr_out = c_loc(struct_obj%base)
    else
      ptr_out = c_null_ptr
    endif
  end subroutine


  subroutine tao_universe_struct_set_base(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_base')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_lattice_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    if (associated(struct_obj%base)) then
      call c_f_pointer(src_ptr, src_obj)
      struct_obj%base = src_obj
    endif
  end subroutine

  ! tao_universe_struct%beam: 0D_NOT_type

  subroutine tao_universe_struct_get_beam(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%beam)
  end subroutine


  subroutine tao_universe_struct_set_beam(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_beam')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_beam_uni_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%beam = src_obj
  end subroutine

  ! tao_universe_struct%dynamic_aperture: 0D_NOT_type

  subroutine tao_universe_struct_get_dynamic_aperture(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%dynamic_aperture)
  end subroutine


  subroutine tao_universe_struct_set_dynamic_aperture(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_dynamic_aperture')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_dynamic_aperture_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%dynamic_aperture = src_obj
  end subroutine

  ! tao_universe_struct%model_branch: 1D_PTR_type

  subroutine tao_universe_struct_get_model_branch_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_universe_struct_get_model_branch_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (associated(struct_obj%model_branch) .and. is_contiguous(struct_obj%model_branch)) then
      data_ptr = c_loc(struct_obj%model_branch(lbound(struct_obj%model_branch, 1)))
      bounds(1) = int(lbound(struct_obj%model_branch, 1), c_int)
      bounds(2) = int(ubound(struct_obj%model_branch, 1), c_int)
      
      el_size = int(storage_size(struct_obj%model_branch(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%d2_data: 1D_ALLOC_type

  subroutine tao_universe_struct_get_d2_data_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_universe_struct_get_d2_data_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%d2_data) .and. is_contiguous(struct_obj%d2_data)) then
      data_ptr = c_loc(struct_obj%d2_data(lbound(struct_obj%d2_data, 1)))
      bounds(1) = int(lbound(struct_obj%d2_data, 1), c_int)
      bounds(2) = int(ubound(struct_obj%d2_data, 1), c_int)
      
      el_size = int(storage_size(struct_obj%d2_data(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%data: 1D_ALLOC_type

  subroutine tao_universe_struct_get_data_info(struct_obj_ptr, data_ptr, bounds, is_allocated, el_size) &
        bind(c, name='tao_universe_struct_get_data_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(2), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_size_t), intent(out) :: el_size
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%data) .and. is_contiguous(struct_obj%data)) then
      data_ptr = c_loc(struct_obj%data(lbound(struct_obj%data, 1)))
      bounds(1) = int(lbound(struct_obj%data, 1), c_int)
      bounds(2) = int(ubound(struct_obj%data, 1), c_int)
      
      el_size = int(storage_size(struct_obj%data(bounds(1))) / 8, c_size_t)
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      el_size = 0
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%ping_scale: 0D_NOT_type

  subroutine tao_universe_struct_get_ping_scale(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_ping_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ping_scale)
  end subroutine


  subroutine tao_universe_struct_set_ping_scale(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_ping_scale')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_ping_scale_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ping_scale = src_obj
  end subroutine

  ! tao_universe_struct%scratch_lat: 0D_NOT_type

  subroutine tao_universe_struct_get_scratch_lat(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_scratch_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%scratch_lat)
  end subroutine


  subroutine tao_universe_struct_set_scratch_lat(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_scratch_lat')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(lat_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%scratch_lat = src_obj
  end subroutine

  ! tao_universe_struct%calc: 0D_NOT_type

  subroutine tao_universe_struct_get_calc(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%calc)
  end subroutine


  subroutine tao_universe_struct_set_calc(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_calc')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_universe_calc_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%calc = src_obj
  end subroutine

  ! tao_universe_struct%ele_order: 0D_NOT_type

  subroutine tao_universe_struct_get_ele_order(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_ele_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%ele_order)
  end subroutine


  subroutine tao_universe_struct_set_ele_order(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_ele_order')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(lat_ele_order_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%ele_order = src_obj
  end subroutine

  ! tao_universe_struct%spin_map: 0D_NOT_type

  subroutine tao_universe_struct_get_spin_map(struct_obj_ptr, ptr_out) bind(c, name='tao_universe_struct_get_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: ptr_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    ptr_out = c_loc(struct_obj%spin_map)
  end subroutine


  subroutine tao_universe_struct_set_spin_map(struct_obj_ptr, src_ptr) bind(c, name='tao_universe_struct_set_spin_map')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(in), value :: src_ptr
    type(tao_universe_struct), pointer :: struct_obj
    type(tao_spin_map_struct), pointer :: src_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    call c_f_pointer(src_ptr, src_obj)
    struct_obj%spin_map = src_obj
  end subroutine

  ! tao_universe_struct%dModel_dVar: 2D_ALLOC_real

  subroutine tao_universe_struct_get_dModel_dVar_info(struct_obj_ptr, data_ptr, bounds, strides, is_allocated) &
        bind(c, name='tao_universe_struct_get_dModel_dVar_info')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    type(c_ptr), intent(out) :: data_ptr
    integer(c_int), dimension(4), intent(out) :: bounds
    logical(c_bool), intent(out) :: is_allocated
    type(tao_universe_struct), pointer :: struct_obj
    integer(c_int), dimension(2), intent(out) :: strides
    integer :: d1
    
    call c_f_pointer(struct_obj_ptr, struct_obj)
    
    if (allocated(struct_obj%dModel_dVar) .and. is_contiguous(struct_obj%dModel_dVar)) then
      data_ptr = c_loc(struct_obj%dModel_dVar(lbound(struct_obj%dModel_dVar, 1), lbound(struct_obj%dModel_dVar, 2)))
      bounds(1) = int(lbound(struct_obj%dModel_dVar, 1), c_int)
      bounds(2) = int(ubound(struct_obj%dModel_dVar, 1), c_int)
      bounds(3) = int(lbound(struct_obj%dModel_dVar, 2), c_int)
      bounds(4) = int(ubound(struct_obj%dModel_dVar, 2), c_int)
      strides(1) = 1_c_int
      d1 = bounds(2) - bounds(1) + 1
      strides(2) = d1
      
      is_allocated = .true.
    else
      data_ptr = c_null_ptr
      bounds = 0_c_int
      strides = 0_c_int
      is_allocated = .false.
    endif
  end subroutine

  ! tao_universe_struct%ix_uni: 0D_NOT_integer

  subroutine tao_universe_struct_get_ix_uni(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%ix_uni
  end subroutine


  subroutine tao_universe_struct_set_ix_uni(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_ix_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%ix_uni = value_in
  end subroutine

  ! tao_universe_struct%n_d2_data_used: 0D_NOT_integer

  subroutine tao_universe_struct_get_n_d2_data_used(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_n_d2_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_d2_data_used
  end subroutine


  subroutine tao_universe_struct_set_n_d2_data_used(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_n_d2_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_d2_data_used = value_in
  end subroutine

  ! tao_universe_struct%n_data_used: 0D_NOT_integer

  subroutine tao_universe_struct_get_n_data_used(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_n_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%n_data_used
  end subroutine


  subroutine tao_universe_struct_set_n_data_used(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_n_data_used')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    integer(c_int), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%n_data_used = value_in
  end subroutine

  ! tao_universe_struct%is_on: 0D_NOT_logical

  subroutine tao_universe_struct_get_is_on(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%is_on
  end subroutine


  subroutine tao_universe_struct_set_is_on(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_is_on')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%is_on = value_in
  end subroutine

  ! tao_universe_struct%design_same_as_previous: 0D_NOT_logical

  subroutine tao_universe_struct_get_design_same_as_previous(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_design_same_as_previous')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%design_same_as_previous
  end subroutine


  subroutine tao_universe_struct_set_design_same_as_previous(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_design_same_as_previous')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%design_same_as_previous = value_in
  end subroutine

  ! tao_universe_struct%picked_uni: 0D_NOT_logical

  subroutine tao_universe_struct_get_picked_uni(struct_obj_ptr, value_out) bind(c, name='tao_universe_struct_get_picked_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(out) :: value_out
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    value_out = struct_obj%picked_uni
  end subroutine


  subroutine tao_universe_struct_set_picked_uni(struct_obj_ptr, value_in) bind(c, name='tao_universe_struct_set_picked_uni')
    type(c_ptr), intent(in), value :: struct_obj_ptr
    logical(c_bool), intent(in), value :: value_in
    type(tao_universe_struct), pointer :: struct_obj
    call c_f_pointer(struct_obj_ptr, struct_obj)
    struct_obj%picked_uni = value_in
  end subroutine

end module
